{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6b3f722b222bf35de67fd32f413cd04d", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2114e300bf78e6a821d075094d9015aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-}\r", "-private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\tchar[][] compoundName = typeReference.getTypeName();\r", "-\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\tint size = compoundName.length;\r", "-\tint n = 1;\r", "-\tReferenceBinding superType;\r", "-\r", "-\t// resolve the first name of the compoundName\r", "-\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "-\t} else {\r", "-\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "-\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\tboolean checkVisibility = false;\r", "-\t\tfor (; n < size; n++) {\r", "-\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\t\r", "+\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\t\tchar[][] compoundName = typeReference.getTypeName();\r", "+\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\t\tint size = compoundName.length;\r", "+\t\tint n = 1;\r", "+\t\tReferenceBinding superType;\r", "-\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t// resolve the first name of the compoundName\r", "+\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\t\tsuperType = sourceType;\r", "+\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "+\t\t} else {\r", "+\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "+\t\t\t\t// record package ref\r", "-\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\tcompoundName[0],\r", "-\t\t\tcheckVisibility = true;\r", "-\t\t}\r", "+\t\t\t}\r", "+\t\t\tboolean checkVisibility = false;\r", "+\t\t\tfor (; n < size; n++) {\r", "+\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "+\t\t\t\t\tbreak;\r", "-\t\t// convert to a ReferenceBinding\r", "-\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\t\t\r", "-\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "-\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "-\t\t\tif (enclosingSourceType == null\r", "-\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "-\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "+\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t\t\t\treturn new ProblemReferenceBinding(\r", "+\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t\t\tcheckVisibility = true;\r", "+\t\t\t}\r", "+\r", "+\t\t\t// convert to a ReferenceBinding\r", "+\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\r", "+\t\t\tif (checkVisibility\r", "+\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "+\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "+\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t// at this point we know we have a type but we have to look for cycles\r", "+\t\twhile (true) {\r", "+\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\t\tif (n >= size)\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\t// retrieve the next member type\r", "+\t\t\tchar[] typeName = compoundName[n++];\r", "+\t\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\t\tif (superType == null)\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tif (!superType.isValidBinding()) {\r", "+\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\t\treturn superType;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn superType;\r", "+\t}\r", "-\t// at this point we know we have a type but we have to look for cycles\r", "-\twhile (true) {\r", "-\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\tif (n >= size)\r", "-\t\t\tbreak;\r", "-\r", "-\t\t// retrieve the next member type\r", "-\t\tchar[] typeName = compoundName[n++];\r", "-\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\tif (superType == null)\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tif (!superType.isValidBinding()) {\r", "-\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\treturn superType;\r", "-\t\t}\r", "-\treturn superType;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "be4dab54106baf0339a9ff0db2516648", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-}\r", "-private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\tchar[][] compoundName = typeReference.getTypeName();\r", "-\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\tint size = compoundName.length;\r", "-\tint n = 1;\r", "-\tReferenceBinding superType;\r", "-\r", "-\t// resolve the first name of the compoundName\r", "-\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "-\t} else {\r", "-\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "-\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\tboolean checkVisibility = false;\r", "-\t\tfor (; n < size; n++) {\r", "-\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\t\r", "+\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\t\tchar[][] compoundName = typeReference.getTypeName();\r", "+\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\t\tint size = compoundName.length;\r", "+\t\tint n = 1;\r", "+\t\tReferenceBinding superType;\r", "-\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t// resolve the first name of the compoundName\r", "+\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\t\tsuperType = sourceType;\r", "+\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "+\t\t} else {\r", "+\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "+\t\t\t\t// record package ref\r", "-\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\tcompoundName[0],\r", "-\t\t\tcheckVisibility = true;\r", "-\t\t}\r", "+\t\t\t}\r", "+\t\t\tboolean checkVisibility = false;\r", "+\t\t\tfor (; n < size; n++) {\r", "+\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "+\t\t\t\t\tbreak;\r", "-\t\t// convert to a ReferenceBinding\r", "-\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\t\t\r", "-\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "-\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "-\t\t\tif (enclosingSourceType == null\r", "-\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "-\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "+\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t\t\t\treturn new ProblemReferenceBinding(\r", "+\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t\t\tcheckVisibility = true;\r", "+\t\t\t}\r", "+\r", "+\t\t\t// convert to a ReferenceBinding\r", "+\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\r", "+\t\t\tif (checkVisibility\r", "+\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "+\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "+\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t// at this point we know we have a type but we have to look for cycles\r", "+\t\twhile (true) {\r", "+\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\t\tif (n >= size)\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\t// retrieve the next member type\r", "+\t\t\tchar[] typeName = compoundName[n++];\r", "+\t\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\t\tif (superType == null)\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tif (!superType.isValidBinding()) {\r", "+\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\t\treturn superType;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn superType;\r", "+\t}\r", "-\t// at this point we know we have a type but we have to look for cycles\r", "-\twhile (true) {\r", "-\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\tif (n >= size)\r", "-\t\t\tbreak;\r", "-\r", "-\t\t// retrieve the next member type\r", "-\t\tchar[] typeName = compoundName[n++];\r", "-\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\tif (superType == null)\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tif (!superType.isValidBinding()) {\r", "-\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\treturn superType;\r", "-\t\t}\r", "-\treturn superType;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "befbe43f9776aa47357c207ff5430d01", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-}\r", "-private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\tchar[][] compoundName = typeReference.getTypeName();\r", "-\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\tint size = compoundName.length;\r", "-\tint n = 1;\r", "-\tReferenceBinding superType;\r", "-\r", "-\t// resolve the first name of the compoundName\r", "-\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "-\t} else {\r", "-\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "-\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\tboolean checkVisibility = false;\r", "-\t\tfor (; n < size; n++) {\r", "-\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\t\r", "+\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\t\tchar[][] compoundName = typeReference.getTypeName();\r", "+\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\t\tint size = compoundName.length;\r", "+\t\tint n = 1;\r", "+\t\tReferenceBinding superType;\r", "-\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t// resolve the first name of the compoundName\r", "+\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\t\tsuperType = sourceType;\r", "+\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "+\t\t} else {\r", "+\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "+\t\t\t\t// record package ref\r", "-\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\tcompoundName[0],\r", "-\t\t\tcheckVisibility = true;\r", "-\t\t}\r", "+\t\t\t}\r", "+\t\t\tboolean checkVisibility = false;\r", "+\t\t\tfor (; n < size; n++) {\r", "+\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "+\t\t\t\t\tbreak;\r", "-\t\t// convert to a ReferenceBinding\r", "-\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\t\t\r", "-\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "-\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "-\t\t\tif (enclosingSourceType == null\r", "-\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "-\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "+\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t\t\t\treturn new ProblemReferenceBinding(\r", "+\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t\t\tcheckVisibility = true;\r", "+\t\t\t}\r", "+\r", "+\t\t\t// convert to a ReferenceBinding\r", "+\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\r", "+\t\t\tif (checkVisibility\r", "+\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "+\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "+\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t// at this point we know we have a type but we have to look for cycles\r", "+\t\twhile (true) {\r", "+\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\t\tif (n >= size)\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\t// retrieve the next member type\r", "+\t\t\tchar[] typeName = compoundName[n++];\r", "+\t\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\t\tif (superType == null)\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tif (!superType.isValidBinding()) {\r", "+\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\t\treturn superType;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn superType;\r", "+\t}\r", "-\t// at this point we know we have a type but we have to look for cycles\r", "-\twhile (true) {\r", "-\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\tif (n >= size)\r", "-\t\t\tbreak;\r", "-\r", "-\t\t// retrieve the next member type\r", "-\t\tchar[] typeName = compoundName[n++];\r", "-\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\tif (superType == null)\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tif (!superType.isValidBinding()) {\r", "-\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\treturn superType;\r", "-\t\t}\r", "-\treturn superType;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4f39f4b914401c4094f25f7d6ab931e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-}\r", "-private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\tchar[][] compoundName = typeReference.getTypeName();\r", "-\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\tint size = compoundName.length;\r", "-\tint n = 1;\r", "-\tReferenceBinding superType;\r", "-\r", "-\t// resolve the first name of the compoundName\r", "-\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "-\t} else {\r", "-\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "-\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\tboolean checkVisibility = false;\r", "-\t\tfor (; n < size; n++) {\r", "-\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\t\r", "+\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\t\tchar[][] compoundName = typeReference.getTypeName();\r", "+\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\t\tint size = compoundName.length;\r", "+\t\tint n = 1;\r", "+\t\tReferenceBinding superType;\r", "-\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t// resolve the first name of the compoundName\r", "+\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\t\tsuperType = sourceType;\r", "+\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "+\t\t} else {\r", "+\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "+\t\t\t\t// record package ref\r", "-\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\tcompoundName[0],\r", "-\t\t\tcheckVisibility = true;\r", "-\t\t}\r", "+\t\t\t}\r", "+\t\t\tboolean checkVisibility = false;\r", "+\t\t\tfor (; n < size; n++) {\r", "+\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "+\t\t\t\t\tbreak;\r", "-\t\t// convert to a ReferenceBinding\r", "-\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\t\t\r", "-\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "-\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "-\t\t\tif (enclosingSourceType == null\r", "-\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "-\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "+\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "+\t\t\t\t\treturn new ProblemReferenceBinding(\r", "+\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "+\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t\t\tcheckVisibility = true;\r", "+\t\t\t}\r", "+\r", "+\t\t\t// convert to a ReferenceBinding\r", "+\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\r", "+\t\t\tif (checkVisibility\r", "+\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "+\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "+\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t// at this point we know we have a type but we have to look for cycles\r", "+\t\twhile (true) {\r", "+\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\t\tif (n >= size)\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\t// retrieve the next member type\r", "+\t\t\tchar[] typeName = compoundName[n++];\r", "+\t\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\t\tif (superType == null)\r", "+\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\t\tif (!superType.isValidBinding()) {\r", "+\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\t\treturn superType;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn superType;\r", "+\t}\r", "-\t// at this point we know we have a type but we have to look for cycles\r", "-\twhile (true) {\r", "-\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\tif (n >= size)\r", "-\t\t\tbreak;\r", "-\r", "-\t\t// retrieve the next member type\r", "-\t\tchar[] typeName = compoundName[n++];\r", "-\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\tif (superType == null)\r", "-\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\tif (!superType.isValidBinding()) {\r", "-\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\treturn superType;\r", "-\t\t}\r", "-\treturn superType;\r", "-}\r"]}], "num": 70141}