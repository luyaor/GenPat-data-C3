{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7b67e2558d0f77973ea09c3f7bf4d077", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a5e6647b25a3ddb3793a58494ebeb1be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "607ff419d62fc0f91055d1c2d16685459d9fa667", "commitAfterChange": "0cad9a75d8029433899afbdf88cbb39e8dd0618a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["+\t// methods includes the inherited methods that the currentMethod must comply with", "+\t// likely only 1 but could be more if mutiple declared supertypes define the method (1 superclass & 1 to many declared interfaces)", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "-\t\t\t&& isTypeSubstituable(currentMethod.returnType, inheritedMethod.returnType);", "-\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "+\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType();", "+\t\tif (!super.areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t\t\t// TODO (kent) work to do on this case", "-\t\t\t\tif (currentMethod.typeVariables.length == 0 && inheritedMethod.declaringClass.isRawType()) {", "-\t\t\t\t\t// bug 69626", "-\t\t\t\t\t// no error since the inheritedMethod's type variables are ignored in raw types... why does a raw type binding not remove the type variables?", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-//\t\t\t\t\tthis.problemReporter(currentMethod).nameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t}", "+\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "+//\t\t\t\tthis.problemReporter(currentMethod).nameClash(currentMethod, inheritedMethod);", "+\t\t\t\tcontinue nextMethod;", "+\t\t\taddBridgeMethod = true;", "-\t\t    if (!isReturnTypeSubstituable(original, currentMethod) || !areParametersEqual(original, currentMethod))", "+\t\t    if (!areReturnTypesEqual(original, currentMethod) || !areParametersEqual(original, currentMethod))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4ac68e3f0cc9485da07e71fffd1a68a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\tproblemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "+\t\t\tproblemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "-\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "+\t\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\tcheckForBridgeMethod(currentMethod, inheritedMethod);"]}], "num": 20002}