{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b06a44b8dbf6459118f185a9d5f42f60", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c280940b3a3591b3ec69e1bc26a74ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": "  public TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\tpublic TypeBinding getOtherFieldBindings(BlockScope scope) {", "-\t\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "-\t\tint length = tokens.length;", "-\t\tFieldBinding field;", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tfield = (FieldBinding) this.binding;", "-\t\t\tif (!field.isStatic()) {", "-\t\t\t\t//must check for the static status....", "-\t\t\t\tif (indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "-\t\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "-\t\t\t\t\treturn null;", "-\t\t\t\t }", "-\t\t\t} else {", "+", "+public TypeBinding getOtherFieldBindings(BlockScope scope) {", "+\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "+\tint length = this.tokens.length;", "+\tFieldBinding field;", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tfield = (FieldBinding) this.binding;", "+\t\tif (!field.isStatic()) {", "+\t\t\t//must check for the static status....", "+\t\t\tif (this.indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "+\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "+\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "+\t\t\t\treturn null;", "+\t\t\t }", "+\t\t} else {", "+\t\t\t// indirect static reference ?", "+\t\t\tif (this.indexOfFirstFieldBinding > 1 ", "+\t\t\t\t\t&& field.declaringClass != this.actualReceiverType", "+\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "+\t\t\t}", "+\t\t}", "+\t\t// only last field is actually a write access if any", "+\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) != 0 && this.indexOfFirstFieldBinding == length))", "+\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t} else {", "+\t\tfield = null;", "+\t}", "+\tTypeBinding type = ((VariableBinding) this.binding).type;", "+\tint index = this.indexOfFirstFieldBinding;", "+\tif (index == length) { //\trestrictiveFlag == FIELD", "+\t\tthis.constant = ((FieldBinding) this.binding).constant();", "+\t\t// perform capture conversion if read access", "+\t\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t\t: type;", "+\t}", "+\t// allocation of the fieldBindings array\tand its respective constants", "+\tint otherBindingsLength = length - index;", "+\tthis.otherCodegenBindings = this.otherBindings = new FieldBinding[otherBindingsLength];", "+\tthis.otherDepths = new int[otherBindingsLength];", "+\t", "+\t// fill the first constant (the one of the binding)", "+\tthis.constant = ((VariableBinding) this.binding).constant();", "+\t// save first depth, since will be updated by visibility checks of other bindings", "+\tint firstDepth = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t// iteration on each field\t", "+\twhile (index < length) {", "+\t\tchar[] token = this.tokens[index];", "+\t\tif (type == null)", "+\t\t\treturn null; // could not resolve type prior to this point", "+", "+\t\tthis.bits &= ~ASTNode.DepthMASK; // flush previous depth if any\t\t", "+\t\tFieldBinding previousField = field;", "+\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "+\t\tint place = index - this.indexOfFirstFieldBinding;", "+\t\tthis.otherBindings[place] = field;", "+\t\tthis.otherDepths[place] = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t\tif (field.isValidBinding()) {", "+\t\t\t// set generic cast of for previous field (if any)", "+\t\t\tif (previousField != null) {", "+\t\t\t\tTypeBinding fieldReceiverType = type;", "+\t\t\t\tTypeBinding receiverErasure = type.erasure();", "+\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "+\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t", "+\t\t\t\tFieldBinding originalBinding = previousField.original();", "+\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != TypeIds.T_JavaLangObject) {", "+\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "+\t\t\t    }", "+\t\t    }", "+\t\t\t// only last field is actually a write access if any", "+\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) !=0 && index+1 == length)) {", "+\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\t}", "+\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "+\t\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "+\t\t\t}", "+", "+\t\t\tif (field.isStatic()) {", "+\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "+\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\tif (indexOfFirstFieldBinding > 1 ", "-\t\t\t\t\t\t&& field.declaringClass != actualReceiverType", "-\t\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t// only last field is actually a write access if any", "-\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) != 0 && indexOfFirstFieldBinding == length))", "-\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\ttype = field.type;", "+\t\t\tindex++;", "-\t\t\tfield = null;", "-\t\t}", "-\t\tTypeBinding type = ((VariableBinding) binding).type;", "-\t\tint index = indexOfFirstFieldBinding;", "-\t\tif (index == length) { //\trestrictiveFlag == FIELD", "-\t\t\tthis.constant = ((FieldBinding) binding).constant();", "-\t\t\t// perform capture conversion if read access", "-\t\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t\t: type;", "-\t\t}", "-\t\t// allocation of the fieldBindings array\tand its respective constants", "-\t\tint otherBindingsLength = length - index;", "-\t\totherCodegenBindings = otherBindings = new FieldBinding[otherBindingsLength];", "-\t\totherDepths = new int[otherBindingsLength];", "-\t\t", "-\t\t// fill the first constant (the one of the binding)", "-\t\tthis.constant = ((VariableBinding) binding).constant();", "-\t\t// save first depth, since will be updated by visibility checks of other bindings", "-\t\tint firstDepth = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t// iteration on each field\t", "-\t\twhile (index < length) {", "-\t\t\tchar[] token = tokens[index];", "-\t\t\tif (type == null)", "-\t\t\t\treturn null; // could not resolve type prior to this point", "-", "-\t\t\tbits &= ~DepthMASK; // flush previous depth if any\t\t", "-\t\t\tFieldBinding previousField = field;", "-\t\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "-\t\t\tint place = index - indexOfFirstFieldBinding;", "-\t\t\totherBindings[place] = field;", "-\t\t\totherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t\tif (field.isValidBinding()) {", "-\t\t\t\t// set generic cast of for previous field (if any)", "-\t\t\t\tif (previousField != null) {", "-\t\t\t\t\tTypeBinding fieldReceiverType = type;", "-\t\t\t\t\tTypeBinding receiverErasure = type.erasure();", "-\t\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "-\t\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tFieldBinding originalBinding = previousField.original();", "-\t\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != T_JavaLangObject) {", "-\t\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "-\t\t\t\t    }", "-\t\t\t    }", "-\t\t\t\t// only last field is actually a write access if any", "-\t\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) !=0 && index+1 == length)) {", "-\t\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "-\t\t\t\t}", "-\t\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "-\t\t\t\tif (this.constant != Constant.NotAConstant) {", "-\t\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "-\t\t\t\t}", "-", "-\t\t\t\tif (field.isStatic()) {", "-\t\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "-\t\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\t\t// indirect static reference ?", "-\t\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\ttype = field.type;", "-\t\t\t\tindex++;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant; //don't fill other constants slots...", "-\t\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "-\t\t\t\tsetDepth(firstDepth);", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t}", "-\t\tsetDepth(firstDepth);", "-\t\ttype = (otherBindings[otherBindingsLength - 1]).type;", "-\t\t// perform capture conversion if read access", "-\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t: type;\t\t", "-\t}", "+\t\t\tthis.constant = Constant.NotAConstant; //don't fill other constants slots...", "+\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "+\t\t\tsetDepth(firstDepth);", "+\t\t\treturn null;", "+\tsetDepth(firstDepth);", "+\ttype = (this.otherBindings[otherBindingsLength - 1]).type;", "+\t// perform capture conversion if read access", "+\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t: type;\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "895be80da000500a2a9b3e741645e5da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " protected void consumeBinaryExpression(int op)", "signatureAfterChange": " protected void consumeBinaryExpression(int op)", "diff": ["-\texpressionPtr--;", "-\texpressionLengthPtr--;", "+\tthis.expressionPtr--;", "+\tthis.expressionLengthPtr--;", "-\t\texpressionStack[expressionPtr] = ", "+\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\texpressionStack[expressionPtr], ", "-\t\t\t\texpressionStack[expressionPtr + 1], ", "+\t\t\t\tthis.expressionStack[this.expressionPtr], ", "+\t\t\t\tthis.expressionStack[this.expressionPtr + 1], ", "-\t\t\texpressionStack[expressionPtr] = ", "+\t\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\t\texpressionStack[expressionPtr], ", "-\t\t\t\t\texpressionStack[expressionPtr + 1], ", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr], ", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr + 1], ", "-\t\t\tif ((op == PLUS) && optimizeStringLiterals) {", "+\t\t\tif ((op == PLUS) && this.optimizeStringLiterals) {", "-\t\t\t\texpr1 = expressionStack[expressionPtr];", "-\t\t\t\texpr2 = expressionStack[expressionPtr + 1];", "+\t\t\t\texpr1 = this.expressionStack[this.expressionPtr];", "+\t\t\t\texpr2 = this.expressionStack[this.expressionPtr + 1];", "-\t\t\t\t\t\texpressionStack[expressionPtr] = ", "+\t\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\t\t\texpressionStack[expressionPtr] = ", "+\t\t\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\t\t\texpressionStack[expressionPtr] = new BinaryExpression(expr1, expr2, PLUS);", "+\t\t\t\t\t\tthis.expressionStack[this.expressionPtr] = new BinaryExpression(expr1, expr2, PLUS);", "-\t\t\t\t\texpressionStack[expressionPtr] = new BinaryExpression(expr1, expr2, PLUS);", "+\t\t\t\t\tthis.expressionStack[this.expressionPtr] = new BinaryExpression(expr1, expr2, PLUS);", "-\t\t\t\texpressionStack[expressionPtr] = ", "+\t\t\t\tthis.expressionStack[this.expressionPtr] = ", "-\t\t\t\t\t\texpressionStack[expressionPtr], ", "-\t\t\t\t\t\texpressionStack[expressionPtr + 1], ", "+\t\t\t\t\t\tthis.expressionStack[this.expressionPtr], ", "+\t\t\t\t\t\tthis.expressionStack[this.expressionPtr + 1], "]}], "num": 687}