{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b778f62bdcf282d0cccd056a7e3a69b0", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "825852b5bd15a1b6d6bee35a2b72b3a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "3ff7b81bced83cc6ffeee9cd4ddf361110eeeb98", "commitAfterChange": "25f2a2d3f2ea6a2ed84c0af6dba49f7f2a42eab8", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "\r \r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite,\r \t\tboolean forAnonymousType)", "signatureAfterChange": "\r \r \tprivate void findConstructors(\r \t\tReferenceBinding currentType,\r \t\tTypeBinding[] argTypes,\r \t\tScope scope,\r \t\tInvocationSite invocationSite,\r \t\tboolean forAnonymousType)", "diff": ["-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding constructor = methods[f];\r", "-\t\t\tif (constructor.isConstructor()) {\r", "-\t\t\t\t\r", "-\t\t\t\tif (constructor.isSynthetic()) continue next;\r", "+\t\tif(methods != null) {\r", "+\t\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\t\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\t\t\tMethodBinding constructor = methods[f];\r", "+\t\t\t\tif (constructor.isConstructor()) {\r", "-\t\t\t\tif (options.checkVisibility\r", "-\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope)) continue next;\r", "-\r", "-\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "-\t\t\t\tint paramLength = parameters.length;\r", "-\t\t\t\tif (minArgLength > paramLength)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "-\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "-\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\r", "-\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "-\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "-\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "-\t\t\t\t\tTypeBinding type = parameters[i];\r", "-\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "-\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "-\t\t\t\t}\r", "-\t\t\t\tchar[][] parameterNames = findMethodParameterNames(constructor,parameterTypeNames);\r", "-\t\t\t\t\r", "-\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\t\tif (source == null\r", "-\t\t\t\t\t|| source.length <= endPosition\r", "-\t\t\t\t\t|| source[endPosition] != ')')\r", "-\t\t\t\t\tcompletion = new char[] { ')' };\r", "-\t\t\t\t\r", "-\t\t\t\tint relevance = DEFAULTRELEVANCE;\r", "-\t\t\t\t\r", "-\t\t\t\tif(forAnonymousType){\r", "-\t\t\t\t\trequestor.acceptAnonymousType(\r", "-\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\t\t\tparameterPackageNames,\r", "-\t\t\t\t\t\tparameterTypeNames,\r", "-\t\t\t\t\t\tparameterNames,\r", "-\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\trelevance);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\trequestor.acceptMethod(\r", "-\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "-\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "-\t\t\t\t\t\tcurrentType.sourceName(),\r", "-\t\t\t\t\t\tparameterPackageNames,\r", "-\t\t\t\t\t\tparameterTypeNames,\r", "-\t\t\t\t\t\tparameterNames,\r", "-\t\t\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\t\t\tTypeConstants.NoChar,\r", "-\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t\tconstructor.modifiers,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\tendPosition - offset,\r", "-\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\tif (constructor.isSynthetic()) continue next;\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\tif (options.checkVisibility\r", "+\t\t\t\t\t\t&& !constructor.canBeSeenBy(invocationSite, scope)) continue next;\r", "+\t\r", "+\t\t\t\t\tTypeBinding[] parameters = constructor.parameters;\r", "+\t\t\t\t\tint paramLength = parameters.length;\r", "+\t\t\t\t\tif (minArgLength > paramLength)\r", "+\t\t\t\t\t\tcontinue next;\r", "+\t\t\t\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\t\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))\r", "+\t\t\t\t\t\t\t\tcontinue next;\r", "+\t\r", "+\t\t\t\t\tchar[][] parameterPackageNames = new char[paramLength][];\r", "+\t\t\t\t\tchar[][] parameterTypeNames = new char[paramLength][];\r", "+\t\t\t\t\tfor (int i = 0; i < paramLength; i++) {\r", "+\t\t\t\t\t\tTypeBinding type = parameters[i];\r", "+\t\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tchar[][] parameterNames = findMethodParameterNames(constructor,parameterTypeNames);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tchar[] completion = TypeConstants.NoChar;\r", "+\t\t\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\t\t\t\tif (source == null\r", "+\t\t\t\t\t\t|| source.length <= endPosition\r", "+\t\t\t\t\t\t|| source[endPosition] != ')')\r", "+\t\t\t\t\t\tcompletion = new char[] { ')' };\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tint relevance = DEFAULTRELEVANCE;\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif(forAnonymousType){\r", "+\t\t\t\t\t\trequestor.acceptAnonymousType(\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\t\t\tparameterNames,\r", "+\t\t\t\t\t\t\tcompletion,\r", "+\t\t\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\trequestor.acceptMethod(\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedPackageName(),\r", "+\t\t\t\t\t\t\tcurrentType.qualifiedSourceName(),\r", "+\t\t\t\t\t\t\tcurrentType.sourceName(),\r", "+\t\t\t\t\t\t\tparameterPackageNames,\r", "+\t\t\t\t\t\t\tparameterTypeNames,\r", "+\t\t\t\t\t\t\tparameterNames,\r", "+\t\t\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\t\t\tTypeConstants.NoChar,\r", "+\t\t\t\t\t\t\tcompletion,\r", "+\t\t\t\t\t\t\tconstructor.modifiers,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\tendPosition - offset,\r", "+\t\t\t\t\t\t\trelevance);\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab3fc3cc9aac4e83aa3235d93939e6e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "1248181e23c81da45ee8e328a409b761a39e6e52", "commitAfterChange": "3df0b6d0a7c9e742ebbc5f2930d09070fa613a77", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames, int dim)", "signatureAfterChange": " \tprivate void findVariableName( \t\tchar[] token, \t\tchar[] qualifiedPackageName, \t\tchar[] qualifiedSourceName, \t\tchar[] sourceName, \t\tchar[][] excludeNames, \t\tint dim, \t\tint kind, \t\tint modifiers)", "diff": ["-\t// Helper method for private void findVariableNames(char[] name, TypeReference type )", "-\tprivate void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames, int dim){", "-\t\t\tif(sourceName == null || sourceName.length == 0)", "-\t\t\t\treturn;", "-\t\t\t\t", "-\t\t\tchar[] name = null;", "+\t\t// Helper method for private void findVariableNames(char[] name, TypeReference type )", "+\tprivate void findVariableName(", "+\t\tchar[] token,", "+\t\tchar[] qualifiedPackageName,", "+\t\tchar[] qualifiedSourceName,", "+\t\tchar[] sourceName,", "+\t\tchar[][] excludeNames,", "+\t\tint dim,", "+\t\tint kind,", "+\t\tint modifiers){", "-\t\t\t// compute variable name for base type", "-\t\t\ttry{", "-\t\t\t\tnameScanner.setSource(sourceName);", "-\t\t\t\tswitch (nameScanner.getNextToken()) {", "-\t\t\t\t\tcase TokenNameint :", "-\t\t\t\t\tcase TokenNamebyte :", "-\t\t\t\t\tcase TokenNameshort :", "-\t\t\t\t\tcase TokenNamechar :", "-\t\t\t\t\tcase TokenNamelong :", "-\t\t\t\t\tcase TokenNamefloat :", "-\t\t\t\t\tcase TokenNamedouble :", "-\t\t\t\t\tcase TokenNameboolean :", "-\t\t\t\t\t\tif(token != null && token.length != 0)", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\tname = computeBaseNames(sourceName[0], excludeNames);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tif(name != null) {", "-\t\t\t\t\tint relevance = computeBaseRelevance();", "-\t\t\t\t\trelevance += computeRelevanceForInterestingProposal();", "-\t\t\t\t\trelevance += computeRelevanceForCaseMatching(token, name);", "-\t\t\t\t\t", "-\t\t\t\t\t// accept result", "-\t\t\t\t\trequestor.acceptVariableName(", "-\t\t\t\t\t\tqualifiedPackageName,", "-\t\t\t\t\t\tqualifiedSourceName,", "-\t\t\t\t\t\tname,", "-\t\t\t\t\t\tname,", "-\t\t\t\t\t\tstartPosition - offset,", "-\t\t\t\t\t\tendPosition - offset,", "-\t\t\t\t\t\trelevance);", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t} catch(InvalidInputException e){", "-\t\t\t}", "-\t\t\t", "-\t\t\t// compute variable name for non base type", "-\t\t\tchar[][] names = computeNames(sourceName, dim > 0);", "-\t\t\tchar[] displayName;", "-\t\t\tif (dim > 0){", "-\t\t\t\tint l = qualifiedSourceName.length;", "-\t\t\t\tdisplayName = new char[l+(2*dim)];", "-\t\t\t\tSystem.arraycopy(qualifiedSourceName, 0, displayName, 0, l);", "-\t\t\t\tfor(int i = 0; i < dim; i++){", "-\t\t\t\t\tdisplayName[l+(i*2)] = '[';", "-\t\t\t\t\tdisplayName[l+(i*2)+1] = ']';", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tdisplayName = qualifiedSourceName;", "-\t\t\t}", "-\t\t\tnext : for(int i = 0 ; i < names.length ; i++){", "-\t\t\t\tname = names[i];", "-\t\t\t\t", "-\t\t\t\tif (!CharOperation.prefixEquals(token, name, false))", "-\t\t\t\t\tcontinue next;", "-\t\t\t\t", "-\t\t\t\t// completion must be an identifier (not a keyword, ...).", "-\t\t\t\ttry{", "-\t\t\t\t\tnameScanner.setSource(name);", "-\t\t\t\t\tif(nameScanner.getNextToken() != TokenNameIdentifier)", "-\t\t\t\t\t\tcontinue next;", "-\t\t\t\t} catch(InvalidInputException e){", "-\t\t\t\t\tcontinue next;", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tint count = 2;", "-\t\t\t\tchar[] originalName = name;", "-\t\t\t\tfor(int j = 0 ; j < excludeNames.length ; j++){", "-\t\t\t\t\tif(CharOperation.equals(name, excludeNames[j], false)) {", "-\t\t\t\t\t\tname = CharOperation.concat(originalName, String.valueOf(count++).toCharArray());", "-\t\t\t\t\t\tj = 0;", "-\t\t\t\t\t}\t", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tint relevance = computeBaseRelevance();", "-\t\t\t\trelevance += computeRelevanceForInterestingProposal();", "-\t\t\t\trelevance += computeRelevanceForCaseMatching(token, name);", "-\t\t\t\t", "-\t\t\t\t// accept result", "-\t\t\t\trequestor.acceptVariableName(", "+\t\tif(sourceName == null || sourceName.length == 0)", "+\t\t\treturn;", "+\t\t", "+\t\tchar[][] names = CharOperation.NO_CHAR_CHAR;", "+\t\tswitch (kind) {", "+\t\t\tcase FIELD :", "+\t\t\t\tnames = NameComputer.suggestFieldNames(", "+\t\t\t\t\tjavaProject,", "-\t\t\t\t\tdisplayName,", "-\t\t\t\t\tname,", "-\t\t\t\t\tname,", "-\t\t\t\t\tstartPosition - offset,", "-\t\t\t\t\tendPosition - offset,", "-\t\t\t\t\trelevance);", "-\t\t\t}", "-\t}", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tdim,", "+\t\t\t\t\tmodifiers,", "+\t\t\t\t\texcludeNames);", "+\t\t\t\tbreak;", "+\t\t\tcase LOCAL :", "+\t\t\t\tnames = NameComputer.suggestLocalVariableNames(", "+\t\t\t\t\tjavaProject,", "+\t\t\t\t\tqualifiedPackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tdim,", "+\t\t\t\t\texcludeNames);", "+\t\t\t\tbreak;", "+\t\t\tcase ARGUMENT :", "+\t\t\t\tnames = NameComputer.suggestArgumentNames(", "+\t\t\t\t\tjavaProject,", "+\t\t\t\t\tqualifiedPackageName,", "+\t\t\t\t\tqualifiedSourceName,", "+\t\t\t\t\tdim,", "+\t\t\t\t\texcludeNames);", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t// compute variable name for non base type", "+\t\tchar[] displayName;", "+\t\tif (dim > 0){", "+\t\t\tint l = qualifiedSourceName.length;", "+\t\t\tdisplayName = new char[l+(2*dim)];", "+\t\t\tSystem.arraycopy(qualifiedSourceName, 0, displayName, 0, l);", "+\t\t\tfor(int i = 0; i < dim; i++){", "+\t\t\t\tdisplayName[l+(i*2)] = '[';", "+\t\t\t\tdisplayName[l+(i*2)+1] = ']';", "+\t\t\t}", "+\t\t} else {", "+\t\t\tdisplayName = qualifiedSourceName;", "+\t\t}", "+\t\t", "+\t\tnext : for(int i = 0 ; i < names.length ; i++){", "+\t\t\tchar[] name = names[i];", "+\t\t", "+\t\t\tif (!CharOperation.prefixEquals(token, name, false))", "+\t\t\t\tcontinue next;", "+\t\t\t", "+\t\t\tint relevance = computeBaseRelevance();", "+\t\t\trelevance += computeRelevanceForInterestingProposal();", "+\t\t\trelevance += computeRelevanceForCaseMatching(token, name);", "+\t\t\t", "+\t\t\t// accept result", "+\t\t\trequestor.acceptVariableName(", "+\t\t\t\tqualifiedPackageName,", "+\t\t\t\tdisplayName,", "+\t\t\t\tname,", "+\t\t\t\tname,", "+\t\t\t\tstartPosition - offset,", "+\t\t\t\tendPosition - offset,", "+\t\t\t\trelevance);", "+\t\t}", "+\t\t", "+\t}"]}], "num": 15149}