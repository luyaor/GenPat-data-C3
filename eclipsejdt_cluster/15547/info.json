{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dd82b810e95406ec73870f10242198a5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59efd68e0855729bec8becba7c1b043d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tpublic void analyseCode( \t\tClassScope classScope, \t\tInitializationFlowContext initializerFlowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["+ */", "+public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode) {", "+\tif (this.ignoreFurtherInvestigation)", "+\t\treturn;", "+", "+\tint nonStaticFieldInfoReachMode = flowInfo.reachMode();", "+\tflowInfo.setReachMode(initialReachMode);", "-\tpublic void analyseCode(", "-\t\tClassScope classScope,", "-\t\tInitializationFlowContext initializerFlowContext,", "-\t\tFlowInfo flowInfo) {", "+\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "+\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "+\t\t\tthis.scope.problemReporter().unusedPrivateConstructor(this);", "+\t\t}", "+\t}", "+\t\t", "+\t// check constructor recursion, once all constructor got resolved", "+\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "+\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "+\t}", "+\t\t", "+\ttry {", "+\t\tExceptionHandlingFlowContext constructorContext =", "+\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\tinitializerFlowContext.parent,", "+\t\t\t\tthis,", "+\t\t\t\tthis.binding.thrownExceptions,", "+\t\t\t\tthis.scope,", "+\t\t\t\tFlowInfo.DEAD_END);", "+\t\tinitializerFlowContext.checkInitializerExceptions(", "+\t\t\tthis.scope,", "+\t\t\tconstructorContext,", "+\t\t\tflowInfo);", "-\t\tif (ignoreFurtherInvestigation)", "-\t\t\treturn;", "-", "-\t\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "-\t\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateConstructor(this);", "+\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "+\t\tif (this.binding.declaringClass.isAnonymousType()) {", "+\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "+\t\t\tif (computedExceptions != null){", "+\t\t\t\tint size;", "+\t\t\t\tif ((size = computedExceptions.size()) > 0){", "+\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "+\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "+\t\t\t\t\tthis.binding.thrownExceptions = actuallyThrownExceptions;", "+\t\t\t\t}", "-\t\t\t", "-\t\t// check constructor recursion, once all constructor got resolved", "-\t\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "-\t\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "+\t\t", "+\t\t// tag parameters as being set", "+\t\tif (this.arguments != null) {", "+\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "+\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "+\t\t\t}", "-\t\t\t", "-\t\ttry {", "-\t\t\tExceptionHandlingFlowContext constructorContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tinitializerFlowContext.parent,", "-\t\t\t\t\tthis,", "-\t\t\t\t\tbinding.thrownExceptions,", "-\t\t\t\t\tscope,", "-\t\t\t\t\tFlowInfo.DEAD_END);", "-\t\t\tinitializerFlowContext.checkInitializerExceptions(", "-\t\t\t\tscope,", "-\t\t\t\tconstructorContext,", "-\t\t\t\tflowInfo);", "-", "-\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "-\t\t\tif (binding.declaringClass.isAnonymousType()) {", "-\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "-\t\t\t\tif (computedExceptions != null){", "-\t\t\t\t\tint size;", "-\t\t\t\t\tif ((size = computedExceptions.size()) > 0){", "-\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "-\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "-\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// tag parameters as being set", "-\t\t\tif (this.arguments != null) {", "-\t\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "-\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// propagate to constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "-\t\t\t\t// set since they are supposed to be set inside other local constructor", "-\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {", "-\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\t\tFieldBinding field;", "-\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t}", "-\t\t\t// propagate to statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tboolean didAlreadyComplain = false;", "-\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {", "-\t\t\t\t\tStatement stat = statements[i];", "-\t\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, scope, didAlreadyComplain)) {", "-\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tdidAlreadyComplain = true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// check for missing returning path", "-\t\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-", "-", "-\t\t\t// check missing blank final field initializations", "-\t\t\tif ((constructorCall != null)", "-\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {", "-\t\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "+\t\t", "+\t\t// propagate to constructor call", "+\t\tif (this.constructorCall != null) {", "+\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "+\t\t\t// set since they are supposed to be set inside other local constructor", "+\t\t\tif (this.constructorCall.accessMode == ExplicitConstructorCall.This) {", "+\t\t\t\tFieldBinding[] fields = this.binding.declaringClass.fields();", "-\t\t\t\t\tif ((!(field = fields[i]).isStatic())", "-\t\t\t\t\t\t&& field.isFinal()", "-\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "-\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\t\tfield,", "-\t\t\t\t\t\t\tisDefaultConstructor ? (ASTNode) scope.referenceType() : this);", "+\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "+\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t// check unreachable catch blocks", "-\t\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "-\t\t} catch (AbortMethod e) {", "-\t\t\tthis.ignoreFurtherInvestigation = true;", "+\t\t\tflowInfo = this.constructorCall.analyseCode(this.scope, constructorContext, flowInfo);", "-\t}", "+\t\t// reuse the reachMode from non static field info", "+\t\tflowInfo.setReachMode(nonStaticFieldInfoReachMode);", "+", "+\t\t// propagate to statements", "+\t\tif (this.statements != null) {", "+\t\t\tboolean didAlreadyComplain = false;", "+\t\t\tfor (int i = 0, count = this.statements.length; i < count; i++) {", "+\t\t\t\tStatement stat = this.statements[i];", "+\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, this.scope, didAlreadyComplain)) {", "+\t\t\t\t\tflowInfo = stat.analyseCode(this.scope, constructorContext, flowInfo);", "+\t\t\t\t} else {", "+\t\t\t\t\tdidAlreadyComplain = true;", "+\t\t\t}", "+\t\t}", "+\t\t// check for missing returning path", "+\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "+", "+\t\t// reuse the initial reach mode for diagnosing missing blank finals", "+\t\tflowInfo.setReachMode(initialReachMode);\t\t", "+", "+\t\t// check missing blank final field initializations", "+\t\tif ((this.constructorCall != null)", "+\t\t\t&& (this.constructorCall.accessMode != ExplicitConstructorCall.This)) {", "+\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "+\t\t\tFieldBinding[] fields = this.binding.declaringClass.fields();", "+\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "+\t\t\t\tFieldBinding field;", "+\t\t\t\tif ((!(field = fields[i]).isStatic())", "+\t\t\t\t\t&& field.isFinal()", "+\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "+\t\t\t\t\tthis.scope.problemReporter().uninitializedBlankFinalField(", "+\t\t\t\t\t\tfield,", "+\t\t\t\t\t\tthis.isDefaultConstructor ? (ASTNode) this.scope.referenceType() : this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// check unreachable catch blocks", "+\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "+\t} catch (AbortMethod e) {", "+\t\tthis.ignoreFurtherInvestigation = true;", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1829b6de2a9c7f4a1fc0f94a1332b24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 49, "signatureBeforeChange": " public String toString()", "signatureAfterChange": " public String toString()", "diff": ["-    if (id == TypeIds.NoId) ", "+    if (this.id == TypeIds.NoId) ", "-        buffer.append(id);", "+        buffer.append(this.id);", "-\tbuffer.append((compoundName != null) ? CharOperation.toString(compoundName) : \"UNNAMED TYPE\"); //$NON-NLS-1$", "+\tbuffer.append((this.compoundName != null) ? CharOperation.toString(this.compoundName) : \"UNNAMED TYPE\"); //$NON-NLS-1$", "-\tbuffer.append((superclass != null) ? superclass.debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "+\tbuffer.append((this.superclass != null) ? this.superclass.debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "-\tif (superInterfaces != null) {", "-\t\tif (superInterfaces != Binding.NO_SUPERINTERFACES) {", "+\tif (this.superInterfaces != null) {", "+\t\tif (this.superInterfaces != Binding.NO_SUPERINTERFACES) {", "-\t\t\tfor (int i = 0, length = superInterfaces.length; i < length; i++) {", "+\t\t\tfor (int i = 0, length = this.superInterfaces.length; i < length; i++) {", "-\t\t\t\tbuffer.append((superInterfaces[i] != null) ? superInterfaces[i].debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "+\t\t\t\tbuffer.append((this.superInterfaces[i] != null) ? this.superInterfaces[i].debugName() : \"NULL TYPE\"); //$NON-NLS-1$", "-\tif (fields != null) {", "-\t\tif (fields != Binding.NO_FIELDS) {", "+\tif (this.fields != null) {", "+\t\tif (this.fields != Binding.NO_FIELDS) {", "-\t\t\tfor (int i = 0, length = fields.length; i < length; i++)", "-\t\t\t    buffer.append('\\n').append((fields[i] != null) ? fields[i].toString() : \"NULL FIELD\"); //$NON-NLS-1$ ", "+\t\t\tfor (int i = 0, length = this.fields.length; i < length; i++)", "+\t\t\t    buffer.append('\\n').append((this.fields[i] != null) ? this.fields[i].toString() : \"NULL FIELD\"); //$NON-NLS-1$ ", "-\tif (methods != null) {", "-\t\tif (methods != Binding.NO_METHODS) {", "+\tif (this.methods != null) {", "+\t\tif (this.methods != Binding.NO_METHODS) {", "-\t\t\tfor (int i = 0, length = methods.length; i < length; i++)", "-\t\t\t\tbuffer.append('\\n').append((methods[i] != null) ? methods[i].toString() : \"NULL METHOD\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = this.methods.length; i < length; i++)", "+\t\t\t\tbuffer.append('\\n').append((this.methods[i] != null) ? this.methods[i].toString() : \"NULL METHOD\"); //$NON-NLS-1$", "-\tif (memberTypes != null) {", "-\t\tif (memberTypes != Binding.NO_MEMBER_TYPES) {", "+\tif (this.memberTypes != null) {", "+\t\tif (this.memberTypes != Binding.NO_MEMBER_TYPES) {", "-\t\t\tfor (int i = 0, length = memberTypes.length; i < length; i++)", "-\t\t\t\tbuffer.append('\\n').append((memberTypes[i] != null) ? memberTypes[i].toString() : \"NULL TYPE\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = this.memberTypes.length; i < length; i++)", "+\t\t\t\tbuffer.append('\\n').append((this.memberTypes[i] != null) ? this.memberTypes[i].toString() : \"NULL TYPE\"); //$NON-NLS-1$"]}], "num": 15547}