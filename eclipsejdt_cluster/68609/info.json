{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "87329b1173d2a9ca9644161ef8019e5d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "657277ba1d255d4c795476e4b2a50ebb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "d2e8e421e16a596877a52fb425bb0c8e82e56cdd", "commitAfterChange": "6397a01054d96cb05aae47d916802945c8f4ba3d", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tprivate static void checkAlternateBinding(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] originalArgumentTypes, TypeBinding[] alternateArgumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": "  \tprivate static void checkAlternateBinding(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] originalArgumentTypes, TypeBinding[] alternateArgumentTypes, final InvocationSite invocationSite)", "diff": ["-\t\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "-\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null; }", "-\t\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "-\t\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "-\t\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) { /* ignore */}", "-\t\t\t\tpublic void setDepth(int depth) { /* ignore */}", "-\t\t\t\tpublic void setFieldIndex(int depth){ /* ignore */}", "-\t\t\t\tpublic int sourceStart() { return 0; }", "-\t\t\t\tpublic int sourceEnd() { return 0; }", "-\t\t\t};\t", "-\t\t\tMethodBinding bindingIfNoCast;", "-\t\t\tif (binding.isConstructor()) {", "-\t\t\t\tbindingIfNoCast = scope.getConstructor((ReferenceBinding)receiverType, alternateArgumentTypes, fakeInvocationSite);", "-\t\t\t} else {", "-\t\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "-\t\t\t\t\t? scope.getImplicitMethod(binding.selector, alternateArgumentTypes, fakeInvocationSite)", "-\t\t\t\t\t: scope.getMethod(receiverType, binding.selector, alternateArgumentTypes, fakeInvocationSite); \t", "-\t\t\t}", "-\t\t\tif (bindingIfNoCast == binding) {", "-\t\t\t\tint argumentLength = originalArgumentTypes.length;", "-\t\t\t\tif (binding.isVarargs()) {", "-\t\t\t\t\tint paramLength = binding.parameters.length;", "-\t\t\t\t   if (paramLength == argumentLength) {", "-\t\t\t\t\t\tint varargsIndex = paramLength - 1;", "-\t\t\t\t\t\tArrayBinding varargsType = (ArrayBinding) binding.parameters[varargsIndex];", "-\t\t\t\t\t\tTypeBinding lastArgType = alternateArgumentTypes[varargsIndex];", "-\t\t\t\t\t\t// originalType may be compatible already, but cast mandated to clarify between varargs/non-varargs call", "-\t\t\t\t\t\tint dimensions = lastArgType.dimensions();", "-\t\t\t\t\t\tif (varargsType.dimensions < dimensions) {", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t} else if (varargsType.dimensions == dimensions) {", "-\t\t\t\t\t\t\tif (lastArgType.isCompatibleWith(varargsType.elementsType())", "-\t\t\t\t\t\t\t\t\t&& lastArgType.isCompatibleWith(varargsType)) {", "-\t\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t   }", "-\t\t\t\t}", "-\t\t\t\tfor (int i = 0; i < argumentLength; i++) {", "-\t\t\t\t\tif (originalArgumentTypes[i] != alternateArgumentTypes[i]) {", "-\t\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)arguments[i]);", "+\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "+\t\t\tpublic TypeBinding[] genericTypeArguments() { return null; }", "+\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "+\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "+\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) { /* ignore */}", "+\t\t\tpublic void setDepth(int depth) { /* ignore */}", "+\t\t\tpublic void setFieldIndex(int depth){ /* ignore */}", "+\t\t\tpublic int sourceStart() { return 0; }", "+\t\t\tpublic int sourceEnd() { return 0; }", "+\t\t};\t", "+\t\tMethodBinding bindingIfNoCast;", "+\t\tif (binding.isConstructor()) {", "+\t\t\tbindingIfNoCast = scope.getConstructor((ReferenceBinding)receiverType, alternateArgumentTypes, fakeInvocationSite);", "+\t\t} else {", "+\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "+\t\t\t\t? scope.getImplicitMethod(binding.selector, alternateArgumentTypes, fakeInvocationSite)", "+\t\t\t\t: scope.getMethod(receiverType, binding.selector, alternateArgumentTypes, fakeInvocationSite); \t", "+\t\t}", "+\t\tif (bindingIfNoCast == binding) {", "+\t\t\tint argumentLength = originalArgumentTypes.length;", "+\t\t\tif (binding.isVarargs()) {", "+\t\t\t\tint paramLength = binding.parameters.length;", "+\t\t\t\tif (paramLength == argumentLength) {", "+\t\t\t\t\tint varargsIndex = paramLength - 1;", "+\t\t\t\t\tArrayBinding varargsType = (ArrayBinding) binding.parameters[varargsIndex];", "+\t\t\t\t\tTypeBinding lastArgType = alternateArgumentTypes[varargsIndex];", "+\t\t\t\t\t// originalType may be compatible already, but cast mandated", "+\t\t\t\t\t// to clarify between varargs/non-varargs call", "+\t\t\t\t\tif (varargsType.dimensions != lastArgType.dimensions()) {", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (lastArgType.isCompatibleWith(varargsType.elementsType())", "+\t\t\t\t\t\t\t&& lastArgType.isCompatibleWith(varargsType)) {", "+\t\t\t\t\t\treturn;", "-\t\t\t}\t", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < argumentLength; i++) {", "+\t\t\t\tif (originalArgumentTypes[i] != alternateArgumentTypes[i]) {", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast(", "+\t\t\t\t\t\t\t(CastExpression) arguments[i]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2bde0fe4424fecccf4bea68c48b4ee0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method)", "signatureAfterChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException", "diff": ["-\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method) {", "+\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException {", "+\t\t", "+\t\t// See https://bugs.openjdk.java.net/browse/JDK-8052325 for exclusion of poly expressions targeting proper types. CEF.reduce validates ", "+\t\t// that they are compatible in a loose invocation context against the target type. They contribute nothing further to solving the formulas.", "+\t\tif (substF.isProperType(true))", "+\t\t\treturn true;", "+\t\t", "+\t\t\tif (expri instanceof LambdaExpression) {", "+\t\t\t\tLambdaExpression lambda = (LambdaExpression) expri;", "+\t\t\t\tBlockScope skope = lambda.enclosingScope;", "+\t\t\t\tif (substF.isFunctionalInterface(skope)) { // could be an inference variable.", "+\t\t\t\t\tReferenceBinding t = (ReferenceBinding) substF;", "+\t\t\t\t\tParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(t);", "+\t\t\t\t\tif (withWildCards != null) {", "+\t\t\t\t\t\tt = ConstraintExpressionFormula.findGroundTargetType(this, skope, lambda, withWildCards);", "+\t\t\t\t\t}", "+\t\t\t\t\tMethodBinding functionType;", "+\t\t\t\t\tif (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.getResolvedCopyForInferenceTargeting(t)) != null) {", "+\t\t\t\t\t\tTypeBinding r = functionType.returnType;", "+\t\t\t\t\t\tExpression[] resultExpressions = lambda.resultExpressions();", "+\t\t\t\t\t\tfor (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {", "+\t\t\t\t\t\t\tExpression resultExpression = resultExpressions[i];", "+\t\t\t\t\t\t\tif (!addConstraintsToC_OneExpr(resultExpression, c, r.original(), r, method, true))", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\tMethodBinding innerMethod = invocation.binding(null, false, null);", "+\t\t\tMethodBinding innerMethod = invocation.binding(substF, this.scope);", "+\t\t\tif (innerMethod == null)", "+\t\t\t\treturn true; \t\t  // -> proceed with no new C set elements.", "+\t\t\t", "+\t\t\tif (interleaved) {", "+\t\t\t\tMethodBinding shallowMethod = innerMethod.shallowOriginal();", "+\t\t\t\tSuspendedInferenceRecord prevInvocation = enterPolyInvocation(invocation, invocation.arguments());", "+\t\t\t\ttry {", "+\t\t\t\t\tExpression[] arguments = invocation.arguments();", "+\t\t\t\t\tTypeBinding[] argumentTypes = arguments == null ? Binding.NO_PARAMETERS : new TypeBinding[arguments.length];", "+\t\t\t\t\tfor (int i = 0; i < argumentTypes.length; i++)", "+\t\t\t\t\t\targumentTypes[i] = arguments[i].resolvedType;", "+\t\t\t\t\tif (innerMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tInferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) innerMethod);", "+\t\t\t\t\t\tthis.inferenceKind = innerCtx.inferenceKind;", "+\t\t\t\t\t}", "+\t\t\t\t\tinferInvocationApplicability(shallowMethod, argumentTypes, shallowMethod.isConstructor());", "+\t\t\t\t\tif (!ConstraintExpressionFormula.inferPolyInvocationType(this, invocation, substF, shallowMethod))", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t} finally {", "+\t\t\t\t\tresumeSuspendedInference(prevInvocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tint applicabilityKind = CHECK_LOOSE;  // FIXME, for <> resolving to a non-generic method, this need to be computed.", "-\t\t\t\tif (innerCtx != null) { // otherwise innerMethod does not participate in inference", "-\t\t\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), innerCtx.inferenceKind);", "+\t\t\t\tif (innerCtx != null) {", "+\t\t\t\t\tapplicabilityKind = innerCtx.inferenceKind;", "+\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), applicabilityKind, interleaved);", "-\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method)", "-\t\t\t\t && addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method);", "+\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method, interleaved)", "+\t\t\t\t\t&& addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method, interleaved);", "-\t}"]}], "num": 68609}