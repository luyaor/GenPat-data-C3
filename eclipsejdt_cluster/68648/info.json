{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba421335a2cc85ea180a36c512bef9b6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99478486faff08d2369392f9759fedf9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java", "commitBeforeChange": "5166ddb130bcb062c1e82da491c829c5d95a6211", "commitAfterChange": "2894ba75386697d7bf484434d073fb6ffaf6cec9", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 22, "signatureBeforeChange": " private int decodeAnnotation(int offset)", "signatureAfterChange": " public IBinaryAnnotation[] getAnnotations()", "diff": ["-private int decodeAnnotation(int offset) {", "-\tint readOffset = offset;", "-\tint utf8Offset = this.constantPoolOffsets[u2At(offset)];", "-\tchar[] typeName = utf8At(utf8Offset + 3, u2At(utf8Offset + 1));", "-\tint numberOfPairs = u2At(offset + 2);", "-\treadOffset += 4;", "-\tswitch(typeName.length) {", "-\t\tcase 21 :", "-\t\t\tif (CharOperation.equals(typeName, ConstantPool.JAVA_LANG_ANNOTATION_INHERITED)) {", "-\t\t\t\tthis.tagBits |= TagBits.AnnotationInherited;", "-\t\t\t\treturn readOffset;\t\t", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tcase 22 :", "-\t\t\tif (CharOperation.equals(typeName, ConstantPool.JAVA_LANG_DEPRECATED)) {", "-\t\t\t\tthis.tagBits |= TagBits.AnnotationDeprecated;", "-\t\t\t\treturn readOffset;\t\t", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tcase 29 :", "-\t\t\tif (CharOperation.equals(typeName, ConstantPool.JAVA_LANG_ANNOTATION_TARGET)) {", "-\t\t\t\tfor (int i = 0; i < numberOfPairs; i++) {", "-\t\t\t\t\treadOffset += 2;", "-\t\t\t\t\treadOffset = decodeElementValueForJavaLangAnnotationTarget(readOffset);", "-\t\t\t\t}", "-\t\t\t\treturn readOffset;\t\t", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tcase 33 :", "-\t\t\tif (CharOperation.equals(typeName, ConstantPool.JAVA_LANG_ANNOTATION_DOCUMENTED)) {", "-\t\t\t\tthis.tagBits |= TagBits.AnnotationDocumented;", "-\t\t\t\treturn readOffset;\t\t", "-\t\t\t}", "-\t\t\tbreak;", "-\t\tcase 32 :", "-\t\t\tif (CharOperation.equals(typeName, ConstantPool.JAVA_LANG_ANNOTATION_RETENTION)) {", "-\t\t\t\tfor (int i = 0; i < numberOfPairs; i++) {", "-\t\t\t\t\treadOffset += 2;", "-\t\t\t\t\treadOffset = decodeElementValueForJavaLangAnnotationRetention(readOffset);", "-\t\t\t\t}", "-\t\t\t\treturn readOffset;", "-\t\t\t}", "-\t\t\tbreak;", "-\t}", "-\tfor (int i = 0; i < numberOfPairs; i++) {", "-\t\treadOffset += 2;", "-\t\treadOffset = decodeElementValue(readOffset);", "-\t}", "-\treturn readOffset;", "-}", "+ */", "+public IBinaryAnnotation[] getAnnotations() {", "+\treturn this.annotations;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9bb2bae1c573ae3844a6ee747a8af927", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "63bda44d804d11c0afa7e8111644ceeb5480e759", "commitAfterChange": "6e3484e93dc48a09ac8c425df0144a313c14ab99", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\tif (binding.isVarargs()) {", "-\t\t// 4 possibilities exist for a call to the vararg method foo(int i, int ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})", "-\t\tTypeBinding[] params = binding.parameters;", "-\t\tint lastIndex = params.length - 1;", "-\t\tfor (int i = 0; i < lastIndex; i++) {", "-\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "-\t\t}", "-", "-\t\tArrayBinding varArgsType = (ArrayBinding) params[lastIndex]; // parameterType has to be an array type", "-\t\tint argLength = arguments == null ? 0 : arguments.length;", "-\t\tif (lastIndex < argLength) { // vararg argument was provided", "-\t\t\tif (params.length == argLength && varArgsType.dimensions() == arguments[lastIndex].resolvedType.dimensions()) {", "-\t\t\t\t// called with matching array : foo(1, new int[] {1, 2}", "-\t\t\t\targuments[lastIndex].generateCode(currentScope, codeStream, true);", "-\t\t\t} else {", "-\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "-\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "-\t\t\t\tcodeStream.generateInlinedValue(argLength - lastIndex);", "-\t\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "-\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "-\t\t\t\tfor (int i = 0, max = argLength - lastIndex; i < max; i++) {", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\tcodeStream.generateInlinedValue(i);", "-\t\t\t\t\targuments[i + lastIndex].generateCode(currentScope, codeStream, true);", "-\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// generate code for an empty array of parameterType", "-\t\t\tcodeStream.generateInlinedValue(0);", "-\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "-\t\t}", "-\t} else if (arguments != null){", "-\t\tfor (int i = 0, max = arguments.length; i < max; i++){", "-\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "-\t\t}", "-\t}", "+\tgenerateArguments(binding, arguments, currentScope, codeStream);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f739b36258e22d3206a255228cd2d93", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "55f4964943e2f63287728b29450cbefa492d313d", "commitAfterChange": "ffcfe0dac7f476f076089d3cdae600b5982efdfb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\tif (arguments != null){", "+\tif (binding.isVararg()) {", "+\t\t// 4 possibilities exist for a call to the vararg method foo(int i, int ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})", "+\t\tTypeBinding[] params = binding.parameters;", "+\t\tint lastIndex = params.length - 1;", "+\t\tfor (int i = 0; i < lastIndex; i++) {", "+\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "+\t\t}", "+", "+\t\tArrayBinding varArgsType = (ArrayBinding) params[lastIndex]; // parameterType has to be an array type", "+\t\tint argLength = arguments == null ? 0 : arguments.length;", "+\t\tif (lastIndex < argLength) { // vararg argument was provided", "+\t\t\tif (params.length == argLength && varArgsType.dimensions() == arguments[lastIndex].resolvedType.dimensions()) {", "+\t\t\t\t// called with matching array : foo(1, new int[] {1, 2}", "+\t\t\t\targuments[lastIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t} else {", "+\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "+\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "+\t\t\t\tcodeStream.generateInlinedValue(argLength - lastIndex);", "+\t\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "+\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "+\t\t\t\tfor (int i = 0, max = argLength - lastIndex; i < max; i++) {", "+\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\tcodeStream.generateInlinedValue(i);", "+\t\t\t\t\targuments[i + lastIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// generate code for an empty array of parameterType", "+\t\t\tcodeStream.generateInlinedValue(0);", "+\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "+\t\t}", "+\t} else if (arguments != null){"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3244f8fc2803756a1c619e94b1d30c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java", "commitBeforeChange": "86284f2db6c7ac41b63c1766c9b7b3a016d95a9a", "commitAfterChange": "c8d8bdad35a9dc8d924116cabb6dd00986cff218", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "diff": ["-\t\treturn (this.resolvedType = null);", "+", "+\t\tint length = this.typeReferences.length;", "+\t\tReferenceBinding[] intersectingTypes = new ReferenceBinding[length];", "+\t\tboolean hasError = false;", "+\t\t", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tfinal TypeReference typeReference = this.typeReferences[i];", "+\t\t\tTypeBinding type = typeReference.resolveType(scope, checkBounds);", "+\t\t\tif (type == null || ((type.tagBits & TagBits.HasMissingType) != 0)) {", "+\t\t\t\thasError = true;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (i == 0) {", "+\t\t\t\tif (type.isBaseType()) { // rejected in grammar for i > 0", "+\t\t\t\t\tscope.problemReporter().onlyReferenceTypesInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (type.isArrayType()) { // javac rejects the pedantic cast: (X[] & Serializable & Cloneable) new X[0], what is good for the goose ...", "+\t\t\t\t\tscope.problemReporter().illegalArrayTypeInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t} else if (!type.isInterface()) {  // TODO: understand how annotations play here ...", "+\t\t\t\tscope.problemReporter().boundMustBeAnInterface(typeReference, type);", "+\t\t\t\thasError = true;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\tif (intersectingTypes[j] == type) {", "+\t\t\t\t\tscope.problemReporter().duplicateBoundInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tintersectingTypes[i] = (ReferenceBinding) type;", "+\t\t}", "+\t\tif (hasError) {", "+\t\t\treturn null;", "+\t\t}", "+\t\treturn (this.resolvedType = scope.environment().createIntersectionCastType(intersectingTypes));"]}], "num": 68648}