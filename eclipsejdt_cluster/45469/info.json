{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ffd388db77316f41f941e8797baa2700", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "010a348393bdbfe67627de8d512c6e38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "signatureAfterChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "diff": ["-\tchar[] superclassName = binaryType.getSuperclassName();", "-\tif (superclassName != null)", "-\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "-\t\tthis.superclass = environment.getTypeFromConstantPoolName(superclassName, 0, -1);", "-", "+\t// need enclosing type to access type variables", "-\t\tthis.enclosingType = environment.getTypeFromConstantPoolName(enclosingTypeName, 0, -1);", "+\t\tthis.enclosingType = environment.getTypeFromConstantPoolName(enclosingTypeName, 0, -1, true); // pretend parameterized to avoid raw", "+\t\tthis.tagBits |= \tHasUnresolvedEnclosingType;", "+\t}", "+", "+\tboolean checkGenericSignatures = environment.options.sourceLevel >= ClassFileConstants.JDK1_5;", "+\tchar[] typeSignature = checkGenericSignatures ? binaryType.getGenericSignature() : null;", "+\tif (typeSignature == null) {", "+\t\tchar[] superclassName = binaryType.getSuperclassName();", "+\t\tif (superclassName != null) {", "+\t\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tthis.superclass = environment.getTypeFromConstantPoolName(superclassName, 0, -1, false);", "+\t\t\tthis.tagBits |= \tHasUnresolvedSuperclass;", "+\t\t}", "+", "+\t\tthis.superInterfaces = NoSuperInterfaces;", "+\t\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "+\t\tif (interfaceNames != null) {", "+\t\t\tint size = interfaceNames.length;", "+\t\t\tif (size > 0) {", "+\t\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "+\t\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\t\tthis.superInterfaces[i] = environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false);", "+\t\t\t\tthis.tagBits |= \tHasUnresolvedSuperinterfaces;", "+\t\t\t}", "+\t\t}", "+\t} else {", "+\t\t// ClassSignature = ParameterPart(optional) super_TypeSignature interface_signature", "+\t\tSignatureWrapper wrapper = new SignatureWrapper(typeSignature);", "+\t\tif (wrapper.signature[wrapper.start] == '<') {", "+\t\t\t// ParameterPart = '<' ParameterSignature(s) '>'", "+\t\t\twrapper.start++; // skip '<'", "+\t\t\tint rank = 0;", "+\t\t\tdo {", "+\t\t\t\tTypeVariableBinding variable = createTypeVariable(wrapper, rank);", "+\t\t\t\tvariable.fPackage = this.fPackage;", "+\t\t\t\tSystem.arraycopy(this.typeVariables, 0, this.typeVariables = new TypeVariableBinding[rank + 1], 0, rank);", "+\t\t\t\tthis.typeVariables[rank++] = variable;", "+\t\t\t} while (wrapper.signature[wrapper.start] != '>');", "+\t\t\twrapper.start++; // skip '>'", "+\t\t\tthis.tagBits |=  HasUnresolvedTypeVariables;", "+\t\t\tthis.modifiers |= AccGenericSignature;", "+\t\t}", "+", "+\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\tthis.superclass = (ReferenceBinding) environment.getTypeFromTypeSignature(wrapper, NoTypeVariables, this);", "+\t\tthis.tagBits |= \tHasUnresolvedSuperclass;", "+", "+\t\tthis.superInterfaces = NoSuperInterfaces;", "+\t\tif (!wrapper.atEnd()) {", "+\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "+\t\t\tdo {", "+\t\t\t\ttypes.add(environment.getTypeFromTypeSignature(wrapper, NoTypeVariables, this));", "+\t\t\t} while (!wrapper.atEnd());", "+\t\t\tthis.superInterfaces = new ReferenceBinding[types.size()];", "+\t\t\ttypes.toArray(this.superInterfaces);", "+\t\t\tthis.tagBits |= \tHasUnresolvedSuperinterfaces;", "+\t\t}", "-\t\t\t\tthis.memberTypes[i] = environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1);", "+\t\t\t\tthis.memberTypes[i] = environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1, false);", "+\t\t\tthis.tagBits |= \tHasUnresolvedMemberTypes;", "-\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "-\tif (interfaceNames != null) {", "-\t\tint size = interfaceNames.length;", "-\t\tif (size > 0) {", "-\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "-\t\t\tfor (int i = 0; i < size; i++)", "-\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\t\tthis.superInterfaces[i] = environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1);", "-\t\t}", "-\t}", "-\t\tcreateFields(binaryType.getFields());", "-\t\tcreateMethods(binaryType.getMethods());", "+\t\tcreateFields(binaryType.getFields(), checkGenericSignatures);", "+\t\tcreateMethods(binaryType.getMethods(), checkGenericSignatures);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5812333d77792e6af0ec5a862d7317f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "cd405a8db634596f85cfafeafe4d4ea561cbd638", "commitAfterChange": "928bbf160d6f9d1eb9d492c7bd7fb73692671b03", "methodNumberBeforeChange": 157, "methodNumberAfterChange": 157, "signatureBeforeChange": " protected boolean moveRecoveryCheckpoint()", "signatureAfterChange": " protected boolean moveRecoveryCheckpoint()", "diff": ["-\tif (completionScanner.record) {", "-\t\tcompletionScanner.currentToken = -1;", "-\t\tcompletionScanner.currentTokenStart = 0;", "+\tboolean recordIdentifers = completionScanner.record;", "+\tif (!recordIdentifers) {", "+\t\treturn super.moveRecoveryCheckpoint();", "-\treturn super.moveRecoveryCheckpoint();", "+\t", "+\tcompletionScanner.record = false;", "+\t", "+\tint pos = this.lastCheckPoint;", "+\tint curTok = completionScanner.lastUsedToken;", "+\tint curTokStart = completionScanner.lastUsedTokenStart;", "+\t", "+\t/* reset this.scanner, and move checkpoint by one token */", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.diet = false; // quit jumping over method bodies", "+\t", "+\tcompletionScanner.currentToken = curTok;", "+\tcompletionScanner.currentTokenStart = curTokStart;", "+\t", "+\t/* if about to restart, then no need to shift token */", "+\tif (this.restartRecovery){", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.scanner.insideRecovery = true;\t\t", "+\t\tcompletionScanner.record = true;", "+\t\treturn true;", "+\t}", "+\t", "+\t/* protect against shifting on an invalid token */", "+\tthis.lastIgnoredToken = this.nextIgnoredToken;", "+\tthis.nextIgnoredToken = -1;", "+\tdo {", "+\t\ttry {", "+\t\t\tthis.nextIgnoredToken = this.scanner.getNextToken();", "+\t\t\tif(this.scanner.currentPosition == this.scanner.startPosition){", "+\t\t\t\tthis.scanner.currentPosition++; // on fake completion identifier", "+\t\t\t\tthis.nextIgnoredToken = -1;", "+\t\t\t}", "+\t\t\t", "+\t\t} catch(InvalidInputException e){", "+\t\t\tpos = this.scanner.currentPosition;", "+\t\t}", "+\t} while (this.nextIgnoredToken < 0);", "+\t", "+\tif (this.nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "+\t\tif (this.currentToken == TokenNameEOF) { // already tried one iteration on EOF", "+\t\t\tcompletionScanner.record = true;", "+\t\t\treturn false;", "+\t\t}", "+\t}", "+\tthis.lastCheckPoint = this.scanner.currentPosition;", "+\tcompletionScanner.lastUsedToken = this.nextIgnoredToken;", "+\tcompletionScanner.lastUsedTokenStart = this.lastCheckPoint;", "+\t", "+\t/* reset this.scanner again to previous checkpoint location*/", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.commentPtr = -1;", "+\tthis.scanner.foundTaskCount = 0;", "+\t", "+\tcompletionScanner.currentToken = curTok;", "+\tcompletionScanner.currentTokenStart = curTokStart;", "+\tcompletionScanner.record = true;", "+\t\t", "+\treturn true;"]}], "num": 45469}