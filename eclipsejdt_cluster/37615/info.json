{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fa935579f52bb9ee61c1529956088c5a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1341ecdaef74114f80fc135680412319", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java", "commitBeforeChange": "e94011fcc318ef65fa86c3461da146f3ce7811d6", "commitAfterChange": "93adf51608925f1838440c274601d52ca5dd3d46", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " public TypeDeclaration updatedTypeDeclaration(int depth, Set knownTypes)", "signatureAfterChange": " public TypeDeclaration updatedTypeDeclaration(int depth, Set knownTypes)", "diff": ["+\t\t", "+\t\tfor (int i = this.fieldCount - 1; 0 < i; i--) {", "+\t\t\tif (fieldDeclarations[existingCount + i - 1].declarationSourceStart == fieldDeclarations[existingCount + i].declarationSourceStart) {", "+\t\t\t\tfieldDeclarations[existingCount + i - 1].declarationSourceEnd = fieldDeclarations[existingCount + i].declarationSourceEnd;", "+\t\t\t\tfieldDeclarations[existingCount + i - 1].declarationEnd = fieldDeclarations[existingCount + i].declarationEnd;", "+\t\t\t}", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8229657378c092b158ca89ba5effed83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "66fe9194782f846d946fc257cc3a475661c8281c", "commitAfterChange": "474eb5356258f18fd9cfbd1a24f6dbe20ed6eea5", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["+\tMethodBinding superClassMethod = null;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tif (!methods[i].declaringClass.isInterface() && methods[i].declaringClass != this.type) {", "+\t\t\tsuperClassMethod = methods[i];", "+\t\t\tbreak;", "+\t\t}", "+\t}", "-\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "-\t\t\t\tcontinueInvestigation = false;", "+\t\t\t\t// 8.4.8.4 defines an exception for default methods if", "+\t\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "+\t\t\t\t// (b) that is override-equivalent with the two methods.", "+\t\t\t\tif (methods[i].isDefaultMethod() ", "+\t\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t\t&& areParametersEqual(superClassMethod, concreteMethod)) {", "+\t\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "+\t\t\t\t\tcontinueInvestigation = false;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2c5d1ab320627134072cbfc711f4cd0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "859e3e60153dbd5b801c22eee34ae0a345494b4e", "commitAfterChange": "1252d6bab1f9d9bcd087d91685fabf29808e5435", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic Answer findType( \t\t\tString typeName,  \t\t\tString packageName,  \t\t\tboolean partialMatch,  \t\t\tint acceptFlags,  \t\t\tboolean considerSecondaryTypes,  \t\t\tboolean waitForIndexes,  \t\t\tboolean checkRestrictions, \t\t\tIProgressMonitor monitor)", "signatureAfterChange": " \tpublic Answer findType( \t\t\tString typeName,  \t\t\tString packageName,  \t\t\tboolean partialMatch,  \t\t\tint acceptFlags,  \t\t\tboolean considerSecondaryTypes,  \t\t\tboolean waitForIndexes,  \t\t\tboolean checkRestrictions, \t\t\tIProgressMonitor monitor)", "diff": ["+\t\tIJavaProject javaProject = null;", "-\t\t\tif (considerSecondaryTypes) {", "-\t\t\t\tif (projects == null) projects = new HashSet(3);", "-\t\t\t\tprojects.add(packages[i].getJavaProject());", "+\t\t\telse if (suggestedAnswer == null && considerSecondaryTypes) {", "+\t\t\t\tif (javaProject == null) {", "+\t\t\t\t\tjavaProject = packages[i].getJavaProject();", "+\t\t\t\t} else if (projects == null)  {", "+\t\t\t\t\tif (!javaProject.equals(packages[i].getJavaProject())) {", "+\t\t\t\t\t\tprojects = new HashSet(3);", "+\t\t\t\t\t\tprojects.add(javaProject);", "+\t\t\t\t\t\tprojects.add(packages[i].getJavaProject());", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tprojects.add(packages[i].getJavaProject());", "+\t\t\t\t}", "-\t\tif (considerSecondaryTypes && projects != null) {", "-\t\t\tIterator allProjects = projects.iterator();", "-\t\t\twhile (type == null && allProjects.hasNext()) {", "-\t\t\t\ttype = findSecondaryType(packageName, typeName, (IJavaProject) allProjects.next(), waitForIndexes, monitor);", "+\t\tif (considerSecondaryTypes && javaProject != null) {", "+\t\t\tif (projects == null) {", "+\t\t\t\ttype = findSecondaryType(packageName, typeName, javaProject, waitForIndexes, monitor);", "+\t\t\t} else {", "+\t\t\t\tIterator allProjects = projects.iterator();", "+\t\t\t\twhile (type == null && allProjects.hasNext()) {", "+\t\t\t\t\ttype = findSecondaryType(packageName, typeName, (IJavaProject) allProjects.next(), waitForIndexes, monitor);", "+\t\t\t\t}"]}], "num": 37615}