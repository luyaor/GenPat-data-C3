{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0f5d4061bbef33ce3c9c1b560ed41253", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a57e8d3a4cd9f2776927fe53d8703215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "c67ad5667d81e7ca8719e3b0faf6c7f2b84f03ce", "commitAfterChange": "55a2e1357c3327be6468ccea0fa1bd5884ed35ad", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "signatureAfterChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "diff": ["-\t    if (argumentType.isWildcard()) {", "-\t        WildcardBinding wildcard = (WildcardBinding) argumentType;", "-\t        switch (wildcard.boundKind) {", "-\t        \tcase Wildcard.SUPER :", "-//\t\t            if (boundCheck(substitution, wildcard.bound) != TypeConstants.OK) return TypeConstants.MISMATCH;", "-//\t\t            break;", "-\t\t            return boundCheck(substitution, wildcard.bound); // only check the lower bound", "+\t\tif (argumentType.isWildcard()) {", "+\t\t\tWildcardBinding wildcard = (WildcardBinding) argumentType;", "+\t\t\tswitch(wildcard.boundKind) {", "+\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\tReferenceBinding superclassBound = (ReferenceBinding)Scope.substitute(substitution, this.superclass());", "+\t\t\t\t\tTypeBinding wildcardBound = wildcard.bound;", "+\t\t\t\t\tboolean isArrayBound = wildcardBound.isArrayType();", "+\t\t\t\t\tif (!wildcardBound.isInterface()) {", "+\t\t\t\t\t\tif (isArrayBound) {", "+\t\t\t\t\t\t\tif (!wildcardBound.isCompatibleWith(superclassBound))", "+\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superclassBound.erasure());", "+\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\tif (!match.isIntersectingWith(superclassBound)) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tReferenceBinding[] superInterfaceBounds = Scope.substitute(substitution, this.superInterfaces());", "+\t\t\t\t\tint length = superInterfaceBounds.length;", "+\t\t\t\t\tboolean mustImplement = isArrayBound || ((ReferenceBinding)wildcardBound).isFinal();", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tTypeBinding superInterfaceBound = superInterfaceBounds[i];", "+\t\t\t\t\t\tif (isArrayBound) {", "+\t\t\t\t\t\t\tif (!wildcardBound.isCompatibleWith(superInterfaceBound))", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superInterfaceBound.erasure());", "+\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\tif (!match.isIntersectingWith(superInterfaceBound)) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (mustImplement) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH; // cannot be extended further to satisfy missing bounds", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\t", "+\t\t\t\tcase Wildcard.SUPER :", "+\t\t\t\t\treturn boundCheck(substitution, wildcard.bound);", "+\t\t\t\t\t", "-\t\t\t\t\tif (this == wildcard.typeVariable()) ", "-\t\t\t\t\t\treturn TypeConstants.OK;", "-\t\t\t\t\tbreak;\t        \t\t", "-\t        }", "-\t    }", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\treturn TypeConstants.OK;", "+\t\t}", "-\t\t\t}", "+\t\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f6d25ca12c576b341585765b48f0160b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "a2a25daab3f792071cba7e3d51c3d2abf00c6c2a", "commitAfterChange": "8bffc680730baeb75a0764c02d5d9479eee4502e", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic TypeBinding[] createBoundsForFunctionalInterfaceParameterizationInference(ParameterizedTypeBinding functionalInterface)", "signatureAfterChange": " \tTypeBinding[] createBoundsForFunctionalInterfaceParameterizationInference(ParameterizedTypeBinding functionalInterface)", "diff": ["+\t */", "+\tTypeBinding[] createBoundsForFunctionalInterfaceParameterizationInference(ParameterizedTypeBinding functionalInterface) {", "+\t\tif (this.currentBounds == null)", "+\t\t\tthis.currentBounds = new BoundSet();", "+\t\tTypeBinding[] a = functionalInterface.arguments;", "+\t\tif (a == null)", "+\t\t\treturn null;", "+\t\tInferenceVariable[] alpha = addInitialTypeVariableSubstitutions(a);", "+", "+\t\tfor (int i = 0; i < a.length; i++) {", "+\t\t\tTypeBound bound;", "+\t\t\tif (a[i].kind() == Binding.WILDCARD_TYPE) {", "+\t\t\t\tWildcardBinding wildcard = (WildcardBinding) a[i];", "+\t\t\t\tswitch(wildcard.boundKind) {", "+    \t\t\t\tcase Wildcard.EXTENDS :", "+    \t\t\t\t\tbound = new TypeBound(alpha[i], wildcard.allBounds(), ReductionResult.SUBTYPE);", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.SUPER :", "+    \t\t\t\t\tbound = new TypeBound(alpha[i], wildcard.bound, ReductionResult.SUPERTYPE);", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.UNBOUND :", "+    \t\t\t\t\tbound = new TypeBound(alpha[i], this.object, ReductionResult.SUBTYPE);", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tdefault:", "+    \t\t\t\t\tcontinue; // cannot", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tbound = new TypeBound(alpha[i], a[i], ReductionResult.SAME);", "+\t\t\t}", "+\t\t\tthis.currentBounds.addBound(bound);", "+\t\t}", "+\t\tTypeBinding falpha = substitute(functionalInterface);", "+\t\treturn falpha.getSingleAbstractMethod(this.scope, true).parameters;", "+\t}", "-\t */", "-\tpublic TypeBinding[] createBoundsForFunctionalInterfaceParameterizationInference(ParameterizedTypeBinding functionalInterface) {", "-\t\tthis.currentBounds = new BoundSet();", "-\t\tTypeBinding[] a = functionalInterface.arguments;", "-\t\tif (a == null)", "-\t\t\treturn null;", "-\t\tInferenceVariable[] alpha = addInitialTypeVariableSubstitutions(a);", "-", "-\t\tfor (int i = 0; i < a.length; i++) {", "-\t\t\tTypeBound bound;", "-\t\t\tif (a[i].kind() == Binding.WILDCARD_TYPE) {", "-\t\t\t\tWildcardBinding wildcard = (WildcardBinding) a[i];", "-\t\t\t\tswitch(wildcard.boundKind) {", "-    \t\t\t\tcase Wildcard.EXTENDS :", "-    \t\t\t\t\tbound = new TypeBound(alpha[i], wildcard.allBounds(), ReductionResult.SUBTYPE);", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.SUPER :", "-    \t\t\t\t\tbound = new TypeBound(alpha[i], wildcard.bound, ReductionResult.SUPERTYPE);", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.UNBOUND :", "-    \t\t\t\t\tbound = new TypeBound(alpha[i], this.object, ReductionResult.SUBTYPE);", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tdefault:", "-    \t\t\t\t\tcontinue; // cannot", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tbound = new TypeBound(alpha[i], a[i], ReductionResult.SAME);", "-\t\t\t}", "-\t\t\tthis.currentBounds.addBound(bound);", "-\t\t}", "-\t\tTypeBinding falpha = substitute(functionalInterface);", "-\t\treturn falpha.getSingleAbstractMethod(this.scope, true).parameters;", "-\t}"]}], "num": 61450}