{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1069919d838e45750452e0d58a37380b", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0fea6a75bd61de0404bffc9d7bf9add6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 180, "methodNumberAfterChange": 180, "signatureBeforeChange": " protected void consumeToken(int type)", "signatureAfterChange": " protected void consumeToken(int type)", "diff": ["-//\t\t\tscanner.commentPtr = -1;", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t//System.out.println(scanner.toStringAction(type));", "+\t//System.out.println(this.scanner.toStringAction(type));", "-\t\t\tif (scanner.useAssertAsAnIndentifier) {", "-\t\t\t\tlong positions = identifierPositionStack[identifierPtr];", "+\t\t\tif (this.scanner.useAssertAsAnIndentifier) {", "+\t\t\t\tlong positions = this.identifierPositionStack[this.identifierPtr];", "-//\t\t\tscanner.commentPtr = -1;", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tthis.synchronizedBlockSourceStart = scanner.startPosition;\t", "+\t\t\tthis.synchronizedBlockSourceStart = this.scanner.startPosition;\t", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);\t\t\t\t", "-\t\t\tpushOnIntStack(scanner.startPosition);\t\t\t\t\t", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);\t\t\t\t", "+\t\t\tpushOnIntStack(this.scanner.startPosition);\t\t\t\t\t", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSource(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\t\tthis.scanner.getCurrentTokenSource(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSource(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\t\tthis.scanner.getCurrentTokenSource(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSource(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\t\tthis.scanner.getCurrentTokenSource(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSource(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\t\tthis.scanner.getCurrentTokenSource(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSource(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\t\tthis.scanner.getCurrentTokenSource(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\t\tscanner.getCurrentTokenSourceString(), ", "-\t\t\t\t\tscanner.startPosition, ", "-\t\t\t\t\tscanner.currentPosition - 1); ", "+\t\t\t\t\tthis.scanner.getCurrentTokenSourceString(), ", "+\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\tthis.scanner.currentPosition - 1); ", "-//\t\t\tscanner.commentPtr = -1;", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\tnew FalseLiteral(scanner.startPosition, scanner.currentPosition - 1)); ", "-//\t\t\tscanner.commentPtr = -1;", "+\t\t\t\tnew FalseLiteral(this.scanner.startPosition, this.scanner.currentPosition - 1)); ", "+//\t\t\tthis.scanner.commentPtr = -1;", "-\t\t\t\tnew TrueLiteral(scanner.startPosition, scanner.currentPosition - 1)); ", "+\t\t\t\tnew TrueLiteral(this.scanner.startPosition, this.scanner.currentPosition - 1)); ", "-\t\t\t\tnew NullLiteral(scanner.startPosition, scanner.currentPosition - 1)); ", "+\t\t\t\tnew NullLiteral(this.scanner.startPosition, this.scanner.currentPosition - 1)); ", "-\t\t\tendPosition = scanner.currentPosition - 1;", "-\t\t\tpushOnIntStack(scanner.startPosition);", "+\t\t\tthis.endPosition = this.scanner.currentPosition - 1;", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "-\t\t\tpushOnIntStack(scanner.startPosition);", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "-\t\t\tpushOnIntStack(scanner.startPosition);", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);", "-\t\t\tpushOnIntStack(scanner.startPosition);", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "-\t\t\tpushOnIntStack(scanner.startPosition);", "-\t\t\tpushOnIntStack(scanner.currentPosition - 1);", "+\t\t\tpushOnIntStack(this.scanner.startPosition);", "+\t\t\tpushOnIntStack(this.scanner.currentPosition - 1);", "-\t\t\tendPosition = scanner.startPosition;", "+\t\t\tthis.endPosition = this.scanner.startPosition;", "-\t\t\tendPosition = scanner.startPosition;", "-\t\t\tendStatementPosition = scanner.currentPosition - 1;", "+\t\t\tthis.endPosition = this.scanner.startPosition;", "+\t\t\tthis.endStatementPosition = this.scanner.currentPosition - 1;", "-\t\t\tendStatementPosition = scanner.currentPosition - 1;", "-\t\t\tendPosition = scanner.startPosition - 1; ", "+\t\t\tthis.endStatementPosition = this.scanner.currentPosition - 1;", "+\t\t\tthis.endPosition = this.scanner.startPosition - 1; ", "-\t\t\trParenPos = scanner.currentPosition - 1; // position of the end of right parenthesis (in case of unicode \\u0029) lex00101", "+\t\t\tthis.rParenPos = this.scanner.currentPosition - 1; // position of the end of right parenthesis (in case of unicode \\u0029) lex00101", "-\t\t\tlParenPos = scanner.startPosition;", "+\t\t\tthis.lParenPos = this.scanner.startPosition;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44c22f0a43350379d2e40e17c50d1d00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "6defd2b79520062f5150164ded77c2d030acc168", "commitAfterChange": "d351702f3561d64a024c15ffbed0faad48ce2838", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprotected boolean parseParam()", "signatureAfterChange": " \tprotected boolean parseParam() throws InvalidInputException", "diff": ["-\tprotected boolean parseParam() {", "+\tprotected boolean parseParam() throws InvalidInputException {", "-\t\t// Store current token state", "+\t\t// Store current state", "-", "-\t\ttry {", "-\t\t\t// Push identifier next", "-\t\t\tint token = readToken();", "-\t\t\tswitch (token) {", "+\t\tboolean tokenWhiteSpace = this.scanner.tokenizeWhiteSpace;", "+\t\tthis.scanner.tokenizeWhiteSpace = true;", "+//\t\tthis.scanner.tokenizeLineSeparator = true;", "+\t\t", "+\t\t// Verify that there are whitespaces after tag", "+\t\tint token = readToken();", "+\t\tif (token != TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(start, this.scanner.getCurrentTokenEndPosition());", "+\t\t\tthis.scanner.currentPosition = start;", "+\t\t\tthis.index = start;", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Get first non whitespace token", "+\t\tboolean hasMultiLines = this.scanner.currentPosition > (this.lineEnd+1);", "+\t\tboolean isTypeParam = false;", "+\t\tboolean valid = true, empty = true;", "+\t\tnextToken: while (true) {", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tswitch (token = readToken()) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\treturn pushParamName();", "-\t\t\t\tcase TerminalTokens.TokenNameEOF :", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault :", "-\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tend = getTokenEndPosition();", "-\t\t\t\t\tif (end < start) start = this.tagSourceStart;", "-\t\t\t\t\tbreak;", "+\t\t\t\t\tif (valid) { ", "+\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t\t\t\tthis.identifierLengthPtr = -1;", "+\t\t\t\t\t\tpushIdentifier(true);", "+\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t}", "+\t\t\t\t\t// fall through next case to report error", "+\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\tif (valid && this.jdk15) {", "+\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tisTypeParam = true;", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t}", "+\t\t\t\t\t// fall through next case to report error", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (token == TerminalTokens.TokenNameLEFT_SHIFT) isTypeParam = true;", "+\t\t\t\t\tif (valid && !hasMultiLines) start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\tvalid = false;", "+\t\t\t\t\tif (!hasMultiLines) {", "+\t\t\t\t\t\tempty = false;", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tend = this.lineEnd;", "+\t\t\t\t\t// when several lines, fall through next case to report problem immediately", "+\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) hasMultiLines = true;", "+\t\t\t\t\tif (valid) break;", "+\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\tif (this.reportProblems)", "+\t\t\t\t\t\tif (empty)", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "+\t\t\t\t\t\telse if (this.jdk15 && isTypeParam)", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "+\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\tthis.index = start;", "+\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "+\t\t\t\t\treturn false;", "-\t\t} catch (InvalidInputException e) {", "-\t\t\tend = getTokenEndPosition();", "-", "-\t\t// Reset position to avoid missing tokens when new line was encountered", "-\t\tthis.index = this.tokenPreviousPosition;", "-\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\tthis.currentTokenType = -1;", "-", "+\t\t", "+\t\t// Scan more tokens for type parameter declaration", "+\t\tif (isTypeParam && this.jdk15) {", "+\t\t\t// Get type parameter name", "+\t\t\tnextToken: while (true) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tswitch (token = readToken()) {", "+\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\tif (valid && this.scanner.currentPosition <= (this.lineEnd+1)) break;", "+\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t\t\t\t\tthis.identifierLengthPtr = -1;", "+\t\t\t\t\t\t\tpushIdentifier(true);", "+\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Get last character of type parameter declaration", "+\t\t\tboolean spaces = false;", "+\t\t\tnextToken: while (true) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tswitch (token = readToken()) {", "+\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) {", "+\t\t\t\t\t\t\t// do not accept type parameter declaration on several lines", "+\t\t\t\t\t\t\thasMultiLines = true;", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tspaces = true;", "+\t\t\t\t\t\tif (valid) break;", "+\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (!spaces) end = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Verify that tag name is well followed by white spaces", "+\t\tif (valid) {", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tint restart = this.scanner.currentPosition;", "+\t\t\tif (readToken() == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\tthis.scanner.currentPosition = restart;", "+\t\t\t\tthis.index = restart;", "+\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "+\t\t\t\treturn pushParamName(isTypeParam);", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\tif (this.sourceParser != null) {", "-\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "+\t\tthis.currentTokenType = -1;", "+\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\twhile (readToken() != TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\tif (this.reportProblems)", "+\t\t\tif (this.jdk15 && isTypeParam)", "+\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\telse", "+\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "+\t\tthis.scanner.currentPosition = start;", "+\t\tthis.index = start;", "+\t\tthis.currentTokenType = -1;", "+\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c27daaa660336dd9735f97faeaca30c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "48b439005b4e27b9edf7ac75008df6663dca3609", "commitAfterChange": "db94ada762c25cbafb7604978ccc4fc3df281550", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": " \tvoid printComment(int kind)", "signatureAfterChange": " \tvoid printComment(int kind, int trailing)", "diff": ["-\tvoid printComment(int kind) {", "+\tvoid printComment(int kind, int trailing) {", "-\t\t\tboolean hasWhitespace = false;", "-\t\t\tint count = 0;", "+\t\t\tboolean hasWhitespaces = false;", "+\t\t\tint lines = 0;", "-\t\t\t\t\t\tcount = 0;", "+\t\t\t\t\t\tint whitespacesStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tint whitespacesEndPosition = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tlines = 0;", "-\t\t\t\t\t\t\t\t\tcount++;", "+\t\t\t\t\t\t\t\t\tlines++;", "-\t\t\t\t\t\t\t\t\tcount++;", "+\t\t\t\t\t\t\t\t\tlines++;", "-\t\t\t\t\t\tif (count == 0) {", "-\t\t\t\t\t\t\thasWhitespace = true;", "-\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "-\t\t\t\t\t\t} else if (hasLineComment) {", "-\t\t\t\t\t\t\tpreserveEmptyLines(count, this.scanner.getCurrentTokenStartPosition());", "-\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "-\t\t\t\t\t\t} else if (hasComment) {", "-\t\t\t\t\t\t\tif (count == 1) {", "-\t\t\t\t\t\t\t\tthis.printNewLine(this.scanner.getCurrentTokenStartPosition());", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t// If following token is a line comment on the same line or the line just after,", "+\t\t\t\t\t\t// then it might be not really formatted as a trailing comment", "+\t\t\t\t\t\tboolean realTrailing = trailing > NO_TRAILING_COMMENT;", "+\t\t\t\t\t\tif (trailing == IMPORT_TRAILING_COMMENT && this.scanner.currentCharacter == '/' && lines <= 1) {", "+\t\t\t\t\t\t\tint currentPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\twhile (token == TerminalTokens.TokenNameCOMMENT_LINE) {", "+\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\t\tchar[] secondWhiteSpaces = this.scanner.getCurrentTokenSource();", "+\t\t\t\t\t\t\t\t\tloop: for (int i = 0, max = secondWhiteSpaces.length; i < max; i++) {", "+\t\t\t\t\t\t\t\t\t\tswitch(secondWhiteSpaces[i]) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\r' :", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\n' :", "+\t\t\t\t\t\t\t\t\t\t\t\trealTrailing = false;", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "-\t\t\t\t\t\t} else if (count != 0 && (!this.formatter.preferences.join_wrapped_lines || this.formatter.preferences.number_of_empty_lines_to_preserve != 0)) {", "-\t\t\t\t\t\t\taddReplaceEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition(), getPreserveEmptyLines(count-1));", "+\t\t\t\t\t\t\tthis.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (realTrailing) {", "+\t\t\t\t\t\t\t// if a line comment is consumed, no other comment can be on the same line after", "+\t\t\t\t\t\t\tif (hasLineComment) {", "+\t\t\t\t\t\t\t\tif (lines >= 1) {", "+\t\t\t\t\t\t\t\t\tcurrentTokenStartPosition = whitespacesStartPosition;", "+\t\t\t\t\t\t\t\t\tpreserveEmptyLines(lines, currentTokenStartPosition);", "+\t\t\t\t\t\t\t\t\taddDeleteEdit(currentTokenStartPosition, whitespacesEndPosition);", "+\t\t\t\t\t\t\t\t\tthis.scanner.resetTo(this.scanner.currentPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\t// if one or several new lines are consumed, following comments cannot be considered as trailing ones", "+\t\t\t\t\t\t\tif (lines >= 1) {", "+\t\t\t\t\t\t\t\tif (hasComment) {", "+\t\t\t\t\t\t\t\t\tthis.printNewLine(whitespacesStartPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// delete consumed white spaces", "+\t\t\t\t\t\t\thasWhitespaces = true;", "+\t\t\t\t\t\t\tcurrentTokenStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\t\t\taddDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);", "-\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\t\t\t\tif (lines == 0) {", "+\t\t\t\t\t\t\t\thasWhitespaces = true;", "+\t\t\t\t\t\t\t\taddDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);", "+\t\t\t\t\t\t\t} else if (hasLineComment) {", "+\t\t\t\t\t\t\t\tcurrentTokenStartPosition = whitespacesStartPosition;", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(lines, currentTokenStartPosition);", "+\t\t\t\t\t\t\t\taddDeleteEdit(currentTokenStartPosition, whitespacesEndPosition);", "+\t\t\t\t\t\t\t} else if (hasComment) {", "+\t\t\t\t\t\t\t\tif (lines == 1) {", "+\t\t\t\t\t\t\t\t\tthis.printNewLine(whitespacesStartPosition);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tpreserveEmptyLines(lines - 1, whitespacesStartPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\taddDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);", "+\t\t\t\t\t\t\t} else if (lines != 0 && (!this.formatter.preferences.join_wrapped_lines || this.formatter.preferences.number_of_empty_lines_to_preserve != 0)) {", "+\t\t\t\t\t\t\t\taddReplaceEdit(whitespacesStartPosition, whitespacesEndPosition, getPreserveEmptyLines(lines-1));", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\taddDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (count >= 1) {", "-\t\t\t\t\t\t\tif (count > 1) {", "-\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "-\t\t\t\t\t\t\t} else if (count == 1) {", "+\t\t\t\t\t\tif (lines >= 1) {", "+\t\t\t\t\t\t\tif (lines > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (lines == 1) {", "-\t\t\t\t\t\t} else if (hasWhitespace) {", "+\t\t\t\t\t\t} else if (hasWhitespaces) {", "-\t\t\t\t\t\thasWhitespace = false;", "+\t\t\t\t\t\thasWhitespaces = false;", "-\t\t\t\t\t\tcount = 0;", "+\t\t\t\t\t\tlines = 0;", "+\t\t\t\t\t\tif (trailing > NO_TRAILING_COMMENT && lines >= 1) {", "+\t\t\t\t\t\t\t// a block comment on next line means that there's no trailing comment", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.scanner.getCurrentTokenStartPosition(), this.scannerEndPosition - 1);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (count >= 1) {", "-\t\t\t\t\t\t\tif (count > 1) {", "-\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "-\t\t\t\t\t\t\t} else if (count == 1) {", "+\t\t\t\t\t\tif (lines >= 1) {", "+\t\t\t\t\t\t\tif (lines > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (lines == 1) {", "-\t\t\t\t\t\t} else if (hasWhitespace) {", "+\t\t\t\t\t\t} else if (hasWhitespaces) {", "-\t\t\t\t\t\thasWhitespace = false;", "+\t\t\t\t\t\thasWhitespaces = false;", "-\t\t\t\t\t\tcount = 0;", "+\t\t\t\t\t\tlines = 0;", "+\t\t\t\t\t\tif (trailing > NO_TRAILING_COMMENT) {", "+\t\t\t\t\t\t\t// a javadoc comment should not be considered as a trailing comment", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.scanner.getCurrentTokenStartPosition(), this.scannerEndPosition - 1);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (count >= 1) {", "-\t\t\t\t\t\t\tif (count > 1) {", "-\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "-\t\t\t\t\t\t\t} else if (count == 1) {", "+\t\t\t\t\t\tif (lines >= 1) {", "+\t\t\t\t\t\t\tif (lines > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (lines == 1) {", "-\t\t\t\t\t\t} else if (hasWhitespace) {", "+\t\t\t\t\t\t} else if (hasWhitespaces) {", "-\t\t\t\t\t\thasWhitespace = false;", "+\t\t\t\t\t\thasWhitespaces = false;", "-\t\t\t\t\t\tcount = 0;", "+\t\t\t\t\t\tlines = 0;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f87a7675d7ae83e42a13a4d28b83a91e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "da3abb814c31b6e1c2d43312de494af316e19273", "commitAfterChange": "8af0e3d96f10bb27360a77bbd330487cf3fdc8dd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference() throws InvalidInputException", "diff": ["-\tprotected boolean parseReference(boolean plain) throws InvalidInputException {", "-\t\tObject typeRef = null;", "-\t\tObject reference = null;", "-\t\tint previousPosition = -1;", "-\t\tint typeRefStartPosition = -1;", "-\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "-\t\t\tpreviousPosition = this.index;", "-\t\t\tint token = readToken();", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t}", "-\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tif (parseHref()) {", "+\tprotected boolean parseReference() throws InvalidInputException {", "+\t\tint currentPosition = this.scanner.currentPosition;", "+\t\ttry {", "+\t\t\tObject typeRef = null;", "+\t\t\tObject reference = null;", "+\t\t\tint previousPosition = -1;", "+\t\t\tint typeRefStartPosition = -1;", "+\t\t\t", "+\t\t\t// Get reference tokens", "+\t\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "+\t\t\t\tpreviousPosition = this.index;", "+\t\t\t\tint token = readToken();", "+\t\t\t\tswitch (token) {", "+\t\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameERROR :", "-\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\treference = parseMember(typeRef);", "-\t\t\t\t\t\tif (reference != null) {", "-\t\t\t\t\t\t\treturn pushSeeRef(reference, plain);", "+\t\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidValueReference(start, getTokenEndPosition());", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tdefault :", "-\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (parseHref()) {", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameERROR :", "+\t\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\treference = parseMember(typeRef);", "+\t\t\t\t\t\t\tif (reference != null) {", "+\t\t\t\t\t\t\t\treturn pushSeeRef(reference);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tif (typeRef == null) {", "+\t\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Verify that we got a reference", "-\t\tif (reference == null) reference = typeRef;", "-\t\tif (reference == null) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+", "+\t\t\t// Verify that we got a reference", "+\t\t\tif (reference == null) reference = typeRef;", "+\t\t\tif (reference == null) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\tif (this.kind == DOM_PARSER) createTag();", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingReference(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Reset position at the end of type reference", "+\t\t\tthis.index = this.lastIdentifierEndPosition+1;", "+\t\t\tthis.scanner.currentPosition = this.index;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingSeeReference(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\treturn false;", "+", "+\t\t\t// In case of @value, we have an invalid reference (only static field refs are valid for this tag)", "+\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(typeRefStartPosition, this.lineEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "+\t\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "+\t\t\tchar ch = peekChar();", "+\t\t\tif (ch == '(') {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that we get white space after reference", "+\t\t\tif (!verifySpaceOrEndComment()) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "+\t\t\t\tif (this.source[end]=='\\n') end--;", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Everything is OK, store reference", "+\t\t\treturn pushSeeRef(reference);", "-", "-\t\t// Reset position at the end of type reference", "-\t\tthis.index = this.lastIdentifierEndPosition+1;", "-\t\tthis.scanner.currentPosition = this.index;", "-\t\tthis.currentTokenType = -1;", "-", "-\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "-\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "-\t\tchar ch = peekChar();", "-\t\tif (ch == '(') {", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// Verify that we get white space after reference", "-\t\tif (!verifySpaceOrEndComment()) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "-\t\t\tif (this.source[end]=='\\n') end--;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Everything is OK, store reference", "-\t\treturn pushSeeRef(reference, plain);", "-\t}", "+\t\tcatch (InvalidInputException ex) {", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(currentPosition, getTokenEndPosition());"]}], "num": 50197}