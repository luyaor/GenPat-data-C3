{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9b74d415fb2f92bfd42e4a72b27e9f67", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "391c032bf25469c643553876e5968222", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "5dd0de42e39b5ae6b6ed70261ede6298820c064c", "commitAfterChange": "2d1b668da982fab23d85fda225f2e9df3073c2e1", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "signatureAfterChange": " public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "diff": ["-", "-    FieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "-\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\tSyntheticMethodBinding accessor =", "-\t\t\tthis.syntheticReadAccessors == null", "-\t\t\t\t? null", "-\t\t\t\t: this.syntheticReadAccessors[this.syntheticReadAccessors.length - 1];", "-\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invoke(Opcodes.OPC_invokestatic, accessor, null /* default declaringClass */);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcodeStream.dup();", "-\t\t\tif (accessor == null) {", "-\t\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t\t} else {", "-\t\t\t\tcodeStream.invoke(Opcodes.OPC_invokestatic, accessor, null /* default declaringClass */);", "-\t\t\t}", "-\t\t}", "-", "-\t\tTypeBinding requiredGenericCast = getGenericCast(this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length);", "-\t\tif (requiredGenericCast != null) codeStream.checkcast(requiredGenericCast);", "-\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-", "-\t\t// duplicate the old field value", "-\t\tint operandType = this.implicitConversion & TypeIds.COMPILE_TYPE_MASK;", "-\t\tif (valueRequired) {", "-\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\tif (operandType == T_long || operandType == T_double) {", "-\t\t\t\t\tcodeStream.dup2();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t}", "-\t\t\t} else { // Stack:  [owner][old field value]  ---> [old field value][owner][old field value]", "-\t\t\t\tif (operandType == T_long || operandType == T_double) {", "-\t\t\t\t\tcodeStream.dup2_x1();", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.dup_x1();", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "-\t\tcodeStream.sendOperator(postIncrement.operator, operandType);", "-\t\tcodeStream.generateImplicitConversion(postIncrement.preAssignImplicitConversion);", "-\t\tfieldStore(codeStream, lastFieldBinding, this.syntheticWriteAccessor, false);", "-\t} else {", "-\t\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "-\t\tif (valueRequired) {", "-\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG) || (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\tcodeStream.dup2();", "-\t\t\t} else {", "-\t\t\t\tcodeStream.dup();", "-\t\t\t}", "-\t\t}", "-\t\tcodeStream.generateEmulationForField(lastFieldBinding);", "-\t\tif ((lastFieldBinding.type == TypeBinding.LONG) || (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\tcodeStream.dup_x2();", "-\t\t\tcodeStream.pop();", "-\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\tcodeStream.aconst_null();", "-\t\t\t} else {", "-\t\t\t\tgenerateReadSequence(currentScope, codeStream);", "-\t\t\t}", "-\t\t\tcodeStream.dup_x2();", "-\t\t\tcodeStream.pop();", "-\t\t} else {", "-\t\t\tcodeStream.dup_x1();", "-\t\t\tcodeStream.pop();", "-\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\tcodeStream.aconst_null();", "-\t\t\t} else {", "-\t\t\t\tgenerateReadSequence(currentScope, codeStream);", "-\t\t\t}", "-\t\t\tcodeStream.dup_x1();", "-\t\t\tcodeStream.pop();", "-\t\t}", "-\t\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "-\t\tcodeStream.sendOperator(postIncrement.operator, lastFieldBinding.type.id);", "-\t\tcodeStream.generateImplicitConversion(postIncrement.preAssignImplicitConversion);", "-\t\tcodeStream.generateEmulatedWriteAccessForField(lastFieldBinding);", "+    FieldBinding lastFieldBinding = this.otherBindings == null ? (FieldBinding) this.binding : this.otherBindings[this.otherBindings.length-1];", "+\tif (lastFieldBinding.canBeSeenBy(getFinalReceiverType(), this, currentScope)) {", "+\t\tsuper.generatePostIncrement(currentScope, codeStream, postIncrement, valueRequired);", "+\t\treturn;", "+\tlastFieldBinding = generateReadSequence(currentScope, codeStream);", "+\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "+\tif (valueRequired) {", "+\t\tswitch (lastFieldBinding.type.id) {", "+\t\t\tcase TypeIds.T_long :", "+\t\t\tcase TypeIds.T_double :", "+\t\t\t\tcodeStream.dup2();", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\tcodeStream.dup();", "+\t\t\tbreak;\t", "+\t\t}\t\t", "+\t}", "+\tcodeStream.generateEmulationForField(lastFieldBinding);", "+\tif ((lastFieldBinding.type == TypeBinding.LONG) || (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "+\t\tcodeStream.dup_x2();", "+\t\tcodeStream.pop();", "+\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tcodeStream.aconst_null();", "+\t\t} else {", "+\t\t\tgenerateReadSequence(currentScope, codeStream);", "+\t\t}", "+\t\tcodeStream.dup_x2();", "+\t\tcodeStream.pop();", "+\t} else {", "+\t\tcodeStream.dup_x1();", "+\t\tcodeStream.pop();", "+\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tcodeStream.aconst_null();", "+\t\t} else {", "+\t\t\tgenerateReadSequence(currentScope, codeStream);", "+\t\t}", "+\t\tcodeStream.dup_x1();", "+\t\tcodeStream.pop();", "+\t}", "+\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "+\tcodeStream.sendOperator(postIncrement.operator, lastFieldBinding.type.id);", "+\tcodeStream.generateImplicitConversion(postIncrement.preAssignImplicitConversion);", "+\tcodeStream.generateEmulatedWriteAccessForField(lastFieldBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb522244cba66b55f35a6354921eb9fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "386973a3070496c014c76dfef6b370eb80aa95d3", "commitAfterChange": "1e351d47b6a42ac5f4bfe0ec77b007aad61afe06", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["+\t\t\tthis.generateCode(classScope, classFile, clinitOffset);\r", "+\t\t} catch (AbortMethod e) {\r", "+\t\t\t// should never occur\r", "+\t\t\t// the clinit referenceContext is the type declaration\r", "+\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t\t// decrement the number of method info as well.\r", "+\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t\t// cases.\r", "+\t\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {\r", "+\t\t\t\t// a branch target required a goto_w, restart code gen in wide mode.\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tif (statements != null) {\r", "+\t\t\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "+\t\t\t\t\t\t\tstatements[i].resetStateForCodeGeneration();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode \r", "+\t\t\t\t\tthis.generateCode(classScope, classFile, clinitOffset); // restart method generation\r", "+\t\t\t\t} catch(AbortMethod e2) {\r", "+\t\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// produce a problem method accounting for this fatal error\r", "+\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "-\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\tclassFile.methodCount--;\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0f688c611a884efb6ced814efd86b61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "26e0b0c271d5031424823a1070ef180ba24218bf", "commitAfterChange": "c84496f37e5dff715764911530c1fceaa60b14ee", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "diff": ["-\t\tLabel falseLabel, endLabel;", "-\t\tbits |= OnlyValueRequired;", "-\t\t\t\t\t\tgenerateOptimizedLogicalAnd(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 && false;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalAnd(currentScope, codeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tgenerateOptimizedLogicalOr(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 || true;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalOr(currentScope, codeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tgenerateOptimizedLogicalXor(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t(falseLabel = new Label(codeStream)),", "-\t\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\t\t/* improving code gen for such a case: boolean b = i < 0 ^ bool;", "-\t\t\t\t\t\t * since the label has never been used, we have the inlined value on the stack. */", "-\t\t\t\t\t\tif (falseLabel.hasForwardReferences()) {", "-\t\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\t\tcodeStream.iconst_1();", "-\t\t\t\t\t\t\t\tif ((bits & IsReturnedValue) != 0) {", "-\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.goto_(endLabel = new Label(codeStream));", "-\t\t\t\t\t\t\t\t\tcodeStream.decrStackSize(1);", "-\t\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t\t\tcodeStream.iconst_0();", "-\t\t\t\t\t\t\t\t\tendLabel.place();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tfalseLabel.place();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tgenerateLogicalXor(currentScope, \tcodeStream, valueRequired);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tLabel falseLabel, endLabel;"]}], "num": 55758}