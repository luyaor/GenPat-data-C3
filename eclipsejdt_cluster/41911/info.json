{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba2be428e2bdd50435edae13a2df3614", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4ae2276faa440ad1b883f740f9a25cd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "a8ed5c9ce2b125913ea11ffa5f66b79c1153133a", "commitAfterChange": "aff037e4075d974a1198e8a25c9e7f07acc35fc1", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 13, "signatureBeforeChange": "  void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": "  void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod,  \t\tboolean hasNonNullDefault, boolean complain, MethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "diff": ["-void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod) {", "-\t// precondition: caller has checked whether annotation-based null analysis is enabled.", "-\tlong inheritedBits = inheritedMethod.tagBits;", "-\tlong currentBits = currentMethod.tagBits;", "-\tAbstractMethodDeclaration srcMethod = null;", "-\tif (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?", "-\t\tsrcMethod = currentMethod.sourceMethod();", "-", "-\t// return type:", "-\tif ((inheritedBits & TagBits.AnnotationNonNull) != 0) {", "-\t\tlong currentNullBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);", "-\t\tif (currentNullBits != TagBits.AnnotationNonNull) {", "-\t\t\tif (srcMethod != null) {", "-\t\t\t\tthis.type.scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.environment.getNonNullAnnotationName());", "-\t\t\t} else {", "-\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "+void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod, ", "+\t\tboolean hasNonNullDefault, boolean complain, MethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "+{", "+\tcomplain &= !currentMethod.isConstructor();", "+\tif (!hasNonNullDefault && !complain && !this.environment.globalOptions.inheritNullAnnotations) {", "+\t\t// nothing to be done, take the shortcut", "+\t\tcurrentMethod.tagBits |= TagBits.IsNullnessKnown;", "+\t\treturn;", "-", "-\t// parameters:", "-\tArgument[] currentArguments = srcMethod == null ? null : srcMethod.arguments;", "-\tif (inheritedMethod.parameterNonNullness != null) {", "-\t\t// inherited method has null-annotations, check compatibility:", "-", "-\t\tint length = inheritedMethod.parameterNonNullness.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tArgument currentArgument = currentArguments == null ? null : currentArguments[i];", "-", "-\t\t\tBoolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];", "-\t\t\tBoolean currentNonNullNess = (currentMethod.parameterNonNullness == null)", "-\t\t\t\t\t\t\t\t\t\t? null : currentMethod.parameterNonNullness[i];", "-\t\t\tif (inheritedNonNullNess != null) {\t\t\t\t// super has a null annotation", "-\t\t\t\tif (currentNonNullNess == null) {\t\t\t// current parameter lacks null annotation", "-\t\t\t\t\tboolean needNonNull = false;", "-\t\t\t\t\tchar[][] annotationName;", "-\t\t\t\t\tif (inheritedNonNullNess == Boolean.TRUE) {", "-\t\t\t\t\t\tneedNonNull = true;", "-\t\t\t\t\t\tannotationName = this.environment.getNonNullAnnotationName();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tannotationName = this.environment.getNullableAnnotationName();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (currentArgument != null) {", "-\t\t\t\t\t\tthis.type.scope.problemReporter().parameterLackingNullAnnotation(", "-\t\t\t\t\t\t\t\tcurrentArgument,", "-\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\tneedNonNull,", "-\t\t\t\t\t\t\t\tannotationName);", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (inheritedNonNullNess != Boolean.TRUE) {\t\t// super parameter is not restricted to @NonNull", "-\t\t\t\tif (currentNonNullNess == Boolean.TRUE) { \t// current parameter is restricted to @NonNull", "-\t\t\t\t\tif (currentArgument != null)", "-\t\t\t\t\t\tthis.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentArgument,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedNonNullNess == null", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t? null", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t: this.environment.getNullableAnnotationName());", "-\t\t\t\t\telse", "-\t\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t} else if (currentMethod.parameterNonNullness != null) {", "-\t\t// super method has no annotations but current has", "-\t\tfor (int i = 0; i < currentMethod.parameterNonNullness.length; i++) {", "-\t\t\tif (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // tightening from unconstrained to @NonNull", "-\t\t\t\tif (currentArguments != null) {", "-\t\t\t\t\tthis.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentArguments[i],", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t// in this context currentMethod can be inherited, too. Recurse if needed.", "+\tif (currentMethod.declaringClass != this.type ", "+\t\t\t&& (currentMethod.tagBits & TagBits.IsNullnessKnown) == 0) ", "+\t{", "+\t\tthis.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, this.type.scope);", "+\tsuper.checkNullSpecInheritance(currentMethod, srcMethod, hasNonNullDefault, complain, inheritedMethod, scope, inheritedNonNullnessInfos);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbcef32037bf629f3a68768498e9daf0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "8542678e2ceb736a9d19d031551da2cab5ea4a72", "commitAfterChange": "4ac6f89083748b9c4fc37b738ed82ea1a7c9c63b", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 13, "signatureBeforeChange": "  void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": "  void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod,  \t\tboolean hasNonNullDefault, boolean complain, MethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "diff": ["-void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod) {", "-\t// precondition: caller has checked whether annotation-based null analysis is enabled.", "-\tlong inheritedBits = inheritedMethod.tagBits;", "-\tlong currentBits = currentMethod.tagBits;", "-\tAbstractMethodDeclaration srcMethod = null;", "-\tif (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?", "-\t\tsrcMethod = currentMethod.sourceMethod();", "-", "-\t// return type:", "-\tif ((inheritedBits & TagBits.AnnotationNonNull) != 0) {", "-\t\tlong currentNullBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);", "-\t\tif (currentNullBits != TagBits.AnnotationNonNull) {", "-\t\t\tif (srcMethod != null) {", "-\t\t\t\tthis.type.scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.environment.getNonNullAnnotationName());", "-\t\t\t} else {", "-\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "+void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod, ", "+\t\tboolean hasNonNullDefault, boolean complain, MethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "+{", "+\tcomplain &= !currentMethod.isConstructor();", "+\tif (!hasNonNullDefault && !complain && !this.environment.globalOptions.inheritNullAnnotations) {", "+\t\t// nothing to be done, take the shortcut", "+\t\tcurrentMethod.tagBits |= TagBits.IsNullnessKnown;", "+\t\treturn;", "-", "-\t// parameters:", "-\tArgument[] currentArguments = srcMethod == null ? null : srcMethod.arguments;", "-\tif (inheritedMethod.parameterNonNullness != null) {", "-\t\t// inherited method has null-annotations, check compatibility:", "-", "-\t\tint length = inheritedMethod.parameterNonNullness.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tArgument currentArgument = currentArguments == null ? null : currentArguments[i];", "-", "-\t\t\tBoolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];", "-\t\t\tBoolean currentNonNullNess = (currentMethod.parameterNonNullness == null)", "-\t\t\t\t\t\t\t\t\t\t? null : currentMethod.parameterNonNullness[i];", "-\t\t\tif (inheritedNonNullNess != null) {\t\t\t\t// super has a null annotation", "-\t\t\t\tif (currentNonNullNess == null) {\t\t\t// current parameter lacks null annotation", "-\t\t\t\t\tboolean needNonNull = false;", "-\t\t\t\t\tchar[][] annotationName;", "-\t\t\t\t\tif (inheritedNonNullNess == Boolean.TRUE) {", "-\t\t\t\t\t\tneedNonNull = true;", "-\t\t\t\t\t\tannotationName = this.environment.getNonNullAnnotationName();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tannotationName = this.environment.getNullableAnnotationName();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (currentArgument != null) {", "-\t\t\t\t\t\tthis.type.scope.problemReporter().parameterLackingNullAnnotation(", "-\t\t\t\t\t\t\t\tcurrentArgument,", "-\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\tneedNonNull,", "-\t\t\t\t\t\t\t\tannotationName);", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (inheritedNonNullNess != Boolean.TRUE) {\t\t// super parameter is not restricted to @NonNull", "-\t\t\t\tif (currentNonNullNess == Boolean.TRUE) { \t// current parameter is restricted to @NonNull", "-\t\t\t\t\tif (currentArgument != null)", "-\t\t\t\t\t\tthis.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentArgument,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedNonNullNess == null", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t? null", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t: this.environment.getNullableAnnotationName());", "-\t\t\t\t\telse", "-\t\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t} else if (currentMethod.parameterNonNullness != null) {", "-\t\t// super method has no annotations but current has", "-\t\tfor (int i = 0; i < currentMethod.parameterNonNullness.length; i++) {", "-\t\t\tif (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // tightening from unconstrained to @NonNull", "-\t\t\t\tif (currentArguments != null) {", "-\t\t\t\t\tthis.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentArguments[i],", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinheritedMethod.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnull);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t// in this context currentMethod can be inherited, too. Recurse if needed.", "+\tif (currentMethod.declaringClass != this.type ", "+\t\t\t&& (currentMethod.tagBits & TagBits.IsNullnessKnown) == 0) ", "+\t{", "+\t\tthis.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, this.type.scope);", "+\tsuper.checkNullSpecInheritance(currentMethod, srcMethod, hasNonNullDefault, complain, inheritedMethod, scope, inheritedNonNullnessInfos);"]}], "num": 41911}