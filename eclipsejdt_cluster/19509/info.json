{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0dc9d74dc2af71dc4676e7fd39cd36a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5535827acd636764b4824d25d6e0e35", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5a10f519c81ebdddb6bd4a37e304977f9bce5290", "commitAfterChange": "7b4e4fcfdd4d04f13dc930d8b751701d20daa4d2", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\t\t} else if (method.isStatic()) {", "+\t\t\t\t\t\t// detect collision between static import methods", "+\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "+\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t// its possible with 2 abstract methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// its possible with 2 methods that one does not inherit from the other", "+\t\t\t\t\t\t\t// see cases in verify test #43", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tif (superType != null) {", "+\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "+\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7b4a05d21d329c9e9eeddf71c1b162b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "db070c14a39516a8671547f6d3e4a976ae6ad4f6", "commitAfterChange": "2936dc77d585d1bce84296ec1690cb761872a148", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-//\t\t\t\t\t} else if (method.isStatic()) {", "-//\t\t\t\t\t\t// detect collision between static import methods", "-//\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "-//\t\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\t} else if (method.isStatic()) {", "+\t\t\t\t\t\t// detect collision between static import methods", "+\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "+\t\t\t\t\t\t\tcontinue nextVisible;"]}], "num": 19509}