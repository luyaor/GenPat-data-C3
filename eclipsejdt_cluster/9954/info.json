{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4803dffabefb2f041f578b68a990092c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8270751895ce89c938c7ebedc7360793", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\t  \tpublic void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired)", "signatureAfterChange": "\t  public void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired)", "diff": ["-\tpublic void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired) {", "-\t", "-\t\t// optimizing assignment like: i = i + 1 or i = 1 + i", "-\t\tif (assignment.expression.isCompactableOperation()) {", "-\t\t\tBinaryExpression operation = (BinaryExpression) assignment.expression;", "-\t\t\tint operator = (operation.bits & OperatorMASK) >> OperatorSHIFT;", "-\t\t\tSingleNameReference variableReference;", "-\t\t\tif ((operation.left instanceof SingleNameReference) && ((variableReference = (SingleNameReference) operation.left).binding == binding)) {", "-\t\t\t\t// i = i + value, then use the variable on the right hand side, since it has the correct implicit conversion", "-\t\t\t\tvariableReference.generateCompoundAssignment(currentScope, codeStream, syntheticAccessors == null ? null : syntheticAccessors[WRITE], operation.right, operator, operation.implicitConversion, valueRequired);", "-\t\t\t\tif (valueRequired) {", "-\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\treturn;", "-\t\t\t} ", "-\t\t\tif ((operation.right instanceof SingleNameReference)", "-\t\t\t\t\t&& ((operator == PLUS) || (operator == MULTIPLY)) // only commutative operations", "-\t\t\t\t\t&& ((variableReference = (SingleNameReference) operation.right).binding == binding)", "-\t\t\t\t\t&& (operation.left.constant != Constant.NotAConstant) // exclude non constant expressions, since could have side-effect", "-\t\t\t\t\t&& (((operation.left.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) != T_JavaLangString) // exclude string concatenation which would occur backwards", "-\t\t\t\t\t&& (((operation.right.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) != T_JavaLangString)) { // exclude string concatenation which would occur backwards", "-\t\t\t\t// i = value + i, then use the variable on the right hand side, since it has the correct implicit conversion", "-\t\t\t\tvariableReference.generateCompoundAssignment(currentScope, codeStream, syntheticAccessors == null ? null : syntheticAccessors[WRITE], operation.left, operator, operation.implicitConversion, valueRequired);", "-\t\t\t\tif (valueRequired) {", "-\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tFieldBinding fieldBinding;", "-\t\t\t\tint pc = codeStream.position;", "-\t\t\t\tif (!(fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) { // need a receiver?", "-\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "-\t\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "-\t\t\t\t\t\tthis.generateReceiver(codeStream);", "-\t\t\t\t}", "-\t\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "-\t\t\t\tfieldStore(codeStream, fieldBinding, syntheticAccessors == null ? null : syntheticAccessors[WRITE], valueRequired);", "-\t\t\t\tif (valueRequired) {", "-\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "-\t\t\t\t}", "-\t\t\t\t// no need for generic cast as value got dupped", "-\t\t\t\treturn;", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "-\t\t\t\tif (localBinding.resolvedPosition != -1) {", "-\t\t\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t\tif (assignment.expression.constant != Constant.NotAConstant) {", "-\t\t\t\t\t\t// assigning an unused local to a constant value = no actual assignment is necessary", "-\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\tcodeStream.generateConstant(assignment.expression.constant, assignment.implicitConversion);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t\t\t/* Even though the value may not be required, we force it to be produced, and discard it later", "-\t\t\t\t\t\ton if it was actually not necessary, so as to provide the same behavior as JDK1.2beta3.\t*/", "-\t\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion); // implicit conversion", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif ((localBinding.type == TypeBinding.LONG) || (localBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\t\t\tcodeStream.pop2();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\treturn;", "-\t\t\t\t// 26903, need extra cast to store null in array local var\t", "-\t\t\t\tif (localBinding.type.isArrayType() ", "-\t\t\t\t\t&& (assignment.expression.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "-\t\t\t\t\t\t|| ((assignment.expression instanceof CastExpression)\t// arrayLoc = (type[])null", "-\t\t\t\t\t\t\t&& (((CastExpression)assignment.expression).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "-\t\t\t\t\tcodeStream.checkcast(localBinding.type); ", "-\t\t\t\t", "-\t\t\t\t// normal local assignment (since cannot store in outer local which are final locations)", "-\t\t\t\tcodeStream.store(localBinding, valueRequired);", "-\t\t\t\tif ((bits & FirstAssignmentToLocal) != 0) { // for local variable debug attributes", "-\t\t\t\t\tlocalBinding.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t// implicit conversion", "-\t\t\t\tif (valueRequired) {", "-\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "-\t\t\t\t}", "+", "+public void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired) {", "+\t// optimizing assignment like: i = i + 1 or i = 1 + i", "+\tif (assignment.expression.isCompactableOperation()) {", "+\t\tBinaryExpression operation = (BinaryExpression) assignment.expression;", "+\t\tint operator = (operation.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;", "+\t\tSingleNameReference variableReference;", "+\t\tif ((operation.left instanceof SingleNameReference) && ((variableReference = (SingleNameReference) operation.left).binding == this.binding)) {", "+\t\t\t// i = i + value, then use the variable on the right hand side, since it has the correct implicit conversion", "+\t\t\tvariableReference.generateCompoundAssignment(currentScope, codeStream, this.syntheticAccessors == null ? null : this.syntheticAccessors[SingleNameReference.WRITE], operation.right, operator, operation.implicitConversion, valueRequired);", "+\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "+\t\t\t}\t\t\t\t", "+\t\t\treturn;", "+\t\t} ", "+\t\tif ((operation.right instanceof SingleNameReference)", "+\t\t\t\t&& ((operator == OperatorIds.PLUS) || (operator == OperatorIds.MULTIPLY)) // only commutative operations", "+\t\t\t\t&& ((variableReference = (SingleNameReference) operation.right).binding == this.binding)", "+\t\t\t\t&& (operation.left.constant != Constant.NotAConstant) // exclude non constant expressions, since could have side-effect", "+\t\t\t\t&& (((operation.left.implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4) != TypeIds.T_JavaLangString) // exclude string concatenation which would occur backwards", "+\t\t\t\t&& (((operation.right.implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4) != TypeIds.T_JavaLangString)) { // exclude string concatenation which would occur backwards", "+\t\t\t// i = value + i, then use the variable on the right hand side, since it has the correct implicit conversion", "+\t\t\tvariableReference.generateCompoundAssignment(currentScope, codeStream, this.syntheticAccessors == null ? null : this.syntheticAccessors[SingleNameReference.WRITE], operation.left, operator, operation.implicitConversion, valueRequired);", "+\t\t\tif (valueRequired) {", "+\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "+\t\t\t}\t\t\t\t", "+\t\t\treturn;", "+\t\t}", "+\t}", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tFieldBinding fieldBinding;", "+\t\t\tint pc = codeStream.position;", "+\t\t\tif (!(fieldBinding = (FieldBinding) this.codegenBinding).isStatic()) { // need a receiver?", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "+\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.generateReceiver(codeStream);", "+\t\t\t\t}", "+\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "+\t\t\tfieldStore(codeStream, fieldBinding, this.syntheticAccessors == null ? null : this.syntheticAccessors[SingleNameReference.WRITE], valueRequired);", "+\t\t\tif (valueRequired) {", "+\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "+\t\t\t}", "+\t\t\t// no need for generic cast as value got dupped", "+\t\tcase Binding.LOCAL : // assigning to a local variable", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+\t\t\tif (localBinding.resolvedPosition != -1) {", "+\t\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "+\t\t\t} else {", "+\t\t\t\tif (assignment.expression.constant != Constant.NotAConstant) {", "+\t\t\t\t\t// assigning an unused local to a constant value = no actual assignment is necessary", "+\t\t\t\t\tif (valueRequired) {", "+\t\t\t\t\t\tcodeStream.generateConstant(assignment.expression.constant, assignment.implicitConversion);", "+\t\t\t\t} else {", "+\t\t\t\t\tassignment.expression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t\t/* Even though the value may not be required, we force it to be produced, and discard it later", "+\t\t\t\t\ton if it was actually not necessary, so as to provide the same behavior as JDK1.2beta3.\t*/", "+\t\t\t\t\tif (valueRequired) {", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion); // implicit conversion", "+\t\t\t\t\t\tif ((localBinding.type == TypeBinding.LONG) || (localBinding.type == TypeBinding.DOUBLE)) {", "+\t\t\t\t\t\t\tcodeStream.pop2();", "+\t\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\t// 26903, need extra cast to store null in array local var\t", "+\t\t\tif (localBinding.type.isArrayType() ", "+\t\t\t\t&& (assignment.expression.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "+\t\t\t\t\t|| ((assignment.expression instanceof CastExpression)\t// arrayLoc = (type[])null", "+\t\t\t\t\t\t&& (((CastExpression)assignment.expression).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "+\t\t\t\tcodeStream.checkcast(localBinding.type); ", "+\t\t\t}", "+\t\t\t", "+\t\t\t// normal local assignment (since cannot store in outer local which are final locations)", "+\t\t\tcodeStream.store(localBinding, valueRequired);", "+\t\t\tif ((this.bits & ASTNode.FirstAssignmentToLocal) != 0) { // for local variable debug attributes", "+\t\t\t\tlocalBinding.recordInitializationStartPC(codeStream.position);", "+\t\t\t}", "+\t\t\t// implicit conversion", "+\t\t\tif (valueRequired) {", "+\t\t\t\tcodeStream.generateImplicitConversion(assignment.implicitConversion);", "+\t\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e580d4d47e7871f5f3edc2e344fa5369", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "80c078ddcf769ceb84a30bdd1354fc49a196e760", "commitAfterChange": "1e3ac51cb3938f7e9fd57cd2551e590148671265", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "\r public int computeSeverity(int problemId)", "signatureAfterChange": "\r public int computeSeverity(int problemId)", "diff": ["-\t\tcase UnreachableCatch :\r", "-\t\tcase CodeCannotBeReached :\r", "+\t\tcase IProblem.UnreachableCatch :\r", "+\t\tcase IProblem.CodeCannotBeReached :\r", "-\t\tcase MaskedCatch : \r", "+\t\tcase IProblem.MaskedCatch : \r", "-\t\tcase ImportProblemBase + NotFound :\r", "-\t\tcase ImportProblemBase + NotVisible :\r", "-\t\tcase ImportProblemBase + Ambiguous :\r", "-\t\tcase ImportProblemBase + InternalNameProvided :\r", "-\t\tcase ImportProblemBase + InheritedNameHidesEnclosingName :\r", "-\t\tcase DuplicateImport :\r", "-\t\tcase ConflictingImport :\r", "-\t\tcase CannotImportPackage :\r", "+\t\tcase IProblem.ImportProblemBase + NotFound :\r", "+\t\tcase IProblem.ImportProblemBase + NotVisible :\r", "+\t\tcase IProblem.ImportProblemBase + Ambiguous :\r", "+\t\tcase IProblem.ImportProblemBase + InternalNameProvided :\r", "+\t\tcase IProblem.ImportProblemBase + InheritedNameHidesEnclosingName :\r", "+\t\tcase IProblem.DuplicateImport :\r", "+\t\tcase IProblem.ConflictingImport :\r", "+\t\tcase IProblem.CannotImportPackage :\r", "-\t\tcase MethodButWithConstructorName :\r", "+\t\tcase IProblem.MethodButWithConstructorName :\r", "-\t\tcase OverridingNonVisibleMethod :\r", "+\t\tcase IProblem.OverridingNonVisibleMethod :\r", "-\t\tcase OverridingDeprecatedMethod :\t\t\t\t\r", "-\t\tcase UsingDeprecatedType :\t\t\t\t\r", "-\t\tcase UsingDeprecatedMethod :\r", "-\t\tcase UsingDeprecatedConstructor :\r", "-\t\tcase UsingDeprecatedField :\r", "+\t\tcase IProblem.OverridingDeprecatedMethod :\t\t\t\t\r", "+\t\tcase IProblem.UsingDeprecatedType :\t\t\t\t\r", "+\t\tcase IProblem.UsingDeprecatedMethod :\r", "+\t\tcase IProblem.UsingDeprecatedConstructor :\r", "+\t\tcase IProblem.UsingDeprecatedField :\r", "-\t\tcase LocalVariableIsNeverUsed :\r", "+\t\tcase IProblem.LocalVariableIsNeverUsed :\r", "-\t\tcase ArgumentIsNeverUsed :\r", "+\t\tcase IProblem.ArgumentIsNeverUsed :\r", "-\t\tcase NoImplicitStringConversionForCharArrayExpression :\r", "+\t\tcase IProblem.NoImplicitStringConversionForCharArrayExpression :\r", "-\t\tcase NeedToEmulateFieldReadAccess :\r", "-\t\tcase NeedToEmulateFieldWriteAccess :\r", "-\t\tcase NeedToEmulateMethodAccess :\r", "-\t\tcase NeedToEmulateConstructorAccess :\t\t\t\r", "+\t\tcase IProblem.NeedToEmulateFieldReadAccess :\r", "+\t\tcase IProblem.NeedToEmulateFieldWriteAccess :\r", "+\t\tcase IProblem.NeedToEmulateMethodAccess :\r", "+\t\tcase IProblem.NeedToEmulateConstructorAccess :\t\t\t\r", "-\t\tcase NonExternalizedStringLiteral :\r", "+\t\tcase IProblem.NonExternalizedStringLiteral :\r", "-\t\tcase UseAssertAsAnIdentifier :\r", "+\t\tcase IProblem.UseAssertAsAnIdentifier :\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee2882aa7e1f19bf6f94ec38d1c76f90", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "5dba2fb9ff4a65e2ec3c984b606cb269bb911a06", "commitAfterChange": "de6638c19ddd648da6cdf9ca6437e426c1cc8e15", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["-\tif (binding.isPrivate()) {", "+\tif (this.binding.isPrivate()) {", "-\t\t\t\t&& binding.constant() == Constant.NotAConstant) {", "-\t\t\tif (syntheticAccessors == null)", "-\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "+\t\t\t\t&& this.binding.constant() == Constant.NotAConstant) {", "+\t\t\tif (this.syntheticAccessors == null)", "+\t\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\t\tthis.syntheticAccessors[isReadAccess ? FieldReference.READ : FieldReference.WRITE] = ", "-\t} else if (receiver instanceof QualifiedSuperReference) { // qualified super", "+\t} else if (this.receiver instanceof QualifiedSuperReference) { // qualified super", "-\t\t\t(SourceTypeBinding) (((QualifiedSuperReference) receiver)", "+\t\t\t(SourceTypeBinding) (((QualifiedSuperReference) this.receiver)", "-\t\tif (syntheticAccessors == null)", "-\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = destinationType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\tif (this.syntheticAccessors == null)", "+\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\tthis.syntheticAccessors[isReadAccess ? FieldReference.READ : FieldReference.WRITE] = destinationType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "-\t} else if (binding.isProtected()) {", "+\t} else if (this.binding.isProtected()) {", "-\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t&& binding.declaringClass.getPackage()", "+\t\tif (((this.bits & ASTNode.DepthMASK) != 0)", "+\t\t\t&& this.binding.declaringClass.getPackage()", "-\t\t\t\t\t(bits & DepthMASK) >> DepthSHIFT);", "-\t\t\tif (syntheticAccessors == null)", "-\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = currentCompatibleType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\t\t\t(this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\tif (this.syntheticAccessors == null)", "+\t\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\t\tthis.syntheticAccessors[isReadAccess ? FieldReference.READ : FieldReference.WRITE] = currentCompatibleType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "-\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(receiver.isImplicitThis() && this.codegenBinding.isStatic()))", "-\t\t\t\t&& this.binding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(this.receiver.isImplicitThis() && this.codegenBinding.isStatic()))", "+\t\t\t\t&& this.binding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields"]}], "num": 9954}