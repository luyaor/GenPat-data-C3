{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "757a5c4a688144bc86f941a92cdaa62d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f371d78d87ce9f89743bf9c1290d76e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c48ecebe36df1bdca1948a66baeb643827a9b9c4", "commitAfterChange": "df8a00dea42b2c33f742d8ce1045c2aa42b28f3e", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 75, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["+\t\t\t\tReferenceBinding[] mostSpecificExceptions = null;", "+\t\t\t\tSimpleSet possibleMethods = null;", "-\t\t\t\t\t\tif (original2 == null || !original.areParameterErasuresEqual(original2) || !original.returnType.isCompatibleWith(original2.returnType)) // 15.2.2", "+\t\t\t\t\t\tif (original2 == null || !original.areParameterErasuresEqual(original2))", "+\t\t\t\t\t\tif (!original.returnType.isCompatibleWith(original2.returnType)) // 15.12.2", "+\t\t\t\t\t\t\tcontinue nextSpecific; // choose original2 instead", "+\t\t\t\t\t\tif (original.thrownExceptions != original2.thrownExceptions) {", "+\t\t\t\t\t\t\tif (mostSpecificExceptions == null)", "+\t\t\t\t\t\t\t\tmostSpecificExceptions = original.thrownExceptions;", "+\t\t\t\t\t\t\tif (possibleMethods == null)", "+\t\t\t\t\t\t\t\tpossibleMethods = new SimpleSet(3);", "+\t\t\t\t\t\t\tint mostSpecificLength = mostSpecificExceptions.length;", "+\t\t\t\t\t\t\tint original2Length = original2.thrownExceptions.length;", "+\t\t\t\t\t\t\tSimpleSet temp = new SimpleSet(mostSpecificLength);", "+\t\t\t\t\t\t\tnextException : for (int t = 0; t < mostSpecificLength; t++) {", "+\t\t\t\t\t\t\t\tReferenceBinding exception = mostSpecificExceptions[t];", "+\t\t\t\t\t\t\t\tfor (int s = 0; s < original2Length; s++) {", "+\t\t\t\t\t\t\t\t\tif (exception.isCompatibleWith(original2.thrownExceptions[s])) {", "+\t\t\t\t\t\t\t\t\t\tpossibleMethods.add(current);", "+\t\t\t\t\t\t\t\t\t\ttemp.add(exception);", "+\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "+\t\t\t\t\t\t\t\t\t} else if (original2.thrownExceptions[s].isCompatibleWith(exception)) {", "+\t\t\t\t\t\t\t\t\t\tpossibleMethods.add(next);", "+\t\t\t\t\t\t\t\t\t\ttemp.add(original2.thrownExceptions[s]);", "+\t\t\t\t\t\t\t\t\t\tcontinue nextException;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tmostSpecificExceptions = temp.elementSize == 0 ? Binding.NO_EXCEPTIONS : new ReferenceBinding[temp.elementSize];", "+\t\t\t\t\t\t\ttemp.asArray(mostSpecificExceptions);", "+\t\t\t\t\t\t}", "+\t\t\t\tif (mostSpecificExceptions != null) {", "+\t\t\t\t\tObject[] values = possibleMethods.values;", "+\t\t\t\t\tint exceptionLength = mostSpecificExceptions.length;", "+\t\t\t\t\tnextMethod : for (int p = 0, vLength = values.length; p < vLength; p++) {", "+\t\t\t\t\t\tMethodBinding possible = (MethodBinding) values[p];", "+\t\t\t\t\t\tif (possible == null) continue nextMethod;", "+\t\t\t\t\t\tReferenceBinding[] itsExceptions = possible.thrownExceptions;", "+\t\t\t\t\t\tif (itsExceptions.length == exceptionLength) {", "+\t\t\t\t\t\t\tnextException : for (int e = 0; e < exceptionLength; e++) {", "+\t\t\t\t\t\t\t\tReferenceBinding exception = itsExceptions[e];", "+\t\t\t\t\t\t\t\tfor (int f = 0; f < exceptionLength; f++)", "+\t\t\t\t\t\t\t\t\tif (exception == mostSpecificExceptions[f]) continue nextException;", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn possible;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+// do not return a new methodBinding until we know that it does not cause problems", "+//\t\t\t\t\treturn new MethodBinding(", "+//\t\t\t\t\t\tcurrent.modifiers,", "+//\t\t\t\t\t\tcurrent.selector,", "+//\t\t\t\t\t\tcurrent.returnType,", "+//\t\t\t\t\t\tcurrent.parameters,", "+//\t\t\t\t\t\tmostSpecificExceptions,", "+//\t\t\t\t\t\tcurrent.declaringClass", "+//\t\t\t\t\t);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53c76e0b12297c0d7d24b4eba615ff6f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java", "commitBeforeChange": "11c24986fc925cfc43f4c88e72e0daee39a1576b", "commitAfterChange": "55350d5af8386833b94a470ab6a0d389ee3fc665", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 53, "signatureBeforeChange": " \tprotected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String[] libraries, final String[] projects, final boolean[] exportedProjects, final String projectOutput, final String[] sourceOutputs, final String[][] inclusionPatterns, final String[][] exclusionPatterns, final String compliance) throws CoreException", "signatureAfterChange": " \tprotected IJavaProject createJavaProject( \t\t\tfinal String projectName, \t\t\tfinal String[] sourceFolders, \t\t\tfinal String[] libraries, \t\t\tfinal String[][] librariesInclusionPatterns, \t\t\tfinal String[][] librariesExclusionPatterns, \t\t\tfinal String[] projects, \t\t\tfinal String[][] projectsInclusionPatterns, \t\t\tfinal String[][] projectsExclusionPatterns, \t\t\tfinal boolean[] exportedProjects, \t\t\tfinal String projectOutput, \t\t\tfinal String[] sourceOutputs, \t\t\tfinal String[][] inclusionPatterns, \t\t\tfinal String[][] exclusionPatterns, \t\t\tfinal String compliance) throws CoreException", "diff": ["+\t}", "+\tprotected IJavaProject createJavaProject(", "+\t\t\tfinal String projectName,", "+\t\t\tfinal String[] sourceFolders,", "+\t\t\tfinal String[] libraries,", "+\t\t\tfinal String[][] librariesInclusionPatterns,", "+\t\t\tfinal String[][] librariesExclusionPatterns,", "+\t\t\tfinal String[] projects,", "+\t\t\tfinal String[][] projectsInclusionPatterns,", "+\t\t\tfinal String[][] projectsExclusionPatterns,", "+\t\t\tfinal boolean[] exportedProjects,", "+\t\t\tfinal String projectOutput,", "+\t\t\tfinal String[] sourceOutputs,", "+\t\t\tfinal String[][] inclusionPatterns,", "+\t\t\tfinal String[][] exclusionPatterns,", "+\t\t\tfinal String compliance) throws CoreException {", "+\t\t\t\t\t", "+//\t\t\t\t\t inclusion patterns", "+\t\t\t\t\tIPath[] inclusionPaths;", "+\t\t\t\t\tif (librariesInclusionPatterns == null) {", "+\t\t\t\t\t\tinclusionPaths = new IPath[0];", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tString[] patterns = librariesInclusionPatterns[i];", "+\t\t\t\t\t\tint length = patterns.length;", "+\t\t\t\t\t\tinclusionPaths = new IPath[length];", "+\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\tString inclusionPattern = patterns[j];", "+\t\t\t\t\t\t\tinclusionPaths[j] = new Path(inclusionPattern);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// exclusion patterns", "+\t\t\t\t\tIPath[] exclusionPaths;", "+\t\t\t\t\tif (librariesExclusionPatterns == null) {", "+\t\t\t\t\t\texclusionPaths = new IPath[0];", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tString[] patterns = librariesExclusionPatterns[i];", "+\t\t\t\t\t\tint length = patterns.length;", "+\t\t\t\t\t\texclusionPaths = new IPath[length];", "+\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\tString exclusionPattern = patterns[j];", "+\t\t\t\t\t\t\texclusionPaths[j] = new Path(exclusionPattern);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\t\tentries[sourceLength+i] = JavaCore.newContainerEntry(new Path(lib));", "+\t\t\t\t\t\tentries[sourceLength+i] = JavaCore.newContainerEntry(", "+\t\t\t\t\t\t\t\tnew Path(lib),", "+\t\t\t\t\t\t\t\tinclusionPaths,", "+\t\t\t\t\t\t\t\texclusionPaths, false);", "-\t\t\t\t\t\tentries[sourceLength+i] = JavaCore.newLibraryEntry(libPath, null, null);", "+\t\t\t\t\t\tentries[sourceLength+i] = JavaCore.newLibraryEntry(", "+\t\t\t\t\t\t\t\tlibPath,", "+\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\tinclusionPaths,", "+\t\t\t\t\t\t\t\texclusionPaths,", "+\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\tentries[sourceLength+libLength+i] = JavaCore.newProjectEntry(new Path(projects[i]), isExported);", "+\t\t\t\t\t", "+\t\t\t\t\t// inclusion patterns", "+\t\t\t\t\tIPath[] inclusionPaths;", "+\t\t\t\t\tif (projectsInclusionPatterns == null) {", "+\t\t\t\t\t\tinclusionPaths = new IPath[0];", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tString[] patterns = projectsInclusionPatterns[i];", "+\t\t\t\t\t\tint length = patterns.length;", "+\t\t\t\t\t\tinclusionPaths = new IPath[length];", "+\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\tString inclusionPattern = patterns[j];", "+\t\t\t\t\t\t\tinclusionPaths[j] = new Path(inclusionPattern);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// exclusion patterns", "+\t\t\t\t\tIPath[] exclusionPaths;", "+\t\t\t\t\tif (projectsExclusionPatterns == null) {", "+\t\t\t\t\t\texclusionPaths = new IPath[0];", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tString[] patterns = projectsExclusionPatterns[i];", "+\t\t\t\t\t\tint length = patterns.length;", "+\t\t\t\t\t\texclusionPaths = new IPath[length];", "+\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\tString exclusionPattern = patterns[j];", "+\t\t\t\t\t\t\texclusionPaths[j] = new Path(exclusionPattern);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tentries[sourceLength+libLength+i] =", "+\t\t\t\t\t\tJavaCore.newProjectEntry(", "+\t\t\t\t\t\t\t\tnew Path(projects[i]),", "+\t\t\t\t\t\t\t\tinclusionPaths,", "+\t\t\t\t\t\t\t\texclusionPaths,", "+\t\t\t\t\t\t\t\tisExported);"]}], "num": 32376}