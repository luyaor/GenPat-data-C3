{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "41d29dd243186901e437279bcee81f26", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0fe5fd9363dc6c8c9612388c237b9a4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "079f1f525d3cbb0b2570dd4fe3bd959b7a33dc49", "commitAfterChange": "b21cadb5eae53d9f84dce9f073b5350a267b6ad6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException", "signatureAfterChange": " void add(JavaProject javaProject, IPath pathToAdd, int includeMask, HashSet visitedProjects, IClasspathEntry referringEntry) throws JavaModelException", "diff": ["-public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException {", "+ */", "+void add(JavaProject javaProject, IPath pathToAdd, int includeMask, HashSet visitedProjects, IClasspathEntry referringEntry) throws JavaModelException {", "+\tJavaModelManager.PerProjectInfo perProjectInfo = javaProject.getPerProjectInfo();", "+\t\tIClasspathEntry rawEntry = null;", "+\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "+\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "+\t\t}", "+\t\tif (rawEntry == null) continue;", "+\t\tAccessRestriction access = null;", "+\t\tClasspathEntry cpEntry = null;", "+\t\tif (rawEntry instanceof ClasspathEntry) {", "+\t\t\tcpEntry = (ClasspathEntry) rawEntry;", "+\t\t\tif (referringEntry != null) {", "+\t\t\t\tcpEntry = cpEntry.combineWith(referringEntry);", "+//\t\t\t\tcpEntry = ((ClasspathEntry)referringEntry).combineWith(cpEntry);", "+\t\t\t}", "+\t\t\taccess = cpEntry.getImportRestriction();", "+\t\t}", "-\t\t\t\tIClasspathEntry rawEntry = null;", "-\t\t\t\tJavaModelManager.PerProjectInfo perProjectInfo = javaProject.getPerProjectInfo();", "-\t\t\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "-\t\t\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "-\t\t\t\t}", "-\t\t\t\tif (rawEntry == null) break;", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\t\t\tadd(path, true, access);", "+\t\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\t\t\tadd(path, true, access);", "+\t\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tadd((JavaProject) model.getJavaProject(entry.getPath().lastSegment()), includeMask, visitedProjects);", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\tadd((JavaProject) model.getJavaProject(entry.getPath().lastSegment()), null, includeMask, visitedProjects, cpEntry);", "+\t\t\t\t\t}", "-\t\t\t\t\tadd(entry.getPath(), true);", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\tadd(entry.getPath(), true, access);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76596cbb27f754e7bcfb90d14e2321a5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/MessagerImpl.java", "commitBeforeChange": "03e205d7db02078dce9accf78d78c9d9a6ce6117", "commitAfterChange": "7ff51a474972e200f8003fdc2186f43ef4e82e14", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "      private void print(int severity, String msg)", "signatureAfterChange": "          private void print(SourcePosition pos,     \t\t\t\t   int severity,     \t\t\t\t   String msg)", "diff": ["+    ", "+    private void print(SourcePosition pos,", "+    \t\t\t\t   int severity,", "+    \t\t\t\t   String msg)", "+    {    \t", "+    \tfinal java.io.File file = pos.file();", "+    \tIResource resource = null;", "+    \tif( file != null ){    \t\t", "+    \t\tfinal String projAbsPath = _env.getProject().getLocation().toOSString();", "+    \t\tfinal String fileAbsPath = file.getAbsolutePath();", "+    \t\tfinal String fileRelPath = fileAbsPath.substring(projAbsPath.length());    \t\t\t", "+    \t\tresource = _env.getProject().getFile(fileRelPath);", "+    \t\tif( !resource.exists() )", "+    \t\t\tresource = null;", "+    \t}", "+    \telse", "+    \t\tresource = null;", "+    \t ", "+    \tfinal IResource currentResource = _env.getFile();", "+    \tint offset = 0;    \t", "+    \tif( currentResource.equals(resource) ){", "+    \t\tfinal CompilationUnit unit = _env.getAstCompilationUnit();", "+    \t\t//TODO: waiting on new API Bugzilla #97766", "+    \t\t//offset = unit.getPosition(pos.line(), pos.column() );", "+    \t\toffset = 0;", "+    \t}    \t", "+", "+    \taddMarker(resource, offset, -1, severity, msg, pos.line());", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94264a178edff90ca220a60ae481a8bb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "014c4b6fb1c7750e40400ac728ee53666326e3d2", "commitAfterChange": "f06de4b999ef266d99070d6e6ee7f897f16a1d0e", "methodNumberBeforeChange": 81, "methodNumberAfterChange": 81, "signatureBeforeChange": " protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException", "signatureAfterChange": " protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException", "diff": ["-\t\t\tenclosingElement = ((IClassFile)this.currentPossibleMatch.openable).getType();", "+\t\t\tIOpenable openable = enclosingElement.getOpenable();", "+\t\t\tIJavaElement anonType = null;", "+\t\t\tif (openable instanceof ClassFile) {", "+\t\t\t\tBinaryType binaryType = (BinaryType)((ClassFile) openable).getType();", "+\t\t\t\tString fileName = binaryType.getPath().toOSString();", "+\t\t\t\tif ((type.bits & ASTNode.IsAnonymousType) != 0) {", "+\t\t\t\t\tif (fileName != null) {", "+\t\t\t\t\t\tif (fileName.endsWith(\"jar\") || fileName.endsWith(SuffixConstants.SUFFIX_STRING_class)) { //$NON-NLS-1$", "+\t\t\t\t\t\t\tIClassFile classFile= binaryType.getPackageFragment().getClassFile(binaryType.getTypeQualifiedName() + ", "+\t\t\t\t\t\t\t\t\t\"$\" + Integer.toString(occurrenceCount) + SuffixConstants.SUFFIX_STRING_class);//$NON-NLS-1$", "+\t\t\t\t\t\t\tanonType =  classFile.getType();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// TODO: JAVA 9 - JIMAGE to be included later - currently assuming that only .class files will be dealt here.", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tenclosingElement = anonType != null ? anonType : ((IClassFile)this.currentPossibleMatch.openable).getType() ;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8962268e8b7b3e8bbd9333f2d76fe09", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java", "commitBeforeChange": "ed84fe583572c00454d25c80a7fbdcb718bd831c", "commitAfterChange": "6104d045de39dfc71d7d1f0e45c4c1c5824b6782", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  protected boolean triggerRecoveryUponLambdaClosure(Statement statement, boolean shouldCommit)", "signatureAfterChange": "  protected boolean triggerRecoveryUponLambdaClosure(Statement statement, boolean shouldCommit)", "diff": ["-\t\tif (!(statement instanceof AbstractVariableDeclaration)) // added already as part of standard recovery since these contribute a name to the scope prevailing at the cursor.", "+\t\tif (!(statement instanceof AbstractVariableDeclaration)) { // added already as part of standard recovery since these contribute a name to the scope prevailing at the cursor.", "+\t\t\t/* See if CompletionParser.attachOrphanCompletionNode has already added bits and pieces of AST to the recovery tree. If so, we want to", "+\t\t\t   replace those fragments with the fuller statement that provides target type for the lambda that got closed just now. There is prior", "+\t\t\t   art/precedent in the Java 7 world to this: Search for recoveredBlock.statements[--recoveredBlock.statementCount] = null;", "+\t\t\t*/", "+\t\t\tASTNode assistNodeParent = this.assistNodeParent();", "+\t\t\tASTNode enclosingNode = this.enclosingNode();", "+\t\t\tif (assistNodeParent != null || enclosingNode != null) {", "+\t\t\t\tRecoveredBlock recoveredBlock = (RecoveredBlock) (this.currentElement instanceof RecoveredBlock ? this.currentElement : ", "+\t\t\t\t\t\t\t\t\t\t\t\t\t(this.currentElement.parent instanceof RecoveredBlock) ? this.currentElement.parent : null);", "+\t\t\t\tif (recoveredBlock != null) {", "+\t\t\t\t\tRecoveredStatement recoveredStatement = recoveredBlock.statementCount > 0 ? recoveredBlock.statements[recoveredBlock.statementCount - 1] : null;", "+\t\t\t\t\tASTNode parseTree = recoveredStatement != null ? recoveredStatement.updatedStatement(0, new HashSet()) : null;", "+\t\t\t\t\tif (parseTree == assistNodeParent || parseTree == enclosingNode) {", "+\t\t\t\t\t\trecoveredBlock.statements[--recoveredBlock.statementCount] = null;", "+\t\t\t\t\t\tthis.currentElement = recoveredBlock;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b46441d85b3284ad8e0ba487077bbb2c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "605463bb98397b59c78b7fc56ee33e7e22fd8367", "commitAfterChange": "7428bd3b18a16b1860e6a1a28fbc6cd63967fdc6", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": " protected void assertSourceEquals(String message, String expected, String actual)", "signatureAfterChange": " protected void assertSourceEquals(String message, String expected, String actual)", "diff": ["-\tactual = org.eclipse.jdt.core.tests.util.Util.convertToIndependantLineDelimiter(actual);", "+\tactual = Util.convertToIndependantLineDelimiter(actual);", "+\t\t\tif (IGNORE_WHITESPACES) {", "+\t\t\t\tString trimmedExpected = ModelTestsUtil.removeWhiteSpace(expected);", "+\t\t\t\tString trimmedActual= ModelTestsUtil.removeWhiteSpace(actual);", "+\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\t\t\tthis.spaceFailures++;", "+\t\t\t\t\tSystem.out.println(\"n\ufffd\"+this.spaceFailures+\": Different spaces than old formatter for \"+this.file.getName());", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t} else if (IGNORE_LINES_LEADING_WHITESPACES) {", "+\t\t\t\tString trimmedExpected = ModelTestsUtil.trimLinesLeadingWhitespaces(expected);", "+\t\t\t\tString trimmedActual= ModelTestsUtil.trimLinesLeadingWhitespaces(actual);", "+\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\t\t\tthis.spaceFailures++;", "+\t\t\t\t\tSystem.out.println(\"n\ufffd\"+this.spaceFailures+\": Different line leading spaces than old formatter for \"+this.file.getName());", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0575ded18bc0fc31bcbad70cd2c3ba6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "bf1ba1c1732b0be00fbd03cfd8ae394b6a169e63", "commitAfterChange": "debb51f61b0b4a5b1a6926f67a451ba72125546c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic void resolve(MethodScope initializationScope)", "signatureAfterChange": "  \tpublic void resolve(MethodScope initializationScope)", "diff": ["+\t\t\t// check if field is hiding some variable", "+\t\t\tClassScope classScope = initializationScope.enclosingClassScope();", "+\t\t\tif (classScope != null) {", "+\t\t\t\tSourceTypeBinding declaringType = classScope.enclosingSourceType();", "+\t\t\t\tboolean checkLocal = true;", "+\t\t\t\tif (declaringType.superclass != null) { ", "+\t\t\t\t\tBinding existingVariable = classScope.findField(declaringType.superclass, name, this);", "+\t\t\t\t\tif (existingVariable != null && existingVariable.isValidBinding()) {", "+\t\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\t\t\t\tcheckLocal = false; // already found a matching field", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (checkLocal) {", "+\t\t\t\t\tMethodScope outerMethodScope = classScope.enclosingMethodScope();", "+\t\t\t\t\tif (outerMethodScope != null) { // local type scenario", "+\t\t\t\t\t\tBinding existingVariable = outerMethodScope.getBinding(name, BindingIds.VARIABLE, this);", "+\t\t\t\t\t\tif (existingVariable != null && existingVariable.isValidBinding()){", "+\t\t\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e8eb6a54e3f57c99a25bf2402d0254dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "6672145af9f0ffc7b3a43bbf4b4faa8f14d04d8b", "commitAfterChange": "5ae7e6b78bc18a365a04a008c907250a535fa48a", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " protected int resolveLevelForType(char[] simpleNamePattern, char[] qualificationPattern, TypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType(char[] simpleNamePattern, char[] qualificationPattern, TypeBinding binding)", "diff": ["-protected int resolveLevelForType(char[] simpleNamePattern, char[] qualificationPattern, TypeBinding type) {", "-\treturn resolveLevelForType(qualifiedPattern(simpleNamePattern, qualificationPattern), type);", "+protected int resolveLevelForType(char[] simpleNamePattern, char[] qualificationPattern, TypeBinding binding) {", "+//\treturn resolveLevelForType(qualifiedPattern(simpleNamePattern, qualificationPattern), type);", "+\tchar[] qualifiedPattern = getQualifiedPattern(simpleNamePattern, qualificationPattern);", "+\tint level = resolveLevelForType(qualifiedPattern, binding);", "+\tif (level == ACCURATE_MATCH || binding == null) return level;", "+\tboolean match = false;", "+\tTypeBinding type = binding instanceof ArrayBinding ? ((ArrayBinding)binding).leafComponentType : binding;", "+\tif (type.isMemberType() || type.isLocalType()) {", "+\t\tif (qualificationPattern != null) {", "+\t\t\tmatch = CharOperation.equals(qualifiedPattern, getQualifiedSourceName(binding), this.isCaseSensitive);", "+\t\t} else {", "+\t\t\tmatch = CharOperation.equals(qualifiedPattern, binding.sourceName(), this.isCaseSensitive); // need to keep binding to get source name", "+\t\t}", "+\t} else if (qualificationPattern == null) {", "+\t\tmatch = CharOperation.equals(qualifiedPattern, getQualifiedSourceName(binding), this.isCaseSensitive);", "+\t}", "+\treturn match ? ACCURATE_MATCH : IMPOSSIBLE_MATCH;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ec38c2ea60e9dddc6744dee70557d475", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "5527337a36439b5f7161d1700f05a2afcdb55c60", "commitAfterChange": "9309fad26eb4113a283f2c853c44a62715f49d70", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic static void validateCycles(Map preferredClasspaths) throws JavaModelException", "signatureAfterChange": " \tpublic static void validateCycles(Map preferredClasspaths) throws JavaModelException", "diff": ["-\t\tHashSet cycleParticipants = new HashSet();", "+\t\tLinkedHashSet cycleParticipants = new LinkedHashSet();", "+\t\t\t\t\t\tIJavaProject[] projectsInCycle;", "+\t\t\t\t\t\tString cycleString = \"\";\t //$NON-NLS-1$", "+\t\t\t\t\t\tif (cycleParticipants.isEmpty()) {", "+\t\t\t\t\t\t\tprojectsInCycle = null;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tprojectsInCycle = new IJavaProject[cycleParticipants.size()];", "+\t\t\t\t\t\t\tIterator it = cycleParticipants.iterator();", "+\t\t\t\t\t\t\tint k = 0;", "+\t\t\t\t\t\t\twhile (it.hasNext()) {", "+\t\t\t\t\t\t\t\t//projectsInCycle[i++] = (IPath) it.next();", "+\t\t\t\t\t\t\t\tIResource member = workspaceRoot.findMember((IPath) it.next());", "+\t\t\t\t\t\t\t\tif (member != null && member.getType() == IResource.PROJECT){", "+\t\t\t\t\t\t\t\t\tprojectsInCycle[k] = JavaCore.create((IProject)member);", "+\t\t\t\t\t\t\t\t\tif (projectsInCycle[k] != null) {", "+\t\t\t\t\t\t\t\t\t\tif (k != 0) cycleString += \", \"; //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\tcycleString += projectsInCycle[k++].getElementName();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tnew JavaModelStatus(IJavaModelStatusConstants.CLASSPATH_CYCLE, project));", "+\t\t\t\t\t\t\tnew JavaModelStatus(IJavaModelStatusConstants.CLASSPATH_CYCLE, project, cycleString));"]}], "num": 14572}