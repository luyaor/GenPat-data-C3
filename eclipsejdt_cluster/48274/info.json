{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db74d0e16b445d446361895ca7aacb4e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ff9b82e02a026f026175bc77c529318", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/TestingEnvironment.java", "commitBeforeChange": "5371361e21820d2b2e231653f1940e5405c7ae2f", "commitAfterChange": "83631fa7de14141f6ec93506fe4cb66a8c3eb380", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tpublic IPath addProject(String projectName, String compliance)", "signatureAfterChange": "  \tpublic IPath addProject(String projectName, String compliance)", "diff": ["+\t\tint requiredComplianceFlag = 0;", "+\t\tString compilerVersion = null;", "-\t\t\tif ((AbstractCompilerTest.getPossibleComplianceLevels()  & AbstractCompilerTest.F_1_5) == 0)", "-\t\t\t\tthrow new RuntimeException(\"This test should run on top of a 1.5 JRE\");", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_5;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_5;", "+\t\t}", "+\t\telse if (\"1.6\".equals(compliance)) {", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_6;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_6;", "+\t\t}", "+\t\telse if (\"1.7\".equals(compliance)) {", "+\t\t\trequiredComplianceFlag = AbstractCompilerTest.F_1_7;", "+\t\t\tcompilerVersion = CompilerOptions.VERSION_1_7;", "+\t\t}", "+\t\telse if (!\"1.4\".equals(compliance) && !\"1.3\".equals(compliance)) {", "+\t\t\tthrow new UnsupportedOperationException(\"Test framework doesn't support compliance level: \" + compliance);", "+\t\t}", "+\t\tif (requiredComplianceFlag != 0) {", "+\t\t\tif ((AbstractCompilerTest.getPossibleComplianceLevels() & requiredComplianceFlag) == 0)", "+\t\t\t\tthrow new RuntimeException(\"This test requires a \" + compliance + \" JRE\");", "-\t\t\toptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "-\t\t\toptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);\t", "-\t\t\toptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);\t", "+\t\t\toptions.put(CompilerOptions.OPTION_Compliance, compilerVersion);", "+\t\t\toptions.put(CompilerOptions.OPTION_Source, compilerVersion);\t", "+\t\t\toptions.put(CompilerOptions.OPTION_TargetPlatform, compilerVersion);\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13bf1aaaa34510472afb3aef08f98086", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java", "commitBeforeChange": "e87bfc3f4fb5c5cbc92139a33aa1f70cbb179bd0", "commitAfterChange": "fea48c1ab8bc004e73a7488c630798836bc78025", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tif (this.action == null", "-\t\t\t\t|| this.action.isEmptyBlock()", "-\t\t\t\t|| ((this.action.bits & IsUsefulEmptyStatement) != 0)) {", "+\t\tfinal boolean hasEmptyAction = this.action == null", "+\t\t\t|| this.action.isEmptyBlock()", "+\t\t\t|| ((this.action.bits & IsUsefulEmptyStatement) != 0);", "+", "+\t\tif (hasEmptyAction", "+\t\t\t\t&& this.elementVariable.binding.resolvedPosition == -1", "+\t\t\t\t&& this.kind == ARRAY) {", "+\t\t\tcollection.generateCode(scope, codeStream, false);", "+", "-\t\t", "-\t\tif (this.elementVariable.binding.resolvedPosition != -1) {", "-\t\t\tswitch(this.kind) {", "-\t\t\t\tcase ARRAY :", "+\t\tswitch(this.kind) {", "+\t\t\tcase ARRAY :", "+\t\t\t\tif (this.elementVariable.binding.resolvedPosition != -1) {", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase RAW_ITERABLE :", "-\t\t\t\tcase GENERIC_ITERABLE :", "-\t\t\t\t\tcodeStream.load(this.indexVariable);", "-\t\t\t\t\tcodeStream.invokeJavaUtilIteratorNext();", "-\t\t\t\t\tif (this.elementVariable.binding.type.id != T_JavaLangObject) {", "-\t\t\t\t\t\tif (this.elementVariableImplicitWidening != -1) {", "-\t\t\t\t\t\t\tcodeStream.checkcast(this.collectionElementType);", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.elementVariableImplicitWidening);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.checkcast(this.elementVariable.binding.type);", "-\t\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.addVisibleLocalVariable(this.elementVariable.binding);", "+\t\t\t\t\tif (this.postCollectionInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tthis.postCollectionInitStateIndex);", "-\t\t\t\t\tcodeStream.store(this.elementVariable.binding, false);", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tcodeStream.addVisibleLocalVariable(this.elementVariable.binding);", "-\t\t\tif (this.postCollectionInitStateIndex != -1) {", "-\t\t\t\tcodeStream.addDefinitelyAssignedVariables(", "-\t\t\t\t\tcurrentScope,", "-\t\t\t\t\tthis.postCollectionInitStateIndex);", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// if unused variable, some side effects still need to be performed (86487)", "-\t\t\tswitch(this.kind) {", "-\t\t\t\tcase ARRAY :", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase RAW_ITERABLE :", "-\t\t\t\tcase GENERIC_ITERABLE :", "-\t\t\t\t\t// still advance in iterator to prevent infinite loop", "-\t\t\t\t\tcodeStream.load(this.indexVariable);", "-\t\t\t\t\tcodeStream.invokeJavaUtilIteratorNext();", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase RAW_ITERABLE :", "+\t\t\tcase GENERIC_ITERABLE :", "+\t\t\t\tcodeStream.load(this.indexVariable);", "+\t\t\t\tcodeStream.invokeJavaUtilIteratorNext();", "+\t\t\t\tif (this.elementVariable.binding.type.id != T_JavaLangObject) {", "+\t\t\t\t\tif (this.elementVariableImplicitWidening != -1) {", "+\t\t\t\t\t\tcodeStream.checkcast(this.collectionElementType);", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.elementVariableImplicitWidening);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.checkcast(this.elementVariable.binding.type);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (this.elementVariable.binding.resolvedPosition == -1) {", "-\t\t\t\t\tbreak;", "-\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.store(this.elementVariable.binding, false);", "+\t\t\t\t\tcodeStream.addVisibleLocalVariable(this.elementVariable.binding);", "+\t\t\t\t\tif (this.postCollectionInitStateIndex != -1) {", "+\t\t\t\t\t\tcodeStream.addDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tthis.postCollectionInitStateIndex);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "-\t\tthis.action.generateCode(scope, codeStream);", "+", "+\t\tif (!hasEmptyAction) {", "+\t\t\tthis.action.generateCode(scope, codeStream);", "+\t\t}", "+\t\t\t\t\tif (hasEmptyAction && this.elementVariable.binding.resolvedPosition == -1) break;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "261bdafebc4ad1d8bb80fef9cc5c0198", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java", "commitBeforeChange": "e18b8152863f75de59815219afe0ab3ec946a798", "commitAfterChange": "5333a8d6e234b4d5bbcbee365cfa39aafade1032", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse( \t\tFlowInfo initsWhenTrue, boolean isOptimizedTrue, \t\tFlowInfo initsWhenFalse, boolean isOptimizedFalse, \t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement)", "signatureAfterChange": " public static UnconditionalFlowInfo mergedOptimizedBranchesIfElse( \t\tFlowInfo initsWhenTrue, boolean isOptimizedTrue, \t\tFlowInfo initsWhenFalse, boolean isOptimizedFalse, \t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement, \t\tboolean reportDeadCodeInKnownPattern)", "diff": ["-\t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement) {", "+\t\tboolean allowFakeDeadBranch, FlowInfo flowInfo, IfStatement ifStatement,", "+\t\tboolean reportDeadCodeInKnownPattern) {", "-\t\t\tmergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "-\t\t\t\tunconditionalInits();", "+\t\t\tif (!reportDeadCodeInKnownPattern) {", "+\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=256796", "+\t\t\t\t// do not report code even after if-else as dead as a consequence of analysis done in known dead code pattern", "+\t\t\t\t// when the CompilerOptions$reportDeadCodeInTrivialIfStatement option is disabled", "+\t\t\t\tif (ifStatement.elseStatement == null) {", "+\t\t\t\t\tmergedInfo = flowInfo.unconditionalInits();", "+\t\t\t\t} else {", "+\t\t\t\t\tmergedInfo = initsWhenFalse.unconditionalInits();", "+\t\t\t\t\tif (initsWhenFalse != FlowInfo.DEAD_END) {", "+\t\t\t\t\t\t// let the definitely true status of known dead code pattern not affect the reachability", "+\t\t\t\t\t\tmergedInfo.setReachMode(flowInfo.reachMode());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tmergedInfo = initsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "+\t\t\t\t\tunconditionalInits();", "+\t\t\t}", "-\t\t\tmergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "-\t\t\t\tunconditionalInits();", "+\t\t\tif (!reportDeadCodeInKnownPattern) {", "+\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=256796", "+\t\t\t\t// do not report code even after if-else as dead as a consequence of analysis done in known dead code pattern", "+\t\t\t\t// when the CompilerOptions$reportDeadCodeInTrivialIfStatement option is disabled", "+\t\t\t\tif (ifStatement.thenStatement == null) {", "+\t\t\t\t\tmergedInfo = flowInfo.unconditionalInits();", "+\t\t\t\t} else {", "+\t\t\t\t\tmergedInfo = initsWhenTrue.unconditionalInits();", "+\t\t\t\t\tif (initsWhenTrue != FlowInfo.DEAD_END) {", "+\t\t\t\t\t\t// let the definitely false status of known dead code pattern not affect the reachability", "+\t\t\t\t\t\tmergedInfo.setReachMode(flowInfo.reachMode());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tmergedInfo = initsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD).", "+\t\t\t\t\tunconditionalInits();", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4553418e09ff6660c538b5860559a072", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java", "commitBeforeChange": "cf6c558f3e8d77fc234110cd8914f5b336ef0d92", "commitAfterChange": "ab10a34ac484d145f4f6c275f96c1a07de4e2006", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public RecoveredElement buildInitialRecoveryState()", "signatureAfterChange": " public RecoveredElement buildInitialRecoveryState()", "diff": ["-\t\t\tif (blockStarts[j] > nodeStart){", "-\t\t\t\tblockIndex = j; // shift the index to the new block", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\tif (blockStarts[j] != lastStart){ // avoid multiple block if at same position", "+\t\t\tif (blockStarts[j] >= 0) {", "+\t\t\t\tif (blockStarts[j] > nodeStart){", "+\t\t\t\t\tblockIndex = j; // shift the index to the new block", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tif (blockStarts[j] != lastStart){ // avoid multiple block if at same position", "+\t\t\t\t\tblock = new Block(0);", "+\t\t\t\t\tblock.sourceStart = lastStart = blockStarts[j];", "+\t\t\t\t\telement = element.add(block, 1);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (-blockStarts[j] > nodeStart){", "+\t\t\t\t\tblockIndex = j; // shift the index to the new block", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "-\t\t\t\tblock.sourceStart = lastStart = blockStarts[j];", "+\t\t\t\tblock.sourceStart = lastStart = -blockStarts[j];", "-\t\tif ((blockStarts[j] < pos) && (blockStarts[j] != lastStart)){ // avoid multiple block if at same position", "-\t\t\tblock = new Block(0);", "-\t\t\tblock.sourceStart = lastStart = blockStarts[j];", "-\t\t\telement = element.add(block, 1);", "+\t\tif (blockStarts[j] >= 0) {", "+\t\t\tif ((blockStarts[j] < pos) && (blockStarts[j] != lastStart)){ // avoid multiple block if at same position", "+\t\t\t\tblock = new Block(0);", "+\t\t\t\tblock.sourceStart = lastStart = blockStarts[j];", "+\t\t\t\telement = element.add(block, 1);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif ((blockStarts[j] < pos)){ // avoid multiple block if at same position", "+\t\t\t\tblock = new Block(0);", "+\t\t\t\tblock.sourceStart = lastStart = -blockStarts[j];", "+\t\t\t\telement = element.add(block, 1);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5579dfaba0ab836f50f43237c36885f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "69d976ecb2b4a910a78fb1eaf551e2775a0ff256", "commitAfterChange": "6e7138933a7b0a4bb6f562a7b0b5324e7f7fa604", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic boolean ensureGeneratedSourceFolder( IProgressMonitor progressMonitor )", "signatureAfterChange": " \tpublic boolean ensureGeneratedSourceFolder( IProgressMonitor progressMonitor )", "diff": ["+\t\tboolean reset = false;", "+\t\tIFolder curSrcFolder = null;", "-\t\t\tif ( _generatedSourceFolder != null )", "+\t\t\tif( _generatedSourceFolderName == null )", "+\t\t\tif( _generatedSourceFolder != null ){", "+\t\t\t\tfinal IPath srcFolderPath = _generatedSourceFolder.getProjectRelativePath();", "+\t\t\t\t", "+\t", "+\t\t\t\tif( !_generatedSourceFolderName.equals( srcFolderPath.toString()) ){", "+\t\t\t\t\treset = true;", "+\t\t\t\t\tcurSrcFolder = _generatedSourceFolder;", "+\t\t\t\t\t_generatedSourceFolder = null;", "+\t\t\t\t}", "+\t\t\t\telse", "+\t\t\t\t\treturn false;", "+\t\t\t}", "+\t", "-\t\t// don't take any locks while creating the folder, since we are doing file-system operations", "-\t\tIFolder srcFolder = getGeneratedSourceFolder();", "-\t\ttry{ ", "+\t\tIFolder srcFolder = null;", "+\t\ttry{", "+\t\t\tif( reset ){", "+\t\t\t\t// the generated source folder and the generated source folder name is not", "+\t\t\t\t// lining up.", "+\t\t\t\tremoveFromProjectClasspath(_javaProject, curSrcFolder, progressMonitor );", "+\t\t\t\tif ( curSrcFolder.exists() ){", "+\t\t\t\t\tif( AptPlugin.DEBUG )", "+\t\t\t\t\t\tAptPlugin.trace(\"deleting gen src dir \" + curSrcFolder.getName() ); //$NON-NLS-1$", "+\t\t\t\t\tcurSrcFolder.delete( true, false, null );", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t\t", "+\t\t\t// don't take any locks while creating the folder, since we are doing file-system operations", "+\t\t\tsrcFolder = getGeneratedSourceFolder();", "+\t\t "]}], "num": 48274}