{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7ed963c8da4d09a6a56fbaf404bdc9ac", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07be8eed2700559cdf49921c890a953f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJarFileToIndex.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \r \tpublic boolean execute()", "signatureAfterChange": "\r public boolean execute()", "diff": ["-\r", "-\tpublic boolean execute() {\r", "-\t\ttry {\r", "-\t\t\tif (this.resource != null) {\r", "-\t\t\t\tif (!this.resource.isLocal(IResource.DEPTH_ZERO)) {\r", "-\t\t\t\t\treturn FAILED;\r", "-\t\t\t\t}\r", "+}\r", "+public boolean execute() {\r", "+\ttry {\r", "+\t\tif (this.resource != null) {\r", "+\t\t\tif (!this.resource.isLocal(IResource.DEPTH_ZERO)) {\r", "+\t\t\t\treturn FAILED;\r", "-\t\t\tIPath indexedPath =\r", "-\t\t\t\tthis.jarRoot == null ? this.resource.getFullPath() : this.jarRoot.getPath();\r", "-\t\t\t// if index already cached, then do not perform any check\r", "-\t\t\tIIndex index = (IIndex) manager.getIndex(indexedPath, false);\r", "-\t\t\tif (index != null)\r", "-\t\t\t\treturn COMPLETE;\r", "+\t\t}\r", "+\t\tIPath indexedPath = this.path;\r", "+\t\t// if index already cached, then do not perform any check\r", "+\t\tIIndex index = (IIndex) manager.getIndex(indexedPath, false);\r", "+\t\tif (index != null) return COMPLETE;\r", "+\t\t\r", "+\t\tindex = manager.getIndex(indexedPath);\r", "+\t\tif (index == null) return COMPLETE;\r", "+\t\tReadWriteMonitor monitor = manager.getMonitorFor(index);\r", "+\t\tif (monitor == null) return COMPLETE; // index got deleted since acquired\r", "+\t\tZipFile zip = null;\r", "+\t\ttry {\r", "+\t\t\t// this path will be a relative path to the workspace in case the zipfile in the workspace otherwise it will be a path in the\r", "+\t\t\t// local file system\r", "+\t\t\tPath zipFilePath = null;\r", "+\t\t\t\r", "+\t\t\tmonitor.enterWrite(); // ask permission to write\r", "+\t\t\tif (resource != null) {\r", "+\t\t\t\tIPath location = this.resource.getLocation();\r", "+\t\t\t\tif (location == null) return FAILED;\r", "+\t\t\t\tzip = new ZipFile(location.toFile());\r", "+\t\t\t\tzipFilePath = (Path) this.resource.getFullPath().makeRelative(); // absolute path relative to the workspace\r", "+\t\t\t} else {\r", "+\t\t\t\tzip = new ZipFile(this.path.toFile());\r", "+\t\t\t\tzipFilePath = (Path) this.path; // absolute path relative to the local file system\r", "+\t\t\t\t// make it a canonical path to avoid duplicate entries\r", "+\t\t\t\tzipFilePath = (Path)JavaProject.canonicalizedPath(zipFilePath);\r", "+\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\tif (JobManager.VERBOSE)\r", "+\t\t\t\tSystem.out.println(\"INDEX : \" + zip.getName());\r", "+\t\t\tlong initialTime = System.currentTimeMillis();\r", "-\t\t\tindex = manager.getIndex(indexedPath);\r", "-\t\t\tif (index == null)\r", "-\t\t\t\treturn COMPLETE;\r", "-\t\t\tReadWriteMonitor monitor = manager.getMonitorFor(index);\r", "-\t\t\tif (monitor == null)\r", "-\t\t\t\treturn COMPLETE; // index got deleted since acquired\r", "-\t\t\tZipFile zip = null;\r", "-\t\t\ttry {\r", "-\t\t\t\t// this path will be a relative path to the workspace in case the zipfile in the workspace otherwise it will be a path in the\r", "-\t\t\t\t// local file system\r", "-\t\t\t\tPath zipFilePath = null;\r", "-\r", "-\t\t\t\tmonitor.enterWrite(); // ask permission to write\r", "-\t\t\t\tif (resource != null) {\r", "-\t\t\t\t\tzip = new ZipFile(this.resource.getLocation().toFile());\r", "-\t\t\t\t\tzipFilePath = (Path) this.resource.getFullPath().makeRelative();\r", "-\t\t\t\t\t// absolute path relative to the workspace\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tzip = new ZipFile(this.jarRoot.getPath().toFile());\r", "-\t\t\t\t\tzipFilePath = (Path) this.jarRoot.getPath();\r", "-\t\t\t\t\t// absolute path relative to the local file system\r", "-\t\t\t\t\t// make it a canonical path to avoid duplicate entries\r", "-\t\t\t\t\tzipFilePath = (Path) JavaProject.canonicalizedPath(zipFilePath);\r", "+\t\t\tfinal Hashtable indexedFileNames = new Hashtable(100);\r", "+\t\t\tIQueryResult[] results = index.queryInDocumentNames(\"\"); // all file names\r", "+\t\t\tint resultLength = results == null ? 0 : results.length;\r", "+\t\t\tif (resultLength != 0) {\r", "+\t\t\t\t/* check integrity of the existing index file\r", "+\t\t\t\t * if the length is equal to 0, we want to index the whole jar again\r", "+\t\t\t\t * If not, then we want to check that there is no missing entry, if\r", "+\t\t\t\t * one entry is missing then we \r", "+\t\t\t\t */ \r", "+\t\t\t\tfor (int i = 0; i < resultLength; i++) {\r", "+\t\t\t\t\tString fileName = results[i].getPath();\r", "+\t\t\t\t\tindexedFileNames.put(fileName, fileName);\r", "-\r", "-\t\t\t\tif (JobManager.VERBOSE)\r", "-\t\t\t\t\tSystem.out.println(\"INDEX : \" + zip.getName());\r", "-\t\t\t\tlong initialTime = System.currentTimeMillis();\r", "-\r", "-\t\t\t\tfinal Hashtable indexedFileNames = new Hashtable(100);\r", "-\t\t\t\tIQueryResult[] results = index.queryInDocumentNames(\"\"); // all file names\r", "-\t\t\t\tint resultLength = results == null ? 0 : results.length;\r", "-\t\t\t\tif (resultLength != 0) {\r", "-\t\t\t\t\t/* check integrity of the existing index file\r", "-\t\t\t\t\t * if the length is equal to 0, we want to index the whole jar again\r", "-\t\t\t\t\t * If not, then we want to check that there is no missing entry, if\r", "-\t\t\t\t\t * one entry is missing then we \r", "-\t\t\t\t\t */\r", "-\t\t\t\t\tfor (int i = 0; i < resultLength; i++) {\r", "-\t\t\t\t\t\tString fileName = results[i].getPath();\r", "-\t\t\t\t\t\tindexedFileNames.put(fileName, fileName);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tboolean needToReindex = false;\r", "-\t\t\t\t\tfor (Enumeration e = zip.entries(); e.hasMoreElements();) {\r", "-\t\t\t\t\t\t// iterate each entry to index it\r", "-\t\t\t\t\t\tZipEntry ze = (ZipEntry) e.nextElement();\r", "-\t\t\t\t\t\tif (ze.getName().toUpperCase().endsWith(\".CLASS\")) {\r", "-\t\t\t\t\t\t\tJarFileEntryDocument entryDocument =\r", "-\t\t\t\t\t\t\t\tnew JarFileEntryDocument(ze, null, zipFilePath);\r", "-\t\t\t\t\t\t\tif (indexedFileNames.remove(entryDocument.getName()) == null) {\r", "-\t\t\t\t\t\t\t\tneedToReindex = true;\r", "-\t\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (!needToReindex && indexedFileNames.size() == 0) {\r", "-\t\t\t\t\t\treturn COMPLETE;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\r", "-\t\t\t\t/*\r", "-\t\t\t\t * Index the jar for the first time or reindex the jar in case the previous index file has been corrupted\r", "-\t\t\t\t */\r", "-\t\t\t\tif (index != null) {\r", "-\t\t\t\t\t// index already existed: recreate it so that we forget about previous entries\r", "-\t\t\t\t\tindex = manager.recreateIndex(indexedPath);\r", "-\t\t\t\t}\r", "+\t\t\t\tboolean needToReindex = false;\r", "-\t\t\t\t\tif (ze.getName().toUpperCase().endsWith(\".CLASS\")) {\r", "-\t\t\t\t\t\tInputStream zipInputStream = zip.getInputStream(ze);\r", "-\t\t\t\t\t\tbyte classFileBytes[] = new byte[(int) ze.getSize()];\r", "-\t\t\t\t\t\tint length = classFileBytes.length;\r", "-\t\t\t\t\t\tint len = 0;\r", "-\t\t\t\t\t\tint readSize = 0;\r", "-\t\t\t\t\t\twhile ((readSize != -1) && (len != length)) {\r", "-\t\t\t\t\t\t\treadSize = zipInputStream.read(classFileBytes, len, length - len);\r", "-\t\t\t\t\t\t\tlen += readSize;\r", "+\t\t\t\t\tif (Util.isClassFileName(ze.getName())) {\r", "+\t\t\t\t\t\tJarFileEntryDocument entryDocument = new JarFileEntryDocument(ze, null, zipFilePath);\r", "+\t\t\t\t\t\tif (indexedFileNames.remove(entryDocument.getName()) == null) {\r", "+\t\t\t\t\t\t\tneedToReindex = true;\r", "+\t\t\t\t\t\t\tbreak;\r", "-\t\t\t\t\t\tzipInputStream.close();\r", "-\t\t\t\t\t\t// Add the name of the file to the index\r", "-\t\t\t\t\t\tindex.add(\r", "-\t\t\t\t\t\t\tnew JarFileEntryDocument(ze, classFileBytes, zipFilePath),\r", "-\t\t\t\t\t\t\tnew BinaryIndexer());\r", "-\t\t\t\tif (JobManager.VERBOSE)\r", "-\t\t\t\t\tSystem.out.println(\r", "-\t\t\t\t\t\t\"INDEX : \"\r", "-\t\t\t\t\t\t\t+ zip.getName()\r", "-\t\t\t\t\t\t\t+ \" COMPLETE in \"\r", "-\t\t\t\t\t\t\t+ (System.currentTimeMillis() - initialTime)\r", "-\t\t\t\t\t\t\t+ \" ms\");\r", "-\t\t\t} finally {\r", "-\t\t\t\tif (zip != null)\r", "-\t\t\t\t\tzip.close();\r", "-\t\t\t\tmonitor.exitWrite(); // free write lock\r", "+\t\t\t\tif (!needToReindex && indexedFileNames.size() == 0) {\r", "+\t\t\t\t\treturn COMPLETE;\r", "+\t\t\t\t}\r", "-\t\t} catch (IOException e) {\r", "-\t\t\treturn FAILED;\r", "-\t\t}\r", "-\t\treturn COMPLETE;\r", "-\t}\r", "+\t\t\t/*\r", "+\t\t\t * Index the jar for the first time or reindex the jar in case the previous index file has been corrupted\r", "+\t\t\t */\r", "+\t\t\tif (index != null) {\r", "+\t\t\t\t// index already existed: recreate it so that we forget about previous entries\r", "+\t\t\t\tindex = manager.recreateIndex(indexedPath);\r", "+\t\t\t}\r", "+\t\t\tfor (Enumeration e = zip.entries(); e.hasMoreElements();) {\r", "+\t\t\t\t// iterate each entry to index it\r", "+\t\t\t\tZipEntry ze = (ZipEntry) e.nextElement();\r", "+\t\t\t\tif (Util.isClassFileName(ze.getName())) {\r", "+\t\t\t\t\tInputStream zipInputStream = zip.getInputStream(ze);\r", "+\t\t\t\t\tbyte classFileBytes[] = new byte[(int) ze.getSize()];\r", "+\t\t\t\t\tint length = classFileBytes.length;\r", "+\t\t\t\t\tint len = 0;\r", "+\t\t\t\t\tint readSize = 0;\r", "+\t\t\t\t\twhile ((readSize != -1) && (len != length)) {\r", "+\t\t\t\t\t\treadSize = zipInputStream.read(classFileBytes, len, length - len);\r", "+\t\t\t\t\t\tlen += readSize;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tzipInputStream.close();\r", "+\t\t\t\t\t// Add the name of the file to the index\r", "+\t\t\t\t\tindex.add(\r", "+\t\t\t\t\t\tnew JarFileEntryDocument(ze, classFileBytes, zipFilePath), \r", "+\t\t\t\t\t\tnew BinaryIndexer()); \r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tif (JobManager.VERBOSE)\r", "+\t\t\t\tSystem.out.println(\r", "+\t\t\t\t\t\"INDEX : \"\r", "+\t\t\t\t\t\t+ zip.getName()\r", "+\t\t\t\t\t\t+ \" COMPLETE in \"\r", "+\t\t\t\t\t\t+ (System.currentTimeMillis() - initialTime)\r", "+\t\t\t\t\t\t+ \" ms\"); \r", "+\t\t} finally {\r", "+\t\t\tif (zip != null)\r", "+\t\t\t\tzip.close();\r", "+\t\t\tmonitor.exitWrite(); // free write lock\r", "+\t\t}\r", "+\t} catch (IOException e) {\r", "+\t\treturn FAILED;\r", "+\t}\r", "+\treturn COMPLETE;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e1a3952956c98fc6413073bd28f5b33", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java", "commitBeforeChange": "3cdc40c3e141f1d38e6828b30530d087867619a9", "commitAfterChange": "0768a01c46bf55c1ad1aefdbfa14c12019b43872", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate void assertBindingCreated(String[] pathAndSources, final String expectedKey) throws JavaModelException", "signatureAfterChange": " \tprivate void assertBindingsCreated(String[] pathAndSources, final String[] expectedKeys) throws JavaModelException", "diff": ["+\t */", "+\tprivate void assertBindingsCreated(String[] pathAndSources, final String[] expectedKeys) throws JavaModelException {", "-\t\t\t\tString createdBindingKey;", "+\t\t\t\tArrayList createdBindingKeys = new ArrayList();", "-\t\t\t\t\tIBinding[] bindings = createBindings(new String[] {expectedKey});", "+\t\t\t\t\tIBinding[] bindings = createBindings(expectedKeys);", "-\t\t\t\t\t\tthis.createdBindingKey = bindings[0].getKey();", "+\t\t\t\t\t\tthis.createdBindingKeys.add(bindings[0].getKey());", "+\t\t\t\t}", "+\t\t\t\tpublic String getCreatedKeys() {", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\tfor (int i = 0, length = this.createdBindingKeys.size(); i < length; i++) {", "+\t\t\t\t\t\tbuffer.append(this.createdBindingKeys.get(i));", "+\t\t\t\t\t\tif (i < length - 1)", "+\t\t\t\t\t\t\tbuffer.append('\\n');", "+\t\t\t\t\t}", "+\t\t\t\t\treturn buffer.toString();", "-\t\t\tString actualKey = requestor.createdBindingKey;", "+\t\t\tString expectedKey = toString(expectedKeys);", "+\t\t\tString actualKey = requestor.getCreatedKeys();", "-\t\t\t\tBindingResolver resolver = requestBinding(pathAndSources, null);", "-\t\t\t\tif (resolver.bindingKey != null) {", "-\t\t\t\t\tif (!expectedKey.equals(resolver.bindingKey))", "-\t\t\t\t\t\tSystem.out.println(Util.displayString(resolver.bindingKey, 3));", "-\t\t\t\t\tassertEquals(\"Inconsistent expected key \", expectedKey, resolver.bindingKey);", "-\t\t\t\t} ", "+\t\t\t\tBindingResolver resolver = requestBindings(pathAndSources, null);", "+\t\t\t\tassertStringsEqual(\"Inconsistent expected key \", expectedKeys, resolver.getBindingKeys());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b90ec1b03336d050da397a14fa75d380", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "380f51fb07b01d50fdf783879a49310c31bf8dde", "commitAfterChange": "cdb3e8d99e2ddf40df3afd879c65627abb3809dc", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " \tpublic static IPath getExternalAnnotationPath(IClasspathEntry entry, IProject project, boolean resolve)", "signatureAfterChange": " \tpublic static IPath getExternalAnnotationPath(IClasspathEntry entry, IProject project, boolean resolve)", "diff": ["-\t\t\t\tIProject targetProject = project.getWorkspace().getRoot().getProject(annotationPath.segment(0));", "-\t\t\t\tif (targetProject.exists()) {", "-\t\t\t\t\tif (annotationPath.segmentCount() > 1)", "-\t\t\t\t\t\treturn targetProject.getLocation().append(annotationPath.removeFirstSegments(1));", "-\t\t\t\t\telse", "-\t\t\t\t\t\treturn targetProject.getLocation();", "+\t\t\t\tIResource resource = project.getWorkspace().getRoot().findMember(annotationPath);", "+\t\t\t\tif (resource != null) {", "+\t\t\t\t\treturn resource.getLocation();", "+\t\t\t\t} else if (new File(annotationPath.toOSString()).exists()) { // absolute, not in workspace, must be Filesystem-absolute", "+\t\t\t\t\treturn annotationPath;", "-\t\t\t\t// absolute, not in workspace, must be Filesystem-absolute:", "-\t\t\t\treturn annotationPath;", "+\t\t\t\tinvalidExternalAnnotationPath(project);", "-\t\t\t\t\tif (resolve)", "-\t\t\t\t\t\treturn project.getLocation().append(annotationPath);", "-\t\t\t\t\telse", "+\t\t\t\t\tif (resolve) {", "+\t\t\t\t\t\tIResource member = project.findMember(annotationPath);", "+\t\t\t\t\t\tif (member != null)", "+\t\t\t\t\t\t\treturn member.getLocation();", "+\t\t\t\t\t\tinvalidExternalAnnotationPath(project);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da5a1f8ee934a3867e51180b166e8854", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java", "commitBeforeChange": "32d0a507edd3d586400bfb151d82b1124713ca7f", "commitAfterChange": "b3a3e56706625d1059f4804a9598e799971e01c0", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r public IJavaElement[] codeSelect(int offset, int length) throws JavaModelException", "signatureAfterChange": "\r public IJavaElement[] codeSelect(int offset, int length) throws JavaModelException", "diff": ["-\t\tString name = getElementName();\r", "-\t\tname = name.substring(0, name.length() - 6); // remove \".class\"\r", "-\t\tname = name + \".java\"; //$NON-NLS-1$\r", "-\t\tString encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);\r", "-\t\tif (\"\".equals(encoding)) encoding = null; //$NON-NLS-1$\r", "-\t\t\r", "-\t\tBasicCompilationUnit cu = new BasicCompilationUnit(contents, name, encoding);\r", "+\r", "+\t\tIType current = this.getType();\r", "+\t\tIType parent;\r", "+\t\twhile ((parent = current.getDeclaringType()) != null){\r", "+\t\t\tcurrent = parent;\r", "+\t\t}\r", "+\t\tBasicCompilationUnit cu = new BasicCompilationUnit(contents, current.getElementName() + \".java\", null); //$NON-NLS-1$\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e306fc3d93d01e574f2e2cc9b508e8fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java", "commitBeforeChange": "7675c409a4b3b1e15b1cc476a0a66b988b5fb4a0", "commitAfterChange": "28d83829a5c5453c02025fb74750ed1594ff644e", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "\r public String getTypeQualifiedName(char enclosingTypeSeparator)", "signatureAfterChange": "\r public String getTypeQualifiedName(char enclosingTypeSeparator)", "diff": ["-\tif (fParent.getElementType() == IJavaElement.CLASS_FILE) {\r", "-\t\tString name= fParent.getElementName();\r", "-\t\treturn name.substring(0,name.lastIndexOf('.'));\r", "-\t}\r", "-\tif (fParent.getElementType() == IJavaElement.TYPE) {\r", "-\t\tif (Character.isDigit(fName.charAt(0))) {\r", "-\t\t\treturn ((IType) fParent).getTypeQualifiedName(enclosingTypeSeparator);\r", "+\tIType declaringType = this.getDeclaringType();\r", "+\tif (declaringType == null) {\r", "+\t\tString classFileName = this.getClassFile().getElementName();\r", "+\t\tif (classFileName.indexOf('$') == -1) {\r", "+\t\t\t// top level class file: name of type is same as name of class file\r", "+\t\t\treturn fName;\r", "-\t\t\treturn ((IType) fParent).getTypeQualifiedName(enclosingTypeSeparator) + enclosingTypeSeparator + fName;\r", "+\t\t\t// anonymous or local class file\r", "+\t\t\treturn classFileName.substring(0, classFileName.lastIndexOf('.')); // remove .class\r", "+\t} else {\r", "+\t\treturn \r", "+\t\t\tdeclaringType.getTypeQualifiedName(enclosingTypeSeparator)\r", "+\t\t\t+ enclosingTypeSeparator\r", "+\t\t\t+ fName;\r", "-\tAssert.isTrue(false); // should not be reachable\r", "-\treturn null;\r"]}], "num": 45281}