{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a29632416506a74bee4c0fe51deb9616", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "972d97ec56ec532030f735d6d39d8b47", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tprivate void locateMatches(JavaProject javaProject) throws JavaModelException", "signatureAfterChange": " \tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["+\tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "+\t\t", "+\t\t// copy array because elements  from the original are removed below", "+\t\tPotentialMatch[] copy = new PotentialMatch[length];", "+\t\tSystem.arraycopy(potentialMatches, start, copy, 0, length);", "+\t\tthis.initialize(javaProject, copy);", "+\t\t", "+\t\tthis.compilationAborted = false;", "+\t\t", "+\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\t\ttry {", "+\t\t\tthis.createAndResolveBindings(potentialMatches, start, length);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}", "+\t\t", "+\t\t// create hierarchy resolver if needed", "+\t\ttry {", "+\t\t\tif (!this.compilationAborted && !this.createHierarchyResolver(copy)) {", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}", "+\t\t", "+\t\t// free memory", "+\t\tcopy = null;", "+\t\tpotentialMatches = null;", "+\t\t", "+\t\t// potential match resolution", "+\t\ttry {", "+\t\t\tCompilationUnitDeclaration unit = null;", "+\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "+\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "+\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\t}", "+\t\t\t\tunit = this.unitsToProcess[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tprocess(unit, i);", "+\t\t\t\t} catch (AbortCompilation e) {", "+\t\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\t\tthis.compilationAborted = true;", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tif (e instanceof JavaModelException) {", "+\t\t\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\t\t\tthis.compilationAborted = true;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// core exception thrown by client's code: let it through", "+\t\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\t// cleanup compilation unit result", "+\t\t\t\t\tunit.cleanUp();", "+\t\t\t\t\tif (this.options.verbose)", "+\t\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\tString.valueOf(totalUnits),", "+\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())}));", "+\t\t\t\t}", "+\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "+\t\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\tthis.progressMonitor.worked(5);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}\t\t", "+\t}", "-\t */", "-\tprivate void locateMatches(JavaProject javaProject) throws JavaModelException {", "-\t\tMatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(javaProject.getPackageFragmentRoots());", "-\t", "-\t\tthis.compilationAborted = false;", "-", "-\t\tif (this.pattern.needsResolve) {", "-\t\t\tthis.createAndResolveBindings(openables);", "-\t\t}", "-", "-\t\t// create hierarchy resolver if scope is a hierarchy scope", "-\t\tif (this.scope instanceof HierarchyScope) {", "-\t\t\tIType focusType = ((HierarchyScope)this.scope).focusType;", "-\t\t\tif (focusType != null) {", "-\t\t\t\tif (!focusType.isBinary()) {", "-\t\t\t\t\t// cache all types in the focus' compilation unit (even secondary types)", "-\t\t\t\t\tthis.accept((ICompilationUnit)focusType.getCompilationUnit());", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tchar[] fullyQualifiedName = focusType.getFullyQualifiedName().toCharArray();", "-\t\t\t\tthis.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);", "-\t\t\t\tif (this.hierarchyResolver.setFocusType(CharOperation.splitOn('.', fullyQualifiedName)) == null) {", "-\t\t\t\t\t// focus type is not visible from this project", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tthis.hierarchyResolver = null;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tthis.hierarchyResolver = null;", "-\t\t}", "-", "-\t\t// matching openable resolution", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) { ", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {", "-\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t}", "-\t\t\t ", "-\t\t\ttry {", "-\t\t\t\tthis.currentMatchingOpenable = openables[i];", "-\t\t\t\t", "-\t\t\t\tif (!this.currentMatchingOpenable.hasAlreadyDefinedType()) {", "-\t\t\t\t\tthis.currentMatchingOpenable.locateMatches();", "-\t\t\t\t} // else skip type has it is hidden so not visible", "-\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\tcompilationAborted = true;", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\tcompilationAborted = true;", "-\t\t\t\t} else {", "-\t\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tthis.currentMatchingOpenable.reset();", "-\t\t\t}", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.worked(3);", "-\t\t\t}", "-\t\t}", "-\t\tthis.currentMatchingOpenable = null;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc32630eb8ea987c7a9a99a5f12ceaa3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["-\tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "-\t\t", "-\t\t// copy array because elements  from the original are removed below", "-\t\tPotentialMatch[] copy = new PotentialMatch[length];", "-\t\tSystem.arraycopy(potentialMatches, start, copy, 0, length);", "-\t\tthis.initialize(javaProject, copy);", "-\t\t", "-\t\tthis.compilationAborted = false;", "-\t\t", "-\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\t\ttry {", "-\t\t\tthis.createAndResolveBindings(potentialMatches, start, length);", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}", "-\t\t", "-\t\t// create hierarchy resolver if needed", "-\t\ttry {", "-\t\t\tif (!this.compilationAborted && !this.createHierarchyResolver(copy)) {", "-\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\t\tcomputeSuperTypeNames();", "-\t\t\t\tif (this.allSuperTypeNames == null) return;", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t", "-\t\t// free memory", "-\t\tcopy = null;", "-\t\tpotentialMatches = null;", "-\t\t", "-\t\t// potential match resolution", "-\t\ttry {", "-\t\t\tCompilationUnitDeclaration unit = null;", "-\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "-\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tunit = this.unitsToProcess[i];", "-\t\t\t\ttry {", "-\t\t\t\t\tprocess(unit, i);", "-\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t} finally {", "-\t\t\t\t\t// cleanup compilation unit result", "-\t\t\t\t\tunit.cleanUp();", "-\t\t\t\t\tif (this.options.verbose)", "-\t\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+}", "+protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "+\tinitialize(javaProject, length);", "+", "+\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\tboolean bindingsWereCreated = true;", "+\ttry {", "+\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\tbuildBindings(potentialMatches[i]);", "+\t\tlookupEnvironment.completeTypeBindings();", "+", "+\t\t// create hierarchy resolver if needed", "+\t\tIType focusType = getFocusType();", "+\t\tif (focusType == null) {", "+\t\t\tthis.hierarchyResolver = null;", "+\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "+\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t}", "+\t} catch (AbortCompilation e) {", "+\t\tbindingsWereCreated = false;", "+\t}", "+", "+\t// potential match resolution", "+\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\tthrow new OperationCanceledException();", "+\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "+\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\ttry {", "+\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (CoreException e) {", "+\t\t\t// core exception thrown by client's code: let it through", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tif (this.options.verbose)", "+\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\t\tString.valueOf(totalUnits),", "-\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())}));", "-\t\t\t\t}", "-\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "-\t\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "-\t\t\t\tif (this.progressMonitor != null) {", "-\t\t\t\t\tthis.progressMonitor.worked(5);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}\t\t", "-\t}", "+\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "+\t\t\t// cleanup compilation unit result", "+\t\t\tpotentialMatch.parsedUnit.cleanUp();", "+\t\t\tpotentialMatch.parsedUnit = null;", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.worked(5);", "+\t}", "+}"]}], "num": 60016}