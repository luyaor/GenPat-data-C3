{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a6fc4c72ef5e98217bd5b5be901c1606", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2efdf06267cbbf4e821a9b0c2cb70b5a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public MethodBinding findMethod( \tReferenceBinding receiverType, \tchar[] selector, \tTypeBinding[] argumentTypes, \tInvocationSite invocationSite)", "signatureAfterChange": " public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-public MethodBinding findMethod(", "-\tReferenceBinding receiverType,", "-\tchar[] selector,", "-\tTypeBinding[] argumentTypes,", "-\tInvocationSite invocationSite) {", "-", "-\t\tReferenceBinding currentType = receiverType;", "-\t\tMethodBinding matchingMethod = null;", "-\t\tObjectVector found = new ObjectVector();", "-", "-\t\t//compilationUnitScope().recordTypeReference(receiverType);", "-\t\t//compilationUnitScope().recordTypeReferences(argumentTypes);", "-", "-\t\tif (currentType.isInterface()) {", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tint currentLength = currentMethods.length;", "-\t\t\tif (currentLength == 1) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 1) {", "-\t\t\t\tfor (int f = 0; f < currentLength; f++)", "-\t\t\t\t\tfound.add(currentMethods[f]);", "-\t\t\t}", "-\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);", "-\t\t\tcurrentType = getJavaLangObject();", "-\t\t}", "-", "-\t\t// superclass lookup", "-\t\tReferenceBinding classHierarchyStart = currentType;", "-\t\t", "-\t\twhile (currentType != null) {", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tint currentLength = currentMethods.length;", "-\t\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 0) {", "-\t\t\t\tif (found.size == 0 && matchingMethod != null)", "-\t\t\t\t\tfound.add(matchingMethod);", "-\t\t\t\tfor (int f = 0; f < currentLength; f++)", "-\t\t\t\t\tfound.add(currentMethods[f]);", "-\t\t\t}", "-\t\t\tcurrentType = currentType.superclass();", "-\t\t}", "-", "-\t\tint foundSize = found.size;", "-\t\tif (foundSize == 0) {", "-\t\t\tif (matchingMethod == null){", "-\t\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\t}", "-\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility", "-\t\t}", "-\t\tMethodBinding[] candidates = new MethodBinding[foundSize];", "-\t\tint candidatesCount = 0;", "-", "-\t\t// argument type compatibility check", "-\t\tfor (int i = 0; i < foundSize; i++) {", "-\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);", "-\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\tif (compatibleMethod != null)", "-\t\t\t\tcandidates[candidatesCount++] = compatibleMethod;", "-\t\t}", "-\t\tif (candidatesCount == 1) {", "-\t\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0]; // have not checked visibility", "-\t\t}", "-\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters", "-\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-", "-\t\t\tint argLength = argumentTypes.length;", "-\t\t\tfoundSize = found.size;", "-\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {", "-\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);", "-\t\t\t\tTypeBinding[] params = methodBinding.parameters;", "-\t\t\t\tint paramLength = params.length;", "-\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {", "-\t\t\t\t\tTypeBinding arg = argumentTypes[a];", "-\t\t\t\t\tfor (int p = 0; p < paramLength; p++)", "-\t\t\t\t\t\tif (params[p] == arg)", "-\t\t\t\t\t\t\tcontinue nextArg;", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t}", "-\t\t\t\treturn methodBinding;", "-\t\t\t}", "-\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found", "-\t\t}", "-", "-\t\t// visibility check", "-\t\tint visiblesCount = 0;", "-\t\tfor (int i = 0; i < candidatesCount; i++) {", "-\t\t\tMethodBinding methodBinding = candidates[i];", "-\t\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {", "-\t\t\t\tif (visiblesCount != i) {", "-\t\t\t\t\tcandidates[i] = null;", "-\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "-\t\t\t\t}", "-\t\t\t\tvisiblesCount++;", "-\t\t\t}", "-\t\t}", "-\t\tif (visiblesCount == 1) {", "-\t\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 0) {", "-\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tcandidates[0].selector,", "-\t\t\t\tcandidates[0].parameters,", "-\t\t\t\tcandidates[0].declaringClass,", "-\t\t\t\tProblemReasons.NotVisible);", "-\t\t}\t", "-\t\tif (!candidates[0].declaringClass.isInterface()) {", "-\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount, invocationSite);", "-\t\t} else {", "-\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount, invocationSite);", "-\t\t}", "-\t}", "+public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\tMethodBinding methodBinding = super.findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\tif (methodBinding != null && methodBinding.isValidBinding())", "+\t\tif (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))", "+\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "+\treturn methodBinding;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38b3e0ae3d13fa7f7d8fb91231aa60fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "424434f0bc8f5f118b22e054c33acbc180d3cbd4", "commitAfterChange": "64b84380d0460c14fe634e03cccf1a33ab7ee879", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "diff": ["-\t\t// abstract superclass superinterface lookup (since maybe missing default\r", "-\t\t// abstract methods)\r", "-\t\tif (hierarchyContainsAbstractClasses){\r", "-\t\t\tcurrentType = classHierarchyStart;\r", "-\t\t\twhile (currentType != null){\r", "-\t\t\t\tif (currentType.isAbstract()){\r", "-\t\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "-\t\t\t\t}\r", "-\t\t\t\tcurrentType = currentType.superclass();\r", "+\t\tint foundSize = found.size;\r", "+\t\tif (foundSize == 0) {\r", "+\t\t\tif (matchingMethod == null && hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\t}\r", "+\t\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\t\tint candidatesCount = 0;\r", "+\r", "+\t\t// argument type compatibility check\r", "+\t\tfor (int i = 0; i < foundSize; i++) {\r", "+\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\tif (areParametersAssignable(methodBinding.parameters, argumentTypes))\r", "+\t\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "+\t\t}\r", "+\t\tif (candidatesCount == 1)\r", "+\t\t\treturn candidates[0]; // have not checked visibility\r", "+\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\tint argLength = argumentTypes.length;\r", "+\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {\r", "+\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\t\tTypeBinding[] params = methodBinding.parameters;\r", "+\t\t\t\tint paramLength = params.length;\r", "+\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {\r", "+\t\t\t\t\tTypeBinding arg = argumentTypes[a];\r", "+\t\t\t\t\tfor (int p = 0; p < paramLength; p++)\r", "+\t\t\t\t\t\tif (params[p] == arg)\r", "+\t\t\t\t\t\t\tcontinue nextArg;\r", "+\t\t\t\t\tcontinue nextMethod;\r", "+\t\t\t\t}\r", "+\t\t\t\treturn methodBinding;\r", "+\t\t\t}\r", "+\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found\r", "-\t\tint foundSize = found.size;\r", "-\t\tif (foundSize == 0)\r", "-\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\t// visibility check\r", "+\t\tint visiblesCount = 0;\r", "+\t\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {\r", "+\t\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t\t}\r", "+\t\t\t\tvisiblesCount++;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (visiblesCount == 1) {\r", "+\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\t\treturn candidates[0];\r", "+\t\t}\r", "+\t\tif (visiblesCount == 0) {\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\treturn new ProblemMethodBinding(\r", "+\t\t\t\tcandidates[0].selector,\r", "+\t\t\t\targumentTypes,\r", "+\t\t\t\tcandidates[0].declaringClass,\r", "+\t\t\t\tNotVisible);\r", "+\t\t}\t\r", "+\t\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t\t} else {\r", "+\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t\t}\r", "+\t}\r", "-\t\tif (candidates[0].declaringClass.isClass()) {\r", "-\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "-\t\t} else {\r", "-\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "-\t\t}\r"]}], "num": 45133}