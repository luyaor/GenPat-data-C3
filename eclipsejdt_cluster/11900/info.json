{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7f363123375b63b869dcf3e9b51c3691", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a717ef70a401349e6a824106ce510255", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "a746953c3c39228e621101bf14cd960b61f268e5", "commitAfterChange": "8d9e4d82b7907a3f11b58a9fee1e77dc3999b852", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean prefixMatch)", "signatureAfterChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean samePartCount)", "diff": ["-public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean prefixMatch) {", "+public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd, boolean samePartCount) {", "-\t/*", "+\t/* !!!!!!!!!! WARNING !!!!!!!!!!", "-\t * CharOperation#camelCaseMatch(char[], int, int, char[], int, int, boolean)", "+\t * CharOperation#camelCaseMatch(char[], int, int, char[], int, int, boolean).", "-\t * WARNING: Do not change one of these methods without changing the other", "-\t * the same way otherwise behavior differences may appear while using them...", "+\t * ", "+\t * So, do NOT modify this method directly to fix any bug but modify first the", "+\t * corresponding CharOperation method and do the copy again to be sure that", "+\t * these two methods are kept synchronized.", "-\t", "+", "-\t\t\t// it's a match if not exact mode or name is also exhausted", "-\t\t\tif (prefixMatch || iName == nameEnd) return true;", "+\t\t\t// it's a match if the name can have additional parts (i.e. uppercase characters) or is also exhausted", "+\t\t\tif (!samePartCount || iName == nameEnd) return true;", "-\t\t\t// it's not a match if last pattern character is a lowercase", "-\t\t\tif ((patternChar = pattern.charAt(iPattern-1)) < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & (ScannerHelper.C_UPPER_LETTER | ScannerHelper.C_DIGIT)) == 0) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar) && !Character.isDigit(patternChar)) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-", "-\t\t\t// it's a match only if name has no more uppercase characters (exact mode)", "+\t\t\t// otherwise it's a match only if the name has no more uppercase characters", "-\t\t\t\t\t// we have exhausted name, so it's a match", "+\t\t\t\t\t// we have exhausted the name, so it's a match", "+\t\t\t\t// test if the name character is uppercase", "-\t\t\t\t\t\t// nameChar is uppercase, so it's not a match", "-\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "+\t\t\t// We have exhausted the name (and not the pattern), so it's not a match "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2dd59f7a366d538fc8909917912fe66", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java", "commitBeforeChange": "a746953c3c39228e621101bf14cd960b61f268e5", "commitAfterChange": "8d9e4d82b7907a3f11b58a9fee1e77dc3999b852", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean prefixMatch)", "signatureAfterChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean samePartCount)", "diff": ["-public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean prefixMatch) {", "+public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean samePartCount) {", "+", "+\t/* !!!!!!!!!! WARNING !!!!!!!!!!", "+\t * The content of this method has been fully copied to", "+\t * SearchPattern#camelCaseMatch(String, int, int, String, int, int, boolean).", "+\t * ", "+\t * So, if current method is modified, do NOT forget to copy again its content", "+\t * to SearchPattern corresponding method!", "+\t */", "+", "-\t\t\t// it's a match if not exact mode or name is also exhausted", "-\t\t\tif (prefixMatch || iName == nameEnd) return true;", "+\t\t\t// it's a match if the name can have additional parts (i.e. uppercase characters) or is also exhausted", "+\t\t\tif (!samePartCount || iName == nameEnd) return true;", "-\t\t\t// it's not a match if last pattern character is a lowercase", "-\t\t\tif ((patternChar = pattern[iPattern-1]) < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & (ScannerHelper.C_UPPER_LETTER | ScannerHelper.C_DIGIT)) == 0) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar) && !Character.isDigit(patternChar)) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-", "-\t\t\t// it's a match only if name has no more uppercase characters (exact mode)", "+\t\t\t// otherwise it's a match only if the name has no more uppercase characters", "-\t\t\t\t\t// we have exhausted name, so it's a match", "+\t\t\t\t\t// we have exhausted the name, so it's a match", "+\t\t\t\t// test if the name character is uppercase", "-\t\t\t\t\t\t// nameChar is uppercase, so it's not a match", "-\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "+\t\t\t// We have exhausted the name (and not the pattern), so it's not a match "]}], "num": 11900}