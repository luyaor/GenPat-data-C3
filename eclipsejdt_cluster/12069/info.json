{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fa143244bde1309bcd51c10748c8544c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4268c0441fd049f61771ab2b43822f4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java", "commitBeforeChange": "cd65b8d76037ea98de2f66f3cc29001c505073c6", "commitAfterChange": "dfc12356d0e56187f27726140c3e4ba7be8134b7", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void initializeBounds(ParameterizedTypeBinding capturedParameterizedType)", "signatureAfterChange": " \tpublic void initializeBounds(ParameterizedTypeBinding capturedParameterizedType)", "diff": ["+\t\tReferenceBinding substitutedVariableSuperclass = (ReferenceBinding) Scope.substitute(capturedParameterizedType, originalVariableSuperclass);", "-\t\tReferenceBinding substitutedVariableSuperclass = originalVariableSuperclass.isTypeVariable() ? originalVariableSuperclass : (ReferenceBinding) Scope.substitute(capturedParameterizedType, originalVariableSuperclass);", "-\t\tReferenceBinding[] substitutedVariableInterfaces = Scope.substitute(capturedParameterizedType, wildcardVariable.superInterfaces());", "+\t\tif (substitutedVariableSuperclass == this) substitutedVariableSuperclass = originalVariableSuperclass;", "+\t\t", "+\t\tReferenceBinding[] originalVariableInterfaces = wildcardVariable.superInterfaces();\t\t", "+\t\tReferenceBinding[] substitutedVariableInterfaces = Scope.substitute(capturedParameterizedType, originalVariableInterfaces);", "+\t\tif (substitutedVariableInterfaces != originalVariableInterfaces) {", "+\t\t\t// prevent cyclic capture: given X<T>, capture(X<? extends T> could yield a circular type", "+\t\t\tfor (int i = 0, length = substitutedVariableInterfaces.length; i < length; i++) {", "+\t\t\t\tif (substitutedVariableInterfaces[i] == this) substitutedVariableInterfaces[i] = originalVariableInterfaces[i];", "+\t\t\t}", "+\t\t}", "+\t\tTypeBinding originalWildcardBound = wildcard.bound;", "+\t\t// prevent cyclic capture: given X<T>, capture(X<? extends T> could yield a circular type", "+\t\tTypeBinding substitutedWildcardBound = originalWildcardBound == null ? null : Scope.substitute(capturedParameterizedType, originalWildcardBound);", "+\t\tif (substitutedWildcardBound == this) substitutedWildcardBound = originalWildcardBound;", "-\t\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[] { (ReferenceBinding) wildcard.bound };", "+\t\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[] { (ReferenceBinding) substitutedWildcardBound };", "-\t\t\t\tTypeBinding substitutedWildcardBound = Scope.substitute(capturedParameterizedType, wildcard.bound);", "-\t\t\t\t// prevent cyclic capture: given X<T>, capture(X<? super T> could yield a circular type", "-\t\t\t\tsubstitutedWildcardBound = wildcard.bound.isTypeVariable() ? wildcard.bound : Scope.substitute(capturedParameterizedType, wildcard.bound);", "-\t\t\t\tif (wildcardVariable.firstBound == this.superclass ", "-\t\t\t\t\t\t|| substitutedWildcardBound == this.superclass) {", "-\t\t\t\t\tthis.firstBound = this.superclass;", "+\t\t\t\tif (wildcardVariable.firstBound == substitutedVariableSuperclass || substitutedWildcardBound == substitutedVariableSuperclass) {", "+\t\t\t\t\tthis.firstBound = substitutedVariableSuperclass;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "952efe967cd451f9b5243fccd04cdf55", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "fb2d7d99aabb8ff6fc09a1333f98ae4d56a6ccdf", "commitAfterChange": "9c8a866e1dfa3b05dfb4303df292630a591df281", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic String getQualifiedName()", "signatureAfterChange": " \tpublic String getQualifiedName()", "diff": ["-\t\t\t\t.append('.')", "-\t\t\t\t.append(getName());", "+\t\t\t\t.append('.');", "+\t\t\tif (isParameterizedType()) {", "+\t\t\t\tParameterizedTypeBinding parameterizedTypeBinding = (ParameterizedTypeBinding) this.binding;", "+\t\t\t\tbuffer.append(parameterizedTypeBinding.sourceName());", "+\t\t\t\tITypeBinding[] typeArguments = getTypeArguments();", "+\t\t\t\tfinal int typeArgumentsLength = typeArguments.length;", "+\t\t\t\tif (typeArgumentsLength != 0) {", "+\t\t\t\t\tbuffer.append('<');", "+\t\t\t\t\tfor (int i = 0, max = typeArguments.length; i < max; i++) {", "+\t\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbuffer.append(typeArguments[i].getQualifiedName());", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append('>');\t", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(getName());", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "95ffcf83c8dc12192b28e750b41441e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "64d39f3567030242a0089e54dec7b20eb2379aa8", "commitAfterChange": "61bef0fdf04ab68e34740d553b6ad5e9433edc7e", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 53, "signatureBeforeChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "signatureAfterChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "diff": ["+\t\t\t\t\t\t\t\t\tif ((result & ClasspathChange.HAS_LIBRARY_CHANGE) != 0) {", "+\t\t\t\t\t\t\t\t\t\tstate.addExternalFolderChange(change.project, change.oldResolvedClasspath);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tHashSet existingElements = this.state.removeExternalElementsToRefresh();", "-\t\t\t\t\t\t\t\tif (existingElements != null) {", "-\t\t\t\t\t\t\t\t\telementsToRefresh.addAll(existingElements);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tHashSet newElementsToRefresh = this.state.removeExternalElementsToRefresh();", "+\t\t\t\t\t\t\t\tif (newElementsToRefresh != null)", "+\t\t\t\t\t\t\t\t\telementsToRefresh.addAll(newElementsToRefresh);", "+\t\t\t\t// update external folders if necessary", "+\t\t\t    ExternalFolderChange[] folderChanges = this.state.removeExternalFolderChanges();", "+\t\t\t\tif (folderChanges != null) {", "+\t\t\t\t    for (int i = 0, length = folderChanges.length; i < length; i++) {", "+\t\t\t\t        try {", "+\t\t\t\t\t        folderChanges[i].updateExternalFoldersIfNecessary(null);", "+\t\t\t\t        } catch (JavaModelException e) {", "+\t\t\t\t        \tif (!e.isDoesNotExist())", "+\t\t\t\t        \t\tUtil.log(e, \"Exception while updating external folders\"); //$NON-NLS-1$", "+\t\t\t\t        }", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t        \tif (!e.isDoesNotExist())", "+\t\t\t\t        \t\tUtil.log(e, \"Exception while updating project references\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac2633e1c1ba2b98577bc8c0f7da65bc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/HashtableOfObjectToIntArray.java", "commitBeforeChange": "69f7860162afcfc8030db1b89728ef29dad30425", "commitAfterChange": "12f67d7a75389e2a993321c57a8e613bfbfd0a38", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tpublic String toString()", "signatureAfterChange": "  \tpublic String toString()", "diff": ["-\t\tString s = \"\"; //$NON-NLS-1$", "+\t\tStringBuffer buffer = new StringBuffer();", "-\t\tfor (int i = 0, length = this.keyTable.length; i < length; i++)", "-\t\t\tif ((key = this.keyTable[i]) != null)", "-\t\t\t\ts += key + \" -> \" + this.valueTable[i] + \"\\n\"; \t//$NON-NLS-2$ //$NON-NLS-1$", "-\t\treturn s;", "+\t\tfor (int i = 0, length = this.keyTable.length; i < length; i++) {", "+\t\t\tif ((key = this.keyTable[i]) != null) {", "+\t\t\t\tbuffer.append(key).append(\" -> \"); //$NON-NLS-1$", "+\t\t\t\tint[] ints = this.valueTable[i];", "+\t\t\t\tbuffer.append('[');", "+\t\t\t\tif (ints != null) {", "+\t\t\t\t\tfor (int j = 0, max = ints.length; j < max; j++) {", "+\t\t\t\t\t\tif (j > 0) {", "+\t\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbuffer.append(ints[j]);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbuffer.append(\"]\\n\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+\t\treturn String.valueOf(buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f59366d07ead035c8972a71f3330aeb2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/OrPattern.java", "commitBeforeChange": "9037a5669c89fc0ae3f8548a99dce6fa5402fb31", "commitAfterChange": "e4e1e1935f0e7607d1265df332c7ce922de89c18", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException", "diff": ["-\tint leftLevel = this.leftPattern.matchLevel(reference, true);", "-\tif (leftLevel == ACCURATE_MATCH || leftLevel == INACCURATE_MATCH) {", "-\t\tthis.leftPattern.matchReportReference(reference, element, accuracy, locator);", "-\t} else {", "-\t\tthis.rightPattern.matchReportReference(reference, element, accuracy, locator);", "+\tif (this.bestMatch != null) {", "+\t\tthis.bestMatch.matchReportReference(reference, element, accuracy, locator);", "+\t\treturn;", "+", "+\tSearchPattern closestPattern = null;", "+\tint level = IMPOSSIBLE_MATCH;", "+\tfor (int i = 0, length = this.patterns.length; i < length; i++) {", "+\t\tint newLevel = this.patterns[i].matchLevel(reference, true);", "+\t\tif (newLevel > level) {", "+\t\t\tif (newLevel == ACCURATE_MATCH) {", "+\t\t\t\tthis.patterns[i].matchReportReference(reference, element, accuracy, locator);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tlevel = newLevel;", "+\t\t\tclosestPattern = this.patterns[i];", "+\t\t}", "+\t}", "+\tif (closestPattern != null)", "+\t\tclosestPattern.matchReportReference(reference, element, accuracy, locator);"]}], "num": 12069}