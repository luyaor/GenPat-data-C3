{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b783f7fcbdeeed3acebcf3eae0b133d8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4be9486e4526272e4d9d6bb5082e1de1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "c0e1e1c2d0d55cd15c5294fbd89785d2ab8aa5fc", "commitAfterChange": "985d711c4d0025a5a5339070a94d4c12c56e272f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "signatureAfterChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "diff": ["-\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);", "-\t\t\t\treturn checkCastTypesCompatibility(scope, castType, expressionType.erasure(), expression);", "+\t\t\t\treturn checkCastTypesCompatibility(scope, castType, ((TypeVariableBinding)expressionType).upperBound(), expression);", "-\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);", "-\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, castType.erasure(), expressionType, expression);", "+\t\t\t\t\t\t\treturn checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);", "-\t\t\t\t\t\t\t\t// ( INTERFACE ) CLASS\t\t", "-\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t// ( INTERFACE ) CLASS", "+\t\t\t\t\t\t\t\tReferenceBinding refExprType = (ReferenceBinding) expressionType;", "+\t\t\t\t\t\t\t\tmatch = refExprType.findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "+\t\t\t\t\t\t\t\tif (refExprType.isFinal()) {", "+\t\t\t\t\t\t\t\t\t// unless final a subclass may implement the interface ==> no check at compile time", "+\t\t\t\t\t\t\t\t\tif (match == null || !match.isCompatibleWith(castType)) {", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// unless final a subclass may implement the interface ==> no check at compile time", "-\t\t\t\t\t\t\t\tif (((ReferenceBinding) expressionType).isFinal()) {", "-\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "+\t\t\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c9331c88aba3d33b66b19e4bbd5193be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "d5ff27f4ac6567ec3845ab2a4c87d426d2f2009e", "commitAfterChange": "2a1e455dd4c823fdae35f395f819afea5a811300", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,\tInvocationSite invocationSite)", "diff": ["+\t\t\t} else if (compilerOptions.sourceLevel == ClassFileConstants.JDK1_7) {", "+\t\t\t\t// bug 425203 - consider additional constraints to conform to buggy javac behavior", "+\t\t\t\tif (methodSubstitute.returnType != TypeBinding.VOID) {", "+\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "+\t\t\t\t\t// In case of a method like <T> List<T> foo(T arg), solution based on return type", "+\t\t\t\t\t// should not be preferred vs solution based on parameter types, so do not attempt", "+\t\t\t\t\t// to use return type based inference in this case", "+ \t\t\t\t\tif (expectedType != null && !originalMethod.returnType.mentionsAny(originalMethod.parameters, -1)) {", "+\t\t\t\t\t\tTypeBinding uncaptured = methodSubstitute.returnType.uncapture(scope);", "+\t\t\t\t\t\tif (!methodSubstitute.returnType.isCompatibleWith(expectedType) &&", "+\t\t\t\t\t\t\t\texpectedType.isCompatibleWith(uncaptured)) { ", "+\t\t\t\t\t\t\tInferenceContext oldContext = inferenceContext;", "+\t\t\t\t\t\t\tinferenceContext = new InferenceContext(originalMethod);", "+\t\t\t\t\t\t\t// Include additional constraint pertaining to the expected type", "+\t\t\t\t\t\t\toriginalMethod.returnType.collectSubstitutes(scope, expectedType, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t\tParameterizedGenericMethodBinding substitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);", "+\t\t\t\t\t\t\tif (substitute != null && substitute.returnType.isCompatibleWith(expectedType)) {", "+\t\t\t\t\t\t\t\t// Do not use the new solution if it results in incompatibilities in parameter types", "+\t\t\t\t\t\t\t\tif ((scope.parameterCompatibilityLevel(substitute, arguments, false)) > Scope.NOT_COMPATIBLE) {", "+\t\t\t\t\t\t\t\t\tmethodSubstitute = substitute;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tinferenceContext = oldContext;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tinferenceContext = oldContext;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t}"]}], "num": 56625}