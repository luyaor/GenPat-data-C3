{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6a32c7489feca477abf76398965569b7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0608deef87e1c279a291afa0c1f23ab5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "d2d42dc68198e20f3f5cc7326a07cced2c751eb5", "commitAfterChange": "add5c6babb13b20df1267306ec710a4efca88a4d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r \r public static final boolean convertToTypeFromTypeValue(int left , int right, Constant cst)", "signatureAfterChange": "\r \r public static final boolean isConstantValueRepresentable(Constant constant, int constantTypeID, int targetTypeID)", "diff": ["-public static final boolean convertToTypeFromTypeValue(int left , int right, Constant cst){\r", "-\t//true if there is no loose of information while casting.\r", "-\t//right is constant's type.id\r", "+public static final boolean isConstantValueRepresentable(Constant constant, int constantTypeID, int targetTypeID){\r", "+\t//true if there is no loss of precision while casting.\r", "+\t// constantTypeID == constant.typeID\r", "-\t//a faster solution would be to use combinaison of \r", "-\t//some range.........????\r", "-\r", "-\r", "-\t/*\r", "-\torg.eclipse.jdt.internal.compiler.util.Constant cst ;\r", "-\tcst = org.eclipse.jdt.internal.compiler.util.Constant.fromValue((float)898565456.0) ;\r", "-\torg.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.convertToTypeFromTypeValue(\r", "-\torg.eclipse.jdt.internal.compiler.ast.TypeReference.T_int,\r", "-\torg.eclipse.jdt.internal.compiler.ast.TypeReference.T_float,\r", "-\tcst)\r", "-\t*/\r", "-\t\r", "-\tif (left == right) return true ;\r", "-\tswitch(left){\r", "+\tif (targetTypeID == constantTypeID) return true ;\r", "+\tswitch(targetTypeID){\r", "-\t\t\t\tswitch (right) {\r", "+\t\t\t\tswitch (constantTypeID) {\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.charValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.charValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.charValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.charValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.charValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.charValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.charValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue() == constant.charValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.charValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.charValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.charValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.charValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.floatValue() ;\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.floatValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.floatValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.floatValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.floatValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.floatValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.floatValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.floatValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.floatValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.floatValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.floatValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.floatValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.doubleValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.doubleValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.doubleValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.doubleValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.doubleValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.doubleValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.doubleValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue()\t== constant.doubleValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.doubleValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.doubleValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.doubleValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.doubleValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.byteValue() ;\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.byteValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.byteValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.byteValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.byteValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.byteValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.byteValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue() == constant.byteValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.byteValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.byteValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.byteValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.byteValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.shortValue() ;\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.shortValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.shortValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.shortValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.shortValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.shortValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue() == constant.shortValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.shortValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.shortValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.shortValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.shortValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.shortValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.intValue() ;\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.intValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.intValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.intValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.intValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue() == constant.intValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.intValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.intValue() ;\r", "-\t\t\t\t\tcase T_long   : return cst.longValue() \t== cst.intValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.intValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.intValue() ;\r", "+\t\t\t\t\tcase T_long   : return constant.longValue() == constant.intValue() ;\r", "-\t\t\t\tswitch (right) {\r", "-\t\t\t\t\tcase T_char\t: return cst.charValue() \t== cst.longValue() ;\r", "-\t\t\t\t\tcase T_double : return cst.doubleValue() \t== cst.longValue() ;\r", "-\t\t\t\t\tcase T_float  : return cst.floatValue() \t== cst.longValue() ;\r", "-\t\t\t\t\tcase T_int    : return cst.intValue() \t== cst.longValue() ;\r", "-\t\t\t\t\tcase T_short  : return cst.shortValue() \t== cst.longValue() ;\r", "-\t\t\t\t\tcase T_byte   : return cst.byteValue() \t== cst.longValue() ;\r", "+\t\t\t\tswitch (constantTypeID) {\r", "+\t\t\t\t\tcase T_char\t: return constant.charValue() == constant.longValue() ;\r", "+\t\t\t\t\tcase T_double : return constant.doubleValue() == constant.longValue() ;\r", "+\t\t\t\t\tcase T_float  : return constant.floatValue() == constant.longValue() ;\r", "+\t\t\t\t\tcase T_int    : return constant.intValue() == constant.longValue() ;\r", "+\t\t\t\t\tcase T_short  : return constant.shortValue() == constant.longValue() ;\r", "+\t\t\t\t\tcase T_byte   : return constant.byteValue() == constant.longValue() ;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a491e4db6fbb61b591d44dbde07771ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-}\r", "-public TypeBinding resolveType(BlockScope scope) {\r", "-\t// specs p.368\r", "-\tconstant = NotAConstant;\r", "-\tTypeBinding condTb = condition.resolveTypeExpecting(scope, BooleanBinding);\r", "-\tTypeBinding trueTb = valueIfTrue.resolveType(scope);\r", "-\tTypeBinding falseTb = valueIfFalse.resolveType(scope);\r", "-\tif (condTb == null || trueTb == null || falseTb == null)\r", "-\t\treturn null;\r", "-\t// Propagate the constant value from the valueIfTrue and valueIFFalse expression if it is possible\r", "-\tif (condition.constant != NotAConstant && valueIfTrue.constant != NotAConstant && valueIfFalse.constant != NotAConstant) {\r", "-\t\t// all terms are constant expression so we can propagate the constant\r", "-\t\t// from valueIFTrue or valueIfFalse to teh receiver constant\r", "-\t\tconstant = (condition.constant.booleanValue()) ? valueIfTrue.constant : valueIfFalse.constant;\r", "-\tif (trueTb == falseTb) { // harmed the implicit conversion \r", "-\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\tvalueIfFalse.implicitConversion = valueIfTrue.implicitConversion;\r", "-\t\tif (trueTb == LongBinding || trueTb == DoubleBinding) {\r", "+\r", "+\tpublic TypeBinding resolveType(BlockScope scope) {\r", "+\t\t// specs p.368\r", "+\t\tconstant = NotAConstant;\r", "+\t\tTypeBinding conditionType = condition.resolveTypeExpecting(scope, BooleanBinding);\r", "+\t\tTypeBinding valueIfTrueType = valueIfTrue.resolveType(scope);\r", "+\t\tTypeBinding valueIfFalseType = valueIfFalse.resolveType(scope);\r", "+\t\tif (conditionType == null || valueIfTrueType == null || valueIfFalseType == null)\r", "+\t\t\treturn null;\r", "+\r", "+\t\t// Propagate the constant value from the valueIfTrue and valueIFFalse expression if it is possible\r", "+\t\tif (condition.constant != NotAConstant\r", "+\t\t\t&& valueIfTrue.constant != NotAConstant\r", "+\t\t\t&& valueIfFalse.constant != NotAConstant) {\r", "+\t\t\t// all terms are constant expression so we can propagate the constant\r", "+\t\t\t// from valueIFTrue or valueIfFalse to teh receiver constant\r", "+\t\t\tconstant =\r", "+\t\t\t\t(condition.constant.booleanValue())\r", "+\t\t\t\t\t? valueIfTrue.constant\r", "+\t\t\t\t\t: valueIfFalse.constant;\r", "+\t\t}\r", "+\t\tif (valueIfTrueType == valueIfFalseType) { // harmed the implicit conversion \r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitConversion = valueIfTrue.implicitConversion;\r", "+\t\t\tif (valueIfTrueType == LongBinding || valueIfTrueType == DoubleBinding) {\r", "+\t\t\t\treturnTypeSlotSize = 2;\r", "+\t\t\t}\r", "+\t\t\treturn valueIfTrueType;\r", "+\t\t}\r", "+\t\t// Determine the return type depending on argument types\r", "+\t\t// Numeric types\r", "+\t\tif (valueIfTrueType.isNumericType() && valueIfFalseType.isNumericType()) {\r", "+\t\t\t// (Short x Byte) or (Byte x Short)\"\r", "+\t\t\tif ((valueIfTrueType == ByteBinding && valueIfFalseType == ShortBinding)\r", "+\t\t\t\t|| (valueIfTrueType == ShortBinding && valueIfFalseType == ByteBinding)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(ShortBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(ShortBinding, valueIfFalseType);\r", "+\t\t\t\treturn ShortBinding;\r", "+\t\t\t}\r", "+\t\t\t// <Byte|Short|Char> x constant(Int)  ---> <Byte|Short|Char>   and reciprocally\r", "+\t\t\tif ((valueIfTrueType == ByteBinding || valueIfTrueType == ShortBinding || valueIfTrueType == CharBinding)\r", "+\t\t\t\t&& (valueIfFalseType == IntBinding\r", "+\t\t\t\t\t&& valueIfFalse.isConstantValueOfTypeAssignableToType(valueIfFalseType, valueIfTrueType))) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(valueIfTrueType, valueIfFalseType);\r", "+\t\t\t\treturn valueIfTrueType;\r", "+\t\t\t}\r", "+\t\t\tif ((valueIfFalseType == ByteBinding\r", "+\t\t\t\t|| valueIfFalseType == ShortBinding\r", "+\t\t\t\t|| valueIfFalseType == CharBinding)\r", "+\t\t\t\t&& (valueIfTrueType == IntBinding\r", "+\t\t\t\t\t&& valueIfTrue.isConstantValueOfTypeAssignableToType(valueIfTrueType, valueIfFalseType))) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(valueIfFalseType, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(valueIfFalseType, valueIfFalseType);\r", "+\t\t\t\treturn valueIfFalseType;\r", "+\t\t\t}\r", "+\t\t\t// Manual binary numeric promotion\r", "+\t\t\t// int\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_int)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_int)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(IntBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(IntBinding, valueIfFalseType);\r", "+\t\t\t\treturn IntBinding;\r", "+\t\t\t}\r", "+\t\t\t// long\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_long)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_long)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(LongBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(LongBinding, valueIfFalseType);\r", "+\t\t\t\treturnTypeSlotSize = 2;\r", "+\t\t\t\treturn LongBinding;\r", "+\t\t\t}\r", "+\t\t\t// float\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_float)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_float)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(FloatBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(FloatBinding, valueIfFalseType);\r", "+\t\t\t\treturn FloatBinding;\r", "+\t\t\t}\r", "+\t\t\t// double\r", "+\t\t\tvalueIfTrue.implicitWidening(DoubleBinding, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(DoubleBinding, valueIfFalseType);\r", "+\t\t\treturn DoubleBinding;\r", "-\t\treturn trueTb;\r", "-\t}\r", "-\r", "-\t// Determine the return type depending on argument types\r", "-\t// Numeric types\r", "-\tif (trueTb.isNumericType() && falseTb.isNumericType()) {\r", "-\t\t// (Short x Byte) or (Byte x Short)\"\r", "-\t\tif ((trueTb == ByteBinding && falseTb == ShortBinding) || (trueTb == ShortBinding && falseTb == ByteBinding)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(ShortBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(ShortBinding, falseTb);\r", "-\t\t\treturn ShortBinding;\r", "+\t\t// Type references (null null is already tested)\r", "+\t\tif ((valueIfTrueType.isBaseType() && valueIfTrueType != NullBinding)\r", "+\t\t\t|| (valueIfFalseType.isBaseType() && valueIfFalseType != NullBinding)) {\r", "+\t\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(\r", "+\t\t\t\tthis,\r", "+\t\t\t\tvalueIfTrueType,\r", "+\t\t\t\tvalueIfFalseType);\r", "+\t\t\treturn null;\r", "-\r", "-\t\t// <Byte|Short|Char> x constant(Int)  ---> <Byte|Short|Char>   and reciprocally\r", "-\t\tif ((trueTb == ByteBinding || trueTb == ShortBinding || trueTb == CharBinding) &&\r", "-\t\t\t(falseTb == IntBinding && valueIfFalse.isConstantValueOfTypeAssignableToType(falseTb, trueTb))) {\r", "-\t\t\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\t\t\tvalueIfFalse.implicitWidening(trueTb, falseTb);\r", "-\t\t\t\treturn trueTb;\r", "+\t\tif (scope.areTypesCompatible(valueIfFalseType, valueIfTrueType)) {\r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(valueIfTrueType, valueIfFalseType);\r", "+\t\t\treturn valueIfTrueType;\r", "-\t\tif ((falseTb == ByteBinding || falseTb == ShortBinding || falseTb == CharBinding) &&\r", "-\t\t\t(trueTb == IntBinding && valueIfTrue.isConstantValueOfTypeAssignableToType(trueTb, falseTb))) {\r", "-\t\t\t\tvalueIfTrue.implicitWidening(falseTb, trueTb);\r", "-\t\t\t\tvalueIfFalse.implicitWidening(falseTb, falseTb);\r", "-\t\t\t\treturn falseTb;\r", "+\t\tif (scope.areTypesCompatible(valueIfTrueType, valueIfFalseType)) {\r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfFalseType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(valueIfFalseType, valueIfFalseType);\r", "+\t\t\treturn valueIfFalseType;\r", "-\r", "-\t\t// Manual binary numeric promotion\r", "-\t\t// int\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_int) && BaseTypeBinding.isNarrowing(falseTb.id, T_int)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(IntBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(IntBinding, falseTb);\r", "-\t\t\treturn IntBinding;\r", "-\t\t}\r", "-\t\t// long\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_long) && BaseTypeBinding.isNarrowing(falseTb.id, T_long)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(LongBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(LongBinding, falseTb);\r", "-\t\t\treturnTypeSlotSize = 2;\r", "-\t\t\treturn LongBinding;\r", "-\t\t}\r", "-\t\t// float\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_float) && BaseTypeBinding.isNarrowing(falseTb.id, T_float)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(FloatBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(FloatBinding, falseTb);\r", "-\t\t\treturn FloatBinding;\r", "-\t\t}\r", "-\t\t// double\r", "-\t\tvalueIfTrue.implicitWidening(DoubleBinding, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(DoubleBinding, falseTb);\r", "-\t\treturnTypeSlotSize = 2;\r", "-\t\treturn DoubleBinding;\r", "-\t}\r", "-\r", "-\t// Type references (null null is already tested)\r", "-\tif ((trueTb.isBaseType() && trueTb != NullBinding) || (falseTb.isBaseType() && falseTb != NullBinding)) {\r", "-\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(this, trueTb, falseTb);\r", "+\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(\r", "+\t\t\tthis,\r", "+\t\t\tvalueIfTrueType,\r", "+\t\t\tvalueIfFalseType);\r", "-\tif (scope.areTypesCompatible(falseTb, trueTb)) {\r", "-\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(trueTb, falseTb);\r", "-\t\treturn trueTb;\r", "-\tif (scope.areTypesCompatible(trueTb, falseTb)) {\r", "-\t\tvalueIfTrue.implicitWidening(falseTb, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(falseTb, falseTb);\r", "-\t\treturn falseTb;\r", "-\t}\r", "-\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(this, trueTb, falseTb);\r", "-\treturn null;\r", "-}\r"]}], "num": 3154}