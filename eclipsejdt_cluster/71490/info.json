{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "31aa6864fbea8a5fbfc8cca6084a592a", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37cab26793bbd17be0a3ee09631afea3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "7ba9ff29fe6b05ec0a2f58eaa1f5d3e68bb11101", "commitAfterChange": "427a01e331e57852efc472cca3a8360bd121fda9", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "signatureAfterChange": "  void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "diff": ["+\tif (this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t// FIXME(stephan): the following code could be used as a stop-gap measure to hook type annotation tagBits into our existing analysis:", "+//\t\tmethodBinding.tagBits |= (methodBinding.returnType.tagBits & TagBits.AnnotationNullMASK);", "+//\t\tTypeBinding[] parameters = methodBinding.parameters;", "+//\t\tint numVisibleParams = parameters.length;", "+//\t\tfor (int j = 0; j < numVisibleParams; j++) {", "+//\t\t\tif ((parameters[j].tagBits & TagBits.AnnotationNonNull) != 0) {", "+//\t\t\t\tif (methodBinding.parameterNonNullness == null)", "+//\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "+//\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.TRUE;", "+//\t\t\t\tbreak;", "+//\t\t\t} else if ((parameters[j].tagBits & TagBits.AnnotationNullable) != 0) {", "+//\t\t\t\tif (methodBinding.parameterNonNullness == null)", "+//\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "+//\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.FALSE;", "+//\t\t\t\tbreak;", "+//\t\t\t}", "+//\t\t}", "+\t\t// END", "+\t\treturn; // not using method.tagBits and parameterNonNullness when we have type annotations.", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "710bf076ecba30c38297c6d7b9845888", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "c7e61e314902d7cf48e71c1a1c0437bb40107c2e", "commitAfterChange": "8a1621e802c664e59aba36b8a87f59ae57902e37", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "signatureAfterChange": "  void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding)", "diff": ["-\tif (this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t// FIXME(stephan): the following code could be used as a stop-gap measure to hook type annotation tagBits into our existing analysis:", "-//\t\tmethodBinding.tagBits |= (methodBinding.returnType.tagBits & TagBits.AnnotationNullMASK);", "-//\t\tTypeBinding[] parameters = methodBinding.parameters;", "-//\t\tint numVisibleParams = parameters.length;", "-//\t\tfor (int j = 0; j < numVisibleParams; j++) {", "-//\t\t\tif ((parameters[j].tagBits & TagBits.AnnotationNonNull) != 0) {", "-//\t\t\t\tif (methodBinding.parameterNonNullness == null)", "-//\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "-//\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.TRUE;", "-//\t\t\t\tbreak;", "-//\t\t\t} else if ((parameters[j].tagBits & TagBits.AnnotationNullable) != 0) {", "-//\t\t\t\tif (methodBinding.parameterNonNullness == null)", "-//\t\t\t\t\tmethodBinding.parameterNonNullness = new Boolean[numVisibleParams];", "-//\t\t\t\tmethodBinding.parameterNonNullness[j] = Boolean.FALSE;", "-//\t\t\t\tbreak;", "-//\t\t\t}", "-//\t\t}", "-\t\t// END", "-\t\treturn; // not using method.tagBits and parameterNonNullness when we have type annotations.", "-\t}", "+\tboolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;", "+\t// in 1.8 we only need @NonNullByDefault, see below and exit further down.", "-\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nonNullAnnotationName)) {", "-\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNull;", "-\t\t\t\texplicitNullness = true;", "-\t\t\t}", "-\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nullableAnnotationName)) {", "-\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNullable;", "-\t\t\t\texplicitNullness = true;", "+\t\t\tif (!useTypeAnnotations) {", "+\t\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nonNullAnnotationName)) {", "+\t\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNonNull;", "+\t\t\t\t\texplicitNullness = true;", "+\t\t\t\t}", "+\t\t\t\tif (!explicitNullness && CharOperation.equals(typeName, nullableAnnotationName)) {", "+\t\t\t\t\tmethodBinding.tagBits |= TagBits.AnnotationNullable;", "+\t\t\t\t\texplicitNullness = true;", "+\t\t\t\t}", "+\tif (useTypeAnnotations)", "+\t\treturn;", "+"]}], "num": 71490}