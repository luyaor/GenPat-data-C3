{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d4b0017384e8c265e9c533212c264cad", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "496bea1739243c9c6f2f515a6dc52795", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tconstant = NotAConstant;", "-\tthis.qualifyingType = this.receiverType = receiver.resolveType(scope); ", "+\tthis.constant = NotAConstant;", "+\tthis.qualifyingType = this.receiverType = this.receiver.resolveType(scope); ", "-\tif (arguments != null) {", "+\tif (this.arguments != null) {", "-\t\tint length = arguments.length;", "+\t\tint length = this.arguments.length;", "-\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)", "+\t\t\tif ((argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "-\tif (receiverType == null) ", "+\tif (this.receiverType == null) ", "-\tif (receiverType.isBaseType()) {", "-\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\tif (this.receiverType.isBaseType()) {", "+\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\tbinding = ", "-\t\treceiver.isImplicitThis()", "-\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(receiverType, selector, argumentTypes, this); ", "-\tif (!binding.isValidBinding()) {", "-\t\tif (binding instanceof ProblemMethodBinding", "-\t\t\t&& ((ProblemMethodBinding) binding).problemId() == NotVisible) {", "+\tthis.binding = ", "+\t\tthis.receiver.isImplicitThis()", "+\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "+\t\t\t: scope.getMethod(this.receiverType, this.selector, argumentTypes, this); ", "+\tif (!this.binding.isValidBinding()) {", "+\t\tif (this.binding instanceof ProblemMethodBinding", "+\t\t\t&& ((ProblemMethodBinding) this.binding).problemId() == NotVisible) {", "-\t\t\t\tdelegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "-\t\t\t\tif (delegateThis == null){ // if not found then internal error, field should have been found", "-\t\t\t\t\tconstant = NotAConstant;", "-\t\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tthis.delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "+\t\t\t\tif (this.delegateThis == null){ // if not found then internal error, field should have been found", "+\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\tconstant = NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\treceiver instanceof CodeSnippetThisReference && ((CodeSnippetThisReference) receiver).isImplicit", "-\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)delegateThis.type, selector, argumentTypes, this)", "-\t\t\t\t\t: localScope.getMethod(delegateThis.type, selector, argumentTypes, this); ", "+\t\t\t\tthis.receiver instanceof CodeSnippetThisReference && ((CodeSnippetThisReference) this.receiver).isImplicit", "+\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, argumentTypes, this)", "+\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, argumentTypes, this); ", "-\t\t\t\tif (binding.declaringClass == null) {", "-\t\t\t\t\tif (receiverType instanceof ReferenceBinding) {", "-\t\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\t\tif (this.receiverType instanceof ReferenceBinding) {", "+\t\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.receiverType;", "-\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\t\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\t\t\t\tbinding = privateBinding;", "+\t\t\t\tthis.binding = privateBinding;", "-\t\t\tif (binding.declaringClass == null) {", "-\t\t\t\tif (receiverType instanceof ReferenceBinding) {", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;", "+\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\tif (this.receiverType instanceof ReferenceBinding) {", "+\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.receiverType;", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);", "+\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "-\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\tscope.problemReporter().invalidMethod(this, this.binding);", "-\tif (!binding.isStatic()) {", "+\tif (!this.binding.isStatic()) {", "-\t\tif (receiver instanceof NameReference) {", "-\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {", "-\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\tif (this.receiver instanceof NameReference) {", "+\t\t\tif ((((NameReference) this.receiver).bits & BindingIds.TYPE) != 0) {", "+\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\tif (arguments != null)", "-\t\tfor (int i = 0; i < arguments.length; i++)", "-\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "+\tif (this.arguments != null)", "+\t\tfor (int i = 0; i < this.arguments.length; i++)", "+\t\t\tthis.arguments[i].implicitWidening(this.binding.parameters[i], argumentTypes[i]);", "-\tif (binding.isAbstract()) {", "-\t\tif (receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "+\tif (this.binding.isAbstract()) {", "+\t\tif (this.receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\tif (isMethodUseDeprecated(binding, scope))", "-\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+\tif (isMethodUseDeprecated(this.binding, scope))", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\treturn this.resolvedType = binding.returnType;", "+\treturn this.resolvedType = this.binding.returnType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "972d97ec56ec532030f735d6d39d8b47", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tprivate void locateMatches(JavaProject javaProject) throws JavaModelException", "signatureAfterChange": " \tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["+\tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "+\t\t", "+\t\t// copy array because elements  from the original are removed below", "+\t\tPotentialMatch[] copy = new PotentialMatch[length];", "+\t\tSystem.arraycopy(potentialMatches, start, copy, 0, length);", "+\t\tthis.initialize(javaProject, copy);", "+\t\t", "+\t\tthis.compilationAborted = false;", "+\t\t", "+\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\t\ttry {", "+\t\t\tthis.createAndResolveBindings(potentialMatches, start, length);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}", "+\t\t", "+\t\t// create hierarchy resolver if needed", "+\t\ttry {", "+\t\t\tif (!this.compilationAborted && !this.createHierarchyResolver(copy)) {", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}", "+\t\t", "+\t\t// free memory", "+\t\tcopy = null;", "+\t\tpotentialMatches = null;", "+\t\t", "+\t\t// potential match resolution", "+\t\ttry {", "+\t\t\tCompilationUnitDeclaration unit = null;", "+\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "+\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "+\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\t}", "+\t\t\t\tunit = this.unitsToProcess[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tprocess(unit, i);", "+\t\t\t\t} catch (AbortCompilation e) {", "+\t\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\t\tthis.compilationAborted = true;", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tif (e instanceof JavaModelException) {", "+\t\t\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\t\t\tthis.compilationAborted = true;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// core exception thrown by client's code: let it through", "+\t\t\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\t// cleanup compilation unit result", "+\t\t\t\t\tunit.cleanUp();", "+\t\t\t\t\tif (this.options.verbose)", "+\t\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\tString.valueOf(totalUnits),", "+\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())}));", "+\t\t\t\t}", "+\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "+\t\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\t\t\tif (this.progressMonitor != null) {", "+\t\t\t\t\tthis.progressMonitor.worked(5);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.compilationAborted = true;", "+\t\t}\t\t", "+\t}", "-\t */", "-\tprivate void locateMatches(JavaProject javaProject) throws JavaModelException {", "-\t\tMatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(javaProject.getPackageFragmentRoots());", "-\t", "-\t\tthis.compilationAborted = false;", "-", "-\t\tif (this.pattern.needsResolve) {", "-\t\t\tthis.createAndResolveBindings(openables);", "-\t\t}", "-", "-\t\t// create hierarchy resolver if scope is a hierarchy scope", "-\t\tif (this.scope instanceof HierarchyScope) {", "-\t\t\tIType focusType = ((HierarchyScope)this.scope).focusType;", "-\t\t\tif (focusType != null) {", "-\t\t\t\tif (!focusType.isBinary()) {", "-\t\t\t\t\t// cache all types in the focus' compilation unit (even secondary types)", "-\t\t\t\t\tthis.accept((ICompilationUnit)focusType.getCompilationUnit());", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tchar[] fullyQualifiedName = focusType.getFullyQualifiedName().toCharArray();", "-\t\t\t\tthis.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);", "-\t\t\t\tif (this.hierarchyResolver.setFocusType(CharOperation.splitOn('.', fullyQualifiedName)) == null) {", "-\t\t\t\t\t// focus type is not visible from this project", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tthis.hierarchyResolver = null;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tthis.hierarchyResolver = null;", "-\t\t}", "-", "-\t\t// matching openable resolution", "-\t\tfor (int i = 0, length = openables.length; i < length; i++) { ", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {", "-\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t}", "-\t\t\t ", "-\t\t\ttry {", "-\t\t\t\tthis.currentMatchingOpenable = openables[i];", "-\t\t\t\t", "-\t\t\t\tif (!this.currentMatchingOpenable.hasAlreadyDefinedType()) {", "-\t\t\t\t\tthis.currentMatchingOpenable.locateMatches();", "-\t\t\t\t} // else skip type has it is hidden so not visible", "-\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\tcompilationAborted = true;", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\tcompilationAborted = true;", "-\t\t\t\t} else {", "-\t\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tthis.currentMatchingOpenable.reset();", "-\t\t\t}", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.worked(3);", "-\t\t\t}", "-\t\t}", "-\t\tthis.currentMatchingOpenable = null;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aff5faff8cc18a31932d968339e14226", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "e33f9e50507ed5c3d45f37527737576191428633", "commitAfterChange": "62bebd71f36545c90d6c943df5cd6ccb18d59a48", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate void complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope)", "signatureAfterChange": "  \tprivate void complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope)", "diff": ["-\t\t\tcompletionToken = type.token;", "+\t\t\tthis.completionToken = type.token;", "-\t\t\tfindTypesAndPackages(completionToken, scope);", "-\t\t\tfindKeywordsForMember(completionToken, field.modifiers);", "+\t\t\tfindTypesAndPackages(this.completionToken, scope);", "+\t\t\tfindKeywordsForMember(this.completionToken, field.modifiers);", "-\t\t\t\tfindMethods(completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false, false);", "-\t\t\t\tproposeNewMethod(completionToken, scope.enclosingSourceType());", "+\t\t\t\tfindMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false, false);", "+\t\t\t\tproposeNewMethod(this.completionToken, scope.enclosingSourceType());", "-\t\t\t\tcompletionToken = type.token;", "+\t\t\t\tthis.completionToken = type.token;", "-\t\t\t\tfindTypesAndPackages(completionToken, scope.parent);", "-\t\t\t\tfindKeywordsForMember(completionToken, method.modifiers);", "+\t\t\t\tfindTypesAndPackages(this.completionToken, scope.parent);", "+\t\t\t\tfindKeywordsForMember(this.completionToken, method.modifiers);", "-\t\t\t\t\tfindMethods(completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false);", "-\t\t\t\t\tproposeNewMethod(completionToken, scope.enclosingSourceType());", "+\t\t\t\t\tfindMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false);", "+\t\t\t\t\tproposeNewMethod(this.completionToken, scope.enclosingSourceType());", "-\t\t\t\t\tcompletionToken = singleNameReference.token;", "+\t\t\t\t\tthis.completionToken = singleNameReference.token;", "-\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\tfindTypesAndPackages(completionToken, scope);", "-\t\t\t\t\tfindKeywords(completionToken, singleNameReference.possibleKeywords);", "+\t\t\t\t\tfindTypesAndPackages(this.completionToken, scope);", "+\t\t\t\t\tfindKeywords(this.completionToken, singleNameReference.possibleKeywords);", "-\t\t\t\t\t\tif(CharOperation.prefixEquals(completionToken, Keywords.THIS, false)) {", "+\t\t\t\t\t\tif(CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {", "-\t\t\t\t\t\t} else if(CharOperation.prefixEquals(completionToken, Keywords.SUPER, false)) {", "+\t\t\t\t\t\t} else if(CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {", "-\t\t\t\t\t\tcompletionToken = ((CompletionOnSingleTypeReference) astNode).token;", "+\t\t\t\t\t\tthis.completionToken = ((CompletionOnSingleTypeReference) astNode).token;", "-\t\t\t\t\t\tassistNodeIsClass = astNode instanceof CompletionOnClassReference;", "-\t\t\t\t\t\tassistNodeIsException = astNode instanceof CompletionOnExceptionReference;", "-\t\t\t\t\t\tassistNodeIsInterface = astNode instanceof CompletionOnInterfaceReference;", "+\t\t\t\t\t\tthis.assistNodeIsClass = astNode instanceof CompletionOnClassReference;", "+\t\t\t\t\t\tthis.assistNodeIsException = astNode instanceof CompletionOnExceptionReference;", "+\t\t\t\t\t\tthis.assistNodeIsInterface = astNode instanceof CompletionOnInterfaceReference;", "-\t\t\t\t\t\t\tfindTypesAndPackages(completionToken, scope);", "+\t\t\t\t\t\t\tfindTypesAndPackages(this.completionToken, scope);", "-\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\tinsideQualifiedReference = true;", "+\t\t\t\t\t\t\tthis.insideQualifiedReference = true;", "-\t\t\t\t\t\t\tcompletionToken = ref.completionIdentifier;", "+\t\t\t\t\t\t\tthis.completionToken = ref.completionIdentifier;", "-\t\t\t\t\t\t\t\t\tfindFieldsAndMethods(completionToken, receiverType, scope, ref, scope,false,false);", "+\t\t\t\t\t\t\t\t\tfindFieldsAndMethods(this.completionToken, receiverType, scope, ref, scope,false,false);", "-\t\t\t\t\t\t\t\t\tfindMemberTypes(completionToken, receiverType, scope, scope.enclosingSourceType());", "+\t\t\t\t\t\t\t\t\tfindMemberTypes(this.completionToken, receiverType, scope, scope.enclosingSourceType());", "-\t\t\t\t\t\t\t\t\tfindClassField(completionToken, (TypeBinding) qualifiedBinding, scope);", "+\t\t\t\t\t\t\t\t\tfindClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);", "-\t\t\t\t\t\t\t\t\t\tif(completionToken.length > 0) {", "-\t\t\t\t\t\t\t\t\t\t\tfindKeywords(completionToken, new char[][]{Keywords.THIS});", "+\t\t\t\t\t\t\t\t\t\tif(this.completionToken.length > 0) {", "+\t\t\t\t\t\t\t\t\t\t\tfindKeywords(this.completionToken, new char[][]{Keywords.THIS});", "-\t\t\t\t\t\t\t\t\t\t\trelevance += computeRelevanceForCaseMatching(completionToken, Keywords.THIS);", "-\t\t\t\t\t\t\t\t\t\t\tnoProposal = false;", "-\t\t\t\t\t\t\t\t\t\t\trequestor.acceptKeyword(Keywords.THIS, startPosition - offset, endPosition - offset,relevance);", "+\t\t\t\t\t\t\t\t\t\t\trelevance += computeRelevanceForCaseMatching(this.completionToken, Keywords.THIS);", "+\t\t\t\t\t\t\t\t\t\t\tthis.noProposal = false;", "+\t\t\t\t\t\t\t\t\t\t\tthis.requestor.acceptKeyword(Keywords.THIS, this.startPosition - this.offset, this.endPosition - this.offset,relevance);", "-\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\t\tfindTypesAndSubpackages(completionToken, (PackageBinding) qualifiedBinding);", "+\t\t\t\t\t\t\t\t\t\tfindTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);", "-\t\t\t\t\t\t\t\tinsideQualifiedReference = true;", "+\t\t\t\t\t\t\t\tthis.insideQualifiedReference = true;", "-\t\t\t\t\t\t\t\tassistNodeIsClass = astNode instanceof CompletionOnQualifiedClassReference;", "-\t\t\t\t\t\t\t\tassistNodeIsException = astNode instanceof CompletionOnQualifiedExceptionReference;", "-\t\t\t\t\t\t\t\tassistNodeIsInterface = astNode instanceof CompletionOnQualifiedInterfaceReference;", "+\t\t\t\t\t\t\t\tthis.assistNodeIsClass = astNode instanceof CompletionOnQualifiedClassReference;", "+\t\t\t\t\t\t\t\tthis.assistNodeIsException = astNode instanceof CompletionOnQualifiedExceptionReference;", "+\t\t\t\t\t\t\t\tthis.assistNodeIsInterface = astNode instanceof CompletionOnQualifiedInterfaceReference;", "-\t\t\t\t\t\t\t\tcompletionToken = ref.completionIdentifier;", "+\t\t\t\t\t\t\t\tthis.completionToken = ref.completionIdentifier;", "-\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\t\tfindTypesAndSubpackages(completionToken, (PackageBinding) qualifiedBinding);", "+\t\t\t\t\t\t\t\t\t\tfindTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);", "-\t\t\t\t\t\t\t\t\tinsideQualifiedReference = true;", "+\t\t\t\t\t\t\t\t\tthis.insideQualifiedReference = true;", "-\t\t\t\t\t\t\t\t\tcompletionToken = access.token;", "+\t\t\t\t\t\t\t\t\tthis.completionToken = access.token;", "-\t\t\t\t\t\t\t\t\tfindKeywords(completionToken, new char[][]{Keywords.NEW});", "+\t\t\t\t\t\t\t\t\tfindKeywords(this.completionToken, new char[][]{Keywords.NEW});", "-\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\t\tcompletionToken = messageSend.selector;", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken = messageSend.selector;", "-\t\t\t\t\t\t\t\t\t\t\tfindImplicitMessageSends(completionToken, argTypes, scope, messageSend, scope);", "+\t\t\t\t\t\t\t\t\t\t\tfindImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);", "-\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = access.completionIdentifier;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = access.completionIdentifier;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfindClassField(completionToken, (TypeBinding) qualifiedBinding, scope);", "+\t\t\t\t\t\t\t\t\t\t\t\t\tfindClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = method.selector;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = method.selector;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(completionToken, method.returnType, excludeNames, FIELD, method.modifiers);", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(this.completionToken, method.returnType, excludeNames, FIELD, method.modifiers);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = field.realName;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = field.realName;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = ((CompletionOnLocalName) variable).realName;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = ((CompletionOnLocalName) variable).realName;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(this.completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = arg.realName;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = arg.realName;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindVariableNames(this.completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinsideQualifiedReference = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.insideQualifiedReference = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassistNodeIsClass = ref.isClass();", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassistNodeIsException = ref.isException();", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassistNodeIsInterface = ref.isInterface();", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.assistNodeIsClass = ref.isClass();", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.assistNodeIsException = ref.isException();", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.assistNodeIsInterface = ref.isInterface();", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken = ref.completionIdentifier;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken = ref.completionIdentifier;", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompletionToken,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.completionToken,"]}], "num": 56220}