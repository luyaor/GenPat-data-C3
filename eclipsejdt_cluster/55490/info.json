{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "680603160326af99d3fca1b0000f659b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04b83908871dead86b2fefb2feca9198", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java", "commitBeforeChange": "cdead094a9813fdba5ccda0ce2f9f48a99552dbc", "commitAfterChange": "3be4aa0b7d051355f329ce1003f3f4c0f7acfab2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "diff": ["-\t\tconstant = NotAConstant;", "-\t\tif (this.receiver instanceof CastExpression) this.receiver.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\tthis.constant = NotAConstant;", "-\t\t\tthis.receiverType = receiver.resolveType((ClassScope)scope);", "+\t\t\tthis.receiverType = this.receiver.resolveType((ClassScope) scope);", "-\t\t\tthis.receiverType = receiver.resolveType((BlockScope)scope);", "+\t\t\tthis.receiverType = this.receiver.resolveType((BlockScope) scope);", "-\t\tif (arguments != null) {", "+\t\tif (this.arguments != null) {", "-\t\t\tint length = arguments.length;", "+\t\t\tint length = this.arguments.length;", "-\t\t\t\tExpression argument = arguments[i];", "+\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\tif(receiverType instanceof ReferenceBinding) {", "-\t\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "-\t\t\t\t\tthis.codegenBinding = this.binding = scope.findMethod((ReferenceBinding)receiverType, selector, new TypeBinding[]{}, this);", "-\t\t\t\t}\t\t\t", "-\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "+\t\t\tscope.problemReporter().javadocErrorNoMethodFor(this, this.receiverType, argumentTypes, scope.getModifiers());", "-\t\tthis.codegenBinding = this.binding = scope.getMethod(this.receiverType, selector, argumentTypes, this); ", "-\t\tif (!binding.isValidBinding()) {", "-\t\t\tif (binding.declaringClass == null) {", "+\t\tthis.codegenBinding = this.binding = scope.getMethod(this.receiverType, this.selector, argumentTypes, this); ", "+\t\tif (!this.binding.isValidBinding()) {", "+\t\t\tif (this.binding.declaringClass == null) {", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) this.receiverType;", "+\t\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.receiverType;", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);", "+\t\t\t\t\tscope.problemReporter().javadocErrorNoMethodFor(this, this.receiverType, argumentTypes, scope.getModifiers());", "-\t\t\tscope.problemReporter().invalidMethod(this, binding);", "+\t\t\tscope.problemReporter().javadocInvalidMethod(this, this.binding, scope.getModifiers());", "-\t\t\tif (binding instanceof ProblemMethodBinding){", "-\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\t\tif (this.binding instanceof ProblemMethodBinding){", "+\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\treturn this.resolvedType = binding == null ? null : binding.returnType;", "+\t\t\treturn this.resolvedType = this.binding == null ? null : this.binding.returnType;", "-\t\tif (arguments != null) {", "-\t\t\tfor (int i = 0; i < arguments.length; i++) {", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);", "-\t\t\t}", "-\t\t}", "-\t\tif (isMethodUseDeprecated(binding, scope)) {", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+\t\tif (isMethodUseDeprecated(this.binding, scope)) {", "+\t\t\tscope.problemReporter().javadocDeprecatedMethod(this.binding, this, scope.getModifiers());", "-\t\treturn this.resolvedType = binding.returnType;", "+\t\treturn this.resolvedType = this.binding.returnType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60d0c2961023d5bc3a70f18a16091a3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic void locateMatches( \t\tString[] filePaths,  \t\tIWorkspace workspace, \t\torg.eclipse.jdt.core.ICompilationUnit[] copies) \t\tthrows JavaModelException", "signatureAfterChange": " public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException", "diff": ["-\t */", "-\tpublic void locateMatches(", "-\t\tString[] filePaths, ", "-\t\tIWorkspace workspace,", "-\t\torg.eclipse.jdt.core.ICompilationUnit[] copies)", "-\t\tthrows JavaModelException {", "-\t\t\t", "-\t\tif (SearchEngine.VERBOSE) {", "-\t\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "-\t\t\tfor (int i = 0, length = filePaths.length; i < length; i++) {", "-\t\t\t\tString path = filePaths[i];", "-\t\t\t\tSystem.out.println(\"\\t\" + path); //$NON-NLS-1$", "-\t\t\t}", "-\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\tif (copies != null) {", "-\t\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "-\t\t\t\tfor (int i = 0, length = copies.length; i < length; i++) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit wc = copies[i];", "-\t\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement)wc).toStringWithAncestors()); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t\t}", "+ */", "+public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException {", "+\tif (SearchEngine.VERBOSE) {", "+\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "+\t\tfor (int i = 0, length = filePaths.length; i < length; i++)", "+\t\t\tSystem.out.println(\"\\t\" + filePaths[i]); //$NON-NLS-1$", "+\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\tif (copies != null) {", "+\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "+\t\t\tfor (int i = 0, length = copies.length; i < length; i++)", "+\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement) copies[i]).toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "+\t\t}", "+\t}", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\ttry {", "+\t\t// optimize access to zip files during search operation", "+\t\tmanager.cacheZipFiles();", "+\t\t\t", "+\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "+\t\tif (this.handleFactory == null)", "+\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\ttry {", "-\t\t\t// optimize access to zip files during search operation", "-\t\t\tmanager.cacheZipFiles();", "-\t\t\t\t", "-\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)", "-\t\t\tif (this.handleFactory == null) {", "-\t\t\t\tthis.handleFactory = new HandleFactory(workspace);", "-\t\t\t}", "-\t\t\t", "-\t\t\t// initialize locator with working copies", "-\t\t\tthis.workingCopies = copies;", "-\t\t\t", "-\t\t\t// substitute compilation units with working copies", "-\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "-\t\t\tint wcLength;", "-\t\t\tif (copies != null && (wcLength = copies.length) > 0) {", "+\t\t// substitute compilation units with working copies", "+\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "+\t\tif ((this.workingCopies = copies) != null) {", "+\t\t\tint wcLength = this.workingCopies.length;", "+\t\t\tif (wcLength > 0) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = this.workingCopies[i];", "-\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength + wcLength], 0, filePathsLength);", "-\t\t\t", "-\t\t\tint length = filePaths.length;", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tif (this.pattern.mustResolve) {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 10); // 1 for file path, 4 for parsing and binding creation, 5 for binding resolution //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tprogressMonitor.beginTask(\"\", length * 5); // 1 for file path, 4 for parsing and binding creation //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\t// sort file paths projects", "-\t\t\tUtil.sort(filePaths); ", "-\t\t\t", "-\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "-\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);", "-\t\t\t", "-\t\t\tJavaProject previousJavaProject = null;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tString pathString = filePaths[i];", "-\t\t\t\t", "-\t\t\t\t// skip duplicate paths", "-\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;", "-\t\t\t\t", "-\t\t\t\tOpenable openable;", "-\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit)wcPaths.get(pathString);", "-\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\topenable = (Openable)workingCopy;", "-\t\t\t\t} else {", "-\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "-\t\t\t\t\tif (openable == null)", "-\t\t\t\t\t\tcontinue; // match is outside classpath", "-\t\t\t\t}", "-\t", "-\t\t\t\t// create new parser and lookup environment if this is a new project", "-\t\t\t\tIResource resource = null;", "-\t\t\t\tJavaProject javaProject = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();", "-\t\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\t\tresource = workingCopy.getResource();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tresource = openable.getResource();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (resource == null) { // case of a file in an external jar", "-\t\t\t\t\t\tresource = javaProject.getProject();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "-\t\t\t\t\t\t// locate matches in previous project", "-\t\t\t\t\t\tif (previousJavaProject != null) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t\t\t\t}", "-\t", "-\t\t\t\t\t\tpreviousJavaProject = javaProject;", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// file doesn't exist -> skip it", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t", "-\t\t\t\t// add potential match", "-\t\t\t\tthis.addPotentialMatch(resource, openable);", "-\t", "-\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\tprogressMonitor.worked(1);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// last project", "-\t\t\tif (previousJavaProject != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tthis.locateMatches(previousJavaProject);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (e.getException() instanceof CoreException) {", "-\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// problem with classpath in last project -> skip it", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.matchSet = new PotentialMatchSet();", "-\t\t\t} ", "-\t\t\t", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.done();", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tif (this.nameEnvironment != null) {", "-\t\t\t\tthis.nameEnvironment.cleanup();", "-\t\t\t}", "-\t\t\tmanager.flushZipFiles();", "-\t\t}\t", "-\t}", "+\t\t}", "+\t\tif (this.progressMonitor != null) {", "+\t\t\t// 1 for file path, 4 for parsing and binding creation, 5 for binding resolution? //$NON-NLS-1$", "+\t\t\tthis.progressMonitor.beginTask(\"\", filePaths.length * (this.pattern.mustResolve ? 10 : 5));", "+\t\t}", "+", "+\t\t// initialize pattern for polymorphic search (ie. method reference pattern)", "+\t\tthis.pattern.initializePolymorphicSearch(this, this.progressMonitor);", "+", "+\t\tJavaProject previousJavaProject = null;", "+\t\tPotentialMatchSet matchSet = new PotentialMatchSet();", "+\t\tUtil.sort(filePaths); ", "+\t\tfor (int i = 0, l = filePaths.length; i < l; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\t\tthrow new OperationCanceledException();", "+", "+\t\t\t// skip duplicate paths", "+\t\t\tString pathString = filePaths[i];", "+\t\t\tif (i > 0 && pathString.equals(filePaths[i - 1])) continue;", "+\t\t\t", "+\t\t\tOpenable openable;", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit) wcPaths.get(pathString);", "+\t\t\tif (workingCopy != null) {", "+\t\t\t\topenable = (Openable) workingCopy;", "+\t\t\t} else {", "+\t\t\t\topenable = this.handleFactory.createOpenable(pathString, this.scope);", "+\t\t\t\tif (openable == null) continue; // match is outside classpath", "+", "+\t\t\t// create new parser and lookup environment if this is a new project", "+\t\t\tIResource resource = null;", "+\t\t\ttry {", "+\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();", "+\t\t\t\tresource = workingCopy != null ? workingCopy.getResource() : openable.getResource();", "+\t\t\t\tif (resource == null)", "+\t\t\t\t\tresource = javaProject.getProject(); // case of a file in an external jar", "+\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "+\t\t\t\t\t// locate matches in previous project", "+\t\t\t\t\tif (previousJavaProject != null) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tmatchSet.reset();", "+\t\t\t\t\t}", "+\t\t\t\t\tpreviousJavaProject = javaProject;", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// file doesn't exist -> skip it", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tmatchSet.add(new PotentialMatch(this, resource, openable));", "+", "+\t\t\tif (this.progressMonitor != null)", "+\t\t\t\tthis.progressMonitor.worked(1);", "+\t\t// last project", "+\t\tif (previousJavaProject != null) {", "+\t\t\ttry {", "+\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "+\t\t\t\t// problem with classpath in last project -> skip it", "+\t\t\t}", "+\t\t} ", "+", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.done();", "+\t} finally {", "+\t\tif (this.nameEnvironment != null)", "+\t\t\tthis.nameEnvironment.cleanup();", "+\t\tmanager.flushZipFiles();", "+\t}\t", "+}"]}], "num": 55490}