{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7b3b3a6cea52ab21b3bcdac7a9f615ee", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cadd2d35c4ff67a89efcacb25d3b2b00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "commitAfterChange": "e6bf96fd82847410c46479a652f4e58f9a6dd052", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic void analyseCode( \t\tClassScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " \tpublic void analyseCode( \t\tClassScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-", "-\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "-\t\t\tInitializationFlowContext initializerContext =", "-\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "-", "-\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\tif (fields != null) {", "-\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\tFieldDeclaration field = fields[i];", "-\t\t\t\t\t/*if (field.isField()){", "-\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tif (!fields[i].isStatic()) {", "-\t\t\t\t\t\tfieldInfo =", "-\t\t\t\t\t\t\tfield.analyseCode(initializerScope, initializerContext, fieldInfo);", "-\t\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (memberTypes != null) {", "-\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (methods != null) {", "-\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "-\t\t\t\t\t\tcontinue;", "+\t\t\tinternalAnalyseCode(flowContext, flowInfo);", "-\t\t\t\t\tif (method.isConstructor()) { // constructor", "-\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "-\t\t\t\t\t} else { // regular method", "-\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+//\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "+//\t\t\tInitializationFlowContext initializerContext =", "+//\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "+//", "+//\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\tif (fields != null) {", "+//\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "+//\t\t\t\t\tFieldDeclaration field = fields[i];", "+//\t\t\t\t\t/*if (field.isField()){", "+//\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "+//\t\t\t\t\t} else {*/", "+//\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "+//\t\t\t\t\t/*}*/", "+//\t\t\t\t\tif (!fields[i].isStatic()) {", "+//\t\t\t\t\t\tfieldInfo =", "+//\t\t\t\t\t\t\tfield.analyseCode(initializerScope, initializerContext, fieldInfo);", "+//\t\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "+//\t\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+//\t\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "+//\t\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "+//\t\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+//\t\t\t\t\t\t}", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (memberTypes != null) {", "+//\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "+//\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (methods != null) {", "+//\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "+//\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "+//\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "+//\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "+//\t\t\t\t\t\tcontinue;", "+//", "+//\t\t\t\t\tif (method.isConstructor()) { // constructor", "+//\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "+//\t\t\t\t\t} else { // regular method", "+//\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea2e0f80688dbfd1ace37158e303f912", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "commitAfterChange": "e6bf96fd82847410c46479a652f4e58f9a6dd052", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-", "-\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "-\t\t\tInitializationFlowContext initializerContext =", "-\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "-\t\t\t", "-\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\t", "-\t\t\tif (fields != null) {", "-\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\tFieldDeclaration field = fields[i];", "-\t\t\t\t\t/*if (field.isField() && !this.binding.isAnonymousType()){", "-\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tfieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);", "-\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (memberTypes != null) {", "-\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (methods != null) {", "-\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tif (method.isConstructor()) { // constructor", "-\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "-\t\t\t\t\t} else { // regular method", "-\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tinternalAnalyseCode(flowContext, flowInfo); ", "+", "+//\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "+//\t\t\tInitializationFlowContext initializerContext =", "+//\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "+//\t\t\t", "+//\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\t", "+//\t\t\tif (fields != null) {", "+//\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "+//\t\t\t\t\tFieldDeclaration field = fields[i];", "+//\t\t\t\t\t/*if (field.isField() && !this.binding.isAnonymousType()){", "+//\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous", "+//\t\t\t\t\t} else {*/", "+//\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "+//\t\t\t\t\t/*}*/", "+//\t\t\t\t\tfieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);", "+//\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "+//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "+//\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "+//\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (memberTypes != null) {", "+//\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "+//\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (methods != null) {", "+//\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "+//\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "+//\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "+//\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "+//\t\t\t\t\t\tcontinue;", "+//\t\t\t\t\tif (method.isConstructor()) { // constructor", "+//\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "+//\t\t\t\t\t} else { // regular method", "+//\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}"]}], "num": 30493}