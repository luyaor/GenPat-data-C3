{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ebbe0f202b6ab95cc34134055d678ed0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37716ba265aeffff17b0833d5b1e6b9f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "c232f63e38d9fdcfc4841ab866a4e36091735ec4", "commitAfterChange": "8dc325b5ad83fe486573fca06bedec7b37f7c533", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tthis.constant = Constant.NotAConstant;", "-\t\tTypeBinding conditionType = this.condition.resolveTypeExpecting(scope, TypeBinding.BOOLEAN);", "-\t\tthis.condition.computeConversion(scope, TypeBinding.BOOLEAN, conditionType);", "-", "-\t\tif (this.valueIfTrue instanceof CastExpression) this.valueIfTrue.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\t/* 15.25.3 : Where a poly reference conditional expression appears in a context of a particular kind with target ", "-\t\t\t\t   type T (5), its second and third operand expressions similarly appear in a context of the same kind with target", "-\t\t\t\t   type T. We eagerly propagate the context and target type here, but that should be harmless. Nonpoly expressions", "-\t\t\t\t   won't respond to it at all. If someone down below does get influenced, then the conditional is poly.", "-\t\t\t\t*/", "-", "-\t\tTypeBinding originalValueIfTrueType = this.valueIfTrue.resolveType(scope);", "+\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\tthis.constant = Constant.NotAConstant;", "-\t\tif (this.valueIfFalse instanceof CastExpression) this.valueIfFalse.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding originalValueIfFalseType = this.valueIfFalse.resolveType(scope);", "+\t\t\tTypeBinding conditionType = this.condition.resolveTypeExpecting(scope, TypeBinding.BOOLEAN);", "+\t\t\tthis.condition.computeConversion(scope, TypeBinding.BOOLEAN, conditionType);", "-\t\tif (conditionType == null || originalValueIfTrueType == null || originalValueIfFalseType == null)", "-\t\t\treturn null;", "+\t\t\tif (this.valueIfTrue instanceof CastExpression) this.valueIfTrue.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\tthis.originalValueIfTrueType = this.valueIfTrue.resolveType(scope);", "-\t\tif (use18specifics && this.expectedType != null) { // so the story is still untold for invocations.", "+\t\t\tif (this.valueIfFalse instanceof CastExpression) this.valueIfFalse.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\tthis.originalValueIfFalseType = this.valueIfFalse.resolveType(scope);", "+", "+\t\t\tif (conditionType == null || this.originalValueIfTrueType == null || this.originalValueIfFalseType == null)", "+\t\t\t\treturn null;", "-\t\t\t    TypeBinding trueType = originalValueIfTrueType;", "-\t\t\t    TypeBinding falseType = originalValueIfFalseType;", "-\t\t\t    if (this.valueIfTrue instanceof MessageSend) {", "-\t\t\t    \tMessageSend message = (MessageSend) this.valueIfTrue;", "-\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "-\t\t\t    \t\tif (pgmb.inferredReturnType) {", "-\t\t\t    \t\t\ttrueType = pgmb.original().returnType;", "-\t\t\t    \t\t}", "-\t\t\t    \t}", "-\t\t\t    }", "-\t\t\t    if (this.valueIfFalse instanceof MessageSend) {", "-\t\t\t    \tMessageSend message = (MessageSend) this.valueIfFalse;", "-\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "-\t\t\t    \t\tif (pgmb.inferredReturnType) {", "-\t\t\t    \t\t\tfalseType = pgmb.original().returnType;", "-\t\t\t    \t\t}", "-\t\t\t    \t}", "-\t\t\t    }", "-\t\t\t    ", "-\t\t\t    if (!trueType.isPrimitiveOrBoxedPrimitiveType() || !falseType.isPrimitiveOrBoxedPrimitiveType()) // reference conditional ==> poly expression.", "-\t\t\t    \tthis.isPolyExpression = true;", "+\t\t\tif (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE || this.originalValueIfFalseType.kind() == Binding.POLY_TYPE) {", "+\t\t\t\tthis.isPolyExpression = true;", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE)", "+\t\t\t\tthis.originalValueIfTrueType = this.valueIfTrue.resolveType(scope);", "+\t\t\tif (this.originalValueIfFalseType.kind() == Binding.POLY_TYPE)", "+\t\t\t\tthis.originalValueIfFalseType = this.valueIfFalse.resolveType(scope);", "-\t\tTypeBinding valueIfTrueType = originalValueIfTrueType;", "-\t\tTypeBinding valueIfFalseType = originalValueIfFalseType;", "+\t\tTypeBinding valueIfTrueType = this.originalValueIfTrueType;", "+\t\tTypeBinding valueIfFalseType = this.originalValueIfFalseType;", "-\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, originalValueIfTrueType);", "-\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, originalValueIfFalseType);", "+\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, this.originalValueIfTrueType);", "+\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.SHORT, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.SHORT, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.SHORT, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.SHORT, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfTrueType, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfTrueType, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfFalseType, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfFalseType, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.INT, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.INT, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.INT, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.INT, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.LONG, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.LONG, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.LONG, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.LONG, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.FLOAT, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.FLOAT, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.FLOAT, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.FLOAT, this.originalValueIfFalseType);", "-\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.DOUBLE, originalValueIfTrueType);", "-\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.DOUBLE, originalValueIfFalseType);", "+\t\t\tthis.valueIfTrue.computeConversion(scope, TypeBinding.DOUBLE, this.originalValueIfTrueType);", "+\t\t\tthis.valueIfFalse.computeConversion(scope, TypeBinding.DOUBLE, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, commonType, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, commonType, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, commonType, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, commonType, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfTrueType, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfTrueType, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfTrueType, this.originalValueIfFalseType);", "-\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfFalseType, originalValueIfTrueType);", "-\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, originalValueIfFalseType);", "+\t\t\t\tthis.valueIfTrue.computeConversion(scope, valueIfFalseType, this.originalValueIfTrueType);", "+\t\t\t\tthis.valueIfFalse.computeConversion(scope, valueIfFalseType, this.originalValueIfFalseType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a491e4db6fbb61b591d44dbde07771ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "e5e6f9097f2c3bf7294bd658643d6be9f7aaa5ef", "commitAfterChange": "d00bc48524f3df289951f11fca95cb39820be47f", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-}\r", "-public TypeBinding resolveType(BlockScope scope) {\r", "-\t// specs p.368\r", "-\tconstant = NotAConstant;\r", "-\tTypeBinding condTb = condition.resolveTypeExpecting(scope, BooleanBinding);\r", "-\tTypeBinding trueTb = valueIfTrue.resolveType(scope);\r", "-\tTypeBinding falseTb = valueIfFalse.resolveType(scope);\r", "-\tif (condTb == null || trueTb == null || falseTb == null)\r", "-\t\treturn null;\r", "-\t// Propagate the constant value from the valueIfTrue and valueIFFalse expression if it is possible\r", "-\tif (condition.constant != NotAConstant && valueIfTrue.constant != NotAConstant && valueIfFalse.constant != NotAConstant) {\r", "-\t\t// all terms are constant expression so we can propagate the constant\r", "-\t\t// from valueIFTrue or valueIfFalse to teh receiver constant\r", "-\t\tconstant = (condition.constant.booleanValue()) ? valueIfTrue.constant : valueIfFalse.constant;\r", "-\tif (trueTb == falseTb) { // harmed the implicit conversion \r", "-\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\tvalueIfFalse.implicitConversion = valueIfTrue.implicitConversion;\r", "-\t\tif (trueTb == LongBinding || trueTb == DoubleBinding) {\r", "+\r", "+\tpublic TypeBinding resolveType(BlockScope scope) {\r", "+\t\t// specs p.368\r", "+\t\tconstant = NotAConstant;\r", "+\t\tTypeBinding conditionType = condition.resolveTypeExpecting(scope, BooleanBinding);\r", "+\t\tTypeBinding valueIfTrueType = valueIfTrue.resolveType(scope);\r", "+\t\tTypeBinding valueIfFalseType = valueIfFalse.resolveType(scope);\r", "+\t\tif (conditionType == null || valueIfTrueType == null || valueIfFalseType == null)\r", "+\t\t\treturn null;\r", "+\r", "+\t\t// Propagate the constant value from the valueIfTrue and valueIFFalse expression if it is possible\r", "+\t\tif (condition.constant != NotAConstant\r", "+\t\t\t&& valueIfTrue.constant != NotAConstant\r", "+\t\t\t&& valueIfFalse.constant != NotAConstant) {\r", "+\t\t\t// all terms are constant expression so we can propagate the constant\r", "+\t\t\t// from valueIFTrue or valueIfFalse to teh receiver constant\r", "+\t\t\tconstant =\r", "+\t\t\t\t(condition.constant.booleanValue())\r", "+\t\t\t\t\t? valueIfTrue.constant\r", "+\t\t\t\t\t: valueIfFalse.constant;\r", "+\t\t}\r", "+\t\tif (valueIfTrueType == valueIfFalseType) { // harmed the implicit conversion \r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitConversion = valueIfTrue.implicitConversion;\r", "+\t\t\tif (valueIfTrueType == LongBinding || valueIfTrueType == DoubleBinding) {\r", "+\t\t\t\treturnTypeSlotSize = 2;\r", "+\t\t\t}\r", "+\t\t\treturn valueIfTrueType;\r", "+\t\t}\r", "+\t\t// Determine the return type depending on argument types\r", "+\t\t// Numeric types\r", "+\t\tif (valueIfTrueType.isNumericType() && valueIfFalseType.isNumericType()) {\r", "+\t\t\t// (Short x Byte) or (Byte x Short)\"\r", "+\t\t\tif ((valueIfTrueType == ByteBinding && valueIfFalseType == ShortBinding)\r", "+\t\t\t\t|| (valueIfTrueType == ShortBinding && valueIfFalseType == ByteBinding)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(ShortBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(ShortBinding, valueIfFalseType);\r", "+\t\t\t\treturn ShortBinding;\r", "+\t\t\t}\r", "+\t\t\t// <Byte|Short|Char> x constant(Int)  ---> <Byte|Short|Char>   and reciprocally\r", "+\t\t\tif ((valueIfTrueType == ByteBinding || valueIfTrueType == ShortBinding || valueIfTrueType == CharBinding)\r", "+\t\t\t\t&& (valueIfFalseType == IntBinding\r", "+\t\t\t\t\t&& valueIfFalse.isConstantValueOfTypeAssignableToType(valueIfFalseType, valueIfTrueType))) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(valueIfTrueType, valueIfFalseType);\r", "+\t\t\t\treturn valueIfTrueType;\r", "+\t\t\t}\r", "+\t\t\tif ((valueIfFalseType == ByteBinding\r", "+\t\t\t\t|| valueIfFalseType == ShortBinding\r", "+\t\t\t\t|| valueIfFalseType == CharBinding)\r", "+\t\t\t\t&& (valueIfTrueType == IntBinding\r", "+\t\t\t\t\t&& valueIfTrue.isConstantValueOfTypeAssignableToType(valueIfTrueType, valueIfFalseType))) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(valueIfFalseType, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(valueIfFalseType, valueIfFalseType);\r", "+\t\t\t\treturn valueIfFalseType;\r", "+\t\t\t}\r", "+\t\t\t// Manual binary numeric promotion\r", "+\t\t\t// int\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_int)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_int)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(IntBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(IntBinding, valueIfFalseType);\r", "+\t\t\t\treturn IntBinding;\r", "+\t\t\t}\r", "+\t\t\t// long\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_long)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_long)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(LongBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(LongBinding, valueIfFalseType);\r", "+\t\t\t\treturnTypeSlotSize = 2;\r", "+\t\t\t\treturn LongBinding;\r", "+\t\t\t}\r", "+\t\t\t// float\r", "+\t\t\tif (BaseTypeBinding.isNarrowing(valueIfTrueType.id, T_float)\r", "+\t\t\t\t&& BaseTypeBinding.isNarrowing(valueIfFalseType.id, T_float)) {\r", "+\t\t\t\tvalueIfTrue.implicitWidening(FloatBinding, valueIfTrueType);\r", "+\t\t\t\tvalueIfFalse.implicitWidening(FloatBinding, valueIfFalseType);\r", "+\t\t\t\treturn FloatBinding;\r", "+\t\t\t}\r", "+\t\t\t// double\r", "+\t\t\tvalueIfTrue.implicitWidening(DoubleBinding, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(DoubleBinding, valueIfFalseType);\r", "+\t\t\treturn DoubleBinding;\r", "-\t\treturn trueTb;\r", "-\t}\r", "-\r", "-\t// Determine the return type depending on argument types\r", "-\t// Numeric types\r", "-\tif (trueTb.isNumericType() && falseTb.isNumericType()) {\r", "-\t\t// (Short x Byte) or (Byte x Short)\"\r", "-\t\tif ((trueTb == ByteBinding && falseTb == ShortBinding) || (trueTb == ShortBinding && falseTb == ByteBinding)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(ShortBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(ShortBinding, falseTb);\r", "-\t\t\treturn ShortBinding;\r", "+\t\t// Type references (null null is already tested)\r", "+\t\tif ((valueIfTrueType.isBaseType() && valueIfTrueType != NullBinding)\r", "+\t\t\t|| (valueIfFalseType.isBaseType() && valueIfFalseType != NullBinding)) {\r", "+\t\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(\r", "+\t\t\t\tthis,\r", "+\t\t\t\tvalueIfTrueType,\r", "+\t\t\t\tvalueIfFalseType);\r", "+\t\t\treturn null;\r", "-\r", "-\t\t// <Byte|Short|Char> x constant(Int)  ---> <Byte|Short|Char>   and reciprocally\r", "-\t\tif ((trueTb == ByteBinding || trueTb == ShortBinding || trueTb == CharBinding) &&\r", "-\t\t\t(falseTb == IntBinding && valueIfFalse.isConstantValueOfTypeAssignableToType(falseTb, trueTb))) {\r", "-\t\t\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\t\t\tvalueIfFalse.implicitWidening(trueTb, falseTb);\r", "-\t\t\t\treturn trueTb;\r", "+\t\tif (scope.areTypesCompatible(valueIfFalseType, valueIfTrueType)) {\r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfTrueType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(valueIfTrueType, valueIfFalseType);\r", "+\t\t\treturn valueIfTrueType;\r", "-\t\tif ((falseTb == ByteBinding || falseTb == ShortBinding || falseTb == CharBinding) &&\r", "-\t\t\t(trueTb == IntBinding && valueIfTrue.isConstantValueOfTypeAssignableToType(trueTb, falseTb))) {\r", "-\t\t\t\tvalueIfTrue.implicitWidening(falseTb, trueTb);\r", "-\t\t\t\tvalueIfFalse.implicitWidening(falseTb, falseTb);\r", "-\t\t\t\treturn falseTb;\r", "+\t\tif (scope.areTypesCompatible(valueIfTrueType, valueIfFalseType)) {\r", "+\t\t\tvalueIfTrue.implicitWidening(valueIfFalseType, valueIfTrueType);\r", "+\t\t\tvalueIfFalse.implicitWidening(valueIfFalseType, valueIfFalseType);\r", "+\t\t\treturn valueIfFalseType;\r", "-\r", "-\t\t// Manual binary numeric promotion\r", "-\t\t// int\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_int) && BaseTypeBinding.isNarrowing(falseTb.id, T_int)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(IntBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(IntBinding, falseTb);\r", "-\t\t\treturn IntBinding;\r", "-\t\t}\r", "-\t\t// long\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_long) && BaseTypeBinding.isNarrowing(falseTb.id, T_long)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(LongBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(LongBinding, falseTb);\r", "-\t\t\treturnTypeSlotSize = 2;\r", "-\t\t\treturn LongBinding;\r", "-\t\t}\r", "-\t\t// float\r", "-\t\tif (BaseTypeBinding.isNarrowing(trueTb.id, T_float) && BaseTypeBinding.isNarrowing(falseTb.id, T_float)) {\r", "-\t\t\tvalueIfTrue.implicitWidening(FloatBinding, trueTb);\r", "-\t\t\tvalueIfFalse.implicitWidening(FloatBinding, falseTb);\r", "-\t\t\treturn FloatBinding;\r", "-\t\t}\r", "-\t\t// double\r", "-\t\tvalueIfTrue.implicitWidening(DoubleBinding, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(DoubleBinding, falseTb);\r", "-\t\treturnTypeSlotSize = 2;\r", "-\t\treturn DoubleBinding;\r", "-\t}\r", "-\r", "-\t// Type references (null null is already tested)\r", "-\tif ((trueTb.isBaseType() && trueTb != NullBinding) || (falseTb.isBaseType() && falseTb != NullBinding)) {\r", "-\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(this, trueTb, falseTb);\r", "+\t\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(\r", "+\t\t\tthis,\r", "+\t\t\tvalueIfTrueType,\r", "+\t\t\tvalueIfFalseType);\r", "-\tif (scope.areTypesCompatible(falseTb, trueTb)) {\r", "-\t\tvalueIfTrue.implicitWidening(trueTb, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(trueTb, falseTb);\r", "-\t\treturn trueTb;\r", "-\tif (scope.areTypesCompatible(trueTb, falseTb)) {\r", "-\t\tvalueIfTrue.implicitWidening(falseTb, trueTb);\r", "-\t\tvalueIfFalse.implicitWidening(falseTb, falseTb);\r", "-\t\treturn falseTb;\r", "-\t}\r", "-\tscope.problemReporter().conditionalArgumentsIncompatibleTypes(this, trueTb, falseTb);\r", "-\treturn null;\r", "-}\r"]}], "num": 23654}