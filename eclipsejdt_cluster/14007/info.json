{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "10659cea6855a6d7aa4163a97d5e8b36", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00d5c4b47615c9fd47561a64de3cd0df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void resolve(MethodScope methScope)", "signatureAfterChange": " \tpublic void resolve(MethodScope methScope)", "diff": ["-\t\t\tif (methDecl != null && (methDecl.isConstructor() || overriding) && !superRef) {", "-\t\t\t\tif (this.seeReferences[i] instanceof JavadocMessageSend) {", "-\t\t\t\t\tJavadocMessageSend messageSend = (JavadocMessageSend) this.seeReferences[i];", "-\t\t\t\t\t// if binding is valid then look if we have a reference to an overriden method/constructor", "-\t\t\t\t\tif (messageSend.binding != null && messageSend.binding.isValidBinding() && messageSend.actualReceiverType instanceof ReferenceBinding) {", "-\t\t\t\t\t\tReferenceBinding methodReceiverType = (ReferenceBinding) messageSend.actualReceiverType;", "-\t\t\t\t\t\tif ((methodReceiverType.isSuperclassOf(methDecl.binding.declaringClass) || (methodReceiverType.isInterface() && methDecl.binding.declaringClass.implementsInterface(methodReceiverType, true))) &&", "-\t\t\t\t\t\t\t\tCharOperation.equals(messageSend.selector, methDecl.selector) &&", "-\t\t\t\t\t\t\t\t(methDecl.binding.returnType.isCompatibleWith(messageSend.binding.returnType))) {", "-\t\t\t\t\t\t\tif (messageSend.arguments == null && methDecl.arguments == null) {", "-\t\t\t\t\t\t\t\tsuperRef = true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\telse if (messageSend.arguments != null && methDecl.arguments != null) {", "-\t\t\t\t\t\t\t\tsuperRef = methDecl.binding.areParameterErasuresEqual(messageSend.binding);", "+\t\t\tif (methDecl != null && !superRef) {", "+\t\t\t\tif (!methDecl.isConstructor()) {", "+\t\t\t\t\tif (overriding && this.seeReferences[i] instanceof JavadocMessageSend) {", "+\t\t\t\t\t\tJavadocMessageSend messageSend = (JavadocMessageSend) this.seeReferences[i];", "+\t\t\t\t\t\t// if binding is valid then look if we have a reference to an overriden method/constructor", "+\t\t\t\t\t\tif (messageSend.binding != null && messageSend.binding.isValidBinding() && messageSend.actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tReferenceBinding methodReceiverType = (ReferenceBinding) messageSend.actualReceiverType;", "+\t\t\t\t\t\t\tTypeBinding superType = methDecl.binding.declaringClass.findSuperTypeOriginatingFrom(methodReceiverType);", "+\t\t\t\t\t\t\tif (superType != null && superType.original() != methDecl.binding.declaringClass && CharOperation.equals(messageSend.selector, methDecl.selector)) {", "+\t\t\t\t\t\t\t\tif (methScope.environment().methodVerifier().doesMethodOverride(methDecl.binding, messageSend.binding.original())) {", "+\t\t\t\t\t\t\t\t\tsuperRef = true;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\telse if (this.seeReferences[i] instanceof JavadocAllocationExpression) {", "+\t\t\t\t} else if (this.seeReferences[i] instanceof JavadocAllocationExpression) {", "-\t\t\t\t\t\tif (methDecl.binding.declaringClass.isCompatibleWith(allocationExpr.resolvedType)) {", "-\t\t\t\t\t\t\tif (allocationExpr.arguments == null && methDecl.arguments == null) {", "-\t\t\t\t\t\t\t\tsuperRef = true;", "+\t\t\t\t\t\tReferenceBinding allocType = (ReferenceBinding) allocationExpr.resolvedType.original();", "+\t\t\t\t\t\tReferenceBinding superType = (ReferenceBinding) methDecl.binding.declaringClass.findSuperTypeOriginatingFrom(allocType);", "+\t\t\t\t\t\tif (superType != null && superType.original() != methDecl.binding.declaringClass) {", "+\t\t\t\t\t\t\tMethodBinding superConstructor = methScope.getConstructor(superType, methDecl.binding.parameters, allocationExpr);", "+\t\t\t\t\t\t\tif (superConstructor.isValidBinding() && superConstructor.original() == allocationExpr.binding.original()) {", "+\t\t\t\t\t\t\t\tif (superConstructor.areParametersEqual(methDecl.binding)) {", "+\t\t\t\t\t\t\t\t\tsuperRef = true;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\telse if (allocationExpr.arguments != null && methDecl.arguments != null && allocationExpr.arguments.length == methDecl.arguments.length) {", "-\t\t\t\t\t\t\t\tsuperRef = methDecl.binding.areParametersCompatibleWith(allocationExpr.binding.parameters);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14f1eaa886b89b9078f58ac30cdd4500", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3091564ff71d95ca83672941f8a4ec3464344683", "commitAfterChange": "ac6c2726bc9770d7575dff83ad9611f141165280", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static method reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.selector, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tchar[] declaringType = CharOperation.concat(pattern.declaringQualification, pattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1da0338b703d734a6e93e579b7bfb80f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CopyResourceElementsOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate void updatePackageStatement(IDOMCompilationUnit domCU, String[] pkgName)", "signatureAfterChange": " \tprivate void updatePackageStatement(CompilationUnit astCU, String[] pkgName, IDocument document) throws JavaModelException", "diff": ["-    // TODO - JDOM - remove once model ported off of JDOM", "-\tprivate void updatePackageStatement(IDOMCompilationUnit domCU, String[] pkgName) {", "+\tprivate void updatePackageStatement(CompilationUnit astCU, String[] pkgName, IDocument document) throws JavaModelException {", "-\t\tboolean seenPackageNode = false;", "-\t\tEnumeration nodes = domCU.getChildren();", "-\t\twhile (nodes.hasMoreElements()) {", "-\t\t\tIDOMNode node = (IDOMNode) nodes.nextElement();", "-\t\t\tif (node.getNodeType() == IDOMNode.PACKAGE) {", "-\t\t\t\tif (! defaultPackage) {", "-\t\t\t\t\tnode.setName(Util.concatWith(pkgName, '.'));", "-\t\t\t\t} else {", "-\t\t\t\t\tnode.remove();", "-\t\t\t\t}", "-\t\t\t\tseenPackageNode = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\t\tAST ast = astCU.getAST();", "+\t\tASTRewrite rewriter = ASTRewrite.create(ast);", "+\t\tif (defaultPackage) {", "+\t\t\t// remove existing package statement", "+\t\t\tif (astCU.getPackage() != null)", "+\t\t\t\trewriter.set(astCU, CompilationUnit.PACKAGE_PROPERTY, null, null);", "+\t\t} else {", "+\t\t\t// add new package statement or replace existing", "+\t\t\torg.eclipse.jdt.core.dom.PackageDeclaration pkg = ast.newPackageDeclaration();", "+\t\t\tName name = ast.newName(pkgName);", "+\t\t\tpkg.setName(name);", "+\t\t\trewriter.set(astCU, CompilationUnit.PACKAGE_PROPERTY, pkg, null);", "-\t\tif (!seenPackageNode && !defaultPackage) {", "-\t\t\t//the cu was in a default package...no package declaration", "-\t\t\t//create the new package declaration as the first child of the cu", "-\t\t\tIDOMPackage pkg = fFactory.createPackage(\"package \" + Util.concatWith(pkgName, '.') + \";\" + org.eclipse.jdt.internal.compiler.util.Util.LINE_SEPARATOR); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\tIDOMNode firstChild = domCU.getFirstChild();", "-\t\t\tif (firstChild != null) {", "-\t\t\t\tfirstChild.insertSibling(pkg);", "-\t\t\t} // else the cu was empty: leave it empty", "-\t\t}", "+ \t\tTextEdit edits = rewriter.rewriteAST(document, null);", "+ \t\ttry {", "+\t \t\tedits.apply(document);", "+ \t\t} catch (BadLocationException e) {", "+ \t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.INVALID_CONTENTS);", "+ \t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e5de2872b92cac5ed9ec9c6a23362ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldLocator.java", "commitBeforeChange": "203954a19427f44b197aa09593f6f49177e09606", "commitAfterChange": "3ed9acfe644f3aa92ee72abfaf147fb3ef3a87d3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public int match(FieldDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static field reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.name, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tFieldPattern fieldPattern = (FieldPattern) this.pattern;", "+\t\t\t\tchar[] declaringType = CharOperation.concat(fieldPattern.declaringQualification, fieldPattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f61c64e0c2cc837bfde1295962f86e3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "diff": ["-public void generateReadSequence(BlockScope currentScope, CodeStream codeStream) {", "+public FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream) {", "+    ", "-", "+\tFieldBinding lastFieldBinding = null;", "+\tTypeBinding lastGenericCast = null;", "+\t", "-\t\t\tthis.lastFieldBinding = (FieldBinding) this.codegenBinding;", "+\t\t\tlastFieldBinding = (FieldBinding) this.codegenBinding;", "+\t\t\tlastGenericCast = this.genericCast;", "-\t\t\tif (this.lastFieldBinding.constant != NotAConstant) {", "+\t\t\tif (lastFieldBinding.constant != NotAConstant) {", "-\t\t\t\tif (this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\t\tif (!this.lastFieldBinding.isStatic()) {", "+\t\t\t\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\t\tif (!lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\tif (emulationPath == null) {", "-\t\t\t\t\t\t\t\t// internal error, per construction we should have found it", "-\t\t\t\t\t\t\t\tcurrentScope.problemReporter().needImplementation();", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "-\t\t\t\t\tif (!this.lastFieldBinding.isStatic()) {", "+\t\t\t\t\tif (!lastFieldBinding.isStatic()) {", "-\t\t\tthis.lastFieldBinding = null;", "-\t\t\t\tif ((this.bits & DepthMASK) != 0) {", "+\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\tif (path == null) {", "-\t\t\t\t\t\t// emulation was not possible (should not happen per construction)", "-\t\t\t\t\t\tcurrentScope.problemReporter().needImplementation();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.generateOuterAccess(path, this, localBinding, currentScope);", "-\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.generateOuterAccess(path, this, localBinding, currentScope);", "-\t\t\tif (this.lastFieldBinding != null) {", "+\t\t\tTypeBinding nextGenericCast = this.otherGenericCasts == null ? null : this.otherGenericCasts[i];", "+\t\t\tif (lastFieldBinding != null) {", "-\t\t\t\t\tif (this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\t\t\tif (this.lastFieldBinding.constant != NotAConstant) {", "-\t\t\t\t\t\t\tif (this.lastFieldBinding != this.codegenBinding && !this.lastFieldBinding.isStatic()) {", "+\t\t\t\t\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\t\t\tif (lastFieldBinding.constant != NotAConstant) {", "+\t\t\t\t\t\t\tif (lastFieldBinding != this.codegenBinding && !lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\tcodeStream.generateConstant(this.lastFieldBinding.constant, 0);", "-\t\t\t\t\t\t} else if (this.lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\tcodeStream.getstatic(this.lastFieldBinding);", "+\t\t\t\t\t\t\tcodeStream.generateConstant(lastFieldBinding.constant, 0);", "+\t\t\t\t\t\t} else if (lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t\t\t\t\tcodeStream.getfield(this.lastFieldBinding);", "+\t\t\t\t\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t\t\t\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(this.lastFieldBinding);", "+\t\t\t\t\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(lastFieldBinding);", "+\t\t\t\t\tif (lastGenericCast != null) codeStream.checkcast(lastGenericCast);", "-\t\t\t\t\tif (this.codegenBinding != this.lastFieldBinding && !this.lastFieldBinding.isStatic()){", "+\t\t\t\t\tif (this.codegenBinding != lastFieldBinding && !lastFieldBinding.isStatic()){", "-\t\t\tthis.lastFieldBinding = nextField;", "-\t\t\tif (this.lastFieldBinding != null && !this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\tif (this.lastFieldBinding.isStatic()) {", "+\t\t\tlastFieldBinding = nextField;", "+\t\t\tlastGenericCast = nextGenericCast;", "+\t\t\tif (lastFieldBinding != null && !lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\tif (lastFieldBinding.isStatic()) {", "+\treturn lastFieldBinding;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c87194100544f10079072edb42da5da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 13, "signatureBeforeChange": " public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope)", "signatureAfterChange": "  public boolean isCompatibleWith(TypeBinding targetType, final Scope scope)", "diff": ["+", "+public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {", "+\tif (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)", "+\t\treturn false;", "+\tTypeBinding allocationType = this.resolvedType;", "+\tif (isPolyExpression()) {", "+\t\tTypeBinding originalExpectedType = this.typeExpected;", "+\t\ttry {", "+\t\t\tthis.typeExpected = targetType;", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null)", "+\t\t\t\treturn false;", "+\t\t\tallocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t} finally {", "+\t\t\tthis.typeExpected = originalExpectedType;", "+\t\t}", "+\t}", "+\treturn allocationType != null && allocationType.isCompatibleWith(targetType, scope);", "+}", "-}", "-public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {", "-\tthis.typeExpected = targetType;", "-\tboolean needsUpdate = this.binding == null || \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not yet resolved", "-\t\t\t(this.resolvedType != null && targetType != null && !this.resolvedType.isCompatibleWith(targetType));\t// previous attempt was wrong", "-\tif (needsUpdate && this.suspendedResolutionState != null && !this.suspendedResolutionState.hasReportedError) {", "-\t\t// Attempt to resolve half resolved diamond", "-\t\tresolvePart2(this.suspendedResolutionState);", "-\t}", "-\t// confer MessageSend.checkAgainstFinalTargetType(,,):", "-\tif (this.binding instanceof ParameterizedGenericMethodBinding) {", "-\t\tInferenceContext18 ctx = getInferenceContext((ParameterizedMethodBinding) this.binding);", "-\t\tif (ctx != null && ctx.stepCompleted < InferenceContext18.TYPE_INFERRED) {", "-\t\t\tthis.typeExpected = targetType;", "-\t\t\tMethodBinding updatedBinding = ctx.inferInvocationType(this, (ParameterizedGenericMethodBinding) this.binding);", "-\t\t\tif (updateBindings(updatedBinding, targetType)) {", "-\t\t\t\tASTNode.resolvePolyExpressionArguments(this, updatedBinding, scope);", "-\t\t\t}", "-\t\t}", "-\t}", "-\tif (this.suspendedResolutionState != null) {", "-\t\treturn resolvePart3(this.suspendedResolutionState);", "-\t}", "-\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc32630eb8ea987c7a9a99a5f12ceaa3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["-\tprivate void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "-\t\t", "-\t\t// copy array because elements  from the original are removed below", "-\t\tPotentialMatch[] copy = new PotentialMatch[length];", "-\t\tSystem.arraycopy(potentialMatches, start, copy, 0, length);", "-\t\tthis.initialize(javaProject, copy);", "-\t\t", "-\t\tthis.compilationAborted = false;", "-\t\t", "-\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\t\ttry {", "-\t\t\tthis.createAndResolveBindings(potentialMatches, start, length);", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}", "-\t\t", "-\t\t// create hierarchy resolver if needed", "-\t\ttry {", "-\t\t\tif (!this.compilationAborted && !this.createHierarchyResolver(copy)) {", "-\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\t\tcomputeSuperTypeNames();", "-\t\t\t\tif (this.allSuperTypeNames == null) return;", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t", "-\t\t// free memory", "-\t\tcopy = null;", "-\t\tpotentialMatches = null;", "-\t\t", "-\t\t// potential match resolution", "-\t\ttry {", "-\t\t\tCompilationUnitDeclaration unit = null;", "-\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "-\t\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled()) {", "-\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t}", "-\t\t\t\tunit = this.unitsToProcess[i];", "-\t\t\t\ttry {", "-\t\t\t\t\tprocess(unit, i);", "-\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\t\t\tthis.compilationAborted = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t} finally {", "-\t\t\t\t\t// cleanup compilation unit result", "-\t\t\t\t\tunit.cleanUp();", "-\t\t\t\t\tif (this.options.verbose)", "-\t\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+}", "+protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException {", "+\tinitialize(javaProject, length);", "+", "+\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\tboolean bindingsWereCreated = true;", "+\ttry {", "+\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\tbuildBindings(potentialMatches[i]);", "+\t\tlookupEnvironment.completeTypeBindings();", "+", "+\t\t// create hierarchy resolver if needed", "+\t\tIType focusType = getFocusType();", "+\t\tif (focusType == null) {", "+\t\t\tthis.hierarchyResolver = null;", "+\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "+\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t}", "+\t} catch (AbortCompilation e) {", "+\t\tbindingsWereCreated = false;", "+\t}", "+", "+\t// potential match resolution", "+\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\tthrow new OperationCanceledException();", "+\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "+\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\ttry {", "+\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t} catch (AbortCompilation e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (CoreException e) {", "+\t\t\t// core exception thrown by client's code: let it through", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tif (this.options.verbose)", "+\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\t\tString.valueOf(totalUnits),", "-\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())}));", "-\t\t\t\t}", "-\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "-\t\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "-\t\t\t\tif (this.progressMonitor != null) {", "-\t\t\t\t\tthis.progressMonitor.worked(5);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.compilationAborted = true;", "-\t\t}\t\t", "-\t}", "+\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "+\t\t\t// cleanup compilation unit result", "+\t\t\tpotentialMatch.parsedUnit.cleanUp();", "+\t\t\tpotentialMatch.parsedUnit = null;", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.worked(5);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0a14791d114087d7c0b560bfd3b64ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java", "commitBeforeChange": "f8f573fb4945f47fa2e1f634d0b55fa9e0151f17", "commitAfterChange": "b1e2ed2bb1403d1f729ccda27eb7b9ebe7009bed", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\tImportRewriteConfiguration config= buildImportRewriteConfiguration();", "+", "-\t\t\t\tnew ImportRewriteAnalyzer(", "-\t\t\t\t\t\tthis.compilationUnit,", "-\t\t\t\t\t\tusedAstRoot,", "-\t\t\t\t\t\tthis.importOrder,", "-\t\t\t\t\t\tthis.importOnDemandThreshold,", "-\t\t\t\t\t\tthis.staticImportOnDemandThreshold,", "-\t\t\t\t\t\tthis.restoreExistingImports,", "-\t\t\t\t\t\tthis.useContextToFilterImplicitImports);", "-\t\t\tcomputer.setFilterImplicitImports(this.filterImplicitImports);", "+\t\t\t\tnew ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);", "-\t\t\tif (this.addedImports != null) {", "-\t\t\t\tfor (int i= 0; i < this.addedImports.size(); i++) {", "-\t\t\t\t\tString curr= (String) this.addedImports.get(i);", "-\t\t\t\t\tcomputer.addImport(curr.substring(1), STATIC_PREFIX == curr.charAt(0), usedAstRoot, this.restoreExistingImports);", "-\t\t\t\t}", "+\t\t\tfor (String addedImport : this.addedImports) {", "+\t\t\t\tboolean isStatic = STATIC_PREFIX == addedImport.charAt(0);", "+\t\t\t\tString qualifiedName = addedImport.substring(1);", "+\t\t\t\tcomputer.addImport(isStatic, qualifiedName);", "-\t\t\tif (this.removedImports != null) {", "-\t\t\t\tfor (int i= 0; i < this.removedImports.size(); i++) {", "-\t\t\t\t\tString curr= (String) this.removedImports.get(i);", "-\t\t\t\t\tcomputer.removeImport(curr.substring(1), STATIC_PREFIX == curr.charAt(0));", "-\t\t\t\t}", "+\t\t\tfor (String removedImport : this.removedImports) {", "+\t\t\t\tboolean isStatic = STATIC_PREFIX == removedImport.charAt(0);", "+\t\t\t\tString qualifiedName = removedImport.substring(1);", "+\t\t\t\tcomputer.removeImport(isStatic, qualifiedName);", "-\t\t\tTextEdit result= computer.getResultingEdits(new SubProgressMonitor(monitor, 1));", "-\t\t\tthis.createdImports= computer.getCreatedImports();", "-\t\t\tthis.createdStaticImports= computer.getCreatedStaticImports();", "-\t\t\treturn result;", "+\t\t\tfor (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {", "+\t\t\t\tcomputer.requireExplicitImport(false, typeExplicitSimpleName);", "+\t\t\t}", "+", "+\t\t\tfor (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {", "+\t\t\t\tcomputer.requireExplicitImport(true, staticExplicitSimpleName);", "+\t\t\t}", "+", "+\t\t\tImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(new SubProgressMonitor(monitor, 1));", "+", "+\t\t\tthis.createdImports= result.getCreatedImports();", "+\t\t\tthis.createdStaticImports= result.getCreatedStaticImports();", "+", "+\t\t\treturn result.getTextEdit();", "+\t}"]}], "num": 14007}