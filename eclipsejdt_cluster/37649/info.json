{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f7746eef9eab2d9d4bb96ce1d7437abe", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a0c3e0605dc81ff5dc20c2d1e68a809", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java", "commitBeforeChange": "7c6fe4f21cb5ba3a5ee61e01b5b0b2742e043690", "commitAfterChange": "51c6ca3e4dfed3078a1640da7a2ab7f26c899e0a", "methodNumberBeforeChange": 95, "methodNumberAfterChange": 95, "signatureBeforeChange": "  \tpublic boolean visit(ExtraDimension node)", "signatureAfterChange": "  \tpublic boolean visit(ExtraDimension node)", "diff": ["-\t\tint pos= node.getStartPosition();", "-\t\tif (isChanged(node, ExtraDimension.ANNOTATIONS_PROPERTY)) {", "-\t\t\trewriteNodeList(node, ExtraDimension.ANNOTATIONS_PROPERTY, pos, Util.EMPTY_STRING, \" \"); //$NON-NLS-1$", "-\t\t}", "+\t\trewriteNodeList(node, ExtraDimension.ANNOTATIONS_PROPERTY, node.getStartPosition(), Util.EMPTY_STRING, \" \"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "657277ba1d255d4c795476e4b2a50ebb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "d2e8e421e16a596877a52fb425bb0c8e82e56cdd", "commitAfterChange": "6397a01054d96cb05aae47d916802945c8f4ba3d", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tprivate static void checkAlternateBinding(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] originalArgumentTypes, TypeBinding[] alternateArgumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": "  \tprivate static void checkAlternateBinding(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] originalArgumentTypes, TypeBinding[] alternateArgumentTypes, final InvocationSite invocationSite)", "diff": ["-\t\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "-\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null; }", "-\t\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "-\t\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "-\t\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) { /* ignore */}", "-\t\t\t\tpublic void setDepth(int depth) { /* ignore */}", "-\t\t\t\tpublic void setFieldIndex(int depth){ /* ignore */}", "-\t\t\t\tpublic int sourceStart() { return 0; }", "-\t\t\t\tpublic int sourceEnd() { return 0; }", "-\t\t\t};\t", "-\t\t\tMethodBinding bindingIfNoCast;", "-\t\t\tif (binding.isConstructor()) {", "-\t\t\t\tbindingIfNoCast = scope.getConstructor((ReferenceBinding)receiverType, alternateArgumentTypes, fakeInvocationSite);", "-\t\t\t} else {", "-\t\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "-\t\t\t\t\t? scope.getImplicitMethod(binding.selector, alternateArgumentTypes, fakeInvocationSite)", "-\t\t\t\t\t: scope.getMethod(receiverType, binding.selector, alternateArgumentTypes, fakeInvocationSite); \t", "-\t\t\t}", "-\t\t\tif (bindingIfNoCast == binding) {", "-\t\t\t\tint argumentLength = originalArgumentTypes.length;", "-\t\t\t\tif (binding.isVarargs()) {", "-\t\t\t\t\tint paramLength = binding.parameters.length;", "-\t\t\t\t   if (paramLength == argumentLength) {", "-\t\t\t\t\t\tint varargsIndex = paramLength - 1;", "-\t\t\t\t\t\tArrayBinding varargsType = (ArrayBinding) binding.parameters[varargsIndex];", "-\t\t\t\t\t\tTypeBinding lastArgType = alternateArgumentTypes[varargsIndex];", "-\t\t\t\t\t\t// originalType may be compatible already, but cast mandated to clarify between varargs/non-varargs call", "-\t\t\t\t\t\tint dimensions = lastArgType.dimensions();", "-\t\t\t\t\t\tif (varargsType.dimensions < dimensions) {", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t} else if (varargsType.dimensions == dimensions) {", "-\t\t\t\t\t\t\tif (lastArgType.isCompatibleWith(varargsType.elementsType())", "-\t\t\t\t\t\t\t\t\t&& lastArgType.isCompatibleWith(varargsType)) {", "-\t\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t   }", "-\t\t\t\t}", "-\t\t\t\tfor (int i = 0; i < argumentLength; i++) {", "-\t\t\t\t\tif (originalArgumentTypes[i] != alternateArgumentTypes[i]) {", "-\t\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)arguments[i]);", "+\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "+\t\t\tpublic TypeBinding[] genericTypeArguments() { return null; }", "+\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "+\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "+\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) { /* ignore */}", "+\t\t\tpublic void setDepth(int depth) { /* ignore */}", "+\t\t\tpublic void setFieldIndex(int depth){ /* ignore */}", "+\t\t\tpublic int sourceStart() { return 0; }", "+\t\t\tpublic int sourceEnd() { return 0; }", "+\t\t};\t", "+\t\tMethodBinding bindingIfNoCast;", "+\t\tif (binding.isConstructor()) {", "+\t\t\tbindingIfNoCast = scope.getConstructor((ReferenceBinding)receiverType, alternateArgumentTypes, fakeInvocationSite);", "+\t\t} else {", "+\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "+\t\t\t\t? scope.getImplicitMethod(binding.selector, alternateArgumentTypes, fakeInvocationSite)", "+\t\t\t\t: scope.getMethod(receiverType, binding.selector, alternateArgumentTypes, fakeInvocationSite); \t", "+\t\t}", "+\t\tif (bindingIfNoCast == binding) {", "+\t\t\tint argumentLength = originalArgumentTypes.length;", "+\t\t\tif (binding.isVarargs()) {", "+\t\t\t\tint paramLength = binding.parameters.length;", "+\t\t\t\tif (paramLength == argumentLength) {", "+\t\t\t\t\tint varargsIndex = paramLength - 1;", "+\t\t\t\t\tArrayBinding varargsType = (ArrayBinding) binding.parameters[varargsIndex];", "+\t\t\t\t\tTypeBinding lastArgType = alternateArgumentTypes[varargsIndex];", "+\t\t\t\t\t// originalType may be compatible already, but cast mandated", "+\t\t\t\t\t// to clarify between varargs/non-varargs call", "+\t\t\t\t\tif (varargsType.dimensions != lastArgType.dimensions()) {", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (lastArgType.isCompatibleWith(varargsType.elementsType())", "+\t\t\t\t\t\t\t&& lastArgType.isCompatibleWith(varargsType)) {", "+\t\t\t\t\t\treturn;", "-\t\t\t}\t", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < argumentLength; i++) {", "+\t\t\t\tif (originalArgumentTypes[i] != alternateArgumentTypes[i]) {", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast(", "+\t\t\t\t\t\t\t(CastExpression) arguments[i]);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t"]}], "num": 37649}