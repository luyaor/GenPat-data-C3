{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e38ce607f415b735611571915e29737e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03d1230f115482e2d08c1dfed876951b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \t \tprivate boolean complete(ASTNode astNode, ASTNode astNodeParent, ASTNode enclosingNode, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation)", "signatureAfterChange": " \t \tprivate boolean complete(ASTNode astNode, ASTNode astNodeParent, ASTNode enclosingNode, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation)", "diff": ["-\t\t\t\tif (receiverType != null) {", "+\t\t\t\tif (receiverType != null && (receiverType.tagBits & TagBits.HasMissingType) == 0) {", "-\t\t\t\t\t\tif (qualifiedBinding instanceof LocalVariableBinding) {", "-\t\t\t\t\t\t\t// complete local variable members with missing variables type", "-\t\t\t\t\t\t\t// class X {", "-\t\t\t\t\t\t\t//   void foo() {", "-\t\t\t\t\t\t\t//     Missing f;", "-\t\t\t\t\t\t\t//     f.|", "-\t\t\t\t\t\t\t//   }", "-\t\t\t\t\t\t\t// }", "-\t\t\t\t\t\t\tLocalVariableBinding localVariableBinding = (LocalVariableBinding) qualifiedBinding;", "+\t\t\t\t\t\tif(ref.tokens.length == 1) {", "+\t\t\t\t\t\t\tif (qualifiedBinding instanceof LocalVariableBinding) {", "+\t\t\t\t\t\t\t\t// complete local variable members with missing variables type", "+\t\t\t\t\t\t\t\t// class X {", "+\t\t\t\t\t\t\t\t//   void foo() {", "+\t\t\t\t\t\t\t\t//     Missing f;", "+\t\t\t\t\t\t\t\t//     f.|", "+\t\t\t\t\t\t\t\t//   }", "+\t\t\t\t\t\t\t\t// }", "+\t\t\t\t\t\t\t\tLocalVariableBinding localVariableBinding = (LocalVariableBinding) qualifiedBinding;", "+\t\t\t\t\t\t\t\tfindFieldsAndMethodsFromMissingType(", "+\t\t\t\t\t\t\t\t\t\tthis.completionToken,", "+\t\t\t\t\t\t\t\t\t\tlocalVariableBinding.declaration.type,", "+\t\t\t\t\t\t\t\t\t\tlocalVariableBinding.declaringScope,", "+\t\t\t\t\t\t\t\t\t\tref,", "+\t\t\t\t\t\t\t\t\t\tscope);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// complete field members with missing fields type", "+\t\t\t\t\t\t\t\t// class X {", "+\t\t\t\t\t\t\t\t//   Missing f;", "+\t\t\t\t\t\t\t\t//   void foo() {", "+\t\t\t\t\t\t\t\t//     f.|", "+\t\t\t\t\t\t\t\t//   }", "+\t\t\t\t\t\t\t\t// }", "+\t\t\t\t\t\t\t\tfindFieldsAndMethodsFromMissingFieldType(ref.tokens[0], scope, ref, insideTypeAnnotation);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tfindFieldsAndMethodsFromMissingType(", "-\t\t\t\t\t\t\t\t\tthis.completionToken,", "-\t\t\t\t\t\t\t\t\tlocalVariableBinding.declaration.type,", "-\t\t\t\t\t\t\t\t\tlocalVariableBinding.declaringScope,", "-\t\t\t\t\t\t\t\t\tref,", "-\t\t\t\t\t\t\t\t\tscope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55af724944cc00fe6f97683e1b49c39e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "40f76b3d0fb01a4a7fa1aad4b09c356c31458c94", "commitAfterChange": "323d52f789e646d704223fd3ac5d22c4e4efec25", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " void analyseOneArgument18(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, \t\tTypeBinding expectedType, Expression argument)", "signatureAfterChange": " void analyseOneArgument18(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, \t\tTypeBinding expectedType, Expression argument)", "diff": ["-\t\t\tbreak;", "+\t\t\treturn;", "-\t\t\tbreak;", "+\t\t\treturn;", "+\t}", "+\tif ((expectedType.tagBits & TagBits.AnnotationNonNull) != 0 && nullStatus != FlowInfo.NON_NULL) {", "+\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "56c1b4d3b52041562cb4ee39b40663dd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "+\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this, (this.bits & ASTNode.Unchecked) != 0);", "-\t\tif (returnType != null) returnType = returnType.capture(scope, this.sourceEnd);", "+\t\t", "+\t\tif (returnType != null) {", "+\t\t\tif ((this.bits & ASTNode.Unchecked) != 0) {", "+\t\t\t\treturnType = scope.environment().convertToRawType(returnType.erasure(), true);", "+\t\t\t}", "+\t\t\treturnType = returnType.capture(scope, this.sourceEnd);\t\t\t", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b1e250569caf54ca15a906a9583cc17", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tthis.binding =", "-\t\tthis.receiver.isImplicitThis()", "+\tthis.binding = this.receiver.isImplicitThis()", "-\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "+\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this, (this.bits & ASTNode.Unchecked) != 0);", "-\t\tTypeBinding returnType = this.binding.returnType;", "-\t\tif (returnType != null) returnType = returnType.capture(scope, this.sourceEnd);", "+\t\tTypeBinding returnType;", "+\t\tif ((this.bits & ASTNode.Unchecked) != 0) {", "+\t\t\treturnType = this.binding.original().returnType;", "+\t\t\tif (returnType != null) {", "+\t\t\t\treturnType = scope.environment().convertToRawType(returnType.erasure(), true);", "+\t\t\t}", "+\t\t} else {", "+\t\t\treturnType = this.binding.returnType;", "+\t\t\tif (returnType != null) {", "+\t\t\t\treturnType = returnType.capture(scope, this.sourceEnd);", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b143ab56af012a9ed5fc8fafb8c834a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\tcheckInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "+\t\t\t\tcheckInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this, (this.bits & ASTNode.Unchecked) != 0);", "-\t\t\tcheckInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this);", "+\t\t\tcheckInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this, (this.bits & ASTNode.Unchecked) != 0);", "-\t\tthis.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding);", "+\t\tthis.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding, \t(this.bits & ASTNode.Unchecked) != 0);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbff1a7949dcbc3adb3b94682d2870ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "  protected void checkAndSetModifiers(int flag)", "signatureAfterChange": "  protected void checkAndSetModifiers(int flag)", "diff": ["-\tif ((this.modifiers & flag) != 0){ // duplicate modifier", "+\tif ((this.modifiers & flag) != 0 // duplicate modifier", "+\t\t\t|| ((this.modifiers & ExtraCompilerModifiers.AccNotNull) != 0  // conflicting flags", "+\t\t\t\t&& (flag & ExtraCompilerModifiers.AccNullable) != 0)", "+\t\t\t|| ((flag & ExtraCompilerModifiers.AccNotNull) != 0  // conflicting flags", "+\t\t\t\t&& (this.modifiers & ExtraCompilerModifiers.AccNullable) != 0)) { ", "+\t\t// TODO (maxime) check error message"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f25564cfd264e0662180fdf19d1fa1ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "c5e448ecc90e8d75bf431155e497df695586ca94", "commitAfterChange": "d137239e9d64b43b4573cdfef965a2c47040a54e", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext, \t\t\t\t\t\t\t\t\t\t\t\t   VariableBinding var, int nullStatus, Expression expression)", "signatureAfterChange": " protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext, \t\t\t\t\t\t\t\t\t\t\t\t   VariableBinding var, int nullStatus, Expression expression)", "diff": ["-\tif (var != null", "-\t\t\t&& (var.tagBits & TagBits.AnnotationNonNull) != 0", "-\t\t\t&& nullStatus != FlowInfo.NON_NULL) {", "-\t\tflowContext.recordNullityMismatch(currentScope, expression, nullStatus, var.type);", "-\t\tnullStatus=FlowInfo.NON_NULL;", "+\tif (var != null) {", "+\t\tif ((var.tagBits & TagBits.AnnotationNonNull) != 0", "+\t\t\t\t&& nullStatus != FlowInfo.NON_NULL) {", "+\t\t\tflowContext.recordNullityMismatch(currentScope, expression, nullStatus, var.type);", "+\t\t\treturn FlowInfo.NON_NULL;", "+\t\t} else if ((var.tagBits & TagBits.AnnotationNullable) != 0", "+\t\t\t\t&& nullStatus == FlowInfo.UNKNOWN) {\t// provided a legacy type?", "+\t\t\treturn FlowInfo.POTENTIALLY_NULL;\t\t\t// -> use more specific info from the annotation", "+\t\t}"]}], "num": 1298}