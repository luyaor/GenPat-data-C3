{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "19b2775125dade9acb105f5d07940c10", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bdc5c7d27f31afda983db76cd67098a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "e29082e6108e43f171cfe9fae0a56914a1f2ec3e", "commitAfterChange": "c9393df013a58676e5f14d40d6c8db0b129e07c0", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "-\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "-\t\t       that constitute the inference per se. Also short circuit this step, if the substitution has no type variables in the first place ", "-\t\t       (as it is effectively a nop.)", "-\t\t     */ ", "-\t\t    TypeBinding substituteForChecks;", "-\t\t    if (substitute instanceof TypeVariableBinding || ((substitute.tagBits & TagBits.HasTypeVariable) == 0)) {", "-\t\t    \tsubstituteForChecks = substitute;", "-\t\t    } else {", "-\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t    }", "-\t\t    ", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "942936b670c8088b01a29fb15cb40125", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "0b118cfcb5b3fc480d2dbaa55fe1b09dc90e4b1c", "commitAfterChange": "e42bb70e533d0ad5cda9877f87d88624ffbb7f33", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "+\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "+\t\t       that constitute the inference per se.", "+\t\t     */ ", "+\t\t    TypeBinding substituteForChecks;", "+\t\t    if (substitute instanceof TypeVariableBinding) {", "+\t\t    \tsubstituteForChecks = substitute;", "+\t\t    } else {", "+\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    }", "+\t\t    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f046629351f5fe837c936d2b4ecbd20c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "30bcd436389796ede9b25cfba962b4a18b7675bd", "commitAfterChange": "d93134db10799af61489a9927044406c2353d246", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "+\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "+\t\t       that constitute the inference per se. Also short circuit this step, if the substitution has no type variables in the first place ", "+\t\t       (as it is effectively a nop.)", "+\t\t     */ ", "+\t\t    TypeBinding substituteForChecks;", "+\t\t    if (substitute instanceof TypeVariableBinding || ((substitute.tagBits & TagBits.HasTypeVariable) == 0)) {", "+\t\t    \tsubstituteForChecks = substitute;", "+\t\t    } else {", "+\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    }", "+\t\t    "]}], "num": 10971}