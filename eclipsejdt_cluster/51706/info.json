{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ca1c561703215bda655b00f28d02a413", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e497f7ff87b27c80d9ec64fbb006866f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java", "commitBeforeChange": "490f0dedc6b033aac107ccccbdc9e8361a921466", "commitAfterChange": "83feb6a3bbe889feb388b89a4854a090c75eaf0e", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public void checkComment()", "signatureAfterChange": " public void checkComment()", "diff": ["+\t\t\t\tif (fieldRef.receiver instanceof TypeReference) {", "+\t\t\t\t\tTypeReference typeRef = (TypeReference) fieldRef.receiver;", "+\t\t\t\t\tpatternLocator.match(typeRef, nodeSet);", "+\t\t\t\t}", "+\t\t\t\tif (messageSend.receiver instanceof TypeReference) {", "+\t\t\t\t\tTypeReference typeRef = (TypeReference) messageSend.receiver;", "+\t\t\t\t\tpatternLocator.match(typeRef, nodeSet);", "+\t\t\t\t}", "+\t\t\t} else if (reference instanceof JavadocAllocationExpression) {", "+\t\t\t\tJavadocAllocationExpression constructor = (JavadocAllocationExpression) reference;", "+\t\t\t\tpatternLocator.match(constructor, nodeSet);", "+\t\t\t\tif (constructor.type != null) {", "+\t\t\t\t\tpatternLocator.match(constructor.type, nodeSet);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcd56772e3fc27d05f3a2b8f0c220ad6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/OrLocator.java", "commitBeforeChange": "daa141019959a9f08f456a67f61c89b2a391fc85", "commitAfterChange": "3d64bc62d20a2710c039270dfe1984ed9440baac", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " protected void matchLevelAndReportImportRef(ImportReference importRef, Binding binding, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchLevelAndReportImportRef(ImportReference importRef, Binding binding, MatchLocator locator) throws CoreException", "diff": ["+\t", "+\t// for static import, binding can be a field binding or a member type binding", "+\t// verify that in this case binding is static and use declaring class for fields", "+\tBinding refBinding = binding;", "+\tif (importRef.isStatic()) {", "+\t\tif (binding instanceof FieldBinding) {", "+\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "+\t\t\tif (!fieldBinding.isStatic()) return;", "+\t\t\trefBinding = fieldBinding.declaringClass;", "+\t\t} else if (binding instanceof MethodBinding) {", "+\t\t\tMethodBinding methodBinding = (MethodBinding) binding;", "+\t\t\tif (!methodBinding.isStatic()) return;", "+\t\t\trefBinding = methodBinding.declaringClass;", "+\t\t} else if (binding instanceof MemberTypeBinding) {", "+\t\t\tMemberTypeBinding memberBinding = (MemberTypeBinding) binding;", "+\t\t\tif (!memberBinding.isStatic()) return;", "+\t\t}", "+\t}", "+\t", "+\t// Look for closest pattern", "-\t\tint newLevel = patternLocator.referenceType() == 0 ? IMPOSSIBLE_MATCH : patternLocator.resolveLevel(binding);", "+\t\tint newLevel = patternLocator.referenceType() == 0 ? IMPOSSIBLE_MATCH : patternLocator.resolveLevel(refBinding);", "-\tif (closestPattern != null)", "+\tif (closestPattern != null) {", "+\t}"]}], "num": 51706}