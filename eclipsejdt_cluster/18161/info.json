{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "48ea36c753e8ee894ae8be79a728ffdb", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c6990a237481d1f0c3fa2c6df60f97d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "5d2cd7f1076b45eee90e6733e80765abd1df3d6a", "commitAfterChange": "14e86a8141996732826e41cf3c8dd392bb1fd5ba", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprivate void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "signatureAfterChange": " \tprivate void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "diff": ["+\t\tboolean processChildren = false;", "+", "-\t\t\t\t", "-\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();", "-\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {", "-\t\t\t\t\tthis.checkProjectsBeingAddedOrRemoved(children[i]);", "-\t\t\t\t}", "+\t\t\t\tprocessChildren = true;", "-\t\t\t\tint deltaKind = delta.getKind();", "-\t\t\t\tif (deltaKind == IResourceDelta.ADDED) {", "-\t\t\t\t\t// remember project and its dependents", "-\t\t\t\t\tIProject project = (IProject)resource;", "-\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "-\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "-\t\t\t\t\t", "-\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "-\t\t\t\t\tif (JavaProject.hasJavaNature(project)) {", "-\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "-\t\t\t\t\t}", "-", "-\t\t\t\t} else if (deltaKind == IResourceDelta.CHANGED) {", "-\t\t\t\t\tIProject project = (IProject)resource;", "-\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.OPEN) != 0) {", "-\t\t\t\t\t\t// project opened or closed: remember  project and its dependents", "+\t\t\t\tswitch (delta.getKind()) {", "+\t\t\t\t\tcase IResourceDelta.ADDED :", "+\t\t\t\t\t\t// remember project and its dependents", "+\t\t\t\t\t\tIProject project = (IProject)resource;", "+\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "+\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) {", "+\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.state.rootsAreStale = true; ", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "-\t\t\t\t\t\tif (project.isOpen()) {", "-\t\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) {", "-\t\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tjavaProject = (JavaProject)this.manager.getJavaModel().findJavaProject(project);", "-\t\t\t\t\t\t\tif (javaProject != null) {", "-\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\tjavaProject.close();", "-\t\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t\t// java project doesn't exist: ignore", "+\t\t\t\t\tcase IResourceDelta.CHANGED : ", "+\t\t\t\t\t\t\tproject = (IProject)resource;", "+\t\t\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.OPEN) != 0) {", "+\t\t\t\t\t\t\t\t// project opened or closed: remember  project and its dependents", "+\t\t\t\t\t\t\t\tjavaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "+\t\t\t\t\t\t\t\tif (project.isOpen()) {", "+\t\t\t\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) {", "+\t\t\t\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\t\tjavaProject.close();", "+\t\t\t\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t\t\t\t// java project doesn't exist: ignore", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.removeFromParentInfo(javaProject);", "+\t\t\t\t\t\t\t\t\tthis.manager.removePerProjectInfo(javaProject);", "-\t\t\t\t\t\t\t\tthis.removeFromParentInfo(javaProject);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {", "-\t\t\t\t\t\tboolean wasJavaProject = this.manager.getJavaModel().findJavaProject(project) != null;", "-\t\t\t\t\t\tboolean isJavaProject = JavaProject.hasJavaNature(project);", "-\t\t\t\t\t\tif (wasJavaProject != isJavaProject) {", "-\t\t\t\t\t\t\t// java nature added or removed: remember  project and its dependents", "-\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "-\t\t\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "-", "-\t\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "-\t\t\t\t\t\t\tif (isJavaProject) {", "-\t\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t\t} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {", "+\t\t\t\t\t\t\t\tboolean wasJavaProject = this.manager.getJavaModel().findJavaProject(project) != null;", "+\t\t\t\t\t\t\t\tboolean isJavaProject = JavaProject.hasJavaNature(project);", "+\t\t\t\t\t\t\t\tif (wasJavaProject != isJavaProject) { ", "+\t\t\t\t\t\t\t\t\t// java nature added or removed: remember  project and its dependents", "+\t\t\t\t\t\t\t\t\tjavaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "+\t\t", "+\t\t\t\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "+\t\t\t\t\t\t\t\t\tif (isJavaProject) {", "+\t\t\t\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tthis.state.rootsAreStale = true;", "+\t\t\t\t\t\t\t\t\t\t// remove classpath cache so that initializeRoots() will not consider the project has a classpath", "+\t\t\t\t\t\t\t\t\t\tthis.manager.removePerProjectInfo((JavaProject)JavaCore.create(project));", "+\t\t\t\t\t\t\t\t\t\t// close project", "+\t\t\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\t\t\tjavaProject.close();", "+\t\t\t\t\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t\t\t\t\t// java project doesn't exist: ignore", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tthis.removeFromParentInfo(javaProject);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// in case the project was removed then added then changed (see bug 19799)", "+\t\t\t\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) { // need nature check - 18698", "+\t\t\t\t\t\t\t\t\t\tthis.addToParentInfo((JavaProject)JavaCore.create(project));", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// flush classpath markers", "-\t\t\t\t\t\t\t\tjavaProject.", "-\t\t\t\t\t\t\t\t\tflushClasspathProblemMarkers(", "-\t\t\t\t\t\t\t\t\t\ttrue, // flush cycle markers", "-\t\t\t\t\t\t\t\t\t\ttrue  //flush classpath format markers", "-\t\t\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t// remove problems and tasks created  by the builder", "-\t\t\t\t\t\t\t\tJavaBuilder.removeProblemsAndTasksFor(project);", "+\t\t\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "+\t\t\t\t\t\t\t\t// in case the project was removed then added then changed", "+\t\t\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) { // need nature check - 18698", "+\t\t\t\t\t\t\t\t\tthis.addToParentInfo((JavaProject)JavaCore.create(project));", "+\t\t\t\t\t\t\t\t\tprocessChildren = true;", "+\t\t\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\t\t}\t\t", "+\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t// close project", "-\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\tjavaProject.close();", "-\t\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t\t// java project doesn't exist: ignore", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tthis.removeFromParentInfo(javaProject);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// in case the project was removed then added then changed (see bug 19799)", "-\t\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) { // need nature check - 18698", "-\t\t\t\t\t\t\t\tthis.addToParentInfo((JavaProject)JavaCore.create(project));", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// workaround for bug 15168 circular errors not reported ", "-\t\t\t\t\t\t// in case the project was removed then added then changed", "-\t\t\t\t\t\tif (JavaProject.hasJavaNature(project)) { // need nature check - 18698", "-\t\t\t\t\t\t\tthis.addToParentInfo((JavaProject)JavaCore.create(project));", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\tcase IResourceDelta.REMOVED : ", "+\t\t\t\t\t\t\t// remove classpath cache so that initializeRoots() will not consider the project has a classpath", "+\t\t\t\t\t\t\tthis.manager.removePerProjectInfo((JavaProject)JavaCore.create(resource));", "+\t\t\t\t\t\t\tthis.state.rootsAreStale = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\tcase IResource.FILE :", "+\t\t\t\tIFile file = (IFile) resource;", "+\t\t\t\t/* classpath file change */", "+\t\t\t\tif (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {", "+\t\t\t\t\treconcileClasspathFileUpdate(delta, (JavaProject)JavaCore.create(file.getProject()));", "+\t\t\t\t\tthis.state.rootsAreStale = true;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t}", "+\t\tif (processChildren) {", "+\t\t\tIResourceDelta[] children = delta.getAffectedChildren();", "+\t\t\tfor (int i = 0; i < children.length; i++) {", "+\t\t\t\tcheckProjectsBeingAddedOrRemoved(children[i]);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13155f2cd0aceea80c4db6da26f5b87c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "849bead878c9a40a476fb6736e2c949015040926", "commitAfterChange": "ffce987f3a5cbc5edb4057595c44a9095dbf9c81", "methodNumberBeforeChange": 56, "methodNumberAfterChange": 56, "signatureBeforeChange": " \tpublic boolean visit( \t\tArrayTypeReference arrayTypeReference, \t\tBlockScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\t\tAnnotationTypeMemberDeclaration annotationTypeMemberDeclaration, \t\t\tClassScope scope)", "diff": ["+\t}", "+\tpublic boolean visit(", "+\t\t\tAnnotationTypeMemberDeclaration annotationTypeMemberDeclaration,", "+\t\t\tClassScope scope) {        ", "+        /*", "+         * Print comments to get proper line number", "+         */", "+        this.scribe.printComment();        ", "+        this.scribe.printModifiers(annotationTypeMemberDeclaration.annotations, this);", "+\t\tthis.scribe.space();", "+\t\t/*", "+\t\t * Print the method return type", "+\t\t */\t", "+\t\tfinal TypeReference returnType = annotationTypeMemberDeclaration.returnType;", "+\t\tfinal MethodScope annotationTypeMemberDeclarationScope = annotationTypeMemberDeclaration.scope;", "+\t\t", "+\t\tif (returnType != null) {", "+\t\t\treturnType.traverse(this, annotationTypeMemberDeclarationScope);", "+\t\t}", "+\t\t/*", "+\t\t * Print the method name", "+\t\t */", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, true); ", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, this.preferences.insert_space_before_opening_paren_in_annotation_type_member_declaration); ", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, this.preferences.insert_space_between_empty_parens_in_annotation_type_member_declaration); ", "+", "+\t\t/*", "+\t\t * Check for extra dimensions", "+\t\t */", "+\t\tint extraDimensions = annotationTypeMemberDeclaration.extendedDimensions;", "+\t\tif (extraDimensions != 0) {", "+\t\t\t for (int i = 0; i < extraDimensions; i++) {", "+\t\t\t \tthis.scribe.printNextToken(TerminalTokens.TokenNameLBRACKET);", "+\t\t\t \tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACKET);", "+\t\t\t }", "+\t\t}", "+", "+\t\tExpression defaultValue = annotationTypeMemberDeclaration.memberValue;", "+\t\tif (defaultValue != null) {", "+\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNamedefault, true);", "+\t\t\tthis.scribe.space();", "+\t\t\tdefaultValue.traverse(this, (BlockScope) null);", "+\t\t}", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);", "+\t\tthis.scribe.printTrailingComment();", "+\t\treturn false;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9320720047e8bdb436653490c22f71ba", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "c13b5c8fdc5b98528c9ff5d2f4f3b65852c12b48", "commitAfterChange": "08ce0253d3f5d5ff59d7d3b857a3b4f1f87c7e61", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 11, "signatureBeforeChange": " \t \tprivate void computeRootPath(File directory, String fullName, String[] rootPathHolder, int[] index)", "signatureAfterChange": " \t \tprivate void computeRootPath(File directory, HashSet firstLevelPackageNames, boolean hasDefaultPackage)", "diff": ["-\tprivate void computeRootPath(File directory, String fullName, String[] rootPathHolder, int[] index) {", "-\t\tFile[] files = directory.listFiles();", "-\t\tfor (int i = 0; i < files.length; i++) {", "-\t\t\tFile file = files[i];", "-\t\t\tif (file.isDirectory()) {", "-\t\t\t\tcomputeRootPath(file, fullName, rootPathHolder, index);", "-\t\t\t} else if (Util.isJavaFileName(file.getName())) {", "-\t\t\t\tIPath fullPath = new Path(file.getPath());", "-\t\t\t\tIPath javaFilePath = fullPath.removeFirstSegments(this.sourcePath.segmentCount()).setDevice(null);", "-\t\t\t\tString javaFilePathString = javaFilePath.toString();", "-\t\t\t\tif (javaFilePathString.endsWith(fullName)) {", "-\t\t\t\t\tindex[0] = Math.min(index[0], javaFilePathString.indexOf(fullName));", "-\t\t\t\t\trootPathHolder[0] = javaFilePathString;", "-\t}\t", "+\t", "+\tprivate void computeRootPath(File directory, HashSet firstLevelPackageNames, boolean hasDefaultPackage) {", "+\t\tFile[] files = directory.listFiles();", "+\t\tboolean hasSubDirectories = false;", "+\t\tloop: for (int i = 0, max = files.length; i < max; i++) {", "+\t\t\tFile file = files[i];", "+\t\t\tif (file.isDirectory()) {", "+\t\t\t\thasSubDirectories = true;", "+\t\t\t\tif (firstLevelPackageNames.contains(file.getName())) {", "+\t\t\t\t\tIPath fullPath = new Path(file.getParentFile().getPath());", "+\t\t\t\t\tIPath rootPathEntry = fullPath.removeFirstSegments(this.sourcePath.segmentCount()).setDevice(null);", "+\t\t\t\t\tthis.rootPaths.add(rootPathEntry.toString());", "+\t\t\t\t\tbreak loop;", "+\t\t\t\t} else {", "+\t\t\t\t\tcomputeRootPath(file, firstLevelPackageNames, hasDefaultPackage);", "+\t\t\t\t}", "+\t\t\t} else if (i == max - 1 && !hasSubDirectories && hasDefaultPackage) {", "+\t\t\t\tFile parentDir = file.getParentFile();", "+\t\t\t\tif (parentDir.list(this.filenameFilter).length != 0) {", "+\t\t\t\t\tIPath fullPath = new Path(parentDir.getPath());", "+\t\t\t\t\tIPath rootPathEntry = fullPath.removeFirstSegments(this.sourcePath.segmentCount()).setDevice(null);", "+\t\t\t\t\tthis.rootPaths.add(rootPathEntry.toString());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a409c3d24f80b89b0ad266af0b411251", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java", "commitBeforeChange": "ee7d00c6fce3f5ac075ad1ae838556503fe6ca33", "commitAfterChange": "42a20f90363fe2e676c07d56364d6cc6b90a9458", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 49, "signatureBeforeChange": "  \tprivate Type createType(ITypeBinding binding, ITypeBinding bindingPoint, AST ast, ImportRewriteContext context)", "signatureAfterChange": "  \tprivate Type createBaseType(AST ast, ImportRewriteContext context, ITypeBinding normalizedBinding)", "diff": ["-\tprivate Type createType(ITypeBinding binding, ITypeBinding bindingPoint, AST ast, ImportRewriteContext context) {", "-\t\tString str = addImport(bindingPoint, context);", "-\t\tint dotIndex = str != null ? str.lastIndexOf('.') : -1;", "-\t\tType qualifier = null;", "-\t\tif (dotIndex != -1) {", "-\t\t\tchar buf [] = new char [dotIndex];", "-\t\t\tfor (int i = 0; i < dotIndex; ++i)", "-\t\t\t\tbuf[i] = str.charAt(i);", "-\t\t\tstr = new String(buf);", "-\t\t\tqualifier = ast.newSimpleType(ast.newName(str));", "-\t\t}", "-\t\treturn createType(binding, bindingPoint, ast, qualifier, context);", "-\t}", "+\tprivate Type createBaseType(AST ast, ImportRewriteContext context, ITypeBinding normalizedBinding) {", "+\t\tType type;", "+\t\tIAnnotationBinding annotationBinding [] = normalizedBinding.getTypeAnnotations();", "+\t\tboolean annotsPresent = annotationBinding != null && annotationBinding.length > 0;", "+\t\tString qualifiedName= getRawQualifiedName(normalizedBinding);", "+\t\tString res = qualifiedName.length() > 0 ? internalAddImport(qualifiedName, context) : getRawName(normalizedBinding);", "+\t", "+\t\tif (annotsPresent) {", "+\t\t\tint dotIndex = res != null ? res.lastIndexOf('.') : -1;", "+\t\t\tif (dotIndex > 0) {", "+\t\t\t\tName nameQualifier = ast.newName(res.substring(0, dotIndex));", "+\t\t\t\tSimpleName simpleName = ast.newSimpleName(res.substring(dotIndex + 1));", "+\t\t\t\ttype = ast.newNameQualifiedType(nameQualifier, simpleName);", "+\t\t\t} else {", "+\t\t\t\ttype = ast.newSimpleType(ast.newName(res));", "+\t\t\t}", "+\t\t\tannotateList(((AnnotatableType) type).annotations(), annotationBinding, ast, context);", "+\t\t\ttype = ast.newSimpleType(ast.newName(res));"]}], "num": 18161}