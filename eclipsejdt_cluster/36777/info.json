{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "deba0ef52faf3dfab14b2b503fca062b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "173bc80ac4792898e6dd9b6359a2a0d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "59f134d776625487d5c6b62a9862cfb00a070d3e", "commitAfterChange": "96b4864be18ed8951f75fa1c52f7e975191f2b07", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tprivate void acceptQualifiedTypes()", "signatureAfterChange": "  \tprivate void acceptQualifiedTypes()", "diff": ["+\t\t}", "+\t\tif(this.acceptedAnnotations != null){", "+\t\t\tthis.acceptedAnswer = true;", "+\t\t\tfor (int i = 0; i < this.acceptedAnnotationsCount; i++) {", "+\t\t\t\tthis.noProposal = false;", "+\t\t\t\tthis.requestor.acceptAnnotation(", "+\t\t\t\t\tthis.acceptedAnnotations[i][0],", "+\t\t\t\t\tthis.acceptedAnnotations[i][1],", "+\t\t\t\t\tfalse,", "+\t\t\t\t\tnull,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t}", "+\t\t\tthis.acceptedAnnotations = null;", "+\t\t\tthis.acceptedAnnotationsCount = 0;", "+\t\t}", "+\t\tif(this.acceptedEnums != null){", "+\t\t\tthis.acceptedAnswer = true;", "+\t\t\tfor (int i = 0; i < this.acceptedEnumsCount; i++) {", "+\t\t\t\tthis.noProposal = false;", "+\t\t\t\tthis.requestor.acceptEnum(", "+\t\t\t\t\tthis.acceptedEnums[i][0],", "+\t\t\t\t\tthis.acceptedEnums[i][1],", "+\t\t\t\t\tfalse,", "+\t\t\t\t\tnull,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t}", "+\t\t\tthis.acceptedEnums = null;", "+\t\t\tthis.acceptedEnumsCount = 0;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23e71916d2e4cc00619a45e084887a71", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "4facfcdf4a36f611ae455f345faa2a13f779251b", "commitAfterChange": "9b4626a240c7fe9f3a95f4bc274592915f73c7ef", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate AbstractMethodDeclaration convert(ISourceMethod sourceMethod, CompilationResult compilationResult)", "signatureAfterChange": " \tprivate AbstractMethodDeclaration convert(SourceMethodElementInfo sourceMethod, CompilationResult compilationResult)", "diff": ["-\tprivate AbstractMethodDeclaration convert(ISourceMethod sourceMethod, CompilationResult compilationResult) {", "+\tprivate AbstractMethodDeclaration convert(SourceMethodElementInfo sourceMethod, CompilationResult compilationResult) {", "+\t\tint modifiers = sourceMethod.getModifiers();", "-\t\t\tMethodDeclaration decl = new MethodDeclaration(compilationResult);", "-\t\t\t/* convert return type */", "-\t\t\tdecl.returnType =", "-\t\t\t\tcreateTypeReference(sourceMethod.getReturnTypeName(), start, end);", "-\t\t\tmethod = decl;", "+\t\t\tMethodDeclaration decl;", "+\t\t\tif (sourceMethod.isAnnotationMethod()) {", "+\t\t\t\tAnnotationMethodDeclaration annotationMethodDeclaration = new AnnotationMethodDeclaration(compilationResult);", "+", "+\t\t\t\t/* conversion of default value */", "+\t\t\t\tif ((this.flags & FIELD_INITIALIZATION) != 0) {", "+\t\t\t\t\tchar[] defaultValueSource = sourceMethod.getDefaultValueSource();", "+\t\t\t\t\tif (defaultValueSource != null) {", "+\t\t\t\t\t\tif (this.parser == null) {", "+\t\t\t\t\t\t\tthis.parser = new Parser(this.problemReporter, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// TODO (jerome) handle Annotation and MemberValusArrayInitializer)", "+\t\t\t\t\t\tExpression expression =  this.parser.parseExpression(defaultValueSource, 0, defaultValueSource.length, this.unit);", "+\t\t\t\t\t\tif (expression != null) {", "+\t\t\t\t\t\t\tannotationMethodDeclaration.defaultValue = expression;", "+\t\t\t\t\t\t\tmodifiers |= AccAnnotationDefault;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tdecl = annotationMethodDeclaration;", "+\t\t\t} else {", "+\t\t\t\tdecl = new MethodDeclaration(compilationResult);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// convert return type", "+\t\t\tdecl.returnType = createTypeReference(sourceMethod.getReturnTypeName(), start, end);", "+\t\t\t", "+\t\t\t// type parameters", "+\t\t\t", "+\t\t\tmethod = decl;", "-\t\tint modifiers = sourceMethod.getModifiers();", "-\t\tif ((this.flags & LOCAL_TYPE) != 0 && sourceMethod instanceof SourceMethodElementInfo) {", "-\t\t\tIJavaElement[] children = ((SourceMethodElementInfo)sourceMethod).getChildren();", "+\t\tif ((this.flags & LOCAL_TYPE) != 0) {", "+\t\t\tIJavaElement[] children = sourceMethod.getChildren();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35d10583a0727711ff407b84e3102c80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "08a2bb4b18c0c69c0ed4f816cadfd40ebe8abddb", "commitAfterChange": "d0e5b2ab614e06e582b08c94edd4cb759a159eaf", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "signatureAfterChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "diff": ["-\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "-\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "-\t\tfalse);\r", "-\t// iterate type lookup in each package fragment\r", "-\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "-\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "-\t\tif (type != null) break;\t\r", "-\t}\r", "-\tif (type == null) {\r", "-\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\t\tif (packageName != null) {\r", "-\t\t\tpName = new String(packageName);\r", "-\t\t}\r", "-\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "-\t\t\t// look inside the type in which we are resolving in\r", "-\t\t\tString tName= new String(typeName);\r", "-\t\t\ttName = tName.replace('.','$');\r", "-\t\t\tIType[] allTypes= null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "-\t\t\t\tallTypes = new IType[v.size()];\r", "-\t\t\t\tv.copyInto(allTypes);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\treturn null;\r", "+\t\r", "+\tif (fCodeResolve instanceof WorkingCopy) {\r", "+\t\tWorkingCopy wc = (WorkingCopy) fCodeResolve;\r", "+\t\ttry {\r", "+\t\t\tif(((packageName == null || packageName.length == 0) && wc.getPackageDeclarations().length == 0) ||\r", "+\t\t\t\t(!(packageName == null || packageName.length == 0) && wc.getPackageDeclaration(new String(packageName)).exists())) {\r", "+\t\t\t\t\t\r", "+\t\t\t\ttype = wc.getType(new String(typeName));\r", "+\t\t\t\tif(!type.exists()) {\r", "+\t\t\t\t\ttype = null;\r", "+\t\t\t\t}\r", "-\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "-\t\t\t\t\treturn allTypes[i];\r", "+\t\t}catch (JavaModelException e) {\r", "+\t\t\ttype = null;", "+\t\t}\r", "+\t}\r", "+\r", "+\tif(type == null) {\r", "+\t\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "+\t\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "+\t\t\tfalse);\r", "+\t\t// iterate type lookup in each package fragment\r", "+\t\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "+\t\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "+\t\t\tif (type != null) break;\t\r", "+\t\t}\r", "+\t\tif (type == null) {\r", "+\t\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\t\tif (packageName != null) {\r", "+\t\t\t\tpName = new String(packageName);\r", "+\t\t\t}\r", "+\t\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "+\t\t\t\t// look inside the type in which we are resolving in\r", "+\t\t\t\tString tName= new String(typeName);\r", "+\t\t\t\ttName = tName.replace('.','$');\r", "+\t\t\t\tIType[] allTypes= null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "+\t\t\t\t\tallTypes = new IType[v.size()];\r", "+\t\t\t\t\tv.copyInto(allTypes);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "+\t\t\t\t\t\treturn allTypes[i];\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "422b957e5b6a98f2b551f7e15bc8df8a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["+\t\t\tboolean isStringSwitch = false;", "+\t\t\t\t\t} else if (upperScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_7 && expressionType.id == TypeIds.T_JavaLangString) {", "+\t\t\t\t\t\tisStringSwitch = true;", "+\t\t\t\t\t\tbreak checkType;", "-\t\t\t\tthis.constants = new int[length];", "-\t\t\t\tCaseStatement[] duplicateCaseStatements = null;", "-\t\t\t\tint duplicateCaseStatementsCounter = 0;", "+\t\t\t\tif (!isStringSwitch) {", "+\t\t\t\t\tthis.constants = new int[length];", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.stringConstants = new String[length];", "+\t\t\t\t}", "-\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\t//----check for duplicate case statement------------", "-\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "-\t\t\t\t\t\t\tif (this.constants[j] == key) {", "-\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "-\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "-\t\t\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateCase(this.cases[j]);", "-\t\t\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateCase(currentCaseStatement);", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = this.cases[j];", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tboolean found = false;", "-\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "-\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "-\t\t\t\t\t\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateCase(currentCaseStatement);", "-\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (!isStringSwitch) {", "+\t\t\t\t\t\t\tint key = constant.intValue();", "+\t\t\t\t\t\t\t//----check for duplicate case statement------------", "+\t\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "+\t\t\t\t\t\t\t\tif (this.constants[j] == key) {", "+\t\t\t\t\t\t\t\t\treportDuplicateCase((CaseStatement) statement, this.cases[j], length);", "+\t\t\t\t\t\t\tthis.constants[counter++] = key;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tString key = constant.stringValue();", "+\t\t\t\t\t\t\t//----check for duplicate case statement------------", "+\t\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "+\t\t\t\t\t\t\t\tif (this.stringConstants[j].equals(key)) {", "+\t\t\t\t\t\t\t\t\treportDuplicateCase((CaseStatement) statement, this.cases[j], length);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.stringConstants[counter++] = key;\t\t\t", "-\t\t\t\t\t\tthis.constants[counter++] = key;", "-\t\t\t\t\tSystem.arraycopy(this.constants, 0, this.constants = new int[counter], 0, counter);", "+\t\t\t\t\tif (!isStringSwitch) {", "+\t\t\t\t\t\tSystem.arraycopy(this.constants, 0, this.constants = new int[counter], 0, counter);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tSystem.arraycopy(this.stringConstants, 0, this.stringConstants = new String[counter], 0, counter);", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (isStringSwitch) {", "+\t\t\t\tthis.dispatchStringCopy  = new LocalVariableBinding(SecretStringVariableName, upperScope.getJavaLangString(), ClassFileConstants.AccDefault, false);", "+\t\t\t\tupperScope.addLocalVariable(this.dispatchStringCopy);", "+\t\t\t\tthis.dispatchStringCopy.setConstant(Constant.NotAConstant);", "+\t\t\t\tthis.dispatchStringCopy.useFlag = LocalVariableBinding.USED;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e585d638a2071e491193e1f0d31572b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CreateCompilationUnitOperation.java", "commitBeforeChange": "eba1b2d8628458befc75c296c3c46577733d25b5", "commitAfterChange": "307bd23008332fd8b3a6f2a1ed42ab1b2a056046", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected void executeOperation() throws JavaModelException", "signatureAfterChange": "\r protected void executeOperation() throws JavaModelException", "diff": ["-\tInputStream stream = new ByteArrayInputStream(BufferManager.stringToBytes(fSource));\r", "-\tcreateFile(folder, unit.getElementName(), stream, fForce);\r", "-\tworked(1);\r", "-\tfResultElements = new IJavaElement[] {unit};\r", "-\tif (unit.getParent().exists()) {\r", "-\t\tfor (int i = 0; i < fResultElements.length; i++) {\r", "-\t\t\tdelta.added(fResultElements[i]);\r", "+\tIFile compilationUnitFile = folder.getFile(new Path(fName));\r", "+\tif (compilationUnitFile.exists()) {\r", "+\t\t// update the contents of the existing unit if fForce is true\r", "+\t\tif (fForce) {\r", "+\t\t\tunit.getBuffer().setContents(fSource);\r", "+\t\t\tunit.save(new NullProgressMonitor(), false);\r", "+\t\t\tfResultElements = new IJavaElement[] {unit};\r", "+\t\t\tif (unit.getParent().exists()) {\r", "+\t\t\t\tfor (int i = 0; i < fResultElements.length; i++) {\r", "+\t\t\t\t\tdelta.changed(fResultElements[i], IJavaElementDelta.F_CONTENT);\r", "+\t\t\t\t}\r", "+\t\t\t\taddDelta(delta);\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION));\r", "-\t\taddDelta(delta);\r", "-\t} // else unit is created outside classpath\r", "-\t  // non-java resource delta will be notified by delta processor\r", "+\t} else {\r", "+\t\tInputStream stream = new ByteArrayInputStream(BufferManager.stringToBytes(fSource));\r", "+\t\tcreateFile(folder, unit.getElementName(), stream, false);\r", "+\t\tfResultElements = new IJavaElement[] {unit};\r", "+\t\tif (unit.getParent().exists()) {\r", "+\t\t\tfor (int i = 0; i < fResultElements.length; i++) {\r", "+\t\t\t\tdelta.added(fResultElements[i]);\r", "+\t\t\t}\r", "+\t\t\taddDelta(delta);\r", "+\t\t}\r", "+\t} \r", "+\tworked(1);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "59db397ab21383421308a4200d6997aa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java", "commitBeforeChange": "c7e13eb999aeeb70fd34b19df0f27a778109206c", "commitAfterChange": "ad2281f1520933e65d479408c685e1055d82a8b2", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \t@Override \tpublic TypeElement getTypeElement(CharSequence name)", "signatureAfterChange": " \t@Override \tpublic TypeElement getTypeElement(CharSequence name)", "diff": ["-\t\t//TODO: do this the right way - this is a hack to test if it works", "-\t\tString qname = name.toString();", "-\t\tString parts[] = qname.split(\"\\\\.\"); //$NON-NLS-1$", "-\t\tint length = parts.length;", "-\t\tchar[][] compoundName = new char[length][];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tcompoundName[i] = parts[i].toCharArray();", "-\t\t}", "+\t\tfinal char[][] compoundName = CharOperation.splitOn('.', name.toString().toCharArray());", "-\t\tif (binding == null) {", "+\t\t// If we didn't find the binding, maybe it's a nested type;", "+\t\t// try finding the top-level type and then working downwards.", "+\t\tif (null == binding) {", "+\t\t\tReferenceBinding topLevelBinding = null;", "+\t\t\tint topLevelSegments = compoundName.length; ", "+\t\t\twhile (--topLevelSegments > 0) {", "+\t\t\t\tchar[][] topLevelName = new char[topLevelSegments][];", "+\t\t\t\tfor (int i = 0; i < topLevelSegments; ++i) {", "+\t\t\t\t\ttopLevelName[i] = compoundName[i];", "+\t\t\t\t}", "+\t\t\t\ttopLevelBinding = le.getType(topLevelName);", "+\t\t\t\tif (null != topLevelBinding) {", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (null == topLevelBinding) {", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tbinding = topLevelBinding;", "+\t\t\tfor (int i = topLevelSegments; null != binding && i < compoundName.length; ++i) {", "+\t\t\t\tbinding = binding.getMemberType(compoundName[i]);", "+\t\t\t}", "+\t\t}", "+\t\tif (null == binding) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a86bd1aea540cf2917b6afcfee34bce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "f88c1fe220ded26227925e3745e5515c08409c5d", "commitAfterChange": "8f896a654035e16596d9bc3a2404427ff7b3145b", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  \tprivate boolean complete( \t\t\tASTNode astNode, \t\t\tASTNode astNodeParent, \t\t\tASTNode enclosingNode, \t\t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\t\tBinding qualifiedBinding, \t\t\tScope scope, \t\t\tboolean insideTypeAnnotation)", "signatureAfterChange": "  \tprivate boolean complete( \t\t\tASTNode astNode, \t\t\tASTNode astNodeParent, \t\t\tASTNode enclosingNode, \t\t\tCompilationUnitDeclaration compilationUnitDeclaration, \t\t\tBinding qualifiedBinding, \t\t\tScope scope, \t\t\tboolean insideTypeAnnotation)", "diff": ["-\t\t\t\t\tthis.findEnumConstant(this.completionToken, (SwitchStatement) astNodeParent);", "+\t\t\t\t\tthis.findEnumConstantsFromSwithStatement(this.completionToken, (SwitchStatement) astNodeParent);", "+\t\t\t\tif (this.expectedTypesPtr > -1) {", "+\t\t\t\t\tthis.assistNodeIsEnum = true;", "+\t\t\t\t\tdone : for (int i = 0; i <= this.expectedTypesPtr; i++) {", "+\t\t\t\t\t\tif (!this.expectedTypes[i].isEnum()) {", "+\t\t\t\t\t\t\tthis.assistNodeIsEnum = false;", "+\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t}", "+\t\t\t\t\t\tif (this.expectedTypesPtr > -1) {", "+\t\t\t\t\t\t\tthis.assistNodeIsEnum = true;", "+\t\t\t\t\t\t\tdone : for (int i = 0; i <= this.expectedTypesPtr; i++) {", "+\t\t\t\t\t\t\t\tif (!this.expectedTypes[i].isEnum()) {", "+\t\t\t\t\t\t\t\t\tthis.assistNodeIsEnum = false;", "+\t\t\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6eca3bb9be6da40b4618cdf7622c431b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "7fdd30796329ce26e7f870767adb170e365b96ed", "commitAfterChange": "5d8cf65e1df5f9eb0a074e2096650fc374a7dd1f", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": " protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customEncoding) throws InvalidInputException", "signatureAfterChange": " protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customEncoding) throws InvalidInputException", "diff": ["-\t \tfinal File javaHome = getJavaHome();", "-\t \t * Handle >= JDK 1.2.2 settings: retrieve rt.jar", "+\t \t * Handle >= JDK 1.2.2 settings: retrieve the bootclasspath", "-\t \t if (javaHome != null) {", "-\t\t\tFile[] directoriesToCheck = null;", "-\t\t\tif (System.getProperty(\"os.name\").startsWith(\"Mac\")) {//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\tdirectoriesToCheck = new File[] {", "-\t\t\t\t\tnew File(javaHome, \"../Classes\"), //$NON-NLS-1$", "-\t\t\t\t};", "-\t\t\t} else {", "-\t\t\t\tdirectoriesToCheck = new File[] {", "-\t\t\t\t\tnew File(javaHome, \"lib\") //$NON-NLS-1$", "-\t\t\t\t};", "+\t\t// check bootclasspath properties for Sun, JRockit and Harmony VMs", "+\t\tString bootclasspathProperty = System.getProperty(\"sun.boot.class.path\"); //$NON-NLS-1$", "+\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t// IBM J9 VMs", "+\t\t\tbootclasspathProperty = System.getProperty(\"vm.boot.class.path\"); //$NON-NLS-1$", "+\t\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t\t// Harmony using IBM VME", "+\t\t\t\tbootclasspathProperty = System.getProperty(\"org.apache.harmony.boot.class.path\"); //$NON-NLS-1$", "-\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "-\t\t\tif (systemLibrariesJars != null) {", "-\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "-\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "-\t\t\t\t\tif (current != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\t\tFileSystem.Classpath classpath =", "-\t\t\t\t\t\t\t\tFileSystem.getClasspath(current[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\tnull, false, null, null);", "-\t\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "+\t\t}", "+\t\tif ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {", "+\t\t\tStringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);", "+\t\t\tString token;", "+\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "+\t\t\t\t\t\t.getClasspath(token, customEncoding, null);", "+\t\t\t\tif (currentClasspath != null) {", "+\t\t\t\t\tbootclasspaths.add(currentClasspath);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// try to get all jars inside the lib folder of the java home", "+\t\t\tfinal File javaHome = getJavaHome();", "+\t\t\tif (javaHome != null) {", "+\t\t\t\tFile[] directoriesToCheck = null;", "+\t\t\t\tif (System.getProperty(\"os.name\").startsWith(\"Mac\")) {//$NON-NLS-1$//$NON-NLS-2$", "+\t\t\t\t\tdirectoriesToCheck = new File[] {", "+\t\t\t\t\t\tnew File(javaHome, \"../Classes\"), //$NON-NLS-1$", "+\t\t\t\t\t};", "+\t\t\t\t} else {", "+\t\t\t\t\t// fall back to try to retrieve them out of the lib directory", "+\t\t\t\t\tdirectoriesToCheck = new File[] {", "+\t\t\t\t\t\tnew File(javaHome, \"lib\") //$NON-NLS-1$", "+\t\t\t\t\t};", "+\t\t\t\t}", "+\t\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "+\t\t\t\tif (systemLibrariesJars != null) {", "+\t\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "+\t\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "+\t\t\t\t\t\tif (current != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tFileSystem.Classpath classpath =", "+\t\t\t\t\t\t\t\t\tFileSystem.getClasspath(current[j].getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\t\tnull, false, null, null);", "+\t\t\t\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "+\t\t\t\t\t\t\t\t}", "- \t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7193652fd9776fb2d65c40412c81d755", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/UserLibrary.java", "commitBeforeChange": "6d532e3e6bb5f869c4cf89800d8c25d215a96667", "commitAfterChange": "cea94298f193240b6230178dfa939e55ae1ab853", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic static UserLibrary createFromString(Reader reader) throws IOException", "signatureAfterChange": "  \tpublic static UserLibrary createFromString(Reader reader) throws IOException", "diff": ["-\t\t// String version= cpElement.getAttribute(TAG_VERSION);", "-\t\t// in case we update the format: add code to read older versions", "-", "+\t\tString version= cpElement.getAttribute(TAG_VERSION);", "-\t\t\t\t\tString path = element.getAttribute(TAG_PATH);", "-\t\t\t\t\tIPath sourceAttach= element.hasAttribute(TAG_SOURCEATTACHMENT) ? new Path(element.getAttribute(TAG_SOURCEATTACHMENT)) : null;", "-\t\t\t\t\tIPath sourceAttachRoot= element.hasAttribute(TAG_SOURCEATTACHMENTROOT) ? new Path(element.getAttribute(TAG_SOURCEATTACHMENTROOT)) : null;", "+\t\t\t\t\tString pathString = element.getAttribute(TAG_PATH);", "+\t\t\t\t\tString sourceAttachString = element.hasAttribute(TAG_SOURCEATTACHMENT) ? element.getAttribute(TAG_SOURCEATTACHMENT) : null;", "+\t\t\t\t\tString sourceAttachRootString = element.hasAttribute(TAG_SOURCEATTACHMENTROOT) ? element.getAttribute(TAG_SOURCEATTACHMENTROOT) : null;", "+\t\t\t\t\tIPath entryPath = null; ", "+\t\t\t\t\tIPath sourceAttachPath = null;", "+\t\t\t\t\tIPath sourceAttachRootPath = null;", "+\t\t\t\t\tif (version.equals(VERSION_ONE)) {", "+\t\t\t\t\t\tentryPath = Path.fromOSString(pathString);", "+\t\t\t\t\t\tif (sourceAttachString != null) sourceAttachPath = Path.fromOSString(sourceAttachString);", "+\t\t\t\t\t\tif (sourceAttachRootString != null) sourceAttachRootPath = Path.fromOSString(sourceAttachRootString);", "+\t\t\t\t\t}", "+\t\t\t\t\telse {", "+\t\t\t\t\t\tentryPath = Path.fromPortableString(pathString);", "+\t\t\t\t\t\tif (sourceAttachString != null) sourceAttachPath = Path.fromPortableString(sourceAttachString);", "+\t\t\t\t\t\tif (sourceAttachRootString != null) sourceAttachRootPath = Path.fromPortableString(sourceAttachRootString);", "+\t\t\t\t\t}", "+", "-\t\t\t\t\tIClasspathEntry entry = JavaCore.newLibraryEntry(new Path(path), sourceAttach, sourceAttachRoot, accessRules, extraAttributes, false/*not exported*/);", "+\t\t\t\t\tIClasspathEntry entry = JavaCore.newLibraryEntry(entryPath, sourceAttachPath, sourceAttachRootPath, accessRules, extraAttributes, false/*not exported*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e9d024088f0453518f6ec05fb15fb06", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java", "commitBeforeChange": "530c48877da8402a05b3f0b84990331c9acd9df4", "commitAfterChange": "d5488a3ba93291ed8339edaad64e7cedc13fb558", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "\r public boolean hasStructuralChanges(byte[] newBytes, boolean orderRequired, boolean excludesSynthetic)", "signatureAfterChange": "\r public boolean hasStructuralChanges(byte[] newBytes, boolean orderRequired, boolean excludesSynthetic)", "diff": ["-\t\tif (orderRequired) {\r", "-\t\t\tif (this.fieldsCount != 0)\r", "-\t\t\t\tArrays.sort(this.fields);\r", "-\t\t\tif (otherFieldInfosLength != 0)\r", "-\t\t\t\tArrays.sort(otherFieldInfos);\r", "+\t\tboolean compareFields = true;\r", "+\t\tif (this.fieldsCount == otherFieldInfosLength) {\r", "+\t\t\tint i = 0;\r", "+\t\t\tfor (; i < this.fieldsCount; i++)\r", "+\t\t\t\tif (hasStructuralFieldChanges(this.fields[i], otherFieldInfos[i])) break;\r", "+\t\t\tif ((compareFields = i != this.fieldsCount) && !orderRequired && !excludesSynthetic)\r", "+\t\t\t\treturn true;\r", "-\t\tif (excludesSynthetic) {\r", "-\t\t\tif (hasNonSyntheticFieldChanges(this.fields, otherFieldInfos))\r", "-\t\t\t\treturn true;\r", "-\t\t} else {\r", "-\t\t\tif (this.fieldsCount != otherFieldInfosLength)\r", "-\t\t\t\treturn true;\r", "-\t\t\tfor (int i = 0; i < this.fieldsCount; i++)\r", "-\t\t\t\tif (hasStructuralFieldChanges(this.fields[i], otherFieldInfos[i]))\r", "+\t\tif (compareFields) {\r", "+\t\t\tif (orderRequired) {\r", "+\t\t\t\tif (this.fieldsCount != 0)\r", "+\t\t\t\t\tArrays.sort(this.fields);\r", "+\t\t\t\tif (otherFieldInfosLength != 0)\r", "+\t\t\t\t\tArrays.sort(otherFieldInfos);\r", "+\t\t\t}\r", "+\t\t\tif (excludesSynthetic) {\r", "+\t\t\t\tif (hasNonSyntheticFieldChanges(this.fields, otherFieldInfos))\r", "+\t\t\t} else {\r", "+\t\t\t\tif (this.fieldsCount != otherFieldInfosLength)\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\tfor (int i = 0; i < this.fieldsCount; i++)\r", "+\t\t\t\t\tif (hasStructuralFieldChanges(this.fields[i], otherFieldInfos[i]))\r", "+\t\t\t\t\t\treturn true;\r", "+\t\t\t}\r", "-\t\tif (orderRequired) {\r", "-\t\t\tif (this.methodsCount != 0)\r", "-\t\t\t\tArrays.sort(this.methods);\r", "-\t\t\tif (otherMethodInfosLength != 0)\r", "-\t\t\t\tArrays.sort(otherMethodInfos);\t\r", "+\t\tboolean compareMethods = true;\r", "+\t\tif (this.methodsCount == otherMethodInfosLength) {\r", "+\t\t\tint i = 0;\r", "+\t\t\tfor (; i < this.methodsCount; i++)\r", "+\t\t\t\tif (hasStructuralMethodChanges(this.methods[i], otherMethodInfos[i])) break;\r", "+\t\t\tif ((compareMethods = i != this.methodsCount) && !orderRequired && !excludesSynthetic)\r", "+\t\t\t\treturn true;\r", "-\t\tif (excludesSynthetic) {\r", "-\t\t\tif (hasNonSyntheticMethodChanges(this.methods, otherMethodInfos))\r", "-\t\t\t\treturn true;\r", "-\t\t} else {\r", "-\t\t\tif (this.methodsCount != otherMethodInfosLength)\r", "-\t\t\t\treturn true;\r", "-\t\t\tfor (int i = 0; i < this.methodsCount; i++)\r", "-\t\t\t\tif (hasStructuralMethodChanges(this.methods[i], otherMethodInfos[i]))\r", "+\t\tif (compareMethods) {\r", "+\t\t\tif (orderRequired) {\r", "+\t\t\t\tif (this.methodsCount != 0)\r", "+\t\t\t\t\tArrays.sort(this.methods);\r", "+\t\t\t\tif (otherMethodInfosLength != 0)\r", "+\t\t\t\t\tArrays.sort(otherMethodInfos);\t\r", "+\t\t\t}\r", "+\t\t\tif (excludesSynthetic) {\r", "+\t\t\t\tif (hasNonSyntheticMethodChanges(this.methods, otherMethodInfos))\r", "+\t\t\t} else {\r", "+\t\t\t\tif (this.methodsCount != otherMethodInfosLength)\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\tfor (int i = 0; i < this.methodsCount; i++)\r", "+\t\t\t\t\tif (hasStructuralMethodChanges(this.methods[i], otherMethodInfos[i]))\r", "+\t\t\t\t\t\treturn true;\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7fd2bc9ec04f38ee3e7bdea32eac0e16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "5d61afa709802d331d230880f37fe526cefe25cb", "commitAfterChange": "611f47e73b2ec0045eb75d60dad86eed58ebb09d", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " public static String[] getJavaClassLibs()", "signatureAfterChange": " public static String[] getJavaClassLibs()", "diff": ["-    String jreDir = getJREDirectory();", "-    final String osName = System.getProperty(\"os.name\");", "-    if (jreDir == null) {", "-        return new String[] {};", "-    }", "-    if (osName.startsWith(\"Mac\")) {", "-        return new String[] {", "-            toNativePath(jreDir + \"/../Classes/classes.jar\")", "-        };", "-    }", "-    final String vmName = System.getProperty(\"java.vm.name\");", "-    if (\"J9\".equals(vmName)) {", "-        return new String[] {", "-            toNativePath(jreDir + \"/lib/jclMax/classes.zip\")", "-        };", "-    }", "-\tif (\"DRLVM\".equals(vmName)) {", "-\t\tFilenameFilter jarFilter = new FilenameFilter() {", "-\t\t\tpublic boolean accept(File dir, String name) {", "-\t\t\t\treturn name.endsWith(\".jar\") & !name.endsWith(\"-src.jar\");", "-\t\t\t}", "-\t\t};", "-\t\tString[] jars = new File(jreDir + \"/lib/boot/\").list(jarFilter);", "-\t\tfor (int i = 0; i < jars.length; i++) {", "-\t\t\tjars[i] = toNativePath(jreDir + \"/lib/boot/\" + jars[i]);", "+\t// check bootclasspath properties for Sun, JRockit and Harmony VMs", "+\tString bootclasspathProperty = System.getProperty(\"sun.boot.class.path\"); //$NON-NLS-1$", "+\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t// IBM J9 VMs", "+\t\tbootclasspathProperty = System.getProperty(\"vm.boot.class.path\"); //$NON-NLS-1$", "+\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t// Harmony using IBM VME", "+\t\t\tbootclasspathProperty = System.getProperty(\"org.apache.harmony.boot.class.path\"); //$NON-NLS-1$", "-\t\treturn jars;", "-    ArrayList paths = new ArrayList();", "-    String[] jarsNames = new String[] {", "-    \t\t\"/lib/vm.jar\",", "-    \t\t\"/lib/rt.jar\",", "-    \t\t\"/lib/core.jar\",", "-    \t\t\"/lib/security.jar\",", "-    \t\t\"/lib/xml.jar\",", "-    \t\t\"/lib/graphics.jar\"", "-    };", "-    addJarEntries(jreDir, jarsNames, paths);", "-    String[] result = new String[paths.size()];", "-    paths.toArray(result);", "-    return result;", "+\tString[] jars = null;", "+\tif ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {", "+\t\tStringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);", "+\t\tfinal int size = tokenizer.countTokens();", "+\t\tjars = new String[size];", "+\t\tint i = 0;", "+\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\tfinal String fileName = toNativePath(tokenizer.nextToken());", "+\t\t\tif (new File(fileName).exists()) {", "+\t\t\t\tjars[i] = fileName;", "+\t\t\t\ti++;", "+\t\t\t}", "+\t\t}", "+\t\tif (size != i) {", "+\t\t\t// resize", "+\t\t\tSystem.arraycopy(jars, 0, (jars = new String[i]), 0, i);", "+\t\t}", "+\t} else {", "+\t\tString jreDir = getJREDirectory();", "+\t\tfinal String osName = System.getProperty(\"os.name\");", "+\t\tif (jreDir == null) {", "+\t\t\treturn new String[] {};", "+\t\t}", "+\t\tif (osName.startsWith(\"Mac\")) {", "+\t\t\treturn new String[] {", "+\t\t\t\t\ttoNativePath(jreDir + \"/../Classes/classes.jar\")", "+\t\t\t};", "+\t\t}", "+\t\tfinal String vmName = System.getProperty(\"java.vm.name\");", "+\t\tif (\"J9\".equals(vmName)) {", "+\t\t\treturn new String[] {", "+\t\t\t\t\ttoNativePath(jreDir + \"/lib/jclMax/classes.zip\")", "+\t\t\t};", "+\t\t}", "+\t\tString[] jarsNames = null;", "+\t\tArrayList paths = new ArrayList();", "+\t\tif (\"DRLVM\".equals(vmName)) {", "+\t\t\tFilenameFilter jarFilter = new FilenameFilter() {", "+\t\t\t\tpublic boolean accept(File dir, String name) {", "+\t\t\t\t\treturn name.endsWith(\".jar\") & !name.endsWith(\"-src.jar\");", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tjarsNames = new File(jreDir + \"/lib/boot/\").list(jarFilter);", "+\t\t\taddJarEntries(jreDir + \"/lib/boot/\", jarsNames, paths);", "+\t\t} else {", "+\t\t\tjarsNames = new String[] {", "+\t\t\t\t\t\"/lib/vm.jar\",", "+\t\t\t\t\t\"/lib/rt.jar\",", "+\t\t\t\t\t\"/lib/core.jar\",", "+\t\t\t\t\t\"/lib/security.jar\",", "+\t\t\t\t\t\"/lib/xml.jar\",", "+\t\t\t\t\t\"/lib/graphics.jar\"", "+\t\t\t};", "+\t\t\taddJarEntries(jreDir, jarsNames, paths);", "+\t\t}", "+\t\tjars = new String[paths.size()];", "+\t\tpaths.toArray(jars);", "+\t}", "+\treturn jars;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83ad56ab5b5d8becc0dd81e11bec2520", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java", "commitBeforeChange": "d2e007901d54a516821cedcfd5f65fdb2954f273", "commitAfterChange": "fa2cb5bc47f7fe5d18ae109d09f3bf4ba668083f", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tpublic void buttonPressed(int index)", "signatureAfterChange": " \tpublic void buttonPressed(int index)", "diff": ["-\t\t// TODO Auto-generated method stub", "+\t\tif (index == IDX_ADDEXTJAR) { // add new", "+\t\t\tFactoryContainer[] newEntries= openExtJarFileDialog(null);", "+\t\t\tint insertAt;", "+\t\t\tList selectedElements= fFactoryPathList.getSelectedElements();", "+\t\t\tif (selectedElements.size() == 1) {", "+\t\t\t\tinsertAt= fFactoryPathList.getIndexOfElement(selectedElements.get(0)) + 1;", "+\t\t\t} else {", "+\t\t\t\tinsertAt= fFactoryPathList.getSize();", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < newEntries.length; ++i) {", "+\t\t\t\tfFactoryPathList.addElement(newEntries[i], insertAt + i);", "+\t\t\t\tfFactoryPathList.setChecked(newEntries[i], true);", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85699fa9dd71c0edfdc83de9a9d9c20c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "b1348e3d0230a581c7eb25acd6ec072853b12bb0", "commitAfterChange": "f3728b24e0fe129a3644e987b967023e3f656958", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic void enterClass(\r \t\tint declarationStart,\r \t\tint modifiers,\r \t\tchar[] name,\r \t\tint nameSourceStart,\r \t\tint nameSourceEnd,\r \t\tchar[] superclass,\r \t\tchar[][] superinterfaces)", "signatureAfterChange": "\r \tpublic void enterClass(\r \t\tint declarationStart,\r \t\tint modifiers,\r \t\tchar[] name,\r \t\tint nameSourceStart,\r \t\tint nameSourceEnd,\r \t\tchar[] superclass,\r \t\tchar[][] superinterfaces)", "diff": ["+\t\t\tSystem.arraycopy(\r", "+\t\t\t\tthis.fMemberName,\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.fMemberName = new String[this.typeDepth * 2],\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.typeDepth);\r", "+\t\t\tSystem.arraycopy(\r", "+\t\t\t\tthis.fMemberDeclarationStart,\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.fMemberDeclarationStart = new int[this.typeDepth * 2],\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.typeDepth);\t\t\t\t\t\t\t\r", "+\t\t\tSystem.arraycopy(\r", "+\t\t\t\tthis.fMemberNameRange,\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.fMemberNameRange = new SourceRange[this.typeDepth * 2],\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.typeDepth);\r", "+\t\t\tSystem.arraycopy(\r", "+\t\t\t\tthis.fMethodParameterTypes,\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.fMethodParameterTypes = new char[this.typeDepth * 2][][],\r", "+\t\t\t\t0,\r", "+\t\t\t\tthis.typeDepth);\t\t\t\t\t\r", "-\t\tthis.types[typeDepth] = this.getType(new String(name));\r", "+\t\tif (name.length == 0) {\r", "+\t\t\tthis.anonymousCounter++;\r", "+\t\t\tif (this.anonymousCounter == this.anonymousClassName) {\r", "+\t\t\t\tthis.types[typeDepth] = this.getType(fType.getElementName());\r", "+\t\t\t} else {\r", "+\t\t\t\tthis.types[typeDepth] = this.getType(new String(name));\t\t\t\t\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tthis.types[typeDepth] = this.getType(new String(name));\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "86f2f28ef3080e05564ee8cc75b10bc9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java", "commitBeforeChange": "96ef1f14bcd478482a92078234eb6af9c101a0ca", "commitAfterChange": "1e440b3a3ee1ce045faaf4b9f0cc5f6c547c81ba", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 30, "signatureBeforeChange": " public SourceMapper getSourceMapper()", "signatureAfterChange": " public SourceMapper getSourceMapper()", "diff": ["+\tSourceMapper mapper;", "-\t\treturn ((PackageFragmentRootInfo) getElementInfo()).getSourceMapper();", "+\t\tPackageFragmentRootInfo rootInfo = (PackageFragmentRootInfo) getElementInfo();", "+\t\tmapper = rootInfo.getSourceMapper();", "+\t\tif (mapper == null) {", "+\t\t\t// first call to this method", "+\t\t\tIPath sourcePath= getSourceAttachmentPath();", "+\t\t\tif (sourcePath != null) {", "+\t\t\t\tIPath rootPath= getSourceAttachmentRootPath();", "+\t\t\t\tmapper = this.createSourceMapper(sourcePath, rootPath);", "+\t\t\t\tif (rootPath == null && mapper.rootPath != null) {", "+\t\t\t\t\t// as a side effect of calling the SourceMapper constructor, the root path was computed", "+\t\t\t\t\trootPath = new Path(mapper.rootPath);", "+\t\t\t\t\t", "+\t\t\t\t\t//set the property to the path of the mapped source", "+\t\t\t\t\tthis.setSourceAttachmentProperty(", "+\t\t\t\t\t\tsourcePath.toString() ", "+\t\t\t\t\t\t+ ATTACHMENT_PROPERTY_DELIMITER ", "+\t\t\t\t\t\t+ rootPath.toString());", "+\t\t\t\t}", "+\t\t\t\trootInfo.setSourceMapper(mapper);", "+\t\t\t} else {", "+\t\t\t\t// remember that no source is attached", "+\t\t\t\trootInfo.setSourceMapper(NO_SOURCE_MAPPER);", "+\t\t\t\tmapper = null;", "+\t\t\t}", "+\t\t} else if (mapper == NO_SOURCE_MAPPER) {", "+\t\t\t// a previous call to this method found out that no source was attached", "+\t\t\tmapper = null;", "+\t\t}", "-\t\treturn null;", "+\t\t// no source can be attached", "+\t\tmapper = null;", "+\treturn mapper;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e2c3ca77ff6e2c6d9741f14d9c9ac1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionJavadocParser.java", "commitBeforeChange": "eb1301b98f2da1fb78fff513bcf414717fc53a5b", "commitAfterChange": "3707a04a590722ca1140d7955ba0f8b75fc66814", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected Object createTypeReference(int primitiveToken)", "signatureAfterChange": " \tprotected Object createTypeReference(int primitiveToken)", "diff": ["-\t\t\tif (this.identifierStack[this.identifierPtr] == CompletionScanner.EmptyCompletionIdentifier) {", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t\t// See if completion is in qualification", "-\t\t\tint size = nbIdentifiers;", "-\t\t\tif (this.tagSourceStart <= this.cursorLocation && this.cursorLocation <= this.tagSourceEnd) {", "-\t\t\t\tfor (size=0; size<nbIdentifiers; size++) {", "-\t\t\t\t\tint start = (int) (this.identifierPositionStack[size] >>> 32);", "-\t\t\t\t\tint end = (int) this.identifierPositionStack[size];", "-\t\t\t\t\tif (start <= this.cursorLocation && this.cursorLocation <= end) {", "-\t\t\t\t\t\tsize++;", "-\t\t\t\t\t\tbreak;", "+\t\t\tfor (int i=startPtr; i<this.identifierPtr; i++) {", "+\t\t\t\tint start = (int) (this.identifierPositionStack[i] >>> 32);", "+\t\t\t\tint end = (int) this.identifierPositionStack[i];", "+\t\t\t\tif (start <= this.cursorLocation && this.cursorLocation <= end) {", "+\t\t\t\t\tif (i == startPtr) {", "+\t\t\t\t\t\tthis.completionNode = new CompletionOnJavadocSingleTypeReference(", "+\t\t\t\t\t\t\t\t\tthis.identifierStack[startPtr],", "+\t\t\t\t\t\t\t\t\tthis.identifierPositionStack[startPtr],", "+\t\t\t\t\t\t\t\t\tthis.tagSourceStart,", "+\t\t\t\t\t\t\t\t\tthis.tagSourceEnd);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tchar[][] tokens = new char[i][];", "+\t\t\t\t\t\tSystem.arraycopy(this.identifierStack, startPtr, tokens, 0, i);", "+\t\t\t\t\t\tlong[] positions = new long[i+1];", "+\t\t\t\t\t\tSystem.arraycopy(this.identifierPositionStack, startPtr, positions, 0, i+1);", "+\t\t\t\t\t\tthis.completionNode = new CompletionOnJavadocQualifiedTypeReference(tokens, this.identifierStack[i], positions, this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\t\tbreak;", "-\t\t\t", "-\t\t\t// Copy only tokens necessary for completion", "-\t\t\tchar[][] tokens = new char[size-1][];", "-\t\t\tSystem.arraycopy(this.identifierStack, startPtr, tokens, 0, size-1);", "-\t\t\tlong[] positions = new long[size];", "-\t\t\tSystem.arraycopy(this.identifierPositionStack, startPtr, positions, 0, size);", "-\t\t\tthis.completionNode = new CompletionOnJavadocQualifiedTypeReference(tokens, this.identifierStack[this.identifierPtr], positions, this.tagSourceStart, this.tagSourceEnd);", "+\t\t\tif (this.completionNode == null) {", "+\t\t\t\tchar[][] tokens = new char[nbIdentifiers-1][];", "+\t\t\t\tSystem.arraycopy(this.identifierStack, startPtr, tokens, 0, nbIdentifiers-1);", "+\t\t\t\tlong[] positions = new long[nbIdentifiers];", "+\t\t\t\tSystem.arraycopy(this.identifierPositionStack, startPtr, positions, 0, nbIdentifiers);", "+\t\t\t\tthis.completionNode = new CompletionOnJavadocQualifiedTypeReference(tokens, this.identifierStack[this.identifierPtr], positions, this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac37dc0f7b02b43fe0119eedd0b2d60c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/compiler/tool/EclipseCompiler.java", "commitBeforeChange": "05ca87fa79cdcdbf8adddd11b0044e5bbc381076", "commitAfterChange": "1a08d829c1b17811d102043c26cfbba0a6765570", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 29, "signatureBeforeChange": " \t \t@Override \t@SuppressWarnings(\"unchecked\") \tprotected void setPaths(ArrayList bootclasspaths, \t\t\tString sourcepathClasspathArg, \t\t\tArrayList sourcepathClasspaths, \t\t\tArrayList classpaths, \t\t\tArrayList extdirsClasspaths, \t\t\tArrayList endorsedDirClasspaths, \t\t\tString customEncoding) throws InvalidInputException", "signatureAfterChange": " \t \t@Override \t@SuppressWarnings(\"unchecked\") \tprotected void setPaths(ArrayList bootclasspaths, \t\t\tString sourcepathClasspathArg, \t\t\tArrayList sourcepathClasspaths, \t\t\tArrayList classpaths, \t\t\tArrayList extdirsClasspaths, \t\t\tArrayList endorsedDirClasspaths, \t\t\tString customEncoding) throws InvalidInputException", "diff": ["+\t\tEclipseFileManager javaFileManager = null;", "+\t\tStandardJavaFileManager standardJavaFileManager = null;", "-\t\t\tEclipseFileManager javaFileManager = (EclipseFileManager) this.fileManager;", "+\t\t\tjavaFileManager = (EclipseFileManager) this.fileManager;", "+\t\t}", "+\t\tif (this.fileManager instanceof StandardJavaFileManager) {", "+\t\t\tstandardJavaFileManager = (StandardJavaFileManager) this.fileManager;", "+\t\t}", "+\t\tif (javaFileManager != null) {", "-\t\t\tIterable<? extends File> location = javaFileManager.getLocation(StandardLocation.PLATFORM_CLASS_PATH);", "-\t\t\tif (location != null) {", "-\t\t\t\tfor (File file : location) {", "-\t\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "-\t    \t\t\t\tfile.getAbsolutePath(),", "-\t    \t\t\t\tnull,", "-\t    \t\t\t\tnull));", "-\t\t\t\t}", "+\t\t}", "+\t\tIterable<? extends File> location = null;", "+\t\tif (standardJavaFileManager != null) {", "+\t\t\tlocation = standardJavaFileManager.getLocation(StandardLocation.PLATFORM_CLASS_PATH);", "+\t\t}", "+\t\tif (location != null) {", "+\t\t\tfor (File file : location) {", "+\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "+    \t\t\t\tfile.getAbsolutePath(),", "+    \t\t\t\tnull,", "+    \t\t\t\tnull));", "-\t\t\tif ((javaFileManager.flags & EclipseFileManager.HAS_EXT_DIRS) == 0", "-\t\t\t\t\t&& (javaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {", "-\t\t\t\tfileSystemClasspaths.addAll((ArrayList<? extends FileSystem.Classpath>) this.handleExtdirs(null));", "+\t\t}", "+\t\tif (javaFileManager != null) {", "+    \t\tif ((javaFileManager.flags & EclipseFileManager.HAS_EXT_DIRS) == 0", "+    \t\t\t\t&& (javaFileManager.flags & EclipseFileManager.HAS_BOOTCLASSPATH) != 0) {", "+    \t\t\tfileSystemClasspaths.addAll((ArrayList<? extends FileSystem.Classpath>) this.handleExtdirs(null));", "+    \t\t}", "+\t\t}", "+\t\tif (standardJavaFileManager != null) {", "+\t\t\tlocation = standardJavaFileManager.getLocation(StandardLocation.SOURCE_PATH);", "+\t\t} else {", "+\t\t\tlocation = null;", "+\t\t}", "+\t\tif (location != null) {", "+\t\t\tfor (File file : location) {", "+\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "+    \t\t\t\tfile.getAbsolutePath(),", "+    \t\t\t\tnull,", "+    \t\t\t\tnull));", "-\t\t\tlocation = javaFileManager.getLocation(StandardLocation.SOURCE_PATH);", "-\t\t\tif (location != null) {", "-\t\t\t\tfor (File file : location) {", "-\t\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "-\t    \t\t\t\tfile.getAbsolutePath(),", "-\t    \t\t\t\tnull,", "-\t    \t\t\t\tnull));", "-\t\t\t\t}", "+\t\t}", "+\t\tif (standardJavaFileManager != null) {", "+\t\t\tlocation = standardJavaFileManager.getLocation(StandardLocation.CLASS_PATH);", "+\t\t} else {", "+\t\t\tlocation = null;", "+\t\t}", "+\t\tif (location != null) {", "+\t\t\tfor (File file : location) {", "+\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "+    \t\t\t\tfile.getAbsolutePath(),", "+    \t\t\t\tnull,", "+    \t\t\t\tnull));", "-\t\t\tlocation = javaFileManager.getLocation(StandardLocation.CLASS_PATH);", "-\t\t\tif (location != null) {", "-\t\t\t\tfor (File file : location) {", "-\t\t\t\t\tfileSystemClasspaths.add(FileSystem.getClasspath(", "-\t    \t\t\t\tfile.getAbsolutePath(),", "-\t    \t\t\t\tnull,", "-\t    \t\t\t\tnull));", "-\t\t\t\t}", "-\t\t\t}", "+\t\t}", "+\t\tif (this.checkedClasspaths == null) {", "+\t\t\tfileSystemClasspaths.addAll((ArrayList<? extends FileSystem.Classpath>) this.handleBootclasspath(null, null));", "+\t\t\tfileSystemClasspaths.addAll((ArrayList<? extends FileSystem.Classpath>) this.handleClasspath(null, null));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c391bf28ae77f583ceafcd7d7692f92d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "677a462098c653b539c7de50745a6a31854b50b0", "commitAfterChange": "2c4668c00bd6d1643aa73fe0da8a62f6377994a9", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t\t \tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " \t\t \tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\tif (thrownExceptions != null) {", "-\t\t\tint thrownExceptionsLength = thrownExceptions.length;", "-\t\t\tfor (int i = 0; i < thrownExceptionsLength; i++) {", "-\t\t\t\tmethodDecl.thrownExceptions().add(convert(thrownExceptions[i]));", "-\t\t\t}", "+\t\tint methodHeaderEnd = methodDeclaration.sourceEnd;", "+\t\tint thrownExceptionsLength = thrownExceptions == null ? 0 : thrownExceptions.length;", "+\t\tif (thrownExceptionsLength > 0) {", "+\t\t\tName thrownException;", "+\t\t\tint i = 0;", "+\t\t\tdo {", "+\t\t\t\tthrownException = convert(thrownExceptions[i++]);", "+\t\t\t\tmethodDecl.thrownExceptions().add(thrownException);", "+\t\t\t} while (i < thrownExceptionsLength);", "+\t\t\tmethodHeaderEnd = thrownException.getStartPosition() + thrownException.getLength();", "-\t\tif (parameters != null) {", "-\t\t\tint parametersLength = parameters.length;", "-\t\t\tfor (int i = 0; i < parametersLength; i++) {", "-\t\t\t\tmethodDecl.parameters().add(convert(parameters[i]));", "+\t\tint parametersLength = parameters == null ? 0 : parameters.length;", "+\t\tif (parametersLength > 0) {", "+\t\t\tSingleVariableDeclaration parameter;", "+\t\t\tint i = 0;", "+\t\t\tdo {", "+\t\t\t\tparameter = convert(parameters[i++]);", "+\t\t\t\tmethodDecl.parameters().add(parameter);", "+\t\t\t} while (i < parametersLength);", "+\t\t\tif (thrownExceptionsLength == 0) {", "+\t\t\t\tmethodHeaderEnd = parameter.getStartPosition() + parameter.getLength();", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\tstart = retrieveStartBlockPosition(methodHeaderEnd, methodDeclaration.bodyStart);", "+\t\t\tif (start == -1) start = methodDeclaration.bodyStart; // use recovery position for body start", "+\t\t\tend = retrieveRightBrace(methodDeclaration.bodyEnd, methodDeclaration.declarationSourceEnd);", "-\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\tblock.setSourceRange(start, closingPosition - start + 1);", "-\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tstart = retrieveStartBlockPosition(methodHeaderEnd, declarationSourceEnd);", "+\t\t\t\tif (start == -1) start = methodDeclaration.bodyStart; // use recovery position for body start"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc1a5e5ebbd79aece5cfd438ce1b68e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "b54cdabe5a10342de9a42176e8c205b30ff48884", "commitAfterChange": "90abc6886041c7118f77692a32b3bc09eb1c2c58", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " public static String[] getJavaClassLibs()", "signatureAfterChange": " public static String[] getJavaClassLibs()", "diff": ["+\tif (\"DRLVM\".equals(vmName)) {", "+\t\tFilenameFilter jarFilter = new FilenameFilter() {", "+\t\t\tpublic boolean accept(File dir, String name) {", "+\t\t\t\treturn name.endsWith(\".jar\") & !name.endsWith(\"-src.jar\");", "+\t\t\t}", "+\t\t};", "+\t\tString[] jars = new File(jreDir + \"/lib/boot/\").list(jarFilter);", "+\t\tfor (int i = 0; i < jars.length; i++) {", "+\t\t\tjars[i] = toNativePath(jreDir + \"/lib/boot/\" + jars[i]);", "+\t\t}", "+\t\treturn jars;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd0ed509f2b9a6857ad1e8fb080b7127", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "bb811cafdba11489b23b9c8cd6c46c237bf0db24", "commitAfterChange": "2a64f816a9e1e382be3c6f39875e5c587a7235c0", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " private void readChunk(String[] docNames, DataInputStream stream, int index, int size) throws IOException", "signatureAfterChange": " private void readChunk(String[] docNames, FileInputStream stream, int index, int size) throws IOException", "diff": ["-private void readChunk(String[] docNames, DataInputStream stream, int index, int size) throws IOException {", "-\tString current = stream.readUTF();", "+private void readChunk(String[] docNames, FileInputStream stream, int index, int size) throws IOException {", "+\tString current = new String(readStreamChars(stream));", "-\t\tint start = stream.readUnsignedByte(); // number of identical characters at the beginning", "-\t\tint end = stream.readUnsignedByte(); // number of identical characters at the end", "-\t\tString next = stream.readUTF();", "+\t\tint start = (streamBuffer[this.bufferIndex++]&0xFF);", "+\t\tif (stream != null && this.bufferIndex == BUFFER_READ_SIZE) {", "+\t\t\tthis.bufferIndex = 0;", "+\t\t\tint readSize = this.streamEnd - this.streamPos;", "+\t\t\tthis.streamPos += stream.read(this.streamBuffer, 0, readSize < BUFFER_READ_SIZE ? readSize : BUFFER_READ_SIZE);", "+\t\t}", "+\t\tint end = (streamBuffer[this.bufferIndex++]&0xFF);", "+\t\tif (stream != null && this.bufferIndex == BUFFER_READ_SIZE) {", "+\t\t\tthis.bufferIndex = 0;", "+\t\t\tint readSize = this.streamEnd - this.streamPos;", "+\t\t\tthis.streamPos += stream.read(this.streamBuffer, 0, readSize < BUFFER_READ_SIZE ? readSize : BUFFER_READ_SIZE);", "+\t\t}", "+\t\tString next  = new String(readStreamChars(stream));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed94687ef0627d4da5e983f3df9a6c89", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "9156e33be70429042b1d72217c4197f996fdfb3a", "commitAfterChange": "0bbc1f10f38c090526549c38a7d30ff164b71a76", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public void checkTaskTag(int commentStart, int commentEnd)", "signatureAfterChange": " public void checkTaskTag(int commentStart, int commentEnd)", "diff": ["-\tif (this.taskCount > 0 && this.taskPositions[this.taskCount-1][0] >= commentStart) {", "+\tif (this.foundTaskCount > 0 && this.foundTaskPositions[this.foundTaskCount-1][0] >= commentStart) {", "+\t\tchar[] tag = null;", "+\t\tchar[] priority = null;", "-\t\t\tchar[] tag = this.taskTags[itag];", "+\t\t\ttag = this.taskTags[itag];", "+\t\t\tpriority = ", "+\t\t\t\tthis.taskPriorities != null && itag < this.taskPriorities.length ?", "+\t\t\t\tthis.taskPriorities[itag] :", "+\t\t\t\tnull;", "-\t\tint msgStart = i; // to exlude tag use:   int msgStart = nextPos;", "+\t\tint msgStart = nextPos;", "-\t\twhile (source[msgStart] == ' ' && msgStart <= end) msgStart++;", "-\t\twhile (source[end] == ' ' && start <= end) end--;", "+\t\twhile (CharOperation.isWhitespace(source[msgStart]) && msgStart <= end) msgStart++;", "+\t\twhile (CharOperation.isWhitespace(source[end]) && msgStart <= end) end--;", "-\t\tif (this.taskMessages == null){", "-\t\t\tthis.taskMessages = new char[5][];", "-\t\t\tthis.taskPositions = new int[5][];", "-\t\t} else if (this.taskCount == this.taskMessages.length) {", "-\t\t\tSystem.arraycopy(this.taskMessages, 0, this.taskMessages = new char[this.taskCount*2][], 0, this.taskCount);", "-\t\t\tSystem.arraycopy(this.taskPositions, 0, this.taskPositions = new int[this.taskCount*2][], 0, this.taskCount);", "+\t\tif (this.foundTaskTags == null){", "+\t\t\tthis.foundTaskTags = new char[5][];", "+\t\t\tthis.foundTaskMessages = new char[5][];", "+\t\t\tthis.foundTaskPriorities = new char[5][];", "+\t\t\tthis.foundTaskPositions = new int[5][];", "+\t\t} else if (this.foundTaskCount == this.foundTaskTags.length) {", "+\t\t\tSystem.arraycopy(this.foundTaskTags, 0, this.foundTaskTags = new char[this.foundTaskCount*2][], 0, this.foundTaskCount);", "+\t\t\tSystem.arraycopy(this.foundTaskMessages, 0, this.foundTaskMessages = new char[this.foundTaskCount*2][], 0, this.foundTaskCount);", "+\t\t\tSystem.arraycopy(this.foundTaskPriorities, 0, this.foundTaskPriorities = new char[this.foundTaskCount*2][], 0, this.foundTaskCount);", "+\t\t\tSystem.arraycopy(this.foundTaskPositions, 0, this.foundTaskPositions = new int[this.foundTaskCount*2][], 0, this.foundTaskCount);", "-\t\tthis.taskMessages[this.taskCount] = message;", "-\t\tthis.taskPositions[this.taskCount] = new int[]{ start, end };", "-\t\tthis.taskCount++;", "+\t\tthis.foundTaskTags[this.foundTaskCount] = tag;", "+\t\tthis.foundTaskMessages[this.foundTaskCount] = message;", "+\t\tthis.foundTaskPriorities[this.foundTaskCount] = priority;", "+\t\tthis.foundTaskPositions[this.foundTaskCount] = new int[]{ start, end };", "+\t\tthis.foundTaskCount++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edc7677d3ed76ab6b80fee920dd0c044", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "8e09a020c985a5c59c2f77650ea0c690b64e1566", "commitAfterChange": "ac2c3539b72e65a4a4e0b168769da151e63c5ff1", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprotected Object createSingleNameReference()", "signatureAfterChange": " \tprotected boolean pushParamName()", "diff": ["-\t */", "-\tprotected Object createSingleNameReference() {", "-\t\tJavadocSingleNameReference nameRef = new JavadocSingleNameReference(this.scanner.getCurrentIdentifierSource(),", "-\t\t\t\tthis.scanner.getCurrentTokenStartPosition(),", "-\t\t\t\tthis.scanner.getCurrentTokenEndPosition());", "-\t\tnameRef.tagSourceStart = this.tagSourceStart;", "-\t\tnameRef.tagSourceEnd = this.tagSourceEnd;", "-\t\treturn nameRef;", "-\t}", "+\t */", "+\tprotected boolean pushParamName() {", "+\t\t// Create name reference", "+\t\tJavadocSingleNameReference nameRef = new JavadocSingleNameReference(this.scanner.getCurrentIdentifierSource(),", "+\t\t\t\tthis.scanner.getCurrentTokenStartPosition(),", "+\t\t\t\tthis.scanner.getCurrentTokenEndPosition());", "+\t\tnameRef.tagSourceStart = this.tagSourceStart;", "+\t\tnameRef.tagSourceEnd = this.tagSourceEnd;", "+\t\t// Push ref on stack", "+\t\tif (this.astLengthPtr == -1) { // First push", "+\t\t\tpushOnAstStack(nameRef, true);", "+\t\t} else {", "+\t\t\t// Verify that no @throws has been declared before", "+\t\t\tfor (int i=THROWS_TAG_EXPECTED_ORDER; i<=this.astLengthPtr; i+=ORDERED_TAGS_NUMBER) {", "+\t\t\t\tif (this.astLengthStack[i] != 0) {", "+\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tswitch (this.astLengthPtr % ORDERED_TAGS_NUMBER) {", "+\t\t\t\tcase PARAM_TAG_EXPECTED_ORDER :", "+\t\t\t\t\t// previous push was a @param tag => push another param name", "+\t\t\t\t\tpushOnAstStack(nameRef, false);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase SEE_TAG_EXPECTED_ORDER :", "+\t\t\t\t\t// previous push was a @see tag => push new param name", "+\t\t\t\t\tpushOnAstStack(nameRef, true);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t\treturn true;", "+\t}"]}], "num": 36777}