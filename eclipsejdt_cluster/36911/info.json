{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "52504dc0937ae15bacf2138df96ee031", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7acf6fd71ec9957e5b6b4a850a0e7c19", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/HandleFactory.java", "commitBeforeChange": "e5988aa6fffbfb1b20b8814c4bf08e1213cd12df", "commitAfterChange": "ac79ebad8b588bff5a071f74e9413cce9477383d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString)", "signatureAfterChange": "\r \tprivate IPackageFragmentRoot getJarPkgFragmentRoot(String jarPathString)", "diff": ["+\t\t\r", "-\t\t\t// internal jar\r", "-\t\t\treturn this.javaModel.getJavaProject(jarFile).getPackageFragmentRoot(jarFile);\r", "-\t\t} else {\r", "-\t\t\t// external jar: walk all projects and find the first one that has the given jar path in its classpath\r", "-\t\t\tIProject[] projects= this.workspace.getRoot().getProjects();\r", "-\t\t\tfor (int i= 0, projectCount= projects.length; i < projectCount; i++) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIProject project = projects[i];\r", "-\t\t\t\t\tif (!project.isAccessible() \r", "-\t\t\t\t\t\t|| !project.hasNature(JavaCore.NATURE_ID)) continue;\r", "-\t\t\t\t\tJavaProject javaProject= (JavaProject)this.javaModel.getJavaProject(project);\r", "-\t\t\t\t\tIClasspathEntry[] classpathEntries= javaProject.getResolvedClasspath(true);\r", "-\t\t\t\t\tfor (int j= 0, entryCount= classpathEntries.length; j < entryCount; j++) {\r", "-\t\t\t\t\t\tif (classpathEntries[j].getPath().equals(jarPath)) {\r", "+\t\t\t// internal jar: is it on the classpath of its project?\r", "+\t\t\t//  e.g. org.eclipse.swt.win32/ws/win32/swt.jar \r", "+\t\t\t//        is NOT on the classpath of org.eclipse.swt.win32\r", "+\t\t\tIJavaProject javaProject = this.javaModel.getJavaProject(jarFile);\r", "+\t\t\tIClasspathEntry[] classpathEntries;\r", "+\t\t\ttry {\r", "+\t\t\t\tclasspathEntries = javaProject.getResolvedClasspath(true);\r", "+\t\t\t\tfor (int j= 0, entryCount= classpathEntries.length; j < entryCount; j++) {\r", "+\t\t\t\t\tif (classpathEntries[j].getPath().equals(jarPath)) {\r", "+\t\t\t\t\t\treturn javaProject.getPackageFragmentRoot(jarFile);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t// ignore and try to find another project\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r", "+\t\t// walk all projects and find the first one that has the given jar path in its classpath\r", "+\t\tIJavaProject[] projects;\r", "+\t\ttry {\r", "+\t\t\tprojects = this.javaModel.getJavaProjects();\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// java model is not accessible\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\t\tfor (int i= 0, projectCount= projects.length; i < projectCount; i++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tJavaProject javaProject= (JavaProject)projects[i];\r", "+\t\t\t\tIClasspathEntry[] classpathEntries= javaProject.getResolvedClasspath(true);\r", "+\t\t\t\tfor (int j= 0, entryCount= classpathEntries.length; j < entryCount; j++) {\r", "+\t\t\t\t\tif (classpathEntries[j].getPath().equals(jarPath)) {\r", "+\t\t\t\t\t\tif (jarFile != null) {\r", "+\t\t\t\t\t\t\t// internal jar\r", "+\t\t\t\t\t\t\treturn javaProject.getPackageFragmentRoot(jarFile);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t// external jar\r", "-\t\t\t\t} catch (CoreException e) {\r", "-\t\t\t\t\t// CoreException from hasNature - should not happen since we check that the project is accessible\r", "-\t\t\t\t\t// JavaModelException from getResolvedClasspath - a problem occured while accessing project: nothing we can do, ignore\r", "+\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t// JavaModelException from getResolvedClasspath - a problem occured while accessing project: nothing we can do, ignore\r", "-\t\t\treturn null;\r", "+\t\treturn null;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e039f3a43d9f8c8adb2558d5a1775b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "0b147b41fd14622e58b9abe70d023e6b22dcfbf7", "commitAfterChange": "224ac51338df376ffd0a9a55fd7c92d9e76b9040", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "signatureAfterChange": "\r \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "diff": ["-\t\tICompilationUnit[] compilationUnits= null;\r", "+\t\tICompilationUnit[] compilationUnits = null;\r", "-\t\t\tcompilationUnits= pkg.getCompilationUnits();\r", "+\t\t\tcompilationUnits = pkg.getCompilationUnits();\r", "-\t\tString matchName= name;\r", "+\t\tString matchName = name;\r", "-\t\tboolean memberType= false;\r", "+\t\tboolean potentialMemberType = false;\r", "+\t\tString potentialMatchName = null;\r", "-\t\t\tmatchName= name.substring(0, index);\r", "-\t\t\tmemberType= true;\r", "+\t\t\tpotentialMatchName = name.substring(0, index);\r", "+\t\t\tpotentialMemberType = true;\r", "-\t\tString unitName= partialMatch ? matchName.toLowerCase() : matchName + \".java\"; //$NON-NLS-1$\r", "+\t\tString unitName = partialMatch ? matchName.toLowerCase() : matchName + \".java\"; //$NON-NLS-1$\r", "+\t\tString potentialUnitName = null;\r", "+\t\tif (potentialMemberType) {\r", "+\t\t\tpotentialUnitName = partialMatch ? potentialMatchName.toLowerCase() : potentialMatchName + \".java\"; //$NON-NLS-1$\r", "+\t\t}\r", "-\t\t\t\t\tif (nameMatches(matchName, type, partialMatch))\r", "-\t\t\t\t\t\tif (!memberType) {\r", "-\t\t\t\t\t\t\tif (acceptType(type, acceptFlags)) requestor.acceptType(type);\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tseekQualifiedMemberTypes(name.substring(index + 1, name.length()), type, partialMatch, requestor, acceptFlags);\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\t\tif (nameMatches(matchName, type, partialMatch)) {\r", "+\t\t\t\t\t\tif (acceptType(type, acceptFlags)) requestor.acceptType(type);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} else \tif (potentialMemberType && nameMatches(potentialUnitName, compilationUnit, partialMatch)) {\r", "+\t\t\t\tIType[] types= null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\ttypes= compilationUnit.getTypes();\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\tcontinue; // the compilation unit is not present\r", "+\t\t\t\t}\r", "+\t\t\t\tint typeLength= types.length;\r", "+\t\t\t\tfor (int j= 0; j < typeLength; j++) {\r", "+\t\t\t\t\tif (requestor.isCanceled())\r", "+\t\t\t\t\t\treturn;\r", "+\t\t\t\t\tIType type= types[j];\r", "+\t\t\t\t\tif (nameMatches(potentialMatchName, type, partialMatch)) {\r", "+\t\t\t\t\t\tseekQualifiedMemberTypes(name.substring(index + 1, name.length()), type, partialMatch, requestor, acceptFlags);\r", "+\t\t\t\t\t}\r", "+\r"]}], "num": 36911}