{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "52631c9befc381d7ebfcb887c450effc", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a0e7a67ff456b39855234f09bb5a1f0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java", "commitBeforeChange": "b944419a775a8766a80aaf50d5c9201201448e38", "commitAfterChange": "66a68a77c79dc8161adf91226d8f791e46bc037a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// due to syntax lhs may be only a NameReference, a FieldReference or an ArrayReference", "+\tthis.constant = Constant.NotAConstant;", "+\tif (!(this.lhs instanceof Reference) || this.lhs.isThis()) {", "+\t\tscope.problemReporter().expressionShouldBeAVariable(this.lhs);", "+\tTypeBinding lhsType = lhs.resolveType(scope);", "+\tthis.expression.setExpectedType(lhsType); // needed in case of generic method invocation", "+\tif (lhsType != null) ", "+\t\tthis.resolvedType = lhsType.capture(scope, this.sourceEnd);", "+\tTypeBinding rhsType = this.expression.resolveType(scope);", "+\tif (lhsType == null || rhsType == null) {", "+\t\treturn null;", "+\t// check for assignment with no effect", "+\tBinding left = getDirectBinding(this.lhs);", "+\tif (left != null && left == getDirectBinding(this.expression)) {", "+\t\tscope.problemReporter().assignmentHasNoEffect(this, left.shortReadableName());", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\t// due to syntax lhs may be only a NameReference, a FieldReference or an ArrayReference", "-\t\tthis.constant = Constant.NotAConstant;", "-\t\tif (!(this.lhs instanceof Reference) || this.lhs.isThis()) {", "-\t\t\tscope.problemReporter().expressionShouldBeAVariable(this.lhs);", "-\t\t\treturn null;", "-\t\t}", "-\t\tTypeBinding lhsType = lhs.resolveType(scope);", "-\t\tthis.expression.setExpectedType(lhsType); // needed in case of generic method invocation", "-\t\tif (lhsType != null) ", "-\t\t\tthis.resolvedType = lhsType.capture(scope, this.sourceEnd);", "-\t\tTypeBinding rhsType = this.expression.resolveType(scope);", "-\t\tif (lhsType == null || rhsType == null) {", "-\t\t\treturn null;", "-\t\t}", "-\t\tcheckAssignmentEffect(scope);", "-", "-\t\t// Compile-time conversion of base-types : implicit narrowing integer into byte/short/character", "-\t\t// may require to widen the rhs expression at runtime", "-\t\tif (lhsType != rhsType) // must call before computeConversion() and typeMismatchError()", "-\t\t\tscope.compilationUnitScope().recordTypeConversion(lhsType, rhsType);", "-\t\tif ((this.expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "-\t\t\t\t|| (lhsType.isBaseType() && BaseTypeBinding.isWidening(lhsType.id, rhsType.id)))", "-\t\t\t\t|| rhsType.isCompatibleWith(lhsType)) {", "-\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\t\tcheckAssignment(scope, lhsType, rhsType);", "-\t\t\tif (this.expression instanceof CastExpression ", "-\t\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "-\t\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType) ", "-\t\t\t\t\t\t\t|| (rhsType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t\t&& !lhsType.isBaseType()", "-\t\t\t\t\t\t\t\t\t&& this.expression.isConstantValueOfTypeAssignableToType(rhsType, scope.environment().computeBoxingType(lhsType)))) {", "-\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\t\tif (this.expression instanceof CastExpression ", "-\t\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "-\t\t} ", "-\t\tscope.problemReporter().typeMismatchError(rhsType, lhsType, this.expression);", "-\t\treturn lhsType;", "-\t}", "+\t// Compile-time conversion of base-types : implicit narrowing integer into byte/short/character", "+\t// may require to widen the rhs expression at runtime", "+\tif (lhsType != rhsType) // must call before computeConversion() and typeMismatchError()", "+\t\tscope.compilationUnitScope().recordTypeConversion(lhsType, rhsType);", "+\tif ((this.expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "+\t\t\t|| (lhsType.isBaseType() && BaseTypeBinding.isWidening(lhsType.id, rhsType.id)))", "+\t\t\t|| rhsType.isCompatibleWith(lhsType)) {", "+\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "+\t\tif (this.expression instanceof CastExpression ", "+\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "+\t\t}\t\t\t", "+\t\treturn this.resolvedType;", "+\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType) ", "+\t\t\t\t\t\t|| (rhsType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t\t&& !lhsType.isBaseType()", "+\t\t\t\t\t\t\t\t&& this.expression.isConstantValueOfTypeAssignableToType(rhsType, scope.environment().computeBoxingType(lhsType)))) {", "+\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "+\t\tif (this.expression instanceof CastExpression ", "+\t\t\t\t&& (this.expression.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\tCastExpression.checkNeedForAssignedCast(scope, lhsType, (CastExpression) this.expression);", "+\t\t}\t\t\t", "+\t\treturn this.resolvedType;", "+\t} ", "+\tscope.problemReporter().typeMismatchError(rhsType, lhsType, this.expression);", "+\treturn lhsType;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ec057077864e0736d5e03b1f9a2d971", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// compute a new constant if the cast is effective", "+", "+\t// due to the fact an expression may start with ( and that a cast can also start with (", "+\t// the field is an expression....it can be a TypeReference OR a NameReference Or", "+\t// any kind of Expression <-- this last one is invalid.......", "+", "+\tthis.constant = Constant.NotAConstant;", "+\tthis.implicitConversion = TypeIds.T_undefined;", "+", "+\tif ((this.type instanceof TypeReference) || (this.type instanceof NameReference)", "+\t\t\t&& ((this.type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp", "+", "+\t\tboolean exprContainCast = false;", "+\t\t", "+\t\tTypeBinding castType = this.resolvedType = this.type.resolveType(scope);", "+\t\t//expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation\t\t\t", "+\t\tif (this.expression instanceof CastExpression) {", "+\t\t\tthis.expression.bits |= ASTNode.DisableUnnecessaryCastCheck;", "+\t\t\texprContainCast = true;", "-", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// compute a new constant if the cast is effective", "-", "-\t\t// due to the fact an expression may start with ( and that a cast can also start with (", "-\t\t// the field is an expression....it can be a TypeReference OR a NameReference Or", "-\t\t// any kind of Expression <-- this last one is invalid.......", "-", "-\t\tconstant = Constant.NotAConstant;", "-\t\timplicitConversion = T_undefined;", "-", "-\t\tif ((type instanceof TypeReference) || (type instanceof NameReference)", "-\t\t\t\t&& ((type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp", "-", "-\t\t\tTypeBinding castType = this.resolvedType = type.resolveType(scope);", "-\t\t\t//expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation\t\t\t", "-\t\t\tTypeBinding expressionType = expression.resolveType(scope);", "-\t\t\tif (castType != null) {", "-\t\t\t\tif (expressionType != null) {", "-\t\t\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "-\t\t\t\t\tif (isLegal) {", "-\t\t\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "-\t\t\t\t\t\tif ((this.bits & UnsafeCast) != 0) { // unsafe cast", "-\t\t\t\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "-\t\t\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);\t\t\t", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif ((this.bits & (UnnecessaryCast|DisableUnnecessaryCastCheck)) == UnnecessaryCast) { // unnecessary cast ", "-\t\t\t\t\t\t\t\tif (!isIndirectlyUsed()) // used for generic type inference or boxing ?", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().unnecessaryCast(this);", "-\t\t\t\t\t\t\t}", "+\t\tTypeBinding expressionType = this.expression.resolveType(scope);", "+\t\tif (castType != null) {", "+\t\t\tif (expressionType != null) {", "+\t\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "+\t\t\t\tif (isLegal) {", "+\t\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "+\t\t\t\t\tif ((this.bits & ASTNode.UnsafeCast) != 0) { // unsafe cast", "+\t\t\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "+\t\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);\t\t\t", "-\t\t\t\t\t} else { // illegal cast", "-\t\t\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "-\t\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\t\t\tif ((this.bits & (ASTNode.UnnecessaryCast|ASTNode.DisableUnnecessaryCastCheck)) == ASTNode.UnnecessaryCast) { // unnecessary cast ", "+\t\t\t\t\t\t\tif (!isIndirectlyUsed()) // used for generic type inference or boxing ?", "+\t\t\t\t\t\t\t\tscope.problemReporter().unnecessaryCast(this);", "-\t\t\t\t\t\tthis.bits |= DisableUnnecessaryCastCheck; // disable further secondary diagnosis", "+\t\t\t\t} else { // illegal cast", "+\t\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "+\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.bits |= ASTNode.DisableUnnecessaryCastCheck; // disable further secondary diagnosis", "-\t\t\t\tthis.resolvedType = castType.capture(scope, this.sourceEnd);", "-\t\t\treturn this.resolvedType;", "-\t\t} else { // expression as a cast", "-\t\t\tTypeBinding expressionType = expression.resolveType(scope);", "-\t\t\tif (expressionType == null) return null;", "-\t\t\tscope.problemReporter().invalidTypeReference(type);", "-\t\t\treturn null;", "-\t\t}", "-\t}", "+\t\t\tthis.resolvedType = castType.capture(scope, this.sourceEnd);", "+\t\t\tif (exprContainCast) {", "+\t\t\t\tcheckNeedForCastCast(scope, this);", "+\t\treturn this.resolvedType;", "+\t} else { // expression as a cast", "+\t\tTypeBinding expressionType = this.expression.resolveType(scope);", "+\t\tif (expressionType == null) return null;", "+\t\tscope.problemReporter().invalidTypeReference(this.type);", "+\t\treturn null;", "+}"]}], "num": 16755}