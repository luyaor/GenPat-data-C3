{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "48efb23b55b40c12c8912ac1eb1441bd", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27c0425ef71e204dde917738f9054ef7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\t */", "-\tpublic void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {", "-\t", "-\t\tint pc = codeStream.position;", "-\t\tboolean needRuntimeCheckcast = (this.bits & GenerateCheckcast) != 0;", "-\t\tif (constant != Constant.NotAConstant) {", "-\t\t\tif (valueRequired || needRuntimeCheckcast) { // Added for: 1F1W9IG: IVJCOM:WINNT - Compiler omits casting check", "-\t\t\t\tcodeStream.generateConstant(constant, implicitConversion);", "-\t\t\t\tif (needRuntimeCheckcast) {", "-\t\t\t\t\tcodeStream.checkcast(this.resolvedType);", "-\t\t\t\tif (!valueRequired) {", "-\t\t\t\t\t// the resolveType cannot be double or long", "-\t\t\t\t\tcodeStream.pop();", "-\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t\t\treturn;", "-\t\t}", "-\t\texpression.generateCode(currentScope, codeStream, valueRequired || needRuntimeCheckcast);", "-\t\tif (needRuntimeCheckcast && this.expression.postConversionType(currentScope) != this.resolvedType.erasure()) { // no need to issue a checkcast if already done as genericCast", "-\t\t\tcodeStream.checkcast(this.resolvedType);", "-\t\t}", "-\t\tif (valueRequired) {", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t} else if (needRuntimeCheckcast) {", "-\t\t\tcodeStream.pop();", "+ */", "+public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {", "+\tint pc = codeStream.position;", "+\tboolean needRuntimeCheckcast = (this.bits & ASTNode.GenerateCheckcast) != 0;", "+\tif (this.constant != Constant.NotAConstant) {", "+\t\tif (valueRequired || needRuntimeCheckcast) { // Added for: 1F1W9IG: IVJCOM:WINNT - Compiler omits casting check", "+\t\t\tcodeStream.generateConstant(this.constant, this.implicitConversion);", "+\t\t\tif (needRuntimeCheckcast) {", "+\t\t\t\tcodeStream.checkcast(this.resolvedType);", "+\t\t\t}", "+\t\t\tif (!valueRequired) {", "+\t\t\t\t// the resolveType cannot be double or long", "+\t\t\t\tcodeStream.pop();", "+\t\t\t}", "+\t\treturn;", "+\tthis.expression.generateCode(currentScope, codeStream, valueRequired || needRuntimeCheckcast);", "+\tif (needRuntimeCheckcast && this.expression.postConversionType(currentScope) != this.resolvedType.erasure()) { // no need to issue a checkcast if already done as genericCast", "+\t\tcodeStream.checkcast(this.resolvedType);", "+\t}", "+\tif (valueRequired) {", "+\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t} else if (needRuntimeCheckcast) {", "+\t\tcodeStream.pop();", "+\t}", "+\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e32f206d68e5e429afab896b6196d7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "   \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "   public TypeBinding resolveType(BlockScope scope)", "diff": ["-", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\tconstant = Constant.NotAConstant;", "-\t\tif (receiver instanceof CastExpression\t// no cast check for ((type[])null)[0]", "-\t\t\t\t&& ((CastExpression)receiver).innermostCastedExpression() instanceof NullLiteral) {", "-\t\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t}\t\t", "-\t\tTypeBinding arrayType = receiver.resolveType(scope);", "-\t\tif (arrayType != null) {", "-\t\t\treceiver.computeConversion(scope, arrayType, arrayType);", "-\t\t\tif (arrayType.isArrayType()) {", "-\t\t\t\tTypeBinding elementType = ((ArrayBinding) arrayType).elementsType();", "-\t\t\t\tthis.resolvedType = ((this.bits & IsStrictlyAssigned) == 0) ? elementType.capture(scope, this.sourceEnd) : elementType;", "-\t\t\t} else {", "-\t\t\t\tscope.problemReporter().referenceMustBeArrayTypeAt(arrayType, this);", "-\t\t\t}", "+public TypeBinding resolveType(BlockScope scope) {", "+\tthis.constant = Constant.NotAConstant;", "+\tif (this.receiver instanceof CastExpression\t// no cast check for ((type[])null)[0]", "+\t\t\t&& ((CastExpression)this.receiver).innermostCastedExpression() instanceof NullLiteral) {", "+\t\tthis.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\t}\t\t", "+\tTypeBinding arrayType = this.receiver.resolveType(scope);", "+\tif (arrayType != null) {", "+\t\tthis.receiver.computeConversion(scope, arrayType, arrayType);", "+\t\tif (arrayType.isArrayType()) {", "+\t\t\tTypeBinding elementType = ((ArrayBinding) arrayType).elementsType();", "+\t\t\tthis.resolvedType = ((this.bits & ASTNode.IsStrictlyAssigned) == 0) ? elementType.capture(scope, this.sourceEnd) : elementType;", "+\t\t} else {", "+\t\t\tscope.problemReporter().referenceMustBeArrayTypeAt(arrayType, this);", "-\t\tTypeBinding positionType = position.resolveTypeExpecting(scope, TypeBinding.INT);", "-\t\tif (positionType != null) {", "-\t\t\tposition.computeConversion(scope, TypeBinding.INT, positionType);", "-\t\t}", "-\t\treturn this.resolvedType;", "+\tTypeBinding positionType = this.position.resolveTypeExpecting(scope, TypeBinding.INT);", "+\tif (positionType != null) {", "+\t\tthis.position.computeConversion(scope, TypeBinding.INT, positionType);", "+\treturn this.resolvedType;", "+}"]}], "num": 47337}