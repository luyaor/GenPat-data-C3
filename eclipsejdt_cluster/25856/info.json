{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "308011ec2419c6cf2bab5020f81327a4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4bc00452fd180ce5a0ec33082f5b907", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "ba27b8beba862586d02454473338bb69e72c4fad", "commitAfterChange": "424434f0bc8f5f118b22e054c33acbc180d3cbd4", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "diff": ["-\t\t//boolean relyOnDefaultAbstractMethods = environment().options.targetJDK < CompilerOptions.JDK1_2;\r", "+\r", "+\t\t// superclass lookup\r", "+\t\tboolean hierarchyContainsAbstractClasses = false;\r", "+\t\tReferenceBinding classHierarchyStart = currentType;\r", "+\t\t\r", "-\r", "-\t\t\t//if (!relyOnDefaultAbstractMethods && currentType.isAbstract())\r", "-\t\t\tif (currentType.isAbstract())\r", "-\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\tif (currentType.isAbstract()) hierarchyContainsAbstractClasses = true;\r", "+\t\t}\r", "+\r", "+\t\t// abstract superclass superinterface lookup (since maybe missing default\r", "+\t\t// abstract methods)\r", "+\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\tcurrentType = classHierarchyStart;\r", "+\t\t\twhile (currentType != null){\r", "+\t\t\t\tif (currentType.isAbstract()){\r", "+\t\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\t\t}\r", "+\t\t\t\tcurrentType = currentType.superclass();\r", "+\t\t\t}\r", "-\t\tMethodBinding[] compatible = new MethodBinding[foundSize];\r", "-\t\tint compatibleIndex = 0;\r", "+\t\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\t\tint candidatesCount = 0;\r", "+\r", "+\t\t// argument type compatibility check\r", "-\t\t\t\tcompatible[compatibleIndex++] = methodBinding;\r", "+\t\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "-\t\tif (compatibleIndex == 1)\r", "-\t\t\treturn compatible[0]; // have not checked visibility\r", "-\t\tif (compatibleIndex == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\tif (candidatesCount == 1)\r", "+\t\t\treturn candidates[0]; // have not checked visibility\r", "+\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "-\t\tMethodBinding[] visible = new MethodBinding[compatibleIndex];\r", "-\t\tint visibleIndex = 0;\r", "-\t\tfor (int i = 0; i < compatibleIndex; i++) {\r", "-\t\t\tMethodBinding methodBinding = compatible[i];\r", "-\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this))\r", "-\t\t\t\tvisible[visibleIndex++] = methodBinding;\r", "+\t\t// visibility check\r", "+\t\tint visiblesCount = 0;\r", "+\t\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {\r", "+\t\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t\t}\r", "+\t\t\t\tvisiblesCount++;\r", "+\t\t\t}\r", "-\t\tif (visibleIndex == 1) {\r", "-\t\t\tcompilationUnitScope().recordTypeReferences(visible[0].thrownExceptions);\r", "-\t\t\treturn visible[0];\r", "+\t\tif (visiblesCount == 1) {\r", "+\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\t\treturn candidates[0];\r", "-\t\tif (visibleIndex == 0)\r", "+\t\tif (visiblesCount == 0)\r", "-\t\t\t\tcompatible[0].selector,\r", "+\t\t\t\tcandidates[0].selector,\r", "-\t\t\t\tcompatible[0].declaringClass,\r", "+\t\t\t\tcandidates[0].declaringClass,\r", "-\t\tif (visible[0].declaringClass.isClass())\r", "-\t\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);\r", "-\t\telse\r", "-\t\t\treturn mostSpecificInterfaceMethodBinding(visible, visibleIndex);\r", "+\t\t\t\t\r", "+\t\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t\t} else {\r", "+\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e83eb2b3d67222af7d148f3a3eb6a2d8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java", "commitBeforeChange": "c4c0df5e4aeb7d3e8571312c597020a7d0812327", "commitAfterChange": "6fea7eafdd413dccff31028f8da1f1ac6859e6fe", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "signatureAfterChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "diff": ["-    \tIPath workspaceRootPath = jproj.getProject().getWorkspace().getRoot().getLocation();", "+    \tIWorkspaceRoot root = jproj.getProject().getWorkspace().getRoot();", "-\t    \t\t\tclasspathSB.append(entry.getPath().makeAbsolute().toOSString());", "+\t    \t\t\tIPath cpPath = entry.getPath();", "+\t    \t\t\t", "+\t    \t\t\tIResource res = root.findMember(cpPath);", "+\t    \t\t\t", "+\t    \t\t\t// If res is null, the path is absolute (it's an external jar)", "+\t    \t\t\tif (res == null) {", "+\t    \t\t\t\tclasspathSB.append(cpPath.toOSString());", "+\t    \t\t\t}", "+\t    \t\t\telse {", "+\t    \t\t\t\t// It's relative", "+\t    \t\t\t\tclasspathSB.append(res.getLocation().toOSString());", "+\t    \t\t\t}", "-    \t\t\t\t\tsourcepathSB.append(File.separatorChar);", "+    \t\t\t\t\tsourcepathSB.append(File.pathSeparatorChar);", "-    \t\t\t\t// Sourcepath is a bit odd -- it's workspace-relative", "-    \t\t\t\tIPath sourcepath = entry.getPath();", "-    \t\t\t\tsourcepathSB.append(workspaceRootPath.append(sourcepath).toOSString());", "+    \t\t\t\t", "+    \t\t\t\tsourcepathSB.append(root.findMember(entry.getPath()).getLocation().toOSString());", "-    \t\toptions.put(\"-classpath\",classpathSB.toString()); //$NON-NLS-1$", "+    \t\toptions.put(\"-classpath\",classpathSB.toString()); //$NON-NLS-1$    \t\t", "-    \t\toptions.put(\"-s\", genSrcDir.getRawLocation().toOSString()); //$NON-NLS-1$", "+    \t\tString genSrcDirString = genSrcDir.getRawLocation().toOSString();", "+    \t\toptions.put(\"-s\", genSrcDirString); //$NON-NLS-1$", "-    \t\tIPath binDir = workspaceRootPath.append(binPath);", "-    \t\toptions.put(\"-d\", binDir.toOSString()); //$NON-NLS-1$", "+    \t\tIResource binPathResource = root.findMember(binPath);", "+    \t\tString binDirString;", "+    \t\tif (binPathResource != null) {", "+    \t\t\tbinDirString = root.findMember(binPath).getLocation().toOSString();", "+    \t\t}", "+    \t\telse {", "+    \t\t\tbinDirString = binPath.toOSString();", "+    \t\t}", "+    \t\toptions.put(\"-d\", binDirString); //$NON-NLS-1$"]}], "num": 25856}