{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e8b81f27144f4e2470f1b701bdfaf4d5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35d10583a0727711ff407b84e3102c80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "08a2bb4b18c0c69c0ed4f816cadfd40ebe8abddb", "commitAfterChange": "d0e5b2ab614e06e582b08c94edd4cb759a159eaf", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "signatureAfterChange": "\r protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags)", "diff": ["-\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "-\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "-\t\tfalse);\r", "-\t// iterate type lookup in each package fragment\r", "-\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "-\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "-\t\tif (type != null) break;\t\r", "-\t}\r", "-\tif (type == null) {\r", "-\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\t\tif (packageName != null) {\r", "-\t\t\tpName = new String(packageName);\r", "-\t\t}\r", "-\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "-\t\t\t// look inside the type in which we are resolving in\r", "-\t\t\tString tName= new String(typeName);\r", "-\t\t\ttName = tName.replace('.','$');\r", "-\t\t\tIType[] allTypes= null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "-\t\t\t\tallTypes = new IType[v.size()];\r", "-\t\t\t\tv.copyInto(allTypes);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\treturn null;\r", "+\t\r", "+\tif (fCodeResolve instanceof WorkingCopy) {\r", "+\t\tWorkingCopy wc = (WorkingCopy) fCodeResolve;\r", "+\t\ttry {\r", "+\t\t\tif(((packageName == null || packageName.length == 0) && wc.getPackageDeclarations().length == 0) ||\r", "+\t\t\t\t(!(packageName == null || packageName.length == 0) && wc.getPackageDeclaration(new String(packageName)).exists())) {\r", "+\t\t\t\t\t\r", "+\t\t\t\ttype = wc.getType(new String(typeName));\r", "+\t\t\t\tif(!type.exists()) {\r", "+\t\t\t\t\ttype = null;\r", "+\t\t\t\t}\r", "-\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "-\t\t\t\t\treturn allTypes[i];\r", "+\t\t}catch (JavaModelException e) {\r", "+\t\t\ttype = null;", "+\t\t}\r", "+\t}\r", "+\r", "+\tif(type == null) {\r", "+\t\tIPackageFragment[] pkgs = fNameLookup.findPackageFragments(\r", "+\t\t\t(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), \r", "+\t\t\tfalse);\r", "+\t\t// iterate type lookup in each package fragment\r", "+\t\tfor (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {\r", "+\t\t\ttype= fNameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);\r", "+\t\t\tif (type != null) break;\t\r", "+\t\t}\r", "+\t\tif (type == null) {\r", "+\t\t\tString pName= IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\t\tif (packageName != null) {\r", "+\t\t\t\tpName = new String(packageName);\r", "+\t\t\t}\r", "+\t\t\tif (fCodeResolve != null && fCodeResolve.getParent().getElementName().equals(pName)) {\r", "+\t\t\t\t// look inside the type in which we are resolving in\r", "+\t\t\t\tString tName= new String(typeName);\r", "+\t\t\t\ttName = tName.replace('.','$');\r", "+\t\t\t\tIType[] allTypes= null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjava.util.Vector v = ((JavaElement)fCodeResolve).getChildrenOfType(IJavaElement.TYPE);\r", "+\t\t\t\t\tallTypes = new IType[v.size()];\r", "+\t\t\t\t\tv.copyInto(allTypes);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\tif (allTypes[i].getTypeQualifiedName().equals(tName)) {\r", "+\t\t\t\t\t\treturn allTypes[i];\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6eca3bb9be6da40b4618cdf7622c431b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "7fdd30796329ce26e7f870767adb170e365b96ed", "commitAfterChange": "5d8cf65e1df5f9eb0a074e2096650fc374a7dd1f", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": " protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customEncoding) throws InvalidInputException", "signatureAfterChange": " protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customEncoding) throws InvalidInputException", "diff": ["-\t \tfinal File javaHome = getJavaHome();", "-\t \t * Handle >= JDK 1.2.2 settings: retrieve rt.jar", "+\t \t * Handle >= JDK 1.2.2 settings: retrieve the bootclasspath", "-\t \t if (javaHome != null) {", "-\t\t\tFile[] directoriesToCheck = null;", "-\t\t\tif (System.getProperty(\"os.name\").startsWith(\"Mac\")) {//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\tdirectoriesToCheck = new File[] {", "-\t\t\t\t\tnew File(javaHome, \"../Classes\"), //$NON-NLS-1$", "-\t\t\t\t};", "-\t\t\t} else {", "-\t\t\t\tdirectoriesToCheck = new File[] {", "-\t\t\t\t\tnew File(javaHome, \"lib\") //$NON-NLS-1$", "-\t\t\t\t};", "+\t\t// check bootclasspath properties for Sun, JRockit and Harmony VMs", "+\t\tString bootclasspathProperty = System.getProperty(\"sun.boot.class.path\"); //$NON-NLS-1$", "+\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t// IBM J9 VMs", "+\t\t\tbootclasspathProperty = System.getProperty(\"vm.boot.class.path\"); //$NON-NLS-1$", "+\t\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t\t// Harmony using IBM VME", "+\t\t\t\tbootclasspathProperty = System.getProperty(\"org.apache.harmony.boot.class.path\"); //$NON-NLS-1$", "-\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "-\t\t\tif (systemLibrariesJars != null) {", "-\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "-\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "-\t\t\t\t\tif (current != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\t\tFileSystem.Classpath classpath =", "-\t\t\t\t\t\t\t\tFileSystem.getClasspath(current[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\tnull, false, null, null);", "-\t\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "+\t\t}", "+\t\tif ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {", "+\t\t\tStringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);", "+\t\t\tString token;", "+\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "+\t\t\t\t\t\t.getClasspath(token, customEncoding, null);", "+\t\t\t\tif (currentClasspath != null) {", "+\t\t\t\t\tbootclasspaths.add(currentClasspath);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// try to get all jars inside the lib folder of the java home", "+\t\t\tfinal File javaHome = getJavaHome();", "+\t\t\tif (javaHome != null) {", "+\t\t\t\tFile[] directoriesToCheck = null;", "+\t\t\t\tif (System.getProperty(\"os.name\").startsWith(\"Mac\")) {//$NON-NLS-1$//$NON-NLS-2$", "+\t\t\t\t\tdirectoriesToCheck = new File[] {", "+\t\t\t\t\t\tnew File(javaHome, \"../Classes\"), //$NON-NLS-1$", "+\t\t\t\t\t};", "+\t\t\t\t} else {", "+\t\t\t\t\t// fall back to try to retrieve them out of the lib directory", "+\t\t\t\t\tdirectoriesToCheck = new File[] {", "+\t\t\t\t\t\tnew File(javaHome, \"lib\") //$NON-NLS-1$", "+\t\t\t\t\t};", "+\t\t\t\t}", "+\t\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "+\t\t\t\tif (systemLibrariesJars != null) {", "+\t\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "+\t\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "+\t\t\t\t\t\tif (current != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tFileSystem.Classpath classpath =", "+\t\t\t\t\t\t\t\t\tFileSystem.getClasspath(current[j].getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\t\tnull, false, null, null);", "+\t\t\t\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "+\t\t\t\t\t\t\t\t}", "- \t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7fd2bc9ec04f38ee3e7bdea32eac0e16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "5d61afa709802d331d230880f37fe526cefe25cb", "commitAfterChange": "611f47e73b2ec0045eb75d60dad86eed58ebb09d", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " public static String[] getJavaClassLibs()", "signatureAfterChange": " public static String[] getJavaClassLibs()", "diff": ["-    String jreDir = getJREDirectory();", "-    final String osName = System.getProperty(\"os.name\");", "-    if (jreDir == null) {", "-        return new String[] {};", "-    }", "-    if (osName.startsWith(\"Mac\")) {", "-        return new String[] {", "-            toNativePath(jreDir + \"/../Classes/classes.jar\")", "-        };", "-    }", "-    final String vmName = System.getProperty(\"java.vm.name\");", "-    if (\"J9\".equals(vmName)) {", "-        return new String[] {", "-            toNativePath(jreDir + \"/lib/jclMax/classes.zip\")", "-        };", "-    }", "-\tif (\"DRLVM\".equals(vmName)) {", "-\t\tFilenameFilter jarFilter = new FilenameFilter() {", "-\t\t\tpublic boolean accept(File dir, String name) {", "-\t\t\t\treturn name.endsWith(\".jar\") & !name.endsWith(\"-src.jar\");", "-\t\t\t}", "-\t\t};", "-\t\tString[] jars = new File(jreDir + \"/lib/boot/\").list(jarFilter);", "-\t\tfor (int i = 0; i < jars.length; i++) {", "-\t\t\tjars[i] = toNativePath(jreDir + \"/lib/boot/\" + jars[i]);", "+\t// check bootclasspath properties for Sun, JRockit and Harmony VMs", "+\tString bootclasspathProperty = System.getProperty(\"sun.boot.class.path\"); //$NON-NLS-1$", "+\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t// IBM J9 VMs", "+\t\tbootclasspathProperty = System.getProperty(\"vm.boot.class.path\"); //$NON-NLS-1$", "+\t\tif ((bootclasspathProperty == null) || (bootclasspathProperty.length() == 0)) {", "+\t\t\t// Harmony using IBM VME", "+\t\t\tbootclasspathProperty = System.getProperty(\"org.apache.harmony.boot.class.path\"); //$NON-NLS-1$", "-\t\treturn jars;", "-    ArrayList paths = new ArrayList();", "-    String[] jarsNames = new String[] {", "-    \t\t\"/lib/vm.jar\",", "-    \t\t\"/lib/rt.jar\",", "-    \t\t\"/lib/core.jar\",", "-    \t\t\"/lib/security.jar\",", "-    \t\t\"/lib/xml.jar\",", "-    \t\t\"/lib/graphics.jar\"", "-    };", "-    addJarEntries(jreDir, jarsNames, paths);", "-    String[] result = new String[paths.size()];", "-    paths.toArray(result);", "-    return result;", "+\tString[] jars = null;", "+\tif ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {", "+\t\tStringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);", "+\t\tfinal int size = tokenizer.countTokens();", "+\t\tjars = new String[size];", "+\t\tint i = 0;", "+\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\tfinal String fileName = toNativePath(tokenizer.nextToken());", "+\t\t\tif (new File(fileName).exists()) {", "+\t\t\t\tjars[i] = fileName;", "+\t\t\t\ti++;", "+\t\t\t}", "+\t\t}", "+\t\tif (size != i) {", "+\t\t\t// resize", "+\t\t\tSystem.arraycopy(jars, 0, (jars = new String[i]), 0, i);", "+\t\t}", "+\t} else {", "+\t\tString jreDir = getJREDirectory();", "+\t\tfinal String osName = System.getProperty(\"os.name\");", "+\t\tif (jreDir == null) {", "+\t\t\treturn new String[] {};", "+\t\t}", "+\t\tif (osName.startsWith(\"Mac\")) {", "+\t\t\treturn new String[] {", "+\t\t\t\t\ttoNativePath(jreDir + \"/../Classes/classes.jar\")", "+\t\t\t};", "+\t\t}", "+\t\tfinal String vmName = System.getProperty(\"java.vm.name\");", "+\t\tif (\"J9\".equals(vmName)) {", "+\t\t\treturn new String[] {", "+\t\t\t\t\ttoNativePath(jreDir + \"/lib/jclMax/classes.zip\")", "+\t\t\t};", "+\t\t}", "+\t\tString[] jarsNames = null;", "+\t\tArrayList paths = new ArrayList();", "+\t\tif (\"DRLVM\".equals(vmName)) {", "+\t\t\tFilenameFilter jarFilter = new FilenameFilter() {", "+\t\t\t\tpublic boolean accept(File dir, String name) {", "+\t\t\t\t\treturn name.endsWith(\".jar\") & !name.endsWith(\"-src.jar\");", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tjarsNames = new File(jreDir + \"/lib/boot/\").list(jarFilter);", "+\t\t\taddJarEntries(jreDir + \"/lib/boot/\", jarsNames, paths);", "+\t\t} else {", "+\t\t\tjarsNames = new String[] {", "+\t\t\t\t\t\"/lib/vm.jar\",", "+\t\t\t\t\t\"/lib/rt.jar\",", "+\t\t\t\t\t\"/lib/core.jar\",", "+\t\t\t\t\t\"/lib/security.jar\",", "+\t\t\t\t\t\"/lib/xml.jar\",", "+\t\t\t\t\t\"/lib/graphics.jar\"", "+\t\t\t};", "+\t\t\taddJarEntries(jreDir, jarsNames, paths);", "+\t\t}", "+\t\tjars = new String[paths.size()];", "+\t\tpaths.toArray(jars);", "+\t}", "+\treturn jars;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8405d8688d625b1e23636a2c02535ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaWorkspaceScope.java", "commitBeforeChange": "e4f6d0091f68bf4b6ecb46943ad5d4d6a5ce0095", "commitAfterChange": "3a73dbc8d9839c0eb87857ef97f640371d15a626", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void initialize(int size)", "signatureAfterChange": " public IPackageFragmentRoot packageFragmentRoot(String resourcePathString, int jarSeparatorIndex, String jarPath)", "diff": ["-public void initialize(int size) {", "-\tsuper.initialize(size);", "-\ttry {", "-\t\tIJavaProject[] projects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();", "-\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\tint includeMask = SOURCES | APPLICATION_LIBRARIES | SYSTEM_LIBRARIES;", "-\t\t\tadd((JavaProject) projects[i], null, includeMask, new HashSet(length*2, 1), null);", "+ */", "+public IPackageFragmentRoot packageFragmentRoot(String resourcePathString, int jarSeparatorIndex, String jarPath) {", "+\tHashMap rootInfos = JavaModelManager.getDeltaState().roots;", "+\tDeltaProcessor.RootInfo rootInfo = null;", "+\tif (jarPath != null) {", "+\t\tIPath path = new Path(jarPath);", "+\t\trootInfo = (DeltaProcessor.RootInfo) rootInfos.get(path);", "+\t\tif (rootInfo == null)", "+\t\t\treturn null;", "+\t\treturn rootInfo.project.getPackageFragmentRoot0(path);", "+\t} else {", "+\t\t// resource in workspace", "+\t\tIPath path = new Path(resourcePathString);", "+\t\trootInfo = (DeltaProcessor.RootInfo) rootInfos.get(path);", "+\t\twhile (rootInfo == null && path.segmentCount() > 0) {", "+\t\t\tpath = path.removeLastSegments(1);", "+\t\t\trootInfo = (DeltaProcessor.RootInfo) rootInfos.get(path);", "-\t} catch (JavaModelException ignored) {", "-\t\t// ignore", "+\t\tif (rootInfo == null)", "+\t\t\treturn null;", "+\t\treturn rootInfo.getPackageFragmentRoot(null/*no resource hint*/);", "-\tthis.needsInitialize = false;"]}], "num": 43625}