{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "de0259f6eb4d33557f22b1fc34aa9486", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66a7d620555847d2c086b6ed486b0aed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java", "commitBeforeChange": "83b88f3849bc3529944cb5ada76e610acc101ab1", "commitAfterChange": "7eed8178809b3804cdae88d40ff2d9114bc0d206", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\t\tTypeBinding collectionElementType = ((ArrayBinding) collectionType).elementsType();", "+\t\t\t\tthis.collectionElementType = ((ArrayBinding) collectionType).elementsType();", "-\t\t\t\tthis.arrayElementTypeID = collectionElementType.id;", "-\t\t\t\tint compileTimeTypeID = this.arrayElementTypeID;", "+\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = parameterizedType.arguments[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = parameterizedType.arguments[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = iterableType.typeVariables()[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = iterableType.typeVariables()[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\t// no conversion needed as only for reference types", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tTypeBinding collectionElementType = scope.getJavaLangObject(); ", "-\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\tthis.collectionElementType = scope.getJavaLangObject();", "+\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "-\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d80e3b0ceff9e56dcf93961426b6cce2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java", "commitBeforeChange": "92852bca9a4e0ceab73bc2cba44652396852b1a5", "commitAfterChange": "20fabe8e19e8477c8c4c948361535071499aefa9", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\tthis.collection.computeConversion(scope, collectionType, collectionType);", "+\t\t\t\tthis.collection.computeConversion(scope,collectionType, collectionType);", "-\t\t\t    if (iterableType != null) {", "-\t\t\t\t    if (iterableType.isParameterizedType()) { // for(E e : Iterable<E>)", "-\t\t\t\t\t    ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding)iterableType;", "-\t\t\t\t\t\tif (parameterizedType.arguments.length == 1) { // per construction can only be one", "-\t\t\t\t\t\t\tthis.kind = GENERIC_ITERABLE;", "-\t\t\t\t\t\t\tthis.collectionElementType = parameterizedType.arguments[0]; ", "+\t\t\t    checkIterable: {", "+\t\t\t    \tif (iterableType == null) break checkIterable;", "+\t\t\t    \t", "+\t\t\t\t\tthis.iteratorReceiverType = collectionType.erasure();", "+\t\t\t\t\tif (((ReferenceBinding)iteratorReceiverType).findSuperTypeErasingTo(T_JavaLangIterable, false) == null) {", "+\t\t\t\t\t\tthis.iteratorReceiverType = iterableType; // handle indirect inheritance thru variable secondary bound", "+\t   \t\t\t\t\tthis.collection.computeConversion(scope, iterableType, collectionType);", "+\t\t\t\t\t} else {", "+\t   \t\t\t\t\tthis.collection.computeConversion(scope, collectionType, collectionType);", "+\t\t\t\t\t}", "+", "+\t\t\t    \tTypeBinding[] arguments = null;", "+\t\t\t    \tswitch (iterableType.kind()) {", "+\t\t\t    \t\tcase Binding.RAW_TYPE : // for(Object o : Iterable)", "+\t\t\t\t\t\t\tthis.kind = RAW_ITERABLE;", "+\t\t\t\t\t\t\tthis.collectionElementType = scope.getJavaLangObject();", "-\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t    \t\t\tbreak checkIterable;", "+\t\t\t    \t\t\t", "+\t\t\t    \t\tcase Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself", "+\t\t\t    \t\t\targuments = iterableType.typeVariables();", "+\t\t\t    \t\t\tbreak;", "+\t\t\t    \t\t\t", "+\t\t\t    \t\tcase Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)", "+\t\t\t    \t\t\targuments = ((ParameterizedTypeBinding)iterableType).arguments;", "+\t\t\t    \t\t\tbreak;", "+\t\t\t    \t\t\t", "+\t\t\t    \t\tdefault:", "+\t\t\t    \t\t\tbreak checkIterable;", "+\t\t\t    \t}", "+\t\t\t    \t// generic or parameterized case", "+\t\t\t\t\tif (arguments.length != 1) break checkIterable; // per construction can only be one", "+\t\t\t\t\tthis.kind = GENERIC_ITERABLE;", "+\t\t\t\t\t", "+\t\t\t\t\tthis.collectionElementType = arguments[0]; ", "+\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\tscope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);", "+\t\t\t\t\t}", "+\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t// no conversion needed as only for reference types", "+\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "-\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "-\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "-\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "-\t\t\t\t    } else if (iterableType.isGenericType()) { // for (T t : Iterable<T>) - in case used inside Iterable itself", "-\t\t\t\t\t\tif (iterableType.typeVariables().length == 1) {", "-\t\t\t\t\t\t\tthis.kind = GENERIC_ITERABLE;", "-\t\t\t\t\t\t\tthis.collectionElementType = iterableType.typeVariables()[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "-\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "-\t\t\t\t\t\t\t// no conversion needed as only for reference types", "-\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "-\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "-\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "-\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "-\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "-\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "-\t\t\t\t\t} else if (iterableType.isRawType()) { // for(Object o : Iterable)", "-\t\t\t\t\t\tthis.kind = RAW_ITERABLE;", "-\t\t\t\t\t\tthis.collectionElementType = scope.getJavaLangObject();", "-\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "-\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "-\t\t\t\t\t\t\tscope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// no conversion needed as only for reference types", "-\t\t\t\t\t}\t\t\t    ", "+\t\t\t\t\t}"]}], "num": 23504}