{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "11cd22c93bd3df304cce3dba6247a39f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "08d40cc445a0de3befa4ac3b3921f53d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java", "commitBeforeChange": "9efbe5554ac761a85464c2e1f07f87b5f5dd57eb", "commitAfterChange": "5af59e31692f51bf5a400460066038f2e641aee5", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "diff": ["-\t\t// if generic type X<T> is referred to as parameterized X<T>, then answer itself", "-\t\tcheckGeneric: {", "-\t\t    for (int i = 0; i < argLength; i++)", "-\t\t\t\tif (typeVariables[i] != argTypes[i])", "-\t\t\t\t    break checkGeneric;", "-\t\t\treturn currentType;", "-\t\t}", "-\t\tParameterizedTypeBinding parameterizedType = scope.createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "-\t\t// check argument type compatibility", "-\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "-\t\t\tfor (int i = 0; i < argLength; i++)", "-\t\t\t    if (!typeVariables[i].boundCheck(parameterizedType, argTypes[i]))", "-\t\t\t\t\tscope.problemReporter().typeMismatchError(argTypes[i], typeVariables[i], currentType, this.typeArguments[i]);", "-\t\tthis.resolvedType = parameterizedType;", "-\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\treportDeprecatedType(scope);", "+\t\t// if generic type X<T> is referred to as parameterized X<T>, then answer itself", "+\t\tboolean allEqual = true;", "+\t    for (int i = 0; allEqual && i < argLength; i++)", "+\t\t\tallEqual = typeVariables[i] == argTypes[i];", "+\t    if (!allEqual) {", "+\t    \tParameterizedTypeBinding parameterizedType = scope.createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "+\t\t\t// check argument type compatibility", "+\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "+\t\t\t\tfor (int i = 0; i < argLength; i++)", "+\t\t\t\t    if (!typeVariables[i].boundCheck(parameterizedType, argTypes[i]))", "+\t\t\t\t\t\tscope.problemReporter().typeMismatchError(argTypes[i], typeVariables[i], currentType, this.typeArguments[i]);", "+\t", "+\t\t\tthis.resolvedType = parameterizedType;", "+\t\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "+\t\t\t\treportDeprecatedType(scope);", "+\t\t}", "-\t\t\tthis.resolvedType = scope.createArrayType(parameterizedType, dimensions);", "+\t\t\tthis.resolvedType = scope.createArrayType(this.resolvedType, dimensions);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cf05b7d31a9444259892ab107d036f3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java", "commitBeforeChange": "d3db880f9ce093cbf2c8ff1aba8ac97e00156523", "commitAfterChange": "161582c49a2d0971bc7a25f8acf5442d64ba84bb", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "diff": ["-\t\t\t\tParameterizedTypeBinding parameterizedType = scope.createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, qualifiedType);", "-\t\t\t\t// check argument type compatibility", "-\t\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "-\t\t\t\t\tfor (int j = 0; j < argLength; j++)", "-\t\t\t\t\t    if (!typeVariables[j].boundCheck(parameterizedType, argTypes[j]))", "-\t\t\t\t\t\t\tscope.problemReporter().typeMismatchError(argTypes[j], typeVariables[j], currentType, args[j]);", "-\t\t\t\tqualifiedType = parameterizedType;", "+\t\t\t\t// if generic type X<T> is referred to as parameterized X<T>, then answer itself", "+\t\t\t\tboolean isIdentical = (qualifiedType == null) || (qualifiedType instanceof SourceTypeBinding);", "+\t\t\t\tif (isIdentical) {", "+\t\t\t\t    for (int j = 0; j < argLength; j++) {", "+\t\t\t\t\t\tif (typeVariables[j] != argTypes[j]) {", "+\t\t\t\t\t\t\tisIdentical = false;", "+\t\t\t\t\t\t    break;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t    if (isIdentical) {", "+\t\t\t    \tqualifiedType = (ReferenceBinding) currentType.erasure();", "+\t\t\t    } else {", "+\t\t\t\t\tParameterizedTypeBinding parameterizedType = scope.createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, qualifiedType);", "+\t\t\t\t\t// check argument type compatibility", "+\t\t\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "+\t\t\t\t\t\tfor (int j = 0; j < argLength; j++)", "+\t\t\t\t\t\t    if (!typeVariables[j].boundCheck(parameterizedType, argTypes[j]))", "+\t\t\t\t\t\t\t\tscope.problemReporter().typeMismatchError(argTypes[j], typeVariables[j], currentType, args[j]);", "+\t\t\t\t\tqualifiedType = parameterizedType;", "+\t\t\t    }"]}], "num": 54913}