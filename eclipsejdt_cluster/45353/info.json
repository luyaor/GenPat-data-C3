{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "93696765675af9aa7231c4cd8b801382", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f21b0f4b761406ae63168a763e73307", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "126dd6025c8f23861069be98f78a4771959a405b", "commitAfterChange": "1bd28947ec61a68bcbaa48e5f62a38f1082dad74", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "signatureAfterChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "diff": ["-\t\t\tint concurrentJobWork = 100;", "-\t\t\tif (progress != null)", "-\t\t\t\tprogress.beginTask(\"\", concurrentJobWork); //$NON-NLS-1$", "+\t\t\tSubMonitor subMonitor = SubMonitor.convert(progress);", "-\t\t\t\t\t\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "+\t\t\t\t\t\t\tstatus = searchJob.execute(subMonitor);", "-\t\t\t\t\t\tIProgressMonitor subProgress = null;", "+\t\t\t\t\t\tint totalWork = 1000;", "+\t\t\t\t\t\tSubMonitor subProgress = subMonitor.setWorkRemaining(10).split(8).setWorkRemaining(totalWork);", "+\t\t\t\t\t\t// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method", "+\t\t\t\t\t\t// and bug 42760 NullPointerException in JobManager when searching)", "+\t\t\t\t\t\tThread t = this.processingThread;", "+\t\t\t\t\t\tint originalPriority = t == null ? -1 : t.getPriority();", "-\t\t\t\t\t\t\tint totalWork = 1000;", "-\t\t\t\t\t\t\tif (progress != null) {", "-\t\t\t\t\t\t\t\tsubProgress = new SubProgressMonitor(progress, concurrentJobWork * 8 / 10);", "-\t\t\t\t\t\t\t\tsubProgress.beginTask(\"\", totalWork); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\tconcurrentJobWork = concurrentJobWork * 2 / 10;", "+\t\t\t\t\t\t\tif (t != null)", "+\t\t\t\t\t\t\t\tt.setPriority(Thread.currentThread().getPriority());", "+\t\t\t\t\t\t\tsynchronized(this) {", "+\t\t\t\t\t\t\t\tthis.awaitingClients++;", "-\t\t\t\t\t\t\t// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method", "-\t\t\t\t\t\t\t// and bug 42760 NullPointerException in JobManager when searching)", "-\t\t\t\t\t\t\tThread t = this.processingThread;", "-\t\t\t\t\t\t\tint originalPriority = t == null ? -1 : t.getPriority();", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tif (t != null)", "-\t\t\t\t\t\t\t\t\tt.setPriority(Thread.currentThread().getPriority());", "-\t\t\t\t\t\t\t\tsynchronized(this) {", "-\t\t\t\t\t\t\t\t\tthis.awaitingClients++;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tIJob previousJob = null;", "-\t\t\t\t\t\t\t\tint awaitingJobsCount;", "-\t\t\t\t\t\t\t\tint lastJobsCount = totalWork;", "-\t\t\t\t\t\t\t\tfloat lastWorked = 0;", "-\t\t\t\t\t\t\t\tfloat totalWorked = 0;", "-\t\t\t\t\t\t\t\twhile ((awaitingJobsCount = awaitingJobsCount()) > 0) {", "-\t\t\t\t\t\t\t\t\tif ((subProgress != null && subProgress.isCanceled())", "-\t\t\t\t\t\t\t\t\t\t\t|| this.processingThread == null)", "-\t\t\t\t\t\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t\t\t\t\t\tIJob currentJob = currentJob();", "-\t\t\t\t\t\t\t\t\t// currentJob can be null when jobs have been added to the queue but job manager is not enabled", "-\t\t\t\t\t\t\t\t\tif (currentJob != null && currentJob != previousJob) {", "-\t\t\t\t\t\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - waiting until ready - \" + searchJob);//$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\tif (subProgress != null) {", "-\t\t\t\t\t\t\t\t\t\t\tString indexing = Messages.bind(Messages.jobmanager_filesToIndex, currentJob.getJobFamily(), Integer.toString(awaitingJobsCount));", "-\t\t\t\t\t\t\t\t\t\t\tsubProgress.subTask(indexing);", "-\t\t\t\t\t\t\t\t\t\t\t// ratio of the amount of work relative to the total work", "-\t\t\t\t\t\t\t\t\t\t\tfloat ratio = awaitingJobsCount < totalWork ? 1 : ((float) totalWork) / awaitingJobsCount;", "-\t\t\t\t\t\t\t\t\t\t\tif (lastJobsCount > awaitingJobsCount) {", "-\t\t\t\t\t\t\t\t\t\t\t\ttotalWorked += (lastJobsCount - awaitingJobsCount) * ratio;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\t// more jobs were added, just increment by the ratio", "-\t\t\t\t\t\t\t\t\t\t\t\ttotalWorked += ratio;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\tif (totalWorked - lastWorked >= 1) {", "-\t\t\t\t\t\t\t\t\t\t\t\tsubProgress.worked((int) (totalWorked - lastWorked));", "-\t\t\t\t\t\t\t\t\t\t\t\tlastWorked = totalWorked;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\tlastJobsCount = awaitingJobsCount;", "+\t\t\t\t\t\t\tIJob previousJob = null;", "+\t\t\t\t\t\t\tint awaitingJobsCount;", "+\t\t\t\t\t\t\tint lastJobsCount = totalWork;", "+\t\t\t\t\t\t\tfloat lastWorked = 0;", "+\t\t\t\t\t\t\tfloat totalWorked = 0;", "+\t\t\t\t\t\t\twhile ((awaitingJobsCount = awaitingJobsCount()) > 0) {", "+\t\t\t\t\t\t\t\tif ((subProgress != null && subProgress.isCanceled())", "+\t\t\t\t\t\t\t\t\t\t|| this.processingThread == null)", "+\t\t\t\t\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\t\t\t\t\tIJob currentJob = currentJob();", "+\t\t\t\t\t\t\t\t// currentJob can be null when jobs have been added to the queue but job manager is not enabled", "+\t\t\t\t\t\t\t\tif (currentJob != null && currentJob != previousJob) {", "+\t\t\t\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - waiting until ready - \" + searchJob);//$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tif (subProgress != null) {", "+\t\t\t\t\t\t\t\t\t\tString indexing = Messages.bind(Messages.jobmanager_filesToIndex, currentJob.getJobFamily(), Integer.toString(awaitingJobsCount));", "+\t\t\t\t\t\t\t\t\t\tsubProgress.subTask(indexing);", "+\t\t\t\t\t\t\t\t\t\t// ratio of the amount of work relative to the total work", "+\t\t\t\t\t\t\t\t\t\tfloat ratio = awaitingJobsCount < totalWork ? 1 : ((float) totalWork) / awaitingJobsCount;", "+\t\t\t\t\t\t\t\t\t\tif (lastJobsCount > awaitingJobsCount) {", "+\t\t\t\t\t\t\t\t\t\t\ttotalWorked += (lastJobsCount - awaitingJobsCount) * ratio;", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t// more jobs were added, just increment by the ratio", "+\t\t\t\t\t\t\t\t\t\t\ttotalWorked += ratio;", "-\t\t\t\t\t\t\t\t\t\tpreviousJob = currentJob;", "+\t\t\t\t\t\t\t\t\t\tif (totalWorked - lastWorked >= 1) {", "+\t\t\t\t\t\t\t\t\t\t\tsubProgress.worked((int) (totalWorked - lastWorked));", "+\t\t\t\t\t\t\t\t\t\t\tlastWorked = totalWorked;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tlastJobsCount = awaitingJobsCount;", "-\t\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> GOING TO SLEEP - \" + searchJob);//$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\tThread.sleep(50);", "-\t\t\t\t\t\t\t\t\t} catch (InterruptedException e) {", "-\t\t\t\t\t\t\t\t\t\t// ignore", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tpreviousJob = currentJob;", "-\t\t\t\t\t\t\t} finally {", "-\t\t\t\t\t\t\t\tsynchronized(this) {", "-\t\t\t\t\t\t\t\t\tthis.awaitingClients--;", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> GOING TO SLEEP - \" + searchJob);//$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tThread.sleep(50);", "+\t\t\t\t\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\t\t\t\t\t// ignore", "-\t\t\t\t\t\t\t\tif (t != null && originalPriority > -1 && t.isAlive())", "-\t\t\t\t\t\t\t\t\tt.setPriority(originalPriority);", "-\t\t\t\t\t\t\tif (subProgress != null)", "-\t\t\t\t\t\t\t\tsubProgress.done();", "+\t\t\t\t\t\t\tsynchronized(this) {", "+\t\t\t\t\t\t\t\tthis.awaitingClients--;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (t != null && originalPriority > -1 && t.isAlive())", "+\t\t\t\t\t\t\t\tt.setPriority(originalPriority);", "-\t\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "+\t\t\tstatus = searchJob.execute(subMonitor);", "-\t\t\tif (progress != null)", "-\t\t\t\tprogress.done();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7cbf2c3fe784018fe75f757107abc91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "8bea847412c36874664a80a329bfe627deff5fa9", "commitAfterChange": "c4145c80a504c8681f4571ff2bd214b778e87107", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "signatureAfterChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "diff": ["-\t\tint concurrentJobWork = 100;", "-\t\tif (progress != null)", "-\t\t\tprogress.beginTask(\"\", concurrentJobWork); //$NON-NLS-1$", "-\t\tif (awaitingJobsCount() > 0) {", "-\t\t\tswitch (waitingPolicy) {", "-", "-\t\t\t\tcase IJob.ForceImmediate :", "-\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - forcing immediate - \" + searchJob);//$NON-NLS-1$", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tdisable(); // pause indexing", "-\t\t\t\t\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "-\t\t\t\t\t} finally {", "-\t\t\t\t\t\tenable();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\tUtil.verbose(\"FINISHED  concurrent job - \" + searchJob); //$NON-NLS-1$", "-\t\t\t\t\treturn status;", "-", "-\t\t\t\tcase IJob.CancelIfNotReady :", "-\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - cancelling - \" + searchJob); //$NON-NLS-1$", "-\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\tUtil.verbose(\"CANCELED concurrent job - \" + searchJob); //$NON-NLS-1$", "-\t\t\t\t\tthrow new OperationCanceledException();", "-", "-\t\t\t\tcase IJob.WaitUntilReady :", "-\t\t\t\t\tint awaitingWork;", "-\t\t\t\t\tIJob previousJob = null;", "-\t\t\t\t\tIJob currentJob;", "-\t\t\t\t\tIProgressMonitor subProgress = null;", "-\t\t\t\t\tint totalWork = this.awaitingJobsCount();", "-\t\t\t\t\tif (progress != null && totalWork > 0) {", "-\t\t\t\t\t\tsubProgress = new SubProgressMonitor(progress, concurrentJobWork / 2);", "-\t\t\t\t\t\tsubProgress.beginTask(\"\", totalWork); //$NON-NLS-1$", "-\t\t\t\t\t\tconcurrentJobWork = concurrentJobWork / 2;", "-\t\t\t\t\t}", "-\t\t\t\t\t// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method", "-\t\t\t\t\t// and bug 42760 NullPointerException in JobManager when searching)", "-\t\t\t\t\tThread t = this.processingThread;", "-\t\t\t\t\tint originalPriority = t == null ? -1 : t.getPriority();", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tif (t != null)", "-\t\t\t\t\t\t\tt.setPriority(Thread.currentThread().getPriority());", "-\t\t\t\t\t\tsynchronized(this) {", "-\t\t\t\t\t\t\tthis.awaitingClients++;", "+\t\ttry {", "+\t\t\tint concurrentJobWork = 100;", "+\t\t\tif (progress != null)", "+\t\t\t\tprogress.beginTask(\"\", concurrentJobWork); //$NON-NLS-1$", "+\t\t\tif (awaitingJobsCount() > 0) {", "+\t\t\t\tswitch (waitingPolicy) {", "+\t", "+\t\t\t\t\tcase IJob.ForceImmediate :", "+\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - forcing immediate - \" + searchJob);//$NON-NLS-1$", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tdisable(); // pause indexing", "+\t\t\t\t\t\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "+\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\tenable();", "-\t\t\t\t\t\twhile ((awaitingWork = awaitingJobsCount()) > 0) {", "-\t\t\t\t\t\t\tif (subProgress != null && subProgress.isCanceled())", "-\t\t\t\t\t\t\t\tthrow new OperationCanceledException();", "-\t\t\t\t\t\t\tcurrentJob = currentJob();", "-\t\t\t\t\t\t\t// currentJob can be null when jobs have been added to the queue but job manager is not enabled", "-\t\t\t\t\t\t\tif (currentJob != null && currentJob != previousJob) {", "-\t\t\t\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - waiting until ready - \" + searchJob);//$NON-NLS-1$", "-\t\t\t\t\t\t\t\tif (subProgress != null) {", "-\t\t\t\t\t\t\t\t\tsubProgress.subTask(", "-\t\t\t\t\t\t\t\t\t\tMessages.bind(Messages.manager_filesToIndex, Integer.toString(awaitingWork))); ", "-\t\t\t\t\t\t\t\t\tsubProgress.worked(1);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tpreviousJob = currentJob;", "+\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\tUtil.verbose(\"FINISHED  concurrent job - \" + searchJob); //$NON-NLS-1$", "+\t\t\t\t\t\treturn status;", "+\t", "+\t\t\t\t\tcase IJob.CancelIfNotReady :", "+\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - cancelling - \" + searchJob); //$NON-NLS-1$", "+\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\tUtil.verbose(\"CANCELED concurrent job - \" + searchJob); //$NON-NLS-1$", "+\t\t\t\t\t\tthrow new OperationCanceledException();", "+\t", "+\t\t\t\t\tcase IJob.WaitUntilReady :", "+\t\t\t\t\t\tint awaitingWork;", "+\t\t\t\t\t\tIJob previousJob = null;", "+\t\t\t\t\t\tIJob currentJob;", "+\t\t\t\t\t\tIProgressMonitor subProgress = null;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tint totalWork = this.awaitingJobsCount();", "+\t\t\t\t\t\t\tif (progress != null && totalWork > 0) {", "+\t\t\t\t\t\t\t\tsubProgress = new SubProgressMonitor(progress, concurrentJobWork / 2);", "+\t\t\t\t\t\t\t\tsubProgress.beginTask(\"\", totalWork); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tconcurrentJobWork = concurrentJobWork / 2;", "+\t\t\t\t\t\t\t// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method", "+\t\t\t\t\t\t\t// and bug 42760 NullPointerException in JobManager when searching)", "+\t\t\t\t\t\t\tThread t = this.processingThread;", "+\t\t\t\t\t\t\tint originalPriority = t == null ? -1 : t.getPriority();", "-\t\t\t\t\t\t\t\tif (VERBOSE)", "-\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> GOING TO SLEEP - \" + searchJob);//$NON-NLS-1$", "-\t\t\t\t\t\t\t\tThread.sleep(50);", "-\t\t\t\t\t\t\t} catch (InterruptedException e) {", "-\t\t\t\t\t\t\t\t// ignore", "+\t\t\t\t\t\t\t\tif (t != null)", "+\t\t\t\t\t\t\t\t\tt.setPriority(Thread.currentThread().getPriority());", "+\t\t\t\t\t\t\t\tsynchronized(this) {", "+\t\t\t\t\t\t\t\t\tthis.awaitingClients++;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\twhile ((awaitingWork = awaitingJobsCount()) > 0) {", "+\t\t\t\t\t\t\t\t\tif (subProgress != null && subProgress.isCanceled())", "+\t\t\t\t\t\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\t\t\t\t\t\tcurrentJob = currentJob();", "+\t\t\t\t\t\t\t\t\t// currentJob can be null when jobs have been added to the queue but job manager is not enabled", "+\t\t\t\t\t\t\t\t\tif (currentJob != null && currentJob != previousJob) {", "+\t\t\t\t\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> NOT READY - waiting until ready - \" + searchJob);//$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\tif (subProgress != null) {", "+\t\t\t\t\t\t\t\t\t\t\tsubProgress.subTask(", "+\t\t\t\t\t\t\t\t\t\t\t\tMessages.bind(Messages.manager_filesToIndex, Integer.toString(awaitingWork))); ", "+\t\t\t\t\t\t\t\t\t\t\tsubProgress.worked(1);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tpreviousJob = currentJob;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\t\tif (VERBOSE)", "+\t\t\t\t\t\t\t\t\t\t\tUtil.verbose(\"-> GOING TO SLEEP - \" + searchJob);//$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\tThread.sleep(50);", "+\t\t\t\t\t\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\t\t\t\t\t\t// ignore", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\t\tsynchronized(this) {", "+\t\t\t\t\t\t\t\t\tthis.awaitingClients--;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (t != null && originalPriority > -1 && t.isAlive())", "+\t\t\t\t\t\t\t\t\tt.setPriority(originalPriority);", "+\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\tif (subProgress != null)", "+\t\t\t\t\t\t\t\tsubProgress.done();", "-\t\t\t\t\t} finally {", "-\t\t\t\t\t\tsynchronized(this) {", "-\t\t\t\t\t\t\tthis.awaitingClients--;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (t != null && originalPriority > -1 && t.isAlive())", "-\t\t\t\t\t\t\tt.setPriority(originalPriority);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (subProgress != null)", "-\t\t\t\t\t\tsubProgress.done();", "+\t\t\t\t}", "+\t\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "+\t\t} finally {", "+\t\t\tif (progress != null)", "+\t\t\t\tprogress.done();", "+\t\t\tif (VERBOSE)", "+\t\t\t\tUtil.verbose(\"FINISHED  concurrent job - \" + searchJob); //$NON-NLS-1$", "-\t\tstatus = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));", "-\t\tif (progress != null)", "-\t\t\tprogress.done();", "-\t\tif (VERBOSE)", "-\t\t\tUtil.verbose(\"FINISHED  concurrent job - \" + searchJob); //$NON-NLS-1$"]}], "num": 45353}