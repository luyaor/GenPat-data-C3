{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3c1423f3ad2a441e3dbcfe329b0671dd", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "129c61c714f79de1d56a7387e1ec3f8c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "7fa614421be752542e93fc8394ff005421401e06", "commitAfterChange": "8c40adfe15c680e040fa4c1f51e65e6986081149", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void buildForProject(JavaProject project, ArrayList potentialSubtypes, org.eclipse.jdt.core.ICompilationUnit[] workingCopies, HashSet localTypes, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " private void buildForProject(JavaProject project, ArrayList potentialSubtypes, org.eclipse.jdt.core.ICompilationUnit[] workingCopies, HashSet localTypes, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t\t\t\t\tthis.hierarchyResolver.resolveLocalType(focusType, declaringMember);", "+\t\t\t\t\tOpenable openable;", "+\t\t\t\t\tif (declaringMember.isBinary()) {", "+\t\t\t\t\t\topenable = (Openable)declaringMember.getClassFile();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\topenable = (Openable)declaringMember.getCompilationUnit();", "+\t\t\t\t\t}", "+\t\t\t\t\tlocalTypes = new HashSet();", "+\t\t\t\t\tlocalTypes.add(openable.getPath().toString());", "+\t\t\t\t\tthis.hierarchyResolver.resolve(new Openable[] {openable}, localTypes, monitor);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ffc2a2d973eecea2cc1a613f8af89ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "83ab9db63b8ff68374b9953ac0c435dcd063d8bf", "commitAfterChange": "710352220ce729b3b70862da914c01e2ca1e73c5", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r \r public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tfor (int i = 0; i < length; i++)\r", "-\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "+\t\tfor (int i = 0; i < length; i++){\r", "+\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){\r", "-\t\tif (argHasError)\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (argHasError){\r", "+\t\t\tMethodBinding closestMethod = null;\r", "+\t\t\tif(receiverType instanceof ReferenceBinding) {\r", "+\t\t\t\t// record any selector match, for clients who may still need hint about possible method match\r", "+\t\t\t\tthis.codegenBinding = this.binding = scope.findMethod((ReferenceBinding)receiverType, selector, new TypeBinding[]{}, this);\r", "+\t\t\t}\t\t\t\r", "+\t\t}\r", "+\t\t// record the closest match, for clients who may still need hint about possible method match\r", "+\t\tif (binding.problemId() == ProblemReasons.NotFound){\r", "+\t\t\tthis.codegenBinding = this.binding = ((ProblemMethodBinding)binding).closestMatch;\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa3631c75c5b5a5cbec57c104ccc4589", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "276d690deab11e5ff278dd7a12340b7922d913fc", "commitAfterChange": "1ed5028f52cac9ac32a1eba090840061fb91b107", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["+\t\t\tReferenceBinding conflictingType = null;", "+\t\t\tif (importBinding instanceof MethodBinding) {", "+\t\t\t\tconflictingType = (ReferenceBinding) getType(compoundName, compoundName.length);", "+\t\t\t\tif (!conflictingType.isValidBinding())", "+\t\t\t\t\tconflictingType = null;", "+\t\t\t}", "-\t\t\tif (importBinding instanceof ReferenceBinding) {", "-\t\t\t\tReferenceBinding referenceBinding = (ReferenceBinding) importBinding;", "+\t\t\tif (importBinding instanceof ReferenceBinding || conflictingType != null) {", "+\t\t\t\tReferenceBinding referenceBinding = conflictingType == null ? (ReferenceBinding) importBinding : conflictingType;", "-\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "+\t\t\tresolvedImports[index++] = conflictingType == null", "+\t\t\t\t? new ImportBinding(compoundName, false, importBinding, importReference)", "+\t\t\t\t: new ImportConflictBinding(compoundName, importBinding, conflictingType, importReference);", "-\t\tif (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding)", "+\t\tif (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding || binding instanceof ImportConflictBinding)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd288df29be6edbcc80551c6ed9e19a5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "02e0207f51a14b2b110968b24524e6d9461bc936", "commitAfterChange": "7743b78aa7dc3095d1fff9fa367431511a686bf2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "signatureAfterChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "diff": ["+\t\t\tReferenceBinding equivalent = this;", "-\t        if (otherEquivalent != null && otherEquivalent.isParameterizedType()) {", "-\t\t        ParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherEquivalent;", "+\t        if (otherEquivalent == null) {", "+\t        \t// allow LinkedList<String> to match List<T> (downcast scenario)", "+\t\t    \tequivalent = this.findSuperTypeErasingTo((ReferenceBinding)otherType.erasure());", "+\t        \tif (equivalent == null || !equivalent.isParameterizedType())", "+\t        \t\treturn;", "+\t        \totherEquivalent = (ReferenceBinding)otherType;", "+\t        }", "+\t        if (equivalent.isParameterizedType() && otherEquivalent.isParameterizedType()) {", "+\t        \tParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) equivalent;", "+\t        \tParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherEquivalent;", "-\t                this.arguments[i].collectSubstitutes(otherParameterizedType.arguments[i], substitutes);", "+\t                parameterizedType.arguments[i].collectSubstitutes(otherParameterizedType.arguments[i], substitutes);", "-\t\t    }", "+\t        }"]}], "num": 19145}