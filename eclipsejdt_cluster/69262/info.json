{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9d41d5a9df5932dc768c68a1c33bdaa7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c7a75f784730a40df50ed6ccea3469b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["+// 8.4.8.4", "-\tint count = length;", "-\tint[] skip = new int[count];", "-\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "-\t\tif (skip[i] == -1) continue nextMethod;", "-\t\tMethodBinding method = methods[i];", "-\t\tMethodBinding[] duplicates = null;", "-\t\tfor (int j = i + 1; j <= l; j++) {", "-\t\t\tMethodBinding method2 = methods[j];", "-\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsCompatible(method, method2)) {", "-\t\t\t\tskip[j] = -1;", "-\t\t\t\tif (duplicates == null)", "-\t\t\t\t\tduplicates = new MethodBinding[length];", "-\t\t\t\tduplicates[j] = method2;", "+\tboolean continueInvestigation = true;", "+\tMethodBinding concreteMethod = null;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tif (!methods[i].isAbstract()) {", "+\t\t\tif (concreteMethod != null) {", "+\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "+\t\t\t\tcontinueInvestigation = false;", "-\t\t}", "-\t\tif (duplicates != null) {", "-\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "-\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "-\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "-\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "-\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "-\t\t\t\t\t\tmethodToKeep = duplicates[m];", "-\t\t\t\t\t\tconcreteCount++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (concreteCount != 1) {", "-\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "-\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tmethods[m] = null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tconcreteMethod = methods[i];", "-\tif (count < length) {", "-\t\tif (count == 1) return; // no need to continue since only 1 inherited method is left", "-\t\tMethodBinding[] newMethods = new MethodBinding[count];", "-\t\tfor (int i = length; --i >= 0;)", "-\t\t\tif (methods[i] != null)", "-\t\t\t\tnewMethods[--count] = methods[i];", "-\t\tmethods = newMethods;", "-\t\tlength = newMethods.length;", "+\tif (continueInvestigation) {", "+\t\tsuper.checkInheritedMethods(methods, length);", "-", "-\tsuper.checkInheritedMethods(methods, length);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e505521d5c4d94bd9e6ec13522ffb24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "23d1f03b5721ce2de9c0b6bda12e344c2ac468ba", "commitAfterChange": "966ae4bbaf97367f3fc38a9b2c2261f477021842", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "-\t\t\tchar[][] typeParameterNames = null;", "-\t\t\tchar[][][] typeParameterBounds = null;", "-\t\t\tif (typeParameters != null) {", "-\t\t\t\tint typeParametersLength = typeParameters.length;", "-\t\t\t\ttypeParameterNames = new char[typeParametersLength][];", "-\t\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "-\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "-\t\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "-\t\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "-\t\t\t\t\tif (bounds != null) {", "-\t\t\t\t\t\tint boundLength = bounds.length;", "-\t\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "-\t\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "-\t\t\t\t\t\t\tboundNames[j] = ", "-\t\t\t\t\t\t\t\tCharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); ", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}\t\t\t", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "+\t\t\tnotifySourceElementRequestor(methodDeclaration.typeParameters());\t\t\t", "-\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "-\t\tchar[][] typeParameterNames = null;", "-\t\tchar[][][] typeParameterBounds = null;", "-\t\tif (typeParameters != null) {", "-\t\t\tint typeParametersLength = typeParameters.length;", "-\t\t\ttypeParameterNames = new char[typeParametersLength][];", "-\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "-\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "-\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "-\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "-\t\t\t\tif (bounds != null) {", "-\t\t\t\t\tint boundLength = bounds.length;", "-\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "-\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "-\t\t\t\t\t\tboundNames[j] = ", "-\t\t\t\t\t\t\tCharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); ", "-\t\t\t\t\t}", "-\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "+\t\tnotifySourceElementRequestor(methodDeclaration.typeParameters());\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71b7a570b233d9cce1f4dd24a3f3377b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java", "commitBeforeChange": "f1193e6503e3d1d4aed816cb60dcc97268ceaf78", "commitAfterChange": "d173da65452fbda2d49c0f6b870b85fed5c21760", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic static Test suiteForJavadocSupport( String level, Class testClass, Constructor constructor, String support) throws InvocationTargetException, IllegalAccessException, InstantiationException", "signatureAfterChange": "  \tpublic static Test suiteForJavadocSupport(String level, Class testClass, Constructor constructor, String support) throws InvocationTargetException, IllegalAccessException, InstantiationException", "diff": ["-\tpublic static Test suiteForJavadocSupport(/*TestSuite suite,*/ String level, Class testClass, Constructor constructor, String support) throws InvocationTargetException, IllegalAccessException, InstantiationException {", "-\t\tTestSuite suite = new TestSuite(\"Doc \"+support);", "-\t\tif (testNames != null) {", "-\t\t\tfor (int i = 0; i < testNames.length; i++) {", "-\t\t\t\tString meth = \"test\" + testNames[i];", "-//\t\t\t\tObject[] params = {meth, support};", "-\t\t\t\tObject[] params = {meth};", "-\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t}", "-\t\t}", "-\t\telse if (testNumbers != null) {", "-\t\t\tfor (int i = 0; i < testNumbers.length; i++) {", "-\t\t\t\tString meth = \"test\";", "-\t\t\t\tint num = testNumbers[i];", "-\t\t\t\tif (num < 10) meth += \"0\";", "-\t\t\t\tif (num < 100) meth += \"0\";", "-\t\t\t\tmeth += num;", "-//\t\t\t\tObject[] params = {meth, support};", "-\t\t\t\tObject[] params = {meth};", "-\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t}", "-\t\t}", "-\t\telse if (testRange != null && testRange.length == 2 && testRange[0]>=0 && testRange[0]<=testRange[1]) {", "-\t\t\tfor (int i=testRange[0]; i<=testRange[1]; i++) {", "-\t\t\t\tString meth = \"test\";", "-\t\t\t\tif (i<10) meth += \"0\";", "-\t\t\t\tif (i<100) meth += \"0\";", "-\t\t\t\tmeth += i;", "-//\t\t\t\tObject[] params = {meth, support};", "-\t\t\t\tObject[] params = {meth};", "-\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// Run all tests", "-\t\t\tMethod[] methods = testClass.getMethods();", "-\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\tif (methods[i].getModifiers() == 1 && methods[i].getName().startsWith(\"test\")) { //$NON-NLS-1$", "-//\t\t\t\t\tObject[] params = {methods[i].getName(), support};", "-\t\t\t\t\tObject[] params = {methods[i].getName()};", "-\t\t\t\t\tsuite.addTest((Test)constructor.newInstance(params));", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-//\t\treturn suite;", "+\tpublic static Test suiteForJavadocSupport(String level, Class testClass, Constructor constructor, String support) throws InvocationTargetException, IllegalAccessException, InstantiationException {", "+\t\tTest suite = suite(testClass, \"Doc \"+support);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5ed19a34a9f7bd4dd34da5d00076099", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java", "commitBeforeChange": "13b3d93ad06f327dd1b71c8b4a9dd41c3f6dfa1e", "commitAfterChange": "21b9b0f5640cfb80f180c2faa0f4171ca50a57f3", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "  public void testDenseCycleDetection() throws CoreException", "signatureAfterChange": " public void testDenseCycleDetection() throws CoreException", "diff": ["-", "+\tdenseCycleDetection(5);", "+\tdenseCycleDetection(10);", "+\tdenseCycleDetection(20);", "+\t//denseCycleDetection(100);", "+}", "-\tint max = 10;", "-\tIJavaProject[] projects = new IJavaProject[max];", "-\tint[] allProjectsInCycle = new int[max];", "-\t\tfor (int i = 0; i < max; i++){", "-\t\tfor (int i = 0; i < max; i++){", "-\t\t\tIClasspathEntry[] extraEntries = new IClasspathEntry[max-1];", "-\t\t\tfor (int j = 0; j < max; j++){", "-\t\tSystem.out.println(\"Dense cycle check (\"+max+\" participants) : \"+ (System.currentTimeMillis()-start)+\" ms\");", "-\t\tfor (int i = 0; i < max; i++){", "-\t\t\tfor (int i = 0; i < max; i++){"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8627bab3103d529e636d98e0c471720", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "commitAfterChange": "59519e2b1686eb933c8efe8536442e5841102c2e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "-\t\t/* validate output locations */", "-\t\tif (projectOutputLocation == null) {", "+\t\t/* validate output location */", "+\t\tif (outputLocation == null) {", "-\t\t// tolerate null path, it will be reset to default", "-\t\tint length = classpath == null ? 0 : classpath.length; ", "-\t\t// collect other output locations", "-\t\tint outputsLength = length+1;", "-\t\tIPath[] outputLocations = new IPath[outputsLength];", "-\t\toutputLocations[length] = projectOutputLocation;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tIClasspathEntry entry = classpath[i];", "-\t\t\tIPath outputLocation = entry.getOutputLocation();", "-\t\t\tif (outputLocation != null) {", "-\t\t\t\tif (outputLocation.isAbsolute()) {", "-\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\toutputLocations[i] = outputLocation;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t\t\t}", "+\t\tif (outputLocation.isAbsolute()) {", "+\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t} else {", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean allowNestingInOutput = false;", "-\t\t", "+\t", "+\t\t// tolerate null path, it will be reset to default", "+\t\tint length = classpath == null ? 0 : classpath.length; ", "+\t", "-\t\t\tint kind = rawEntry.getEntryKind();", "-\t\t\tswitch(kind){", "+\t\t\tswitch(rawEntry.getEntryKind()){", "-\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "-\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "-\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "-\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "-\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "-\t\t\t\tfor (int j = 0; j < length; j++){", "+\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "-\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\tif (outputLocation != null) {", "-\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t", "-\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t}", "+\t", "+\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$"]}], "num": 69262}