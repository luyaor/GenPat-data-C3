{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3ddf92d249df1d76443143f0e9a3ebdc", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79dd79ed5dea8484b0361db5ed9567af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean denyEnclosingArgInConstructorCall)", "signatureAfterChange": " public Object[] getEmulationPath(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean denyEnclosingArgInConstructorCall)", "diff": ["+ */", "+public Object[] getEmulationPath(ReferenceBinding targetEnclosingType, boolean onlyExactMatch, boolean denyEnclosingArgInConstructorCall) {", "+\tMethodScope currentMethodScope = this.methodScope();", "+\tSourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();", "+", "+\t// use 'this' if possible", "+\tif (!currentMethodScope.isStatic && !currentMethodScope.isConstructorCall) {", "+\t\tif (sourceType == targetEnclosingType || (!onlyExactMatch && sourceType.findSuperTypeWithSameErasure(targetEnclosingType) != null)) {", "+\t\t\treturn BlockScope.EmulationPathToImplicitThis; // implicit this is good enough", "+\t\t}", "+\t}", "+\tif (!sourceType.isNestedType() || sourceType.isStatic()) { // no emulation from within non-inner types", "+\t\tif (currentMethodScope.isConstructorCall) {", "+\t\t\treturn BlockScope.NoEnclosingInstanceInConstructorCall;", "+\t\t} else if (currentMethodScope.isStatic){", "+\t\t\treturn BlockScope.NoEnclosingInstanceInStaticContext;", "-\t */", "-\tpublic Object[] getEmulationPath(", "-\t\t\tReferenceBinding targetEnclosingType, ", "-\t\t\tboolean onlyExactMatch,", "-\t\t\tboolean denyEnclosingArgInConstructorCall) {", "-\t\t\t\t", "-\t\tMethodScope currentMethodScope = this.methodScope();", "-\t\tSourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();", "-", "-\t\t// use 'this' if possible", "-\t\tif (!currentMethodScope.isStatic && !currentMethodScope.isConstructorCall) {", "-\t\t\tif (sourceType == targetEnclosingType || (!onlyExactMatch && sourceType.findSuperTypeWithSameErasure(targetEnclosingType) != null)) {", "-\t\t\t\treturn EmulationPathToImplicitThis; // implicit this is good enough", "+\tboolean insideConstructor = currentMethodScope.isInsideInitializerOrConstructor();", "+\t// use synthetic constructor arguments if possible", "+\tif (insideConstructor) {", "+\t\tSyntheticArgumentBinding syntheticArg;", "+\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, onlyExactMatch)) != null) {", "+\t\t\t// reject allocation and super constructor call", "+\t\t\tif (denyEnclosingArgInConstructorCall", "+\t\t\t\t\t&& currentMethodScope.isConstructorCall ", "+\t\t\t\t\t&& (sourceType == targetEnclosingType || (!onlyExactMatch && sourceType.findSuperTypeWithSameErasure(targetEnclosingType) != null))) {", "+\t\t\t\treturn BlockScope.NoEnclosingInstanceInConstructorCall;", "-\t\t}", "-\t\tif (!sourceType.isNestedType() || sourceType.isStatic()) { // no emulation from within non-inner types", "-\t\t\tif (currentMethodScope.isConstructorCall) {", "-\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "-\t\t\t} else if (currentMethodScope.isStatic){", "-\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t\t}", "-\t\t\treturn null;", "-\t\t}", "-\t\tboolean insideConstructor = currentMethodScope.isInsideInitializerOrConstructor();", "-\t\t// use synthetic constructor arguments if possible", "-\t\tif (insideConstructor) {", "-\t\t\tSyntheticArgumentBinding syntheticArg;", "-\t\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, onlyExactMatch)) != null) {", "-\t\t\t\t// reject allocation and super constructor call", "-\t\t\t\tif (denyEnclosingArgInConstructorCall", "-\t\t\t\t\t\t&& currentMethodScope.isConstructorCall ", "-\t\t\t\t\t\t&& (sourceType == targetEnclosingType || (!onlyExactMatch && sourceType.findSuperTypeWithSameErasure(targetEnclosingType) != null))) {", "-\t\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "-\t\t\t\t}", "-\t\t\t\treturn new Object[] { syntheticArg };", "-\t\t\t}", "-\t\t}", "-", "-\t\t// use a direct synthetic field then", "-\t\tif (currentMethodScope.isStatic) {", "-\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t}", "-\t\tif (sourceType.isAnonymousType()) {", "-\t\t\tReferenceBinding enclosingType = sourceType.enclosingType();", "-\t\t\tif (enclosingType.isNestedType()) {", "-\t\t\t\tNestedTypeBinding nestedEnclosingType = (NestedTypeBinding) enclosingType;", "-\t\t\t\tSyntheticArgumentBinding enclosingArgument = nestedEnclosingType.getSyntheticArgument(nestedEnclosingType.enclosingType(), onlyExactMatch);", "-\t\t\t\tif (enclosingArgument != null) {", "-\t\t\t\t\tFieldBinding syntheticField = sourceType.getSyntheticField(enclosingArgument);", "-\t\t\t\t\tif (syntheticField != null) {", "-\t\t\t\t\t\tif (syntheticField.type == targetEnclosingType || (!onlyExactMatch && ((ReferenceBinding)syntheticField.type).findSuperTypeWithSameErasure(targetEnclosingType) != null))", "-\t\t\t\t\t\t\treturn new Object[] { syntheticField };", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tFieldBinding syntheticField = sourceType.getSyntheticField(targetEnclosingType, onlyExactMatch);", "-\t\tif (syntheticField != null) {", "-\t\t\tif (currentMethodScope.isConstructorCall){", "-\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "-\t\t\t}", "-\t\t\treturn new Object[] { syntheticField };", "-\t\t}", "-", "-\t\t// could be reached through a sequence of enclosing instance link (nested members)", "-\t\tObject[] path = new Object[2]; // probably at least 2 of them", "-\t\tReferenceBinding currentType = sourceType.enclosingType();", "-\t\tif (insideConstructor) {", "-\t\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument(currentType, onlyExactMatch);", "-\t\t} else {", "-\t\t\tif (currentMethodScope.isConstructorCall){", "-\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "-\t\t\t}", "-\t\t\tpath[0] = sourceType.getSyntheticField(currentType, onlyExactMatch);", "-\t\t}", "-\t\tif (path[0] != null) { // keep accumulating", "-\t\t\t", "-\t\t\tint count = 1;", "-\t\t\tReferenceBinding currentEnclosingType;", "-\t\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "-", "-\t\t\t\t//done?", "-\t\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t\t|| (!onlyExactMatch && currentType.findSuperTypeWithSameErasure(targetEnclosingType) != null))\tbreak;", "-", "-\t\t\t\tif (currentMethodScope != null) {", "-\t\t\t\t\tcurrentMethodScope = currentMethodScope.enclosingMethodScope();", "-\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isConstructorCall){", "-\t\t\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isStatic){", "-\t\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField(currentEnclosingType, onlyExactMatch);", "-\t\t\t\tif (syntheticField == null) break;", "-", "-\t\t\t\t// append inside the path", "-\t\t\t\tif (count == path.length) {", "-\t\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "-\t\t\t\t}", "-\t\t\t\t// private access emulation is necessary since synthetic field is private", "-\t\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "-\t\t\t\tcurrentType = currentEnclosingType;", "-\t\t\t}", "-\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t|| (!onlyExactMatch && currentType.findSuperTypeWithSameErasure(targetEnclosingType) != null)) {", "-\t\t\t\treturn path;", "-\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t\t\treturn new Object[] { syntheticArg };", "+\t// use a direct synthetic field then", "+\tif (currentMethodScope.isStatic) {", "+\t\treturn BlockScope.NoEnclosingInstanceInStaticContext;", "+\t}", "+\tif (sourceType.isAnonymousType()) {", "+\t\tReferenceBinding enclosingType = sourceType.enclosingType();", "+\t\tif (enclosingType.isNestedType()) {", "+\t\t\tNestedTypeBinding nestedEnclosingType = (NestedTypeBinding) enclosingType;", "+\t\t\tSyntheticArgumentBinding enclosingArgument = nestedEnclosingType.getSyntheticArgument(nestedEnclosingType.enclosingType(), onlyExactMatch);", "+\t\t\tif (enclosingArgument != null) {", "+\t\t\t\tFieldBinding syntheticField = sourceType.getSyntheticField(enclosingArgument);", "+\t\t\t\tif (syntheticField != null) {", "+\t\t\t\t\tif (syntheticField.type == targetEnclosingType || (!onlyExactMatch && ((ReferenceBinding)syntheticField.type).findSuperTypeWithSameErasure(targetEnclosingType) != null))", "+\t\t\t\t\t\treturn new Object[] { syntheticField };", "+\t\t\t\t}", "+\tFieldBinding syntheticField = sourceType.getSyntheticField(targetEnclosingType, onlyExactMatch);", "+\tif (syntheticField != null) {", "+\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\treturn BlockScope.NoEnclosingInstanceInConstructorCall;", "+\t\t}", "+\t\treturn new Object[] { syntheticField };", "+\t// could be reached through a sequence of enclosing instance link (nested members)", "+\tObject[] path = new Object[2]; // probably at least 2 of them", "+\tReferenceBinding currentType = sourceType.enclosingType();", "+\tif (insideConstructor) {", "+\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument(currentType, onlyExactMatch);", "+\t} else {", "+\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\treturn BlockScope.NoEnclosingInstanceInConstructorCall;", "+\t\t}", "+\t\tpath[0] = sourceType.getSyntheticField(currentType, onlyExactMatch);", "+\t}", "+\tif (path[0] != null) { // keep accumulating", "+\t\tint count = 1;", "+\t\tReferenceBinding currentEnclosingType;", "+\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "+", "+\t\t\t//done?", "+\t\t\tif (currentType == targetEnclosingType", "+\t\t\t\t|| (!onlyExactMatch && currentType.findSuperTypeWithSameErasure(targetEnclosingType) != null))\tbreak;", "+", "+\t\t\tif (currentMethodScope != null) {", "+\t\t\t\tcurrentMethodScope = currentMethodScope.enclosingMethodScope();", "+\t\t\t\tif (currentMethodScope != null && currentMethodScope.isConstructorCall){", "+\t\t\t\t\treturn BlockScope.NoEnclosingInstanceInConstructorCall;", "+\t\t\t\tif (currentMethodScope != null && currentMethodScope.isStatic){", "+\t\t\t\t\treturn BlockScope.NoEnclosingInstanceInStaticContext;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField(currentEnclosingType, onlyExactMatch);", "+\t\t\tif (syntheticField == null) break;", "+", "+\t\t\t// append inside the path", "+\t\t\tif (count == path.length) {", "+\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "+\t\t\t}", "+\t\t\t// private access emulation is necessary since synthetic field is private", "+\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "+\t\t\tcurrentType = currentEnclosingType;", "+\t\t}", "+\t\tif (currentType == targetEnclosingType", "+\t\t\t|| (!onlyExactMatch && currentType.findSuperTypeWithSameErasure(targetEnclosingType) != null)) {", "+\t\t\treturn path;", "+\t\t}", "+\t}", "+\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac9bca8cfd8f4ade5c287f7234902ccf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "e749248b2d171474b4cec0b274f15c474b2172fa", "commitAfterChange": "49bbfb9368cdcf7ee010de91440ff4d54ad31533", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic Object[] getCompatibleEmulationPath(ReferenceBinding targetEnclosingType)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "diff": ["-\t */", "-\tpublic Object[] getCompatibleEmulationPath(ReferenceBinding targetEnclosingType) {", "-", "-\t\tMethodScope currentMethodScope = this.methodScope();", "-\t\tSourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();", "-", "-\t\t// identity check", "-\t\tif (!currentMethodScope.isStatic ", "-\t\t\t&& !currentMethodScope.isConstructorCall", "-\t\t\t&& (sourceType == targetEnclosingType", "-\t\t\t\t|| targetEnclosingType.isSuperclassOf(sourceType))) {", "-\t\t\treturn EmulationPathToImplicitThis; // implicit this is good enough", "-\t\t}", "-\t\tif (!sourceType.isNestedType()", "-\t\t\t|| sourceType.isStatic()) { // no emulation from within non-inner types", "-\t\t\treturn null;", "-\t\t}", "-\t\tboolean insideConstructor =", "-\t\t\tcurrentMethodScope.isInsideInitializerOrConstructor();", "-\t\t// use synthetic constructor arguments if possible", "-\t\tif (insideConstructor) {", "-\t\t\tSyntheticArgumentBinding syntheticArg;", "-\t\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, this, false)) != null) {", "-\t\t\t\treturn new Object[] { syntheticArg };", "-\t\t\t}", "-\t\t}", "-", "-\t\t// use a direct synthetic field then", "-\t\tif (!currentMethodScope.isStatic) {", "-\t\t\tFieldBinding syntheticField;", "-\t\t\tif ((syntheticField = sourceType.getSyntheticField(targetEnclosingType, this, false)) != null) {", "-\t\t\t\treturn new Object[] { syntheticField };", "-\t\t\t}", "-\t\t\t// could be reached through a sequence of enclosing instance link (nested members)", "-\t\t\tObject[] path = new Object[2]; // probably at least 2 of them", "-\t\t\tReferenceBinding currentType = sourceType.enclosingType();", "-\t\t\tif (insideConstructor) {", "-\t\t\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument((SourceTypeBinding) currentType, this, false);", "-\t\t\t} else {", "-\t\t\t\tpath[0] =", "-\t\t\t\t\tsourceType.getSyntheticField((SourceTypeBinding) currentType, this, false);", "-\t\t\t}", "-\t\t\tif (path[0] != null) { // keep accumulating", "-\t\t\t\tint count = 1;", "-\t\t\t\tReferenceBinding currentEnclosingType;", "-\t\t\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "-\t\t\t\t\t//done?", "-\t\t\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentType))", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField((SourceTypeBinding) currentEnclosingType, this, false);", "-\t\t\t\t\tif (syntheticField == null)", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t// append inside the path", "-\t\t\t\t\tif (count == path.length) {", "-\t\t\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "-\t\t\t\t\t}", "-\t\t\t\t\t// private access emulation is necessary since synthetic field is private", "-\t\t\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "-\t\t\t\t\tcurrentType = currentEnclosingType;", "-\t\t\t\t}", "-\t\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentType)) {", "-\t\t\t\t\treturn path;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\tpublic Object[] getEmulationPath(", "+\t\t\tReferenceBinding targetEnclosingType, ", "+\t\t\tboolean onlyExactMatch,", "+\t\t\tboolean ignoreEnclosingArgInConstructorCall) {", "+\t\t//TODO: (philippe) investigate why exactly test76 fails if ignoreEnclosingArgInConstructorCall is always false", "+\t\t\t&& (!currentMethodScope.isConstructorCall || ignoreEnclosingArgInConstructorCall)", "+\t\t\t&& (sourceType == targetEnclosingType", "+\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType)))) {", "+\t\t\tif (currentMethodScope.isConstructorCall) {", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t}", "+\t\t\tif (currentMethodScope.isStatic){", "+\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t}", "+\t\tif (!sourceType.isNestedType() || sourceType.isStatic()) { // no emulation from within non-inner types", "+\t\t\tif (currentMethodScope.isConstructorCall) {", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t}", "+\t\t\t\tif (currentMethodScope.isStatic){", "+\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t\t}", "+\t\tboolean insideConstructor = currentMethodScope.isInsideInitializerOrConstructor();", "+\t\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, onlyExactMatch)) != null) {", "+", "+\t\tif (currentMethodScope.isStatic) {", "+\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t}", "+\t\tFieldBinding syntheticField = sourceType.getSyntheticField(targetEnclosingType, onlyExactMatch);", "+\t\tif (syntheticField != null) {", "+\t\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\treturn new Object[] { syntheticField };", "+\t\t}", "+\t\t// could be reached through a sequence of enclosing instance link (nested members)", "+\t\tObject[] path = new Object[2]; // probably at least 2 of them", "+\t\tReferenceBinding currentType = sourceType.enclosingType();", "+\t\tif (insideConstructor) {", "+\t\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument((SourceTypeBinding) currentType, onlyExactMatch);", "+\t\t} else {", "+\t\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\tpath[0] = sourceType.getSyntheticField((SourceTypeBinding) currentType, onlyExactMatch);", "+\t\t}", "+\t\tif (path[0] != null) { // keep accumulating", "+\t\t\t", "+\t\t\tint count = 1;", "+\t\t\tReferenceBinding currentEnclosingType;", "+\t\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "+", "+\t\t\t\t//done?", "+\t\t\t\tif (currentType == targetEnclosingType", "+\t\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType)))\tbreak;", "+", "+\t\t\t\tif (currentMethodScope != null) {", "+\t\t\t\t\tcurrentMethodScope = currentMethodScope.enclosingMethodScope();", "+\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isConstructorCall){", "+\t\t\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isStatic){", "+\t\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField((SourceTypeBinding) currentEnclosingType, onlyExactMatch);", "+\t\t\t\tif (syntheticField == null) break;", "+", "+\t\t\t\t// append inside the path", "+\t\t\t\tif (count == path.length) {", "+\t\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "+\t\t\t\t// private access emulation is necessary since synthetic field is private", "+\t\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "+\t\t\t\tcurrentType = currentEnclosingType;", "+\t\t\t}", "+\t\t\tif (currentType == targetEnclosingType", "+\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType))) {", "+\t\t\t\treturn path;"]}], "num": 44585}