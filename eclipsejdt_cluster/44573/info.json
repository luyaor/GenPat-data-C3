{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7f84ec24fce57a7b6c66ba029e5654eb", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "963980ac4b155d8def9889281f472700", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "4bca3a5b750a1427c84a78f92ee835c1f5e75da7", "commitAfterChange": "65cffea518e323981e83002b5b2ff520f43d6c58", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "signatureAfterChange": " \tpublic static String buildAllDirectoriesInto( \t\tString outputPath, \t\tString relativeFileName) \t\tthrows IOException", "diff": ["-\t\t// First we ensure that the outputPath exists", "-\t\t// To be able to pass the mkdirs() method we need to remove the extra file separator at the end of the outDir name", "-\t\tif (outputPath.endsWith(fileSeparator)) {", "-\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "-\t\t}", "-\t\tf = new File(outputPath);", "-\t\tif (f.exists()) {", "-\t\t\tif (!f.isDirectory()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_isFile, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\t// these could be optimized out if we normalized paths once and for", "+\t\t\t// all", "+\t\trelativeFileName = relativeFileName.replace('/', fileSeparatorChar);", "+\t\tString outputDirPath, fileName;", "+\t\tint separatorIndex = relativeFileName.lastIndexOf(fileSeparatorChar);", "+\t\tif (separatorIndex == -1) {", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath;", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\t\t// we have to create that directory", "-\t\t\tif (!f.mkdirs()) {", "-\t\t\t\tfinal String message = Messages.bind(Messages.output_notValidAll, f.getAbsolutePath());", "-\t\t\t\tthrow new IOException(message);", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputDirPath = outputPath + ", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + relativeFileName;", "+\t\t\t} else {", "+\t\t\t\toutputDirPath = outputPath + fileSeparator +", "+\t\t\t\t\trelativeFileName.substring(0, separatorIndex);", "+\t\t\t\tfileName = outputPath + fileSeparator + relativeFileName;", "-\t\tStringBuffer outDir = new StringBuffer(outputPath);", "-\t\toutDir.append(fileSeparator);", "-\t\tStringTokenizer tokenizer =", "-\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "-\t\tString token = tokenizer.nextToken();", "-\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\tf = new File(outputDirPath);", "+\t\tf.mkdirs();", "+\t\tif (f.isDirectory()) {", "+\t\t\treturn fileName;", "+\t\t} else {", "+\t\t\t// the directory creation failed for some reason - retry using", "+\t\t\t// a slower algorithm so as to refine the diagnostic", "+\t\t\tif (outputPath.endsWith(fileSeparator)) {", "+\t\t\t\toutputPath = outputPath.substring(0, outputPath.length() - 1);", "+\t\t\t}", "+\t\t\tf = new File(outputPath);", "+\t\t\tboolean checkFileType = false;", "-\t\t\t\t// The outDir already exists, so we proceed the next entry", "-\t\t\t\t// System.out.println(\"outDir: \" + outDir + \" already exists.\");", "+\t\t\t  \tcheckFileType = true; // pre-existed", "-\t\t\t\t// Need to add the outDir", "-\t\t\t\tif (!f.mkdir()) {", "-\t\t\t\t\tthrow new IOException(Messages.bind(Messages.output_notValid, f.getName()));", "+\t\t\t\t// we have to create that directory", "+\t\t\t\tif (!f.mkdirs()) {", "+\t\t\t\t  \tif (f.exists()) {", "+\t\t\t\t  \t  \t// someone else created f -- need to check its type", "+\t\t\t\t  \t  \tcheckFileType = true;", "+\t\t\t\t  \t} else {", "+\t\t\t\t  \t  \t// no one could create f -- complain", "+\t    \t\t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\t\tMessages.output_notValidAll, f.getAbsolutePath()));", "+\t\t\t\t  \t}", "-\t\t\ttoken = tokenizer.nextToken();", "+\t\t\tif (checkFileType) {", "+\t\t\t  \tif (!f.isDirectory()) {", "+\t    \t\t\tthrow new IOException(Messages.bind(", "+\t    \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t\t\t  \t}", "+\t\t\t}", "+\t\t\tStringBuffer outDir = new StringBuffer(outputPath);", "+\t\t\toutDir.append(fileSeparator);", "+\t\t\tStringTokenizer tokenizer =", "+\t\t\t\tnew StringTokenizer(relativeFileName, fileSeparator);", "+\t\t\tString token = tokenizer.nextToken();", "+\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\tf = new File(outDir.append(token).append(fileSeparator).toString());", "+\t\t\t  \tcheckFileType = false; // reset", "+\t\t\t\tif (f.exists()) {", "+\t\t\t\t  \tcheckFileType = true; // this is suboptimal, but it catches corner cases", "+\t\t\t\t  \t\t\t\t\t\t  // in which a regular file pre-exists", "+\t\t\t\t} else {", "+\t\t\t\t// we have to create that directory", "+\t    \t\t\tif (!f.mkdir()) {", "+\t    \t\t\t  \tif (f.exists()) {", "+\t    \t\t\t  \t  \t// someone else created f -- need to check its type", "+\t    \t\t\t  \t  \tcheckFileType = true;", "+\t    \t\t\t  \t} else {", "+\t    \t\t\t  \t  \t// no one could create f -- complain", "+\t        \t\t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\t\tMessages.output_notValid, ", "+\t        \t\t\t\t\t\toutDir.substring(outputPath.length() + 1, ", "+\t        \t\t\t\t\t\t\toutDir.length() - 1),", "+\t        \t\t\t\t\t\toutputPath));", "+\t    \t\t\t  \t}", "+\t    \t\t\t}", "+\t\t\t\t}", "+\t    \t\tif (checkFileType) {", "+\t    \t\t  \tif (!f.isDirectory()) {", "+\t        \t\t\tthrow new IOException(Messages.bind(", "+\t        \t\t\t\tMessages.output_isFile, f.getAbsolutePath()));", "+\t    \t\t  \t}", "+\t    \t\t}", "+\t\t\t\ttoken = tokenizer.nextToken();", "+\t\t\t}", "+\t\t\t// token contains the last one", "+\t\t\treturn outDir.append(token).toString();", "-\t\t// token contains the last one", "-\t\treturn outDir.append(token).toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a77489973310ee3748450d428d184654", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterMassiveRegressionTests.java", "commitBeforeChange": "6b6471423b89c70a33d53654f3143292c15724dc", "commitAfterChange": "dbb5484f1c0506305bb2de3acc0db3501ec7c329", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 15, "signatureBeforeChange": " private static void initVersion(StringBuffer buffer)", "signatureAfterChange": " private static void initVersion()", "diff": ["-private static void initVersion(StringBuffer buffer) {", "-\tBufferedReader buildnotesReader;", "-    try {", "-\t\tURL platformURL = Platform.getBundle(\"org.eclipse.jdt.core\").getEntry(\"/\");", "-\t\tString path = new File(FileLocator.toFileURL(platformURL).getFile(), \"buildnotes_jdt-core.html\").getAbsolutePath();", "-\t    buildnotesReader = new BufferedReader(new InputStreamReader(new FileInputStream(path)));", "-    } catch (IOException ioe) {", "-\t    ioe.printStackTrace();", "-\t    return;", "-    }", "-\tString line;", "-\tString patch_line = null;", "-\tJDT_CORE_HEAD = true;", "-\ttry {", "-\t\twhile ((line = buildnotesReader.readLine()) != null) {", "-\t\t\tif (line.startsWith(\"<a name=\\\"\")) {", "-\t\t\t\tboolean first = JDT_CORE_VERSION == null;", "-\t\t\t\tJDT_CORE_VERSION = line.substring(line.indexOf('\"')+1, line.lastIndexOf('\"'));", "-\t\t\t\tif (!first) break;", "-\t\t\t} else if (line.startsWith(\"Eclipse SDK \")) {", "-\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(line);", "-\t\t\t\ttokenizer.nextToken(); // 'Eclipse'", "-\t\t\t\ttokenizer.nextToken(); // 'SDK'", "-\t\t\t\tString milestone = tokenizer.nextToken();", "-\t\t\t\tECLIPSE_VERSION = \"v\"+milestone.charAt(0)+milestone.charAt(2);", "-\t\t\t\tECLIPSE_MILESTONE = milestone.substring(3);", "-\t\t\t\ttokenizer.nextToken(); // '-'", "-\t\t\t\tJDT_CORE_HEAD = tokenizer.nextToken().equals(\"%date%\");", "-\t\t\t} else if (line.startsWith(\"<h2>What's new\")) {", "-\t\t\t\tline = buildnotesReader.readLine();", "-\t\t\t\tif (line.startsWith(\"Patch\")) {", "-\t\t\t\t\tpatch_line = line;", "+private static void initVersion() {", "+\tif (JDT_CORE_VERSION == null) {", "+\t\tBufferedReader buildnotesReader;", "+\t    try {", "+\t\t\tURL platformURL = Platform.getBundle(\"org.eclipse.jdt.core\").getEntry(\"/\");", "+\t\t\tString path = new File(FileLocator.toFileURL(platformURL).getFile(), \"buildnotes_jdt-core.html\").getAbsolutePath();", "+\t\t    buildnotesReader = new BufferedReader(new InputStreamReader(new FileInputStream(path)));", "+\t    } catch (IOException ioe) {", "+\t\t    ioe.printStackTrace();", "+\t\t    return;", "+\t    }", "+\t\tString line;", "+\t\tJDT_CORE_HEAD = true;", "+\t\ttry {", "+\t\t\twhile ((line = buildnotesReader.readLine()) != null) {", "+\t\t\t\tif (line.startsWith(\"<a name=\\\"\")) {", "+\t\t\t\t\tboolean first = JDT_CORE_VERSION == null;", "+\t\t\t\t\tJDT_CORE_VERSION = line.substring(line.indexOf('\"')+1, line.lastIndexOf('\"'));", "+\t\t\t\t\tif (!first) break;", "+\t\t\t\t} else if (line.startsWith(\"Eclipse SDK \")) {", "-\t\t\t\t\ttokenizer.nextToken(); // 'Patch'", "-\t\t\t\t\tPATCH_VERSION = tokenizer.nextToken();", "-\t\t\t\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\t\t\t\tPATCH_BUG = tokenizer.nextToken();", "-\t\t\t\t\t}", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tInteger.parseInt(PATCH_BUG);", "-\t\t\t\t\t}", "-\t\t\t\t\tcatch (NumberFormatException nfe) {", "-\t\t\t\t\t\t// try to split", "-\t\t\t\t\t\tStringTokenizer bugTokenizer = new StringTokenizer(PATCH_BUG, \"+\");", "+\t\t\t\t\ttokenizer.nextToken(); // 'Eclipse'", "+\t\t\t\t\ttokenizer.nextToken(); // 'SDK'", "+\t\t\t\t\tString milestone = tokenizer.nextToken();", "+\t\t\t\t\tECLIPSE_VERSION = \"v\"+milestone.charAt(0)+milestone.charAt(2);", "+\t\t\t\t\tECLIPSE_MILESTONE = milestone.substring(3);", "+\t\t\t\t\ttokenizer.nextToken(); // '-'", "+\t\t\t\t\tJDT_CORE_HEAD = tokenizer.nextToken().equals(\"%date%\");", "+\t\t\t\t} else if (line.startsWith(\"<h2>What's new\")) {", "+\t\t\t\t\tline = buildnotesReader.readLine();", "+\t\t\t\t\tif (line.startsWith(\"Patch\")) {", "+\t\t\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(line);", "+\t\t\t\t\t\ttokenizer.nextToken(); // 'Patch'", "+\t\t\t\t\t\tPATCH_VERSION = tokenizer.nextToken();", "+\t\t\t\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\t\tPATCH_BUG = tokenizer.nextToken();", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\twhile (bugTokenizer.hasMoreTokens()) {", "-\t\t\t\t\t\t\t\tInteger.parseInt(bugTokenizer.nextToken());", "+\t\t\t\t\t\t\tInteger.parseInt(PATCH_BUG);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcatch (NumberFormatException nfe) {", "+\t\t\t\t\t\t\t// try to split", "+\t\t\t\t\t\t\tStringTokenizer bugTokenizer = new StringTokenizer(PATCH_BUG, \"+\");", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\twhile (bugTokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\t\t\t\tInteger.parseInt(bugTokenizer.nextToken());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcatch (NumberFormatException nfe2) {", "+\t\t\t\t\t\t\t\tSystem.err.println(\"Invalid patch bug number noticed in JDT/Core buildnotes: \"+PATCH_BUG);", "-\t\t\t\t\t\tcatch (NumberFormatException nfe2) {", "-\t\t\t\t\t\t\tSystem.err.println(\"Invalid patch bug number noticed in JDT/Core buildnotes: \"+PATCH_BUG);", "-\t\t\t\t\t\t}", "+\t\t\t\t\tif (!JDT_CORE_HEAD) break;", "-\t\t\t\tif (!JDT_CORE_HEAD) break;", "+\t\t} catch (Exception e) {", "+\t\t\ttry {", "+\t\t        buildnotesReader.close();", "+\t        } catch (IOException ioe) {", "+\t\t        ioe.printStackTrace();", "+\t        }", "-\t} catch (Exception e) {", "-\t\ttry {", "-\t        buildnotesReader.close();", "-        } catch (IOException ioe) {", "-\t        ioe.printStackTrace();", "-        }", "-", "-\t// Log version info", "-\tbuffer.append(\"Version   : \");", "-\tif (PATCH_BUG != null) {", "-\t\tbuffer.append('\\'');", "-\t\tbuffer.append(patch_line);", "-\t\tbuffer.append(\"' applied on \");", "-\t}", "-\tif (JDT_CORE_HEAD) {", "-\t\tbuffer.append(\"HEAD on top of \");", "-\t}", "-\tbuffer.append(JDT_CORE_VERSION);", "-\tbuffer.append(LINE_SEPARATOR);"]}], "num": 44573}