{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "739563335f3b32509b2df1595f9a3c61", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24db879ab3e8bf057c14c4e8d9a26b7b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java", "commitBeforeChange": "bb161cc0f24c88013c90d4f52d2200284e6436fc", "commitAfterChange": "2f5fd18c93661c661012397a8eb704f52a56558d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, final Openable openable)", "signatureAfterChange": " \tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable)", "diff": ["-\tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, final Openable openable) {", "+\tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable) {", "-\t\t\tIJavaElement currentElement = openable;", "-\t\t\tHashSet knownElements = new HashSet();", "+\t\t    ASTNode[] nodeStack = new ASTNode[10];", "+\t\t    int nodeIndex = -1;", "+\t\t    public void push(ASTNode node) {", "+\t\t        try {", "+\t\t            this.nodeStack[++this.nodeIndex] = node;", "+\t\t        } catch (IndexOutOfBoundsException e) {", "+\t\t            System.arraycopy(this.nodeStack, 0, this.nodeStack = new ASTNode[this.nodeStack.length*2], 0, this.nodeIndex-1);", "+\t\t            this.nodeStack[this.nodeIndex] = node;", "+\t\t        }", "+\t\t    }", "+\t\t    ", "+\t\t    public void pop(ASTNode node) {", "+\t\t    \twhile (this.nodeIndex >= 0 && this.nodeStack[this.nodeIndex--] != node);", "+\t\t    }", "+\t\t    ", "-\t\t\t\tif (node == toBeFound) {", "-\t\t\t\t\tcurrentElement = ", "-\t\t\t\t\t\tnew LocalVariable(", "-\t\t\t\t\t\t\t(JavaElement)currentElement, ", "-\t\t\t\t\t\t\tnew String(node.name), ", "-\t\t\t\t\t\t\tnode.declarationSourceStart,", "-\t\t\t\t\t\t\tnode.declarationSourceEnd,", "-\t\t\t\t\t\t\tnode.sourceStart,", "-\t\t\t\t\t\t\tnode.sourceEnd,", "-\t\t\t\t\t\t\tUtil.typeSignature(node.type));", "-\t\t\t\t\t// NB: no need to update occurence count as the variable is defined by its positions", "-\t\t\t\t\tthrow new EndVisit();", "-\t\t\t\t}", "+\t\t\t    push(node);", "+\t\t\t\tif (node == toBeFound) throw new EndVisit();", "+\t\t\tpublic void endVisit(Argument node, BlockScope scope) {", "+\t\t\t    pop(node);", "+            }", "-\t\t\t\tcurrentElement = ", "-\t\t\t\t\t((IType)currentElement).getMethod(", "-\t\t\t\t\t\tcurrentElement.getElementName(), ", "-\t\t\t\t\t\tUtil.typeParameterSignatures(node));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\t\tcurrentElement = ((IType)currentElement).getField(new String(node.name));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t    pop(node);", "-\t\t\t\tcurrentElement = updateOccurenceCount(((IType)currentElement).getInitializer(1));", "+\t\t\t    push(node);", "-\t\t\tpublic void endVisit(Initializer node, MethodScope scope) {", "-\t\t\t\tcurrentElement = currentElement.getParent();", "-\t\t\t}", "+\t\t\t// don't pop initializers (used to count how many occurrences are in the type)", "-\t\t\t\tif (node == toBeFound) {", "-\t\t\t\t\tcurrentElement = ", "-\t\t\t\t\t\tnew LocalVariable(", "-\t\t\t\t\t\t\t(JavaElement)currentElement, ", "-\t\t\t\t\t\t\tnew String(node.name), ", "-\t\t\t\t\t\t\tnode.declarationSourceStart,", "-\t\t\t\t\t\t\tnode.declarationSourceEnd,", "-\t\t\t\t\t\t\tnode.sourceStart,", "-\t\t\t\t\t\t\tnode.sourceEnd,", "-\t\t\t\t\t\t\tUtil.typeSignature(node.type));", "-\t\t\t\t\t// NB: no need to update occurence count as the variable is defined by its positions", "-\t\t\t\t\tthrow new EndVisit();", "-\t\t\t\t}", "+\t\t\t    push(node);", "+\t\t\t\tif (node == toBeFound) throw new EndVisit();", "+\t\t\tpublic void endVisit(LocalDeclaration node, BlockScope scope) {", "+\t\t\t    pop(node);", "+            }", "-\t\t\t\tif ((node.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "-\t\t\t\t\tcurrentElement = updateOccurenceCount(((IMember)currentElement).getType(\"\", 1)); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = updateOccurenceCount(((IMember)currentElement).getType(new String(node.name), 1));", "-\t\t\t\t}", "+\t\t\t    push(node);", "-\t\t\t\t\tcurrentElement = ((IType)currentElement).getDeclaringType();", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\t    pop(node);", "+\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the method)", "-\t\t\t\tcurrentElement = ((IType)currentElement).getType(new String(node.name));", "+\t\t\t    push(node);", "-\t\t\t\t\tcurrentElement = ((IType)currentElement).getDeclaringType();", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\t    pop(node);", "+\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the initializer)", "-\t\t\t\tcurrentElement = ", "-\t\t\t\t\t((IType)currentElement).getMethod(", "-\t\t\t\t\t\tnew String(node.selector), ", "-\t\t\t\t\t\tUtil.typeParameterSignatures(node));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\t\tif (currentElement instanceof ICompilationUnit) {", "-\t\t\t\t\tcurrentElement = ((ICompilationUnit)currentElement).getType(new String(node.name));", "-\t\t\t\t} else {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tcurrentElement = ((IClassFile)currentElement).getType();", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t// class file doesn't exit: ignore", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\tprivate IJavaElement updateOccurenceCount(IJavaElement element) {", "-\t\t\t\twhile (knownElements.contains(element)) {", "-\t\t\t\t\t((JavaElement)element).occurrenceCount++;", "-\t\t\t\t}", "-\t\t\t\tknownElements.add(element);", "-\t\t\t\treturn element;", "-\t\t\t}", "-\t\t\treturn visitor.currentElement;", "+\t\t    ASTNode[] nodeStack = visitor.nodeStack;", "+\t\t    int end = visitor.nodeIndex;", "+\t\t    int start = 0;", "+\t\t    ", "+\t\t    // find the inner most type declaration if binary type", "+\t\t    ASTNode typeDecl = null;", "+\t\t    if (openable instanceof ClassFile) {", "+\t\t\t\tfor (int i = end; i >= 0; i--) {", "+\t\t\t\t    if (nodeStack[i] instanceof TypeDeclaration) {", "+\t\t\t\t        typeDecl = nodeStack[i];", "+\t\t\t\t        start = i;", "+\t\t\t\t        break;", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t    }", "+\t\t\t", "+\t\t\t// find the openable corresponding to this type declaration", "+\t\t\tif (typeDecl != null) {", "+\t\t\t    openable = getOpenable(typeDecl, openable);", "+\t\t\t}", "+\t\t\t", "+\t\t\treturn createElement(nodeStack, start, end, openable);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa76def2cd81f9dc10372f41fa073d2c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java", "commitBeforeChange": "287a8246425dec3b8e6cdd428f661326776e45cd", "commitAfterChange": "058b7e49b52c7b18f15a01083d7620b3d5aa8490", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable)", "signatureAfterChange": " \tpublic IJavaElement createElement(ClassScope scope, ICompilationUnit unit, HashSet existingElements, HashMap knownScopes)", "diff": ["-\t */", "-\tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable) {", "-\t\tclass EndVisit extends RuntimeException {", "-\t\t\t// marker to stop traversing ast", "-\t\t\tprivate static final long serialVersionUID = 7264372508108115988L; // backward compatible", "-\t\t}", "-\t\tclass Visitor extends ASTVisitor {", "-\t\t    ASTNode[] nodeStack = new ASTNode[10];", "-\t\t    int nodeIndex = -1;", "-\t\t\t", "-\t\t    public void push(ASTNode node) {", "-\t\t    \tif (++this.nodeIndex >= this.nodeStack.length) ", "-\t\t            System.arraycopy(this.nodeStack, 0, this.nodeStack = new ASTNode[this.nodeStack.length*2], 0, this.nodeIndex);", "-\t            this.nodeStack[this.nodeIndex] = node;", "-\t\t    }", "-\t\t    ", "-\t\t    public void pop(ASTNode node) {", "-\t\t    \twhile (this.nodeIndex >= 0 && this.nodeStack[this.nodeIndex--] != node){/*empty*/}", "-\t\t    }", "-\t\t    ", "-\t\t\tpublic boolean visit(Argument node, BlockScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(Argument node, BlockScope scope) {", "-\t\t\t    pop(node);", "-            }", "-", "-\t\t\tpublic boolean visit(ConstructorDeclaration node, ClassScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(ConstructorDeclaration node, ClassScope scope) {", "-\t\t\t\tpop(node);", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(FieldDeclaration node, MethodScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(FieldDeclaration node, MethodScope scope) {", "-\t\t\t    pop(node);", "-\t\t\t}", "-", "-\t\t\tpublic boolean visit(Initializer node, MethodScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\t// don't pop initializers (used to count how many occurrences are in the type)", "-", "-\t\t\tpublic boolean visit(LocalDeclaration node, BlockScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(LocalDeclaration node, BlockScope scope) {", "-\t\t\t    pop(node);", "-            }", "-", "-\t\t\tpublic boolean visit(TypeDeclaration node, BlockScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(TypeDeclaration node, BlockScope scope) {", "-\t\t\t\tif ((node.bits & ASTNode.IsMemberTypeMASK) != 0) {", "-\t\t\t\t    pop(node);", "-\t\t\t\t}", "-\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the method)", "-\t\t\t}", "-", "-\t\t\tpublic boolean visit(TypeDeclaration node, ClassScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(TypeDeclaration node, ClassScope scope) {", "-\t\t\t\tif ((node.bits & ASTNode.IsMemberTypeMASK) != 0) {", "-\t\t\t\t    pop(node);", "-\t\t\t\t}", "-\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the initializer)", "-\t\t\t}", "-\t\t\t\t\t\t", "-\t\t\tpublic boolean visit(MethodDeclaration node, ClassScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(MethodDeclaration node, ClassScope scope) {", "-\t\t\t\tpop(node);", "-\t\t\t}", "-\t\t\t", "-\t\t\tpublic boolean visit(TypeDeclaration node, CompilationUnitScope scope) {", "-\t\t\t    push(node);", "-\t\t\t\tif (node == toBeFound) throw new EndVisit();", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t\tpublic void endVisit(TypeDeclaration node, CompilationUnitScope scope) {", "-\t\t\t\tpop(node);", "-\t\t\t}", "-\t\t}", "-\t\tVisitor visitor = new Visitor();", "-\t\ttry {", "-\t\t\tparsedUnit.traverse(visitor, parsedUnit.scope);", "-\t\t} catch (EndVisit e) {", "-\t\t    ASTNode[] nodeStack = visitor.nodeStack;", "-\t\t    int end = visitor.nodeIndex;", "-\t\t    int start = 0;", "-\t\t    ", "-\t\t    // find the inner most type declaration if binary type", "-\t\t    ASTNode typeDecl = null;", "-\t\t    if (openable instanceof ClassFile) {", "-\t\t\t\tfor (int i = end; i >= 0; i--) {", "-\t\t\t\t    if (nodeStack[i] instanceof TypeDeclaration) {", "-\t\t\t\t        typeDecl = nodeStack[i];", "-\t\t\t\t        start = i;", "-\t\t\t\t        break;", "-\t\t\t\t    }", "-\t\t\t\t}", "-\t\t    }", "-\t\t\t", "-\t\t\t// find the openable corresponding to this type declaration", "-\t\t\tif (typeDecl != null) {", "-\t\t\t    openable = getOpenable(typeDecl, openable);", "-\t\t\t}", "-\t\t\t", "-\t\t\treturn createElement(nodeStack, start, end, openable);", "-\t\t}", "-\t\treturn null;", "-\t}"]}], "num": 16581}