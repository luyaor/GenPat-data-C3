{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cf6b4ba8c7145e44056f3a9ae48da196", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5244886f80adf152c8162889307de201", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java", "commitBeforeChange": "e0048708b1f289d431c0dd85e7c6b6e3c3eaa0d5", "commitAfterChange": "67af3f8a85df293ff8ca16e3b23c249a593b75c2", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "signatureAfterChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "diff": ["-\t\t/* Next, try deletion of the error token, preferring deletion as a criteria in", "-\t\t   case of identical, superfluous keyword tokens. See below.", "-\t\t*/", "+\t\t//", "+\t\t// Next, try deletion of the error token.", "+\t\t//", "-\t\t} else if (j == repair.distance) {", "-\t\t\t/* Handle some cases where deletion as a repair strategy is obviously superior to", "-\t\t\t   others. e.g: Object o = new new Object() {}; For some reason, with the new grammar", "-\t\t\t   rules to support type annotations in place, the scopeTrial's choice above wins out", "-\t\t\t   with the repair strategy being to insert a semicolon after the first new. That looks", "-\t\t\t   very suspicious. It is not clear if that is due to the bug in the implementation of", "-\t\t\t   scopeTrial or in the jikespg parser generator or in the grammar.", "-\t\t\t", "-\t\t\t   The current fix is a temporary point-fix to address this problem. It does make sense", "-\t\t\t   as a rule, but is a bit ad-hoc in nature and the reason why scopeTrial succeeds needs", "-\t\t\t   to be understood.", "-\t\t\t*/", "-\t\t\tLexStream.Token previousToken = this.lexStream.token(repair.bufferPosition + 1);", "-\t\t\tLexStream.Token curToken = this.lexStream.token(repair.bufferPosition + 2);", "-\t\t\tif (previousToken != null && curToken != null && previousToken.kind == curToken.kind && Scanner.isKeyword(curToken.kind)) {", "-\t\t\t\trepair.misspellIndex = k;", "-\t\t\t\trepair.code = DELETION_CODE;", "-\t\t\t\trepair.distance = j;", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ae0a984bf73990fd03414726c8dacf2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java", "commitBeforeChange": "a11ec54f2e1e149e77b968382e79f482cc29add9", "commitAfterChange": "831d96bc5763622ed503192c35bfd6688abedd96", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "signatureAfterChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "diff": ["-\t\t//", "-\t\t// Next, try deletion of the error token.", "-\t\t//", "+\t\t/* Next, try deletion of the error token, preferring deletion as a criteria in", "+\t\t   case of identical, superfluous keyword tokens. See below.", "+\t\t*/", "+\t\t} else if (j == repair.distance) {", "+\t\t\t/* Handle some cases where deletion as a repair strategy is obviously superior to", "+\t\t\t   others. e.g: Object o = new new Object() {}; For some reason, with the new grammar", "+\t\t\t   rules to support type annotations in place, the scopeTrial's choice above wins out", "+\t\t\t   with the repair strategy being to insert a semicolon after the first new. That looks", "+\t\t\t   very suspicious. It is not clear if that is due to the bug in the implementation of", "+\t\t\t   scopeTrial or in the jikespg parser generator or in the grammar.", "+\t\t\t", "+\t\t\t   The current fix is a temporary point-fix to address this problem. It does make sense", "+\t\t\t   as a rule, but is a bit ad-hoc in nature and the reason why scopeTrial succeeds needs", "+\t\t\t   to be understood.", "+\t\t\t*/", "+\t\t\tLexStream.Token previousToken = this.lexStream.token(repair.bufferPosition + 1);", "+\t\t\tLexStream.Token curToken = this.lexStream.token(repair.bufferPosition + 2);", "+\t\t\tif (previousToken != null && curToken != null && previousToken.kind == curToken.kind && Scanner.isKeyword(curToken.kind)) {", "+\t\t\t\trepair.misspellIndex = k;", "+\t\t\t\trepair.code = DELETION_CODE;", "+\t\t\t\trepair.distance = j;", "+\t\t\t}"]}], "num": 7364}