{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "65f58797c5a96565ae0a60acd25de784", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "509c96effce07a452f6cac20ce74a6a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  String[] directoryList(String qualifiedPackageName)", "signatureAfterChange": "  String[] directoryList(String qualifiedPackageName)", "diff": ["-\tFile dir = new File(binaryPath + qualifiedPackageName);", "-\tnotFound : if (dir != null && dir.isDirectory()) {", "-\t\t// must protect against a case insensitive File call", "-\t\t// walk the qualifiedPackageName backwards looking for an uppercase character before the '/'", "-\t\tint index = qualifiedPackageName.length();", "-\t\tint last = qualifiedPackageName.lastIndexOf('/');", "-\t\twhile (--index > last && !Character.isUpperCase(qualifiedPackageName.charAt(index))) {}", "-\t\tif (index > last) {", "-\t\t\tif (last == -1) {", "-\t\t\t\tif (!doesFileExist(qualifiedPackageName, \"\")) //$NON-NLS-1$ ", "-\t\t\t\t\tbreak notFound;", "-\t\t\t} else {", "-\t\t\t\tString packageName = qualifiedPackageName.substring(last + 1);", "-\t\t\t\tString parentPackage = qualifiedPackageName.substring(0, last);", "-\t\t\t\tif (!doesFileExist(packageName, parentPackage))", "-\t\t\t\t\tbreak notFound;", "+\ttry {", "+\t\tIResource folder = binaryFolder.findMember(qualifiedPackageName); // this is a case-sensitive check", "+\t\tif (folder != null && folder.getType() == IResource.FOLDER) {", "+\t\t\tIResource[] members = ((IFolder) folder).members();", "+\t\t\tdirList = new String[members.length];", "+\t\t\tint index = 0;", "+\t\t\tfor (int i = 0, l = members.length; i < l; i++) {", "+\t\t\t\tIResource m = members[i];", "+\t\t\t\tif (m.getType() == IResource.FILE && JavaBuilder.CLASS_EXTENSION.equalsIgnoreCase(m.getFileExtension()))", "+\t\t\t\t\t// add exclusion pattern check here if we want to hide .class files", "+\t\t\t\t\tdirList[index++] = m.getName();", "+\t\t\tif (index < dirList.length)", "+\t\t\t\tSystem.arraycopy(dirList, 0, dirList = new String[index], 0, index);", "+\t\t\tdirectoryCache.put(qualifiedPackageName, dirList);", "+\t\t\treturn dirList;", "-\t\tif ((dirList = dir.list()) == null)", "-\t\t\tdirList = new String[0];", "-\t\tdirectoryCache.put(qualifiedPackageName, dirList);", "-\t\treturn dirList;", "+\t} catch(CoreException ignored) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a881aa513d86ed728d30054b59b3aab0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java", "commitBeforeChange": "06f23e3e171e1532838272ad3cfed1dbf476c295", "commitAfterChange": "fd83708e4f6c48e5f68b55d90ce222d8723ca6ce", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r String[] directoryList(String qualifiedPackageName)", "signatureAfterChange": "\r private String[] directoryList(char[][] compoundName, char[] packageName)", "diff": ["-String[] directoryList(String qualifiedPackageName) {\r", "-\tString[] dirList = (String[]) directoryCache.get(qualifiedPackageName);\r", "-\tif (dirList == missingPackageHolder) return null; // package exists in another classpath directory or jar\r", "-\tif (dirList != null) return dirList;\r", "-\r", "-\tFile dir = new File(path + qualifiedPackageName);\r", "-\tnotFound : if (dir != null && dir.isDirectory()) {\r", "-\t\t// must protect against a case insensitive File call\r", "-\t\t// walk the qualifiedPackageName backwards looking for an uppercase character before the '/'\r", "-\t\tint index = qualifiedPackageName.length();\r", "-\t\tint last = qualifiedPackageName.lastIndexOf('/');\r", "-\t\twhile (--index > last && !Character.isUpperCase(qualifiedPackageName.charAt(index))) {}\r", "-\t\tif (index > last) {\r", "-\t\t\tif (last == -1) {\r", "-\t\t\t\tif (!doesFileExist(qualifiedPackageName, \"\"))\r", "-\t\t\t\t\tbreak notFound;\r", "-\t\t\t} else {\r", "-\t\t\t\tString packageName = qualifiedPackageName.substring(last + 1);\r", "-\t\t\t\tString parentPackage = qualifiedPackageName.substring(0, last);\r", "-\t\t\t\tif (!doesFileExist(packageName, parentPackage))\r", "-\t\t\t\t\tbreak notFound;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tif ((dirList = dir.list()) == null)\r", "-\t\t\tdirList = new String[0];\r", "-\t\tdirectoryCache.put(qualifiedPackageName, dirList);\r", "+private String[] directoryList(char[][] compoundName, char[] packageName) {\r", "+\tString partialPath = FileSystem.assembleName(packageName, compoundName, File.separatorChar);\r", "+\tString[] dirList = (String[])directoryCache.get(partialPath);\r", "+\tif (dirList != null)\r", "+\tif (missingPackages.containsKey(partialPath))\r", "+\t\treturn null;\r", "+\r", "+\tFile dir = new File(path + partialPath);\r", "+\tif (dir != null && dir.isDirectory()) {\r", "+\t\tboolean matchesName = packageName == null;\r", "+\t\tif (!matchesName) {\r", "+\t\t\tint index = packageName.length;\r", "+\t\t\twhile (--index >= 0 && !Character.isUpperCase(packageName[index])) {}\r", "+\t\t\tmatchesName = index < 0 || exists(new String(packageName), compoundName); // verify that the case sensitive packageName really does exist\r", "+\t\t}\r", "+\t\tif (matchesName) {\r", "+\t\t\tif ((dirList = dir.list()) == null)\r", "+\t\t\t\tdirList = new String[0];\r", "+\t\t\tdirectoryCache.put(partialPath, dirList);\r", "+\t\t\treturn dirList;\r", "+\t\t}\r", "-\tdirectoryCache.put(qualifiedPackageName, missingPackageHolder);\r", "+\tmissingPackages.put(partialPath, partialPath); // value is not used\r"]}], "num": 57837}