{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d5e07e1536faf595965081b098ec43db", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "015ef4cbf2f0a15108d550749546005f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope scope)", "signatureAfterChange": " \t \tpublic void resolve(BlockScope scope)", "diff": ["-\t\t\tTypeBinding[] argTypes = NoParameters;", "+\t\t\tTypeBinding[] argumentTypes = NoParameters;", "+\t\t\tboolean argsContainCast = false;", "-\t\t\t\targTypes = new TypeBinding[length];", "-\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\tif ((argTypes[i] = arguments[i].resolveType(scope)) == null)", "+\t\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\t\t\targsContainCast = true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t\tif (argHasError)", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (argHasError) {", "+\t\t\t\t}", "-\t\t\tif ((binding = scope.getConstructor(receiverType, argTypes, this))", "-\t\t\t\t.isValidBinding()) {", "+\t\t\tif ((binding = scope.getConstructor(receiverType, argumentTypes, this)).isValidBinding()) {", "-\t\t\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\t\t\targuments[i].implicitWidening(paramTypes[i], argTypes[i]);", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\targuments[i].implicitWidening(paramTypes[i], argumentTypes[i]);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (argsContainCast) {", "+\t\t\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, receiverType, binding, this.arguments, argumentTypes, this);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0495b5a070b3c45fec278aadef4e1a17", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tboolean argsContainCast = false; ", "-\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null){", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\targsContainCast = true;", "+\t\t\t}", "+\t\t\tif ((argumentTypes[i] = argument.resolveType(scope)) == null){", "-\t\tif (argHasError){", "+\t\tif (argHasError) {", "-\tif (arguments != null)", "-\t\tfor (int i = 0; i < arguments.length; i++)", "+\tif (arguments != null) {", "+\t\tfor (int i = 0; i < arguments.length; i++) {", "-", "+\t\t}", "+\t\tif (argsContainCast) {", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, this.receiver, (ReferenceBinding)receiverType, binding, this.arguments, argumentTypes, this);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7f085ec53444d164e015c72b1bfac40", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "3b6218bf29a9e110fd6530cc102e5abb2713eb28", "commitAfterChange": "fdc78eae04c092b433b059502afa80612c96fda8", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "diff": ["-\t\tTypeBinding[] parameterTypes = binding.parameters;", "+\t\t// iterate over arguments, and retrieve original argument types (before cast)", "+\t\tTypeBinding[] rawArgumentTypes = argumentTypes;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\tTypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;", "+\t\t\t\t// obvious identity cast", "+\t\t\t\tif (castedExpressionType == argumentTypes[i]) { ", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)argument);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (rawArgumentTypes == argumentTypes) {", "+\t\t\t\t\t\tSystem.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);", "+\t\t\t\t\t}", "+\t\t\t\t\t// retain original argument type", "+\t\t\t\t\trawArgumentTypes[i] = castedExpressionType; ", "+\t\t\t\t}", "+\t\t\t}\t\t\t\t", "+\t\t}", "+\t\t// perform alternate lookup with original types", "+\t\tif (rawArgumentTypes != argumentTypes) {", "+\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);", "+\t\t}", "+/* alternate implementation performing 2 passes of alternate lookup, once for widening casts, once for narrowing casts", "-\t\t\t\tif (castedExpressionType == parameterTypes[i]) { ", "+\t\t\t\tif (castedExpressionType == argumentTypes[i]) { ", "+*/"]}], "num": 69678}