{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "32c36245f25ef22f30e112a264740810", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1650ae36e40c487693a04b8450d20798", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java", "commitBeforeChange": "9d422f535f1cf1a8b8f8401815db736b124961e4", "commitAfterChange": "13ebf03f7d31f9fda8d23c3fe70da0f01fcad14a", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public void activateProcessing()", "signatureAfterChange": "  public synchronized void aboutToUpdateIndex(IPath path, Integer newIndexState)", "diff": ["- */", "-public void activateProcessing() {", "-\ttry {", "-\t\tThread.sleep(10000); // wait 10 seconds so as not to interfere with plugin startup", "-\t} catch (InterruptedException ie) {", "-\t}\t", "-\tcheckIndexConsistency();", "-\tsuper.activateProcessing();", "-}", "+", "+public synchronized void aboutToUpdateIndex(IPath path, Integer newIndexState) {", "+\t// newIndexState is either UPDATING_STATE or REBUILDING_STATE", "+\t// must tag the index as inconsistent, in case we exit before the update job is started", "+\tString indexName = computeIndexName(path);", "+\tObject state = getIndexStates().get(indexName);", "+\tInteger currentIndexState = state == null ? UNKNOWN_STATE : (Integer) state;", "+", "+\tint compare = newIndexState.compareTo(currentIndexState);", "+\tif (compare > 0) {", "+\t\t// so UPDATING_STATE replaces SAVED_STATE and REBUILDING_STATE replaces everything", "+\t\tupdateIndexState(indexName, newIndexState);", "+\t} else if (compare < 0 && this.indexes.get(path) == null) {", "+\t\t// if already cached index then there is nothing more to do", "+\t\trebuildIndex(indexName, path);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3015ae51f0a0dfb71531ead5e965638", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "4b1cb82b00b0f3c43755c37280deb732ae600c1a", "commitAfterChange": "1caf2b41c370e66c328190589dd64f01b35d7384", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean denyEnclosingArgInConstructorCall)", "diff": ["-\t\t\tboolean ignoreEnclosingArgInConstructorCall) {", "+\t\t\tboolean denyEnclosingArgInConstructorCall) {", "-\t\tif (!currentMethodScope.isConstructorCall && !currentMethodScope.isStatic) {", "+\t\tif (!currentMethodScope.isStatic && !currentMethodScope.isConstructorCall) {", "-\t\t\t\tif (ignoreEnclosingArgInConstructorCall ", "+\t\t\t\tif (denyEnclosingArgInConstructorCall", "+\t\tif (sourceType.isAnonymousType()) {", "+\t\t\tReferenceBinding enclosingType = sourceType.enclosingType();", "+\t\t\tif (enclosingType.isNestedType()) {", "+\t\t\t\tNestedTypeBinding nestedEnclosingType = (NestedTypeBinding) enclosingType;", "+\t\t\t\tSyntheticArgumentBinding enclosingArgument = nestedEnclosingType.getSyntheticArgument(nestedEnclosingType.enclosingType(), onlyExactMatch);", "+\t\t\t\tif (enclosingArgument != null) {", "+\t\t\t\t\tFieldBinding syntheticField = sourceType.getSyntheticField(enclosingArgument);", "+\t\t\t\t\tif (syntheticField != null) {", "+\t\t\t\t\t\tif (syntheticField.type == targetEnclosingType || (!onlyExactMatch && ((ReferenceBinding)syntheticField.type).findSuperTypeErasingTo(targetEnclosingType) != null))", "+\t\t\t\t\t\t\treturn new Object[] { syntheticField };", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+"]}], "num": 57763}