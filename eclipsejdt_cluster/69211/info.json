{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dcd037edb4ce04672ad93d5d0875c1e7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4828bb5da696da568d771e406ec4807d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["+}\r", "+public TypeBinding resolveType(BlockScope scope) {\r", "+\t// Answer the signature return type\r", "+\t// Base type promotion\r", "+\tconstant = NotAConstant;\r", "+\tthis.receiverType = receiver.resolveType(scope); \r", "+\t// will check for null after args are resolved\r", "+\tTypeBinding[] argumentTypes = NoParameters;\r", "+\tif (arguments != null) {\r", "+\t\tboolean argHasError = false; // typeChecks all arguments \r", "+\t\tint length = arguments.length;\r", "+\t\targumentTypes = new TypeBinding[length];\r", "+\t\tfor (int i = 0; i < length; i++)\r", "+\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "+\t\t\t\targHasError = true;\r", "+\t\tif (argHasError)\r", "+\t\t\treturn null;\r", "+\t}\r", "+\tif (this.receiverType == null)\r", "+\t\treturn null;\r", "+\r", "+\t// base type cannot receive any message\r", "+\tif (this.receiverType.isBaseType()) {\r", "+\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);\r", "+\t\treturn null;\r", "+\t}\r", "+\r", "+\tbinding = \r", "+\t\treceiver == ThisReference.ThisImplicit\r", "+\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)\r", "+\t\t\t: scope.getMethod(this.receiverType, selector, argumentTypes, this); \r", "+\tif (!binding.isValidBinding()) {\r", "+\t\tif (binding.declaringClass == null) {\r", "+\t\t\tif (this.receiverType instanceof ReferenceBinding) {\r", "+\t\t\t\tbinding.declaringClass = (ReferenceBinding) this.receiverType;\r", "+\t\t\t} else { // really bad error ....\r", "+\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.receiverType, argumentTypes);\r", "+\t\t\t\treturn null;\r", "+\t\t}\r", "+\t\tscope.problemReporter().invalidMethod(this, binding);\r", "+\t\treturn null;\r", "+\t}\r", "+\tif (!binding.isStatic()) {\r", "+\t\t// the \"receiver\" must not be a type, i.e. a NameReference that the TC has bound to a Type\r", "+\t\tif (receiver instanceof NameReference) {\r", "+\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {\r", "+\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);\r", "+\t\t\t\treturn null;\r", "+\tif (arguments != null)\r", "+\t\tfor (int i = 0; i < arguments.length; i++)\r", "+\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "-\tpublic TypeBinding resolveType(BlockScope scope) {\r", "-\t\t// Answer the signature return type\r", "-\t\t// Base type promotion\r", "-\r", "-\t\tconstant = NotAConstant;\r", "-\t\tTypeBinding receiverType = receiver.resolveType(scope);\r", "-\t\t// will check for null after args are resolved\r", "-\t\tTypeBinding[] argumentTypes = NoParameters;\r", "+\t//-------message send that are known to fail at compile time-----------\r", "+\tif (binding.isAbstract()) {\r", "+\t\tif (receiver.isSuper()) {\r", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\t\t// abstract private methods cannot occur nor abstract static............\r", "+\t}\r", "+\tif (isMethodUseDeprecated(binding, scope))\r", "+\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "+\t// if the binding declaring class is not visible, need special action\r", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\tif (binding.declaringClass != this.receiverType\r", "+\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "+\t\tbinding = new MethodBinding(binding, (ReferenceBinding) this.receiverType);\r", "+\treturn binding.returnType;\r", "+}\r", "-\t\t\tboolean argHasError = false; // typeChecks all arguments \r", "-\t\t\tint length = arguments.length;\r", "-\t\t\targumentTypes = new TypeBinding[length];\r", "-\t\t\tfor (int i = 0; i < length; i++)\r", "-\t\t\t\tif ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)\r", "-\t\t\t\t\targHasError = true;\r", "-\t\t\tif (argHasError)\r", "-\t\t\t\treturn null;\r", "-\t\t}\r", "-\t\tif (receiverType == null)\r", "-\t\t\treturn null;\r", "-\r", "-\t\t// base type cannot receive any message\r", "-\t\tif (receiverType.isBaseType()) {\r", "-\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\r", "-\t\tbinding =\r", "-\t\t\treceiver == ThisReference.ThisImplicit\r", "-\t\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)\r", "-\t\t\t\t: scope.getMethod(receiverType, selector, argumentTypes, this);\r", "-\t\tif (!binding.isValidBinding()) {\r", "-\t\t\tif (binding.declaringClass == null) {\r", "-\t\t\t\tif (receiverType instanceof ReferenceBinding) {\r", "-\t\t\t\t\tbinding.declaringClass = (ReferenceBinding) receiverType;\r", "-\t\t\t\t} else { // really bad error ....\r", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);\r", "-\t\t\t\t\treturn null;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tscope.problemReporter().invalidMethod(this, binding);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\tif (!binding.isStatic()) {\r", "-\t\t\t// the \"receiver\" must not be a type, i.e. a NameReference that the TC has bound to a Type\r", "-\t\t\tif (receiver instanceof NameReference) {\r", "-\t\t\t\tif ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {\r", "-\t\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);\r", "-\t\t\t\t\treturn null;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\tif (arguments != null)\r", "-\t\t\tfor (int i = 0; i < arguments.length; i++)\r", "-\t\t\t\targuments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);\r", "-\r", "-\t\t//-------message send that are known to fail at compile time-----------\r", "-\t\tif (binding.isAbstract()) {\r", "-\t\t\tif (receiver.isSuper()) {\r", "-\t\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t\t// abstract private methods cannot occur nor abstract static............\r", "-\t\t}\r", "-\t\tif (isMethodUseDeprecated(binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedMethod(binding, this);\r", "-\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\tif (binding.declaringClass != receiverType\r", "-\t\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "-\t\t\tbinding = new MethodBinding(binding, (ReferenceBinding) receiverType);\r", "-\t\treturn binding.returnType;\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4903b247a44d6c1fb8bd3ac438067b39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "b93a217fe6b68aa2016c37812b125d5d097ba1a3", "commitAfterChange": "1beaef02926dace59f07acb73879fd00f7c0b3eb", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprivate void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext)", "signatureAfterChange": "  \tprivate void computeNullStatus(FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext)", "diff": ["-\tprivate void computeNullStatus(int ifTrueNullStatus, FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {", "+\tprivate void computeNullStatus(FlowInfo trueBranchInfo, FlowInfo falseBranchInfo, FlowContext flowContext) {", "-\t\tif (ifTrueNullStatus == -1) { // has this status been pre-computed?", "-\t\t\tifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo, flowContext);", "+\t\tif (this.ifTrueNullStatus == -1) { // has this status been pre-computed?", "+\t\t\tthis.ifTrueNullStatus = this.valueIfTrue.nullStatus(trueBranchInfo, flowContext);", "-\t\tint ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo, flowContext);", "+\t\tthis.ifFalseNullStatus = this.valueIfFalse.nullStatus(falseBranchInfo, flowContext);", "-\t\tif (ifTrueNullStatus == ifFalseNullStatus) {", "-\t\t\tthis.nullStatus = ifTrueNullStatus;", "+\t\tif (this.ifTrueNullStatus == this.ifFalseNullStatus) {", "+\t\t\tthis.nullStatus = this.ifTrueNullStatus;", "-\t\t\tthis.nullStatus = ifFalseNullStatus;", "+\t\t\tthis.nullStatus = this.ifFalseNullStatus;", "-\t\t\tthis.nullStatus = ifTrueNullStatus;", "+\t\t\tthis.nullStatus = this.ifTrueNullStatus;", "-\t\tint combinedStatus = ifTrueNullStatus|ifFalseNullStatus;", "+\t\tint combinedStatus = this.ifTrueNullStatus|this.ifFalseNullStatus;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbb0887d4b5330e5521935588bc829a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionJavadocParser.java", "commitBeforeChange": "330aeaad59d1633d10c0cd3a9ee9ac57073b385f", "commitAfterChange": "960ce528d76bd309a28ce655fc14cff77629ffa5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int commentPtr)", "diff": ["-\tpublic boolean checkDeprecation(int javadocStart, int javadocEnd) {", "+\tpublic boolean checkDeprecation(int commentPtr) {", "-\t\tif (javadocStart <= this.selectionStart && this.selectionEnd <= javadocEnd) {", "+\t\tthis.javadocStart = this.sourceParser.scanner.commentStarts[commentPtr];", "+\t\tthis.javadocEnd = this.sourceParser.scanner.commentStops[commentPtr];", "+\t\tif (this.javadocStart <= this.selectionStart && this.selectionEnd <= this.javadocEnd) {", "-\t\t\tsuper.checkDeprecation(javadocStart, javadocEnd);", "+\t\t\tsuper.checkDeprecation(commentPtr);"]}], "num": 69211}