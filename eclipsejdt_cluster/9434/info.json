{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "90f97158e5d9ef378b29f67b3964aec5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04418621cd55016a72b31d8c8f4a35cb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "0e160bd57ca4572e4cc317f77eef59eff0c912a6", "commitAfterChange": "1b0238cbdda2702f17c4f0b30e4c8493818f8888", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic MethodBinding tiebreakMethod()", "signatureAfterChange": " \tpublic MethodBinding tiebreakMethod()", "diff": ["-\t\t\tthis.tiebreakMethod = this.isRaw ? this : new ParameterizedGenericMethodBinding(this.originalMethod, (RawTypeBinding)null, this.environment);", "+//\t\t\tif (this.isRaw) {", "+//\t\t\t\tthis.tiebreakMethod = this;", "+//\t\t\t} else {", "+//\t\t\t\tthis.tiebreakMethod = new ParameterizedGenericMethodBinding(this.originalMethod, (RawTypeBinding)null, this.environment);", "+\t\t\t\tTypeVariableBinding[] originalVariables = originalMethod.typeVariables;", "+\t\t\t\tint length = originalVariables.length;", "+\t\t\t\tTypeBinding[] rawArguments = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++)", "+\t\t\t\t\trawArguments[i] =  environment.convertToRawType(originalVariables[i].erasure());", "+\t\t\t\tthis.tiebreakMethod = new ParameterizedGenericMethodBinding(this.originalMethod, rawArguments, this.environment);", "+//\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d77f0f893f535c97b8feb3ea2d41ecb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "778e64a3c8e6903c625067607c9068d73d8cd5e5", "commitAfterChange": "e12812c02c749e710a55fe1f28fa9764f0ac6bd5", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " MethodBinding asRawMethod(LookupEnvironment env)", "signatureAfterChange": " MethodBinding asRawMethod(LookupEnvironment env)", "diff": ["-\t\t\tTypeBinding rawSuperclass = env.convertToRawType(var.superclass(), false);", "-\t\t\tTypeBinding[] rawSuperinterfaces = new TypeBinding[superLength];", "-\t\t\tfor (int s = 0; s < superLength; s++)", "-\t\t\t\trawSuperinterfaces[s] = env.convertToRawType(itsSuperinterfaces[s], false);", "-\t\t\targuments[i] = env.createWildcard(null, 0, rawSuperclass, rawSuperinterfaces, org.eclipse.jdt.internal.compiler.ast.Wildcard.EXTENDS);", "+\t\t\tTypeBinding rawFirstBound = null;", "+\t\t\tTypeBinding[] rawOtherBounds = null;", "+\t\t\tif (var.boundsCount() == superLength) {", "+\t\t\t\trawFirstBound = env.convertToRawType(itsSuperinterfaces[0], false);", "+\t\t\t\trawOtherBounds = new TypeBinding[superLength - 1];", "+\t\t\t\tfor (int s = 1; s < superLength; s++)", "+\t\t\t\t\trawOtherBounds[s - 1] = env.convertToRawType(itsSuperinterfaces[s], false);", "+\t\t\t} else {", "+\t\t\t\trawFirstBound = env.convertToRawType(var.superclass(), false);", "+\t\t\t\trawOtherBounds = new TypeBinding[superLength];", "+\t\t\t\tfor (int s = 0; s < superLength; s++)", "+\t\t\t\t\trawOtherBounds[s] = env.convertToRawType(itsSuperinterfaces[s], false);", "+\t\t\t}", "+\t\t\targuments[i] = env.createWildcard(null, 0, rawFirstBound, rawOtherBounds, org.eclipse.jdt.internal.compiler.ast.Wildcard.EXTENDS);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6415ec6121a9d9963195fa938d966694", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "67766e5b27ea79987add5b8cee1657ec3cbfbedb", "commitAfterChange": "e6c002b5fc187b459093049d56b25a0df58b8d61", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0)", "+\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "-\t\t\telse if (!sourceType.isAnonymousType()){ // body of enum constant must implement any inherited abstract methods", "+\t\t\t} else if (!sourceType.isAnonymousType()) {", "+\t\t\t\t// body of enum constant must implement any inherited abstract methods", "-\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "-\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "-\t\t\t\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "-\t\t\t\t\tif (length == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "-\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\t\tint fieldsLength = fields == null ? 0 : fields.length;", "+\t\t\t\t\tif (fieldsLength == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "+\t\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+\t\t\t\t\tint methodsLength = methods == null ? 0 : methods.length;", "+\t\t\t\t\t// TODO (kent) cannot tell that the superinterfaces are empty or that their methods are implemented", "+\t\t\t\t\tboolean definesAbstractMethod = typeDeclaration.superInterfaces != null;", "+\t\t\t\t\tfor (int i = 0; i < methodsLength && !definesAbstractMethod; i++)", "+\t\t\t\t\t\tdefinesAbstractMethod = methods[i].isAbstract();", "+\t\t\t\t\tif (!definesAbstractMethod) break checkAbstractEnum; // all methods have bodies", "+\t\t\t\t\tfor (int i = 0; i < fieldsLength; i++) {", "+\t\t\tmodifiers |= AccFinal;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c25841813738d16774f5e1df6a5bfb98", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "fa2250802984cea8cb5424fd54457f3c16db0f4e", "commitAfterChange": "9dccafa0339bc7819f07b3f80a49e2da470c0aab", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic MethodBinding tiebreakMethod()", "signatureAfterChange": " \tpublic MethodBinding tiebreakMethod()", "diff": ["-\t */", "-//\t\t\tif (this.isRaw) {", "-//\t\t\t\tthis.tiebreakMethod = this;", "-//\t\t\t} else {", "-//\t\t\t\tthis.tiebreakMethod = new ParameterizedGenericMethodBinding(this.originalMethod, (RawTypeBinding)null, this.environment);", "+\t\t\tif (this.isStatic()) {", "+\t\t\t\tTypeVariableBinding[] originalVariables = originalMethod.typeVariables;", "+\t\t\t\tint length = originalVariables.length;", "+\t\t\t\tTypeBinding[] newArguments = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++)", "+\t\t\t\t\tnewArguments[i] =  originalVariables[i].upperBound(); // do not rawify", "+\t\t\t\tthis.tiebreakMethod = this.environment.createParameterizedGenericMethod(this.originalMethod, newArguments);", "+\t\t\t} else {", "-//\t\t\t}", "+\t\t\t}"]}], "num": 9434}