{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "88e663758d9a4dc86c8c926e9baeb13e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "024924592205fcf6720f22cd06d2e188", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "e760e456d0e96ba9bce504014e582b9dbdf7e542", "commitAfterChange": "c67d112c20f07c2dcda11714ef23687a9781a753", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "+", "+\t\t\t// internally for type checking use the unannotated types:", "+\t\t\tTypeBinding unannotatedCastType = castType.unannotated();", "+\t\t\tint nullityMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1);", "+\t\t\tif (nullityMismatch > 0)", "+\t\t\t\tcastType = unannotatedCastType; // problem exists, so use the unannotated type also externally", "+\t\t\texpressionType = expressionType.unannotated();", "+", "+\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, unannotatedCastType, expressionType, this.expression);", "-\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "+\t\t\t\tthis.expression.computeConversion(scope, unannotatedCastType, expressionType);", "+\t\t\t\t} else if (nullityMismatch > 0) {", "+\t\t\t\t\t// report null annotation issue at medium priority", "+\t\t\t\t\tscope.problemReporter().unsafeNullnessCast(this, scope);", "-\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "-\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);", "+\t\t\t\t\tif (unannotatedCastType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "+\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, unannotatedCastType);", "-\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "-\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "+\t\t\t\tif ((unannotatedCastType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "+\t\t\t\t\tscope.problemReporter().typeCastError(this, unannotatedCastType, expressionType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee7ea63d581a62d0fb651c086249f36d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "83b2f6a03c3dc62e9f0da4478de073882f53022b", "commitAfterChange": "3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t// internally for type checking use the unannotated types:", "-\t\t\tTypeBinding unannotatedCastType = castType.unannotated();", "-\t\t\tif (nullAnnotationMismatch)", "-\t\t\t\tcastType = unannotatedCastType; // problem exists, so use the unannotated type also externally", "-\t\t\texpressionType = expressionType.unannotated();", "-\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, unannotatedCastType, expressionType, this.expression);", "+\t\t\tboolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);", "-\t\t\t\tthis.expression.computeConversion(scope, unannotatedCastType, expressionType);", "+\t\t\t\tthis.expression.computeConversion(scope, castType, expressionType);", "-\t\t\t\t\tif (unannotatedCastType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "-\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, unannotatedCastType);", "+\t\t\t\t\tif (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){", "+\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.type, castType);", "-\t\t\t\tif ((unannotatedCastType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "-\t\t\t\t\tscope.problemReporter().typeCastError(this, unannotatedCastType, expressionType);", "+\t\t\t\tif ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error", "+\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);"]}], "num": 38086}