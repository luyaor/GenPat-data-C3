{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e65838ce3ae7cbc33f942a9bccf85b5c", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "640d47487fa89369e756114b1917c92d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tpublic void resolve(MethodScope initializationScope)", "signatureAfterChange": " \t \tpublic void resolve(MethodScope initializationScope)", "diff": ["-\t\t\t\tif (isTypeUseDeprecated(this.binding.type, initializationScope)) {", "-\t\t\t\t\tinitializationScope.problemReporter().deprecatedType(this.binding.type, this.type);", "-\t\t\t\t}", "-\t\t\t\t\tTypeBinding typeBinding = this.binding.type;", "-\t\t\t\t\tTypeBinding initializationTypeBinding;", "-\t\t\t\t\t", "+\t\t\t\t\tTypeBinding fieldType = this.binding.type;", "+\t\t\t\t\tTypeBinding initializationType;", "+\t\t\t\t\tthis.initialization.setExpectedType(fieldType); // needed in case of generic method invocation", "-\t\t\t\t\t\tif ((initializationTypeBinding = this.initialization.resolveTypeExpecting(initializationScope, typeBinding)) != null) {", "-\t\t\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationTypeBinding;", "-\t\t\t\t\t\t\tthis.initialization.implicitWidening(typeBinding, initializationTypeBinding);", "+\t\t\t\t\t\tif ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {", "+\t\t\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;", "+\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t} else if ((initializationTypeBinding = this.initialization.resolveType(initializationScope)) != null) {", "+\t\t\t\t\t} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {", "-\t\t\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationTypeBinding, typeBinding)", "-\t\t\t\t\t\t\t|| (typeBinding.isBaseType() && BaseTypeBinding.isWidening(typeBinding.id, initializationTypeBinding.id))) {", "-", "-\t\t\t\t\t\t\tthis.initialization.implicitWidening(typeBinding, initializationTypeBinding);", "-", "-\t\t\t\t\t\t}\telse if (initializationTypeBinding.isCompatibleWith(typeBinding)) {", "-\t\t\t\t\t\t\tthis.initialization.implicitWidening(typeBinding, initializationTypeBinding);", "-", "+\t\t\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)", "+\t\t\t\t\t\t\t\t|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))", "+\t\t\t\t\t\t\t\t|| initializationType.isCompatibleWith(fieldType)) {", "+\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "+\t\t\t\t\t\t\tif (initializationType.isRawType() && (fieldType.isParameterizedType() || fieldType.isGenericType())) {", "+\t\t\t\t\t\t\t\t    initializationScope.problemReporter().unsafeRawAssignment(this.initialization, initializationType, fieldType);", "+\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationTypeBinding, typeBinding, this);", "+\t\t\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93aabd25cb61c0f0802f66eb39b5e900", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "9a9af4e642a47932f3bfeeec13330339dcc48de3", "commitAfterChange": "c3ad34ec44b228feb09e91ff5ac00fc774236d05", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\tTypeBinding methodTypeErasure = method.returnType == null ? null : method.returnType.erasure();", "+\t\t\t\tTypeBinding returnErasure = method.returnType == null ? null : method.returnType.erasure();", "-\t\t\t\tnextOtherMethod: for (int j = length - 1; j > i; j--) {", "-\t\t\t\t\tMethodBinding otherMethod = methods[j];", "-\t\t\t\t\t// check collision with otherMethod", "-\t\t\t\t\tif (otherMethod == null) ", "-\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\tif (!CharOperation.equals(selector, otherMethod.selector))", "-\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\tnextMethod : for (int j = length - 1; j > i; j--) {", "+\t\t\t\t\tMethodBinding method2 = methods[j];", "+\t\t\t\t\tif (method2 == null || !CharOperation.equals(selector, method2.selector))", "+\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\tTypeBinding otherMethodTypeErasure = otherMethod.returnType == null ? null : otherMethod.returnType.erasure();", "-\t\t\t\t\t\tif (methodTypeErasure != otherMethodTypeErasure) {", "-\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables && otherMethod.typeVariables != NoTypeVariables) {", "-\t\t\t\t\t\t\t\t// for generic methods, no need to check arguments", "-\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "-\t\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!method.areParameterErasuresEqual(otherMethod))", "-\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\tif (returnErasure != (method2.returnType == null ? null : method2.returnType.erasure())) {", "+\t\t\t\t\t\t\t // colllision when parameters are identical & type variable erasures match", "+\t\t\t\t\t\t\tif (!method.areParametersEqual(method2))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\tif (!method.areTypeVariableErasuresEqual(method2))", "+\t\t\t\t\t\t\t\tif (method.typeVariables.length > 0 && method2.typeVariables.length > 0)", "+\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t} else if (!method.areParameterErasuresEqual(method2)) { // colllision when parameter & return type erasures match", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// prior to 1.5, parameter match is enough for collision", "-\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "-\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t} else if (!method.areParametersEqual(method2)) { // prior to 1.5, parameter identity meant a collision case", "+\t\t\t\t\t\tcontinue nextMethod;", "+", "-\t\t\t\t\tAbstractMethodDeclaration otherMethodDecl = otherMethod.sourceMethod();", "-\t\t\t\t\tif (otherMethodDecl != null && otherMethodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\tAbstractMethodDeclaration method2Decl = method2.sourceMethod();", "+\t\t\t\t\tif (method2Decl != null && method2Decl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, otherMethodDecl);", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, otherMethodDecl);", "-\t\t\t\t\t\totherMethodDecl.binding = null;", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "+\t\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\tif (methodTypeErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions", "+\t\t\t\tif (returnErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions"]}], "num": 43604}