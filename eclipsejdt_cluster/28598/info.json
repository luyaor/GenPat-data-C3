{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b4a055d0e98d8b8e2fbb01ccf0a56d6c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e7baacc6bcea9205443719fe9a0e9dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t */\r", "-\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {\r", "-\t\tint clinitOffset = 0;\r", "-\t\tif (ignoreFurtherInvestigation) {\r", "-\t\t\t// should never have to add any <clinit> problem method\r", "-\t\t\treturn;\r", "+ */\r", "+public void generateCode(ClassScope classScope, ClassFile classFile) {\r", "+\tint clinitOffset = 0;\r", "+\tif (ignoreFurtherInvestigation) {\r", "+\t\t// should never have to add any <clinit> problem method\r", "+\t\treturn;\r", "+\t}\r", "+\ttry {\r", "+\t\tclinitOffset = classFile.contentsOffset;\r", "+\t\tConstantPool constantPool = classFile.constantPool;\r", "+\t\tint constantPoolOffset = constantPool.currentOffset;\r", "+\t\tint constantPoolIndex = constantPool.currentIndex;\r", "+\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "+\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "+\t\tclassFile.generateCodeAttributeHeader();\r", "+\t\tCodeStream codeStream = classFile.codeStream;\r", "+\t\tcodeStream.reset(this, classFile);\r", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "+\r", "+\t\t// initialize local positions - including initializer scope.\r", "+\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "+\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "+\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream); // offset by the argument size\r", "+\r", "+\t\t// generate initializers\r", "+\t\tif (declaringType.fields != null) {\r", "+\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "+\t\t\t\tFieldDeclaration fieldDecl;\r", "+\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "+\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\ttry {\r", "-\t\t\tclinitOffset = classFile.contentsOffset;\r", "-\t\t\tConstantPool constantPool = classFile.constantPool;\r", "-\t\t\tint constantPoolOffset = constantPool.currentOffset;\r", "-\t\t\tint constantPoolIndex = constantPool.currentIndex;\r", "-\t\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\t\tthis.resolve(classScope);\r", "-\r", "-\t\t\tcodeStream.reset(this, classFile);\r", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "-\r", "-\t\t\t// initialize local positions - including initializer scope.\r", "-\t\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "-\t\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "-\t\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream);\r", "-\t\t\t// offset by the argument size\r", "-\r", "-\t\t\t// 1.4 feature\r", "-\t\t\t// This has to be done before any other initialization\r", "-\t\t\tif (this.assertionSyntheticFieldBinding != null) {\r", "-\t\t\t\t// generate code related to the activation of assertion for this class\r", "-\t\t\t\tcodeStream.generateClassLiteralAccessForType(\r", "-\t\t\t\t\tclassScope.enclosingSourceType(),\r", "-\t\t\t\t\tclassLiteralSyntheticField);\r", "-\t\t\t\tcodeStream.invokeJavaLangClassDesiredAssertionStatus();\r", "-\t\t\t\tLabel falseLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.ifne(falseLabel);\r", "-\t\t\t\tcodeStream.iconst_1();\r", "-\t\t\t\tLabel jumpLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.goto_(jumpLabel);\r", "-\t\t\t\tfalseLabel.place();\r", "-\t\t\t\tcodeStream.iconst_0();\r", "-\t\t\t\tjumpLabel.place();\r", "-\t\t\t\tcodeStream.putstatic(this.assertionSyntheticFieldBinding);\r", "-\t\t\t}\r", "-\t\t\t// generate initializers\r", "-\t\t\tif (declaringType.fields != null) {\r", "-\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "-\t\t\t\t\tFieldDeclaration fieldDecl;\r", "-\t\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (codeStream.position == 0) {\r", "-\t\t\t\t// do not need to output a Clinit if no bytecodes\r", "-\t\t\t\t// so we reset the offset inside the byte array contents.\r", "-\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "-\t\t\t\tclassFile.methodCount--;\r", "-\t\t\t\t// reset the constant pool to its state before the clinit\r", "-\t\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "-\t\t\t} else {\r", "-\t\t\t\tif (needFreeReturn) {\r", "-\t\t\t\t\tint oldPosition = codeStream.position;\r", "-\t\t\t\t\tcodeStream.return_();\r", "-\t\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "-\t\t\t\t}\r", "-\t\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "-\t\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "-\t\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "-\t\t\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "+\t\tif (codeStream.position == 0) {\r", "+\t\t\t// do not need to output a Clinit if no bytecodes\r", "+\t\t\t// so we reset the offset inside the byte array contents.\r", "+\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "+\t\t\t// reset the constant pool to its state before the clinit\r", "+\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "+\t\t} else {\r", "+\t\t\tif (needFreeReturn) {\r", "+\t\t\t\tint oldPosition = codeStream.position;\r", "+\t\t\t\tcodeStream.return_();\r", "+\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "+\t\t\t}\r", "+\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "+\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "+\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "+\t} catch (AbortMethod e) {\r", "+\t\t// should never occur\r", "+\t\t// the clinit referenceContext is the type declaration\r", "+\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t// decrement the number of method info as well.\r", "+\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t// cases.\r", "+\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\tclassFile.methodCount--;\t\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac029add1aa87fcbefd1ceab67a7f4eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t */\r", "-\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {\r", "-\t\tint clinitOffset = 0;\r", "-\t\tif (ignoreFurtherInvestigation) {\r", "-\t\t\t// should never have to add any <clinit> problem method\r", "-\t\t\treturn;\r", "+ */\r", "+public void generateCode(ClassScope classScope, ClassFile classFile) {\r", "+\tint clinitOffset = 0;\r", "+\tif (ignoreFurtherInvestigation) {\r", "+\t\t// should never have to add any <clinit> problem method\r", "+\t\treturn;\r", "+\t}\r", "+\ttry {\r", "+\t\tclinitOffset = classFile.contentsOffset;\r", "+\t\tConstantPool constantPool = classFile.constantPool;\r", "+\t\tint constantPoolOffset = constantPool.currentOffset;\r", "+\t\tint constantPoolIndex = constantPool.currentIndex;\r", "+\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "+\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "+\t\tclassFile.generateCodeAttributeHeader();\r", "+\t\tCodeStream codeStream = classFile.codeStream;\r", "+\t\tcodeStream.reset(this, classFile);\r", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "+\r", "+\t\t// initialize local positions - including initializer scope.\r", "+\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "+\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "+\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream); // offset by the argument size\r", "+\r", "+\t\t// generate initializers\r", "+\t\tif (declaringType.fields != null) {\r", "+\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "+\t\t\t\tFieldDeclaration fieldDecl;\r", "+\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "+\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\ttry {\r", "-\t\t\tclinitOffset = classFile.contentsOffset;\r", "-\t\t\tConstantPool constantPool = classFile.constantPool;\r", "-\t\t\tint constantPoolOffset = constantPool.currentOffset;\r", "-\t\t\tint constantPoolIndex = constantPool.currentIndex;\r", "-\t\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\t\tthis.resolve(classScope);\r", "-\r", "-\t\t\tcodeStream.reset(this, classFile);\r", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "-\r", "-\t\t\t// initialize local positions - including initializer scope.\r", "-\t\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "-\t\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "-\t\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream);\r", "-\t\t\t// offset by the argument size\r", "-\r", "-\t\t\t// 1.4 feature\r", "-\t\t\t// This has to be done before any other initialization\r", "-\t\t\tif (this.assertionSyntheticFieldBinding != null) {\r", "-\t\t\t\t// generate code related to the activation of assertion for this class\r", "-\t\t\t\tcodeStream.generateClassLiteralAccessForType(\r", "-\t\t\t\t\tclassScope.enclosingSourceType(),\r", "-\t\t\t\t\tclassLiteralSyntheticField);\r", "-\t\t\t\tcodeStream.invokeJavaLangClassDesiredAssertionStatus();\r", "-\t\t\t\tLabel falseLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.ifne(falseLabel);\r", "-\t\t\t\tcodeStream.iconst_1();\r", "-\t\t\t\tLabel jumpLabel = new Label(codeStream);\r", "-\t\t\t\tcodeStream.goto_(jumpLabel);\r", "-\t\t\t\tfalseLabel.place();\r", "-\t\t\t\tcodeStream.iconst_0();\r", "-\t\t\t\tjumpLabel.place();\r", "-\t\t\t\tcodeStream.putstatic(this.assertionSyntheticFieldBinding);\r", "-\t\t\t}\r", "-\t\t\t// generate initializers\r", "-\t\t\tif (declaringType.fields != null) {\r", "-\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "-\t\t\t\t\tFieldDeclaration fieldDecl;\r", "-\t\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (codeStream.position == 0) {\r", "-\t\t\t\t// do not need to output a Clinit if no bytecodes\r", "-\t\t\t\t// so we reset the offset inside the byte array contents.\r", "-\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "-\t\t\t\tclassFile.methodCount--;\r", "-\t\t\t\t// reset the constant pool to its state before the clinit\r", "-\t\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "-\t\t\t} else {\r", "-\t\t\t\tif (needFreeReturn) {\r", "-\t\t\t\t\tint oldPosition = codeStream.position;\r", "-\t\t\t\t\tcodeStream.return_();\r", "-\t\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "-\t\t\t\t}\r", "-\t\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "-\t\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "-\t\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "-\t\t\t}\r", "-\t\t} catch (AbortMethod e) {\r", "-\t\t\t// should never occur\r", "-\t\t\t// the clinit referenceContext is the type declaration\r", "-\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t\t// decrement the number of method info as well.\r", "-\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t\t// cases.\r", "+\t\tif (codeStream.position == 0) {\r", "+\t\t\t// do not need to output a Clinit if no bytecodes\r", "+\t\t\t// so we reset the offset inside the byte array contents.\r", "+\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "+\t\t\t// reset the constant pool to its state before the clinit\r", "+\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "+\t\t} else {\r", "+\t\t\tif (needFreeReturn) {\r", "+\t\t\t\tint oldPosition = codeStream.position;\r", "+\t\t\t\tcodeStream.return_();\r", "+\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "+\t\t\t}\r", "+\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "+\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "+\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "+\t} catch (AbortMethod e) {\r", "+\t\t// should never occur\r", "+\t\t// the clinit referenceContext is the type declaration\r", "+\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t// decrement the number of method info as well.\r", "+\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t// cases.\r", "+\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\tclassFile.methodCount--;\t\r", "+}\r"]}], "num": 28598}