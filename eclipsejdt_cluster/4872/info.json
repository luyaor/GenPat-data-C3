{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4f5f051ee9ef51ac9e30ae5bd276ccc2", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "040c5de738c5a140b8e73c4cfa197b7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \tprivate void locateMatches() throws JavaModelException", "signatureAfterChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "diff": ["+ */\r", "+private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "+\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "+\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "+\tIBinaryType info;\r", "+\tif (classFile.isOpen()) {\r", "+\t\t// reuse the info from the java model cache\r", "+\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "+\t} else {\r", "+\t\t// create a temporary info\r", "+\t\ttry {\r", "+\t\t\tIJavaElement pkg = classFile.getParent();\r", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t// class file in a jar\r", "+\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "+\t\t\t\tString classFilePath = \r", "+\t\t\t\t\t(pkgPath.length() > 0) ?\r", "+\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "+\t\t\t\t\t\tclassFile.getElementName();\r", "+\t\t\t\tZipFile zipFile = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "+\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "+\t\t\t\t\t\tzipFile,\r", "+\t\t\t\t\t\tclassFilePath);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tif (zipFile != null) {\r", "+\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\tzipFile.close();\r", "+\t\t\t\t\t\t} catch (IOException e) {\r", "+\t\t\t\t\t\t\t// ignore \r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// class file in a directory\r", "+\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "+\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "+\t\t\t}\r", "+\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "+\t\t\te.printStackTrace();\r", "+\t\t\treturn;\r", "+\t\t} catch (java.io.IOException e) {\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "+\t\t}\r", "+\t\t\r", "+\t}\r", "+\r", "+\t// check class definition\r", "+\tif (this.pattern.matchesBinary(info, null)) {\r", "+\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t}\r", "+\r", "+\tboolean compilationAborted = false;\r", "+\tif (this.pattern.needsResolve) {\r", "+\t\t// resolve\r", "+\t\tBinaryTypeBinding binding = null;\r", "+\t\ttry {\r", "+\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "+\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "+\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "+\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "+\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "+\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "+\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\t// check methods\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tMethodBinding[] methods = binding.methods();\r", "+\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\t\tMethodBinding method = methods[i];\r", "+\t\t\t\t\tif (this.pattern.matches(method)) {\r", "+\t\t\t\t\t\tIMethod methodHandle = \r", "+\t\t\t\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "+\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "+\t\t\t\t\t\t\t);\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\r", "+\t\t\t// check fields\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tFieldBinding[] fields = binding.fields();\r", "+\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "+\t\t\t\t\tFieldBinding field = fields[i];\r", "+\t\t\t\t\tif (this.pattern.matches(field)) {\r", "+\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\tbinding = null;\r", "+\t\t}\r", "+\r", "+\t\t// no need to check binary info if resolve was successful\r", "+\t\tcompilationAborted = binding == null;\r", "+\t\tif (!compilationAborted) return;\r", "+\t}\r", "+\r", "+\t// if compilation was aborted it is a problem with the class path: \r", "+\t// report as a potential match if binary info matches the pattern\r", "+\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\r", "+\t// check methods\r", "+\tIBinaryMethod[] methods = info.getMethods();\r", "+\tint length = methods == null ? 0 : methods.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryMethod method = methods[i];\r", "+\t\tif (this.pattern.matchesBinary(method, info)) {\r", "+\t\t\tIMethod methodHandle = \r", "+\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "+\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "+\t\t\t\t);\r", "+\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "+\t// check fields\r", "+\tIBinaryField[] fields = info.getFields();\r", "+\tlength = fields == null ? 0 : fields.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryField field = fields[i];\r", "+\t\tif (this.pattern.matchesBinary(field, info)) {\r", "+\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "+\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "+}\r", "-\t */\r", "-\tprivate void locateMatches() throws JavaModelException {\r", "-\t\t// binding resolution\r", "-\t\tthis.lookupEnvironment.completeTypeBindings();\r", "-\r", "-\t\t// potential match resolution\r", "-\t\tfor (this.potentialMatchesIndex = 0;\r", "-\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "-\t\t\tthis.potentialMatchesIndex++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tPotentialMatch potentialMatch =\r", "-\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "-\t\t\t\tpotentialMatch.locateMatches();\r", "-\t\t\t\tpotentialMatch.reset();\r", "-\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t// problem with class path: it could not find base classes\r", "-\t\t\t\tthrow new JavaModelException(\r", "-\t\t\t\t\te,\r", "-\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "-\t\t\t} catch (CoreException e) {\r", "-\t\t\t\tif (e instanceof JavaModelException) {\r", "-\t\t\t\t\tthrow (JavaModelException) e;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tthrow new JavaModelException(e);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3cb123beb90848928f8cf229d129d42f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \tprivate void locateMatches() throws JavaModelException", "signatureAfterChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "diff": ["+ */\r", "+private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "+\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "+\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "+\tIBinaryType info;\r", "+\tif (classFile.isOpen()) {\r", "+\t\t// reuse the info from the java model cache\r", "+\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "+\t} else {\r", "+\t\t// create a temporary info\r", "+\t\ttry {\r", "+\t\t\tIJavaElement pkg = classFile.getParent();\r", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t// class file in a jar\r", "+\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "+\t\t\t\tString classFilePath = \r", "+\t\t\t\t\t(pkgPath.length() > 0) ?\r", "+\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "+\t\t\t\t\t\tclassFile.getElementName();\r", "+\t\t\t\tZipFile zipFile = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "+\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "+\t\t\t\t\t\tzipFile,\r", "+\t\t\t\t\t\tclassFilePath);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tif (zipFile != null) {\r", "+\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\tzipFile.close();\r", "+\t\t\t\t\t\t} catch (IOException e) {\r", "+\t\t\t\t\t\t\t// ignore \r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// class file in a directory\r", "+\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "+\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "+\t\t\t}\r", "+\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "+\t\t\te.printStackTrace();\r", "+\t\t\treturn;\r", "+\t\t} catch (java.io.IOException e) {\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "+\t\t}\r", "+\t\t\r", "+\t}\r", "+\r", "+\t// check class definition\r", "+\tif (this.pattern.matchesBinary(info, null)) {\r", "+\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t}\r", "+\r", "+\tboolean compilationAborted = false;\r", "+\tif (this.pattern.needsResolve) {\r", "+\t\t// resolve\r", "+\t\tBinaryTypeBinding binding = null;\r", "+\t\ttry {\r", "+\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "+\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "+\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "+\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "+\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "+\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "+\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\t// check methods\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tMethodBinding[] methods = binding.methods();\r", "+\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\t\tMethodBinding method = methods[i];\r", "+\t\t\t\t\tif (this.pattern.matches(method)) {\r", "+\t\t\t\t\t\tIMethod methodHandle = \r", "+\t\t\t\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "+\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "+\t\t\t\t\t\t\t);\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\r", "+\t\t\t// check fields\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tFieldBinding[] fields = binding.fields();\r", "+\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "+\t\t\t\t\tFieldBinding field = fields[i];\r", "+\t\t\t\t\tif (this.pattern.matches(field)) {\r", "+\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\tbinding = null;\r", "+\t\t}\r", "+\r", "+\t\t// no need to check binary info if resolve was successful\r", "+\t\tcompilationAborted = binding == null;\r", "+\t\tif (!compilationAborted) return;\r", "+\t}\r", "+\r", "+\t// if compilation was aborted it is a problem with the class path: \r", "+\t// report as a potential match if binary info matches the pattern\r", "+\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\r", "+\t// check methods\r", "+\tIBinaryMethod[] methods = info.getMethods();\r", "+\tint length = methods == null ? 0 : methods.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryMethod method = methods[i];\r", "+\t\tif (this.pattern.matchesBinary(method, info)) {\r", "+\t\t\tIMethod methodHandle = \r", "+\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "+\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "+\t\t\t\t);\r", "+\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "+\t// check fields\r", "+\tIBinaryField[] fields = info.getFields();\r", "+\tlength = fields == null ? 0 : fields.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryField field = fields[i];\r", "+\t\tif (this.pattern.matchesBinary(field, info)) {\r", "+\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "+\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "+}\r", "-\t */\r", "-\tprivate void locateMatches() throws JavaModelException {\r", "-\t\t// binding resolution\r", "-\t\tthis.lookupEnvironment.completeTypeBindings();\r", "-\r", "-\t\t// potential match resolution\r", "-\t\tfor (this.potentialMatchesIndex = 0;\r", "-\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "-\t\t\tthis.potentialMatchesIndex++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tPotentialMatch potentialMatch =\r", "-\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "-\t\t\t\tpotentialMatch.locateMatches();\r", "-\t\t\t\tpotentialMatch.reset();\r", "-\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t// problem with class path: it could not find base classes\r", "-\t\t\t\tthrow new JavaModelException(\r", "-\t\t\t\t\te,\r", "-\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "-\t\t\t} catch (CoreException e) {\r", "-\t\t\t\tif (e instanceof JavaModelException) {\r", "-\t\t\t\t\tthrow (JavaModelException) e;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tthrow new JavaModelException(e);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f000001b3de7e7a6366ad535bac17904", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \tprivate void locateMatches() throws JavaModelException", "signatureAfterChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "diff": ["+ */\r", "+private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "+\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "+\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "+\tIBinaryType info;\r", "+\tif (classFile.isOpen()) {\r", "+\t\t// reuse the info from the java model cache\r", "+\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "+\t} else {\r", "+\t\t// create a temporary info\r", "+\t\ttry {\r", "+\t\t\tIJavaElement pkg = classFile.getParent();\r", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t// class file in a jar\r", "+\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "+\t\t\t\tString classFilePath = \r", "+\t\t\t\t\t(pkgPath.length() > 0) ?\r", "+\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "+\t\t\t\t\t\tclassFile.getElementName();\r", "+\t\t\t\tZipFile zipFile = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "+\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "+\t\t\t\t\t\tzipFile,\r", "+\t\t\t\t\t\tclassFilePath);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tif (zipFile != null) {\r", "+\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\tzipFile.close();\r", "+\t\t\t\t\t\t} catch (IOException e) {\r", "+\t\t\t\t\t\t\t// ignore \r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// class file in a directory\r", "+\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "+\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "+\t\t\t}\r", "+\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "+\t\t\te.printStackTrace();\r", "+\t\t\treturn;\r", "+\t\t} catch (java.io.IOException e) {\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "+\t\t}\r", "+\t\t\r", "+\t}\r", "+\r", "+\t// check class definition\r", "+\tif (this.pattern.matchesBinary(info, null)) {\r", "+\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t}\r", "+\r", "+\tboolean compilationAborted = false;\r", "+\tif (this.pattern.needsResolve) {\r", "+\t\t// resolve\r", "+\t\tBinaryTypeBinding binding = null;\r", "+\t\ttry {\r", "+\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "+\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "+\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "+\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "+\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "+\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "+\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\t// check methods\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tMethodBinding[] methods = binding.methods();\r", "+\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\t\tMethodBinding method = methods[i];\r", "+\t\t\t\t\tif (this.pattern.matches(method)) {\r", "+\t\t\t\t\t\tIMethod methodHandle = \r", "+\t\t\t\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "+\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "+\t\t\t\t\t\t\t);\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\r", "+\t\t\t// check fields\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tFieldBinding[] fields = binding.fields();\r", "+\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "+\t\t\t\t\tFieldBinding field = fields[i];\r", "+\t\t\t\t\tif (this.pattern.matches(field)) {\r", "+\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\tbinding = null;\r", "+\t\t}\r", "+\r", "+\t\t// no need to check binary info if resolve was successful\r", "+\t\tcompilationAborted = binding == null;\r", "+\t\tif (!compilationAborted) return;\r", "+\t}\r", "+\r", "+\t// if compilation was aborted it is a problem with the class path: \r", "+\t// report as a potential match if binary info matches the pattern\r", "+\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\r", "+\t// check methods\r", "+\tIBinaryMethod[] methods = info.getMethods();\r", "+\tint length = methods == null ? 0 : methods.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryMethod method = methods[i];\r", "+\t\tif (this.pattern.matchesBinary(method, info)) {\r", "+\t\t\tIMethod methodHandle = \r", "+\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "+\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "+\t\t\t\t);\r", "+\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "+\t// check fields\r", "+\tIBinaryField[] fields = info.getFields();\r", "+\tlength = fields == null ? 0 : fields.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryField field = fields[i];\r", "+\t\tif (this.pattern.matchesBinary(field, info)) {\r", "+\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "+\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "+}\r", "-\t */\r", "-\tprivate void locateMatches() throws JavaModelException {\r", "-\t\t// binding resolution\r", "-\t\tthis.lookupEnvironment.completeTypeBindings();\r", "-\r", "-\t\t// potential match resolution\r", "-\t\tfor (this.potentialMatchesIndex = 0;\r", "-\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "-\t\t\tthis.potentialMatchesIndex++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tPotentialMatch potentialMatch =\r", "-\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "-\t\t\t\tpotentialMatch.locateMatches();\r", "-\t\t\t\tpotentialMatch.reset();\r", "-\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t// problem with class path: it could not find base classes\r", "-\t\t\t\tthrow new JavaModelException(\r", "-\t\t\t\t\te,\r", "-\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "-\t\t\t} catch (CoreException e) {\r", "-\t\t\t\tif (e instanceof JavaModelException) {\r", "-\t\t\t\t\tthrow (JavaModelException) e;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tthrow new JavaModelException(e);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f47090c3988a0bb4e3abf2af0ce49442", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \tprivate void locateMatches() throws JavaModelException", "signatureAfterChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "diff": ["+ */\r", "+private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "+\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "+\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "+\tIBinaryType info;\r", "+\tif (classFile.isOpen()) {\r", "+\t\t// reuse the info from the java model cache\r", "+\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "+\t} else {\r", "+\t\t// create a temporary info\r", "+\t\ttry {\r", "+\t\t\tIJavaElement pkg = classFile.getParent();\r", "+\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "+\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t// class file in a jar\r", "+\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "+\t\t\t\tString classFilePath = \r", "+\t\t\t\t\t(pkgPath.length() > 0) ?\r", "+\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "+\t\t\t\t\t\tclassFile.getElementName();\r", "+\t\t\t\tZipFile zipFile = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "+\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "+\t\t\t\t\t\tzipFile,\r", "+\t\t\t\t\t\tclassFilePath);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tif (zipFile != null) {\r", "+\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\tzipFile.close();\r", "+\t\t\t\t\t\t} catch (IOException e) {\r", "+\t\t\t\t\t\t\t// ignore \r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\t// class file in a directory\r", "+\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "+\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "+\t\t\t}\r", "+\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "+\t\t\te.printStackTrace();\r", "+\t\t\treturn;\r", "+\t\t} catch (java.io.IOException e) {\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "+\t\t}\r", "+\t\t\r", "+\t}\r", "+\r", "+\t// check class definition\r", "+\tif (this.pattern.matchesBinary(info, null)) {\r", "+\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t}\r", "+\r", "+\tboolean compilationAborted = false;\r", "+\tif (this.pattern.needsResolve) {\r", "+\t\t// resolve\r", "+\t\tBinaryTypeBinding binding = null;\r", "+\t\ttry {\r", "+\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "+\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "+\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "+\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "+\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "+\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "+\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\t// check methods\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tMethodBinding[] methods = binding.methods();\r", "+\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\t\tMethodBinding method = methods[i];\r", "+\t\t\t\t\tif (this.pattern.matches(method)) {\r", "+\t\t\t\t\t\tIMethod methodHandle = \r", "+\t\t\t\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "+\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "+\t\t\t\t\t\t\t);\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\r", "+\t\t\t// check fields\r", "+\t\t\tif (binding != null) {\r", "+\t\t\t\tFieldBinding[] fields = binding.fields();\r", "+\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "+\t\t\t\t\tFieldBinding field = fields[i];\r", "+\t\t\t\t\tif (this.pattern.matches(field)) {\r", "+\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "+\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\tbinding = null;\r", "+\t\t}\r", "+\r", "+\t\t// no need to check binary info if resolve was successful\r", "+\t\tcompilationAborted = binding == null;\r", "+\t\tif (!compilationAborted) return;\r", "+\t}\r", "+\r", "+\t// if compilation was aborted it is a problem with the class path: \r", "+\t// report as a potential match if binary info matches the pattern\r", "+\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "+\t\r", "+\t// check methods\r", "+\tIBinaryMethod[] methods = info.getMethods();\r", "+\tint length = methods == null ? 0 : methods.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryMethod method = methods[i];\r", "+\t\tif (this.pattern.matchesBinary(method, info)) {\r", "+\t\t\tIMethod methodHandle = \r", "+\t\t\t\tbinaryType.getMethod(\r", "+\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "+\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "+\t\t\t\t);\r", "+\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "+\t// check fields\r", "+\tIBinaryField[] fields = info.getFields();\r", "+\tlength = fields == null ? 0 : fields.length;\r", "+\tfor (int i = 0; i < length; i++) {\r", "+\t\tIBinaryField field = fields[i];\r", "+\t\tif (this.pattern.matchesBinary(field, info)) {\r", "+\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "+\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "+}\r", "-\t */\r", "-\tprivate void locateMatches() throws JavaModelException {\r", "-\t\t// binding resolution\r", "-\t\tthis.lookupEnvironment.completeTypeBindings();\r", "-\r", "-\t\t// potential match resolution\r", "-\t\tfor (this.potentialMatchesIndex = 0;\r", "-\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "-\t\t\tthis.potentialMatchesIndex++) {\r", "-\t\t\ttry {\r", "-\t\t\t\tPotentialMatch potentialMatch =\r", "-\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "-\t\t\t\tpotentialMatch.locateMatches();\r", "-\t\t\t\tpotentialMatch.reset();\r", "-\t\t\t} catch (AbortCompilation e) {\r", "-\t\t\t\t// problem with class path: it could not find base classes\r", "-\t\t\t\tthrow new JavaModelException(\r", "-\t\t\t\t\te,\r", "-\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "-\t\t\t} catch (CoreException e) {\r", "-\t\t\t\tif (e instanceof JavaModelException) {\r", "-\t\t\t\t\tthrow (JavaModelException) e;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tthrow new JavaModelException(e);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}], "num": 4872}