{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c0618ed60a6d34527ff0dccc8345bd7", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b47b735f25348f7dd7600652e2e8101", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "2a762b85f858691a63d4547af177cc649d7b1329", "commitAfterChange": "7675c409a4b3b1e15b1cc476a0a66b988b5fb4a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tIClasspathEntry[] originalClasspath = classpath;\r", "+\tArrayList resolvedEntries = new ArrayList();\r", "-\t\t// use resolved variable\r", "-\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_VARIABLE){\r", "-\t\t\tif (classpath == originalClasspath) System.arraycopy(originalClasspath, 0, classpath = new IClasspathEntry[length], 0, length);\r", "-\t\t\tclasspath[i] = JavaCore.getResolvedClasspathEntry(classpath[i]);\r", "-\t\t}\r", "-\t\tif (classpath[i] != null){\r", "-\t\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "-\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "-\t\t\tif (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\tIClasspathEntry rawEntry = classpath[i];\r", "+\t\tswitch(rawEntry.getEntryKind()){\r", "+\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_VARIABLE :\r", "+\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);\r", "+\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\tcase IClasspathEntry.CPE_CONTAINER :\r", "+\t\t\t\tIClasspathEntry[] containerEntries = javaProject.getResolvedClasspathContainer(rawEntry.getPath());\r", "+\t\t\t\tif (containerEntries != null){\r", "+\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){\r", "+\t\t\t\t\t\t resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);\r", "+\t\t\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_SOURCE :\r", "+\t\t\t\thasSource = true;\r", "+\t\t\tdefault :\r", "+\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\tresolvedEntries.add(rawEntry);\r", "+\t\t\t\tbreak;\r", "+\t\r", "+\tlength = resolvedEntries.size();\r", "+\tclasspath = new IClasspathEntry[length];\r", "+\tresolvedEntries.toArray(classpath);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c00b5073ba859895d9f7fe0fd87c72b9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "0c0f02419934ad3b7d3b29ce6843cc90f00cf260", "commitAfterChange": "ce9d82264275b3c4ad926312ca4ca735e225fab4", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\t\t// basic entry validation, will abort in presence of unresolved variable\r", "-\t\tIJavaModelStatus status = validateClasspathEntry(javaProject, classpath[i], false);\r", "-\t\tif (!status.isOK()){\r", "-\t\t\treturn status;\r", "-\t\t}\r", "-\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "-\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "-\t\tif (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\tif (classpath[i] != null){\r", "+\t\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\tif (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t}\r", "+\t\tif (entry == null) continue;\r", "+\t\t\t\tif (otherEntry == null) continue;\r"]}], "num": 32147}