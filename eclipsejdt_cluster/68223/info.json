{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "61646d6f842b51ffe4e3f05cd7638c22", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2718695629873e76012c6090cda94f65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "904e81d11d3fc634ae2d9d861dc6c73c9ea81e03", "commitAfterChange": "2fce9fdec7d24fd4985bfaa8a4da9bdc5aff2660", "methodNumberBeforeChange": 176, "methodNumberAfterChange": 184, "signatureBeforeChange": "\t \t \tpublic void testJavadoc()", "signatureAfterChange": " \tpublic void testJavadoc()", "diff": ["-\t", "+\t */", "-\t\tJavadoc x = ast.newJavadoc();", "+\t\tfinal Javadoc x = ast.newJavadoc();", "+\t\tassertTrue(!x.isBlockComment());", "+\t\tassertTrue(!x.isLineComment());", "+\t\tassertTrue(x.isDocComment());", "+\t\tassertTrue(x.fragments().isEmpty());", "+\t\tassertTrue(x.getAlternateRoot() == null);", "+\t\t", "+\t\ttAlternateRoot(x);", "+", "+\t\t// check that fragments() can handle TagElement", "+\t\tgenericPropertyListTest(x, x.fragments(),", "+\t\t  new Property(\"Fragments\", true, TagElement.class) { //$NON-NLS-1$", "+\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\tTagElement result = targetAst.newTagElement();", "+\t\t\t\tif (parented) {", "+\t\t\t\t\tJavadoc parent = targetAst.newJavadoc();", "+\t\t\t\t\tparent.fragments().add(result);", "+\t\t\t\t}", "+\t\t\t\treturn result;", "+\t\t\t}", "+\t\t\tpublic ASTNode[] counterExamples(AST targetAst) {", "+\t\t\t\treturn new ASTNode[] {", "+\t\t\t\t\ttargetAst.newEmptyStatement(),", "+\t\t\t\t\ttargetAst.newCompilationUnit(),", "+\t\t\t\t\ttargetAst.newTypeDeclaration(),", "+\t\t\t\t\ttargetAst.newJavadoc(),", "+\t\t\t\t};", "+\t\t\t}", "+\t\t});", "+\t\t// check that fragments() can handle Name", "+\t\tgenericPropertyListTest(x, x.fragments(),", "+\t\t  new Property(\"Fragments\", true, Name.class) { //$NON-NLS-1$", "+\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\tSimpleName result = targetAst.newSimpleName(\"foo\"); //$NON-NLS-1$", "+\t\t\t\tif (parented) {", "+\t\t\t\t\ttargetAst.newExpressionStatement(result);", "+\t\t\t\t}", "+\t\t\t\treturn result;", "+\t\t\t}", "+\t\t});", "+\t\t// check that fragments() can handle TextElement", "+\t\tgenericPropertyListTest(x, x.fragments(),", "+\t\t  new Property(\"Fragments\", true, TextElement.class) { //$NON-NLS-1$", "+\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\tTextElement result = targetAst.newTextElement();", "+\t\t\t\tif (parented) {", "+\t\t\t\t\tJavadoc parent = targetAst.newJavadoc();", "+\t\t\t\t\tparent.fragments().add(result);", "+\t\t\t\t}", "+\t\t\t\treturn result;", "+\t\t\t}", "+\t\t});", "+\t\t// check that fragments() can handle MethodRef", "+\t\tgenericPropertyListTest(x, x.fragments(),", "+\t\t  new Property(\"Fragments\", true, MethodRef.class) { //$NON-NLS-1$", "+\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\tMethodRef result = targetAst.newMethodRef();", "+\t\t\t\tif (parented) {", "+\t\t\t\t\tJavadoc parent = targetAst.newJavadoc();", "+\t\t\t\t\tparent.fragments().add(result);", "+\t\t\t\t}", "+\t\t\t\treturn result;", "+\t\t\t}", "+\t\t});", "+\t\t// check that fragments() can handle MemberRef", "+\t\tgenericPropertyListTest(x, x.fragments(),", "+\t\t  new Property(\"Fragments\", true, MemberRef.class) { //$NON-NLS-1$", "+\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\tMemberRef result = targetAst.newMemberRef();", "+\t\t\t\tif (parented) {", "+\t\t\t\t\tJavadoc parent = targetAst.newJavadoc();", "+\t\t\t\t\tparent.fragments().add(result);", "+\t\t\t\t}", "+\t\t\t\treturn result;", "+\t\t\t}", "+\t\t});"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5105f5acd94cfdb3334bdb8acc43a8e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "97881e1f65dad02c5fcba69e18ae3332573c3839", "commitAfterChange": "5ae43aadc33d93b5c6af6a0612729105eee79d4f", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic static CompilationUnit parsePartialCompilationUnit(         IClassFile classFile, \t\tint position, \t\tboolean resolveBindings, \t\tWorkingCopyOwner owner, \t\tIProgressMonitor monitor)", "signatureAfterChange": " \tpublic static CompilationUnit parsePartialCompilationUnit(         IClassFile classFile, \t\tint position, \t\tboolean resolveBindings, \t\tWorkingCopyOwner owner, \t\tIProgressMonitor monitor)", "diff": ["-\t\t// TODO (olivier) missing implementation", "-\t\tthrow new RuntimeException(\"Not implemented yet\"); //$NON-NLS-1$", "+", "+\t\tchar[] source = null;", "+\t\tString sourceString = null;", "+\t\ttry {", "+\t\t\tsourceString = classFile.getSource();", "+\t\t} catch (JavaModelException e) {", "+\t\t\tthrow new IllegalArgumentException();", "+\t\t}", "+", "+\t\tif (sourceString == null) {", "+\t\t\tthrow new IllegalArgumentException();", "+\t\t}", "+\t\tsource = sourceString.toCharArray();", "+", "+\t\tNodeSearcher searcher = new NodeSearcher(position);", "+", "+\t\tfinal Map options = classFile.getJavaProject().getOptions(true);", "+\t\tif (resolveBindings) {", "+\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = null;", "+\t\t\ttry {", "+\t\t\t\t// parse and resolve", "+\t\t\t\tcompilationUnitDeclaration = CompilationUnitResolver.resolve(", "+\t\t\t\t\tclassFile,", "+\t\t\t\t\tsearcher,", "+\t\t\t\t\tfalse/*don't cleanup*/,", "+\t\t\t\t\tsource,", "+\t\t\t\t\towner,", "+\t\t\t\t\tmonitor);", "+\t\t\t\t", "+\t\t\t\tASTConverter converter = new ASTConverter(options, true, monitor);", "+\t\t\t\tAST ast = new AST();", "+\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(compilationUnitDeclaration.scope);", "+\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\tconverter.setAST(ast);", "+\t\t\t", "+\t\t\t\tCompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration, source);", "+\t\t\t\tcompilationUnit.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);", "+\t\t\t\tresolver.storeModificationCount(ast.modificationCount());", "+\t\t\t\treturn compilationUnit;", "+\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t/* if a JavaModelException is thrown trying to retrieve the name environment", "+\t\t\t\t * then we simply do a parsing without creating bindings.", "+\t\t\t\t * Therefore all binding resolution will return null.", "+\t\t\t\t */", "+\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration2 = CompilationUnitResolver.parse(", "+\t\t\t\t\tsource,", "+\t\t\t\t\tsearcher,", "+\t\t\t\t\toptions);", "+\t\t\t\t", "+\t\t\t\tASTConverter converter = new ASTConverter(options, false, monitor);", "+\t\t\t\tAST ast = new AST();", "+\t\t\t\tfinal BindingResolver resolver = new BindingResolver();", "+\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\tconverter.setAST(ast);", "+\t", "+\t\t\t\tCompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration2, source);", "+\t\t\t\tcompilationUnit.setLineEndTable(compilationUnitDeclaration2.compilationResult.lineSeparatorPositions);", "+\t\t\t\tresolver.storeModificationCount(ast.modificationCount());", "+\t\t\t\treturn compilationUnit;", "+\t\t\t} finally {", "+\t\t\t\tif (compilationUnitDeclaration != null) {", "+\t\t\t\t\tcompilationUnitDeclaration.cleanUp();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = CompilationUnitResolver.parse(", "+\t\t\t\tsource,", "+\t\t\t\tsearcher,", "+\t\t\t\toptions);", "+\t\t\t", "+\t\t\tASTConverter converter = new ASTConverter(options, false, monitor);", "+\t\t\tAST ast = new AST();", "+\t\t\tfinal BindingResolver resolver = new BindingResolver();", "+\t\t\tast.setBindingResolver(resolver);", "+\t\t\tconverter.setAST(ast);", "+", "+\t\t\tCompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration, source);", "+\t\t\tcompilationUnit.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);", "+\t\t\tresolver.storeModificationCount(ast.modificationCount());", "+\t\t\treturn compilationUnit;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bed0f1540aeba53795dc7f800959b7f9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java", "commitBeforeChange": "be479df5b4bb2001cc125bb2cd5431e316d0b787", "commitAfterChange": "e5d2b54b64c5be9c6975192bdd4dd72df228563d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate String processElement(ICompilationUnit unit, char[] source)", "signatureAfterChange": " \tprivate String processElement(ICompilationUnit unit, char[] source)", "diff": ["+\t\tdomUnit.accept(new ASTVisitor() {", "+\t\t\tpublic boolean visit(org.eclipse.jdt.core.dom.CompilationUnit compilationUnit) {", "+\t\t\t\tList types = compilationUnit.types();", "+\t\t\t\tfor (Iterator iter = types.iterator(); iter.hasNext();) {", "+\t\t\t\t\tAbstractTypeDeclaration typeDeclaration = (AbstractTypeDeclaration) iter.next();", "+\t\t\t\t\ttypeDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(typeDeclaration.getStartPosition()));", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\tpublic boolean visit(AnnotationTypeDeclaration annotationTypeDeclaration) {", "+\t\t\t\tList bodyDeclarations = annotationTypeDeclaration.bodyDeclarations();", "+\t\t\t\tfor (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {", "+\t\t\t\t\tBodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();", "+\t\t\t\t\tbodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+", "+\t\t\tpublic boolean visit(AnonymousClassDeclaration anonymousClassDeclaration) {", "+\t\t\t\tList bodyDeclarations = anonymousClassDeclaration.bodyDeclarations();", "+\t\t\t\tfor (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {", "+\t\t\t\t\tBodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();", "+\t\t\t\t\tbodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration) {", "+\t\t\t\tList bodyDeclarations = typeDeclaration.bodyDeclarations();", "+\t\t\t\tfor (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {", "+\t\t\t\t\tBodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();", "+\t\t\t\t\tbodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+", "+\t\t\tpublic boolean visit(EnumDeclaration enumDeclaration) {", "+\t\t\t\tList bodyDeclarations = enumDeclaration.bodyDeclarations();", "+\t\t\t\tfor (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {", "+\t\t\t\t\tBodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();", "+\t\t\t\t\tbodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}\t\t\t", "+\t\t});"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df5a3e8016d385ff850e372eaf29b490", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragment.java", "commitBeforeChange": "9de11e1c2a41a21613174b6ab91cab4369b64686", "commitAfterChange": "d8ffd58c7c4b7aeb0d38e216b7c221e9b8f78625", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " void computeNonJavaResources(String[] resNames, JarPackageFragmentInfo info, String zipName)", "signatureAfterChange": " void computeNonJavaResources(String[] resNames, JarPackageFragment pkg, JarPackageFragmentInfo info, String zipName)", "diff": ["-/* package */ void computeNonJavaResources(String[] resNames, JarPackageFragmentInfo info, String zipName) {", "+/* package */ void computeNonJavaResources(String[] resNames, JarPackageFragment pkg, JarPackageFragmentInfo info, String zipName) {", "-\t\tObject[] res = new Object[max];", "-\t\tint index = 0;", "+\t\tHashMap jarEntries = new HashMap(); // map from IPath to IJarEntryResource", "+\t\tHashMap childrenMap = new HashMap(); // map from IPath to ArrayList<IJarEntryResource>", "+\t\tArrayList topJarEntries = new ArrayList();", "-\t\t\t\tIPath parentRelativePath = new Path(resName).removeFirstSegments(this.names.length);", "-\t\t\t\tres[index++] = new JarEntryFile(resName, zipName, parentRelativePath);", "+\t\t\t\tIPath childPath = new Path(resName).removeFirstSegments(this.names.length);", "+\t\t\t\tJarEntryFile file = new JarEntryFile(resName, zipName, childPath);", "+\t\t\t\tjarEntries.put(childPath, file);", "+\t\t\t\tif (childPath.segmentCount() == 1) {", "+\t\t\t\t\tfile.setParent(pkg);", "+\t\t\t\t\ttopJarEntries.add(file);", "+\t\t\t\t} else {", "+\t\t\t\t\tIPath parentPath = childPath.removeLastSegments(1);", "+\t\t\t\t\twhile (parentPath.segmentCount() > 0) {", "+\t\t\t\t\t\tArrayList parentChildren = (ArrayList) childrenMap.get(parentPath);", "+\t\t\t\t\t\tif (parentChildren == null) {", "+\t\t\t\t\t\t\tObject dir = new JarEntryDirectory(parentPath);", "+\t\t\t\t\t\t\tjarEntries.put(parentPath, dir);", "+\t\t\t\t\t\t\tchildrenMap.put(parentPath, parentChildren = new ArrayList());", "+\t\t\t\t\t\t\tparentChildren.add(childPath);", "+\t\t\t\t\t\t\tif (parentPath.segmentCount() == 1) {", "+\t\t\t\t\t\t\t\ttopJarEntries.add(dir);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tchildPath = parentPath;", "+\t\t\t\t\t\t\tparentPath = childPath.removeLastSegments(1);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tparentChildren.add(childPath);", "+\t\t\t\t\t\t\tbreak; // all parents are already registered", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t} ", "-\t\tif (index != max) {", "-\t\t\tSystem.arraycopy(res, 0, res = new Object[index], 0, index);", "+\t\tIterator entries = childrenMap.entrySet().iterator();", "+\t\twhile (entries.hasNext()) {", "+\t\t\tMap.Entry entry = (Map.Entry) entries.next();", "+\t\t\tIPath entryPath = (IPath) entry.getKey();", "+\t\t\tArrayList entryValue =  (ArrayList) entry.getValue();", "+\t\t\tJarEntryDirectory jarEntryDirectory = (JarEntryDirectory) jarEntries.get(entryPath);", "+\t\t\tint size = entryValue.size();", "+\t\t\tIJarEntryResource[] children = new IJarEntryResource[size];", "+\t\t\tfor (int i = 0; i < size; i++) {", "+\t\t\t\tObject child = jarEntries.get(entryValue.get(i));", "+\t\t\t\tif (child instanceof JarEntryFile) {", "+\t\t\t\t\t((JarEntryFile) child).setParent(jarEntryDirectory);", "+\t\t\t\t} else {", "+\t\t\t\t\t((JarEntryDirectory) child).setParent(jarEntryDirectory);", "+\t\t\t\t}", "+\t\t\t\tchildren[i] = (IJarEntryResource) child;", "+\t\t\t}", "+\t\t\tjarEntryDirectory.setChildren(children);", "+\t\t\tif (entryPath.segmentCount() == 1) {", "+\t\t\t\tjarEntryDirectory.setParent(pkg);", "+\t\t\t}", "+\t\t}", "+\t\tObject[] res = topJarEntries.toArray(new Object[topJarEntries.size()]);"]}], "num": 68223}