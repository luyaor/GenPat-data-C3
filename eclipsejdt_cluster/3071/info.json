{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c8ee5b5513ee262e28d8d4d628858204", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "20d74226ac94c342af2684abc87d4dfd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "signatureAfterChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "diff": ["-\t\t\t\t\t\tReferenceBinding binding2 = problemReferenceBinding.closestMatch();", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding binding2 = problemReferenceBinding.closestMatch();", "-\t\t\t\t\tif (this.isRecoveredBinding) {", "-\t\t\t\t\t\tITypeBinding binding = (ITypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(referenceBinding);", "-\t\t\t\t\t\tif (binding != null) {", "-\t\t\t\t\t\t\treturn binding;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbinding = new RecoveredTypeBinding(this, referenceBinding);", "-\t\t\t\t\t\tthis.bindingTables.compilerBindingsToASTBindings.put(referenceBinding, binding);", "+\t\t\t\t\tITypeBinding binding = (ITypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(referenceBinding);", "+\t\t\t\t\tif (binding != null) {", "+\t\t\t\t\tif ((referenceBinding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\tbinding = new TypeBinding(this, referenceBinding);", "+\t\t\t\t\t} else if (this.isRecoveringBindings) {", "+\t\t\t\t\t\tbinding = new RecoveredTypeBinding(this, referenceBinding);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.bindingTables.compilerBindingsToASTBindings.put(referenceBinding, binding);", "+\t\t\t\t\treturn binding;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f046629351f5fe837c936d2b4ecbd20c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "30bcd436389796ede9b25cfba962b4a18b7675bd", "commitAfterChange": "d93134db10799af61489a9927044406c2353d246", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, ", "+\t\t       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references", "+\t\t       that constitute the inference per se. Also short circuit this step, if the substitution has no type variables in the first place ", "+\t\t       (as it is effectively a nop.)", "+\t\t     */ ", "+\t\t    TypeBinding substituteForChecks;", "+\t\t    if (substitute instanceof TypeVariableBinding || ((substitute.tagBits & TagBits.HasTypeVariable) == 0)) {", "+\t\t    \tsubstituteForChecks = substitute;", "+\t\t    } else {", "+\t\t    \tsubstituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "+\t\t    }", "+\t\t    "]}], "num": 3071}