{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3160bac3c2210451cf45f4508936bf5d", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d4dd3813e7ac2568eebdafbef3be5d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java", "commitBeforeChange": "1924cfa5e4209a8742be0104afe1beaad86d0922", "commitAfterChange": "dfe897878a3115c90160783084107f96dcd301be", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t \tpublic void suppressRecordedWarnings(int sourceStart, int sourceEnd, ProblemReporter problemReporter)", "signatureAfterChange": "  \tpublic void discardSuppressedWarnings()", "diff": ["+\tpublic void discardSuppressedWarnings() {", "+", "+\t\tif (this.suppressWarningsCount == 0) return;", "+\t\tint removed = 0;", "+\t\tnextProblem: for (int i = 0, length = this.problemCount; i < length; i++) {", "+\t\t\tIProblem problem = this.problems[i];", "+\t\t\tif (!problem.isWarning()) ", "+\t\t\t\tcontinue nextProblem;", "+\t\t\tint start = problem.getSourceStart();", "+\t\t\tint end = problem.getSourceEnd();", "+\t\t\tint problemID = problem.getID();", "+\t\t\tnextSuppress: for (int j = 0, max = this.suppressWarningsCount; j < max; j++) {", "+\t\t\t\tlong position = this.suppressWarningPositions[j];", "+\t\t\t\tint startSuppress = (int) (position >>> 32);", "+\t\t\t\tint endSuppress = (int) position;", "+\t\t\t\tif (start < startSuppress) continue nextSuppress;", "+\t\t\t\tif (end > endSuppress) continue nextSuppress;", "+\t\t\t\tif ((ProblemReporter.getIrritant(problemID) & this.suppressWarningIrritants[j]) == 0)", "+\t\t\t\t\tcontinue nextSuppress;", "+\t\t\t\t// discard suppressed warning", "+\t\t\t\tremoved++;", "+\t\t\t\tproblems[i] = null;", "+\t\t\t\tif (problemsMap != null) problemsMap.remove(problem);", "+\t\t\t\tcontinue nextProblem;", "+\t\t\t}", "+\t\t}", "+\t\tif (removed > 0) {", "+\t\t\tfor (int i = 0, index = 0; i < this.problemCount; i++) {", "+\t\t\t\tIProblem problem;", "+\t\t\t\tif ((problem = this.problems[i]) != null) {", "+\t\t\t\t\tif (i > index) {", "+\t\t\t\t\t\tthis.problems[index++] = problem;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.problemCount -= removed;", "+\t\t}", "+\t}", "-\t", "-\tpublic void suppressRecordedWarnings(int sourceStart, int sourceEnd, ProblemReporter problemReporter) {", "-\t\tint removed = 0;", "-\t\tint index = 0;", "-\t\tfor (int i = 0, length = this.problemCount; i < length; i++) {", "-\t\t\tIProblem problem = this.problems[i];", "-\t\t\tif (problem.isWarning() && problem.getSourceStart() >= sourceStart && problem.getSourceEnd() <= sourceEnd) {", "-\t\t\t\tif (problemReporter.computeSeverity(problem.getID()) == ProblemSeverities.Ignore) {", "-\t\t\t\t\tremoved++;", "-\t\t\t\t\tproblems[i] = null;", "-\t\t\t\t\tproblemsMap.remove(problem);", "-\t\t\t\t}", "-\t\t\t} else if (i > index) {", "-\t\t\t\tproblems[index++] = problem;", "-\t\t\t} else {", "-\t\t\t\tindex++;", "-\t\t\t}", "-\t\t}", "-\t\tthis.problemCount -= removed;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5dcb9e2d5dad7f75420faf00fe49b125", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "a289b2bef35844f69838cba7e382e98900bb75bf", "commitAfterChange": "81190a8f2edcd73602d2c6f116017af0ad27c7cf", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["+\t\t\t", "+\t\t\t/*", "+\t\t\t * if 1.4 compliant, must filter out redundant protected methods from superclasses", "+\t\t\t */", "+\t\t\tif (compilationUnitScope().environment.options.complianceLevel >= CompilerOptions.JDK1_4){\t\t\t ", "+\t\t\t\tnextMethod: for (int i = 0; i < currentLength; i++){", "+\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t// protected method need to be checked only - default access is already dealt with in #canBeSeen implementation", "+\t\t\t\t\t// when checking that p.C -> q.B -> p.A cannot see default access members from A through B.", "+\t\t\t\t\tif ((currentMethod.modifiers & AccProtected) == 0) continue nextMethod;", "+\t\t\t\t\tif (matchingMethod != null){", "+\t\t\t\t\t\tif (currentMethod.areParametersEqual(matchingMethod)){", "+\t\t\t\t\t\t\tcurrentLength--;", "+\t\t\t\t\t\t\tcurrentMethods[i] = null; // discard this match", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int j = 0, max = found.size; j < max; j++) {", "+\t\t\t\t\t\t\tif (((MethodBinding)found.elementAt(j)).areParametersEqual(currentMethod)){", "+\t\t\t\t\t\t\t\tcurrentLength--;", "+\t\t\t\t\t\t\t\tcurrentMethods[i] = null;", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "-\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t// append currentMethods, filtering out null entries", "+\t\t\t\tint maxMethod = currentMethods.length;", "+\t\t\t\tif (maxMethod == currentLength) { // no method was eliminated for 1.4 compliance (see above)", "+\t\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t} else {", "+\t\t\t\t\tfor (int i = 0, max = currentMethods.length; i < max; i++) {", "+\t\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t\tif (currentMethod != null) found.add(currentMethod);", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 747}