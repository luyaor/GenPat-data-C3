{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "80c9c7c46170bf1e203f2c687b7bf68e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53e32ba90b0c8a8850fabd645b21e89a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "diff": ["-\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "-\t\t\tfirstColumn++;", "-\t\tStringBuffer indentationBuffer = printJavadocIndentationBuffer(block, firstColumn);", "-\t\tif (!block.isDescription()) {", "-\t\t\tthis.column += previousEnd - block.sourceStart + 1;", "+\t\tif (block.isDescription()) {", "+\t\t\tif (!block.isInlined()) {", "+\t\t\t    this.commentIndentation = null;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tint tagLength = previousEnd - block.sourceStart + 1;", "+\t\t\tthis.column += tagLength;", "+\t\t\tif (!block.isInlined()) {", "+\t\t\t    boolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();", "+\t\t\t    int commentIndentationLevel = 0;", "+\t\t\t\tif (indentRootTags) {", "+\t\t\t\t    commentIndentationLevel = tagLength + 1;", "+\t\t\t\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();", "+\t\t\t\t\tif (indentParamTag) {", "+\t\t\t\t\t\tcommentIndentationLevel += this.indentationSize;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (commentIndentationLevel == 0) {", "+\t\t\t\t    this.commentIndentation = null;", "+\t\t\t\t} else {", "+\t\t    \t\tStringBuffer indentationBuffer = new StringBuffer();", "+\t\t        \tfor (int i=0; i<commentIndentationLevel; i++) {", "+\t\t    \t\t\tindentationBuffer.append(' ');", "+\t\t        \t}", "+\t        \t\tthis.commentIndentation = indentationBuffer.toString();", "+\t\t    \t}", "+\t\t\t}", "-\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\tprintJavadocBlockReference(buffer, reference, block);", "-\t\t\t    addReplaceEdit(previousEnd+1, reference.sourceEnd, buffer.toString());", "+\t\t\t\tprintJavadocBlockReference(block, reference);", "-\t\t\t\t\t// Need to print the closing brace", "-\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\t\tif ((this.column+1) > maxColumn) {", "-\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\t\t\tthis.line++;", "-\t\t\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t\t\t    \tthis.column = 1;", "-\t\t\t\t    \tprintIndentationIfNecessary(buffer);", "-\t\t\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "-\t\t\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "-\t\t\t\t    \tif (indentationBuffer != null) {", "-\t\t\t\t\t\t\tbuffer.append(indentationBuffer);", "-\t\t\t\t\t\t\tthis.column += indentationBuffer.length();", "-\t\t\t\t    \t}", "-\t\t\t\t    \theaderLine = false;", "-\t\t\t\t    \tmaxColumn--;", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.scanner.resetTo(previousEnd+1, block.sourceEnd+1);", "-\t\t\t\t\ttry {", "-\t                    int token = this.scanner.getNextToken();", "-\t                    while (token == TerminalTokens.TokenNameWHITESPACE || token == TerminalTokens.TokenNameMULTIPLY) {", "-\t                    \ttoken = this.scanner.getNextToken();", "-\t                    }", "-\t                    if (token == TerminalTokens.TokenNameRBRACE) {", "-\t\t                    buffer.append(this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition-this.scanner.startPosition);", "-\t\t\t\t\t    \tthis.column += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t                    }", "-                    } catch (InvalidInputException e) {", "-\t\t\t\t\t\tbuffer.append('}');", "-                    }", "-                    addReplaceEdit(previousEnd+1, block.sourceEnd, buffer.toString());", "+\t\t\t\t\tthis.column++;", "+\t\tint previousLine = 0;", "-\t\t\tint textLength = -1;", "-\t\t\t   \t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "+\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "+\t\t\t\tif (!clearBlankLines && node.lineStart > (previousLine+1)) newLines = node.lineStart - previousLine;", "-\t\t\t\t\t\t// Immutable tags are not formatted", "-\t\t\t\t\t\tif (textLength == -1) {", "-\t\t\t\t\t\t\ttextLength = getTextLength(block, text, false);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint additionalLength = printJavadocHtmlImmutableTag(text, block, newLines > 0);", "-\t\t\t\t\t\tthis.column += textLength - additionalLength;", "+\t\t\t\t\t\tif (newLines > 0 && this.commentIndentation != null) {", "+\t\t\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tprintJavadocHtmlImmutableTag(text, block, newLines > 0);", "+\t\t\t\t\t\tthis.column += getTextLength(block, text);", "-\t\t\t\tif (newLines > 0 && indentationBuffer != null) {", "-\t\t\t\t\taddInsertEdit(node.sourceStart, indentationBuffer.toString());", "-\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\tif (newLines > 0 && this.commentIndentation != null) {", "+\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\tpreviousLine = Util.getLineNumber(previousEnd, this.lineEnds, node.lineStart > 1 ? node.lineStart-2 : 0, this.maxLines);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f61720369a2fcf2d8f68c03ee09ea5e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "5292c15945b50fef548808f853ce39423b5670f2", "commitAfterChange": "e32dbbc9904e1f7eb4c6e79a7595e742217638b3", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlock(FormatJavadocBlock block)", "diff": ["+\t\t// Compute indentation", "+\t\tboolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;", "+\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "+\t\tif (headerLine) firstColumn++;", "+\t\tStringBuffer indentationBuffer = printJavadocIndentationBuffer(block, firstColumn);", "+", "-\t\tint maxColumn = this.formatter.preferences.comment_line_length;", "+\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tif (!block.isInlined()) {", "+\t\t\tthis.lastNumberOfNewLines = 0;", "+\t\t}", "-\t\t\tif (maxNodes < 0)  return;", "+\t\t\tif (maxNodes < 0)  {", "+\t\t\t\tif (block.isInlined()) {", "+\t\t\t\t\t// Need to print the closing brace", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\tif ((this.column+2) > (maxColumn+1)) {", "+\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\tthis.line++;", "+\t\t\t\t    \tbuffer.append(this.lineSeparator);", "+\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t    \tprintIndentationIfNecessary(buffer);", "+\t\t\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "+\t\t\t\t    \tif (indentationBuffer != null) {", "+\t\t\t\t\t\t\tbuffer.append(indentationBuffer);", "+\t\t\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\t    \t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scanner.resetTo(previousEnd+1, block.sourceEnd+1);", "+\t\t\t\t\ttry {", "+\t                    int token = this.scanner.getNextToken();", "+\t                    while (token == TerminalTokens.TokenNameWHITESPACE || token == TerminalTokens.TokenNameMULTIPLY) {", "+\t                    \ttoken = this.scanner.getNextToken();", "+\t                    }", "+\t                    buffer.append(this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition-this.scanner.startPosition);", "+                    } catch (InvalidInputException e) {", "+\t\t\t\t\t\tbuffer.append('}');", "+                    }", "+                    addReplaceEdit(previousEnd+1, block.sourceEnd, buffer.toString());", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "-\t\tif (block.isHeaderLine()) maxColumn++;", "+//\t\tif (block.isHeaderLine()) maxColumn++;", "-\t\t\t\tnewLines = this.formatter.preferences.comment_insert_new_line_for_parameter && !block.isInlined() && block.isParamTag() ? 1 : 0;", "+\t\t\t\tnewLines = this.formatter.preferences.comment_insert_new_line_for_parameter && block.isParamTag() ? 1 : 0;", "+\t\t\t\t\tif (newLines == 0) {", "+\t\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "+\t\t\t\t\t}", "-\t\t\t\tnewLines = this.column > this.formatter.preferences.comment_line_length ? 1 : 0;", "-\t\t\t\tif (node.isText()) {", "-\t\t\t\t\t// Need to verify if new line is necessary for immutable tag", "-\t\t\t\t\tFormatJavadocText text = (FormatJavadocText) node;", "-\t\t\t\t\tif (newLines < text.linesBefore) newLines = text.linesBefore;", "-\t\t\t\t\tif (newLines == 0 && text.isImmutableHtmlTag()) {", "-\t\t\t\t\t\ttextLength = getTextLength(block, text);", "-\t\t\t\t\t\tif ((this.column + textLength) > maxColumn) {", "-\t\t\t\t\t\t\tnewLines = 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\tnewLines = this.column > maxColumn ? 1 : 0;", "+\t\t\t\tif (newLines < node.linesBefore) newLines = node.linesBefore;", "+\t\t\t\tif (newLines == 0) {", "+\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "-\t\t\t\tif (!node.isText() || newLines > 0 || nodeStart > (previousEnd+1)) {", "-\t\t\t\t\tif (newLines == 0 && node.isText()) {", "-\t\t\t\t\t\t// Special case when two texts are consecutive (html tag->text or text->html tag)", "-\t\t\t\t\t\t// If no line is to be inserted, then no space should not be inserted either", "-\t\t\t\t\t\t// and column reset if the next token is over the max line length", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tthis.scanner.resetTo(nodeStart, block.sourceEnd);", "-\t\t\t\t\t\t\tthis.scanner.getNextToken();", "-\t\t\t\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t    \t\tif (((FormatJavadocText)node).isHtmlTag()) {", "-\t\t\t\t\t\t\t\t// read the html tag", "-\t\t\t\t\t\t\t\tif (this.scanner.getNextToken() == TerminalTokens.TokenNameDIVIDE) {", "-\t\t\t\t\t\t\t\t\ttokenLength++;", "-\t\t\t\t\t\t\t\t\tthis.scanner.getNextToken();", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\ttokenLength += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t\t\t\t\tthis.scanner.getNextToken(); // '>'", "-\t\t\t\t\t\t\t\ttokenLength++;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (nodeStart > (previousEnd+1)) {", "-\t\t\t\t\t\t\t\ttokenLength++; // include space between nodes", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif ((this.column + tokenLength) > maxColumn) {", "-\t\t\t\t\t\t\t\t// finally a new line will be inserted while printing next text", "-\t\t\t\t\t\t\t\tnewLines = 1;", "-\t\t\t\t\t\t\t\t((FormatJavadocText)node).linesBefore = 1;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t\t} catch (InvalidInputException iie) {", "-\t\t\t\t\t\t\t// skip", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t}", "+\t\t\t\tif (newLines > 0 || nodeStart > (previousEnd+1)) {", "+\t\t   \t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t\tprintJavadocHtmlTag(text, block);", "+\t\t\t\t\t\tprintJavadocHtmlTag(text, block, newLines>0);", "-\t\t\t\t\tprintJavadocText(text, block);", "+\t\t\t\t\tprintJavadocText(text, block, newLines>0);", "+\t\t\t\tif (newLines > 0 && indentationBuffer != null) {", "+\t\t\t\t\taddInsertEdit(node.sourceStart, indentationBuffer.toString());", "+\t\t\t\t\tthis.column += indentationBuffer.length();", "+\t\t\t\t}", "+\t\tthis.lastNumberOfNewLines = 0;"]}], "num": 66642}