{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "39e928aa59c6690e8e6feb1bb4802a0d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2be3bac0d722e809b87e8aeab66d3df9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-", "-", "+\t\tTypeBinding[] uncheckedArguments = null;", "-", "-", "+\t\t\t", "-", "+\t\t\t\tif (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7", "+\t\t\t\t\tint length = inferenceContext.substitutes.length;", "+\t\t\t\t\tSystem.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);", "+\t\t\t\t}", "-\t\tif (!methodSubstitute.isRaw) {", "-\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "-\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "-\t\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "-\t\t\t\tswitch (typeVariable.boundCheck(methodSubstitute, substitute)) {", "-\t\t\t\t\tcase TypeConstants.MISMATCH :", "-\t\t\t\t        // incompatible due to bound check", "-\t\t\t\t\t\tint argLength = arguments.length;", "-\t\t\t\t\t\tTypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable", "-\t\t\t\t\t\tSystem.arraycopy(arguments, 0, augmentedArguments, 0, argLength);", "-\t\t\t\t\t\taugmentedArguments[argLength] = substitute;", "-\t\t\t\t\t\taugmentedArguments[argLength+1] = typeVariable;", "-\t\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);", "-\t\t\t\t\tcase TypeConstants.UNCHECKED :", "-\t\t\t\t\t\t// tolerate unchecked bounds", "-\t\t\t\t\t\tmethodSubstitute.isUnchecked = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "+\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "+\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t    if (uncheckedArguments != null && uncheckedArguments[i] == null) continue; // only bound check if inferred through 15.12.2.6", "+\t\t\tswitch (typeVariable.boundCheck(methodSubstitute, substitute)) {", "+\t\t\t\tcase TypeConstants.MISMATCH :", "+\t\t\t        // incompatible due to bound check", "+\t\t\t\t\tint argLength = arguments.length;", "+\t\t\t\t\tTypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable", "+\t\t\t\t\tSystem.arraycopy(arguments, 0, augmentedArguments, 0, argLength);", "+\t\t\t\t\taugmentedArguments[argLength] = substitute;", "+\t\t\t\t\taugmentedArguments[argLength+1] = typeVariable;", "+\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);", "+\t\t\t\tcase TypeConstants.UNCHECKED :", "+\t\t\t\t\t// tolerate unchecked bounds", "+\t\t\t\t\tinvocationSite.setUnchecked(true);", "+\t\t\t\t\tbreak;", "+\t\t// check presence of unchecked argument conversion a posteriori (15.12.2.6)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f0a971f57e4b453dc8c699d5138d7d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "acc8bb9a2c395d7f5684b514d1321ba6377e97fd", "commitAfterChange": "dc9a89d9f844d31b09ec158bf347daa2976701f3", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tpublic MethodBinding getMethodBinding()", "signatureAfterChange": " \tpublic MethodBinding getMethodBinding()", "diff": ["-\t\t\t\tthis.actualMethodBinding = new MethodBinding(this.binding.modifiers, this.binding.selector, this.binding.returnType, ", "-\t\t\t\t\t\tthis.binding instanceof SyntheticMethodBinding ? this.descriptor.parameters : this.binding.parameters,  // retain any faults in parameter list.", "-\t\t\t\t\t\t\t\tthis.binding.thrownExceptions, this.binding.declaringClass);", "+\t\t\t\t// Get rid of the synthetic arguments added via addSyntheticArgument()", "+\t\t\t\tTypeBinding[] newParams = null;", "+\t\t\t\tif (this.binding instanceof SyntheticMethodBinding && this.outerLocalVariables.length > 0) {", "+\t\t\t\t\tnewParams = new TypeBinding[this.binding.parameters.length - this.outerLocalVariables.length];", "+\t\t\t\t\tSystem.arraycopy(this.binding.parameters, this.outerLocalVariables.length, newParams, 0, newParams.length);", "+\t\t\t\t} else {", "+\t\t\t\t\tnewParams = this.binding.parameters;", "+\t\t\t\t}", "+\t\t\t\tthis.actualMethodBinding = new MethodBinding(this.binding.modifiers, this.binding.selector,", "+\t\t\t\t\t\tthis.binding.returnType, newParams, this.binding.thrownExceptions, this.binding.declaringClass);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4583c5ee4df5b8784ecc8a71334f297c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.pluggable.tests/src/org/eclipse/jdt/apt/pluggable/tests/processors/genclass6/GenClass6Proc.java", "commitBeforeChange": "cae1ac0076053182a150a9a6566741ab9c075217", "commitAfterChange": "976283265acccc4408306834f2f927413343ea11", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate void generateType(GenClass6 genClassMirror, Element annotatedEl)", "signatureAfterChange": " \tprivate void processType(GenClass6 genClassMirror, Element annotatedEl)", "diff": ["-\tprivate void generateType(GenClass6 genClassMirror, Element annotatedEl) {", "+\tprivate void processType(GenClass6 genClassMirror, Element annotatedEl) {", "+\t\tString[] options = null;", "+\t\t\toptions = genClassMirror.options();", "+\t\t", "+\t\t// Options allow the processor to expose certain error conditions.", "+\t\tif (null != options) {", "+\t\t\tSet<String> optionSet = new HashSet<String>(Arrays.asList(options));", "+\t\t\t// See https://bugs.eclipse.org/269934: calling getEnclosedElements forces resolution of referenced types", "+\t\t\tif (optionSet.contains(\"forceElementResolution\")) {", "+\t\t\t\tannotatedEl.getEnclosedElements();", "+\t\t\t}", "+\t\t}", "+\t\t"]}], "num": 67893}