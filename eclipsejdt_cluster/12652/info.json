{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "aaf680ddc8026ab0cd27da3b469b332c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "003a0a58aea26ea8d88169f24e75a7fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AdvancedFactoryPathOptionsDialog.java", "commitBeforeChange": "3973964fa15a8c49d459282ce0d949753f7e2224", "commitAfterChange": "be99a78ebde70e086535a722e0c99b2c26590dce", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprotected Control createDialogArea(Composite parent)", "signatureAfterChange": "      \tprotected Control createDialogArea(Composite parent)", "diff": ["+    ", "+\tprotected Control createDialogArea(Composite parent) {", "+\t\tComposite dlgArea= (Composite) super.createDialogArea(parent);", "+\t\t// Set up \"batch mode\" checkbox.", "-", "-\tprotected Control createDialogArea(Composite parent) {", "-\t\tComposite composite= (Composite) super.createDialogArea(parent);", "-\t\t", "-\t\tComposite inner= new Composite(composite, SWT.NONE);", "-\t\tGridLayout layout= new GridLayout();", "-\t\tlayout.marginHeight= 0;", "-\t\tlayout.marginWidth= 0;", "-\t\tlayout.numColumns= 2;", "-\t\tinner.setLayout(layout);", "-\t\t", "-\t\t_batchModeField.doFillIntoGrid(inner, 2);", "-\t\t", "-\t\t// Plugins can't run in APT compatibility mode.", "+\t\t_batchModeField.doFillIntoGrid(dlgArea, 2);", "+\t\t\t// Plugins can't run in APT compatibility mode.", "-\t\tapplyDialogFont(composite);\t\t", "-\t\treturn composite;", "+\t\tDialogField.createEmptySpace(dlgArea, 1);", "+", "+\t\t// Set up label for processor contents list", "+\t\tLabel description= new Label(dlgArea, SWT.WRAP);", "+\t\tdescription.setText(Messages.AdvancedFactoryPathOptionsDialog_label_processorsInThisContainer); ", "+\t\tGridData gdLabel= new GridData(GridData.HORIZONTAL_ALIGN_FILL);", "+\t\tgdLabel.horizontalSpan= 2;", "+\t\tdescription.setLayoutData(gdLabel);", "+", "+\t\t// Set up processor contents list", "+\t\t_contentsField= new ListViewer(dlgArea, SWT.SINGLE | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);", "+        GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);", "+        data.heightHint = convertHeightInCharsToPixels(LIST_HEIGHT);", "+        data.widthHint = convertWidthInCharsToPixels(LIST_WIDTH);", "+        _contentsField.getList().setLayoutData(data);", "+        _contentsField.getList().setFont(parent.getFont());", "+        try {", "+\t        for (String name : _fc.getFactoryNames()) {", "+\t        \t_contentsField.add(name);", "+\t        }", "+        }", "+        catch (IOException e) {", "+\t\t\tfinal String message = \"Unable to load factory names from container [\" + _fc.getId() + \"]\"; //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\tExceptionHandler.log(e, message);", "+        }", "+        _contentsField.setSelection(null, false);", "+        ", "+\t\tapplyDialogFont(dlgArea);\t\t", "+\t\treturn dlgArea;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0985a9451b337c623b54ce69446f2ac8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java", "commitBeforeChange": "2daf63d08a96c2ed6e0e08ccfe89195f55d9f8ce", "commitAfterChange": "b4d3f967db596bbe85e51e090676967f450c3332", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "signatureAfterChange": "     @Override     public TypeMirror asMemberOf(DeclaredType containing, Element element)", "diff": ["-        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+//        throw new UnsupportedOperationException(\"NYI: TypesImpl.asMemberOf(\" + containing + \", \" + element + \")\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+    \tElementImpl elementImpl = (ElementImpl) element;", "+    \tDeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;", "+    \tReferenceBinding referenceBinding = (ReferenceBinding) declaredTypeImpl._binding;", "+    \tswitch(element.getKind()) {", "+    \t\tcase CONSTRUCTOR :", "+    \t\tcase METHOD :", "+    \t\t\tMethodBinding methodBinding = (MethodBinding) elementImpl._binding;", "+    \t\t\tif (methodBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (MethodBinding method : referenceBinding.methods()) {", "+    \t\t\t\tif (CharOperation.equals(method.selector, methodBinding.selector)", "+    \t\t\t\t\t\t&& method.areParameterErasuresEqual(methodBinding)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(method);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase FIELD :", "+    \t\t\tFieldBinding fieldBinding = (FieldBinding) elementImpl._binding;", "+    \t\t\tif (fieldBinding.declaringClass != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (FieldBinding field : referenceBinding.fields()) {", "+    \t\t\t\tif (CharOperation.equals(field.name, fieldBinding.name)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(field);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t\tcase ENUM :", "+    \t\tcase ANNOTATION_TYPE :", "+    \t\tcase INTERFACE :", "+    \t\tcase CLASS :", "+    \t\t\tReferenceBinding referenceBinding2 = (ReferenceBinding) elementImpl._binding;", "+    \t\t\tif (referenceBinding2.enclosingType() != referenceBinding) {", "+    \t\t\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$", "+    \t\t\t}", "+    \t\t\tfor (ReferenceBinding referenceBinding3 : referenceBinding.memberTypes()) {", "+    \t\t\t\tif (CharOperation.equals(referenceBinding3.compoundName, referenceBinding3.compoundName)) {", "+    \t\t\t\t\treturn this._env.getFactory().newTypeMirror(referenceBinding3);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tbreak;", "+    \t}", "+\t\tthrow new IllegalArgumentException(\"element is not valid for the containing declared type\"); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "601d34d7c064304ea3598f2574c2f69d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java", "commitBeforeChange": "4b460199498c48cda44ce10125aa5901a10bff62", "commitAfterChange": "ccd12469d7fc21a8e1a0a597451a059df56002ad", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static String formatJavadoc(char[] unparsed)", "signatureAfterChange": " \tprivate static String formatJavadoc(char[] unparsed)", "diff": ["-\tpublic static String formatJavadoc(char[] unparsed)", "+\tprivate static String formatJavadoc(char[] unparsed)", "-\t\t", "+", "-\t\t\treturn lines[0];", "-\t\t}", "-\t\t", "-\t\tint firstLine = lines[0].trim().length() > 0 ? 0 : 1;", "-\t\t", "-\t\t// for each line after the first, including the last, if it starts with whitespace", "-\t\t// followed by stars, skip all that. ", "-\t\tfor (int line = 1; line < lines.length; ++line) {", "-\t\t\tMatcher whitespaceMatcher = INITIAL_WHITESPACE_STARS.matcher(lines[line]);", "-\t\t\tif (whitespaceMatcher.find()) {", "-\t\t\t\tint firstAfterStars = whitespaceMatcher.end();", "-\t\t\t\tlines[line] = lines[line].substring(firstAfterStars);", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// If the last line is now empty, skip it", "-\t\tint lastLine = lines[lines.length - 1].trim().length() > 0 ? lines.length - 1 : lines.length - 2;", "-\t\t", "-\t\tStringBuilder sb = new StringBuilder();", "-\t\tfor (int line = firstLine; line <= lastLine; ++line) {", "-\t\t\tchar[] chars = lines[line].toCharArray();", "+\t\t\t// we should however remove the starting whitespaces", "+\t\t\tStringBuilder sb = new StringBuilder();", "+\t\t\tchar[] chars = lines[0].toCharArray();", "+\t\t\tboolean startingWhitespaces = true;", "-\t\t\t\tif (c == '\\t') {", "-\t\t\t\t\tfor (int i = 0; i < 8; i++) {", "-\t\t\t\t\t\tsb.append(' ');", "-\t\t\t\t\t}", "+\t\t\t\tif (Character.isWhitespace(c))", "+\t\t\t\t\tif (startingWhitespaces) {", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\tstartingWhitespaces = false;", "+\t\t\treturn sb.toString();", "+\t\t}", "+", "+\t\t// if the first line ends with spaces after the /** then we want to insert a line separator", "+\t\tint firstLine = lines[0].trim().length() > 0 ? 0 : 1;", "+", "+\t\t// If the last line is now empty, skip it", "+\t\tint lastLine = lines[lines.length - 1].trim().length() > 0 ? lines.length - 1 : lines.length - 2;", "+", "+\t\tStringBuilder sb = new StringBuilder();", "+\t\tif (lines[0].length() != 0 && firstLine == 1) {", "+\t\t\t// insert a line separator only if the remaining chars on the line are whitespaces", "+\t\t\tsb.append('\\n');", "+\t\t}", "+\t\tboolean preserveLineSeparator = lines[0].length() == 0;", "+\t\tfor (int line = firstLine; line <= lastLine; ++line) {", "+\t\t\tchar[] chars = lines[line].toCharArray();", "+\t\t\tint starsIndex = getStars(chars);", "+\t\t\tint leadingWhitespaces = 0;", "+\t\t\tboolean recordLeadingWhitespaces = true;", "+\t\t\tfor (int i = 0, max = chars.length; i < max; i++) {", "+\t\t\t\tchar c = chars[i];", "+\t\t\t\tswitch(c) {", "+\t\t\t\t\tcase '\\t' :", "+\t\t\t\t\t\tif (starsIndex == -1) {", "+\t\t\t\t\t\t\tif (recordLeadingWhitespaces) {", "+\t\t\t\t\t\t\t\tleadingWhitespaces += 8;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (i >= starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase ' ' :", "+\t\t\t\t\t\tif (starsIndex == -1) {", "+\t\t\t\t\t\t\tif (recordLeadingWhitespaces) {", "+\t\t\t\t\t\t\t\tleadingWhitespaces++;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (i >= starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\t// convert leadingwhitespaces to spaces", "+\t\t\t\t\t\trecordLeadingWhitespaces = false;", "+\t\t\t\t\t\tif (leadingWhitespaces != 0) {", "+\t\t\t\t\t\t\tint numberOfTabs = leadingWhitespaces / 8;", "+\t\t\t\t\t\t\tif (numberOfTabs != 0) {", "+\t\t\t\t\t\t\t\tfor (int j = 0, max2 = numberOfTabs; j < max2; j++) {", "+\t\t\t\t\t\t\t\t\tsb.append(\"        \"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif ((leadingWhitespaces % 8) >= 1) {", "+\t\t\t\t\t\t\t\t\tsb.append(' ');", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (line != 0) {", "+\t\t\t\t\t\t\t\t// we don't want to preserve the leading spaces for the first line", "+\t\t\t\t\t\t\t\tfor (int j = 0, max2 = leadingWhitespaces; j < max2; j++) {", "+\t\t\t\t\t\t\t\t\tsb.append(' ');", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tleadingWhitespaces = 0;", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t} else if (c != '*' || i > starsIndex) {", "+\t\t\t\t\t\t\tsb.append(c);", "+\t\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "-\t\t\tif (line < lines.length - 1) {", "+\t\t\tint end = lines.length - 1;", "+\t\t\tif (line < end) {", "+\t\t\t\tsb.append('\\n');", "+\t\t\t} else if (preserveLineSeparator && line == end) {"]}], "num": 12652}