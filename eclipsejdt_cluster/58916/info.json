{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "124dc7c3fb4a94551a369e2d10bc1977", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37ae0f216d904670bdcbfa029c02cb71", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java", "commitBeforeChange": "0199702ff6cca8392f62e334c86875a1b31484e2", "commitAfterChange": "4d36cf912bda83cf994dbb030b9c8cbc9e169048", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tvoid findMatches(SearchPattern pattern, SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tvoid findMatches(SearchPattern pattern, SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException", "diff": ["-\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.beginTask(Messages.engine_searching, 100 * length);", "+\t\t\tSubMonitor loopMonitor = SubMonitor.convert(monitor, Messages.engine_searching, length);", "-\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t\t\t\tSubMonitor iterationMonitor = loopMonitor.split(1).setWorkRemaining(100);", "-\t\t\t\t\tif (monitor != null) monitor.subTask(Messages.bind(Messages.engine_searching_indexing, new String[] {participant.getDescription()}));", "+\t\t\t\t\titerationMonitor.subTask(Messages.bind(Messages.engine_searching_indexing, new String[] {participant.getDescription()}));", "-\t\t\t\t\t\tmonitor==null ? null : new SubProgressMonitor(monitor, 50));", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();", "+\t\t\t\t\t\titerationMonitor.split(50));", "-\t\t\t\t\tif (monitor != null) monitor.subTask(Messages.bind(Messages.engine_searching_matching, new String[] {participant.getDescription()}));", "+\t\t\t\t\titerationMonitor.subTask(Messages.bind(Messages.engine_searching_matching, new String[] {participant.getDescription()}));", "-\t\t\t\t\t\tparticipant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : new SubProgressMonitor(monitor, 50));", "+\t\t\t\t\t\tparticipant.locateMatches(matches, pattern, scope, requestor, iterationMonitor.split(50));", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.done();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db591901a9f941c6c0fbe03c438032ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "0199702ff6cca8392f62e334c86875a1b31484e2", "commitAfterChange": "4d36cf912bda83cf994dbb030b9c8cbc9e169048", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 49, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\tSubMonitor mainMonitor = SubMonitor.convert(monitor, Messages.javamodel_initialization, 100);", "+\t\tmainMonitor.subTask(Messages.javamodel_configuring_classpath_containers);", "+", "+\t\t// initialize all containers and variables", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\t\tif (monitor != null) {", "-\t\t\t\tmonitor.beginTask(Messages.javamodel_initialization, 100);", "-\t\t\t\tmonitor.subTask(Messages.javamodel_configuring_classpath_containers);", "-\t\t\t}", "-", "-\t\t\t// initialize all containers and variables", "-\t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\t\tSubProgressMonitor subMonitor = null;", "-\t\t\ttry {", "-\t\t\t\tif (monitor != null) {", "-\t\t\t\t\tsubMonitor = new SubProgressMonitor(monitor, 50); // 50% of the time is spent in initializing containers and variables", "-\t\t\t\t\tsubMonitor.beginTask(\"\", 100); //$NON-NLS-1$", "-\t\t\t\t\tsubMonitor.worked(5); // give feedback to the user that something is happening", "-\t\t\t\t\tmanager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);", "-\t\t\t\t}", "-\t\t\t\tif (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations", "-\t\t\t\t\tmanager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization", "-\t\t\t\t} else { // else wait for the batch initialization to finish", "-\t\t\t\t\twhile (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {", "-\t\t\t\t\t\tif (subMonitor != null) {", "-\t\t\t\t\t\t\tsubMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);", "-\t\t\t\t\t\t\tsubMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tsynchronized(manager) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tmanager.wait(100);", "-\t\t\t\t\t\t\t} catch (InterruptedException e) {", "-\t\t\t\t\t\t\t\t// continue", "-\t\t\t\t\t\t\t}", "+\t\t\tSubMonitor subMonitor = mainMonitor.split(50).setWorkRemaining(100); // 50% of the time is spent in initializing containers and variables", "+\t\t\tsubMonitor.worked(5); // give feedback to the user that something is happening", "+\t\t\tmanager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);", "+\t\t\tif (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations", "+\t\t\t\tmanager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization", "+\t\t\t} else { // else wait for the batch initialization to finish", "+\t\t\t\twhile (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {", "+\t\t\t\t\tsubMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);", "+\t\t\t\t\tsubMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());", "+\t\t\t\t\tsynchronized(manager) {", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tmanager.wait(100);", "+\t\t\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\t\t\t// continue", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tif (subMonitor != null)", "-\t\t\t\t\tsubMonitor.done();", "-\t\t\t\tmanager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);", "-\t\t\t}", "-", "-\t\t\t// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )", "-\t\t\t// and recreate links for external folders if needed", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.subTask(Messages.javamodel_resetting_source_attachment_properties);", "-\t\t\tfinal IJavaProject[] projects = manager.getJavaModel().getJavaProjects();", "-\t\t\tHashSet visitedPaths = new HashSet();", "-\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "-\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "-\t\t\t\tIClasspathEntry[] classpath;", "-\t\t\t\ttry {", "-\t\t\t\t\tclasspath = javaProject.getResolvedClasspath();", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// project no longer exist: ignore", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t\t\t\tif (classpath != null) {", "-\t\t\t\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {", "-\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "-\t\t\t\t\t\tif (entry.getSourceAttachmentPath() != null) {", "-\t\t\t\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\t\t\t\tif (visitedPaths.add(entryPath)) {", "-\t\t\t\t\t\t\t\tUtil.setSourceAttachmentProperty(entryPath, null);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it", "-\t\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "-\t\t\t\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\t\t\t\tif (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {", "-\t\t\t\t\t\t\t\texternalFoldersManager.addFolder(entryPath, true);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\ttry {", "-\t\t\t\texternalFoldersManager.createPendingFolders(monitor);", "-\t\t\t}", "-\t\t\tcatch(JavaModelException jme) {", "-\t\t\t\t// Creation of external folder project failed. Log it and continue;", "-\t\t\t\tUtil.log(jme, \"Error while processing external folders\"); //$NON-NLS-1$", "-\t\t\t}", "-", "-\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "-\t\t\t// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)", "-\t\t\tfinal JavaModel model = manager.getJavaModel();", "-\t\t\ttry {", "-\t\t\t\tif (monitor != null)", "-\t\t\t\t\tmonitor.subTask(Messages.javamodel_refreshing_external_jars);", "-\t\t\t\tmodel.refreshExternalArchives(", "-\t\t\t\t\tnull/*refresh all projects*/,", "-\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh", "-\t\t\t\t);", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// refreshing failed: ignore", "-\t\t\t}", "-", "-\t\t\t// initialize delta state", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.subTask(Messages.javamodel_initializing_delta_state);", "-\t\t\tmanager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties", "-\t\t\tmanager.deltaState.initializeRoots(true/*initAfteLoad*/);", "-", "-\t\t\t// dummy query for waiting until the indexes are ready", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.subTask(Messages.javamodel_configuring_searchengine);", "-\t\t\tSearchEngine engine = new SearchEngine();", "-\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope();", "-\t\t\ttry {", "-\t\t\t\tengine.searchAllTypeNames(", "-\t\t\t\t\tnull,", "-\t\t\t\t\tSearchPattern.R_EXACT_MATCH,", "-\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "-\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "-\t\t\t\t\tIJavaSearchConstants.CLASS,", "-\t\t\t\t\tscope,", "-\t\t\t\t\tnew TypeNameRequestor() {", "-\t\t\t\t\t\tpublic void acceptType(", "-\t\t\t\t\t\t\tint modifiers,", "-\t\t\t\t\t\t\tchar[] packageName,", "-\t\t\t\t\t\t\tchar[] simpleTypeName,", "-\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "-\t\t\t\t\t\t\tString path) {", "-\t\t\t\t\t\t\t// no type to accept", "-\t\t\t\t\t\t}", "-\t\t\t\t\t},", "-\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "-\t\t\t\t\t// to wait until indexes are fully rebuild", "-\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "-\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 49) // 49% of the time is spent in the dummy search", "-\t\t\t\t);", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// /search failed: ignore", "-\t\t\t} catch (OperationCanceledException e) {", "-\t\t\t\tif (monitor != null && monitor.isCanceled())", "-\t\t\t\t\tthrow e;", "-\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "-\t\t\t}", "-", "-\t\t\t// check if the build state version number has changed since last session", "-\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "-\t\t\tif (monitor != null)", "-\t\t\t\tmonitor.subTask(Messages.javamodel_getting_build_state_number);", "-\t\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "-\t\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "-\t\t\tString versionNumber = null;", "-\t\t\ttry {", "-\t\t\t\tversionNumber = root.getPersistentProperty(qName);", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\t// could not read version number: consider it is new", "-\t\t\t}", "-\t\t\tString newVersionNumber = Byte.toString(State.VERSION);", "-\t\t\tif (!newVersionNumber.equals(versionNumber)) {", "-\t\t\t\t// build state version number has changed: touch every projects to force a rebuild", "-\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "-\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "-\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "-\t\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\t\t\t\t\tIJavaProject project = projects[i];", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\tnew ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164", "-\t\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "-\t\t\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t\t\t// could not touch this project: ignore", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t};", "-\t\t\t\tif (monitor != null)", "-\t\t\t\t\tmonitor.subTask(Messages.javamodel_building_after_upgrade);", "-\t\t\t\ttry {", "-\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, monitor);", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t// could not touch all projects", "-\t\t\t\t}", "-\t\t\t\ttry {", "-\t\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "-\t\t\tif (monitor != null) monitor.done();", "+\t\t\tmanager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);", "+\t\t}", "+", "+\t\t// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )", "+\t\t// and recreate links for external folders if needed", "+\t\tmainMonitor.subTask(Messages.javamodel_resetting_source_attachment_properties);", "+\t\tfinal IJavaProject[] projects = manager.getJavaModel().getJavaProjects();", "+\t\tHashSet visitedPaths = new HashSet();", "+\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "+\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "+\t\t\tIClasspathEntry[] classpath;", "+\t\t\ttry {", "+\t\t\t\tclasspath = javaProject.getResolvedClasspath();", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// project no longer exist: ignore", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (classpath != null) {", "+\t\t\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {", "+\t\t\t\t\tIClasspathEntry entry = classpath[j];", "+\t\t\t\t\tif (entry.getSourceAttachmentPath() != null) {", "+\t\t\t\t\t\tIPath entryPath = entry.getPath();", "+\t\t\t\t\t\tif (visitedPaths.add(entryPath)) {", "+\t\t\t\t\t\t\tUtil.setSourceAttachmentProperty(entryPath, null);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it", "+\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\t\tIPath entryPath = entry.getPath();", "+\t\t\t\t\t\tif (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {", "+\t\t\t\t\t\t\texternalFoldersManager.addFolder(entryPath, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\ttry {", "+\t\t\texternalFoldersManager.createPendingFolders(mainMonitor.split(1));", "+\t\t}", "+\t\tcatch(JavaModelException jme) {", "+\t\t\t// Creation of external folder project failed. Log it and continue;", "+\t\t\tUtil.log(jme, \"Error while processing external folders\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)", "+\t\tfinal JavaModel model = manager.getJavaModel();", "+\t\ttry {", "+\t\t\tmainMonitor.subTask(Messages.javamodel_refreshing_external_jars);", "+\t\t\tmodel.refreshExternalArchives(", "+\t\t\t\tnull/*refresh all projects*/,", "+\t\t\t\tmainMonitor.split(1) // 1% of the time is spent in jar refresh", "+\t\t\t);", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// refreshing failed: ignore", "+\t\t}", "+", "+\t\t// initialize delta state", "+\t\tmainMonitor.subTask(Messages.javamodel_initializing_delta_state);", "+\t\tmanager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties", "+\t\tmanager.deltaState.initializeRoots(true/*initAfteLoad*/);", "+", "+\t\t// dummy query for waiting until the indexes are ready", "+\t\tmainMonitor.subTask(Messages.javamodel_configuring_searchengine);", "+\t\tSearchEngine engine = new SearchEngine();", "+\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope();", "+\t\ttry {", "+\t\t\tengine.searchAllTypeNames(", "+\t\t\t\tnull,", "+\t\t\t\tSearchPattern.R_EXACT_MATCH,", "+\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "+\t\t\t\tIJavaSearchConstants.CLASS,", "+\t\t\t\tscope,", "+\t\t\t\tnew TypeNameRequestor() {", "+\t\t\t\t\tpublic void acceptType(", "+\t\t\t\t\t\tint modifiers,", "+\t\t\t\t\t\tchar[] packageName,", "+\t\t\t\t\t\tchar[] simpleTypeName,", "+\t\t\t\t\t\tchar[][] enclosingTypeNames,", "+\t\t\t\t\t\tString path) {", "+\t\t\t\t\t\t// no type to accept", "+\t\t\t\t\t}", "+\t\t\t\t},", "+\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "+\t\t\t\t// to wait until indexes are fully rebuild", "+\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "+\t\t\t\tmainMonitor.split(47) // 47% of the time is spent in the dummy search", "+\t\t\t);", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// /search failed: ignore", "+\t\t} catch (OperationCanceledException e) {", "+\t\t\tif (mainMonitor.isCanceled())", "+\t\t\t\tthrow e;", "+\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "+\t\t}", "+", "+\t\t// check if the build state version number has changed since last session", "+\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "+\t\tmainMonitor.subTask(Messages.javamodel_getting_build_state_number);", "+\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "+\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "+\t\tString versionNumber = null;", "+\t\ttry {", "+\t\t\tversionNumber = root.getPersistentProperty(qName);", "+\t\t} catch (CoreException e) {", "+\t\t\t// could not read version number: consider it is new", "+\t\t}", "+\t\tString newVersionNumber = Byte.toString(State.VERSION);", "+\t\tif (!newVersionNumber.equals(versionNumber)) {", "+\t\t\t// build state version number has changed: touch every projects to force a rebuild", "+\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "+\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "+\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "+\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\t\tIJavaProject project = projects[i];", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "+\t\t\t\t\t\t\tnew ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164", "+\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "+\t\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\t\t// could not touch this project: ignore", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tmainMonitor.subTask(Messages.javamodel_building_after_upgrade);", "+\t\t\ttry {", "+\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, mainMonitor.split(1));", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\t// could not touch all projects", "+\t\t\t}", "+\t\t\ttry {", "+\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "+\t\t\t}"]}], "num": 58916}