{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "969ff917dc4b3d8716d7f0ae659348d2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "010a348393bdbfe67627de8d512c6e38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "signatureAfterChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "diff": ["-\tchar[] superclassName = binaryType.getSuperclassName();", "-\tif (superclassName != null)", "-\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "-\t\tthis.superclass = environment.getTypeFromConstantPoolName(superclassName, 0, -1);", "-", "+\t// need enclosing type to access type variables", "-\t\tthis.enclosingType = environment.getTypeFromConstantPoolName(enclosingTypeName, 0, -1);", "+\t\tthis.enclosingType = environment.getTypeFromConstantPoolName(enclosingTypeName, 0, -1, true); // pretend parameterized to avoid raw", "+\t\tthis.tagBits |= \tHasUnresolvedEnclosingType;", "+\t}", "+", "+\tboolean checkGenericSignatures = environment.options.sourceLevel >= ClassFileConstants.JDK1_5;", "+\tchar[] typeSignature = checkGenericSignatures ? binaryType.getGenericSignature() : null;", "+\tif (typeSignature == null) {", "+\t\tchar[] superclassName = binaryType.getSuperclassName();", "+\t\tif (superclassName != null) {", "+\t\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tthis.superclass = environment.getTypeFromConstantPoolName(superclassName, 0, -1, false);", "+\t\t\tthis.tagBits |= \tHasUnresolvedSuperclass;", "+\t\t}", "+", "+\t\tthis.superInterfaces = NoSuperInterfaces;", "+\t\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "+\t\tif (interfaceNames != null) {", "+\t\t\tint size = interfaceNames.length;", "+\t\t\tif (size > 0) {", "+\t\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "+\t\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\t\tthis.superInterfaces[i] = environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false);", "+\t\t\t\tthis.tagBits |= \tHasUnresolvedSuperinterfaces;", "+\t\t\t}", "+\t\t}", "+\t} else {", "+\t\t// ClassSignature = ParameterPart(optional) super_TypeSignature interface_signature", "+\t\tSignatureWrapper wrapper = new SignatureWrapper(typeSignature);", "+\t\tif (wrapper.signature[wrapper.start] == '<') {", "+\t\t\t// ParameterPart = '<' ParameterSignature(s) '>'", "+\t\t\twrapper.start++; // skip '<'", "+\t\t\tint rank = 0;", "+\t\t\tdo {", "+\t\t\t\tTypeVariableBinding variable = createTypeVariable(wrapper, rank);", "+\t\t\t\tvariable.fPackage = this.fPackage;", "+\t\t\t\tSystem.arraycopy(this.typeVariables, 0, this.typeVariables = new TypeVariableBinding[rank + 1], 0, rank);", "+\t\t\t\tthis.typeVariables[rank++] = variable;", "+\t\t\t} while (wrapper.signature[wrapper.start] != '>');", "+\t\t\twrapper.start++; // skip '>'", "+\t\t\tthis.tagBits |=  HasUnresolvedTypeVariables;", "+\t\t\tthis.modifiers |= AccGenericSignature;", "+\t\t}", "+", "+\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\tthis.superclass = (ReferenceBinding) environment.getTypeFromTypeSignature(wrapper, NoTypeVariables, this);", "+\t\tthis.tagBits |= \tHasUnresolvedSuperclass;", "+", "+\t\tthis.superInterfaces = NoSuperInterfaces;", "+\t\tif (!wrapper.atEnd()) {", "+\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "+\t\t\tdo {", "+\t\t\t\ttypes.add(environment.getTypeFromTypeSignature(wrapper, NoTypeVariables, this));", "+\t\t\t} while (!wrapper.atEnd());", "+\t\t\tthis.superInterfaces = new ReferenceBinding[types.size()];", "+\t\t\ttypes.toArray(this.superInterfaces);", "+\t\t\tthis.tagBits |= \tHasUnresolvedSuperinterfaces;", "+\t\t}", "-\t\t\t\tthis.memberTypes[i] = environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1);", "+\t\t\t\tthis.memberTypes[i] = environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1, false);", "+\t\t\tthis.tagBits |= \tHasUnresolvedMemberTypes;", "-\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "-\tif (interfaceNames != null) {", "-\t\tint size = interfaceNames.length;", "-\t\tif (size > 0) {", "-\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "-\t\t\tfor (int i = 0; i < size; i++)", "-\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\t\tthis.superInterfaces[i] = environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1);", "-\t\t}", "-\t}", "-\t\tcreateFields(binaryType.getFields());", "-\t\tcreateMethods(binaryType.getMethods());", "+\t\tcreateFields(binaryType.getFields(), checkGenericSignatures);", "+\t\tcreateMethods(binaryType.getMethods(), checkGenericSignatures);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "abab1f800e66e4098964711ceefc380d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "1792e0070dc3b1849feda66768ccad0efbbe2ccb", "commitAfterChange": "dab5aa3bb8b075bbfc24a6c2d0ca56f5c17938c5", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "signatureAfterChange": "  void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods)", "diff": ["-\t// default initialization for super-interfaces early, in case some aborting compilation error occurs,", "-\t// and still want to use binaries passed that point (e.g. type hierarchy resolver, see bug 63748).", "-\tthis.typeVariables = Binding.NO_TYPE_VARIABLES;", "-\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "-", "-\t// must retrieve member types in case superclass/interfaces need them", "-\tthis.memberTypes = Binding.NO_MEMBER_TYPES;", "-\tIBinaryNestedType[] memberTypeStructures = binaryType.getMemberTypes();", "-\tif (memberTypeStructures != null) {", "-\t\tint size = memberTypeStructures.length;", "-\t\tif (size > 0) {", "-\t\t\tthis.memberTypes = new ReferenceBinding[size];", "-\t\t\tfor (int i = 0; i < size; i++)", "-\t\t\t\t// attempt to find each member type if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\t\tthis.memberTypes[i] = this.environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1, false, null /* could not be missing */);", "-\t\t\tthis.tagBits |= \tTagBits.HasUnresolvedMemberTypes;", "-\t\t}", "-\t}", "-", "-", "-\tlong sourceLevel = this.environment.globalOptions.sourceLevel;", "-\tchar[] typeSignature = null;", "-\tif (sourceLevel >= ClassFileConstants.JDK1_5) {", "-\t\ttypeSignature = binaryType.getGenericSignature();", "-\t\tthis.tagBits |= binaryType.getTagBits();", "-\t}", "-\tchar[][][] missingTypeNames = binaryType.getMissingTypeNames();", "-\tif (typeSignature == null) {", "-\t\tchar[] superclassName = binaryType.getSuperclassName();", "-\t\tif (superclassName != null) {", "-\t\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\tthis.superclass = this.environment.getTypeFromConstantPoolName(superclassName, 0, -1, false, missingTypeNames);", "-\t\t\tthis.tagBits |= TagBits.HasUnresolvedSuperclass;", "-\t\t}", "-", "+\ttry {", "+\t\t// default initialization for super-interfaces early, in case some aborting compilation error occurs,", "+\t\t// and still want to use binaries passed that point (e.g. type hierarchy resolver, see bug 63748).", "+\t\tthis.typeVariables = Binding.NO_TYPE_VARIABLES;", "-\t\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "-\t\tif (interfaceNames != null) {", "-\t\t\tint size = interfaceNames.length;", "+", "+\t\t// must retrieve member types in case superclass/interfaces need them", "+\t\tthis.memberTypes = Binding.NO_MEMBER_TYPES;", "+\t\tIBinaryNestedType[] memberTypeStructures = binaryType.getMemberTypes();", "+\t\tif (memberTypeStructures != null) {", "+\t\t\tint size = memberTypeStructures.length;", "-\t\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "+\t\t\t\tthis.memberTypes = new ReferenceBinding[size];", "-\t\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\t\t\tthis.superInterfaces[i] = this.environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false, missingTypeNames);", "+\t\t\t\t\t// attempt to find each member type if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\t\tthis.memberTypes[i] = this.environment.getTypeFromConstantPoolName(memberTypeStructures[i].getName(), 0, -1, false, null /* could not be missing */);", "+\t\t\t\tthis.tagBits |= \tTagBits.HasUnresolvedMemberTypes;", "+\t\t\t}", "+\t\t}", "+", "+\t\tlong sourceLevel = this.environment.globalOptions.sourceLevel;", "+\t\tchar[] typeSignature = null;", "+\t\tif (sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\ttypeSignature = binaryType.getGenericSignature();", "+\t\t\tthis.tagBits |= binaryType.getTagBits();", "+\t\t}", "+\t\tchar[][][] missingTypeNames = binaryType.getMissingTypeNames();", "+\t\tif (typeSignature == null) {", "+\t\t\tchar[] superclassName = binaryType.getSuperclassName();", "+\t\t\tif (superclassName != null) {", "+\t\t\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\tthis.superclass = this.environment.getTypeFromConstantPoolName(superclassName, 0, -1, false, missingTypeNames);", "+\t\t\t\tthis.tagBits |= TagBits.HasUnresolvedSuperclass;", "+\t\t\t}", "+", "+\t\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "+\t\t\tchar[][] interfaceNames = binaryType.getInterfaceNames();", "+\t\t\tif (interfaceNames != null) {", "+\t\t\t\tint size = interfaceNames.length;", "+\t\t\t\tif (size > 0) {", "+\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[size];", "+\t\t\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\t\t\tthis.superInterfaces[i] = this.environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false, missingTypeNames);", "+\t\t\t\t\tthis.tagBits |= TagBits.HasUnresolvedSuperinterfaces;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// ClassSignature = ParameterPart(optional) super_TypeSignature interface_signature", "+\t\t\tSignatureWrapper wrapper = new SignatureWrapper(typeSignature);", "+\t\t\tif (wrapper.signature[wrapper.start] == '<') {", "+\t\t\t\t// ParameterPart = '<' ParameterSignature(s) '>'", "+\t\t\t\twrapper.start++; // skip '<'", "+\t\t\t\tthis.typeVariables = createTypeVariables(wrapper, true, missingTypeNames);", "+\t\t\t\twrapper.start++; // skip '>'", "+\t\t\t\tthis.tagBits |=  TagBits.HasUnresolvedTypeVariables;", "+\t\t\t\tthis.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+\t\t\t}", "+\t\t\tTypeVariableBinding[] typeVars = Binding.NO_TYPE_VARIABLES;", "+\t\t\tchar[] methodDescriptor = binaryType.getEnclosingMethod();", "+\t\t\tif (methodDescriptor != null) {", "+\t\t\t\tMethodBinding enclosingMethod = findMethod(methodDescriptor, missingTypeNames);", "+\t\t\t\ttypeVars = enclosingMethod.typeVariables;", "+\t\t\t}", "+", "+\t\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tthis.superclass = (ReferenceBinding) this.environment.getTypeFromTypeSignature(wrapper, typeVars, this, missingTypeNames);", "+\t\t\tthis.tagBits |= TagBits.HasUnresolvedSuperclass;", "+", "+\t\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "+\t\t\tif (!wrapper.atEnd()) {", "+\t\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "+\t\t\t\tdo {", "+\t\t\t\t\ttypes.add(this.environment.getTypeFromTypeSignature(wrapper, typeVars, this, missingTypeNames));", "+\t\t\t\t} while (!wrapper.atEnd());", "+\t\t\t\tthis.superInterfaces = new ReferenceBinding[types.size()];", "+\t\t\t\ttypes.toArray(this.superInterfaces);", "-\t} else {", "-\t\t// ClassSignature = ParameterPart(optional) super_TypeSignature interface_signature", "-\t\tSignatureWrapper wrapper = new SignatureWrapper(typeSignature);", "-\t\tif (wrapper.signature[wrapper.start] == '<') {", "-\t\t\t// ParameterPart = '<' ParameterSignature(s) '>'", "-\t\t\twrapper.start++; // skip '<'", "-\t\t\tthis.typeVariables = createTypeVariables(wrapper, true, missingTypeNames);", "-\t\t\twrapper.start++; // skip '>'", "-\t\t\tthis.tagBits |=  TagBits.HasUnresolvedTypeVariables;", "-\t\t\tthis.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+", "+\t\tif (needFieldsAndMethods) {", "+\t\t\tcreateFields(binaryType.getFields(), sourceLevel, missingTypeNames);", "+\t\t\tcreateMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);", "-", "-\t\t// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)", "-\t\tthis.superclass = (ReferenceBinding) this.environment.getTypeFromTypeSignature(wrapper, Binding.NO_TYPE_VARIABLES, this, missingTypeNames);", "-\t\tthis.tagBits |= TagBits.HasUnresolvedSuperclass;", "-", "-\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "-\t\tif (!wrapper.atEnd()) {", "-\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "-\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "-\t\t\tdo {", "-\t\t\t\ttypes.add(this.environment.getTypeFromTypeSignature(wrapper, Binding.NO_TYPE_VARIABLES, this, missingTypeNames));", "-\t\t\t} while (!wrapper.atEnd());", "-\t\t\tthis.superInterfaces = new ReferenceBinding[types.size()];", "-\t\t\ttypes.toArray(this.superInterfaces);", "-\t\t\tthis.tagBits |= TagBits.HasUnresolvedSuperinterfaces;", "-\t\t}", "+\t\tif (this.environment.globalOptions.storeAnnotations)", "+\t\t\tsetAnnotations(createAnnotations(binaryType.getAnnotations(), this.environment, missingTypeNames));", "+\t} finally {", "+\t\t// protect against incorrect use of the needFieldsAndMethods flag, see 48459", "+\t\tif (this.fields == null)", "+\t\t\tthis.fields = Binding.NO_FIELDS;", "+\t\tif (this.methods == null)", "+\t\t\tthis.methods = Binding.NO_METHODS;", "-", "-\tif (needFieldsAndMethods) {", "-\t\tcreateFields(binaryType.getFields(), sourceLevel, missingTypeNames);", "-\t\tcreateMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);", "-\t} else { // protect against incorrect use of the needFieldsAndMethods flag, see 48459", "-\t\tthis.fields = Binding.NO_FIELDS;", "-\t\tthis.methods = Binding.NO_METHODS;", "-\t}", "-\tif (this.environment.globalOptions.storeAnnotations)", "-\t\tsetAnnotations(createAnnotations(binaryType.getAnnotations(), this.environment, missingTypeNames));"]}], "num": 29795}