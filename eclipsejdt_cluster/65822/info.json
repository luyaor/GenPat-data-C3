{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "04f86e34523e63c29a63fbd17ff24a59", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26579cbdf608f3b66ad90463e6950b68", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ChangeClasspathOperation.java", "commitBeforeChange": "350b82ab3c63ae55823f8e44a928b77c38cede62", "commitAfterChange": "25fc0dc927021078640560e2fe95e5127e517fc3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprotected void classpathChanged(JavaProject project) throws JavaModelException", "signatureAfterChange": " \tprotected void classpathChanged(JavaProject project) throws JavaModelException", "diff": ["+\t\t\t// workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=177922", "+\t\t\tif (isTopLevelOperation() && !ResourcesPlugin.getWorkspace().isTreeLocked()) {", "+\t\t\t\tnew ClasspathValidation(project).validate();", "+\t\t\t}", "+\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4232b741086723d07cc584784afacf86", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "e1454516411e21c76afb7797ea67208e4fc9c49d", "commitAfterChange": "85e7f681aa7d70ec863df3c9b4c8ff252b7d94c0", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["+\t\t\t\t\t\t\tif (matchingMethod.hasSubstitutedParameters() && !currentMethod.original().areParametersEqual(matchingMethod.original()))", "+\t\t\t\t\t\t\t\tcontinue nextMethod; // keep inherited substituted methods to detect anonymous errors"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65aaed54267ece9dfd6b3e572c168e00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "451a4290b08482db72c12f90b576f09a8da8fda2", "commitAfterChange": "68032f015aeece9b1e17b3f98b4f78c4d8098b12", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 75, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["+\t\t\t\t\t// pick a concrete method over a bridge method when parameters are equal since the return type of the concrete method is more specific", "+\t\t\t\t\tif (current.isBridge() && !next.isBridge())", "+\t\t\t\t\t\tif (tiebreakMethod.areParametersEqual(acceptable))", "+\t\t\t\t\t\t\tcontinue nextVisible; // skip current so acceptable wins over this bridge method"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e11662f6ae1390baa9eb627b36b4f88", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "021e686ee83a3b0326c84f6f27522d049b5f1c51", "commitAfterChange": "d82d2582a5a8021d8284aeaa33e16ef79de34fe9", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["+\t\t\t\t\tif (method.isAbstract() && method.declaringClass.isClass())", "+\t\t\t\t\t\tif (areReturnTypesCompatible(methods[j], method))", "+\t\t\t\t\t\t\tcontinue nextMethod; // return type of the superclass' inherited method is a supertype of the return type of the interface's method "]}], "num": 65822}