{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4bc81d28111becfc31bd08a933610957", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c8497a9fd1c44153bdb9d99e50d7306", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "99d47e4046e97803f75625986f5eb5ffc13cddfe", "commitAfterChange": "8282cb3c46786d73ca763e64384724ac9c0798d9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "diff": ["-\t", "-\tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope) {", "-\t    if (this.returnType == expectedType) ", "-\t        return;", "-\t    if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "-\t        return;", "-\t    Map substitutes = new HashMap(1);", "-\t    int length = this.typeArguments.length;", "+\t */", "+\tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes) {", "-\t    boolean hasUnboundParameters = false;", "-\t    for (int i = 0; i < length; i++) {", "-\t        if (this.typeArguments[i] == originalVariables[i]) {", "-\t            hasUnboundParameters = true;", "-\t        \tsubstitutes.put(originalVariables[i], new TypeBinding[1]);", "-\t        } else {", "-\t        \tsubstitutes.put(originalVariables[i], new TypeBinding[] { this.typeArguments[i] });", "-\t        }", "-\t    }", "-\t    if (!hasUnboundParameters)", "-\t        return;", "-\t    returnType.collectSubstitutes(expectedType, substitutes);", "-\t    if (substitutes.isEmpty()) {", "-\t    \t// raw generic method inferred", "-\t    \tthis.isRaw = true;", "-\t    \tfor (int i = 0; i < length; i++) {", "-\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "-\t    \t}", "-\t    } else {", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "-\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\t\tif (mostSpecificSubstitute == null) {", "-\t\t\t\t    return; // TODO (philippe) should report no way to infer type", "-\t\t\t\t}", "-\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "-\t\t\t\t\t// 15.12.2.8 - any remaining variable is assumed to be its erasure", "-\t\t\t\t\tmostSpecificSubstitute = originalVariables[i].erasure();", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\tthis.typeArguments[i] = mostSpecificSubstitute;", "+\t\tint varLength = originalVariables.length;", "+\t\t", "+\t\tcomputeSubstitutes: {", "+\t\t    // infer from expected return type", "+\t\t\tif (expectedType != null) {", "+\t\t\t    returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "-\t    }", "+\t\t    // infer from bounds of type parameters", "+\t\t\tfor (int i = 0; i < varLength; i++) {", "+\t\t\t\tTypeVariableBinding originalVariable = originalVariables[i];", "+\t\t\t\tTypeBinding argument = this.typeArguments[i];", "+\t\t\t\tif (originalVariable.firstBound == originalVariable.superclass) {", "+\t\t\t\t\tScope.substitute(this, originalVariable.firstBound) // substitue original bound with resolved variables", "+\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t}", "+\t\t\t\tfor (int j = 0, max = originalVariable.superInterfaces.length; j < max; j++) {", "+\t\t\t\t\tScope.substitute(this, originalVariable.superInterfaces[j]) // substitue original bound with resolved variables", "+\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tsubstitutes = resolveSubstituteConstraints(scope, originalVariables, substitutes, true/*consider Ti<:Uk*/, collectedSubstitutes);", "+\t\t\tif (substitutes == null) ", "+\t\t\t\treturn null; // incompatible", "+\t\t\tif (substitutes.length == 0) {", "+\t\t    \t// raw generic method inferred", "+\t\t    \tthis.isRaw = true;", "+\t\t    \tfor (int i = 0; i < varLength; i++) {", "+\t\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t\t    \t}", "+\t\t    \tbreak computeSubstitutes;", "+\t\t\t}", "+\t\t\t// this.typeArguments = substitutes; - no op since side effects got performed during #resolveSubstituteConstraints", "+\t    \tfor (int i = 0; i < varLength; i++) {", "+\t    \t\tTypeBinding substitute = substitutes[i];", "+\t    \t\tif (substitute != null) {", "+\t    \t\t\tthis.typeArguments[i] = substitutes[i];", "+\t    \t\t} else {", "+\t    \t\t\t// remaining unresolved variable are considered to be Object (or their bound actually)", "+\t\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t\t    \t}", "+\t    \t}", "+\t\t}\t\t", "+\t\t// adjust method types to reflect latest inference", "+\t    return this;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e19ed98e12c954fbe20b089fa947e489", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexBinaryFolder.java", "commitBeforeChange": "2acf337b771d06ad716c2ae54bdb8443b5b5d1d6", "commitAfterChange": "28f793f875e5d5b5aa1f2b69f1f41ea8e36715ac", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return COMPLETE;", "+\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return true;", "+\t\tif (!this.folder.isAccessible()) return true; // nothing to do", "-\t\tif (!this.folder.isAccessible())", "-\t\t\treturn COMPLETE; // nothing to do", "+\t\tIPath folderPath = this.folder.getFullPath();", "+\t\tIIndex index = this.manager.getIndex(folderPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\tif (index == null) return true;", "+\t\tReadWriteMonitor monitor = this.manager.getMonitorFor(index);", "+\t\tif (monitor == null) return true; // index got deleted since acquired", "-\t\tIIndex index = manager.getIndex(this.folder.getFullPath(), true /*reuse index file*/, true /*create if none*/);", "-\t\tif (index == null)", "-\t\t\treturn COMPLETE;", "-\t\tReadWriteMonitor monitor = manager.getMonitorFor(index);", "-\t\tif (monitor == null)", "-\t\t\treturn COMPLETE; // index got deleted since acquired", "+\t\t\tsaveIfNecessary(index, monitor);", "-\t\t\t/* if index has changed, commit these before querying */", "-\t\t\tif (index.hasChanged()) {", "-\t\t\t\ttry {", "-\t\t\t\t\tmonitor.exitRead(); // free read lock", "-\t\t\t\t\tmonitor.enterWrite(); // ask permission to write", "-\t\t\t\t\tif (IndexManager.VERBOSE)", "-\t\t\t\t\t\tJobManager.verbose(\"-> merging index \" + index.getIndexFile()); //$NON-NLS-1$", "-\t\t\t\t\tindex.save();", "-\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\treturn FAILED;", "-\t\t\t\t} finally {", "-\t\t\t\t\tmonitor.exitWriteEnterRead(); // finished writing and reacquire read permission", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tIQueryResult[] results = index.queryInDocumentNames(\"\"); // all file names //$NON-NLS-1$", "+\t\t\tint max = results == null ? 0 : results.length;", "+\t\t\tfinal Hashtable indexedFileNames = new Hashtable(100);", "-\t\t\tfinal long indexLastModified = index.getIndexFile().lastModified();", "-", "-\t\t\tfinal Hashtable indexedFileNames = new Hashtable(100);", "-\t\t\tIQueryResult[] results = index.queryInDocumentNames(\"\");// all file names //$NON-NLS-1$", "-\t\t\tfor (int i = 0, max = results == null ? 0 : results.length; i < max; i++) {", "-\t\t\t\tString fileName = results[i].getPath();", "-\t\t\t\tindexedFileNames.put(fileName, DELETED);", "-\t\t\t}", "-\t\t\tthis.folder.accept(new IResourceVisitor() {", "-\t\t\t\tpublic boolean visit(IResource resource) {", "-\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "-\t\t\t\t\t\tString extension = resource.getFileExtension();", "-\t\t\t\t\t\tif ((extension != null)", "-\t\t\t\t\t\t\t&& extension.equalsIgnoreCase(\"class\")) { //$NON-NLS-1$", "-\t\t\t\t\t\t\tIPath path = resource.getLocation();", "-\t\t\t\t\t\t\tif (path != null) {", "-\t\t\t\t\t\t\t\tFile resourceFile = path.toFile();", "+\t\t\tif (max == 0) {", "+\t\t\t\tthis.folder.accept(new IResourceVisitor() {", "+\t\t\t\t\tpublic boolean visit(IResource resource) {", "+\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "+\t\t\t\t\t\t\tif (Util.isClassFileName(resource.getName()) && resource.getLocation() != null) {", "-\t\t\t\t\t\t\t\tif (indexedFileNames.get(name) == null) {", "-\t\t\t\t\t\t\t\t\tindexedFileNames.put(name, resource);", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tindexedFileNames.put(", "-\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\tresourceFile.lastModified() > indexLastModified", "+\t\t\t\t\t\t\t\tindexedFileNames.put(name, resource);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t});", "+\t\t\t} else {", "+\t\t\t\tfor (int i = 0; i < max; i++)", "+\t\t\t\t\tindexedFileNames.put(results[i].getPath(), DELETED);", "+", "+\t\t\t\tfinal long indexLastModified = index.getIndexFile().lastModified();", "+\t\t\t\tthis.folder.accept(new IResourceVisitor() {", "+\t\t\t\t\tpublic boolean visit(IResource resource) {", "+\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "+\t\t\t\t\t\t\tif (Util.isClassFileName(resource.getName())) {", "+\t\t\t\t\t\t\t\tIPath path = resource.getLocation();", "+\t\t\t\t\t\t\t\tif (path != null) {", "+\t\t\t\t\t\t\t\t\tString name = new IFileDocument((IFile) resource).getName();", "+\t\t\t\t\t\t\t\t\tindexedFileNames.put(name,", "+\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(name) == null || indexLastModified < path.toFile().lastModified()", "+\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\treturn true;", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t});", "+\t\t\t\t});", "+\t\t\t}", "-\t\t\tIPath folderPath = this.folder.getFullPath();", "-\t\t\tIPath projectPath = this.project.getFullPath();", "+\t\t\tboolean shouldSave = false;", "-\t\t\t\tif (this.isCancelled) return FAILED;", "-\t\t\t\t", "+\t\t\t\tif (this.isCancelled) return false;", "+", "-\t\t\t\tif (value instanceof IFile) {", "-\t\t\t\t\tmanager.addBinary((IFile) value, folderPath);", "-\t\t\t\t} else if (value == DELETED) {", "-\t\t\t\t\tmanager.remove(name, projectPath);", "+\t\t\t\tif (value != OK) {", "+\t\t\t\t\tshouldSave = true;", "+\t\t\t\t\tif (value == DELETED)", "+\t\t\t\t\t\tthis.manager.remove(name, folderPath);", "+\t\t\t\t\telse", "+\t\t\t\t\t\tthis.manager.addBinary((IFile) value, folderPath);", "-\t\t\tmanager.request(new SaveIndex(folderPath, manager));", "+\t\t\tif (shouldSave)", "+\t\t\t\tthis.manager.request(new SaveIndex(folderPath, manager));", "-\t\t\tmanager.removeIndex(this.folder.getFullPath());", "-\t\t\treturn FAILED;", "+\t\t\tthis.manager.removeIndex(folderPath);", "+\t\t\treturn false;", "-\t\t\tmanager.removeIndex(this.folder.getFullPath());", "-\t\t\treturn FAILED;", "+\t\t\tthis.manager.removeIndex(folderPath);", "+\t\t\treturn false;", "-\t\treturn COMPLETE;", "+\t\treturn true;", "+\t}"]}], "num": 52290}