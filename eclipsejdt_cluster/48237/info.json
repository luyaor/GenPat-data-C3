{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db8c2b7f351e0f7767473d7975bf7871", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f091e8ba74300162238e53e2edac1ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "e5fda1d929f48b1ed961a5e3c698240a2263aa5e", "commitAfterChange": "492742130581f98e928eea7bd4ac7e448a4c7517", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "diff": ["+\t// need to find the overridden methods to avoid blaming this type for issues which are already reported against a supertype", "+\t// but cannot ignore an overridden inherited method completely when it comes to checking for bridge methods", "+\tint[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tproblemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// want to tag currentMethod even if return types are not equal", "-\t\tif (inheritedMethod.isAbstract()) {", "-\t\t\tif (inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing;", "-\t\t\t} else {", "-\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing | ExtraCompilerModifiers.AccOverriding;", "-\t\t\t}", "-// with the above change an abstract method is tagged as implementing the inherited abstract method", "-//\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-//\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-//\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "-\t\t\tif (reportIncompatibleReturnTypeError(currentMethod, inheritedMethod))", "+\t\tif (overriddenInheritedMethods == null || overriddenInheritedMethods[i] == 0) {", "+\t\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "+\t\t\t\tproblemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\t}", "-\t\tif (currentMethod.thrownExceptions != Binding.NO_EXCEPTIONS)", "-\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\t// want to tag currentMethod even if return types are not equal", "+\t\t\tif (inheritedMethod.isAbstract()) {", "+\t\t\t\tif (inheritedMethod.declaringClass.isInterface()) {", "+\t\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing;", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing | ExtraCompilerModifiers.AccOverriding;", "+\t\t\t\t}", "+//\t\t\twith the above change an abstract method is tagged as implementing the inherited abstract method", "+//\t\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "+//\t\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "+//\t\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "+\t\t\t} else {", "+\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccOverriding;", "+\t\t\t}", "+\t", "+\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "+\t\t\t\tif (reportIncompatibleReturnTypeError(currentMethod, inheritedMethod))", "+\t\t\t\t\tcontinue nextMethod;", "+\t", "+\t\t\tif (currentMethod.thrownExceptions != Binding.NO_EXCEPTIONS)", "+\t\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "+\t\t\tif (inheritedMethod.isFinal())", "+\t\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "+\t\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\t\tif (options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t", "+\t\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "628a9bdb6df3795f05ea612b580affc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["-}", "-void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t// methods includes the inherited methods that the currentMethod must comply with", "-\t// likely only 1 but could be more if mutiple declared supertypes define the method (1 superclass & 1 to many declared interfaces)", "-\tnextMethod : for (int i = length; --i >= 0;) {", "-\t\tMethodBinding inheritedMethod = methods[i];", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// curentMethod is always resolved as its defined by the source type BUT the inheritedMethod may not be", "-\t\t// so now with generics, the inheritedMethod should be resolved since we don't want to waste time dealing", "-\t\t// with Unresolved types over & over", "-\t\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "-\t\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "-", "-\t\tif (checkForNameClash(currentMethod, inheritedMethod)) {", "-\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType();", "-\t\tif (currentMethod.returnType != inheritedMethod.returnType) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t}", "-", "-\t\t\tTypeBinding inheritedReturnType = inheritedMethod.returnType.leafComponentType();", "-\t\t\tTypeBinding returnType = currentMethod.returnType.leafComponentType();", "-\t\t\tif (inheritedReturnType.isRawType()) {", "-\t\t\t\tif (returnType.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) returnType)) {", "-\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedReturnType.isParameterizedType()) {", "-\t\t\t\tif (!returnType.isParameterizedType()) ", "-\t\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod, ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t} else if (inheritedReturnType.isTypeVariable()) {", "-\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod,  ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t}", "-\t\t\taddBridgeMethod = true;", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!areReturnTypesEqual(original, currentMethod) || !areParametersEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+}", "+MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {", "+\tif (inheritedMethod == null) return null;", "+", "+\t// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved", "+\t// should we push these tests to where they're needed? returnType.isCompatibleWith && parameter isEquivalentTo ?", "+\tif (currentMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);", "+\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "+", "+\tTypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables();", "+\tif (inheritedTypeVariables == NoTypeVariables) return inheritedMethod;", "+\tTypeVariableBinding[] typeVariables = currentMethod == null ? NoTypeVariables : currentMethod.typeVariables;", "+", "+\tint inheritedLength = inheritedTypeVariables.length;", "+\tint length = typeVariables.length;", "+\tTypeBinding[] arguments = new TypeBinding[inheritedLength];", "+\tif (inheritedLength <= length) {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, inheritedLength);", "+\t} else {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, length);", "+\t\tfor (int i = length; i < inheritedLength; i++)", "+\t\t\targuments[i] = inheritedTypeVariables[i].erasure();", "+\t}", "+\tParameterizedGenericMethodBinding substitute =", "+\t\tnew ParameterizedGenericMethodBinding(inheritedMethod, arguments, this.environment);", "+\tfor (int i = 0; i < inheritedLength; i++)", "+\t    if (!inheritedTypeVariables[i].boundCheck(substitute, arguments[i]))", "+\t    \treturn inheritedMethod; // incompatible due to bound check", "+   return substitute;", "+}"]}], "num": 48237}