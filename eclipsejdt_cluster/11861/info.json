{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a4f5ac0729954f4749539a638073344d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34690fe04c284b49dda9058a77c4df33", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java", "commitBeforeChange": "3d73760dc9e0c52d27b28aa6b5ee7c1a07bc4ccf", "commitAfterChange": "510e79670ef0450a78c7882799bbb7cd266ab2e6", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 19, "signatureBeforeChange": " \t \tprivate TypeBinding cacheDerivedType(TypeBinding keyType, TypeBinding derivedType)", "signatureAfterChange": " \t \tprivate TypeBinding cacheDerivedType(TypeBinding keyType, TypeBinding derivedType)", "diff": ["-\t\tint i = 0, length = derivedTypes.length;", "-\t\twhile (i < length && derivedTypes[i] != null) {", "-\t\t\ti++;", "-\t\t}", "+\t\t// binary search for the *earliest* slot with a null reference. By design and construction, a null value will never be followed by a valid derived type.", "+\t\tint first, last,length = derivedTypes.length;", "+\t\tfirst = 0; last = length;", "+\t\tint i = (first + last) / 2;", "+\t\tdo {", "+\t\t\t  if (derivedTypes[i] == null) {", "+\t\t\t\t  if (i == first || i > 0 && derivedTypes[i - 1] != null)", "+\t\t\t\t\t  break;", "+\t\t\t\t  last = i - 1;", "+\t\t\t  } else { ", "+\t\t\t\t  first = i + 1;", "+\t\t\t  }", "+\t\t\t  i = (first + last) / 2;", "+\t\t} while (i < length && first <= last);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1ff911c7a1edaf4e6f7de849702e673", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "98c49c7e442095e4ddf2a6384735e696e7050501", "commitAfterChange": "182b54f27909efda960637e81e9fbc3f1f6ab16a", "methodNumberBeforeChange": 295, "methodNumberAfterChange": 296, "signatureBeforeChange": " public void recordPositionsFrom(int startPC, int sourcePos)", "signatureAfterChange": " public void recordPositionsFrom(int startPC, int sourcePos, boolean widen)", "diff": ["+}", "+public void recordPositionsFrom(int startPC, int sourcePos, boolean widen) {", "-\tif ((this.generateAttributes & ClassFileConstants.ATTR_LINES) == 0)", "-\t\treturn;", "-\tif (sourcePos == 0)", "-\t\treturn;", "-", "-\t// no code generated for this node. e.g. field without any initialization", "-\tif (position == startPC)", "+\tif ((this.generateAttributes & ClassFileConstants.ATTR_LINES) == 0", "+\t\t\t|| sourcePos == 0", "+\t\t\t|| (startPC == position && !widen))", "-\t\t\tif (startPC < lastEntryPC) {", "+\t\t\tif (startPC <= lastEntryPC) {", "-\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "-\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\tif (lastEntryPC == startPC || lastEntryPC == pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (pcToSourceMap[pcToSourceMapSize - 1] < lineNumber && widen) {", "+\t\t\t\t\t// see if we can widen the existing entry", "+\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;"]}], "num": 11861}