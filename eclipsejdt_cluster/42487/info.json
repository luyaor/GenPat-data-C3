{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "63bc7e822c12d1bd3c85ac0e0fc2edf3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26c8de7a121b93c79333e6434edf372f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "031774399eed50847f433b5425b7551aed0c6cbc", "commitAfterChange": "30ba2db951e79b89a330e1209e461b1c083d6de3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\t\treturn TypeBinding.NULL;", "+\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "+", "+\t\tTypeBinding expected = this.expectedType();", "+\t\tif (expected == null) return TypeBinding.NULL;", "+", "+\t\tMethodBinding singleAbstractMethod = expected.getSingleAbstractMethod();", "+\t\tif (this.arguments != null && singleAbstractMethod != null) {", "+\t\t\tint parameterCount = singleAbstractMethod.parameters != null ? singleAbstractMethod.parameters.length : 0;", "+\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+", "+\t\t\tif (parameterCount == lambdaArgumentCount) {", "+\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "+\t\t\t\t\tArgument argument = this.arguments[i];", "+\t\t\t\t\tif (argument.type != null) {", "+\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\targument.bind(this.scope, singleAbstractMethod.parameters[i], false);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} /* TODO: else complain */", "+\t\t}", "+\t\tif (this.body instanceof Expression) {", "+\t\t\tExpression expression = (Expression) this.body;", "+\t\t\tif (singleAbstractMethod != null) {", "+\t\t\t\texpression.setExpectedType(singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "+\t\t\t\t/* TypeBinding expressionType = */ expression.resolveType(this.scope);", "+\t\t\t\t// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tthis.body.resolve(this.scope);", "+\t\t}", "+\t\treturn expected;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d1e3d42d4ed81f6271d6535361cdc0d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "af7c555b94268663ad75bc44adea174c67a820bf", "commitAfterChange": "5f14954289dcfe3aa64cd723a9ea9807dea33e05", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \t\t \tpublic MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " \t\t \tpublic MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\tretrieveRightBraceOrSemiColonPosition(methodDecl);", "-\t\t", "-\t\torg.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;", "-\t\t", "-\t\tif (statements != null || explicitConstructorCall != null) {", "-\t\t\tBlock block = this.ast.newBlock();", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);", "-\t\t\tblock.setSourceRange(start, end - start + 1);", "-\t\t\tif (explicitConstructorCall != null && explicitConstructorCall.accessMode != ExplicitConstructorCall.ImplicitSuper) {", "-\t\t\t\tblock.statements().add(convert(explicitConstructorCall));", "-\t\t\t}", "-\t\t\tint statementsLength = statements == null ? 0 : statements.length;", "-\t\t\tfor (int i = 0; i < statementsLength; i++) {", "-\t\t\t\tif (statements[i] instanceof LocalDeclaration) {", "-\t\t\t\t\tcheckAndAddMultipleLocalDeclaration(statements, i, block.statements());", "-\t\t\t\t} else {", "-\t\t\t\t\tblock.statements().add(convert(statements[i]));", "+\t\tint closingPosition = retrieveRightBraceOrSemiColonPosition(methodDecl, methodDeclaration);", "+\t\tif (closingPosition != -1) {", "+\t\t\tint startPosition = methodDecl.getStartPosition();", "+\t\t\tmethodDecl.setSourceRange(startPosition, closingPosition - startPosition);", "+", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;", "+\t\t\t", "+\t\t\tif (statements != null || explicitConstructorCall != null) {", "+\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\tif (explicitConstructorCall != null && explicitConstructorCall.accessMode != ExplicitConstructorCall.ImplicitSuper) {", "+\t\t\t\t\tblock.statements().add(convert(explicitConstructorCall));", "+\t\t\t\t}", "+\t\t\t\tint statementsLength = statements == null ? 0 : statements.length;", "+\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "+\t\t\t\t\tif (statements[i] instanceof LocalDeclaration) {", "+\t\t\t\t\t\tcheckAndAddMultipleLocalDeclaration(statements, i, block.statements());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tblock.statements().add(convert(statements[i]));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tmethodDecl.setBody(block);", "+\t\t\t} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\t\tif (start != -1 && end != -1) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "+\t\t\t\t\t */", "+\t\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\t\tmethodDecl.setBody(block);", "-\t\t\tmethodDecl.setBody(block);", "-\t\t} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);", "-\t\t\tif (start != -1 && end != -1) {", "-\t\t\t\t/*", "-\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "-\t\t\t\t */", "-\t\t\t\tBlock block = this.ast.newBlock();", "-\t\t\t\tblock.setSourceRange(start, end - start + 1);", "-\t\t\t\tmethodDecl.setBody(block);", "-\t\t\t}", "+\t\t} else {", "+\t\t\t// syntax error in this method declaration", "+\t\t\tif (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {", "+\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tend = methodDeclaration.bodyEnd;", "+\t\t\t\t// try to get the best end position", "+\t\t\t\tIProblem[] problems = methodDeclaration.compilationResult().problems;", "+\t\t\t\tif (problems != null) {", "+\t\t\t\t\tfor (int i = 0, max = problems.length; i < max; i++) {", "+\t\t\t\t\t\tIProblem currentProblem = problems[i];", "+\t\t\t\t\t\tif (currentProblem.getSourceStart() == start && currentProblem.getID() == IProblem.ParsingErrorInsertToComplete) {", "+\t\t\t\t\t\t\tend = currentProblem.getSourceEnd();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tint startPosition = methodDecl.getStartPosition();", "+\t\t\t\tmethodDecl.setSourceRange(startPosition, end - startPosition + 1);", "+\t\t\t\tif (start != -1 && end != -1) {", "+\t\t\t\t\t/*", "+\t\t\t\t\t * start or end can be equal to -1 if we have an interface's method.", "+\t\t\t\t\t */", "+\t\t\t\t\tBlock block = this.ast.newBlock();", "+\t\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\t\tmethodDecl.setBody(block);", "+\t\t\t\t}", "+\t\t\t}\t\t\t", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc6e819bb0512cc527b73432ef83e2c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "91a5b49121a22c32ff81484145fe6ce15b755e81", "commitAfterChange": "16b9910572e7876db169469e4f3c509a31490ed4", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult)", "signatureAfterChange": " \tprivate TypeDeclaration convert(ISourceType sourceType, CompilationResult compilationResult)", "diff": ["-\t\tif (sourceType.getEnclosingType() != null) {", "+\t\tif (sourceType.getEnclosingType() == null && sourceType instanceof SourceTypeElementInfo) {", "+\t\t\tIType typeHandle = ((SourceTypeElementInfo)sourceType).getHandle();", "+\t\t\ttry {", "+\t\t\t\tif (typeHandle.isAnonymous()) {", "+\t\t\t\t\ttype.name = TypeDeclaration.ANONYMOUS_EMPTY_NAME;", "+\t\t\t\t\ttype.bits |= ASTNode.AnonymousAndLocalMask;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (typeHandle.isLocal()) {", "+\t\t\t\t\t\ttype.bits |= ASTNode.IsLocalTypeMASK;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// could not figure, assume toplevel", "+\t\t\t}", "+\t\t}  else {", "+\t\t}", "+\t\tif ((type.bits & ASTNode.IsAnonymousTypeMASK) == 0) {", "+\t\t\ttype.name = sourceType.getName();", "-\t\t/* convert fields */", "+\t\t/* convert intializers and fields*/", "+\t\tInitializerElementInfo[] initializers = null;", "+\t\tint initializerCount = 0;", "+\t\tif ((this.flags & LOCAL_TYPE) != 0 && sourceType instanceof SourceTypeElementInfo) {", "+\t\t\tinitializers = ((SourceTypeElementInfo)sourceType).getInitializers();", "+\t\t\tinitializerCount = initializers.length;", "+\t\t}", "+\t\tISourceField[] sourceFields = null;", "+\t\tint sourceFieldCount = 0;", "-\t\t\tISourceField[] sourceFields = sourceType.getFields();", "-\t\t\tint sourceFieldCount = sourceFields == null ? 0 : sourceFields.length;", "-\t\t\ttype.fields = new FieldDeclaration[sourceFieldCount];", "-\t\t\tfor (int i = 0; i < sourceFieldCount; i++) {", "-\t\t\t\ttype.fields[i] = convert(sourceFields[i], type);", "+\t\t\tsourceFields = sourceType.getFields();", "+\t\t\tsourceFieldCount = sourceFields == null ? 0 : sourceFields.length;", "+\t\t}", "+\t\tint length = initializerCount + sourceFieldCount;", "+\t\tif (length > 0) {", "+\t\t\ttype.fields = new FieldDeclaration[length];", "+\t\t\tfor (int i = 0; i < initializerCount; i++) {", "+\t\t\t\ttype.fields[i] = convert(initializers[i], compilationResult);", "+\t\t\t}", "+\t\t\tint index = 0;", "+\t\t\tfor (int i = initializerCount; i < length; i++) {", "+\t\t\t\ttype.fields[i] = convert(sourceFields[index++], type, compilationResult);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db7e76f6c9f1f1378324c7c06b14934d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "15354ef30ff1d65c0145e0a7585cb94774313c51", "commitAfterChange": "f49cf7529ae8b80cdf3f120143dad37a4f24e498", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public AnnotationBinding[] getParameterAnnotations(int index)", "signatureAfterChange": " public AnnotationBinding[] getParameterAnnotations(int index)", "diff": ["-\treturn holder == null ? Binding.NO_ANNOTATIONS : holder.getParameterAnnotations(index);", "+\tAnnotationBinding[][] allParameterAnnotations = holder == null ? null : holder.getParameterAnnotations();", "+\tif (allParameterAnnotations == null && (this.tagBits & TagBits.HasParameterAnnotations) != 0) {", "+\t\t// forward reference to method, where param annotations have not yet been associated to method", "+\t\tif (this.declaringClass instanceof SourceTypeBinding) {", "+\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) this.declaringClass;", "+\t\t\tif (sourceType.scope != null) {", "+\t\t\t\tAbstractMethodDeclaration methodDecl = sourceType.scope.referenceType().declarationOf(this);", "+\t\t\t\tif (methodDecl.arguments != null) {", "+\t\t\t\t\tfor (int i = 0, length = methodDecl.arguments.length; i < length; i++) {", "+\t\t\t\t\t\tArgument argument = methodDecl.arguments[i];", "+\t\t\t\t\t\tif (argument.annotations != null) {", "+\t\t\t\t\t\t\tASTNode.resolveAnnotations(methodDecl.scope, argument.annotations, argument.binding);", "+\t\t\t\t\t\t\tif (allParameterAnnotations == null) {", "+\t\t\t\t\t\t\t\tallParameterAnnotations = new AnnotationBinding[length][];", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tallParameterAnnotations[i] = argument.binding.getAnnotations();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (allParameterAnnotations != null)", "+\t\t\t\t\t\tthis.setParameterAnnotations(allParameterAnnotations);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\tAnnotationBinding[] resultParameterAnnotations = allParameterAnnotations == null ? null : allParameterAnnotations[\tindex];", "+\t if (resultParameterAnnotations != null) {", "+\t\t return resultParameterAnnotations;", "+\t }", "+\treturn Binding.NO_ANNOTATIONS;"]}], "num": 42487}