{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a41fadb82715fab6784f6d789926ba88", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fadc9d2be6657f0803853c003661367", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "aaea056b63df0d51dde45ba7280dde54d23c0cca", "commitAfterChange": "c472000c78a59beb7304d9a44e86450b859aeee1", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["+\t\t\t\t\t\t&& sourceType.findSuperTypeErasingTo(TypeIds.T_JavaIoExternalizable, false /*Serializable is not a class*/) == null", "-\t\t", "+", "+\t\tif (needSerialVersion) {", "+\t\t\t// if Object writeReplace() throws java.io.ObjectStreamException is present, then no serialVersionUID is needed", "+\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=101476", "+    \t\tCompilationUnitScope compilationUnitScope = this.scope.compilationUnitScope();", "+\t\t\tMethodBinding methodBinding = sourceType.getExactMethod(TypeConstants.WRITEREPLACE, new TypeBinding[0], compilationUnitScope);", "+   \t\t\tReferenceBinding[] throwsExceptions;", "+\t\t\tneedSerialVersion = ", "+\t\t\t\tmethodBinding == null", "+    \t\t\t\t|| !methodBinding.isValidBinding()", "+    \t\t\t\t|| methodBinding.returnType.id != TypeIds.T_JavaLangObject", "+    \t\t\t\t|| (throwsExceptions = methodBinding.thrownExceptions).length != 1", "+    \t\t\t\t|| throwsExceptions[0].id != TypeIds.T_JavaIoObjectStreamException;", "+    \t\tif (needSerialVersion) {", "+    \t\t\t// check the presence of an implementation of the methods", "+    \t\t\t// private void writeObject(java.io.ObjectOutputStream out) throws IOException", "+    \t\t\t// private void readObject(java.io.ObjectInputStream out) throws IOException", "+    \t\t\tboolean hasWriteObjectMethod = false;", "+    \t\t\tboolean hasReadObjectMethod = false;", "+    \t\t\tTypeBinding argumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTOUTPUTSTREAM, 3);", "+     \t\t\tif (argumentTypeBinding.isValidBinding()) {", "+            \t\tmethodBinding = sourceType.getExactMethod(TypeConstants.WRITEOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "+            \t\thasWriteObjectMethod = methodBinding != null", "+            \t\t\t\t&& methodBinding.isValidBinding()", "+            \t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "+            \t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "+            \t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "+            \t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "+    \t\t\t}", "+    \t\t\targumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTINPUTSTREAM, 3);", "+     \t\t\tif (argumentTypeBinding.isValidBinding()) {", "+            \t\tmethodBinding = sourceType.getExactMethod(TypeConstants.READOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "+            \t\thasReadObjectMethod = methodBinding != null", "+            \t\t\t\t&& methodBinding.isValidBinding()", "+            \t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "+            \t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "+            \t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "+            \t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "+    \t\t\t}", "+    \t\t\tneedSerialVersion = !hasWriteObjectMethod || !hasReadObjectMethod;", "+    \t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f1e62959be8628aa9f53faf085f182c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "34420b68eb797510644f3cf500d173864737a241", "commitAfterChange": "879ea9ced188291ab9fadfbc62fcd44bb0ea6163", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["-\t\t\t\t\t\t&& sourceType.isClass() ", "-\t\t\t\t\t\t&& !sourceType.isAbstract() ", "+\t\t\t\t\t\t&& sourceType.isClass()", "-    \t\tCompilationUnitScope compilationUnitScope = this.scope.compilationUnitScope();", "+\t\t\tCompilationUnitScope compilationUnitScope = this.scope.compilationUnitScope();", "-   \t\t\tReferenceBinding[] throwsExceptions;", "+\t\t\tReferenceBinding[] throwsExceptions;", "-    \t\t\t\t|| !methodBinding.isValidBinding()", "-    \t\t\t\t|| methodBinding.returnType.id != TypeIds.T_JavaLangObject", "-    \t\t\t\t|| (throwsExceptions = methodBinding.thrownExceptions).length != 1", "-    \t\t\t\t|| throwsExceptions[0].id != TypeIds.T_JavaIoObjectStreamException;", "-    \t\tif (needSerialVersion) {", "-    \t\t\t// check the presence of an implementation of the methods", "-    \t\t\t// private void writeObject(java.io.ObjectOutputStream out) throws IOException", "-    \t\t\t// private void readObject(java.io.ObjectInputStream out) throws IOException", "-    \t\t\tboolean hasWriteObjectMethod = false;", "-    \t\t\tboolean hasReadObjectMethod = false;", "-    \t\t\tTypeBinding argumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTOUTPUTSTREAM, 3);", "-     \t\t\tif (argumentTypeBinding.isValidBinding()) {", "-            \t\tmethodBinding = sourceType.getExactMethod(TypeConstants.WRITEOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "-            \t\thasWriteObjectMethod = methodBinding != null", "-            \t\t\t\t&& methodBinding.isValidBinding()", "-            \t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "-            \t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "-            \t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "-            \t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "-    \t\t\t}", "-    \t\t\targumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTINPUTSTREAM, 3);", "-     \t\t\tif (argumentTypeBinding.isValidBinding()) {", "-            \t\tmethodBinding = sourceType.getExactMethod(TypeConstants.READOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "-            \t\thasReadObjectMethod = methodBinding != null", "-            \t\t\t\t&& methodBinding.isValidBinding()", "-            \t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "-            \t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "-            \t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "-            \t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "-    \t\t\t}", "-    \t\t\tneedSerialVersion = !hasWriteObjectMethod || !hasReadObjectMethod;", "-    \t\t}", "+\t\t\t\t\t|| !methodBinding.isValidBinding()", "+\t\t\t\t\t|| methodBinding.returnType.id != TypeIds.T_JavaLangObject", "+\t\t\t\t\t|| (throwsExceptions = methodBinding.thrownExceptions).length != 1", "+\t\t\t\t\t|| throwsExceptions[0].id != TypeIds.T_JavaIoObjectStreamException;", "+\t\t\tif (needSerialVersion) {", "+\t\t\t\t// check the presence of an implementation of the methods", "+\t\t\t\t// private void writeObject(java.io.ObjectOutputStream out) throws IOException", "+\t\t\t\t// private void readObject(java.io.ObjectInputStream out) throws IOException", "+\t\t\t\tboolean hasWriteObjectMethod = false;", "+\t\t\t\tboolean hasReadObjectMethod = false;", "+\t\t\t\tTypeBinding argumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTOUTPUTSTREAM, 3);", "+\t\t\t\tif (argumentTypeBinding.isValidBinding()) {", "+\t\t\t\t\tmethodBinding = sourceType.getExactMethod(TypeConstants.WRITEOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "+\t\t\t\t\thasWriteObjectMethod = methodBinding != null", "+\t\t\t\t\t\t\t&& methodBinding.isValidBinding()", "+\t\t\t\t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "+\t\t\t\t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "+\t\t\t\t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "+\t\t\t\t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "+\t\t\t\t}", "+\t\t\t\targumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTINPUTSTREAM, 3);", "+\t\t\t\tif (argumentTypeBinding.isValidBinding()) {", "+\t\t\t\t\tmethodBinding = sourceType.getExactMethod(TypeConstants.READOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);", "+\t\t\t\t\thasReadObjectMethod = methodBinding != null", "+\t\t\t\t\t\t\t&& methodBinding.isValidBinding()", "+\t\t\t\t\t\t\t&& methodBinding.modifiers == ClassFileConstants.AccPrivate", "+\t\t\t\t\t\t\t&& methodBinding.returnType == TypeBinding.VOID", "+\t\t\t\t\t\t\t&& (throwsExceptions = methodBinding.thrownExceptions).length == 1", "+\t\t\t\t\t\t\t&& throwsExceptions[0].id == TypeIds.T_JavaIoException;", "+\t\t\t\t}", "+\t\t\t\tneedSerialVersion = !hasWriteObjectMethod || !hasReadObjectMethod;", "+\t\t\t}", "-\t\t\t\t\tbreak checkEnclosedInGeneric;\t\t\t\t\t\t", "+\t\t\t\t\tbreak checkEnclosedInGeneric;", "-\t\t\t\t}\t\t\t\t", "+\t\t\t\t}"]}], "num": 22758}