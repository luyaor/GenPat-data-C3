{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1d7f0027b05d75136a3422c1354b60d9", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "20c999035481597a1c4366ec478ccd15", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java", "commitBeforeChange": "928aa699a216cf69978cb24af1fa6f7f4cba1f20", "commitAfterChange": "9221731a3d20320a45d9e6a6337379d8a431c366", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \t@Override \tpublic SourceVersion getSourceVersion()", "signatureAfterChange": "  \t@Override \tpublic SourceVersion getSourceVersion()", "diff": ["-\t\t// As of this writing, RELEASE_6 is the highest level available.", "-\t\t// It is also the lowest level for which this code can possibly", "-\t\t// be called.  When Java 7 is released, this method will need to", "-\t\t// return a value based on _compiler.options.sourceLevel.", "-\t\treturn SourceVersion.RELEASE_6;", "+\t\tif (this._compiler.options.sourceLevel <= ClassFileConstants.JDK1_5) {", "+\t\t\treturn SourceVersion.RELEASE_5;", "+\t\t}", "+\t\tif (this._compiler.options.sourceLevel == ClassFileConstants.JDK1_6) {", "+\t\t\treturn SourceVersion.RELEASE_6;", "+\t\t}", "+\t\ttry {", "+\t\t\treturn SourceVersion.valueOf(\"RELEASE_7\"); //$NON-NLS-1$", "+\t\t} catch(IllegalArgumentException e) {", "+\t\t\t// handle call on a JDK 6", "+\t\t\treturn SourceVersion.RELEASE_6;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2926f6405bd524db0a2513ca9e0f3eac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "7df061f9da0ab96be87e5851cb157a28c5f5bca0", "commitAfterChange": "5138a70372af4817aefdd3da44dfadf7f7557bf3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " boolean areReturnTypesCompatible0(MethodBinding one, MethodBinding two)", "signatureAfterChange": " static boolean areReturnTypesCompatible(MethodBinding one, MethodBinding two, LookupEnvironment environment)", "diff": ["-boolean areReturnTypesCompatible0(MethodBinding one, MethodBinding two) {", "-\t// short is compatible with int, but as far as covariance is concerned, its not", "-\tif (one.returnType.isBaseType()) return false;", "+static boolean areReturnTypesCompatible(MethodBinding one, MethodBinding two, LookupEnvironment environment) {", "+\tif (one.returnType == two.returnType) return true;", "+\tif (environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t// short is compatible with int, but as far as covariance is concerned, its not", "+\t\tif (one.returnType.isBaseType()) return false;", "-\tif (!one.declaringClass.isInterface() && one.declaringClass.id == TypeIds.T_JavaLangObject)", "-\t\treturn two.returnType.isCompatibleWith(one.returnType); // interface methods inherit from Object", "+\t\tif (!one.declaringClass.isInterface() && one.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\treturn two.returnType.isCompatibleWith(one.returnType); // interface methods inherit from Object", "-\treturn one.returnType.isCompatibleWith(two.returnType);", "+\t\treturn one.returnType.isCompatibleWith(two.returnType);", "+\t} else {", "+\t\treturn areTypesEqual(one.returnType.erasure(), two.returnType.erasure());", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a64aaf4cc964c0c519036fcf14e8440", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "3fa437321fe88b141d60a98c3b39cea46c7fbc44", "commitAfterChange": "ac6a9f56760bba7aec9ca8548c00a789a95fdc11", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r \tpublic Object getLastBuiltState2(IProject project, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic Object getLastBuiltState2(IProject project, IProgressMonitor monitor)", "diff": ["-//\t\tif (state == null && JavaBuilder.SAVE_ENABLED && !info.triedRead) {\r", "-//\t\t\tinfo.triedRead= true;\r", "-//\t\t\ttry {\r", "-//\t\t\t\tif (monitor != null) monitor.subTask(Util.bind(\"build.readStateProgress\"/*nonNLS*/, project.getName()));\r", "-//\t\t\t\tstate= readState(info);\r", "-//\t\t\t\tinfo.setLastBuiltState(state);\r", "-//\t\t\t} catch (CoreException e) {\r", "-//\t\t\t\te.printStackTrace();\r", "-//\t\t\t}\r", "-//\t\t}\r", "+\t\tif (state == null && !info.triedRead) {\r", "+\t\t\tinfo.triedRead= true;\r", "+\t\t\ttry {\r", "+\t\t\t\tif (monitor != null)\r", "+\t\t\t\t\tmonitor.subTask(Util.bind(\"build.readStateProgress\"/*nonNLS*/, project.getName()));\r", "+\t\t\t\tstate = readState2(project);\r", "+\t\t\t} catch (CoreException e) {\r", "+\t\t\t\te.printStackTrace();\r", "+\t\t\t}\r", "+\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c70306089faec28b5f5e2e6789b75eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "325f3cd70524915aea7c5208cccbff17dcccc775", "commitAfterChange": "eaaeea046b340f91bd2146e38b8d80abded44679", "methodNumberBeforeChange": 89, "methodNumberAfterChange": 89, "signatureBeforeChange": " \tprivate IClasspathContainer initializeAllContainers(IJavaProject javaProjectToInit, IPath containerToInit) throws JavaModelException", "signatureAfterChange": " \tprivate IClasspathContainer initializeAllContainers(IJavaProject javaProjectToInit, IPath containerToInit) throws JavaModelException", "diff": ["-\t\t\t\t\t\tSet entrySet = allContainerPaths.entrySet();", "-\t\t\t\t\t\tint length = entrySet.size();", "-\t\t\t\t\t\tMap.Entry[] entries = new Map.Entry[length]; // clone as the following will have a side effect", "-\t\t\t\t\t\tentrySet.toArray(entries);", "-\t\t\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\t\t\tMap.Entry entry = entries[i];", "-\t\t\t\t\t\t\tIJavaProject javaProject = (IJavaProject) entry.getKey();", "-\t\t\t\t\t\t\tHashSet pathSet = (HashSet) entry.getValue();", "-\t\t\t\t\t\t\tif (pathSet == null) continue;", "-\t\t\t\t\t\t\tint length2 = pathSet.size();", "-\t\t\t\t\t\t\tIPath[] paths = new IPath[length2];", "-\t\t\t\t\t\t\tpathSet.toArray(paths); // clone as the following will have a side effect", "-\t\t\t\t\t\t\tfor (int j = 0; j < length2; j++) {", "-\t\t\t\t\t\t\t\tIPath path = paths[j];", "-\t\t\t\t\t\t\t\tinitializeContainer(javaProject, path);", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tSet entrySet = allContainerPaths.entrySet();", "+\t\t\t\t\t\t\tint length = entrySet.size();", "+\t\t\t\t\t\t\tif (monitor != null)", "+\t\t\t\t\t\t\t\tmonitor.beginTask(\"\", length); //$NON-NLS-1$", "+\t\t\t\t\t\t\tMap.Entry[] entries = new Map.Entry[length]; // clone as the following will have a side effect", "+\t\t\t\t\t\t\tentrySet.toArray(entries);", "+\t\t\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\t\tMap.Entry entry = entries[i];", "+\t\t\t\t\t\t\t\tIJavaProject javaProject = (IJavaProject) entry.getKey();", "+\t\t\t\t\t\t\t\tHashSet pathSet = (HashSet) entry.getValue();", "+\t\t\t\t\t\t\t\tif (pathSet == null) continue;", "+\t\t\t\t\t\t\t\tint length2 = pathSet.size();", "+\t\t\t\t\t\t\t\tIPath[] paths = new IPath[length2];", "+\t\t\t\t\t\t\t\tpathSet.toArray(paths); // clone as the following will have a side effect", "+\t\t\t\t\t\t\t\tfor (int j = 0; j < length2; j++) {", "+\t\t\t\t\t\t\t\t\tIPath path = paths[j];", "+\t\t\t\t\t\t\t\t\tinitializeContainer(javaProject, path);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (monitor != null)", "+\t\t\t\t\t\t\t\t\tmonitor.worked(1);", "+\t\t\t\t\t\t} finally {", "+\t\t\t\t\t\t\tif (monitor != null)", "+\t\t\t\t\t\t\t\tmonitor.done();", "+\t\t\tIProgressMonitor monitor = (IProgressMonitor) this.batchContainerInitializationsProgress.get();", "-\t\t\t\trunnable.run(null/*no progress available*/);", "+\t\t\t\trunnable.run(monitor);", "-\t\t\t\t\tnull/*no progress available here*/);", "+\t\t\t\t\tmonitor);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "454c78951792d31975272e5aade87bad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java", "commitBeforeChange": "17d4fac2e2145f81ae8773e6bd604f552ec24c76", "commitAfterChange": "8f4037084194a0a8c6b51e4ac889744e5d6e68a8", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 92, "signatureBeforeChange": " private VerificationTypeInfo getLocal(int resolvedPosition, StackMapFrame frame)", "signatureAfterChange": " private VerificationTypeInfo getLocal(int resolvedPosition, StackMapFrame frame)", "diff": ["-\treturn frame.locals[resolvedPosition];", "+\tfinal VerificationTypeInfo verificationTypeInfo = frame.locals[resolvedPosition];", "+\tif (verificationTypeInfo == null) {", "+\t\treturn null;", "+\t}", "+\ttry {", "+\t\tif (verificationTypeInfo.tag == VerificationTypeInfo.ITEM_UNINITIALIZED_THIS", "+\t\t\t\t|| verificationTypeInfo.tag == VerificationTypeInfo.ITEM_UNINITIALIZED) {", "+\t\t\treturn verificationTypeInfo;", "+\t\t}", "+\t\treturn (VerificationTypeInfo) verificationTypeInfo.clone();", "+\t} catch (CloneNotSupportedException e) {", "+\t\treturn verificationTypeInfo;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc1f50d98df4bbb95710d1b25c4bc43c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "325f3cd70524915aea7c5208cccbff17dcccc775", "commitAfterChange": "eaaeea046b340f91bd2146e38b8d80abded44679", "methodNumberBeforeChange": 91, "methodNumberAfterChange": 91, "signatureBeforeChange": "  \tIClasspathContainer initializeContainer(IJavaProject project, IPath containerPath) throws JavaModelException", "signatureAfterChange": "  \tIClasspathContainer initializeContainer(IJavaProject project, IPath containerPath) throws JavaModelException", "diff": ["+\t\t\t\tIProgressMonitor monitor = (IProgressMonitor) this.batchContainerInitializationsProgress.get();", "+\t\t\t\tif (monitor != null)", "+\t\t\t\t\tmonitor.subTask(Messages.bind(Messages.javamodel_configuring, initializer.getDescription(containerPath, project)));", "+\t\t\t\t", "+\t\t\t\tif (monitor != null)", "+\t\t\t\t\tmonitor.subTask(\"\"); //$NON-NLS-1$", "+\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da8983681d33a8484956d9852d0f3e3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "167e0a563c0934d033fb860086f34607180326b0", "commitAfterChange": "27ab9447fb0786cab5fb449fe90ffd060e3fc9d0", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["-\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)  ", "+\t\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "+\t\t\t\tif (typeVariable.firstBound == null)", "+\t\t\t\t\tcontinue; // both are null", "+\t\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "+\t\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "+\t\t\t\t\treturn inheritedMethod; // not a match", "+\t\t\t}", "+\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)"]}], "num": 56055}