{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "62a2b7a99e6d94d9a9287bffc5184e46", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03ea310e5b319818f9dbea68a35052b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["+\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "+\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\tcontinue nextMethod;", "+\t\t}", "+", "-\t\tif (!areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "+\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "+\t\t\t&& isSameOrSubTypeOf(currentMethod.returnType, inheritedMethod.returnType);", "+\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t} else if (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t} else {", "-\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\t\tif (inheritedMethod.isFinal())", "-\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\tcontinue nextMethod;", "+\t\t}", "-\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t\t}", "+\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "+\t\t    MethodBinding original = inheritedMethod.original();", "+\t\t    if (!areReturnTypeErasuresEqual(original, currentMethod) || !areParameterErasuresEqual(original, currentMethod))", "+\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "+\t\t}", "+", "+\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\tif (inheritedMethod.isFinal())", "+\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "+\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "641715c8512a99dac96326b8b56bd37e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "36cfe82a075699d2a0eb4fa6f987724ecb548c8c", "commitAfterChange": "37d61d5c5c650829214bf858cd078e7d345a9a26", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["-private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "+void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "-\t\t\t&& isTypeSubstituable(currentMethod.returnType, inheritedMethod.returnType);", "-\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedMethod.typeVariables.length != currentMethod.typeVariables.length) {", "-\t\t\t\t// TODO (kent) work to do on this case", "-\t\t\t\tif (currentMethod.typeVariables.length == 0 && inheritedMethod.declaringClass.isRawType()) {", "-\t\t\t\t\t// bug 69626", "-\t\t\t\t\t// no error since the inheritedMethod's type variables are ignored in raw types... why does a raw type binding not remove the type variables?", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-//\t\t\t\t\tthis.problemReporter(currentMethod).nameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "+\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "+\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "+\t\t} else {", "+\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\t\tif (inheritedMethod.isFinal())", "+\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "+\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!isReturnTypeSubstituable(original, currentMethod) || !areParameterErasuresEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);"]}], "num": 56867}