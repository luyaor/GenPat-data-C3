{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dfd790fc54abf3533e6f04ce5a5a8fad", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2efdf06267cbbf4e821a9b0c2cb70b5a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public MethodBinding findMethod( \tReferenceBinding receiverType, \tchar[] selector, \tTypeBinding[] argumentTypes, \tInvocationSite invocationSite)", "signatureAfterChange": " public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-public MethodBinding findMethod(", "-\tReferenceBinding receiverType,", "-\tchar[] selector,", "-\tTypeBinding[] argumentTypes,", "-\tInvocationSite invocationSite) {", "-", "-\t\tReferenceBinding currentType = receiverType;", "-\t\tMethodBinding matchingMethod = null;", "-\t\tObjectVector found = new ObjectVector();", "-", "-\t\t//compilationUnitScope().recordTypeReference(receiverType);", "-\t\t//compilationUnitScope().recordTypeReferences(argumentTypes);", "-", "-\t\tif (currentType.isInterface()) {", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tint currentLength = currentMethods.length;", "-\t\t\tif (currentLength == 1) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 1) {", "-\t\t\t\tfor (int f = 0; f < currentLength; f++)", "-\t\t\t\t\tfound.add(currentMethods[f]);", "-\t\t\t}", "-\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);", "-\t\t\tcurrentType = getJavaLangObject();", "-\t\t}", "-", "-\t\t// superclass lookup", "-\t\tReferenceBinding classHierarchyStart = currentType;", "-\t\t", "-\t\twhile (currentType != null) {", "-\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);", "-\t\t\tint currentLength = currentMethods.length;", "-\t\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 0) {", "-\t\t\t\tif (found.size == 0 && matchingMethod != null)", "-\t\t\t\t\tfound.add(matchingMethod);", "-\t\t\t\tfor (int f = 0; f < currentLength; f++)", "-\t\t\t\t\tfound.add(currentMethods[f]);", "-\t\t\t}", "-\t\t\tcurrentType = currentType.superclass();", "-\t\t}", "-", "-\t\tint foundSize = found.size;", "-\t\tif (foundSize == 0) {", "-\t\t\tif (matchingMethod == null){", "-\t\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\t}", "-\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility", "-\t\t}", "-\t\tMethodBinding[] candidates = new MethodBinding[foundSize];", "-\t\tint candidatesCount = 0;", "-", "-\t\t// argument type compatibility check", "-\t\tfor (int i = 0; i < foundSize; i++) {", "-\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);", "-\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\tif (compatibleMethod != null)", "-\t\t\t\tcandidates[candidatesCount++] = compatibleMethod;", "-\t\t}", "-\t\tif (candidatesCount == 1) {", "-\t\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0]; // have not checked visibility", "-\t\t}", "-\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters", "-\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-", "-\t\t\tint argLength = argumentTypes.length;", "-\t\t\tfoundSize = found.size;", "-\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {", "-\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);", "-\t\t\t\tTypeBinding[] params = methodBinding.parameters;", "-\t\t\t\tint paramLength = params.length;", "-\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {", "-\t\t\t\t\tTypeBinding arg = argumentTypes[a];", "-\t\t\t\t\tfor (int p = 0; p < paramLength; p++)", "-\t\t\t\t\t\tif (params[p] == arg)", "-\t\t\t\t\t\t\tcontinue nextArg;", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t}", "-\t\t\t\treturn methodBinding;", "-\t\t\t}", "-\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found", "-\t\t}", "-", "-\t\t// visibility check", "-\t\tint visiblesCount = 0;", "-\t\tfor (int i = 0; i < candidatesCount; i++) {", "-\t\t\tMethodBinding methodBinding = candidates[i];", "-\t\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {", "-\t\t\t\tif (visiblesCount != i) {", "-\t\t\t\t\tcandidates[i] = null;", "-\t\t\t\t\tcandidates[visiblesCount] = methodBinding;", "-\t\t\t\t}", "-\t\t\t\tvisiblesCount++;", "-\t\t\t}", "-\t\t}", "-\t\tif (visiblesCount == 1) {", "-\t\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);", "-\t\t\treturn candidates[0];", "-\t\t}", "-\t\tif (visiblesCount == 0) {", "-\t\t\tMethodBinding interfaceMethod = findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tcandidates[0].selector,", "-\t\t\t\tcandidates[0].parameters,", "-\t\t\t\tcandidates[0].declaringClass,", "-\t\t\t\tProblemReasons.NotVisible);", "-\t\t}\t", "-\t\tif (!candidates[0].declaringClass.isInterface()) {", "-\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount, invocationSite);", "-\t\t} else {", "-\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount, invocationSite);", "-\t\t}", "-\t}", "+public MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\tMethodBinding methodBinding = super.findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\tif (methodBinding != null && methodBinding.isValidBinding())", "+\t\tif (!canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this))", "+\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotVisible);", "+\treturn methodBinding;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0b7dee89bb05729335aff77f60d0968", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "cefc7f3f8677282aa49e610700500999ffcaffcb", "commitAfterChange": "89e8879d5dd978e5f2535f9d8b7bac080dd4f73b", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " protected void reportMatching(Annotation[] annotations, IJavaElement enclosingElement, IJavaElement[] otherElements, Binding elementBinding, MatchingNodeSet nodeSet, boolean matchedContainer, boolean enclosesElement) throws CoreException", "signatureAfterChange": "  protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet) throws CoreException", "diff": ["+", "+protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet) throws CoreException {", "+\tif (accuracy > -1) {", "+\t\tIJavaElement enclosingElement = createHandle(lambdaExpression, parent);", "+\t\tif (enclosingElement != null) { // skip if unable to find method", "+\t\t\t// compute source positions of the selector", "+\t\t\tint nameSourceStart = lambdaExpression.sourceStart;", "+\t\t\tif (encloses(enclosingElement)) {", "+\t\t\t\tSearchMatch match = null;", "+\t\t\t\tint length = lambdaExpression.getArrowPosition() + 1 - nameSourceStart;", "+\t\t\t\tmatch = this.patternLocator.newDeclarationMatch(lambdaExpression, enclosingElement, lambdaExpression.descriptor, accuracy, length, this);", "+\t\t\t\tif (match != null) {", "+\t\t\t\t\treport(match);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+}"]}], "num": 32007}