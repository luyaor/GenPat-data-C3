{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e2ff487bc37a6ac2e99e38636f27286", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7589f08e15e3322955d36ed1b0246848", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java", "commitBeforeChange": "0199702ff6cca8392f62e334c86875a1b31484e2", "commitAfterChange": "4d36cf912bda83cf994dbb030b9c8cbc9e169048", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": "  \tpublic void searchAllMethodNames( \t\t\tfinal char[] packageName, \t\t\tfinal int pkgMatchRule, \t\t\tfinal char[] declaringQualification, \t\t\tfinal int declQualificationMatchRule, \t\t\tfinal char[] declaringSimpleName, \t\t\tfinal int declSimpleNameMatchRule, \t\t\tfinal char[] methodName, \t\t\tfinal int methodMatchRule, \t\t\tIJavaSearchScope scope, \t\t\tfinal IRestrictedAccessMethodRequestor nameRequestor, \t\t\tint waitingPolicy, \t\t\tIProgressMonitor progressMonitor)  throws JavaModelException", "signatureAfterChange": "  \tpublic void searchAllMethodNames( \t\t\tfinal char[] packageName, \t\t\tfinal int pkgMatchRule, \t\t\tfinal char[] declaringQualification, \t\t\tfinal int declQualificationMatchRule, \t\t\tfinal char[] declaringSimpleName, \t\t\tfinal int declSimpleNameMatchRule, \t\t\tfinal char[] methodName, \t\t\tfinal int methodMatchRule, \t\t\tIJavaSearchScope scope, \t\t\tfinal IRestrictedAccessMethodRequestor nameRequestor, \t\t\tint waitingPolicy, \t\t\tIProgressMonitor progressMonitor)  throws JavaModelException", "diff": ["-\t\t\ttry {", "-\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\tprogressMonitor.beginTask(Messages.engine_searching, 1000);", "-\t\t\t\t}", "-\t\t\t\t// add type names from indexes", "-\t\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\t\tnew PatternSearchJob(", "-\t\t\t\t\t\tpattern,", "-\t\t\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "-\t\t\t\t\t\tscope,", "-\t\t\t\t\t\tsearchRequestor),", "-\t\t\t\t\twaitingPolicy,", "-\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));", "+\t\t\tSubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);", "+\t\t\t// add type names from indexes", "+\t\t\tindexManager.performConcurrentJob(", "+\t\t\t\tnew PatternSearchJob(", "+\t\t\t\t\tpattern,", "+\t\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "+\t\t\t\t\tscope,", "+\t\t\t\t\tsearchRequestor),", "+\t\t\t\twaitingPolicy,", "+\t\t\t\tsubMonitor.split(Math.max(1000-copiesLength, 0)));", "-\t\t\t\t// add type names from working copies", "-\t\t\t\tif (copies != null) {", "-\t\t\t\t\tboolean isPkgCaseSensitive = (pkgMatchRule & SearchPattern.R_CASE_SENSITIVE) != 0; ", "-\t\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "-\t\t\t\t\t\tfinal ICompilationUnit workingCopy = copies[i];", "-\t\t\t\t\t\tif (scope instanceof HierarchyScope) {", "-\t\t\t\t\t\t\tif (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "-\t\t\t\t\t\t}", "+\t\t\t// add type names from working copies", "+\t\t\tif (copies != null) {", "+\t\t\t\tboolean isPkgCaseSensitive = (pkgMatchRule & SearchPattern.R_CASE_SENSITIVE) != 0; ", "+\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "+\t\t\t\t\tSubMonitor iterationMonitor = subMonitor.split(1);", "+\t\t\t\t\tfinal ICompilationUnit workingCopy = copies[i];", "+\t\t\t\t\tif (scope instanceof HierarchyScope) {", "+\t\t\t\t\t\tif (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "+\t\t\t\t\t}", "-\t\t\t\t\t\tfinal String path = workingCopy.getPath().toString();", "-\t\t\t\t\t\tif (workingCopy.isConsistent()) {", "-\t\t\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "-\t\t\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "-\t\t\t\t\t\t\tif (packageName != null && !CharOperation.equals(packageName, packageDeclaration, isPkgCaseSensitive))", "+\t\t\t\t\tfinal String path = workingCopy.getPath().toString();", "+\t\t\t\t\tif (workingCopy.isConsistent()) {", "+\t\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "+\t\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "+\t\t\t\t\t\tif (packageName != null && !CharOperation.equals(packageName, packageDeclaration, isPkgCaseSensitive))", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "+\t\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "+\t\t\t\t\t\t\tIType type = allTypes[j];", "+\t\t\t\t\t\t\tIJavaElement parent = type.getParent();", "+\t\t\t\t\t\t\tchar[] rDeclaringQualification = parent instanceof IType ? ((IType) parent).getTypeQualifiedName('.').toCharArray() : CharOperation.NO_CHAR;", "+\t\t\t\t\t\t\tchar[] rSimpleName = type.getElementName().toCharArray();", "+\t\t\t\t\t\t\tif (!match(declaringQualification, declQualificationMatchRule, rDeclaringQualification) ||", "+\t\t\t\t\t\t\t\t\t!match(declaringSimpleName, declSimpleNameMatchRule, rSimpleName))", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "-\t\t\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "-\t\t\t\t\t\t\t\tIType type = allTypes[j];", "-\t\t\t\t\t\t\t\tIJavaElement parent = type.getParent();", "-\t\t\t\t\t\t\t\tchar[] rDeclaringQualification = parent instanceof IType ? ((IType) parent).getTypeQualifiedName('.').toCharArray() : CharOperation.NO_CHAR;", "-\t\t\t\t\t\t\t\tchar[] rSimpleName = type.getElementName().toCharArray();", "-\t\t\t\t\t\t\t\tif (!match(declaringQualification, declQualificationMatchRule, rDeclaringQualification) ||", "-\t\t\t\t\t\t\t\t\t\t!match(declaringSimpleName, declSimpleNameMatchRule, rSimpleName))", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\treportMatchingMethods(methodName, methodMatchRule, nameRequestor, path,", "-\t\t\t\t\t\t\t\t\t\tpackageDeclaration, type, rDeclaringQualification, rSimpleName); ", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tParser basicParser = getParser();", "-\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "-\t\t\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "-\t\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "-\t\t\t\t\t\t\tif (parsedUnit != null) {", "-\t\t\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "-\t\t\t\t\t\t\t\tclass AllMethodDeclarationVisitor extends ASTVisitor {", "+\t\t\t\t\t\t\treportMatchingMethods(methodName, methodMatchRule, nameRequestor, path,", "+\t\t\t\t\t\t\t\t\tpackageDeclaration, type, rDeclaringQualification, rSimpleName); ", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tParser basicParser = getParser();", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "+\t\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "+\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "+\t\t\t\t\t\tif (parsedUnit != null) {", "+\t\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "+\t\t\t\t\t\t\tclass AllMethodDeclarationVisitor extends ASTVisitor {", "-\t\t\t\t\t\t\t\t\tclass TypeInfo {", "-\t\t\t\t\t\t\t\t\t\tpublic TypeDeclaration typeDecl;", "-\t\t\t\t\t\t\t\t\t\tpublic IType type;", "-\t\t\t\t\t\t\t\t\t\tpublic boolean visitMethods;", "-\t\t\t\t\t\t\t\t\t\tpublic char[] enclosingTypeName;", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\tTypeInfo(TypeDeclaration typeDecl, boolean visitMethods, char[] enclosingTypeName) {", "-\t\t\t\t\t\t\t\t\t\t\tthis.typeDecl = typeDecl;", "-\t\t\t\t\t\t\t\t\t\t\tthis.type = workingCopy.getType(new String(typeDecl.name));", "-\t\t\t\t\t\t\t\t\t\t\tthis.visitMethods = visitMethods;", "-\t\t\t\t\t\t\t\t\t\t\tthis.enclosingTypeName = enclosingTypeName;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tStack<TypeInfo> typeInfoStack = new Stack<>();", "-\t\t\t\t\t\t\t\t\tIType getCurrentType() {", "-\t\t\t\t\t\t\t\t\t\tint l = this.typeInfoStack.size();", "-\t\t\t\t\t\t\t\t\t\tif (l <= 0) return null;", "-\t\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.get(0);", "-\t\t\t\t\t\t\t\t\t\tIType type = typeInfo.type;", "-\t\t\t\t\t\t\t\t\t\tif (type == null) {", "-\t\t\t\t\t\t\t\t\t\t\tTypeInfo ti = this.typeInfoStack.get(0);", "-\t\t\t\t\t\t\t\t\t\t\tti.type = ti.type == null ? workingCopy.getType(new String(ti.typeDecl.name)) : ti.type;", "-\t\t\t\t\t\t\t\t\t\t\ttype = ti.type;", "-\t\t\t\t\t\t\t\t\t\t\tfor (int j = 1; j < l && type != null; ++j) {", "-\t\t\t\t\t\t\t\t\t\t\t\tti = this.typeInfoStack.get(j);", "-\t\t\t\t\t\t\t\t\t\t\t\tif (ti.type == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tti.type = type.getType(new String(ti.typeDecl.name));", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\ttype = ti.type;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn type;", "-\t\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\t\tprivate void addStackEntry(TypeDeclaration typeDeclaration, char[] enclosingTypeName) {", "-\t\t\t\t\t\t\t\t\t\tboolean visitMethods = match(declaringQualification, declQualificationMatchRule, enclosingTypeName) &&", "-\t\t\t\t\t\t\t\t\t\t\t\tmatch(declaringSimpleName, declSimpleNameMatchRule, typeDeclaration.name);", "-\t\t\t\t\t\t\t\t\t\tthis.typeInfoStack.push(new TypeInfo(typeDeclaration, visitMethods, enclosingTypeName));", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "-\t\t\t\t\t\t\t\t\t\tthis.typeInfoStack.pop();", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "-\t\t\t\t\t\t\t\t\t\tthis.typeInfoStack.pop();", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {", "-\t\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.peek();", "-\t\t\t\t\t\t\t\t\t\tif (typeInfo.visitMethods &&", "-\t\t\t\t\t\t\t\t\t\t\tmatch(methodName, methodMatchRule, methodDeclaration.selector)) {", "-\t\t\t\t\t\t\t\t\t\t\treportMatchingMethod(path, packageDeclaration,", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttypeInfo.enclosingTypeName, ", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttypeInfo.typeDecl, ", "-\t\t\t\t\t\t\t\t\t\t\t\t\tmethodDeclaration,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tgetCurrentType(),", "-\t\t\t\t\t\t\t\t\t\t\t\t\tnameRequestor);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\treturn false; // no need to find methods from local/anonymous type", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "-\t\t\t\t\t\t\t\t\t\treturn false; // do not visit local/anonymous types", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "-\t\t\t\t\t\t\t\t\t\taddStackEntry(typeDeclaration, CharOperation.NO_CHAR);", "-\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "-\t\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.peek();", "-\t\t\t\t\t\t\t\t\t\taddStackEntry(memberTypeDeclaration, typeInfo.enclosingTypeName == CharOperation.NO_CHAR ? typeInfo.typeDecl.name :", "-\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.concat(typeInfo.enclosingTypeName, typeInfo.typeDecl.name, '.'));", "-\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\tclass TypeInfo {", "+\t\t\t\t\t\t\t\t\tpublic TypeDeclaration typeDecl;", "+\t\t\t\t\t\t\t\t\tpublic IType type;", "+\t\t\t\t\t\t\t\t\tpublic boolean visitMethods;", "+\t\t\t\t\t\t\t\t\tpublic char[] enclosingTypeName;", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tTypeInfo(TypeDeclaration typeDecl, boolean visitMethods, char[] enclosingTypeName) {", "+\t\t\t\t\t\t\t\t\t\tthis.typeDecl = typeDecl;", "+\t\t\t\t\t\t\t\t\t\tthis.type = workingCopy.getType(new String(typeDecl.name));", "+\t\t\t\t\t\t\t\t\t\tthis.visitMethods = visitMethods;", "+\t\t\t\t\t\t\t\t\t\tthis.enclosingTypeName = enclosingTypeName;", "-\t\t\t\t\t\t\t\tif (match(packageName, pkgMatchRule, packageDeclaration))", "-\t\t\t\t\t\t\t\t\tparsedUnit.traverse(new AllMethodDeclarationVisitor(), parsedUnit.scope);", "+\t\t\t\t\t\t\t\tStack<TypeInfo> typeInfoStack = new Stack<>();", "+\t\t\t\t\t\t\t\tIType getCurrentType() {", "+\t\t\t\t\t\t\t\t\tint l = this.typeInfoStack.size();", "+\t\t\t\t\t\t\t\t\tif (l <= 0) return null;", "+\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.get(0);", "+\t\t\t\t\t\t\t\t\tIType type = typeInfo.type;", "+\t\t\t\t\t\t\t\t\tif (type == null) {", "+\t\t\t\t\t\t\t\t\t\tTypeInfo ti = this.typeInfoStack.get(0);", "+\t\t\t\t\t\t\t\t\t\tti.type = ti.type == null ? workingCopy.getType(new String(ti.typeDecl.name)) : ti.type;", "+\t\t\t\t\t\t\t\t\t\ttype = ti.type;", "+\t\t\t\t\t\t\t\t\t\tfor (int j = 1; j < l && type != null; ++j) {", "+\t\t\t\t\t\t\t\t\t\t\tti = this.typeInfoStack.get(j);", "+\t\t\t\t\t\t\t\t\t\t\tif (ti.type == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\tti.type = type.getType(new String(ti.typeDecl.name));", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\ttype = ti.type;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn type;", "+\t\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t\t\tprivate void addStackEntry(TypeDeclaration typeDeclaration, char[] enclosingTypeName) {", "+\t\t\t\t\t\t\t\t\tboolean visitMethods = match(declaringQualification, declQualificationMatchRule, enclosingTypeName) &&", "+\t\t\t\t\t\t\t\t\t\t\tmatch(declaringSimpleName, declSimpleNameMatchRule, typeDeclaration.name);", "+\t\t\t\t\t\t\t\t\tthis.typeInfoStack.push(new TypeInfo(typeDeclaration, visitMethods, enclosingTypeName));", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "+\t\t\t\t\t\t\t\t\tthis.typeInfoStack.pop();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "+\t\t\t\t\t\t\t\t\tthis.typeInfoStack.pop();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {", "+\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.peek();", "+\t\t\t\t\t\t\t\t\tif (typeInfo.visitMethods &&", "+\t\t\t\t\t\t\t\t\t\tmatch(methodName, methodMatchRule, methodDeclaration.selector)) {", "+\t\t\t\t\t\t\t\t\t\treportMatchingMethod(path, packageDeclaration,", "+\t\t\t\t\t\t\t\t\t\t\t\ttypeInfo.enclosingTypeName, ", "+\t\t\t\t\t\t\t\t\t\t\t\ttypeInfo.typeDecl, ", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodDeclaration,", "+\t\t\t\t\t\t\t\t\t\t\t\tgetCurrentType(),", "+\t\t\t\t\t\t\t\t\t\t\t\tnameRequestor);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\treturn false; // no need to find methods from local/anonymous type", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "+\t\t\t\t\t\t\t\t\treturn false; // do not visit local/anonymous types", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "+\t\t\t\t\t\t\t\t\taddStackEntry(typeDeclaration, CharOperation.NO_CHAR);", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "+\t\t\t\t\t\t\t\t\tTypeInfo typeInfo = this.typeInfoStack.peek();", "+\t\t\t\t\t\t\t\t\taddStackEntry(memberTypeDeclaration, typeInfo.enclosingTypeName == CharOperation.NO_CHAR ? typeInfo.typeDecl.name :", "+\t\t\t\t\t\t\t\t\t\t\tCharOperation.concat(typeInfo.enclosingTypeName, typeInfo.typeDecl.name, '.'));", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\t\t\tif (progressMonitor.isCanceled()) throw new OperationCanceledException();", "-\t\t\t\t\t\t\tprogressMonitor.worked(1);", "+\t\t\t\t\t\t\tif (match(packageName, pkgMatchRule, packageDeclaration))", "+\t\t\t\t\t\t\t\tparsedUnit.traverse(new AllMethodDeclarationVisitor(), parsedUnit.scope);", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\tprogressMonitor.done();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93afc12147dbf51b752bf648a8dcc065", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java", "commitBeforeChange": "0199702ff6cca8392f62e334c86875a1b31484e2", "commitAfterChange": "4d36cf912bda83cf994dbb030b9c8cbc9e169048", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \t \tpublic void searchAllConstructorDeclarations( \t\tfinal char[] packageName, \t\tfinal char[] typeName, \t\tfinal int typeMatchRule, \t\tIJavaSearchScope scope, \t\tfinal IRestrictedAccessConstructorRequestor nameRequestor, \t\tint waitingPolicy, \t\tIProgressMonitor progressMonitor)  throws JavaModelException", "signatureAfterChange": " \t \tpublic void searchAllConstructorDeclarations( \t\tfinal char[] packageName, \t\tfinal char[] typeName, \t\tfinal int typeMatchRule, \t\tIJavaSearchScope scope, \t\tfinal IRestrictedAccessConstructorRequestor nameRequestor, \t\tint waitingPolicy, \t\tIProgressMonitor progressMonitor)  throws JavaModelException", "diff": ["-\t\ttry {", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.beginTask(Messages.engine_searching, 1000);", "-\t\t\t}", "-\t\t\t// add type names from indexes", "-\t\t\tindexManager.performConcurrentJob(", "-\t\t\t\tnew PatternSearchJob(", "-\t\t\t\t\tpattern,", "-\t\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "-\t\t\t\t\tscope,", "-\t\t\t\t\tsearchRequestor),", "-\t\t\t\twaitingPolicy,", "-\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));", "+\t\tSubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);", "+\t\t// add type names from indexes", "+\t\tindexManager.performConcurrentJob(", "+\t\t\tnew PatternSearchJob(", "+\t\t\t\tpattern,", "+\t\t\t\tgetDefaultSearchParticipant(), // Java search only", "+\t\t\t\tscope,", "+\t\t\t\tsearchRequestor),", "+\t\t\twaitingPolicy,", "+\t\t\tsubMonitor.split(Math.max(1000-copiesLength, 0)));", "-\t\t\t// add type names from working copies", "-\t\t\tif (copies != null) {", "-\t\t\t\tfor (int i = 0; i < copiesLength; i++) {", "-\t\t\t\t\tfinal ICompilationUnit workingCopy = copies[i];", "-\t\t\t\t\tif (scope instanceof HierarchyScope) {", "-\t\t\t\t\t\tif (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\tfinal String path = workingCopy.getPath().toString();", "-\t\t\t\t\tif (workingCopy.isConsistent()) {", "-\t\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "-\t\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "-\t\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "-\t\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "-\t\t\t\t\t\t\tIType type = allTypes[j];", "-\t\t\t\t\t\t\tchar[] simpleName = type.getElementName().toCharArray();", "-\t\t\t\t\t\t\tif (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tint extraFlags = ExtraFlags.getExtraFlags(type);", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tboolean hasConstructor = false;", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tIMethod[] methods = type.getMethods();", "-\t\t\t\t\t\t\t\tfor (int k = 0; k < methods.length; k++) {", "-\t\t\t\t\t\t\t\t\tIMethod method = methods[k];", "-\t\t\t\t\t\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\t\t\t\t\t\thasConstructor = true;", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\tString[] stringParameterNames = method.getParameterNames();", "-\t\t\t\t\t\t\t\t\t\tString[] stringParameterTypes = method.getParameterTypes();", "-\t\t\t\t\t\t\t\t\t\tint length = stringParameterNames.length;", "-\t\t\t\t\t\t\t\t\t\tchar[][] parameterNames = new char[length][];", "-\t\t\t\t\t\t\t\t\t\tchar[][] parameterTypes = new char[length][];", "-\t\t\t\t\t\t\t\t\t\tfor (int l = 0; l < length; l++) {", "-\t\t\t\t\t\t\t\t\t\t\tparameterNames[l] = stringParameterNames[l].toCharArray();", "-\t\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptConstructor(", "-\t\t\t\t\t\t\t\t\t\t\t\tmethod.getFlags(),", "-\t\t\t\t\t\t\t\t\t\t\t\tsimpleName,", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterNames.length,", "-\t\t\t\t\t\t\t\t\t\t\t\tnull,// signature is not used for source type", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterTypes, ", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterNames,", "-\t\t\t\t\t\t\t\t\t\t\t\ttype.getFlags(),", "-\t\t\t\t\t\t\t\t\t\t\t\tpackageDeclaration,", "-\t\t\t\t\t\t\t\t\t\t\t\textraFlags,", "-\t\t\t\t\t\t\t\t\t\t\t\tpath,", "-\t\t\t\t\t\t\t\t\t\t\t\tnull);", "+\t\t// add type names from working copies", "+\t\tif (copies != null) {", "+\t\t\tfor (int i = 0; i < copiesLength; i++) {", "+\t\t\t\tSubMonitor iterationMonitor = subMonitor.split(1);", "+\t\t\t\tfinal ICompilationUnit workingCopy = copies[i];", "+\t\t\t\tif (scope instanceof HierarchyScope) {", "+\t\t\t\t\tif (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (!scope.encloses(workingCopy)) continue;", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tfinal String path = workingCopy.getPath().toString();", "+\t\t\t\tif (workingCopy.isConsistent()) {", "+\t\t\t\t\tIPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();", "+\t\t\t\t\tchar[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();", "+\t\t\t\t\tIType[] allTypes = workingCopy.getAllTypes();", "+\t\t\t\t\tfor (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {", "+\t\t\t\t\t\tIType type = allTypes[j];", "+\t\t\t\t\t\tchar[] simpleName = type.getElementName().toCharArray();", "+\t\t\t\t\t\tif (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tint extraFlags = ExtraFlags.getExtraFlags(type);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tboolean hasConstructor = false;", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tIMethod[] methods = type.getMethods();", "+\t\t\t\t\t\t\tfor (int k = 0; k < methods.length; k++) {", "+\t\t\t\t\t\t\t\tIMethod method = methods[k];", "+\t\t\t\t\t\t\t\tif (method.isConstructor()) {", "+\t\t\t\t\t\t\t\t\thasConstructor = true;", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tString[] stringParameterNames = method.getParameterNames();", "+\t\t\t\t\t\t\t\t\tString[] stringParameterTypes = method.getParameterTypes();", "+\t\t\t\t\t\t\t\t\tint length = stringParameterNames.length;", "+\t\t\t\t\t\t\t\t\tchar[][] parameterNames = new char[length][];", "+\t\t\t\t\t\t\t\t\tchar[][] parameterTypes = new char[length][];", "+\t\t\t\t\t\t\t\t\tfor (int l = 0; l < length; l++) {", "+\t\t\t\t\t\t\t\t\t\tparameterNames[l] = stringParameterNames[l].toCharArray();", "+\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tif (!hasConstructor) {", "+\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\t\tFlags.AccPublic,", "+\t\t\t\t\t\t\t\t\t\t\tmethod.getFlags(),", "-\t\t\t\t\t\t\t\t\t\t\t-1,", "-\t\t\t\t\t\t\t\t\t\t\tnull, // signature is not used for source type", "-\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "-\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "+\t\t\t\t\t\t\t\t\t\t\tparameterNames.length,", "+\t\t\t\t\t\t\t\t\t\t\tnull,// signature is not used for source type", "+\t\t\t\t\t\t\t\t\t\t\tparameterTypes, ", "+\t\t\t\t\t\t\t\t\t\t\tparameterNames,", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif (!hasConstructor) {", "+\t\t\t\t\t\t\t\tnameRequestor.acceptConstructor(", "+\t\t\t\t\t\t\t\t\t\tFlags.AccPublic,", "+\t\t\t\t\t\t\t\t\t\tsimpleName,", "+\t\t\t\t\t\t\t\t\t\t-1,", "+\t\t\t\t\t\t\t\t\t\tnull, // signature is not used for source type", "+\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "+\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "+\t\t\t\t\t\t\t\t\t\ttype.getFlags(),", "+\t\t\t\t\t\t\t\t\t\tpackageDeclaration,", "+\t\t\t\t\t\t\t\t\t\textraFlags,", "+\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\tnull);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tParser basicParser = getParser();", "-\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "-\t\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "-\t\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "-\t\t\t\t\t\tif (parsedUnit != null) {", "-\t\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "-\t\t\t\t\t\t\tclass AllConstructorDeclarationsVisitor extends ASTVisitor {", "-\t\t\t\t\t\t\t\tprivate TypeDeclaration[] declaringTypes = new TypeDeclaration[0];", "-\t\t\t\t\t\t\t\tprivate int declaringTypesPtr = -1;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tParser basicParser = getParser();", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;", "+\t\t\t\t\tCompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);", "+\t\t\t\t\tCompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);", "+\t\t\t\t\tif (parsedUnit != null) {", "+\t\t\t\t\t\tfinal char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');", "+\t\t\t\t\t\tclass AllConstructorDeclarationsVisitor extends ASTVisitor {", "+\t\t\t\t\t\t\tprivate TypeDeclaration[] declaringTypes = new TypeDeclaration[0];", "+\t\t\t\t\t\t\tprivate int declaringTypesPtr = -1;", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tprivate void endVisit(TypeDeclaration typeDeclaration) {", "+\t\t\t\t\t\t\t\tif (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {", "-\t\t\t\t\t\t\t\tprivate void endVisit(TypeDeclaration typeDeclaration) {", "-\t\t\t\t\t\t\t\t\tif (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\tif (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {", "-\t\t\t\t\t\t\t\t\t\t\tnameRequestor.acceptConstructor(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tFlags.AccPublic,", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttypeName,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t-1,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tnull, // signature is not used for source type", "-\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttypeDeclaration.modifiers,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tpackageDeclaration,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tExtraFlags.getExtraFlags(typeDeclaration),", "-\t\t\t\t\t\t\t\t\t\t\t\t\tpath,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tnull);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\tthis.declaringTypes[this.declaringTypesPtr] = null;", "-\t\t\t\t\t\t\t\t\tthis.declaringTypesPtr--;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "-\t\t\t\t\t\t\t\t\tendVisit(typeDeclaration);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "-\t\t\t\t\t\t\t\t\tendVisit(memberTypeDeclaration);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tprivate boolean hasConstructor(TypeDeclaration typeDeclaration) {", "-\t\t\t\t\t\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "-\t\t\t\t\t\t\t\t\tint length = methods == null ? 0 : methods.length;", "-\t\t\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\t\t\t\t\tif (methods[j].isConstructor()) {", "-\t\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tpublic boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {", "-\t\t\t\t\t\t\t\t\tTypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];", "-\t\t\t\t\t\t\t\t\t\tArgument[] arguments = constructorDeclaration.arguments;", "-\t\t\t\t\t\t\t\t\t\tint length = arguments == null ? 0 : arguments.length;", "-\t\t\t\t\t\t\t\t\t\tchar[][] parameterNames = new char[length][];", "-\t\t\t\t\t\t\t\t\t\tchar[][] parameterTypes = new char[length][];", "-\t\t\t\t\t\t\t\t\t\tfor (int l = 0; l < length; l++) {", "-\t\t\t\t\t\t\t\t\t\t\tArgument argument = arguments[l];", "-\t\t\t\t\t\t\t\t\t\t\tparameterNames[l] = argument.name;", "-\t\t\t\t\t\t\t\t\t\t\tif (argument.type instanceof SingleTypeReference) {", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = ((SingleTypeReference)argument.type).token;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\tTypeDeclaration enclosing = typeDeclaration.enclosingType;", "-\t\t\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "-\t\t\t\t\t\t\t\t\t\twhile (enclosing != null) {", "-\t\t\t\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);", "-\t\t\t\t\t\t\t\t\t\t\tif ((enclosing.bits & ASTNode.IsMemberType) != 0) {", "-\t\t\t\t\t\t\t\t\t\t\t\tenclosing = enclosing.enclosingType;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\tenclosing = null;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t\t\t\t\tconstructorDeclaration.modifiers,", "+\t\t\t\t\t\t\t\t\t\t\t\tFlags.AccPublic,", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterNames.length,", "+\t\t\t\t\t\t\t\t\t\t\t\t-1,", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterTypes,", "-\t\t\t\t\t\t\t\t\t\t\t\tparameterNames,", "+\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "+\t\t\t\t\t\t\t\t\t\t\t\tCharOperation.NO_CHAR_CHAR,", "-\t\t\t\t\t\t\t\t\treturn false; // no need to find constructors from local/anonymous type", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "-\t\t\t\t\t\t\t\t\treturn false; ", "-\t\t\t\t\t\t\t\tprivate boolean visit(TypeDeclaration typeDeclaration) {", "-\t\t\t\t\t\t\t\t\tif(this.declaringTypes.length <= ++this.declaringTypesPtr) {", "-\t\t\t\t\t\t\t\t\t\tint length = this.declaringTypesPtr;", "-\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tthis.declaringTypes[this.declaringTypesPtr] = typeDeclaration;", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "-\t\t\t\t\t\t\t\t\treturn visit(typeDeclaration);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "-\t\t\t\t\t\t\t\t\treturn visit(memberTypeDeclaration);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.declaringTypes[this.declaringTypesPtr] = null;", "+\t\t\t\t\t\t\t\tthis.declaringTypesPtr--;", "-\t\t\t\t\t\t\tparsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "+\t\t\t\t\t\t\t\tendVisit(typeDeclaration);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tpublic void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "+\t\t\t\t\t\t\t\tendVisit(memberTypeDeclaration);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tprivate boolean hasConstructor(TypeDeclaration typeDeclaration) {", "+\t\t\t\t\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+\t\t\t\t\t\t\t\tint length = methods == null ? 0 : methods.length;", "+\t\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\t\t\tif (methods[j].isConstructor()) {", "+\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpublic boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {", "+\t\t\t\t\t\t\t\tTypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];", "+\t\t\t\t\t\t\t\tif (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {", "+\t\t\t\t\t\t\t\t\tArgument[] arguments = constructorDeclaration.arguments;", "+\t\t\t\t\t\t\t\t\tint length = arguments == null ? 0 : arguments.length;", "+\t\t\t\t\t\t\t\t\tchar[][] parameterNames = new char[length][];", "+\t\t\t\t\t\t\t\t\tchar[][] parameterTypes = new char[length][];", "+\t\t\t\t\t\t\t\t\tfor (int l = 0; l < length; l++) {", "+\t\t\t\t\t\t\t\t\t\tArgument argument = arguments[l];", "+\t\t\t\t\t\t\t\t\t\tparameterNames[l] = argument.name;", "+\t\t\t\t\t\t\t\t\t\tif (argument.type instanceof SingleTypeReference) {", "+\t\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = ((SingleTypeReference)argument.type).token;", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tparameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tTypeDeclaration enclosing = typeDeclaration.enclosingType;", "+\t\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;", "+\t\t\t\t\t\t\t\t\twhile (enclosing != null) {", "+\t\t\t\t\t\t\t\t\t\tenclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);", "+\t\t\t\t\t\t\t\t\t\tif ((enclosing.bits & ASTNode.IsMemberType) != 0) {", "+\t\t\t\t\t\t\t\t\t\t\tenclosing = enclosing.enclosingType;", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tenclosing = null;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tnameRequestor.acceptConstructor(", "+\t\t\t\t\t\t\t\t\t\t\tconstructorDeclaration.modifiers,", "+\t\t\t\t\t\t\t\t\t\t\ttypeName,", "+\t\t\t\t\t\t\t\t\t\t\tparameterNames.length,", "+\t\t\t\t\t\t\t\t\t\t\tnull, // signature is not used for source type", "+\t\t\t\t\t\t\t\t\t\t\tparameterTypes,", "+\t\t\t\t\t\t\t\t\t\t\tparameterNames,", "+\t\t\t\t\t\t\t\t\t\t\ttypeDeclaration.modifiers,", "+\t\t\t\t\t\t\t\t\t\t\tpackageDeclaration,", "+\t\t\t\t\t\t\t\t\t\t\tExtraFlags.getExtraFlags(typeDeclaration),", "+\t\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\t\tnull);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn false; // no need to find constructors from local/anonymous type", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {", "+\t\t\t\t\t\t\t\treturn false; ", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tprivate boolean visit(TypeDeclaration typeDeclaration) {", "+\t\t\t\t\t\t\t\tif(this.declaringTypes.length <= ++this.declaringTypesPtr) {", "+\t\t\t\t\t\t\t\t\tint length = this.declaringTypesPtr;", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.declaringTypes[this.declaringTypesPtr] = typeDeclaration;", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {", "+\t\t\t\t\t\t\t\treturn visit(typeDeclaration);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {", "+\t\t\t\t\t\t\t\treturn visit(memberTypeDeclaration);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (progressMonitor != null) {", "-\t\t\t\t\t\tif (progressMonitor.isCanceled()) throw new OperationCanceledException();", "-\t\t\t\t\t\tprogressMonitor.worked(1);", "+\t\t\t\t\t\tparsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tif (progressMonitor != null) {", "-\t\t\t\tprogressMonitor.done();"]}], "num": 17956}