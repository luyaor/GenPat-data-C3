{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c910a991c312a1da899aab85d4115bf4", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1092409be720427d08fe25fe9d0daf5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java", "commitBeforeChange": "146dc3b7afcca724ac2ba30b2cbb382c047a5a77", "commitAfterChange": "916862391ff792c972ae46f3240db598c93015ba", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "diff": ["-\t\tboolean hasTypeVarArgs = false;", "+\t\tboolean hasArgsTypeVar = false;", "-\t\t\t\t} else if (!hasTypeVarArgs) {", "-\t\t\t\t\thasTypeVarArgs = argumentTypes[i].isTypeVariable();", "+\t\t\t\t} else if (!hasArgsTypeVar) {", "+\t\t\t\t\thasArgsTypeVar = argumentTypes[i].isTypeVariable();", "-\t\tthis.binding = (this.receiver != null && this.receiver.isThis())", "-\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);", "+\t\tthis.binding = scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);", "+\t\tif (!this.binding.isValidBinding()) {", "+\t\t\t// Try method in enclosing types", "+\t\t\tTypeBinding enclosingTypeBinding = this.actualReceiverType;", "+\t\t\tMethodBinding methodBinding = this.binding;", "+\t\t\twhile (!methodBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {", "+\t\t\t\tenclosingTypeBinding = enclosingTypeBinding.enclosingType();", "+\t\t\t\tmethodBinding = scope.getMethod(enclosingTypeBinding, this.selector, argumentTypes, this);", "+\t\t\t}", "+\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\tthis.binding = methodBinding;", "+\t\t\t} else {", "+\t\t\t\t// Try to search a constructor instead", "+\t\t\t\tenclosingTypeBinding = this.actualReceiverType;", "+\t\t\t\tMethodBinding contructorBinding = this.binding;", "+\t\t\t\twhile (!contructorBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {", "+\t\t\t\t\tenclosingTypeBinding = enclosingTypeBinding.enclosingType();", "+\t\t\t\t\tif (CharOperation.equals(this.selector, enclosingTypeBinding.shortReadableName())) {", "+\t\t\t\t\t\tcontructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, argumentTypes, this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (contructorBinding.isValidBinding()) {", "+\t\t\t\t\tthis.binding = contructorBinding;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t} else if (hasTypeVarArgs) {", "+\t\t} else if (hasArgsTypeVar) {", "+\t\t} else if (binding.isVarargs()) {", "+\t\t\tint length = argumentTypes.length;", "+\t\t\tif (!(binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {", "+\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\tscope.problemReporter().javadocInvalidMethod(this, problem, scope.getDeclarationModifiers());", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf6cac821eb17feabeaaf27f5fa60504", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tTypeBinding internalResolveType(Scope scope)", "signatureAfterChange": "  \tTypeBinding internalResolveType(Scope scope)", "diff": ["-\t\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "+\t\tthis.argumentTypes = Binding.NO_PARAMETERS;", "-\t\t\targumentTypes = new TypeBinding[length];", "+\t\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\t\t\t\targumentTypes[i] = argument.resolveType((ClassScope)scope);", "+\t\t\t\t\tthis.argumentTypes[i] = argument.resolveType((ClassScope)scope);", "-\t\t\t\t\targumentTypes[i] = argument.resolveType((BlockScope)scope);", "+\t\t\t\t\tthis.argumentTypes[i] = argument.resolveType((BlockScope)scope);", "-\t\t\t\tif (argumentTypes[i] == null) {", "+\t\t\t\tif (this.argumentTypes[i] == null) {", "-\t\t\t\t\thasTypeVarArgs = argumentTypes[i].isTypeVariable();", "+\t\t\t\t\thasTypeVarArgs = this.argumentTypes[i].isTypeVariable();", "-\t\tthis.binding = scope.getConstructor(allocationType, argumentTypes, this);", "+\t\tthis.binding = scope.getConstructor(allocationType, this.argumentTypes, this);", "-\t\t\t\tcontructorBinding = scope.getConstructor(enclosingTypeBinding, argumentTypes, this);", "+\t\t\t\tcontructorBinding = scope.getConstructor(enclosingTypeBinding, this.argumentTypes, this);", "-\t\t\tMethodBinding methodBinding = scope.getMethod(this.resolvedType, this.resolvedType.sourceName(), argumentTypes, this);", "+\t\t\tMethodBinding methodBinding = scope.getMethod(this.resolvedType, this.resolvedType.sourceName(), this.argumentTypes, this);", "-\t\t\tint length = argumentTypes.length;", "-\t\t\tif (!(this.binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {", "-\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\tint length = this.argumentTypes.length;", "+\t\t\tif (!(this.binding.parameters.length == length && this.argumentTypes[length-1].isArrayType())) {", "+\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);", "-\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\tint length = argumentTypes.length;", "+\t\t\t\tint length = this.argumentTypes.length;", "-\t\t\t\t\tif (TypeBinding.notEquals(paramMethodBinding.parameters[i], argumentTypes[i]) &&", "-\t\t\t\t\t\t\tTypeBinding.notEquals(paramMethodBinding.parameters[i].erasure(), argumentTypes[i].erasure())) {", "-\t\t\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\tif (TypeBinding.notEquals(paramMethodBinding.parameters[i], this.argumentTypes[i]) &&", "+\t\t\t\t\t\t\tTypeBinding.notEquals(paramMethodBinding.parameters[i].erasure(), this.argumentTypes[i].erasure())) {", "+\t\t\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e63e3715c796a9a9d187610a50f6480d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "  \tpublic MethodBinding getMethod(TypeBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tpublic MethodBinding getMethod(TypeBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tif (receiverType.isArrayType())", "-\t\t\treturn findMethodForArray((ArrayBinding) receiverType, selector, argumentTypes, invocationSite);", "-\t\tif (receiverType.isBaseType())", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "-", "-\t\tReferenceBinding currentType = (ReferenceBinding) receiverType;", "-\t\tif (!currentType.canBeSeenBy(this))", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, ReceiverTypeNotVisible);", "-", "-\t\t// retrieve an exact visible match (if possible)", "-\t\tMethodBinding methodBinding = findExactMethod(currentType, selector, argumentTypes, invocationSite);", "-\t\tif (methodBinding != null) return methodBinding;", "-", "-\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\tmethodBinding = findMethod(currentType, selector, argumentTypes, invocationSite);", "-\t\tif (methodBinding == null)", "-\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes))", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\targumentTypes,", "-\t\t\t\t\tNotFound);", "-\t\t\tif (!methodBinding.canBeSeenBy(currentType, invocationSite, this))", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\tNotVisible);", "+\t\ttry {", "+\t\t\tif (receiverType.isArrayType())", "+\t\t\t\treturn findMethodForArray((ArrayBinding) receiverType, selector, argumentTypes, invocationSite);", "+\t\t\tif (receiverType.isBaseType())", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "+\t", "+\t\t\tReferenceBinding currentType = (ReferenceBinding) receiverType;", "+\t\t\tif (!currentType.canBeSeenBy(this))", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, ReceiverTypeNotVisible);", "+\t", "+\t\t\t// retrieve an exact visible match (if possible)", "+\t\t\tMethodBinding methodBinding = findExactMethod(currentType, selector, argumentTypes, invocationSite);", "+\t\t\tif (methodBinding != null) return methodBinding;", "+\t", "+\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\tmethodBinding = findMethod(currentType, selector, argumentTypes, invocationSite);", "+\t\t\tif (methodBinding == null)", "+\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, NotFound);", "+\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes))", "+\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\tmethodBinding,", "+\t\t\t\t\t\tselector,", "+\t\t\t\t\t\targumentTypes,", "+\t\t\t\t\t\tNotFound);", "+\t\t\t\tif (!methodBinding.canBeSeenBy(currentType, invocationSite, this))", "+\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\tmethodBinding,", "+\t\t\t\t\t\tselector,", "+\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\tNotVisible);", "+\t\t\t}", "+\t\t\treturn methodBinding;", "+\t\t\t", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(invocationSite, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\treturn methodBinding;"]}], "num": 22822}