{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9813ff57a3a6ab601289472fbf38b7fa", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "49249e837b3041e369cd87fbbe174163", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/NullInfoRegistry.java", "commitBeforeChange": "ed32ce010cb6b771c8064ab8d69b715c1bc9347a", "commitAfterChange": "c6f68ef4215a4043642761fb9fa6bf6a14d9061b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public UnconditionalFlowInfo mitigateNullInfoOf(FlowInfo flowInfo)", "signatureAfterChange": " public UnconditionalFlowInfo mitigateNullInfoOf(FlowInfo flowInfo)", "diff": ["-\tm2 = s1 & (s2 = this.nullBit2) & (s3 ^ s4)", "+\tm2 = s1 & (s2 = this.nullBit2) & (s3 ^ s4) // TODO(stephan): potential typo: should this be \"s2 = source.nullBit2\"???", "+\t\t// any variable that is (pot n, pot nn, pot un) at end of try (as captured by *this* NullInfoRegistry)", "+\t\t// has the same uncertainty also for the mitigated case (function result)", "+\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=320170 -  [compiler] [null] Whitebox issues in null analysis", "+\t\t// and org.eclipse.jdt.core.tests.compiler.regression.NullReferenceTest.test0536_try_finally()", "+\t\tlong x = ~this.nullBit1 & a2 & a3 & a4; // x is set for all variable ids that have state 0111 (pot n, pot nn, pot un)", "+\t\tif (x != 0) {", "+\t\t\t// restore state 0111 for all variable ids in x:", "+\t\t\tsource.nullBit1 &= ~x;", "+\t\t\tsource.nullBit2 |= x;", "+\t\t\tsource.nullBit3 |= x;", "+\t\t\tsource.nullBit4 |= x;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ce607a1b8c0594b8d8f702b59d03500", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "41fe30d0273f5089ef76e570928ab7cb2dabbec3", "commitAfterChange": "3cca2130a88b1412da5c23c480bb1e524d89ea5e", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits)", "signatureAfterChange": "  public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits)", "diff": ["+    \t\t// the above formulae do not handle the state 0111, do it now explicitly:", "+    \t\tlong ax = ~a1 & a2 & a3 & a4;", "+    \t\tlong bx = ~b1 & b2 & b3 & b4;", "+    \t\tlong x = ax|bx;", "+    \t\tif (x != 0) {", "+    \t\t\t// restore state 0111 for all variable ids in x:", "+    \t\t\tthis.nullBit1 &= ~x;", "+    \t\t\tthis.nullBit2 |= x;", "+    \t\t\tthis.nullBit3 |= x;", "+    \t\t\tthis.nullBit4 |= x;", "+    \t\t}", "+\t\t", "+    \t\t// the above formulae do not handle the state 0111, do it now explicitly:", "+    \t\tlong ax = ~a1 & a2 & a3 & a4;", "+    \t\tlong bx = ~b1 & b2 & b3 & b4;", "+    \t\tlong x = ax|bx;", "+    \t\tif (x != 0) {", "+    \t\t\t// restore state 0111 for all variable ids in x:", "+    \t\t\tthis.extra[2][i] &= ~x;", "+    \t\t\tthis.extra[3][i] |= x;", "+    \t\t\tthis.extra[4][i] |= x;", "+    \t\t\tthis.extra[5][i] |= x;", "+    \t\t}"]}], "num": 33734}