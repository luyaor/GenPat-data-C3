{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d494e8d162e54590cac82341c5cac9f2", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77d8061f69547c9ac1ad8ea411124175", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 25, "signatureBeforeChange": "  \tpublic void clearWorkingCopyMaps()", "signatureAfterChange": " \tprivate synchronized List<ICompilationUnit> clearWorkingCopyMaps()", "diff": ["+\t */", "+\tprivate synchronized List<ICompilationUnit> clearWorkingCopyMaps()", "+\t{", "+\t\tint size = _hiddenBuiltTypes.size() + _workingCopies.size();", "+\t\tList<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>(size);", "+\t\ttoDiscard.addAll(_hiddenBuiltTypes.values());", "+\t\ttoDiscard.addAll(_workingCopies.values());", "+\t\t_workingCopies.clear();", "+\t\t_hiddenBuiltTypes.clear();", "+\t\t_parentToGenWorkingCopies.clear();", "+", "+\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace( ", "+\t\t\t\t\"cleared working copy dependencies\"); //$NON-NLS-1$", "+", "+\t\tassert checkIntegrity();", "+\t\treturn toDiscard;", "+\t}", "-", "-\tpublic void clearWorkingCopyMaps()", "-\t{", "-\t\t// first discard all working copies", "-", "-\t\tCollection<ICompilationUnit> workingCopies;", "-\t\t", "-\t\tsynchronized( this )", "-\t\t{", "-\t\t\t// make a copy to avoid race conditions", "-\t\t\tworkingCopies = new ArrayList<ICompilationUnit>( _generatedFile2WorkingCopy.values() );", "-\t\t", "-\t\t\t_generatedWorkingCopy2OpenParentFiles.clear();", "-\t\t\t_generatedFile2WorkingCopy.clear();", "-\t\t}", "-\t\t", "-\t\t\t", "-\t\tfor ( ICompilationUnit workingCopy : workingCopies )", "-\t\t{", "-\t\t\ttry", "-\t\t\t{", "-\t\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t\t}", "-\t\t\tcatch( JavaModelException jme )", "-\t\t\t{", "-\t\t\t\tAptPlugin.log(jme, \"Could not discard working copy\"); //$NON-NLS-1$", "-\t\t\t\t// TODO:  deal with this", "-\t\t\t}", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8cb07a6300f68a3de510e721a065bd46", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "signatureAfterChange": " protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "diff": ["-}", "-protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator) {", "-\t// We can only refine if locator has an unit scope.", "-\tif (locator.unitScope == null) return accuracy;", "-", "-\t// Refine accuracy using binding and pattern arguments", "-\tchar[][] patternArguments = (patternTypeArguments==null) ? null : patternTypeArguments[depth];", "-\tint refinedAccuracy = refineAccuracy(accuracy, parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "-\tif (refinedAccuracy == SearchPattern.R_ERASURE_MATCH) {", "-\t\treturn SearchPattern.R_ERASURE_MATCH;", "-", "-\t// Recurse refining on enclosing types if any", "-\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "-\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "-\t\tif (patternTypeArguments == null || (depth+1)<patternTypeArguments.length) {", "-\t\t\treturn refineAccuracy(refinedAccuracy, (ParameterizedTypeBinding)enclosingType, patternTypeArguments, patternHasTypeParameters, depth+1, locator);", "-\t\t}", "-\t}", "-\t", "-\t// Refine the accuracy to accurate", "-\treturn refinedAccuracy;", "+protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator) {", "+\t// Only possible if locator has an unit scope.", "+\tif (locator.unitScope == null) return;", "+", "+\t// Set match raw flag", "+\tboolean endPattern = depth>=patternTypeArguments.length;", "+\tchar[][] patternArguments = (patternTypeArguments==null || endPattern) ? null : patternTypeArguments[depth];", "+\tboolean isRaw = parameterizedBinding.isRawType()|| (parameterizedBinding.arguments==null && parameterizedBinding.type.isGenericType());", "+\tif (isRaw && !match.isRaw()) {", "+\t\tmatch.setRaw(isRaw);", "+\t}", "+\t", "+\t// Update match", "+\tif (!endPattern) {", "+\t\tupdateMatch(parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "+\t}", "+", "+\t// Recurse", "+\tTypeBinding enclosingType = parameterizedBinding.enclosingType();", "+\tif (enclosingType != null && (enclosingType.isParameterizedType() || enclosingType.isRawType())) {", "+\t\tupdateMatch((ParameterizedTypeBinding)enclosingType, patternTypeArguments, patternHasTypeParameters, depth+1, locator);", "+\t}", "+}"]}], "num": 44768}