{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2d647f53dafcab3019598eebd2f68195", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "042b087e3881cd388285d55d5d4a390b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "332f2b4bbc61519d48f9e1634468f589fe6ec357", "commitAfterChange": "1dac44e6f5251febeac5322fb143c153ef780c6a", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " \tprotected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations)", "signatureAfterChange": " \tprotected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations)", "diff": ["+\t\tTypeBinding firstType = types[indexOfFirst];", "+\t\tif (firstType.isBaseType()) return null; ", "-\t\tTypeBinding firstType = types[indexOfFirst];", "-\t\tTypeBinding[] erasedSuperTypes;", "-\t\tint superLength;", "-\t\tif (firstType.isBaseType()) {", "-\t\t\treturn null; ", "-\t\t} else if (firstType.isArrayType()) {", "-\t\t\tsuperLength = 4;", "-\t\t\tif (firstType.erasure() != firstType) {", "-\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\tsomeInvocations.add(firstType);", "-\t\t\t\tallInvocations.put(firstType.erasure(), someInvocations);", "-\t\t\t}", "-\t\t\terasedSuperTypes = new TypeBinding[] { // inject well-known array supertypes", "-\t\t\t\t\tfirstType.erasure(), ", "-\t\t\t\t\tgetJavaIoSerializable(),", "-\t\t\t\t\tgetJavaLangCloneable(),", "-\t\t\t\t\tgetJavaLangObject(),", "-\t\t\t};", "-\t\t} else {", "-\t\t\tArrayList typesToVisit = new ArrayList(5);", "-\t\t\tTypeBinding firstErasure = (firstType.isTypeVariable() && !firstType.isCapture()) ? firstType : firstType.erasure();", "-\t\t\tif (firstErasure != firstType) {", "-\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\tsomeInvocations.add(firstType);", "-\t\t\t\tallInvocations.put(firstErasure, someInvocations);", "-\t\t\t}", "-\t\t\ttypesToVisit.add(firstType);", "-\t\t\tint max = 1;", "-\t\t\tif (firstErasure.isArrayType()) {", "-\t\t\t\ttypesToVisit.add(getJavaIoSerializable());", "-\t\t\t\ttypesToVisit.add(getJavaLangCloneable());", "-\t\t\t\ttypesToVisit.add(getJavaLangObject());", "-\t\t\t\tmax += 3;", "-\t\t\t}", "-\t\t\tReferenceBinding currentType = (ReferenceBinding)firstType;", "-\t\t\tfor (int i = 0; i < max; i++) {", "-\t\t\t\tTypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);", "-\t\t\t\tif (typeToVisit.isArrayType()) continue;", "-\t\t\t\tcurrentType = (ReferenceBinding) typeToVisit;", "-\t\t\t\t// inject super interfaces prior to superclass", "-\t\t\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "-\t\t\t\tfor (int j = 0, count = itsInterfaces.length; j < count; j++) {", "-\t\t\t\t\tTypeBinding itsInterface = itsInterfaces[j];", "-\t\t\t\t\tTypeBinding itsInterfaceErasure = (itsInterface.isTypeVariable() && !itsInterface.isCapture()) ? itsInterface : itsInterface.erasure();", "-\t\t\t\t\tif (!typesToVisit.contains(itsInterfaceErasure)) {", "-\t\t\t\t\t\tif (itsInterfaceErasure != itsInterface) {", "-\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\t\t\t\tsomeInvocations.add(itsInterface);", "-\t\t\t\t\t\t\tallInvocations.put(itsInterfaceErasure, someInvocations);", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\ttypesToVisit.add(itsInterface);", "-\t\t\t\t\t\tmax++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "-\t\t\t\tif (itsSuperclass != null) {", "-\t\t\t\t\tTypeBinding itsSuperclassErasure = (itsSuperclass.isTypeVariable() && !itsSuperclass.isCapture()) ? itsSuperclass : itsSuperclass.erasure();", "-\t\t\t\t\tif (!typesToVisit.contains(itsSuperclassErasure)) {", "-\t\t\t\t\t\tif (itsSuperclassErasure != itsSuperclass) {", "-\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\t\t\t\tsomeInvocations.add(itsSuperclass);", "-\t\t\t\t\t\t\tallInvocations.put(itsSuperclassErasure, someInvocations);", "+\t\tArrayList typesToVisit = new ArrayList(5);", "+\t\t", "+\t\tint dim = firstType.dimensions();", "+\t\tTypeBinding leafType = firstType.leafComponentType();", "+\t\tTypeBinding firstErasure = (leafType.isTypeVariable() || leafType.isWildcard()/*&& !leafType.isCapture()*/) ? firstType : firstType.erasure();", "+\t\tif (firstErasure != firstType) {", "+\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\tsomeInvocations.add(firstType);", "+\t\t\tallInvocations.put(firstErasure, someInvocations);", "+\t\t}\t\t\t\t\t\t", "+\t\ttypesToVisit.add(firstType);", "+\t\tint max = 1;", "+\t\tReferenceBinding currentType;", "+\t\tfor (int i = 0; i < max; i++) {", "+\t\t\tTypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);", "+\t\t\tdim = typeToVisit.dimensions();", "+\t\t\tif (dim > 0) {", "+\t\t\t\tleafType = typeToVisit.leafComponentType();", "+\t\t\t\tswitch(leafType.id) {", "+\t\t\t\t\tcase T_JavaLangObject:", "+\t\t\t\t\t\tif (dim > 1) { // Object[][] supertype is Object[]", "+\t\t\t\t\t\t\tTypeBinding elementType = ((ArrayBinding)typeToVisit).elementsType();", "+\t\t\t\t\t\t\tif (!typesToVisit.contains(elementType)) {", "+\t\t\t\t\t\t\t\ttypesToVisit.add(elementType);", "+\t\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\ttypesToVisit.add(itsSuperclass);", "+\t\t\t\t\t\t// fallthrough", "+\t\t\t\t\tcase T_byte:", "+\t\t\t\t\tcase T_short:", "+\t\t\t\t\tcase T_char:", "+\t\t\t\t\tcase T_boolean:", "+\t\t\t\t\tcase T_int:", "+\t\t\t\t\tcase T_long:", "+\t\t\t\t\tcase T_float:", "+\t\t\t\t\tcase T_double:", "+\t\t\t\t\t\tTypeBinding superType = getJavaIoSerializable();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsuperType = getJavaLangCloneable();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsuperType = getJavaLangObject();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t", "+\t\t\t\t\tdefault:", "+\t\t\t\t}", "+\t\t\t\ttypeToVisit = leafType;", "+\t\t\t}", "+\t\t\tcurrentType = (ReferenceBinding) typeToVisit;", "+\t\t\tif (currentType.isCapture()) {", "+\t\t\t\tTypeBinding firstBound = ((CaptureBinding) currentType).firstBound;", "+\t\t\t\tif (firstBound != null && firstBound.isArrayType()) {", "+\t\t\t\t\tTypeBinding superType = dim == 0 ? firstBound : (TypeBinding)environment().createArrayType(firstBound, dim); // recreate array if needed", "+\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\tTypeBinding superTypeErasure = (firstBound.isTypeVariable() || firstBound.isWildcard() /*&& !itsInterface.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// inject super interfaces prior to superclass", "+\t\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "+\t\t\tfor (int j = 0, count = itsInterfaces.length; j < count; j++) {", "+\t\t\t\tTypeBinding itsInterface = itsInterfaces[j];", "+\t\t\t\tTypeBinding superType = dim == 0 ? itsInterface : (TypeBinding)environment().createArrayType(itsInterface, dim); // recreate array if needed", "+\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\tmax++;", "+\t\t\t\t\tTypeBinding superTypeErasure = (itsInterface.isTypeVariable() || itsInterface.isWildcard() /*&& !itsInterface.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "+\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "+\t\t\tif (itsSuperclass != null) {", "+\t\t\t\tTypeBinding superType = dim == 0 ? itsSuperclass : (TypeBinding)environment().createArrayType(itsSuperclass, dim); // recreate array if needed", "+\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\tmax++;", "+\t\t\t\t\tTypeBinding superTypeErasure = (itsSuperclass.isTypeVariable() || itsSuperclass.isWildcard() /*&& !itsSuperclass.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "-\t\t\tsuperLength = typesToVisit.size();", "-\t\t\terasedSuperTypes = new TypeBinding[superLength];", "-\t\t\tint rank = 0;", "-\t\t\tfor (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {", "-\t\t\t\tTypeBinding type = (TypeBinding)iter.next();", "-\t\t\t\terasedSuperTypes[rank++] = type.isTypeVariable() ? type : type.erasure();", "-\t\t\t}", "+\t\t}", "+\t\tint superLength = typesToVisit.size();", "+\t\tTypeBinding[] erasedSuperTypes = new TypeBinding[superLength];", "+\t\tint rank = 0;", "+\t\tfor (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {", "+\t\t\tTypeBinding type = (TypeBinding)iter.next();", "+\t\t\tleafType = type.leafComponentType();", "+\t\t\terasedSuperTypes[rank++] = (leafType.isTypeVariable() || leafType.isWildcard() /*&& !leafType.isCapture()*/) ? type : type.erasure();", "-\t\t\t\t\tswitch (erasedSuperType.id) {", "-\t\t\t\t\t\tcase T_JavaIoSerializable :", "-\t\t\t\t\t\tcase T_JavaLangCloneable :", "-\t\t\t\t\t\tcase T_JavaLangObject :", "-\t\t\t\t\t\t\tcontinue nextSuperType;", "+\t\t\t\t\tTypeBinding match;", "+\t\t\t\t\tif ((match = ((ArrayBinding)otherType).findSuperTypeWithSameErasure(erasedSuperType)) == null) {", "+\t\t\t\t\t\terasedSuperTypes[j] = null;", "+\t\t\t\t\t\tif (--remaining == 0) return null;", "+\t\t\t\t\t\tcontinue nextSuperType;", "-\t\t\t\t\terasedSuperTypes[j] = null;", "-\t\t\t\t\tif (--remaining == 0) return null;", "-\t\t\t\t\t", "+\t\t\t\t\t// record invocation", "+\t\t\t\t\tSet someInvocations = (Set) allInvocations.get(erasedSuperType);", "+\t\t\t\t\tif (someInvocations == null) someInvocations = new HashSet(1);", "+\t\t\t\t\tsomeInvocations.add(match);", "+\t\t\t\t\tallInvocations.put(erasedSuperType, someInvocations);", "-\t\t\t\t\tif (otherType.id == T_JavaLangObject && erasedSuperType.isInterface()) continue nextOtherType;", "+\t\t\t\t\t\tif (otherType.id == T_JavaLangObject && erasedSuperType.isInterface()) continue nextOtherType; // keep Object for an interface", "+\t\t\t\t\t} else if (erasedSuperType.isArrayType()) {", "+\t\t\t\t\tif (otherType.isArrayType() // keep Object[...] for an interface array (same dimensions)", "+\t\t\t\t\t\t\t&& otherType.leafComponentType().id == T_JavaLangObject", "+\t\t\t\t\t\t\t&& otherType.dimensions() == erasedSuperType.dimensions()", "+\t\t\t\t\t\t\t&& erasedSuperType.leafComponentType().isInterface()) continue nextOtherType;", "+\t\t\t\t\t\tif (((ArrayBinding)erasedSuperType).findSuperTypeWithSameErasure(otherType) != null) {", "+\t\t\t\t\t\t\terasedSuperTypes[j] = null; // discard non minimal supertype", "+\t\t\t\t\t\t\tremaining--;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "361766e5c2a4019a07989555ac7dfcd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingExpressionsTest.java", "commitBeforeChange": "0878e1dc107fb190292b2de3d6e4f25e19c0489c", "commitAfterChange": "80b12656ac31b339fd22081301db662b77277ac4", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tpublic static Test setUpTest(Test someTest)", "signatureAfterChange": "  \tpublic void testInfixExpression2() throws Exception", "diff": ["-", "-\tpublic static Test setUpTest(Test someTest) {", "-\t\tTestSuite suite= new Suite(\"one test\");", "-\t\tsuite.addTest(someTest);", "-\t\treturn suite;", "+\tpublic void testInfixExpression2() throws Exception {", "+\t\tIPackageFragment pack1= this.sourceFolder.createPackageFragment(\"test1\", false, null);", "+\t\tStringBuffer buf= new StringBuffer();", "+\t\tbuf.append(\"package test1;\\n\");", "+\t\tbuf.append(\"public class E {\\n\");", "+\t\tbuf.append(\"    public void foo() {\\n\");", "+\t\tbuf.append(\"        i= 0 + 2;\\n\");", "+\t\tbuf.append(\"        j= 1 + 0;\\n\");", "+\t\tbuf.append(\"        k= 0 + 2 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        l= 1 + 0 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        m= 0 + 0 + 0 + 4 + 5;\\n\");", "+\t\tbuf.append(\"    }\\n\");", "+\t\tbuf.append(\"}\\n\");", "+\t\tICompilationUnit cu= pack1.createCompilationUnit(\"E.java\", buf.toString(), false, null);", "+\t", "+\t\tCompilationUnit astRoot= createAST(cu);", "+\t\tASTRewrite rewrite= ASTRewrite.create(astRoot.getAST());", "+\t", "+\t\tassertTrue(\"Parse errors\", (astRoot.getFlags() & ASTNode.MALFORMED) == 0);", "+\t\tTypeDeclaration type= findTypeDeclaration(astRoot, \"E\");", "+\t\tMethodDeclaration methodDecl= findMethodDeclaration(type, \"foo\");", "+\t\tBlock block= methodDecl.getBody();", "+\t\tList statements= block.statements();", "+\t\t{ // remove left side", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(0);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove right side", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(1);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove left side (with extended operands)", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(2);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t}", "+\t", "+\t\t{ // remove right side (with extended operands)", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(3);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t\t\t", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t}", "+\t\t", "+\t\t{ // remove left, right, and extended operand", "+\t\t\tExpressionStatement stmt= (ExpressionStatement) statements.get(4);", "+\t\t\tAssignment assignment= (Assignment) stmt.getExpression();", "+\t\t\tInfixExpression expr= (InfixExpression) assignment.getRightHandSide();", "+\t\t\t", "+\t\t\trewrite.remove(expr.getLeftOperand(), null);", "+\t\t\trewrite.remove(expr.getRightOperand(), null);", "+\t\t\trewrite.remove((ASTNode) expr.extendedOperands().get(0), null);", "+\t\t}", "+\t\t", "+\t\tString preview= evaluateRewrite(cu, rewrite);", "+\t", "+\t\tbuf= new StringBuffer();", "+\t\tbuf.append(\"package test1;\\n\");", "+\t\tbuf.append(\"public class E {\\n\");", "+\t\tbuf.append(\"    public void foo() {\\n\");", "+\t\tbuf.append(\"        i= 2;\\n\");", "+\t\tbuf.append(\"        j= 1;\\n\");", "+\t\tbuf.append(\"        k= 2 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        l= 1 + 3 + 4 + 5;\\n\");", "+\t\tbuf.append(\"        m= 4 + 5;\\n\");", "+\t\tbuf.append(\"    }\\n\");", "+\t\tbuf.append(\"}\\n\");", "+\t\tassertEqualString(preview, buf.toString());", "+\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78d111afc41e14740713ed4ccd6ecff4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "b18b012adcc471e2280a6e20faa4d2a33f1db69a", "commitAfterChange": "5bb01926d23a6cf003d0d521691c391ac08b77a7", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 13, "signatureBeforeChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber)", "signatureAfterChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber)", "diff": ["-\t\tbuffer", "-\t\t\t.append(Util.bind(\"disassembler.commentstart\")) //$NON-NLS-1$", "-\t\t\t.append(Util.bind(\"classfileformat.maxStack\")) //$NON-NLS-1$", "-\t\t\t.append(codeAttribute.getMaxStack())", "-\t\t\t.append(Util.bind(\"disassembler.comma\")) //$NON-NLS-1$", "-\t\t\t.append(Util.bind(\"classfileformat.maxLocals\")) //$NON-NLS-1$", "-\t\t\t.append(codeAttribute.getMaxLocals())", "-\t\t\t.append(Util.bind(\"disassembler.commentend\")); //$NON-NLS-1$", "-\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "-\t\tbuffer.append(Util.bind(\"disassembler.codeattributeheader\")); //$NON-NLS-1$", "-\t\tDefaultBytecodeVisitor visitor = new DefaultBytecodeVisitor(codeAttribute.getCodeLength(), buffer, lineSeparator, tabNumber + 1);", "+\t\tDefaultBytecodeVisitor visitor = new DefaultBytecodeVisitor(codeAttribute.getCodeLength(), buffer, lineSeparator, tabNumber);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\tfinal int tabNumberForExceptionAttribute = tabNumber + 2;", "+\t\t\tdumpTab(tabNumberForExceptionAttribute, buffer);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "-\t\t\tfor (int i = 0; i < exceptionTableLength; i++) {", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForExceptionAttribute + 1);", "+\t\t\tfor (int i = 0; i < exceptionTableLength - 1; i++) {", "-\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForExceptionAttribute + 1);", "+\t\t\tIExceptionTableEntry exceptionTableEntry = exceptionTableEntries[exceptionTableLength - 1];", "+\t\t\tbuffer", "+\t\t\t\t.append(Util.bind(\"classfileformat.exceptiontablefrom\")) //$NON-NLS-1$", "+\t\t\t\t.append(exceptionTableEntry.getStartPC())", "+\t\t\t\t.append(Util.bind(\"classfileformat.exceptiontableto\")) //$NON-NLS-1$", "+\t\t\t\t.append(exceptionTableEntry.getEndPC())", "+\t\t\t\t.append(Util.bind(\"classfileformat.exceptiontablegoto\")) //$NON-NLS-1$", "+\t\t\t\t.append(exceptionTableEntry.getHandlerPC())", "+\t\t\t\t.append(Util.bind(\"classfileformat.exceptiontablewhen\")); //$NON-NLS-1$", "+\t\t\tif (exceptionTableEntry.getCatchTypeIndex() == 0) {", "+\t\t\t\tbuffer.append(ANY_EXCEPTION);", "+\t\t\t} else {", "+\t\t\t\tchar[] catchType = exceptionTableEntry.getCatchType();", "+\t\t\t\tCharOperation.replace(catchType, '/', '.');", "+\t\t\t\tbuffer.append(catchType);", "+\t\t\t}", "+\t\t\twriteNewLine(buffer, lineSeparator, 0);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\tint tabNumberForLineAttribute = tabNumber + 2;", "+\t\t\tdumpTab(tabNumberForLineAttribute, buffer);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute + 1);", "-\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute + 1);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\tint tabNumberForLocalVariableAttribute = tabNumber + 2;", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute + 1);", "+\t\t\t\tint index= localVariableTableEntry.getIndex();", "-\t\t\t\tchar[] exceptionType = Signature.toCharArray(localVariableTableEntry.getDescriptor());", "-\t\t\t\tCharOperation.replace(exceptionType, '/', '.');", "-\t\t\t\t\t.append(localVariableTableEntry.getIndex())", "-\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")) //$NON-NLS-1$", "-\t\t\t\t\t.append(exceptionType);", "-\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\t\t.append(index)", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")); //$NON-NLS-1$", "+\t\t\t\tbuffer.append(localVariableTableEntry.getDescriptor());", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute + 1);", "+\t\t\tint index= localVariableTableEntry.getIndex();", "-\t\t\tchar[] exceptionType = Signature.toCharArray(localVariableTableEntry.getDescriptor());", "-\t\t\tCharOperation.replace(exceptionType, '/', '.');", "-\t\t\t\t.append(localVariableTableEntry.getIndex())", "-\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")) //$NON-NLS-1$", "-\t\t\t\t.append(exceptionType);", "+\t\t\t\t.append(index)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")); //$NON-NLS-1$", "+\t\t\tbuffer.append(localVariableTableEntry.getDescriptor());", "+\t\tILocalVariableTypeTableAttribute localVariableTypeAttribute= getLocalVariableTypeAttribute(codeAttribute);", "+\t\tint localVariableTypeTableLength = localVariableTypeAttribute == null ? 0 : localVariableTypeAttribute.getLocalVariableTypeTableLength();", "+\t\tif (localVariableTypeTableLength != 0) {", "+\t\t\tint tabNumberForLocalVariableAttribute = tabNumber + 2;", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\tbuffer.append(Util.bind(\"disassembler.localvariabletypetableattributeheader\")); //$NON-NLS-1$", "+\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute + 1);", "+\t\t\tILocalVariableTypeTableEntry[] localVariableTypeTableEntries = localVariableTypeAttribute.getLocalVariableTypeTable();", "+\t\t\tfor (int i = 0; i < localVariableTypeTableLength - 1; i++) {", "+\t\t\t\tILocalVariableTypeTableEntry localVariableTypeTableEntry = localVariableTypeTableEntries[i];", "+\t\t\t\tint index= localVariableTypeTableEntry.getIndex();", "+\t\t\t\tint startPC = localVariableTypeTableEntry.getStartPC();", "+\t\t\t\tint length  = localVariableTypeTableEntry.getLength();", "+\t\t\t\tbuffer", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablefrom\")) //$NON-NLS-1$", "+\t\t\t\t\t.append(startPC)", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletableto\")) //$NON-NLS-1$", "+\t\t\t\t\t.append(startPC + length)", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalname\")) //$NON-NLS-1$", "+\t\t\t\t\t.append(localVariableTypeTableEntry.getName())", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalindex\")) //$NON-NLS-1$", "+\t\t\t\t\t.append(index)", "+\t\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")); //$NON-NLS-1$", "+\t\t\t\tbuffer.append(localVariableTypeTableEntry.getSignature());", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute + 1);", "+\t\t\t}", "+\t\t\tILocalVariableTypeTableEntry localVariableTypeTableEntry = localVariableTypeTableEntries[localVariableTypeTableLength - 1];", "+\t\t\tint index= localVariableTypeTableEntry.getIndex();", "+\t\t\tint startPC = localVariableTypeTableEntry.getStartPC();", "+\t\t\tint length  = localVariableTypeTableEntry.getLength();", "+\t\t\tbuffer", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablefrom\")) //$NON-NLS-1$", "+\t\t\t\t.append(startPC)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletableto\")) //$NON-NLS-1$", "+\t\t\t\t.append(startPC + length)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalname\")) //$NON-NLS-1$", "+\t\t\t\t.append(localVariableTypeTableEntry.getName())", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalindex\")) //$NON-NLS-1$", "+\t\t\t\t.append(index)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")) //$NON-NLS-1$", "+\t\t\t\t.append(localVariableTypeTableEntry.getSignature());", "+\t\t} ", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8115d358dc712651421cb2b826a65ee2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/AllPerformanceTests.java", "commitBeforeChange": "dea180787931d8ee1f626772e59d44fa10c93411", "commitAfterChange": "b6e6b13ef7ecfc2948e12f097478c9541e12b4c6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic static Test suite()", "signatureAfterChange": " \tpublic static Test suite()", "diff": ["-\t\t// Cannot run performance tests if one of subset static fields is not null", "+\t\t// Display warning if one of subset static fields is not null", "-\t\tif (TestCase.TESTS_NAMES != null ||", "-\t\t\tTestCase.TESTS_PREFIX != null ||", "-\t\t\tTestCase.TESTS_NUMBERS != null ||", "-\t\t\tTestCase.TESTS_RANGE != null) {", "-\t\t\tSystem.err.println(\"Cannot run performance tests as there are defined subsets which may alter tests order!\");", "-\t\t\treturn perfSuite;", "+\t\tStringBuffer buffer = null;", "+\t\tif (TestCase.TESTS_NAMES != null) {", "+\t\t\tbuffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\tbuffer.append(\"\t- following subset is still defined and may alter tests order:\\n\");", "+\t\t\tbuffer.append(\"\t\t+ TESTS_NAMES = new String[] { \");", "+\t\t\tint length = TestCase.TESTS_NAMES.length;", "+\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\tif (i>0) buffer.append(',');", "+\t\t\t\tbuffer.append('\"');", "+\t\t\t\tbuffer.append(TestCase.TESTS_NAMES[i]);", "+\t\t\t\tbuffer.append('\"');", "+\t\t\t}", "+\t\t\tbuffer.append(\" };\\n\");", "+\t\t}", "+\t\tif (TestCase.TESTS_PREFIX != null) {", "+\t\t\tif (buffer == null) {", "+\t\t\t\tbuffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\t\tbuffer.append(\"\t- following subset is still defined and may alter tests order:\\n\");", "+\t\t\t}", "+\t\t\tbuffer.append(\"\t\t+ TESTS_PREFIX = \");", "+\t\t\tbuffer.append('\"');", "+\t\t\tbuffer.append(TestCase.TESTS_PREFIX);", "+\t\t\tbuffer.append('\"');", "+\t\t\tbuffer.append(\";\\n\");", "+\t\t}", "+\t\tif (TestCase.TESTS_NUMBERS != null) {", "+\t\t\tif (buffer == null) {", "+\t\t\t\tbuffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\t\tbuffer.append(\"\t- following subset is still defined and may alter tests order:\\n\");", "+\t\t\t}", "+\t\t\tbuffer.append(\"\t\t+ TESTS_NUMBERS = new int[] { \");", "+\t\t\tint length = TestCase.TESTS_NUMBERS.length;", "+\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\tif (i>0) buffer.append(',');", "+\t\t\t\tbuffer.append(TestCase.TESTS_NUMBERS[i]);", "+\t\t\t}", "+\t\t\tbuffer.append(\" };\\n\");", "+\t\t}", "+\t\tif (TestCase.TESTS_RANGE != null) {", "+\t\t\tif (buffer == null) {", "+\t\t\t\tbuffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\t\tbuffer.append(\"\t- following subset is still defined and may alter tests order:\\n\");", "+\t\t\t}", "+\t\t\tbuffer.append(\"\t\t+ TESTS_RANGE = new int[] { \");", "+\t\t\tbuffer.append(TestCase.TESTS_RANGE[0]);", "+\t\t\tbuffer.append(',');", "+\t\t\tbuffer.append(TestCase.TESTS_RANGE[1]);", "+\t\t\tbuffer.append(\";\\n\");", "+\t\t}", "+\t\t", "+\t\t// Verify VM memory arguments: should be -Xmx256M -Xms256M", "+\t\tNumberFormat floatFormat = NumberFormat.getNumberInstance();", "+\t\tfloatFormat.setMaximumFractionDigits(1);", "+\t\tlong maxMem = Runtime.getRuntime().maxMemory(); // -Xmx", "+\t\tboolean tooMuch = false;", "+\t\tif (maxMem < (MAX_MEM*0.98) || (tooMuch = maxMem > (MAX_MEM*1.02))) {", "+\t\t\tif (buffer == null) buffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\tbuffer.append(\"\t- \");", "+\t\t\tbuffer.append(tooMuch ? \"too much \" : \"not enough \");", "+\t\t\tbuffer.append(\"max memory allocated (\");", "+\t\t\tbuffer.append(floatFormat.format(((maxMem/1024.0)/1024.0)));", "+\t\t\tbuffer.append(\"M)!\\n\");", "+\t\t\tbuffer.append(\"\t\t=> -Xmx\");", "+\t\t\tbuffer.append(floatFormat.format(((MAX_MEM/1024.0)/1024.0)));", "+\t\t\tbuffer.append(\"M should have been specified.\\n\");", "+\t\t}", "+\t\tlong totalMem = Runtime.getRuntime().totalMemory(); // -Xms", "+\t\ttooMuch = false;", "+\t\tif (totalMem < (TOTAL_MEM*0.98)|| (tooMuch = totalMem > (TOTAL_MEM*1.02))) {", "+\t\t\tif (buffer == null) buffer = new StringBuffer(\"WARNING: Performance tests results may be invalid !!!\\n\");", "+\t\t\tbuffer.append(\"\t- \");", "+\t\t\tbuffer.append(tooMuch ? \"too much \" : \"not enough \");", "+\t\t\tbuffer.append(\"total memory allocated (\");", "+\t\t\tbuffer.append(floatFormat.format(((totalMem/1024.0)/1024.0)));", "+\t\t\tbuffer.append(\"M)!\\n\");", "+\t\t\tbuffer.append(\"\t\t=> -Xms\");", "+\t\t\tbuffer.append(floatFormat.format(((MAX_MEM/1024.0)/1024.0)));", "+\t\t\tbuffer.append(\"M should have been specified.\\n\");", "+\t\t}", "+\t\t", "+\t\t// Display warning message if any", "+\t\tif (buffer != null) {", "+\t\t\tSystem.err.println(buffer.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e43acf1aef4eef1af469721b3fd2c49", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java", "commitBeforeChange": "581702d71a138ac97fe73cfd2b06cc855f39a496", "commitAfterChange": "d47f7e16ee9a06ebea0c1bfa73440fda6af0235f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprotected boolean computeChildren(OpenableElementInfo info) throws JavaModelException", "signatureAfterChange": " \tprotected boolean computeChildren(OpenableElementInfo info, Map newElements) throws JavaModelException", "diff": ["-\tprotected boolean computeChildren(OpenableElementInfo info) throws JavaModelException {", "+\tprotected boolean computeChildren(OpenableElementInfo info, Map newElements) throws JavaModelException {", "+\t\t", "-\t\tcomputeJarChildren((JarPackageFragmentRootInfo) info, vChildren);", "+\t\tfinal int JAVA = 0;", "+\t\tfinal int NON_JAVA = 1;", "+\t\tZipFile jar= null;", "+\t\ttry {", "+\t\t\tjar= getJar();", "+\t", "+\t\t\tHashMap packageFragToTypes= new HashMap();", "+\t", "+\t\t\t// always create the default package", "+\t\t\tpackageFragToTypes.put(IPackageFragment.DEFAULT_PACKAGE_NAME, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t", "+\t\t\tfor (Enumeration e= jar.entries(); e.hasMoreElements();) {", "+\t\t\t\tZipEntry member= (ZipEntry) e.nextElement();", "+\t\t\t\tString entryName= member.getName();", "+\t", "+\t\t\t\tif (member.isDirectory()) {", "+\t\t\t\t\t", "+\t\t\t\t\tint last = entryName.length() - 1;", "+\t\t\t\t\tentryName= entryName.substring(0, last);", "+\t\t\t\t\tentryName= entryName.replace('/', '.');", "+\t", "+\t\t\t\t\t// add the package name & all of its parent packages", "+\t\t\t\t\twhile (true) {", "+\t\t\t\t\t\t// extract the package name", "+\t\t\t\t\t\tif (packageFragToTypes.containsKey(entryName)) break;", "+\t\t\t\t\t\tpackageFragToTypes.put(entryName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif ((last = entryName.lastIndexOf('.')) < 0) break;", "+\t\t\t\t\t\tentryName = entryName.substring(0, last);", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t//store the class file / non-java rsc entry name to be cached in the appropriate package fragment", "+\t\t\t\t\t//zip entries only use '/'", "+\t\t\t\t\tint lastSeparator= entryName.lastIndexOf('/');", "+\t\t\t\t\tString packageName;", "+\t\t\t\t\tString fileName;", "+\t\t\t\t\tif (lastSeparator != -1) { //not in the default package", "+\t\t\t\t\t\tentryName= entryName.replace('/', '.');", "+\t\t\t\t\t\tfileName= entryName.substring(lastSeparator + 1);", "+\t\t\t\t\t\tpackageName= entryName.substring(0, lastSeparator);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfileName = entryName;", "+\t\t\t\t\t\tpackageName =  IPackageFragment.DEFAULT_PACKAGE_NAME;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// add the package name & all of its parent packages", "+\t\t\t\t\tString currentPackageName = packageName;", "+\t\t\t\t\twhile (true) {", "+\t\t\t\t\t\t// extract the package name", "+\t\t\t\t\t\tif (packageFragToTypes.containsKey(currentPackageName)) break;", "+\t\t\t\t\t\tpackageFragToTypes.put(currentPackageName, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tint last;", "+\t\t\t\t\t\tif ((last = currentPackageName.lastIndexOf('.')) < 0) break;", "+\t\t\t\t\t\tcurrentPackageName = currentPackageName.substring(0, last);", "+\t\t\t\t\t}", "+\t\t\t\t\t// add classfile info amongst children", "+\t\t\t\t\tArrayList[] children = (ArrayList[]) packageFragToTypes.get(packageName);", "+\t\t\t\t\tif (Util.isClassFileName(entryName)) {", "+\t\t\t\t\t\tif (children[JAVA] == EMPTY_LIST) children[JAVA] = new ArrayList();", "+\t\t\t\t\t\tchildren[JAVA].add(fileName);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (children[NON_JAVA] == EMPTY_LIST) children[NON_JAVA] = new ArrayList();", "+\t\t\t\t\t\tchildren[NON_JAVA].add(fileName);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t//loop through all of referenced packages, creating package fragments if necessary", "+\t\t\t// and cache the entry names in the infos created for those package fragments", "+\t\t\tIterator packages = packageFragToTypes.keySet().iterator();", "+\t\t\twhile (packages.hasNext()) {", "+\t\t\t\tString packName = (String) packages.next();", "+\t\t\t\t", "+\t\t\t\tArrayList[] entries= (ArrayList[]) packageFragToTypes.get(packName);", "+\t\t\t\tJarPackageFragment packFrag= (JarPackageFragment) getPackageFragment(packName);", "+\t\t\t\tJarPackageFragmentInfo fragInfo= (JarPackageFragmentInfo) packFrag.createElementInfo();", "+\t\t\t\tif (entries[0].size() > 0){", "+\t\t\t\t\tfragInfo.setEntryNames(entries[JAVA]);", "+\t\t\t\t}", "+\t\t\t\tint resLength= entries[NON_JAVA].size();", "+\t\t\t\tif (resLength == 0) {", "+\t\t\t\t\tpackFrag.computeNonJavaResources(NO_STRINGS, fragInfo, jar.getName());", "+\t\t\t\t} else {", "+\t\t\t\t\tString[] resNames= new String[resLength];", "+\t\t\t\t\tentries[NON_JAVA].toArray(resNames);", "+\t\t\t\t\tpackFrag.computeNonJavaResources(resNames, fragInfo, jar.getName());", "+\t\t\t\t}", "+\t\t\t\tpackFrag.computeChildren(fragInfo);", "+\t\t\t\tnewElements.put(packFrag, fragInfo);", "+\t\t\t\tvChildren.add(packFrag);", "+\t\t\t}", "+\t\t} catch (CoreException e) {", "+\t\t\tif (e instanceof JavaModelException) throw (JavaModelException)e;", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tJavaModelManager.getJavaModelManager().closeZipFile(jar);", "+\t\t}", "+", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8eea02a8824be2f77bbbbba057072382", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "a0827b5ed51f9fc68d50a6070897f74217550da1", "commitAfterChange": "266357791826a02f1dd87ad4cdccffd484f96fd9", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "  \tprivate ConstraintFormula pickFromCycle(Set<ConstraintFormula> c)", "signatureAfterChange": "  \tprivate ConstraintFormula pickFromCycle(Set<ConstraintFormula> c)", "diff": ["-\t\tmissingImplementation(\"Breaking a dependency cycle NYI\"); //$NON-NLS-1$", "-\t\treturn null; // never", "+\t\t// Detail from 18.5.2 bullet 6.1", "+", "+\t\t// Note on performance: this implementation could quite possibly be optimized a lot.", "+\t\t// However, we only *very rarely* reach here,", "+\t\t// so nobody should really be affected by the performance penalty paid here.", "+", "+\t\t// Note on spec conformance: the spec seems to require _all_ criteria (i)-(iv) to be fulfilled", "+\t\t// with the sole exception of (iii), which should only be used, if _any_ constraints matching (i) & (ii)", "+\t\t// also fulfill this condition.", "+\t\t// Experiments, however, show that strict application of the above is prone to failing to pick any constraint,", "+\t\t// causing non-termination of the algorithm.", "+\t\t// Since that is not acceptable, I'm *interpreting* the spec to request a search for a constraint", "+\t\t// that \"best matches\" the given conditions.", "+\t\t", "+\t\t// collect all constraints participating in a cycle", "+\t\tHashMap<ConstraintFormula,Set<ConstraintFormula>> dependencies = new HashMap<ConstraintFormula, Set<ConstraintFormula>>();", "+\t\tSet<ConstraintFormula> cycles = new HashSet<ConstraintFormula>();", "+\t\tfor (ConstraintFormula constraint : c) {", "+\t\t\tCollection<InferenceVariable> infVars = constraint.inputVariables(this);", "+\t\t\tfor (ConstraintFormula other : c) {", "+\t\t\t\tif (other == constraint) continue;", "+\t\t\t\tif (dependsOn(infVars, other.outputVariables(this))) {", "+\t\t\t\t\t// found a dependency, record it:", "+\t\t\t\t\tSet<ConstraintFormula> targetSet = dependencies.get(constraint);", "+\t\t\t\t\tif (targetSet == null)", "+\t\t\t\t\t\tdependencies.put(constraint, targetSet = new HashSet<ConstraintFormula>());", "+\t\t\t\t\ttargetSet.add(other);", "+\t\t\t\t\t// look for a cycle:", "+\t\t\t\t\tSet<ConstraintFormula> nodesInCycle = new HashSet<ConstraintFormula>();", "+\t\t\t\t\tif (isReachable(dependencies, other, constraint, new HashSet<ConstraintFormula>(), nodesInCycle)) {", "+\t\t\t\t\t\t// found a cycle, record the involved nodes:", "+\t\t\t\t\t\tcycles.addAll(nodesInCycle);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tSet<ConstraintFormula> outside = new HashSet<ConstraintFormula>(c);", "+\t\toutside.removeAll(cycles);", "+", "+\t\tSet<ConstraintFormula> candidatesII = new HashSet<ConstraintFormula>();", "+\t\t// (i): participates in a cycle:", "+\t\tcandidates: for (ConstraintFormula candidate : cycles) {", "+\t\t\tCollection<InferenceVariable> infVars = candidate.inputVariables(this);", "+\t\t\t// (ii) does not depend on any constraints outside the cycle", "+\t\t\tfor (ConstraintFormula out : outside) {", "+\t\t\t\tif (dependsOn(infVars, out.outputVariables(this)))", "+\t\t\t\t\tcontinue candidates;", "+\t\t\t}", "+\t\t\tcandidatesII.add(candidate);", "+\t\t}", "+\t\tif (candidatesII.isEmpty())", "+\t\t\tcandidatesII = c; // not spec'ed but needed to avoid returning null below, witness: java.util.stream.Collectors", "+\t\t", "+\t\t// tentatively: (iii)  has the form \u27e8Expression \u2192 T\u27e9", "+\t\tSet<ConstraintFormula> candidatesIII = new HashSet<ConstraintFormula>();", "+\t\tfor (ConstraintFormula candidate : candidatesII) {", "+\t\t\tif (candidate instanceof ConstraintExpressionFormula)", "+\t\t\t\tcandidatesIII.add(candidate);", "+\t\t}", "+\t\tif (candidatesIII.isEmpty()) {", "+\t\t\tcandidatesIII = candidatesII; // no constraint fulfills (iii) -> ignore this condition", "+\t\t} else { // candidatesIII contains all relevant constraints \u27e8Expression \u2192 T\u27e9", "+\t\t\t// (iv) contains an expression that appears to the left of the expression", "+\t\t\t// \t\tof every other constraint satisfying the previous three requirements", "+\t\t\t", "+\t\t\t// collect containment info regarding all expressions in candidate constraints:", "+\t\t\t// (a) find minimal enclosing expressions:", "+\t\t\tMap<ConstraintExpressionFormula,ConstraintExpressionFormula> expressionContainedBy = new HashMap<ConstraintExpressionFormula, ConstraintExpressionFormula>();", "+\t\t\tfor (ConstraintFormula one : candidatesIII) {", "+\t\t\t\tConstraintExpressionFormula oneCEF = (ConstraintExpressionFormula) one;", "+\t\t\t\tExpression exprOne = oneCEF.left;", "+\t\t\t\tfor (ConstraintFormula two : candidatesIII) {", "+\t\t\t\t\tif (one == two) continue;", "+\t\t\t\t\tConstraintExpressionFormula twoCEF = (ConstraintExpressionFormula) two;", "+\t\t\t\t\tExpression exprTwo = twoCEF.left;", "+\t\t\t\t\tif (doesExpressionContain(exprOne, exprTwo)) {", "+\t\t\t\t\t\tConstraintExpressionFormula previous = expressionContainedBy.get(two);", "+\t\t\t\t\t\tif (previous == null || doesExpressionContain(previous.left, exprOne)) // only if improving", "+\t\t\t\t\t\t\texpressionContainedBy.put(twoCEF, oneCEF);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// (b) build the tree from the above", "+\t\t\tMap<ConstraintExpressionFormula,Set<ConstraintExpressionFormula>> containmentForest = new HashMap<ConstraintExpressionFormula, Set<ConstraintExpressionFormula>>();", "+\t\t\tfor (Map.Entry<ConstraintExpressionFormula, ConstraintExpressionFormula> parentRelation : expressionContainedBy.entrySet()) {", "+\t\t\t\tConstraintExpressionFormula parent = parentRelation.getValue();", "+\t\t\t\tSet<ConstraintExpressionFormula> children = containmentForest.get(parent);", "+\t\t\t\tif (children == null)", "+\t\t\t\t\tcontainmentForest.put(parent, children = new HashSet<ConstraintExpressionFormula>());", "+\t\t\t\tchildren.add(parentRelation.getKey());", "+\t\t\t}", "+\t\t\t", "+\t\t\t// approximate the spec by searching the largest containment tree:", "+\t\t\tint bestRank = -1;", "+\t\t\tConstraintExpressionFormula candidate = null;", "+\t\t\tfor (ConstraintExpressionFormula parent : containmentForest.keySet()) {", "+\t\t\t\tint rank = rankNode(parent, expressionContainedBy, containmentForest);", "+\t\t\t\tif (rank > bestRank) {", "+\t\t\t\t\tbestRank = rank;", "+\t\t\t\t\tcandidate = parent;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (candidate != null)", "+\t\t\t\treturn candidate;", "+\t\t}", "+\t\t", "+\t\tif (candidatesIII.isEmpty())", "+\t\t\tthrow new IllegalStateException(\"cannot pick constraint from cyclic set\"); //$NON-NLS-1$", "+\t\treturn candidatesIII.iterator().next();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0b4366bd6d8f8fd10c88340b3c02416", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "372799d5bd955eabbf1069fe0bbf8aba8ea8af85", "commitAfterChange": "baf433f0226e8b9036b18a28d560e5a42cb8b949", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations( \t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env)", "signatureAfterChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "diff": ["+\t */", "+\tprivate void runAPTInMixedMode(", "+\t\t\tfinal List<AnnotationProcessorFactory> factories,", "+\t\t\tfinal ProcessorEnvImpl processorEnv)", "+\t{", "+\t\tfinal Map<IFile, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = ", "+\t\t\tnew HashMap<IFile, Set<AnnotationTypeDeclaration>>(_filesToProcess.length * 4/3 + 1);", "+\t\tfinal Map<String, AnnotationTypeDeclaration> annotationDecls = ", "+\t\t\tprocessorEnv.getAllAnnotationTypes(file2AnnotationDecls);\t", "+\t\t", "+\t\tSystem.err.println(file2AnnotationDecls);", "+\t\t", "+\t\tif (annotationDecls.isEmpty())", "+\t\t{", "+\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\ttrace( \"runAPT:  leaving early because annotationDecls is empty\" ); //$NON-NLS-1$", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\t// file based processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> fileFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );", "+\t\t", "+\t\t// batch processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> batchFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );\t\t", "+\t\t", "+\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\tSet<AnnotationTypeDeclaration> annotationTypes = getFactorySupportedAnnotations(factory, annotationDecls);", "+\t\t\tif( annotationTypes != null ){", "+\t\t\t\t", "+\t\t\t\tboolean batch = isBatchFactory(factory);", "+\t\t\t\tMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration> > factory2Annos = ", "+\t\t\t\t\tbatch ? batchFactory2Annos : fileFactory2Annos;", "+\t\t\t\tif( annotationTypes.size() == 0 ){", "+\t\t\t\t\t// this factory is claiming all (remaining) annotations. ", "+\t\t\t\t\tannotationTypes = new HashSet<AnnotationTypeDeclaration>(annotationDecls.values());", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t\tannotationDecls.clear();", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\telse{", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif( annotationDecls.isEmpty() )", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t", "+\t\tif( ! annotationDecls.isEmpty() )", "+\t\t\t; // TODO: (theodora) log unclaimed annotations.", "+\t\t", "+\t\t// Dispatch to the batch process factories first.", "+\t\t// Batch processors only get executed on a full/clean build.", "+\t\tif( !batchFactory2Annos.isEmpty() ){", "+\t\t\tprocessorEnv.setBatchProcessing();", "+\t\t\t// Once we figure out which factory claims what annotation,", "+\t\t\t// the order of the factory doesn't matter.", "+\t\t\t// But in order to make things consists between runs, will ", "+\t\t\t// dispatch base on factory order.", "+\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);", "+\t\t\t\tif( annotationTypes == null ) continue;", "+\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\tfactory.getProcessorFor(annotationTypes, processorEnv);", "+\t\t\t\tif( processor != null ){", "+\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\ttrace( \"runAPT: invoking batch processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\tprocessor.process();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Now, do the file based dispatch", "+\t\tif( !fileFactory2Annos.isEmpty() ){", "+\t\t\tfor( int fileIndex=0, numFiles=_filesToProcess.length; fileIndex<numFiles; fileIndex ++ ){", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesInFile = file2AnnotationDecls.get(_filesToProcess[fileIndex]);", "+\t\t\t\tif( annotationTypesInFile == null || annotationTypesInFile.isEmpty() )", "+\t\t\t\t\tcontinue;", "+\t\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesForFactory = fileFactory2Annos.get(factory);", "+\t\t\t\t\tif( annotationTypesForFactory == null || annotationTypesForFactory.isEmpty() ) ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> intersect = setIntersect(annotationTypesInFile, annotationTypesForFactory);", "+\t\t\t\t\tif( intersect != null && !intersect.isEmpty() ){", "+\t\t\t\t\t\tprocessorEnv.setFileProcessing(_filesToProcess[fileIndex]);", "+\t\t\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\t\t\tfactory.getProcessorFor(intersect, processorEnv);", "+\t\t\t\t\t\tif( processor != null ){", "+\t\t\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\t\t\ttrace( \"runAPT: invoking file-based processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+\t\t                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\t\t\tprocessor.process();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-", "-\tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations(", "-\t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env) {", "-\t\tfinal List<Annotation> instances = new ArrayList<Annotation>();", "-\t\tfinal AnnotationVisitor visitor = new AnnotationVisitor(instances);", "-\t\tastCompilationUnit.accept(visitor);", "-\t\tfinal Map<String, AnnotationTypeDeclaration> decls = new HashMap<String, AnnotationTypeDeclaration>();", "-\t\tfor (int i = 0, size = instances.size(); i < size; i++) {", "-\t\t\tfinal Annotation instance = instances.get(i);", "-\t\t\tfinal ITypeBinding annoType = instance.resolveTypeBinding();", "-\t\t\tif (annoType == null)", "-\t\t\t\tcontinue;", "-\t\t\tfinal TypeDeclarationImpl annoDecl = Factory.createReferenceType(", "-\t\t\t\t\tannoType, env);", "-\t\t\tif (annoDecl.kind() == EclipseMirrorImpl.MirrorKind.TYPE_ANNOTATION)", "-\t\t\t\tdecls.put(annoDecl.getQualifiedName(),", "-\t\t\t\t\t\t(AnnotationTypeDeclaration) annoDecl);", "-\t\t}", "-\t\treturn decls;", "-\t}"]}], "num": 28726}