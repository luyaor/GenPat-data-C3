{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7cc3950a23786250e6096fe320a5361d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3097fe4f1bb3f10895494b1edd7bb80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// Consider the try block and catch block so as to compute the intersection of initializations and\t", "-\t\t// the minimum exit relative depth amongst all of them. Then consider the subroutine, and append its", "-\t\t// initialization to the try/catch ones, if the subroutine completes normally. If the subroutine does not", "-\t\t// complete, then only keep this result for the rest of the analysis", "+\t// Consider the try block and catch block so as to compute the intersection of initializations and\t", "+\t// the minimum exit relative depth amongst all of them. Then consider the subroutine, and append its", "+\t// initialization to the try/catch ones, if the subroutine completes normally. If the subroutine does not", "+\t// complete, then only keep this result for the rest of the analysis", "-\t\t// process the finally block (subroutine) - create a context for the subroutine", "+\t// process the finally block (subroutine) - create a context for the subroutine", "-\t\tthis.preTryInitStateIndex =", "-\t\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "+\tthis.preTryInitStateIndex =", "+\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "-\t\tif (this.anyExceptionVariable != null) {", "-\t\t\tthis.anyExceptionVariable.useFlag = LocalVariableBinding.USED;", "-\t\t}", "-\t\tif (this.returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "-\t\t\tthis.returnAddressVariable.useFlag = LocalVariableBinding.USED;", "-\t\t}", "-\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\t// no finally block -- this is a simplified copy of the else part", "-\t\t\t// process the try block in a context handling the local exceptions.", "-\t\t\tExceptionHandlingFlowContext handlingContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tflowContext,", "-\t\t\t\t\tthis.tryBlock,", "-\t\t\t\t\tthis.caughtExceptionTypes,", "-\t\t\t\t\tthis.scope,", "-\t\t\t\t\tflowInfo.unconditionalInits());", "-\t", "-\t\t\tFlowInfo tryInfo;", "-\t\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\t\ttryInfo = flowInfo;", "-\t\t\t} else {", "-\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\t\tif ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\tthis.bits |= IsTryBlockExiting;", "-\t\t\t}", "-\t", "-\t\t\t// check unreachable catch blocks", "-\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-\t", "-\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "-\t\t\tif (this.catchArguments != null) {", "-\t\t\t\tint catchCount;", "-\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "-\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "-\t\t\t\t\tFlowInfo catchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t\t// remove null info to protect point of ", "-\t\t\t\t\t\t\t\t// exception null info ", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "-\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "-\t", "-\t\t\t\t\t// catch var is always set", "-\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t\t/*", "-\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\t\tthe try block that need to be detected , e.g. ", "-\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t\t*/", "-\t\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tflowContext,", "-\t\t\t\t\t\t\tcatchInfo);", "-\t\t\t\t\tthis.catchExits[i] = ", "-\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "-\t\t\treturn tryInfo;", "+\tif (this.anyExceptionVariable != null) {", "+\t\tthis.anyExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\tif (this.returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "+\t\tthis.returnAddressVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\tif (this.subRoutineStartLabel == null) {", "+\t\t// no finally block -- this is a simplified copy of the else part", "+\t\t// process the try block in a context handling the local exceptions.", "+\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\tflowContext,", "+\t\t\t\tthis,", "+\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\tthis.scope,", "+\t\t\t\tflowInfo.unconditionalInits());", "+", "+\t\tFlowInfo tryInfo;", "+\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\ttryInfo = flowInfo;", "-\t\t\tInsideSubRoutineFlowContext insideSubContext;", "-\t\t\tFinallyFlowContext finallyContext;", "-\t\t\tUnconditionalFlowInfo subInfo;", "-\t\t\t// analyse finally block first", "-\t\t\tinsideSubContext = new InsideSubRoutineFlowContext(flowContext, this);", "-\t\t\tsubInfo = ", "-\t\t\t\tthis.finallyBlock", "-\t\t\t\t\t.analyseCode(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, this.finallyBlock),", "-\t\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t.unconditionalInits();", "-\t\t\tif (subInfo == FlowInfo.DEAD_END) {", "-\t\t\t\tthis.bits |= IsSubRoutineEscaping;", "-\t\t\t\tthis.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);", "-\t\t\t}", "-\t\t\tthis.subRoutineInits = subInfo;", "-\t\t\t// process the try block in a context handling the local exceptions.", "-\t\t\tExceptionHandlingFlowContext handlingContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tinsideSubContext,", "-\t\t\t\t\tthis.tryBlock,", "-\t\t\t\t\tthis.caughtExceptionTypes,", "-\t\t\t\t\tthis.scope,", "-\t\t\t\t\tflowInfo.unconditionalInits());", "-\t", "-\t\t\tFlowInfo tryInfo;", "-\t\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\t\ttryInfo = flowInfo;", "-\t\t\t} else {", "-\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\t\tif ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\tthis.bits |= IsTryBlockExiting;", "-\t\t\t}", "-\t", "-\t\t\t// check unreachable catch blocks", "-\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-\t", "-\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "-\t\t\tif (this.catchArguments != null) {", "-\t\t\t\tint catchCount;", "-\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "-\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "-\t\t\t\t\tFlowInfo catchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t\t// remove null info to protect point of ", "-\t\t\t\t\t\t\t\t// exception null info ", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "-\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "-\t", "-\t\t\t\t\t// catch var is always set", "-\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t\t/*", "-\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\t\tthe try block that need to be detected , e.g. ", "-\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t\t*/", "-\t\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tinsideSubContext,", "-\t\t\t\t\t\t\tcatchInfo);", "-\t\t\t\t\tthis.catchExits[i] = ", "-\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "-\t\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "-\t\t\tfinallyContext.complainOnDeferredChecks( ", "-\t\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "-\t\t\t\t\t? flowInfo.unconditionalCopy().", "-\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "-\t\t\t\t\t\t\t// exited at any point", "+\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tif ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\tthis.bits |= ASTNode.IsTryBlockExiting;", "+\t\t}", "+", "+\t\t// check unreachable catch blocks", "+\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+", "+\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\tif (this.catchArguments != null) {", "+\t\t\tint catchCount;", "+\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\tinsideSubContext.initsOnReturn)", "-\t\t\t\t\t: insideSubContext.initsOnReturn,", "-\t\t\t\tcurrentScope);", "-\t\t\t", "-\t\t\tif (subInfo == FlowInfo.DEAD_END) {", "-\t\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "-\t\t\t\treturn subInfo;", "-\t\t\t} else {", "-\t\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "-\t\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\t\t\treturn mergedInfo;", "+\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+", "+\t\t\t\t// catch var is always set", "+\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t/*", "+\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t*/", "+\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t}", "+\t\t\t\tcatchInfo =", "+\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\tflowContext,", "+\t\t\t\t\t\tcatchInfo);", "+\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t}", "+\t\tthis.mergedInitStateIndex =", "+\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "+\t\treturn tryInfo;", "+\t} else {", "+\t\tInsideSubRoutineFlowContext insideSubContext;", "+\t\tFinallyFlowContext finallyContext;", "+\t\tUnconditionalFlowInfo subInfo;", "+\t\t// analyse finally block first", "+\t\tinsideSubContext = new InsideSubRoutineFlowContext(flowContext, this);", "+", "+\t\tsubInfo = ", "+\t\t\tthis.finallyBlock", "+\t\t\t\t.analyseCode(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, this.finallyBlock),", "+\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t.unconditionalInits();", "+\t\tif (subInfo == FlowInfo.DEAD_END) {", "+\t\t\tthis.bits |= ASTNode.IsSubRoutineEscaping;", "+\t\t\tthis.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);", "+\t\t}", "+\t\tthis.subRoutineInits = subInfo;", "+\t\t// process the try block in a context handling the local exceptions.", "+\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\tinsideSubContext,", "+\t\t\t\tthis,", "+\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\tthis.scope,", "+\t\t\t\tflowInfo.unconditionalInits());", "+", "+\t\tFlowInfo tryInfo;", "+\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\ttryInfo = flowInfo;", "+\t\t} else {", "+\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tif ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\tthis.bits |= ASTNode.IsTryBlockExiting;", "+\t\t}", "+", "+\t\t// check unreachable catch blocks", "+\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+", "+\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\tif (this.catchArguments != null) {", "+\t\t\tint catchCount;", "+\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+", "+\t\t\t\t// catch var is always set", "+\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t/*", "+\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t*/", "+\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t}", "+\t\t\t\tcatchInfo =", "+\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\tinsideSubContext,", "+\t\t\t\t\t\tcatchInfo);", "+\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t}", "+\t\t}", "+\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "+\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "+\t\tfinallyContext.complainOnDeferredChecks( ", "+\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "+\t\t\t\t? flowInfo.unconditionalCopy().", "+\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "+\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "+\t\t\t\t\t\t// exited at any point", "+\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\tinsideSubContext.initsOnReturn)", "+\t\t\t\t: insideSubContext.initsOnReturn,", "+\t\t\tcurrentScope);", "+\t\t", "+\t\tif (subInfo == FlowInfo.DEAD_END) {", "+\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "+\t\t\treturn subInfo;", "+\t\t} else {", "+\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "+\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "+\t\t\treturn mergedInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e4365e0c9de814f88bb5e47b240c9ba8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tpublic TypeBinding checkFieldAccess(BlockScope scope)", "signatureAfterChange": "  public TypeBinding checkFieldAccess(BlockScope scope)", "diff": ["-\t", "-\tpublic TypeBinding checkFieldAccess(BlockScope scope) {", "-\t", "-\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t", "-\t\tbits &= ~RestrictiveFlagMASK; // clear bits", "-\t\tbits |= Binding.FIELD;", "-\t\tMethodScope methodScope = scope.methodScope();", "-\t\tboolean isStatic = fieldBinding.isStatic();", "-\t\tif (!isStatic) {", "-\t\t\t// must check for the static status....", "-\t\t\tif (methodScope.isStatic) {", "-\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, fieldBinding);", "-\t\t\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\treturn fieldBinding.type;", "-\t\t\t}", "-\t\t}", "-\t\tthis.constant = fieldBinding.constant();", "-\t", "-\t\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssigned) !=0))", "-\t\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "-\t", "-\t\tif ((this.bits & IsStrictlyAssigned) == 0", "-\t\t\t\t&& methodScope.enclosingSourceType() == fieldBinding.original().declaringClass", "-\t\t\t\t&& methodScope.lastVisibleFieldID >= 0", "-\t\t\t\t&& fieldBinding.id >= methodScope.lastVisibleFieldID", "-\t\t\t\t&& (!fieldBinding.isStatic() || methodScope.isStatic)) {", "-\t\t\tscope.problemReporter().forwardReference(this, 0, methodScope.enclosingSourceType());", "-\t\t\tthis.bits |= ASTNode.IgnoreNoEffectAssignCheck;", "-\t\t}", "-\t\treturn fieldBinding.type;", "-\t", "+", "+public TypeBinding checkFieldAccess(BlockScope scope) {", "+\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t", "+\tthis.bits &= ~ASTNode.RestrictiveFlagMASK; // clear bits", "+\tthis.bits |= Binding.FIELD;", "+\tMethodScope methodScope = scope.methodScope();", "+\tboolean isStatic = fieldBinding.isStatic();", "+\tif (!isStatic) {", "+\t\t// must check for the static status....", "+\t\tif (methodScope.isStatic) {", "+\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, fieldBinding);", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\treturn fieldBinding.type;", "+\tthis.constant = fieldBinding.constant();", "+", "+\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & ASTNode.IsStrictlyAssigned) !=0))", "+\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "+", "+\tif ((this.bits & ASTNode.IsStrictlyAssigned) == 0", "+\t\t\t&& methodScope.enclosingSourceType() == fieldBinding.original().declaringClass", "+\t\t\t&& methodScope.lastVisibleFieldID >= 0", "+\t\t\t&& fieldBinding.id >= methodScope.lastVisibleFieldID", "+\t\t\t&& (!fieldBinding.isStatic() || methodScope.isStatic)) {", "+\t\tscope.problemReporter().forwardReference(this, 0, methodScope.enclosingSourceType());", "+\t\tthis.bits |= ASTNode.IgnoreNoEffectAssignCheck;", "+\t}", "+\treturn fieldBinding.type;", "+", "+}"]}], "num": 61549}