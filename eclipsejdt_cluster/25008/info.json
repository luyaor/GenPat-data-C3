{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "657d2176e35b05a9dea7102b252974c2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "08deddbd2096df88290441f77583eedc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java", "commitBeforeChange": "b12492ad0eb83de9816def47b0f6dea2ec7ff67f", "commitAfterChange": "0deabbafa4ad0926b565767fe8d2a589d68558ed", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 22, "signatureBeforeChange": " public void executeNestedOperation(JavaModelOperation operation, int subWorkAmount) throws JavaModelException", "signatureAfterChange": " \tpublic void executeNestedOperation(JavaModelOperation operation, int subWorkAmount) throws JavaModelException", "diff": ["- */", "-public void executeNestedOperation(JavaModelOperation operation, int subWorkAmount) throws JavaModelException {", "-\tIProgressMonitor subProgressMonitor = getSubProgressMonitor(subWorkAmount);", "-\t// fix for 1FW7IKC, part (1)", "-\ttry {", "-\t\toperation.setNested(true);", "-\t\toperation.run(subProgressMonitor);", "-\t\tif (operation.hasModifiedResource()) {", "-\t\t\tthis.hasModifiedResource = true;", "-\t\t//accumulate the nested operation deltas", "-\t\tif (operation.fDeltas != null) {", "-\t\t\tfor (int i = 0; i < operation.fDeltas.length; i++) {", "-\t\t\t\taddDelta(operation.fDeltas[i]);", "-\t\t\t}", "-\t} catch (CoreException ce) {", "-\t\tif (ce instanceof JavaModelException) {", "-\t\t\tthrow (JavaModelException)ce;", "-\t\t} else {", "-\t\t\t// translate the core exception to a java model exception", "-\t\t\tif (ce.getStatus().getCode() == IResourceStatus.OPERATION_FAILED) {", "-\t\t\t\tThrowable e = ce.getStatus().getException();", "-\t\t\t\tif (e instanceof JavaModelException) {", "-\t\t\t\t\tthrow (JavaModelException) e;", "-\t\t\tthrow new JavaModelException(ce);", "-}", "+\t */", "+\tpublic void executeNestedOperation(JavaModelOperation operation, int subWorkAmount) throws JavaModelException {", "+\t\tIProgressMonitor subProgressMonitor = getSubProgressMonitor(subWorkAmount);", "+\t\t// fix for 1FW7IKC, part (1)", "+\t\ttry {", "+\t\t\toperation.setNested(true);", "+\t\t\toperation.run(subProgressMonitor);", "+\t\t} catch (CoreException ce) {", "+\t\t\tif (ce instanceof JavaModelException) {", "+\t\t\t\tthrow (JavaModelException)ce;", "+\t\t\t} else {", "+\t\t\t\t// translate the core exception to a java model exception", "+\t\t\t\tif (ce.getStatus().getCode() == IResourceStatus.OPERATION_FAILED) {", "+\t\t\t\t\tThrowable e = ce.getStatus().getException();", "+\t\t\t\t\tif (e instanceof JavaModelException) {", "+\t\t\t\t\t\tthrow (JavaModelException) e;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tthrow new JavaModelException(ce);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11212058b90c43b3e73ed18b350c3f78", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "572021b99f292f39a76e81c2ea834ac6a839b00b", "commitAfterChange": "727d8ca46d64642ad4f629f81ba37e76e7ae8c85", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate void adaptEdits()", "signatureAfterChange": " \tprivate void adaptEdits()", "diff": ["-", "-    \t// Set invalid all edits outside the region", "-\t\tif (currentEdit != -1) {", "-\t\t\tint length = sortedEdits.length;", "-\t    \tfor (int e=currentEdit; e<length; e++) {", "-\t    \t\tsortedEdits[e].valid = false;", "-\t    \t}", "-    \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "169b37ecdab84063aa95b4b4f5482f02", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "9713cc0fc86fbe0881ff90c5290328149c35cbdc", "commitAfterChange": "236485921f70a82e4283431ca8763bf21e25e459", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, InferenceContext inferenceContext)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, InferenceContext inferenceContext)", "diff": ["-", "-\t\tcomputeSubstitutes: {", "-\t\t    // infer from expected return type", "-\t\t\tif (inferenceContext.expectedType != null) {", "-\t\t\t    this.returnType.collectSubstitutes(scope, inferenceContext.expectedType, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t    if (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "-\t\t\t}", "-\t\t    // infer from bounds of type parameters", "-\t\t\tfor (int i = 0; i < varLength; i++) {", "-\t\t\t\tTypeVariableBinding originalVariable = originalVariables[i];", "-\t\t\t\tTypeBinding argument = this.typeArguments[i];", "-\t\t\t\tboolean argAlreadyInferred = argument != originalVariable;", "-\t\t\t\tif (originalVariable.firstBound == originalVariable.superclass) {", "-\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);", "-\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "-\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "-\t\t\t\t\t// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)", "-\t\t\t\t\t//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String", "-\t\t\t\t\tif (argAlreadyInferred) {", "-\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tfor (int j = 0, max = originalVariable.superInterfaces.length; j < max; j++) {", "-\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);", "-\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "-\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "-\t\t\t\t\tif (argAlreadyInferred) {", "-\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (inferenceContext.status == InferenceContext.RAW_SUBSTITUTION) {", "-\t\t    \t// raw generic method inferred", "-\t\t    \tthis.isRaw = true;", "-\t\t\t\tthis.isUnchecked = false;", "-\t\t    \tfor (int i = 0; i < varLength; i++) {", "-\t\t    \t\tthis.typeArguments[i] = originalVariables[i].upperBound();", "-\t\t    \t}", "-\t\t    \tbreak computeSubstitutes;", "-\t\t\t}", "-\t\t\tif (!resolveSubstituteConstraints(scope, originalVariables, inferenceContext, true/*consider Ti<:Uk*/))", "-\t\t\t\treturn null; // incompatible", "-\t\t\t// this.typeArguments = substitutes; - no op since side effects got performed during #resolveSubstituteConstraints", "-\t    \tfor (int i = 0; i < varLength; i++) {", "-\t    \t\tTypeBinding substitute = inferenceContext.substitutes[i];", "-\t    \t\tif (substitute != null) {", "-\t    \t\t\tthis.typeArguments[i] = inferenceContext.substitutes[i];", "-\t    \t\t} else {", "-\t    \t\t\t// remaining unresolved variable are considered to be Object (or their bound actually)", "-\t\t    \t\tthis.typeArguments[i] = originalVariables[i].upperBound();", "-\t\t    \t}", "-\t    \t}", "+\t    // infer from expected return type", "+\t\tif (inferenceContext.expectedType != null) {", "+\t\t    this.returnType.collectSubstitutes(scope, inferenceContext.expectedType, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t    if (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "+\t    // infer from bounds of type parameters", "+\t\tfor (int i = 0; i < varLength; i++) {", "+\t\t\tTypeVariableBinding originalVariable = originalVariables[i];", "+\t\t\tTypeBinding argument = this.typeArguments[i];", "+\t\t\tboolean argAlreadyInferred = argument != originalVariable;", "+\t\t\tif (originalVariable.firstBound == originalVariable.superclass) {", "+\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);", "+\t\t\t\targument.collectSubstitutes(scope, substitutedBound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "+\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)", "+\t\t\t\t//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String", "+\t\t\t\tif (argAlreadyInferred) {", "+\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tfor (int j = 0, max = originalVariable.superInterfaces.length; j < max; j++) {", "+\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);", "+\t\t\t\targument.collectSubstitutes(scope, substitutedBound, inferenceContext, TypeConstants.CONSTRAINT_SUPER);", "+\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "+\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\tif (argAlreadyInferred) {", "+\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, inferenceContext, TypeConstants.CONSTRAINT_EXTENDS);", "+\t\t\t\t\tif (inferenceContext.status == InferenceContext.FAILED) return null; // impossible substitution", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (!resolveSubstituteConstraints(scope, originalVariables, inferenceContext, true/*consider Ti<:Uk*/))", "+\t\t\treturn null; // incompatible", "+\t\t// this.typeArguments = substitutes; - no op since side effects got performed during #resolveSubstituteConstraints", "+    \tfor (int i = 0; i < varLength; i++) {", "+    \t\tTypeBinding substitute = inferenceContext.substitutes[i];", "+    \t\tif (substitute != null) {", "+    \t\t\tthis.typeArguments[i] = inferenceContext.substitutes[i];", "+    \t\t} else {", "+    \t\t\t// remaining unresolved variable are considered to be Object (or their bound actually)", "+\t    \t\tthis.typeArguments[i] = originalVariables[i].upperBound();", "+\t    \t}", "+    \t}", "-\t\tthis.typeArguments = Scope.substitute(this, this.typeArguments);", "-\t\t// adjust method types to reflect latest inference", "+    \tthis.typeArguments = Scope.substitute(this, this.typeArguments);", "+", "+    \t// adjust method types to reflect latest inference"]}], "num": 25008}