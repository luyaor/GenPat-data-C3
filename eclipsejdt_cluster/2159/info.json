{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dd47613908ba8d4e09d8848320f1aa56", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0194d061c4bff37ecea32839adf6e63f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "signatureAfterChange": "  public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "diff": ["-\tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {", "- \t\tif (match == castType) {", "-\t\t\tif (!isNarrowing && match == this.resolvedType.leafComponentType()) { // do not tag as unnecessary when recursing through upper bounds", "-\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "-\t\t\treturn true;", "-\t\t}", "-\t\tif (match != null) {", "-\t\t\tif (isNarrowing", "-\t\t\t\t\t? match.isProvablyDistinct(expressionType)", "-\t\t\t\t\t: castType.isProvablyDistinct(match)) {", "-\t\t\t\treturn false;", "-\t\tswitch (castType.kind()) {", "-\t\t\tcase Binding.PARAMETERIZED_TYPE :", "-\t\t\t\tif (castType.isBoundParameterizedType()) {", "-\t\t\t\t\tif (match == null) { // unrelated types", "-\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t\tswitch (match.kind()) {", "-\t\t\t\t\t\tcase Binding.PARAMETERIZED_TYPE :", "-\t\t\t\t\t\t\tif (isNarrowing) {", "-\t\t\t\t\t\t\t\t// [JLS 5.5] T <: S", "-\t\t\t\t\t\t\t\tif (expressionType.isRawType() || !expressionType.isEquivalentTo(match)) {", "-\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// [JLS 5.5] S has no subtype X != T, such that |X| == |T|", "-\t\t\t\t\t\t\t\tTypeBinding genericCastType = castType.erasure(); // jump to generic type", "-\t\t\t\t\t\t\t\tTypeBinding genericMatch = genericCastType.findSuperTypeOriginatingFrom(expressionType);", "-\t\t\t\t\t\t\t\tif (genericMatch == match) {", "-\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t// if I2<T,U> extends I1<T>, then cast from I1<T> to I2<T,U> is unchecked", "-\t\t\t\t\t\t\t\t\tParameterizedTypeBinding paramCastType = (ParameterizedTypeBinding) castType;", "-\t\t\t\t\t\t\t\t\tParameterizedTypeBinding paramMatch = (ParameterizedTypeBinding) match;", "-\t\t\t\t\t\t\t\t\t// easy case if less parameters on match", "-\t\t\t\t\t\t\t\t\tTypeBinding[] castArguments = paramCastType.arguments;", "-\t\t\t\t\t\t\t\t\tint length = castArguments.length;", "-\t\t\t\t\t\t\t\t\tif (length > paramMatch.arguments.length) {", "-\t\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\t\t} else if ((paramCastType.tagBits & (TagBits.HasDirectWildcard|TagBits.HasTypeVariable)) != 0) {", "-\t\t\t\t\t\t\t\t\t\t// verify alternate cast type, substituting different type arguments", "-\t\t\t\t\t\t\t\t\t\tLookupEnvironment environment = scope.environment();", "-\t\t\t\t\t\t\t\t\t\tnextAlternateArgument: for (int i = 0; i < length; i++) {", "-\t\t\t\t\t\t\t\t\t\t\tswitch (castArguments[i].kind()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "-\t\t\t\t\t\t\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "-\t\t\t\t\t\t\t\t\t\t\t\t\tbreak; // check substituting with other", "-\t\t\t\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextAlternateArgument; // no alternative possible", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\tTypeBinding[] alternateArguments;", "-\t\t\t\t\t\t\t\t\t\t\t// need to clone for each iteration to avoid env paramtype cache interference", "-\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(paramCastType.arguments, 0, alternateArguments = new TypeBinding[length], 0, length);", "-\t\t\t\t\t\t\t\t\t\t\talternateArguments[i] = scope.getJavaLangObject();", "-\t\t\t\t\t\t\t\t\t\t\tParameterizedTypeBinding alternateCastType = environment.createParameterizedType((ReferenceBinding)genericCastType, alternateArguments, castType.enclosingType());", "-\t\t\t\t\t\t\t\t\t\t\tif (alternateCastType.findSuperTypeOriginatingFrom(expressionType) == match) {", "-\t\t\t\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t// [JLS 5.5] T >: S", "-\t\t\t\t\t\t\t\tif (!match.isEquivalentTo(castType)) {", "-\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Binding.RAW_TYPE :", "-\t\t\t\t\t\t\tthis.bits |= UnsafeCast; // upcast since castType is known to be bound paramType", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\tdefault :", "-\t\t\t\t\t\t\tif (isNarrowing){", "-\t\t\t\t\t\t\t\t// match is not parameterized or raw, then any other subtype of match will erase  to |T|", "-\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase Binding.ARRAY_TYPE :", "-\t\t\t\tTypeBinding leafType = castType.leafComponentType();", "-\t\t\t\tif (isNarrowing && (leafType.isBoundParameterizedType() || leafType.isTypeVariable())) {", "-\t\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase Binding.TYPE_PARAMETER :", "-\t\t\t\tthis.bits |= UnsafeCast;", "-\t\t\t\treturn true;\t\t\t\t", "+", "+public boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing) {", "+\tif (match == castType) {", "-\t}\t", "+\t}", "+\tif (match != null) {", "+\t\tif (isNarrowing", "+\t\t\t\t? match.isProvablyDistinct(expressionType)", "+\t\t\t\t: castType.isProvablyDistinct(match)) {", "+\t\t\treturn false;", "+\t\t}", "+\t}", "+\tswitch (castType.kind()) {", "+\t\tcase Binding.PARAMETERIZED_TYPE :", "+\t\t\tif (castType.isBoundParameterizedType()) {", "+\t\t\t\tif (match == null) { // unrelated types", "+\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\treturn true;", "+\t\t\t\tswitch (match.kind()) {", "+\t\t\t\t\tcase Binding.PARAMETERIZED_TYPE :", "+\t\t\t\t\t\tif (isNarrowing) {", "+\t\t\t\t\t\t\t// [JLS 5.5] T <: S", "+\t\t\t\t\t\t\tif (expressionType.isRawType() || !expressionType.isEquivalentTo(match)) {", "+\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// [JLS 5.5] S has no subtype X != T, such that |X| == |T|", "+\t\t\t\t\t\t\tTypeBinding genericCastType = castType.erasure(); // jump to generic type", "+\t\t\t\t\t\t\tTypeBinding genericMatch = genericCastType.findSuperTypeOriginatingFrom(expressionType);", "+\t\t\t\t\t\t\tif (genericMatch == match) {", "+\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// if I2<T,U> extends I1<T>, then cast from I1<T> to I2<T,U> is unchecked", "+\t\t\t\t\t\t\t\tParameterizedTypeBinding paramCastType = (ParameterizedTypeBinding) castType;", "+\t\t\t\t\t\t\t\tParameterizedTypeBinding paramMatch = (ParameterizedTypeBinding) match;", "+\t\t\t\t\t\t\t\t// easy case if less parameters on match", "+\t\t\t\t\t\t\t\tTypeBinding[] castArguments = paramCastType.arguments;", "+\t\t\t\t\t\t\t\tint length = castArguments.length;", "+\t\t\t\t\t\t\t\tif (length > paramMatch.arguments.length) {", "+\t\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t\t} else if ((paramCastType.tagBits & (TagBits.HasDirectWildcard|TagBits.HasTypeVariable)) != 0) {", "+\t\t\t\t\t\t\t\t\t// verify alternate cast type, substituting different type arguments", "+\t\t\t\t\t\t\t\t\tLookupEnvironment environment = scope.environment();", "+\t\t\t\t\t\t\t\t\tnextAlternateArgument: for (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tswitch (castArguments[i].kind()) {", "+\t\t\t\t\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak; // check substituting with other", "+\t\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextAlternateArgument; // no alternative possible", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tTypeBinding[] alternateArguments;", "+\t\t\t\t\t\t\t\t\t\t// need to clone for each iteration to avoid env paramtype cache interference", "+\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(paramCastType.arguments, 0, alternateArguments = new TypeBinding[length], 0, length);", "+\t\t\t\t\t\t\t\t\t\talternateArguments[i] = scope.getJavaLangObject();", "+\t\t\t\t\t\t\t\t\t\tParameterizedTypeBinding alternateCastType = environment.createParameterizedType((ReferenceBinding)genericCastType, alternateArguments, castType.enclosingType());", "+\t\t\t\t\t\t\t\t\t\tif (alternateCastType.findSuperTypeOriginatingFrom(expressionType) == match) {", "+\t\t\t\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// [JLS 5.5] T >: S", "+\t\t\t\t\t\t\tif (!match.isEquivalentTo(castType)) {", "+\t\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Binding.RAW_TYPE :", "+\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast; // upcast since castType is known to be bound paramType", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tif (isNarrowing){", "+\t\t\t\t\t\t\t// match is not parameterized or raw, then any other subtype of match will erase  to |T|", "+\t\t\t\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\tbreak;", "+\t\tcase Binding.ARRAY_TYPE :", "+\t\t\tTypeBinding leafType = castType.leafComponentType();", "+\t\t\tif (isNarrowing && (leafType.isBoundParameterizedType() || leafType.isTypeVariable())) {", "+\t\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\tthis.bits |= ASTNode.UnsafeCast;", "+\t\t\treturn true;\t\t\t\t", "+\t}", "+\tif (!isNarrowing && match == this.resolvedType.leafComponentType()) { // do not tag as unnecessary when recursing through upper bounds", "+\t\ttagAsUnnecessaryCast(scope, castType);", "+\t}", "+\treturn true;", "+}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3bd999f0b6d20c1cdd9586477ad277d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "80c078ddcf769ceb84a30bdd1354fc49a196e760", "commitAfterChange": "1e3ac51cb3938f7e9fd57cd2551e590148671265", "methodNumberBeforeChange": 111, "methodNumberAfterChange": 111, "signatureBeforeChange": "\r public void invalidMethod(MessageSend messageSend, MethodBinding method)", "signatureAfterChange": "\r public void invalidMethod(MessageSend messageSend, MethodBinding method)", "diff": ["-\tint flag = UndefinedMethod; //default...\r", "+\tint flag = IProblem.UndefinedMethod; //default...\r", "-\t\t\tflag = UndefinedMethod;\r", "+\t\t\tflag = IProblem.UndefinedMethod;\r", "-\t\t\tflag = NotVisibleMethod;\r", "+\t\t\tflag = IProblem.NotVisibleMethod;\r", "-\t\t\tflag = AmbiguousMethod;\r", "+\t\t\tflag = IProblem.AmbiguousMethod;\r", "-\t\t\tflag = InheritedMethodHidesEnclosingName;\r", "+\t\t\tflag = IProblem.InheritedMethodHidesEnclosingName;\r", "-\t\t\tflag = InstanceMethodDuringConstructorInvocation;\r", "+\t\t\tflag = IProblem.InstanceMethodDuringConstructorInvocation;\r", "-\t\t\tflag = StaticMethodRequested;\r", "+\t\t\tflag = IProblem.StaticMethodRequested;\r", "-\tif (flag == UndefinedMethod) {\r", "+\tif (flag == IProblem.UndefinedMethod) {\r", "-\t\t\t\t\tParameterMismatch,\r", "+\t\t\t\t\tIProblem.ParameterMismatch,\r"]}], "num": 2159}