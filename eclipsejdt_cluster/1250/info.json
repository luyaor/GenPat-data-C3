{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b26e9c1238a3c1b9906703483d13ffc0", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e7ae383fdf99681bf81280629f79098", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java", "commitBeforeChange": "4694cc0005ea017b2601e02ddce206da50b47138", "commitAfterChange": "6b1cf9545e376e005c20d9c5709294b65e338780", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\t", "+\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=320463", "+\t\t   https://bugs.eclipse.org/bugs/show_bug.cgi?id=312076", "+\t\t   JLS3 15.8.2 forbids the type named in the class literal expression from being a parameterized type.", "+\t\t   And the grammar in 18.1 disallows (where X and Y are some concrete types) constructs of the form", "+\t\t   Outer<X>.class, Outer<X>.Inner.class, Outer.Inner<X>.class, Outer<X>.Inner<Y>.class etc.", "+\t\t   Corollary wise, we should resolve the type of the class literal expression to be a raw type as", "+\t\t   class literals exist only for the raw underlying type. ", "+\t\t */", "+\t\tthis.targetType = scope.environment().convertToRawType(this.targetType, true /* force conversion of enclosing types*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c5fe475e43beecd3c878de77e552b76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b89ad18e17834e64930a830c92b5e2241f9a8b44", "commitAfterChange": "d9605208e25375e966739effbd053a969138c830", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " boolean detectNameClash(MethodBinding current, MethodBinding inherited, boolean treatAsSynthetic)", "signatureAfterChange": " boolean detectNameClash(MethodBinding current, MethodBinding inherited, boolean treatAsSynthetic)", "diff": ["+\tint severity = ProblemSeverities.Error;", "+\tif (this.environment.globalOptions.complianceLevel == ClassFileConstants.JDK1_6) {", "+\t\t// for 1.6 return types also need to be checked", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317719", "+\t\tif (current.returnType.erasure() != original.returnType.erasure())", "+\t\t\tseverity = ProblemSeverities.Warning;", "+\t}", "-\tproblemReporter(current).methodNameClash(current, inherited.declaringClass.isRawType() ? inherited : original);", "+\tproblemReporter(current).methodNameClash(current, inherited.declaringClass.isRawType() ? inherited : original, severity);", "+\tif (severity == ProblemSeverities.Warning) return false;"]}], "num": 1250}