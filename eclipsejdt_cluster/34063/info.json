{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "31871a9316bf835b6fb83eb15557171c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4274b91a705ededd16adb67f4a0618ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "-\t\t\t\t\tboolean isExactMatch = true;", "-\t\t\t\t\t// retrieve an exact visible match (if possible)", "-\t\t\t\t\t// compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type", "-\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t(foundMethod == null)", "-\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\t\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\t\t\t\t\tisExactMatch = false;", "-\t\t\t\t\t\tmethodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (methodBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\tif (methodBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible) {", "-\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\tboolean isExactMatch = true;", "+\t\t\t\t\t\t// retrieve an exact visible match (if possible)", "+\t\t\t\t\t\t// compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type", "+\t\t\t\t\t\tMethodBinding methodBinding =", "+\t\t\t\t\t\t\t(foundMethod == null)", "+\t\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "+\t\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\tif (methodBinding == null) {", "+\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\t\t\t\t\tisExactMatch = false;", "+\t\t\t\t\t\t\tmethodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "-\t\t\t\t\t\t\tif (!isExactMatch) {", "-\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, NotFound);", "-\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "-\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "-\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != NoMethods", "-\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "-\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\tif (methodBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\tif (methodBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible) {", "+\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "-\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\tselector,", "+\t\t\t\t\t\t\t\t\targumentTypes,", "+\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\t\t\t\t\tif (depth > 0) {", "-\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "+\t\t\t\t\t\t\tMethodBinding insideProblem = null;", "+\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\tif (!isExactMatch) {", "+\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, NotFound);", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "+\t\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "+\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t", "+\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != NoMethods", "+\t\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "+\t\t\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "+\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "+\t\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\tif (fuzzyProblem == null)", "-\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "+\t", "+\t\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "+\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "+\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "+\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\tif (fuzzyProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\tinsideTypeAnnotation = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67f58eb000dad92c1ba828f495c6b84c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java", "commitBeforeChange": "623caf65031b4d3defbd380cba91f808dab32695", "commitAfterChange": "e2004ef45b0415339d4919288b26a41edf5dcc65", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r public TypeDeclaration updatedTypeDeclaration()", "signatureAfterChange": "\r public TypeDeclaration updatedTypeDeclaration()", "diff": ["-\t\t\tfields[fieldCount - 1].fieldDeclaration.declarationSourceEnd = bodyEnd();\r", "+\t\t\tint temp = bodyEnd();\r", "+\t\t\tfields[fieldCount - 1].fieldDeclaration.declarationSourceEnd = temp;\r", "+\t\t\tfields[fieldCount - 1].fieldDeclaration.declarationEnd = temp;\r"]}], "num": 34063}