{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6923275e688a56abc5a99d025bbb63a1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b8989b3cbdd769cb8f256bf8b73211a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+\tif (this.primaryExceptionVariable != null) {", "+\t\tthis.primaryExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\tif (this.caughtThrowableVariable != null) {", "+\t\tthis.caughtThrowableVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\t\t\t\tthis.caughtExceptionsCatchBlocks,", "+\t\t\t\tthis.catchArguments,", "+\t\tfor (int i = 0, max = this.resources.length; i < max; i++) {", "+\t\t\tflowInfo = this.resources[i].analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.resources[i].binding.useFlag = LocalVariableBinding.USED; // Is implicitly used anyways.", "+\t\t\tTypeBinding type = this.resources[i].binding.type;", "+\t\t\tif (type != null && type.isValidBinding()) {", "+\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "+\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "+\t\t\t\tif (closeMethod != null && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], flowInfo, currentScope, true);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\tif (this.caughtExceptionTypes[i].isUncheckedException(true)) {", "+\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i])).", "+\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(this.caughtExceptionTypes[i]);", "+\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+\t\t\t\tthis.caughtExceptionsCatchBlocks,", "+\t\t\t\tthis.catchArguments,", "+\t\tfor (int i = 0, max = this.resources.length; i < max; i++) {", "+\t\t\tflowInfo = this.resources[i].analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.resources[i].binding.useFlag = LocalVariableBinding.USED; // Is implicitly used anyways.", "+\t\t\tTypeBinding type = this.resources[i].binding.type;", "+\t\t\tif (type != null && type.isValidBinding()) {", "+\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "+\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "+\t\t\t\tif (closeMethod != null && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[j], flowInfo, currentScope);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\tif (this.caughtExceptionTypes[i].isUncheckedException(true)) {", "+\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i])).", "+\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(this.caughtExceptionTypes[i]);", "+\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b790beaa9c50c4e48e23fd3bd9550c42", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "0e160bd57ca4572e4cc317f77eef59eff0c912a6", "commitAfterChange": "1b0238cbdda2702f17c4f0b30e4c8493818f8888", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\t\tbyte[] skipValues = new byte[visibleSize]; // tagged with -1 if method cannot be best match", "+\t\tboolean useTiebreakMethod = invocationSite.genericTypeArguments() == null;", "+\t\tMethodBinding[] moreSpecific = new MethodBinding[visibleSize];", "+\t\tint count = 0;", "-\t\t\t\tif (compatibilityLevels[i] != level || skipValues[i] == -1) continue nextVisible; // skip this method for now", "-\t\t\t\tMethodBinding original = visible[i].original();", "-\t\t\t\tMethodBinding tiebreakMethod = visible[i].tiebreakMethod();", "+\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible;", "+\t\t\t\tmax = level; // do not examine further categories, will either return mostSpecific or report ambiguous case", "+\t\t\t\tMethodBinding current = visible[i];", "+\t\t\t\tMethodBinding original = current.original();", "+\t\t\t\tMethodBinding tiebreakMethod = useTiebreakMethod ? current.tiebreakMethod() : current;", "-\t\t\t\t\tmax = level; // do not examine further categories", "-\t\t\t\t\tMethodBinding original2 = visible[j].original();", "-\t\t\t\t\tif (original == original2)", "-\t\t\t\t\t\tcontinue; // parameterized superclasses & interfaces may be walked twice from different paths", "-", "-\t\t\t\t\tMethodBinding tiebreakMethod2 = visible[j].tiebreakMethod();", "-\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod, tiebreakMethod2)) {", "-\t\t\t\t\t\tif (!isMoreSpecificMethod(tiebreakMethod2, tiebreakMethod))", "-\t\t\t\t\t\t\tskipValues[j] = -1; // no point checking method2 either", "-\t\t\t\t\t\tcontinue nextVisible; // method2 is a better match", "+\t\t\t\t\tMethodBinding next = visible[j];", "+\t\t\t\t\tif (original == next.original()) {", "+\t\t\t\t\t\t// parameterized superclasses & interfaces may be walked twice from different paths so skip next from now on", "+\t\t\t\t\t\tcompatibilityLevels[j] = -1; ", "+\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tif (tiebreakMethod.areParametersEqual(tiebreakMethod2)) {", "-\t\t\t\t\t\tMethodBinding method = tiebreakMethod;", "-\t\t\t\t\t\tMethodBinding method2 = tiebreakMethod2;", "-\t\t\t\t\t\tif (method.isStatic() && method2.isStatic()) {", "-\t\t\t\t\t\t\t// if you knew that method overrode method2, it would help", "-\t\t\t\t\t\t\tTypeBinding superType = method.declaringClass.erasure().findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (superType == null)", "-\t\t\t\t\t\t\t\tcontinue nextVisible; // static methods from unrelated types", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (original == method && original2 == method2)", "-\t\t\t\t\t\t\tcontinue; // no need to check further", "-\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "-\t\t\t\t\t\t\tcontinue; // 15.12.2, concrete method beats abstract method", "-\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "-\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "-", "-\t\t\t\t\t\tif (method.isAbstract() == method2.isAbstract() && receiverType != null", "-\t\t\t\t\t\t\t&& (method.hasSubstitutedParameters() || original.typeVariables != Binding.NO_TYPE_VARIABLES)) {", "-\t\t\t\t\t\t\t// class A<T> { void foo(T t) {} }", "-\t\t\t\t\t\t\t// class B<T, S> extends A<S> { void foo(T t) {} }", "-\t\t\t\t\t\t\treceiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();", "-\t\t\t\t\t\t\tTypeBinding superType = receiverType.findSuperTypeWithSameErasure(method.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (original.declaringClass == superType || !(superType instanceof ReferenceBinding)) {", "-\t\t\t\t\t\t\t\tmethod = original;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = ((ReferenceBinding)superType).getMethods(method.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\tmethod = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tsuperType = receiverType.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (original2.declaringClass == superType || !(superType instanceof ReferenceBinding)) {", "-\t\t\t\t\t\t\t\tmethod2 = original2;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = ((ReferenceBinding)superType).getMethods(method2.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\tmethod2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// when method has no type variables and method2 does, then you need a way to substitute them with their erasures at least", "-\t\t\t\t\t\t\tif (method.typeVariables != Binding.NO_TYPE_VARIABLES)", "-\t\t\t\t\t\t\t\tmethod2 = method.computeSubstitutedMethod(method2, environment());", "-\t\t\t\t\t\t\tif (method2 == null || !method.areParametersEqual(method2)) {", "-\t\t\t\t\t\t\t\tskipValues[j] = -1;", "-\t\t\t\t\t\t\t\tcontinue nextVisible; // dup thru substitution, not overridden... cannot find possible match", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// method overrides method2, accept it", "-\t\t\t\t\t\t} else if (!original.areTypeVariableErasuresEqual(original2)) {", "-\t\t\t\t\t\t\t// to detect   class AA<T> { void test() {} }   vs   class BB extends AA<CC> { <U> void test() {} }", "-\t\t\t\t\t\t\tif (original.typeVariables != Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\t\t\t\t\tskipValues[j] = -1;", "-\t\t\t\t\t\t\t\tcontinue nextVisible; // method is not better since variables are not equal", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\tMethodBinding methodToTest = next;", "+\t\t\t\t\tif (next instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tParameterizedGenericMethodBinding pNext = (ParameterizedGenericMethodBinding) next;", "+\t\t\t\t\t\tif (pNext.isRaw) {", "+\t\t\t\t\t\t\t// hold onto the raw substituted method", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tmethodToTest = pNext.originalMethod;", "+\t\t\t\t\tMethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, invocationSite);", "+\t\t\t\t\t/* There are 4 choices to consider with current & next :", "+\t\t\t\t\t foo(B) & foo(A) where B extends A", "+\t\t\t\t\t 1. the 2 methods are equal (both accept each others parameters) -> want to continue", "+\t\t\t\t\t 2. current has more specific parameters than next (so acceptable is a valid method) -> want to continue", "+\t\t\t\t\t 3. current has less specific parameters than next (so acceptable is null) -> go on to next", "+\t\t\t\t\t 4. current and next are not compatible with each other (so acceptable is null) -> go on to next", "+\t\t\t\t\t */", "+\t\t\t\t\tif (acceptable == null || !acceptable.isValidBinding())", "+\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tif (!isAcceptableMethod(tiebreakMethod, acceptable))", "+\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\tcompilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);", "-\t\t\t\treturn visible[i];", "+\t\t\t\tmoreSpecific[i] = current;", "+\t\t\t\tcount++;", "+\t\tif (count == 1) {", "+\t\t\tfor (int i = 0; i < visibleSize; i++) {", "+\t\t\t\tif (moreSpecific[i] != null) {", "+\t\t\t\t\tcompilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);", "+\t\t\t\t\treturn visible[i];", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else if (count == 0) {", "+\t\t\treturn new ProblemMethodBinding(visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);", "+\t\t}", "+", "+\t\t// found several methods that are mutually acceptable -> must be equal", "+\t\t// so now with the first acceptable method, find the 'correct' inherited method for each other acceptable method AND", "+\t\t// see if they are equal after substitution of type variables (do the type variables have to be equal to be considered an override???)", "+\t\tif (receiverType != null)", "+\t\t\treceiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();", "+\t\tnextSpecific : for (int i = 0; i < visibleSize; i++) {", "+\t\t\tMethodBinding current = moreSpecific[i];", "+\t\t\tif (current != null) {", "+\t\t\t\tMethodBinding original = current.original();", "+\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\t\tMethodBinding next = moreSpecific[j];", "+\t\t\t\t\tif (next == null || i == j) continue;", "+\t\t\t\t\tMethodBinding original2 = next.original();", "+\t\t\t\t\tif (original.declaringClass == original2.declaringClass)", "+\t\t\t\t\t\tbreak nextSpecific; // duplicates thru substitution", "+", "+\t\t\t\t\tif (!original.isAbstract()) {", "+\t\t\t\t\t\tif (original2.isAbstract())", "+\t\t\t\t\t\t\tcontinue; // only compare current against other concrete methods", "+\t\t\t\t\t\tTypeBinding superType = original.declaringClass.findSuperTypeWithSameErasure(original2.declaringClass.erasure());", "+\t\t\t\t\t\tif (superType == null)", "+\t\t\t\t\t\t\tcontinue nextSpecific; // current's declaringClass is not a subtype of next's declaringClass", "+\t\t\t\t\t\tif (current != original) {", "+\t\t\t\t\t\t\tif (original2.declaringClass != superType) {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (original.typeVariables != Binding.NO_TYPE_VARIABLES)", "+\t\t\t\t\t\t\t\toriginal2 = original.computeSubstitutedMethod(original2, environment());", "+\t\t\t\t\t\t\tif (original2 == null || !original.areParametersEqual(original2))", "+\t\t\t\t\t\t\t\tcontinue nextSpecific; // current does not override next", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (receiverType != null) { // should not be null if original isAbstract, but be safe", "+\t\t\t\t\t\tTypeBinding superType = receiverType.findSuperTypeWithSameErasure(original.declaringClass.erasure());", "+\t\t\t\t\t\tif (original.declaringClass == superType || !(superType instanceof ReferenceBinding)) {", "+\t\t\t\t\t\t\t// keep original", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\tMethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original.selector);", "+\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsuperType = receiverType.findSuperTypeWithSameErasure(original2.declaringClass.erasure());", "+\t\t\t\t\t\tif (original2.declaringClass == superType || !(superType instanceof ReferenceBinding)) {", "+\t\t\t\t\t\t\t// keep original2", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\tMethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);", "+\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (original.typeVariables != Binding.NO_TYPE_VARIABLES)", "+\t\t\t\t\t\t\toriginal2 = original.computeSubstitutedMethod(original2, environment());", "+\t\t\t\t\t\tif (original2 == null || !original.areParameterErasuresEqual(original2) || !original.returnType.isCompatibleWith(original2.returnType)) // 15.2.2", "+\t\t\t\t\t\t\tcontinue nextSpecific; // current does not override next", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn current;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// if all moreSpecific methods are equal then see if duplicates exist because of substitution"]}], "num": 30231}