{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "40b928efd8c4c3a60aa53903ddba8d9e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06f7e42731900efea583603e39982b1e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java", "commitBeforeChange": "3c755125fb6d43834cd7c6dfb58024a6d397b566", "commitAfterChange": "790443c8ea7a17aa25cb0c35c01196da99d52e04", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t\tpublic boolean visit(IResourceDelta delta) throws CoreException", "signatureAfterChange": " \t\tpublic boolean visit(IResourceDelta delta) throws CoreException", "diff": ["-\t\t\t\t\t\tgfm.generatedSourceFolderDeleted(_removedProjects.contains(project));", "-\t\t\t\t\t\t_addGenFolderTo.add(project);", "+\t\t\t\t\t\tif( !_removedProjects.contains(project) ){\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tgfm.generatedSourceFolderDeleted();", "+\t\t\t\t\t\t\t_addGenFolderTo.add(project);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// if the project is already closed or in the process of being", "+\t\t\t\t\t\t// deleted, will ignore this deletion since we cannot correct ", "+\t\t\t\t\t\t// the classpath anyways.", "-\t\t\t\tif( proj.isOpen() && proj.exists() && proj.hasNature(JavaCore.NATURE_ID) ){", "+\t\t\t\tif( canUpdate(proj) ){", "-\t\t\t\t}", "+\t\t\t\t}\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "594028472e12052f1a3d6d7eaedf032f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "4290d9d156b3fffdf4fa47faed755763dff62df4", "commitAfterChange": "ec3d2b8d7bc5e4b4b2d91a6a1cfd252341798462", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private void checkDefaultAbstractMethod(MethodBinding abstractMethod)", "signatureAfterChange": " private void checkPackagePrivateAbstractMethod(MethodBinding abstractMethod)", "diff": ["-// TODO: (kent) should rename into checkNonVisibleAbstractMethod(...) - default abstract means something else.", "-private void checkDefaultAbstractMethod(MethodBinding abstractMethod) {", "+private void checkPackagePrivateAbstractMethod(MethodBinding abstractMethod) {", "-\twhile (superType != abstractMethod.declaringClass && superType.isValidBinding()) {", "+\tdo {", "+\t\tif (!superType.isValidBinding()) return;", "+\t\tif (!superType.isAbstract()) return; // closer non abstract super type will be flagged instead", "-\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract() || method.isAbstract())", "+\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "-", "-\t\t\tif (!superType.isAbstract()) return; // will report error against this type", "-", "-\t\t\t// non visible abstract methods cannot be overridden so the type must be defined abstract", "-\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, abstractMethod);", "-\t\t\treturn;", "-\t\tsuperType = superType.superclass();", "-\t}", "+\t} while ((superType = superType.superclass()) != abstractMethod.declaringClass);", "+\t// non visible abstract methods cannot be overridden so the type must be defined abstract", "+\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, abstractMethod);"]}], "num": 18586}