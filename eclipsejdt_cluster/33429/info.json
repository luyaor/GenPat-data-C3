{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "df9ae5f189ce4c45753061428fc0bf3a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04a1098de600044e218df870210917e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "c59be425cf25326239f4ea61082e801292bcf9ab", "commitAfterChange": "d6fb9802bac486c7e71b20d321f123bc000bd933", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r public static String createArraySignature(String typeSignature, int arrayCount)", "signatureAfterChange": "\r public static String createArraySignature(String typeSignature, int arrayCount)", "diff": ["-\tif (arrayCount == 0) return typeSignature;\r", "-\tStringBuffer sb = new StringBuffer(typeSignature.length() + arrayCount);\r", "-\tfor (int i = 0; i < arrayCount; ++i) {\r", "-\t\tsb.append(C_ARRAY);\r", "+\treturn new String(createArraySignature(typeSignature.toCharArray(), arrayCount));\r", "+}\r", "-\tsb.append(typeSignature);\r", "-\treturn sb.toString();\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2076f28d10d665230690e57b618cebcf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "341ead40b71a0bffec0f8325f6b29d2b567caf8a", "commitAfterChange": "f5884fa8b0573c548eaeabaa37cd99c51e41fd3b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["-\t\t\t\t\t\t}", "-\t\t\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682, 18.2.1, bullet 3, clause 2", "-\t\t\t\t\t\t   \"... the constraint reduces to the bound set B3 which would be used to determine the expression's invocation type when targeting T, as defined in \u00a718.5.2.\"", "-\t\t\t\t\t\t   We are actually using B4 here - to be fixed with https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tSolution solution = innerCtx.getResultFor(this.right);", "-\t\t\t\t\t\tif (solution != null) {", "-\t\t\t\t\t\t\tBoundSet b3 = solution.bounds;", "-\t\t\t\t\t\t\tinferenceContext.currentBounds.addBounds(b3, inferenceContext.environment);", "-\t\t\t\t\t\t\treturn TRUE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23633fa0068c6677e83b386ffbdcdb1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "3f131825dfbebcd2d9846517fd8419ae56311784", "commitAfterChange": "ede87229fe271e061ecd80820c468f7956351f61", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t// recording the closing of AutoCloseable resources:", "-\tif (CharOperation.equals(TypeConstants.CLOSE, this.selector)) ", "-\t{", "-\t\tFakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.receiver);", "-\t\tif (trackingVariable != null) { // null happens if receiver is not a local variable or not an AutoCloseable", "-\t\t\tif (trackingVariable.methodScope == currentScope.methodScope()) {", "-\t\t\t\ttrackingVariable.markClose(flowInfo, flowContext);", "-\t\t\t} else {", "-\t\t\t\ttrackingVariable.markClosedInNestedMethod();", "-\t\t\t}", "-\t\t}", "-\t}", "-\t\t\t// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)", "-\t\t\tflowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33e1e550df93bc9dcd527e1a84530d04", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "3022496b74f0bbeccd974aa8b5d23fb3438cc799", "commitAfterChange": "0841b38e29c9b9a090c0d849b31ae1e8b6484d97", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 61, "signatureBeforeChange": " \tprivate void findLocalMethodDeclarations( \t\tchar[] methodName, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType)", "signatureAfterChange": " \tprivate void findLocalMethodDeclarations( \t\tchar[] methodName, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean exactMatch, \t\tReferenceBinding receiverType)", "diff": ["-\t\tboolean onlyStaticMethods,", "-\t\t\tif(method.isStatic()) {", "-\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "-\t\t\t\t", "-\t\t\t\tif(receiverType.isMemberType() && !receiverType.isStatic()) continue next;", "-\t\t\t\t", "-\t\t\t\tif(receiverType.isLocalType()) continue next;", "-\t\t\t} else  {", "-\t\t\t\tif(onlyStaticMethods) continue next;", "-\t\t\t}", "+\t\t\tif(method.isStatic()) continue next;", "-\t\t\trelevance += computeRelevanceForStaticOveride(method.isStatic());", "+\t\t\trelevance += R_METHOD_OVERIDE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d36b13da374a3c0b72368794ef3bfae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "42f049f937d70e439674a5e8b4bf5fe233176519", "commitAfterChange": "b554fb8243e7e9f6b3dc500c3bd41ecd1fd736dd", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-\t\t\tif (this.kind == BLOCK_SCOPE || this.kind == METHOD_SCOPE) {", "-\t\t\t\tLocalVariableBinding variableBinding = findVariable(name);", "-\t\t\t\t// looks in this scope only", "-\t\t\t\tif (variableBinding != null) return variableBinding;", "-\t\t\t}", "-", "-\t\t\tif (this.kind == METHOD_SCOPE) {", "-\t\t\t\tMethodScope methodScope = (MethodScope) this;", "-\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "-\t\t\t\tinsideConstructorCall |= methodScope.isConstructorCall;", "-\t\t\t}", "-\t\t\tScope scope = parent;", "-\t\t\tif (scope == null) return new ProblemBinding(name, null, NotFound);", "+\t\t\tScope scope = this;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "628ffc956abc08dbbb4ea2842f315bf4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java", "commitBeforeChange": "c4c0df5e4aeb7d3e8571312c597020a7d0812327", "commitAfterChange": "6fea7eafdd413dccff31028f8da1f1ac6859e6fe", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate IStatus validateGenSrcDir()", "signatureAfterChange": " \tprivate IStatus validateGenSrcDir()", "diff": ["-\t\t// TODO: this check should be delegated to a validation routine in apt.core.", "-\t\tPath path = null;", "-\t\tif (dirName != null) {", "-\t\t\tpath= new Path(dirName);", "-\t\t}", "-\t\tif (path == null || ", "-\t\t\t\tpath.isAbsolute() || ", "-\t\t\t\tpath.isEmpty() || ", "-\t\t\t\t!path.isValidPath(dirName) ||", "-\t\t\t\t!dirName.trim().equals(dirName)) {", "+\t\tif (!AptConfig.validateGenSrcDir(fJProj, dirName)) {", "-\t\t// TODO: how can we tell whether dirName points to a \"normal\" src directory?"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "642d6f46dc6e6aaedf7e98e92106afd9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "3f131825dfbebcd2d9846517fd8419ae56311784", "commitAfterChange": "ede87229fe271e061ecd80820c468f7956351f61", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t\t}", "-\t\tFakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression);", "-\t\tif (trackingVariable != null) {", "-\t\t\tif (currentScope.methodScope() != trackingVariable.methodScope)", "-\t\t\t\ttrackingVariable.markClosedInNestedMethod();", "-\t\t\t// don't report issues concerning this local, since by returning", "-\t\t\t// the method passes the responsibility to the caller:", "-\t\t\tcurrentScope.removeTrackingVar(trackingVariable);", "-\tcurrentScope.checkUnclosedCloseables(flowInfo, null/*ignore exception exits from flowContext*/, this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "96da27457022247240a4ea2142f6ce20", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java", "commitBeforeChange": "e4d4ff5013f9df9fd57cdef7bafc039c1cd3f062", "commitAfterChange": "7b395b3717036fc2a84c58be444dfad51be38b89", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  private double getOpenableRatio()", "signatureAfterChange": "  private double getOpenableRatio()", "diff": ["-\tString property = System.getProperty(RATIO_PROPERTY);", "+\treturn getRatioForProperty(RATIO_PROPERTY);", "+}", "-\t\t\tUtil.log(e, \"Could not parse value for \" + RATIO_PROPERTY + \": \" + property); //$NON-NLS-1$ //$NON-NLS-2$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c68aeaeadc3f81cde29034a0468a9f81", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "0d09a2966f3cebfb8d6601000e2b64259fed7dd8", "commitAfterChange": "2b3acbf04ca04c733316af44132ec605de080f66", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public void resolve(Openable[] openables, HashSet localTypes, IProgressMonitor monitor)", "signatureAfterChange": " public void resolve(Openable[] openables, HashSet localTypes, IProgressMonitor monitor)", "diff": ["-\t\t\t\t\tif (isJava8 && !containsLocalType) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t// move state to handle as this defeats the purpose.", "-\t\t\t\t\t\t\tfinal CompilationUnitElementInfo compilationUnitElementInfo = (CompilationUnitElementInfo) openable.getElementInfo();", "-\t\t\t\t\t\t\tif (compilationUnitElementInfo.hasFunctionalTypes)  ", "-\t\t\t\t\t\t\t\tcontainsLocalType = true;", "-\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t// drop.", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tparsedUnit = containsLocalType ? parser.parse(sourceUnit, unitResult) : parser.dietParse(sourceUnit, unitResult);", "+\t\t\t\t\tparsedUnit = parser.dietParse(sourceUnit, unitResult);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cadc7720d1002ac2bda81e74578de781", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java", "commitBeforeChange": "64d39f3567030242a0089e54dec7b20eb2379aa8", "commitAfterChange": "61bef0fdf04ab68e34740d553b6ad5e9433edc7e", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " public static Object getTarget(IContainer container, IPath path, boolean checkResourceExistence)", "signatureAfterChange": " public static Object getTarget(IPath path, boolean checkResourceExistence)", "diff": ["-public static Object getTarget(IContainer container, IPath path, boolean checkResourceExistence) {", "-", "-\tif (path == null) return null;", "-\t", "-\t// lookup - inside the container", "-\tif (path.getDevice() == null) { // container relative paths should not contain a device ", "-\t\t\t\t\t\t\t\t\t\t\t\t// (see http://dev.eclipse.org/bugs/show_bug.cgi?id=18684)", "-\t\t\t\t\t\t\t\t\t\t\t\t// (case of a workspace rooted at d:\\ )", "-\t\tIResource resource = container.findMember(path);", "-\t\tif (resource != null){", "-\t\t\tif (!checkResourceExistence ||resource.exists()) return resource;", "-\t\t\treturn null;", "-\t\t}", "-\t}", "-\t", "-\t// if path is relative, it cannot be an external path", "-\t// (see http://dev.eclipse.org/bugs/show_bug.cgi?id=22517)", "-\tif (!path.isAbsolute()) return null; ", "-", "-\t// lookup - outside the container", "-\treturn getTargetAsExternalFile(path, checkResourceExistence);\t", "+public static Object getTarget(IPath path, boolean checkResourceExistence) {", "+\tObject target = getWorkspaceTarget(path); // Implicitly checks resource existence", "+\tif (target != null)", "+\t\treturn target;", "+\treturn getExternalTarget(path, checkResourceExistence);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4645e8225d5dad3c055f0fc4a50672f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "c96ea754cbc1843e6373572c9a41527df8e971a2", "commitAfterChange": "b026aefdcbffec474ae6cafef5ea7136332c257c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " private Binding findOnDemandImport(char[][] compoundName, boolean isStaticImport)", "signatureAfterChange": " private Binding findImport(char[][] compoundName, int length)", "diff": ["-private Binding findOnDemandImport(char[][] compoundName, boolean isStaticImport) {", "+private Binding findImport(char[][] compoundName, int length) {", "-\tint length = compoundName.length;", "-\t\tif (isStaticImport) {", "-\t\t\t// does look for inherited member types unlike non static imports", "-\t\t\ttype = findMemberType(name, type);", "-\t\t\tif (type == null || !type.isStatic())", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, i), NotFound);", "-\t\t} else {", "-\t\t\t// does not look for inherited member types on purpose, only immediate members", "-\t\t\ttype = type.getMemberType(name);", "-\t\t\tif (type == null)", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, i), NotFound);", "-\t\t}", "+\t\t// does not look for inherited member types on purpose, only immediate members", "+\t\ttype = type.getMemberType(name);", "+\t\tif (type == null)", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, i), NotFound);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffe520414ae6108306e8ef2ebc0b340b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java", "commitBeforeChange": "78950c7a462ba6fe8424532e69a4abeff0c7c745", "commitAfterChange": "bb74c75a01728288c8fd321cd0dfd5da07348196", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\tcheckAccess(scope.methodScope(), this.resolvedType);", "-\t\t} else {", "-\t\t\t// Could also be targeting an enclosing instance inside a super constructor invocation", "-\t\t\t//\tclass X {", "-\t\t\t//\t\tpublic X(int i) {", "-\t\t\t//\t\t\tthis(new Object() { Object obj = X.this; });", "-\t\t\t//\t\t}", "-\t\t\t//\t}", "-", "-\t\t\tMethodScope methodScope = scope.methodScope();", "-\t\t\twhile (methodScope != null) {", "-\t\t\t\tif (!this.checkAccess(methodScope, this.resolvedType)) break;", "-\t\t\t\tif (methodScope.enclosingSourceType() == this.currentCompatibleType) break;", "-\t\t\t\tmethodScope = methodScope.parent.methodScope();", "-\t\t\t}", "-\t\t}", "+\t\t\tcheckAccess(scope.methodScope());", "+\t\t} // if depth>0, path emulation will diagnose bad scenarii"]}], "num": 33429}