{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cff73cb7e8f410a837fe7062b0001997", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71429eb8afd684ac5540f922f4b4c96a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "+\tthis.argumentTypes = Binding.NO_PARAMETERS;", "-\t\targumentTypes = new TypeBinding[length];", "-\t\tTypeBinding argumentType;", "+\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\t\tif ((argumentType = argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t}", "-\t\t\tif (argumentType != null && argumentType.kind() == Binding.POLY_TYPE) {", "-\t\t\t\tif (this.innerInferenceHelper == null)", "-\t\t\t\t\tthis.innerInferenceHelper = new InnerInferenceHelper();", "-\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);", "+\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);", "-\tthis.binding = findConstructorBinding(scope, this, allocatedType, argumentTypes);", "+\tthis.binding = findConstructorBinding(scope, this, allocatedType, this.argumentTypes);", "-\t\t\tMethodBinding privateBinding = localScope.getConstructor((ReferenceBinding)this.delegateThis.type, argumentTypes, this);", "+\t\t\tMethodBinding privateBinding = localScope.getConstructor((ReferenceBinding)this.delegateThis.type, this.argumentTypes, this);", "-\t\t\tTypeBinding argumentType = argumentTypes[i];", "+\t\t\tTypeBinding argumentType = this.argumentTypes[i];", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocatedType, this.binding, this.arguments, argumentTypes, this);", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocatedType, this.binding, this.arguments, this.argumentTypes, this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "afbc76f8b01ef7f91ea259a5bea633c6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-", "-\tthis.constant = Constant.NotAConstant;", "-\tboolean receiverCast = false, argsContainCast = false;", "-\tif (this.receiver instanceof CastExpression) {", "-\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\treceiverCast = true;", "-\t}", "-\tthis.actualReceiverType = this.receiver.resolveType(scope);", "-\tif (receiverCast && this.actualReceiverType != null) {", "-\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "-\t\tif (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {", "-\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);", "+\t", "+\tif (this.constant != Constant.NotAConstant) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\tboolean receiverCast = false;", "+\t\tif (this.receiver instanceof CastExpression) {", "+\t\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\treceiverCast = true;", "-\t}", "-\t// resolve type arguments (for generic constructor call)", "-\tif (this.typeArguments != null) {", "-\t\tint length = this.typeArguments.length;", "-\t\tboolean argHasError = false; // typeChecks all arguments", "-\t\tthis.genericTypeArguments = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\targHasError = true;", "+\t\tthis.actualReceiverType = this.receiver.resolveType(scope);", "+\t\tif (receiverCast && this.actualReceiverType != null) {", "+\t\t\t// due to change of declaring class with receiver type, only identity cast should be notified", "+\t\t\tif (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {", "+\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);", "-\t\tif (argHasError) {", "+\t\t// resolve type arguments (for generic constructor call)", "+\t\tif (this.typeArguments != null) {", "+\t\t\tint length = this.typeArguments.length;", "+\t\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\targHasError = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\t// will check for null after args are resolved", "+\t\tif (this.arguments != null) {", "+\t\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\t\tint length = this.arguments.length;", "+\t\t\tthis.argumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tthis.argsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "+\t\t\t\tif ((this.argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "+\t\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\tif(this.actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "+\t\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);", "+\t\t\t\t}", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\tif (this.actualReceiverType == null) {", "+\t\t\treturn null;", "+\t\t}", "+\t\t// base type cannot receive any message", "+\t\tif (this.actualReceiverType.isBaseType()) {", "+\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\t// will check for null after args are resolved", "-\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "-\tif (this.arguments != null) {", "-\t\tboolean argHasError = false; // typeChecks all arguments", "-\t\tint length = this.arguments.length;", "-\t\targumentTypes = new TypeBinding[length];", "-\t\tTypeBinding argumentType;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression argument = this.arguments[i];", "-\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\targsContainCast = true;", "-\t\t\t}", "-\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\tif ((argumentType = argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "-\t\t\t\targHasError = true;", "-\t\t\tif (argumentType != null && argumentType.kind() == Binding.POLY_TYPE) {", "-\t\t\t\tif (this.innerInferenceHelper == null)", "-\t\t\t\t\tthis.innerInferenceHelper = new InnerInferenceHelper();", "-\t\t\t}", "-\t\t}", "-\t\tif (argHasError) {", "-\t\t\tif(this.actualReceiverType instanceof ReferenceBinding) {", "-\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);", "-\t\t\t}", "-\t\t\treturn null;", "-\t\t}", "-\t}", "-\tif (this.actualReceiverType == null) {", "-\t\treturn null;", "-\t}", "-\t// base type cannot receive any message", "-\tif (this.actualReceiverType.isBaseType()) {", "-\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "-\t\treturn null;", "-\t}", "-", "-\tfindMethodBinding(scope, argumentTypes);", "+\tfindMethodBinding(scope);", "-\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, argumentTypes, this)", "-\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, argumentTypes, this);", "+\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, this.argumentTypes, this)", "+\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, this.argumentTypes, this);", "-\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "+\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "+\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\tif (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "+\tif (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {"]}], "num": 12560}