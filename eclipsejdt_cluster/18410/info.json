{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "423218c23a9fb9b35415d7fa65d4a55d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b1e322a2fb9e695cb51914428623a7f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "8ff87d310a91c2a77c65ad68bb4b1fd94425fd85", "commitAfterChange": "dbf8a869161361178e399dd7e18a85b9a48bde74", "methodNumberBeforeChange": 241, "methodNumberAfterChange": 312, "signatureBeforeChange": "\t \t \tpublic void testVariableDeclarationStatement()", "signatureAfterChange": "\t \t \tpublic void testVariableDeclarationStatement()", "diff": ["-\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\t} else {", "+\t\t\tassertTrue(x.modifiers().size() == 0);", "+\t\t}", "-\t\tint legal = Modifier.FINAL;", "-\t\tpreviousCount = ast.modificationCount();", "-\t\tx.setModifiers(legal);", "-\t\tassertTrue(ast.modificationCount() > previousCount);", "-\t\tassertTrue(x.getModifiers() == legal);", "-", "-\t\tpreviousCount = ast.modificationCount();", "-\t\tx.setModifiers(Modifier.NONE);", "-\t\tassertTrue(ast.modificationCount() > previousCount);", "-\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "+\t\t\tint legal = Modifier.FINAL;", "+\t\t\tpreviousCount = ast.modificationCount();", "+\t\t\tx.setModifiers(legal);", "+\t\t\tassertTrue(ast.modificationCount() > previousCount);", "+\t\t\tassertTrue(x.getModifiers() == legal);", "+\t", "+\t\t\tpreviousCount = ast.modificationCount();", "+\t\t\tx.setModifiers(Modifier.NONE);", "+\t\t\tassertTrue(ast.modificationCount() > previousCount);", "+\t\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\t}", "-\t\t// check that property cannot be set to illegal value", "-\t\ttry {", "-\t\t\tx.setModifiers(Modifier.PUBLIC);", "-\t\t\tassertTrue(false);", "-\t\t} catch (RuntimeException e) {", "-\t\t\t// pass", "+\t\tif (ast.apiLevel() >= AST.LEVEL_3_0) {", "+\t\t\tgenericPropertyListTest(x, x.modifiers(), new Property(\"Modifiers\", true, ExtendedModifier.class) { //$NON-NLS-1$", "+\t\t\t\tpublic ASTNode sample(AST targetAst, boolean parented) {", "+\t\t\t\t\tModifier result = targetAst.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);", "+\t\t\t\t\tif (parented) {", "+\t\t\t\t\t\tTypeDeclaration pd = targetAst.newTypeDeclaration();", "+\t\t\t\t\t\tpd.modifiers().add(result);", "+\t\t\t\t\t}", "+\t\t\t\t\treturn result;", "+\t\t\t\t}", "+\t\t\t\tpublic ASTNode wrap() {", "+\t\t\t\t\tSingleMemberAnnotation s1 = x.getAST().newSingleMemberAnnotation();", "+\t\t\t\t\tClassInstanceCreation s2 = x.getAST().newClassInstanceCreation();", "+\t\t\t\t\tAnonymousClassDeclaration s3 = x.getAST().newAnonymousClassDeclaration();", "+\t\t\t\t\tMethodDeclaration s4 = x.getAST().newMethodDeclaration();", "+\t\t\t\t\tBlock s5 = x.getAST().newBlock();", "+\t\t\t\t\tVariableDeclarationFragment s6 = x.getAST().newVariableDeclarationFragment();", "+\t\t\t\t\tVariableDeclarationStatement s7 = x.getAST().newVariableDeclarationStatement(s6);", "+\t\t\t\t\ts1.setValue(s2);", "+\t\t\t\t\ts2.setAnonymousClassDeclaration(s3);", "+\t\t\t\t\ts3.bodyDeclarations().add(s4);", "+\t\t\t\t\ts4.setBody(s5);", "+\t\t\t\t\ts5.statements().add(s7);", "+\t\t\t\t\ts7.modifiers().add(x);", "+\t\t\t\t\treturn s1;", "+\t\t\t\t}", "+\t\t\t\tpublic void unwrap() {", "+\t\t\t\t\tVariableDeclarationStatement s7 = (VariableDeclarationStatement) x.getParent();", "+\t\t\t\t\ts7.modifiers().remove(x);", "+\t\t\t\t}", "+\t\t\t});", "+\t\t\t", "+\t\t\t// check that getModifiers() tracks changes to modifiers()", "+\t\t\tx.modifiers().clear();", "+\t\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\t\tModifier[] allMods = allModifiers();", "+\t\t\t// one at a time", "+\t\t\tfor (int i = 0 ; i < allMods.length; i++) {", "+\t\t\t\tx.modifiers().add(allMods[i]);", "+\t\t\t\tassertTrue(x.getModifiers() == allMods[i].getKeyword().toFlagValue());", "+\t\t\t\tx.modifiers().remove(allMods[i]);", "+\t\t\t\tassertTrue(x.getModifiers() == Modifier.NONE);", "+\t\t\t}", "+\t\t\t// all at same time", "+\t\t\tfor (int i = 0 ; i < allMods.length; i++) {", "+\t\t\t\tx.modifiers().add(allMods[i]);", "+\t\t\t}", "+\t\t\tint flags  = x.getModifiers();", "+\t\t\tfor (int i = 0 ; i < allMods.length; i++) {", "+\t\t\t\tassertTrue((flags & allMods[i].getKeyword().toFlagValue()) != 0);", "+\t\t\t}", "-\t", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "efb52a2ce6224db51dca0833cafd6291", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "82e3492687fb385a8a9ba6c56e1f6d491dc8d79a", "commitAfterChange": "0b30f6ac807cc8aa14a5978d1dd305dd71baedda", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected void verifyFragmentsPositions(TagElement tagElement, char[] source)", "signatureAfterChange": " \tprivate void verifyPositions(TagElement tagElement, char[] source)", "diff": ["-\t */", "-\tprotected void verifyFragmentsPositions(TagElement tagElement, char[] source) {", "+\t */", "+\tprivate void verifyPositions(TagElement tagElement, char[] source) {", "+\t\tString text = null;", "+\t\tint tagStart = tagElement.getStartPosition();", "+\t\tif (tagElement.isNested()) {", "+\t\t\tassertEquals(\"Wrong start position for \"+tagElement, '{', source[tagStart++]);", "+\t\t}", "+\t\t\ttext= new String(source, tagStart, tagName.length());", "+\t\t\tassertEquals(\"Misplaced tag name at \"+tagStart, tagName, text);", "+\t\t\ttagStart += tagName.length();", "+\t\tASTNode previousFragment = null;", "+\t\t\t\tif (previousFragment != null && previousFragment.getNodeType() == ASTNode.TEXT_ELEMENT) {", "+\t\t\t\t\tassertTrue(\"Wrong length for text element \"+previousFragment, source[tagStart] == '\\r' || source[tagStart] == '\\n');", "+\t\t\t\t\twhile (source[tagStart] == '*' || Character.isWhitespace(source[tagStart])) {", "+\t\t\t\t\t\ttagStart++; // purge non-stored characters", "+\t\t\t\t}", "+\t\t\t\ttext = new String(source, tagStart, fragment.getLength());", "+\t\t\t\tassertEquals(\"Misplaced or wrong text element at \"+tagStart, text, ((TextElement) fragment).getText());", "+\t\t\t} else {", "+\t\t\t\twhile (source[tagStart] == '*' || Character.isWhitespace(source[tagStart])) {", "+\t\t\t\t\ttagStart++; // purge non-stored characters", "+\t\t\t\t}", "+\t\t\t\tif (fragment.getNodeType() == ASTNode.SIMPLE_NAME || fragment.getNodeType() == ASTNode.QUALIFIED_NAME) {", "+\t\t\t\t\tverifyNamePositions(tagStart, (Name) fragment, source);", "+\t\t\t\t} else if (fragment.getNodeType() == ASTNode.TAG_ELEMENT) {", "+\t\t\t\t\tTagElement inlineTag = (TagElement) fragment;", "+\t\t\t\t\tassertEquals(\"Tag element has wrong start position\", tagStart, inlineTag.getStartPosition());", "+\t\t\t\t\tverifyPositions(inlineTag, source);", "+\t\t\t\t} else if (fragment.getNodeType() == ASTNode.MEMBER_REF) {", "+\t\t\t\t\tMemberRef memberRef = (MemberRef) fragment;", "+\t\t\t\t\t// Store start position", "+\t\t\t\t\tint start = tagStart;", "+\t\t\t\t\t// Verify qualifier position", "+\t\t\t\t\tName qualifier = memberRef.getQualifier();", "+\t\t\t\t\tif (qualifier != null) {", "+\t\t\t\t\t\ttext = new String(source, start, qualifier.getLength());", "+\t\t\t\t\t\tassertEquals(\"Misplaced or wrong member ref qualifier at \"+start, text, qualifier.toString());", "+\t\t\t\t\t\tverifyNamePositions(start, qualifier, source);", "+\t\t\t\t\t\tstart += qualifier.getLength();", "+\t\t\t\t\t\twhile (source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\t\tstart++; // purge non-stored characters", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// Verify member separator position", "+\t\t\t\t\tassertEquals(\"Misplace # separator for member ref\"+memberRef, '#', source[start]);", "+\t\t\t\t\tstart++;", "+\t\t\t\t\twhile (source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\tstart++; // purge non-stored characters", "+\t\t\t\t\t}", "+\t\t\t\t\t// Verify member name position", "+\t\t\t\t\tName name = memberRef.getName();", "+\t\t\t\t\ttext = new String(source, start, name.getLength());", "+\t\t\t\t\tassertEquals(\"Misplaced or wrong member ref name at \"+start, text, name.toString());", "+\t\t\t\t\tverifyNamePositions(start, name, source);", "+\t\t\t\t} else if (fragment.getNodeType() == ASTNode.METHOD_REF) {", "+\t\t\t\t\tMethodRef methodRef = (MethodRef) fragment;", "+\t\t\t\t\t// Store start position", "+\t\t\t\t\tint start = tagStart;", "+\t\t\t\t\t// Verify qualifier position", "+\t\t\t\t\tName qualifier = methodRef.getQualifier();", "+\t\t\t\t\tif (qualifier != null) {", "+\t\t\t\t\t\ttext = new String(source, start, qualifier.getLength());", "+\t\t\t\t\t\tassertEquals(\"Misplaced or wrong member ref qualifier at \"+start, text, qualifier.toString());", "+\t\t\t\t\t\tverifyNamePositions(start, qualifier, source);", "+\t\t\t\t\t\tstart += qualifier.getLength();", "+\t\t\t\t\t\twhile (source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\t\tstart++; // purge non-stored characters", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// Verify member separator position", "+\t\t\t\t\tassertEquals(\"Misplace # separator for member ref\"+methodRef, '#', source[start]);", "+\t\t\t\t\tstart++;", "+\t\t\t\t\twhile (source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\tstart++; // purge non-stored characters", "+\t\t\t\t\t}", "+\t\t\t\t\t// Verify member name position", "+\t\t\t\t\tName name = methodRef.getName();", "+\t\t\t\t\ttext = new String(source, start, name.getLength());", "+\t\t\t\t\tassertEquals(\"Misplaced or wrong member ref name at \"+start, text, name.toString());", "+\t\t\t\t\tverifyNamePositions(start, name, source);", "+\t\t\t\t\tstart += name.getLength();", "+\t\t\t\t\twhile (source[start] == '(' || source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\tstart++; // purge non-stored characters", "+\t\t\t\t\t}", "+\t\t\t\t\t// Verify parameters", "+\t\t\t\t\tIterator parameters = methodRef.parameters().listIterator();", "+\t\t\t\t\twhile (parameters.hasNext()) {", "+\t\t\t\t\t\tMethodRefParameter param = (MethodRefParameter) parameters.next();", "+\t\t\t\t\t\t// Verify parameter type positions", "+\t\t\t\t\t\tType type = param.getType();", "+\t\t\t\t\t\ttext = new String(source, start, type.getLength());", "+\t\t\t\t\t\tassertEquals(\"Misplaced or wrong method ref parameter type at \"+start, text, type.toString());", "+\t\t\t\t\t\tif (type.isSimpleType()) {", "+\t\t\t\t\t\t\tverifyNamePositions(start, ((SimpleType)type).getName(), source);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tstart += type.getLength();", "+\t\t\t\t\t\twhile (Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\t\t start++; // purge non-stored characters", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Verify parameter name positions", "+\t\t\t\t\t\tname = param.getName();", "+\t\t\t\t\t\tif (name != null) {", "+\t\t\t\t\t\t\ttext = new String(source, start, name.getLength());", "+\t\t\t\t\t\t\tassertEquals(\"Misplaced or wrong method ref parameter name at \"+start, text, name.toString());", "+\t\t\t\t\t\t\tstart += name.getLength();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\twhile (source[start] == ',' || source[start] == ')' || source[start] == '*' || Character.isWhitespace(source[start])) {", "+\t\t\t\t\t\t\tchar ch = source[start++];", "+\t\t\t\t\t\t\t if (ch == ',' || ch == ')') {", "+\t\t\t\t\t\t\t \tbreak;", "+\t\t\t\t\t\t\t }", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\ttagStart += fragment.getLength();", "+//\t\t\tif (source[tagStart] == '\\r' || source[tagStart] == '\\n') {", "+//\t\t\t\twhile (source[tagStart] == '*' || Character.isWhitespace(source[tagStart])) {", "+//\t\t\t\t\ttagStart++; // purge non-stored characters", "+//\t\t\t\t}", "+//\t\t\t}", "+\t\t\tpreviousFragment = fragment;", "+\t\t}", "+\t\tif (tagElement.isNested()) {", "+\t\t\tassertEquals(\"Wrong end character for \"+tagElement, '}', source[tagStart++]);"]}], "num": 18410}