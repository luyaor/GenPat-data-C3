{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e89605036062aafae49b2c640e4076b5", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "193e848d3db92dd01082c51020e9504a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeleteElementsOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void replaceElementInBuffer(IBuffer buffer, IJavaElement elementToRemove, String cuName)", "signatureAfterChange": " \t \tprivate void deleteElement(IJavaElement elementToRemove, ICompilationUnit cu) throws JavaModelException", "diff": ["+\tprivate void deleteElement(IJavaElement elementToRemove, ICompilationUnit cu) throws JavaModelException {", "+\t\t// ensure cu is consistent (noop if already consistent)", "+\t\tcu.makeConsistent(this.progressMonitor);", "+\t\tthis.parser.setSource(cu);", "+\t\tCompilationUnit astCU = (CompilationUnit) this.parser.createAST(this.progressMonitor);", "+\t\tASTNode node = ((JavaElement) elementToRemove).findNode(astCU);", "+\t\tif (node == null) ", "+\t\t\tAssert.isTrue(false, \"Failed to locate \" + elementToRemove.getElementName() + \" in \" + cu.getElementName()); //$NON-NLS-1$//$NON-NLS-2$", "+\t\tIDocument document = getDocument(cu);", "+\t\tAST ast = astCU.getAST();", "+\t\tASTRewrite rewriter = ASTRewrite.create(ast);", "+\t\trewriter.remove(node, null);", "+ \t\tTextEdit edits = rewriter.rewriteAST(document, null);", "+ \t\ttry {", "+\t \t\tedits.apply(document);", "+ \t\t} catch (BadLocationException e) {", "+ \t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.INVALID_CONTENTS);", "+ \t\t}", "+\t}", "-    // TODO - JDOM - remove once model ported off of JDOM", "-\tprivate void replaceElementInBuffer(IBuffer buffer, IJavaElement elementToRemove, String cuName) {", "-\t\tIDOMCompilationUnit cuDOM = factory.createCompilationUnit(buffer.getCharacters(), cuName);", "-\t\torg.eclipse.jdt.internal.core.jdom.DOMNode node = (org.eclipse.jdt.internal.core.jdom.DOMNode)((JavaElement) elementToRemove).findNode(cuDOM);", "-\t\tif (node == null) Assert.isTrue(false, \"Failed to locate \" + elementToRemove.getElementName() + \" in \" + cuDOM.getName()); //$NON-NLS-1$//$NON-NLS-2$", "-", "-\t\tint startPosition = node.getStartPosition();", "-\t\tbuffer.replace(startPosition, node.getEndPosition() - startPosition + 1, CharOperation.NO_CHAR);", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fda8b01721457059e8f3911d318c5309", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic void addEntryToFileMaps( IFile parentFile, IFile generatedFile )", "signatureAfterChange": " \tpublic void deleteObsoleteTypesAfterReconcile(ICompilationUnit parentWC, Set<IFile> newlyGeneratedFiles)", "diff": ["+\t */", "+\tpublic void deleteObsoleteTypesAfterReconcile(ICompilationUnit parentWC, Set<IFile> newlyGeneratedFiles)", "+\t{", "+\t\tIFile parentFile = (IFile) parentWC.getResource();", "+", "+\t\tList<ICompilationUnit> toSetBlank;", "+\t\tList<ICompilationUnit> toDiscard;", "+\t\tsynchronized (this) {", "+\t\t\tif (GENERATE_TYPE_DURING_RECONCILE) {", "+\t\t\t\ttoSetBlank = calculateHiddenTypes(parentFile, newlyGeneratedFiles, _CUHELPER);", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\ttoSetBlank = Collections.emptyList();", "+\t\t\t}", "+\t\t\ttoDiscard = calculateObsoleteWorkingCopies(parentFile, newlyGeneratedFiles);", "+\t\t}", "+", "+\t\tfor (ICompilationUnit wcToDiscard : toDiscard) {", "+\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace(", "+\t\t\t\t\t\"discarded obsolete working copy during reconcile: \" + wcToDiscard.getElementName()); //$NON-NLS-1$", "+\t\t\t_CUHELPER.discardWorkingCopy(wcToDiscard);", "+\t\t}", "+", "+\t\tWorkingCopyOwner workingCopyOwner = parentWC.getOwner();", "+\t\tfor (ICompilationUnit wcToSetBlank : toSetBlank) {", "+\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace(", "+\t\t\t\t\t\"hiding file with blank working copy during reconcile: \" + wcToSetBlank.getElementName()); //$NON-NLS-1$", "+\t\t\t_CUHELPER.updateWorkingCopyContents(\"\", wcToSetBlank, workingCopyOwner, RECURSIVE_RECONCILE); //$NON-NLS-1$", "+\t\t}", "+", "+\t\tassert checkIntegrity();", "+\t}", "-\t", "-\tpublic void addEntryToFileMaps( IFile parentFile, IFile generatedFile )", "-\t{", "-\t\tsynchronized ( this )", "-\t\t{", "-\t\t\t// add parent file -> set of derived files", "-\t\t\tSet<IFile> fileSet = _parentFile2GeneratedFiles.get( parentFile );", "-\t\t\tif ( fileSet == null )", "-\t\t\t{", "-\t\t\t\tfileSet = new HashSet<IFile>();", "-\t\t\t\t_parentFile2GeneratedFiles.put( parentFile, fileSet );", "-\t\t\t}", "-\t\t\tif (fileSet.add( generatedFile )) {", "-\t\t\t\t// Mark the maps as dirty, so that we can store them later", "-\t\t\t\t_mapsDirty = true;", "-\t\t\t}", "-", "-\t\t\t// add derived file -> set of parent files", "-\t\t\tfileSet = _generatedFile2ParentFiles.get( generatedFile );", "-\t\t\tif ( fileSet == null )", "-\t\t\t{ ", "-\t\t\t\tfileSet = new HashSet<IFile>();", "-\t\t\t\t_generatedFile2ParentFiles.put( generatedFile, fileSet );", "-\t\t\t}", "-\t\t\tif (fileSet.add( parentFile )) {", "-\t\t\t\t_mapsDirty = true;", "-\t\t\t}", "-\t\t}", "-\t}"]}], "num": 59138}