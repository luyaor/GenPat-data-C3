{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "20164afc03e82a18ef7e5ed7b1f5de50", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "042b087e3881cd388285d55d5d4a390b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "332f2b4bbc61519d48f9e1634468f589fe6ec357", "commitAfterChange": "1dac44e6f5251febeac5322fb143c153ef780c6a", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " \tprotected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations)", "signatureAfterChange": " \tprotected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations)", "diff": ["+\t\tTypeBinding firstType = types[indexOfFirst];", "+\t\tif (firstType.isBaseType()) return null; ", "-\t\tTypeBinding firstType = types[indexOfFirst];", "-\t\tTypeBinding[] erasedSuperTypes;", "-\t\tint superLength;", "-\t\tif (firstType.isBaseType()) {", "-\t\t\treturn null; ", "-\t\t} else if (firstType.isArrayType()) {", "-\t\t\tsuperLength = 4;", "-\t\t\tif (firstType.erasure() != firstType) {", "-\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\tsomeInvocations.add(firstType);", "-\t\t\t\tallInvocations.put(firstType.erasure(), someInvocations);", "-\t\t\t}", "-\t\t\terasedSuperTypes = new TypeBinding[] { // inject well-known array supertypes", "-\t\t\t\t\tfirstType.erasure(), ", "-\t\t\t\t\tgetJavaIoSerializable(),", "-\t\t\t\t\tgetJavaLangCloneable(),", "-\t\t\t\t\tgetJavaLangObject(),", "-\t\t\t};", "-\t\t} else {", "-\t\t\tArrayList typesToVisit = new ArrayList(5);", "-\t\t\tTypeBinding firstErasure = (firstType.isTypeVariable() && !firstType.isCapture()) ? firstType : firstType.erasure();", "-\t\t\tif (firstErasure != firstType) {", "-\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\tsomeInvocations.add(firstType);", "-\t\t\t\tallInvocations.put(firstErasure, someInvocations);", "-\t\t\t}", "-\t\t\ttypesToVisit.add(firstType);", "-\t\t\tint max = 1;", "-\t\t\tif (firstErasure.isArrayType()) {", "-\t\t\t\ttypesToVisit.add(getJavaIoSerializable());", "-\t\t\t\ttypesToVisit.add(getJavaLangCloneable());", "-\t\t\t\ttypesToVisit.add(getJavaLangObject());", "-\t\t\t\tmax += 3;", "-\t\t\t}", "-\t\t\tReferenceBinding currentType = (ReferenceBinding)firstType;", "-\t\t\tfor (int i = 0; i < max; i++) {", "-\t\t\t\tTypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);", "-\t\t\t\tif (typeToVisit.isArrayType()) continue;", "-\t\t\t\tcurrentType = (ReferenceBinding) typeToVisit;", "-\t\t\t\t// inject super interfaces prior to superclass", "-\t\t\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "-\t\t\t\tfor (int j = 0, count = itsInterfaces.length; j < count; j++) {", "-\t\t\t\t\tTypeBinding itsInterface = itsInterfaces[j];", "-\t\t\t\t\tTypeBinding itsInterfaceErasure = (itsInterface.isTypeVariable() && !itsInterface.isCapture()) ? itsInterface : itsInterface.erasure();", "-\t\t\t\t\tif (!typesToVisit.contains(itsInterfaceErasure)) {", "-\t\t\t\t\t\tif (itsInterfaceErasure != itsInterface) {", "-\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\t\t\t\tsomeInvocations.add(itsInterface);", "-\t\t\t\t\t\t\tallInvocations.put(itsInterfaceErasure, someInvocations);", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\ttypesToVisit.add(itsInterface);", "-\t\t\t\t\t\tmax++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "-\t\t\t\tif (itsSuperclass != null) {", "-\t\t\t\t\tTypeBinding itsSuperclassErasure = (itsSuperclass.isTypeVariable() && !itsSuperclass.isCapture()) ? itsSuperclass : itsSuperclass.erasure();", "-\t\t\t\t\tif (!typesToVisit.contains(itsSuperclassErasure)) {", "-\t\t\t\t\t\tif (itsSuperclassErasure != itsSuperclass) {", "-\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\t\t\t\tsomeInvocations.add(itsSuperclass);", "-\t\t\t\t\t\t\tallInvocations.put(itsSuperclassErasure, someInvocations);", "+\t\tArrayList typesToVisit = new ArrayList(5);", "+\t\t", "+\t\tint dim = firstType.dimensions();", "+\t\tTypeBinding leafType = firstType.leafComponentType();", "+\t\tTypeBinding firstErasure = (leafType.isTypeVariable() || leafType.isWildcard()/*&& !leafType.isCapture()*/) ? firstType : firstType.erasure();", "+\t\tif (firstErasure != firstType) {", "+\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\tsomeInvocations.add(firstType);", "+\t\t\tallInvocations.put(firstErasure, someInvocations);", "+\t\t}\t\t\t\t\t\t", "+\t\ttypesToVisit.add(firstType);", "+\t\tint max = 1;", "+\t\tReferenceBinding currentType;", "+\t\tfor (int i = 0; i < max; i++) {", "+\t\t\tTypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);", "+\t\t\tdim = typeToVisit.dimensions();", "+\t\t\tif (dim > 0) {", "+\t\t\t\tleafType = typeToVisit.leafComponentType();", "+\t\t\t\tswitch(leafType.id) {", "+\t\t\t\t\tcase T_JavaLangObject:", "+\t\t\t\t\t\tif (dim > 1) { // Object[][] supertype is Object[]", "+\t\t\t\t\t\t\tTypeBinding elementType = ((ArrayBinding)typeToVisit).elementsType();", "+\t\t\t\t\t\t\tif (!typesToVisit.contains(elementType)) {", "+\t\t\t\t\t\t\t\ttypesToVisit.add(elementType);", "+\t\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\ttypesToVisit.add(itsSuperclass);", "+\t\t\t\t\t\t// fallthrough", "+\t\t\t\t\tcase T_byte:", "+\t\t\t\t\tcase T_short:", "+\t\t\t\t\tcase T_char:", "+\t\t\t\t\tcase T_boolean:", "+\t\t\t\t\tcase T_int:", "+\t\t\t\t\tcase T_long:", "+\t\t\t\t\tcase T_float:", "+\t\t\t\t\tcase T_double:", "+\t\t\t\t\t\tTypeBinding superType = getJavaIoSerializable();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsuperType = getJavaLangCloneable();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsuperType = getJavaLangObject();", "+\t\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\t\tmax++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t", "+\t\t\t\t\tdefault:", "+\t\t\t\t}", "+\t\t\t\ttypeToVisit = leafType;", "+\t\t\t}", "+\t\t\tcurrentType = (ReferenceBinding) typeToVisit;", "+\t\t\tif (currentType.isCapture()) {", "+\t\t\t\tTypeBinding firstBound = ((CaptureBinding) currentType).firstBound;", "+\t\t\t\tif (firstBound != null && firstBound.isArrayType()) {", "+\t\t\t\t\tTypeBinding superType = dim == 0 ? firstBound : (TypeBinding)environment().createArrayType(firstBound, dim); // recreate array if needed", "+\t\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\t\tTypeBinding superTypeErasure = (firstBound.isTypeVariable() || firstBound.isWildcard() /*&& !itsInterface.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// inject super interfaces prior to superclass", "+\t\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "+\t\t\tfor (int j = 0, count = itsInterfaces.length; j < count; j++) {", "+\t\t\t\tTypeBinding itsInterface = itsInterfaces[j];", "+\t\t\t\tTypeBinding superType = dim == 0 ? itsInterface : (TypeBinding)environment().createArrayType(itsInterface, dim); // recreate array if needed", "+\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\tmax++;", "+\t\t\t\t\tTypeBinding superTypeErasure = (itsInterface.isTypeVariable() || itsInterface.isWildcard() /*&& !itsInterface.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "+\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "+\t\t\tif (itsSuperclass != null) {", "+\t\t\t\tTypeBinding superType = dim == 0 ? itsSuperclass : (TypeBinding)environment().createArrayType(itsSuperclass, dim); // recreate array if needed", "+\t\t\t\tif (!typesToVisit.contains(superType)) {", "+\t\t\t\t\ttypesToVisit.add(superType);", "+\t\t\t\t\tmax++;", "+\t\t\t\t\tTypeBinding superTypeErasure = (itsSuperclass.isTypeVariable() || itsSuperclass.isWildcard() /*&& !itsSuperclass.isCapture()*/) ? superType : superType.erasure();", "+\t\t\t\t\tif (superTypeErasure != superType) {", "+\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\t\t\tsomeInvocations.add(superType);", "+\t\t\t\t\t\tallInvocations.put(superTypeErasure, someInvocations);", "-\t\t\tsuperLength = typesToVisit.size();", "-\t\t\terasedSuperTypes = new TypeBinding[superLength];", "-\t\t\tint rank = 0;", "-\t\t\tfor (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {", "-\t\t\t\tTypeBinding type = (TypeBinding)iter.next();", "-\t\t\t\terasedSuperTypes[rank++] = type.isTypeVariable() ? type : type.erasure();", "-\t\t\t}", "+\t\t}", "+\t\tint superLength = typesToVisit.size();", "+\t\tTypeBinding[] erasedSuperTypes = new TypeBinding[superLength];", "+\t\tint rank = 0;", "+\t\tfor (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {", "+\t\t\tTypeBinding type = (TypeBinding)iter.next();", "+\t\t\tleafType = type.leafComponentType();", "+\t\t\terasedSuperTypes[rank++] = (leafType.isTypeVariable() || leafType.isWildcard() /*&& !leafType.isCapture()*/) ? type : type.erasure();", "-\t\t\t\t\tswitch (erasedSuperType.id) {", "-\t\t\t\t\t\tcase T_JavaIoSerializable :", "-\t\t\t\t\t\tcase T_JavaLangCloneable :", "-\t\t\t\t\t\tcase T_JavaLangObject :", "-\t\t\t\t\t\t\tcontinue nextSuperType;", "+\t\t\t\t\tTypeBinding match;", "+\t\t\t\t\tif ((match = ((ArrayBinding)otherType).findSuperTypeWithSameErasure(erasedSuperType)) == null) {", "+\t\t\t\t\t\terasedSuperTypes[j] = null;", "+\t\t\t\t\t\tif (--remaining == 0) return null;", "+\t\t\t\t\t\tcontinue nextSuperType;", "-\t\t\t\t\terasedSuperTypes[j] = null;", "-\t\t\t\t\tif (--remaining == 0) return null;", "-\t\t\t\t\t", "+\t\t\t\t\t// record invocation", "+\t\t\t\t\tSet someInvocations = (Set) allInvocations.get(erasedSuperType);", "+\t\t\t\t\tif (someInvocations == null) someInvocations = new HashSet(1);", "+\t\t\t\t\tsomeInvocations.add(match);", "+\t\t\t\t\tallInvocations.put(erasedSuperType, someInvocations);", "-\t\t\t\t\tif (otherType.id == T_JavaLangObject && erasedSuperType.isInterface()) continue nextOtherType;", "+\t\t\t\t\t\tif (otherType.id == T_JavaLangObject && erasedSuperType.isInterface()) continue nextOtherType; // keep Object for an interface", "+\t\t\t\t\t} else if (erasedSuperType.isArrayType()) {", "+\t\t\t\t\tif (otherType.isArrayType() // keep Object[...] for an interface array (same dimensions)", "+\t\t\t\t\t\t\t&& otherType.leafComponentType().id == T_JavaLangObject", "+\t\t\t\t\t\t\t&& otherType.dimensions() == erasedSuperType.dimensions()", "+\t\t\t\t\t\t\t&& erasedSuperType.leafComponentType().isInterface()) continue nextOtherType;", "+\t\t\t\t\t\tif (((ArrayBinding)erasedSuperType).findSuperTypeWithSameErasure(otherType) != null) {", "+\t\t\t\t\t\t\terasedSuperTypes[j] = null; // discard non minimal supertype", "+\t\t\t\t\t\t\tremaining--;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70abf6040ca81aa8edfeb679a1529224", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "a81ccfc0bc8694879e3dd29554f4e34087f49572", "commitAfterChange": "090ebdc0744610fb4e5ac8b5b4731d3eafdb24fe", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "diff": ["+\t\tfinal int InsideExtdirs = 512;", "+\t\tfinal int InsideSourcepath = 1024;", "+", "-\t\tArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);", "-\t\tArrayList classpaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);", "+\t\tArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH),", "+\t\t\textdirsClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH),", "+\t\t\textdirsNames = new ArrayList(DEFAULT_SIZE_CLASSPATH),", "+\t\t\tsourcepathClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH),", "+\t\t\tclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);", "-\t\t\tif (currentArg.endsWith(\"]\") && !(mode == InsideBootClasspath || mode == InsideClasspath) ) { //$NON-NLS-1$ ", "+\t\t\tif (currentArg.endsWith(\"]\") && !(mode == InsideBootClasspath || mode == InsideClasspath || //$NON-NLS-1$ ", "+\t\t\t\t\tmode == InsideSourcepath) ) {", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-sourcepath\")) {//$NON-NLS-1$", "+\t\t\t\tif (sourcepathClasspaths.size() > 0)", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateSourcepath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tmode = InsideSourcepath;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-extdirs\")) {//$NON-NLS-1$", "+\t\t\t\tif (extdirsNames.size() > 0)", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateExtdirs\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tmode = InsideExtdirs;", "+\t\t\t// tolerated javac options - quietly filtered out", "+\t\t\tif (currentArg.startsWith(\"-X\")) { //$NON-NLS-1$", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.startsWith(\"-J\")) { //$NON-NLS-1$", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-O\")) { //$NON-NLS-1$", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (currentArg.equals(\"-sourcepath\")) {//$NON-NLS-1$", "+\t\t\t\tif (sourcepathClasspaths.size() > 0)", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateSourcepath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tmode = InsideSourcepath;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-extdirs\")) {//$NON-NLS-1$", "+\t\t\t\tif (extdirsNames.size() > 0)", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateExtdirs\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tmode = InsideExtdirs;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+", "-\t\t\tif (mode == InsideClasspath || mode == InsideBootClasspath) {", "+\t\t\tif (mode == InsideClasspath || mode == InsideBootClasspath || mode == InsideSourcepath) {", "+\t\t\t\t\t\t\taddNewEntry(InsideClasspath, InsideSourcepath, bootclasspaths, classpaths, sourcepathClasspaths, currentClasspathName, currentRuleSpecs, mode, customEncoding);", "-\t\t\t\t\t} else // regular word", "-\t\t\t\t\t{", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// regular word", "-\t\t\t\tif (state == readyToClose", "-\t\t\t\t\t\t|| state == readyToCloseEndingWithRules ", "-\t\t\t\t\t\t|| state == readyToCloseOrOtherEntry) {", "-\t\t\t\t\tAccessRule[] accessRules = new AccessRule[currentRuleSpecs", "-\t\t\t\t\t\t\t.size()];", "-\t\t\t\t\tboolean rulesOK = true;", "-\t\t\t\t\tIterator i = currentRuleSpecs.iterator();", "-\t\t\t\t\tint j = 0;", "-\t\t\t\t\twhile (i.hasNext()) {", "-\t\t\t\t\t\tString ruleSpec = (String) i.next();", "-\t\t\t\t\t\tchar key = ruleSpec.charAt(0);", "-\t\t\t\t\t\tString pattern = ruleSpec.substring(1);", "-\t\t\t\t\t\tif (pattern.length() > 0) {", "-\t\t\t\t\t\t\tswitch (key) {", "-\t\t\t\t\t\t\tcase '+':", "-\t\t\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t\t\t\t.toCharArray(), -1);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase '~':", "-\t\t\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\t\t\t\t\tIProblem.DiscouragedReference);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase '-':", "-\t\t\t\t\t\t\t\taccessRules[j++] = new AccessRule(pattern", "-\t\t\t\t\t\t\t\t\t\t.toCharArray(),", "-\t\t\t\t\t\t\t\t\t\tIProblem.ForbiddenReference);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\trulesOK = false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\trulesOK = false;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (rulesOK) {", "-\t\t\t\t\t\tAccessRuleSet accessRuleSet = new AccessRuleSet(", "-\t\t\t\t\t\t\t\taccessRules, \"{0}\"); //$NON-NLS-1$", "-\t\t\t\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "-\t\t\t\t\t\t\t\t.getClasspath(currentClasspathName,", "-\t\t\t\t\t\t\t\t\t\tcustomEncoding, 0, accessRuleSet);", "-\t\t\t\t\t\tif (currentClasspath != null) {", "-\t\t\t\t\t\t\tif (mode == InsideClasspath) {", "-\t\t\t\t\t\t\t\tclasspaths.add(currentClasspath);", "-\t\t\t\t\t\t\t} else { // inside bootclasspath", "-\t\t\t\t\t\t\t\tbootclasspaths.add(currentClasspath);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.logger.logIncorrectClasspath(currentArg);", "-\t\t\t\t\t\t\t// we go on anyway", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.logger.logIncorrectClasspath(currentArg);", "+\t\t\t\tswitch(state) {", "+\t\t\t\t\tcase readyToClose :", "+\t\t\t\t\tcase readyToCloseEndingWithRules :", "+\t\t\t\t\tcase readyToCloseOrOtherEntry :", "+\t\t\t\t\t\taddNewEntry(InsideClasspath, InsideSourcepath, bootclasspaths, classpaths, sourcepathClasspaths, currentClasspathName, currentRuleSpecs, mode, customEncoding);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.logger.logIncorrectClasspath(currentArg);", "-\t\t\t\t\t// we go on anyway", "+\t\t\t\t\t\tthis.logger.logIncorrectClasspath(currentArg);", "+\t\t\tif (mode == InsideExtdirs) {", "+\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(currentArg,\tFile.pathSeparator, false);", "+\t\t\t\twhile (tokenizer.hasMoreTokens())", "+\t\t\t\t\textdirsNames.add(tokenizer.nextToken());", "+\t\t\t\tif (extdirsNames.size() == 0) // empty entry", "+\t\t\t\t\textdirsNames.add(\"\"); //$NON-NLS-1$", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+", "-\t\tif (bootclasspaths.size() == 0) {", "+\t \t if (bootclasspaths.size() == 0) {", "-\t\t \t String javaHome = System.getProperty(\"java.home\");//$NON-NLS-1$", "-\t\t \t if (javaHome != null) {", "-\t\t \t \tFile javaHomeFile = new File(javaHome);", "-\t\t \t \tif (javaHomeFile.exists()) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tjavaHomeFile = new File(javaHomeFile.getCanonicalPath());", "-\t\t\t\t\t\t// add all jars in the lib subdirectory", "-\t\t\t\t\t\tFile[] directoriesToCheck = new File[] { new File(javaHomeFile, \"lib\"), new File(javaHomeFile, \"lib/ext\")};//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "-\t\t\t\t\t\tif (systemLibrariesJars != null) {", "-\t\t\t\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "-\t\t\t\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "-\t\t\t\t\t\t\t\tif (current != null) {", "-\t\t\t\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\t\t\t\t\tFileSystem.Classpath classpath = ", "-\t\t\t\t\t\t\t\t\t\t\tFileSystem.getClasspath(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tcurrent[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\t\t\t\t\tnull, 0, null); ", "-\t\t\t\t\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "+\t\t \t if (getJavaHome() != null) {", "+\t\t\t\tFile[] directoriesToCheck = new File[] { ", "+\t\t\t\t\t\tnew File(getJavaHome(), \"lib\") //$NON-NLS-1$", "+\t\t\t\t\t\t};", "+\t\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "+\t\t\t\tif (systemLibrariesJars != null) {", "+\t\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "+\t\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "+\t\t\t\t\t\tif (current != null) {", "+\t\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "+\t\t\t\t\t\t\t\tFileSystem.Classpath classpath = ", "+\t\t\t\t\t\t\t\t\tFileSystem.getClasspath(", "+\t\t\t\t\t\t\t\t\t\t\tcurrent[j].getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\t\t\tnull, 0, null); ", "+\t\t\t\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "-\t\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t\t// cannot retrieve libraries", "-\t\t \t \t}", "-\t\t \t }", "+\t\t\t\t}", "+\t \t\t}", "+\t \t }", "+\t\t", "+\t\t/*", "+\t\t * Feed extdirsNames according to:", "+\t\t * - -extdirs first if present;", "+\t\t * - else java.ext.dirs if defined;", "+\t\t * - else default extensions directory for the platform.", "+\t\t */", "+\t\tif (extdirsNames.size() == 0) {", "+\t\t\tString extdirsStr = System.getProperty(\"java.ext.dirs\"); //$NON-NLS-1$", "+\t\t\tif (extdirsStr == null) {", "+\t\t\t\textdirsNames.add(getJavaHome().getAbsolutePath() + \"/lib/ext\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(extdirsStr, File.pathSeparator);", "+\t\t\t\twhile (tokenizer.hasMoreTokens()) ", "+\t\t\t\t\textdirsNames.add(tokenizer.nextToken());", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t/*", "+\t\t * Feed extdirsClasspath with the entries found into the directories listed by", "+\t\t * extdirsNames.", "+\t\t */", "+\t\tif (extdirsNames.size() != 0) {", "+\t\t\tFile[] directoriesToCheck = new File[extdirsNames.size()];", "+\t\t\tfor (int i = 0; i < directoriesToCheck.length; i++) ", "+\t\t\t\tdirectoriesToCheck[i] = new File((String) extdirsNames.get(i));", "+\t\t\tFile[][] extdirsJars = getLibrariesFiles(directoriesToCheck);", "+\t\t\tif (extdirsJars != null) {", "+\t\t\t\tfor (int i = 0, max = extdirsJars.length; i < max; i++) {", "+\t\t\t\t\tFile[] current = extdirsJars[i];", "+\t\t\t\t\tif (current != null) {", "+\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "+\t\t\t\t\t\t\tFileSystem.Classpath classpath = ", "+\t\t\t\t\t\t\t\tFileSystem.getClasspath(", "+\t\t\t\t\t\t\t\t\t\tcurrent[j].getAbsolutePath(),", "+\t\t\t\t\t\t\t\t\t\tnull, 0, null); ", "+\t\t\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\t\t\textdirsClasspaths.add(classpath);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t\t * We put the bootclasspath at the beginning of the classpath entries", "+\t\t * Concatenate classpath entries", "+\t\t * We put the bootclasspath at the beginning of the classpath", "+\t\t * entries, followed by the extension libraries, followed by", "+\t\t * the sourcepath followed by the classpath.  All classpath", "+\t\t * entries are searched for both sources and binaries except", "+\t\t * the sourcepath entries which are searched for sources only.", "+\t\tbootclasspaths.addAll(extdirsClasspaths);", "+\t\tbootclasspaths.addAll(sourcepathClasspaths);"]}], "num": 24564}