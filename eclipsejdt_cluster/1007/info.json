{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d69ab3810a3acdbb4ba2607763f43929", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30a28430bf304d3d5ae7631682dc9840", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "  private void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-", "-\tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "-\t\t", "-\t\tclassFile.generateMethodInfoHeader(binding);", "-\t\tint methodAttributeOffset = classFile.contentsOffset;", "-\t\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "-\t\tif ((!binding.isNative()) && (!binding.isAbstract())) {", "-\t\t\t", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;", "-\t\t\tclassFile.generateCodeAttributeHeader();", "-\t\t\tCodeStream codeStream = classFile.codeStream;", "-\t\t\tcodeStream.reset(this, classFile);", "-", "-\t\t\t// initialize local positions - including initializer scope.", "-\t\t\tReferenceBinding declaringClass = binding.declaringClass;", "-", "-\t\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "-\t\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "-", "-\t\t\tif (declaringClass.isNestedType()){", "-\t\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "-\t\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "-\t\t\t\tscope.computeLocalVariablePositions(// consider synthetic arguments if any", "-\t\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "-\t\t\t\t\tcodeStream);", "-\t\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "-\t\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "-\t\t\t} else {", "-\t\t\t\tscope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "-\t\t\t}", "-\t\t\t\t", "-\t\t\tif (arguments != null) {", "-\t\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "-\t\t\t\t\t// arguments initialization for local variable debug attributes", "-\t\t\t\t\tLocalVariableBinding argBinding;", "-\t\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = arguments[i].binding);", "-\t\t\t\t\targBinding.recordInitializationStartPC(0);", "-\t\t\t\t\tTypeBinding argType;", "-\t\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\targSlotSize += 2;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\targSlotSize++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\tMethodScope initializerScope = declaringType.initializerScope;", "-\t\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "-", "-\t\t\tboolean needFieldInitializations = constructorCall == null || constructorCall.accessMode != ExplicitConstructorCall.This;", "-", "-\t\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "-\t\t\tboolean preInitSyntheticFields = scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "-", "-\t\t\tif (needFieldInitializations && preInitSyntheticFields){", "-\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t}\t\t\t", "-\t\t\t// generate constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\tconstructorCall.generateCode(scope, codeStream);", "-\t\t\t}", "-\t\t\t// generate field initialization - only if not invoking another constructor call of the same class", "-\t\t\tif (needFieldInitializations) {", "-\t\t\t\tif (!preInitSyntheticFields){", "-\t\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t\t}", "-\t\t\t\t// generate user field initialization", "-\t\t\t\tif (declaringType.fields != null) {", "-\t\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "-\t\t\t\t\t\tFieldDeclaration fieldDecl;", "-\t\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// generate statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++) {", "-\t\t\t\t\tstatements[i].generateCode(scope, codeStream);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (this.needFreeReturn) {", "-\t\t\t\tcodeStream.return_();", "-\t\t\t}", "-\t\t\t// local variable attributes", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "-\t\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "-\t\t\tattributeNumber++;", "-\t\t}", "-\t\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "-", "-\t\t// if a problem got reported during code gen, then trigger problem method creation", "-\t\tif (ignoreFurtherInvestigation) {", "-\t\t\tthrow new AbortMethod(scope.referenceCompilationUnit().compilationResult, null);", "-\t\t}", "-\t}", "+", "+private void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "+\tclassFile.generateMethodInfoHeader(this.binding);", "+\tint methodAttributeOffset = classFile.contentsOffset;", "+\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "+\tif ((!this.binding.isNative()) && (!this.binding.isAbstract())) {", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;", "+\t\tint codeAttributeOffset = classFile.contentsOffset;", "+\t\tclassFile.generateCodeAttributeHeader();", "+\t\tCodeStream codeStream = classFile.codeStream;", "+\t\tcodeStream.reset(this, classFile);", "+\t\t// initialize local positions - including initializer scope.", "+\t\tReferenceBinding declaringClass = this.binding.declaringClass;", "+\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "+\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "+\t\tif (declaringClass.isNestedType()){", "+\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "+\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "+\t\t\tthis.scope.computeLocalVariablePositions(// consider synthetic arguments if any", "+\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "+\t\t\t\tcodeStream);", "+\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "+\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "+\t\t} else {", "+\t\t\tthis.scope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "+\t\t\t", "+\t\tif (this.arguments != null) {", "+\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t// arguments initialization for local variable debug attributes", "+\t\t\t\tLocalVariableBinding argBinding;", "+\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = this.arguments[i].binding);", "+\t\t\t\targBinding.recordInitializationStartPC(0);", "+\t\t\t\tTypeBinding argType;", "+\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "+\t\t\t\t\targSlotSize += 2;", "+\t\t\t\t} else {", "+\t\t\t\t\targSlotSize++;", "+\t\t", "+\t\tMethodScope initializerScope = declaringType.initializerScope;", "+\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "+", "+\t\tboolean needFieldInitializations = this.constructorCall == null || this.constructorCall.accessMode != ExplicitConstructorCall.This;", "+", "+\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "+\t\tboolean preInitSyntheticFields = this.scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "+", "+\t\tif (needFieldInitializations && preInitSyntheticFields){", "+\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t}\t\t\t", "+\t\t// generate constructor call", "+\t\tif (this.constructorCall != null) {", "+\t\t\tthis.constructorCall.generateCode(this.scope, codeStream);", "+\t\t}", "+\t\t// generate field initialization - only if not invoking another constructor call of the same class", "+\t\tif (needFieldInitializations) {", "+\t\t\tif (!preInitSyntheticFields){", "+\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t\t}", "+\t\t\t// generate user field initialization", "+\t\t\tif (declaringType.fields != null) {", "+\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "+\t\t\t\t\tFieldDeclaration fieldDecl;", "+\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "+\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// generate statements", "+\t\tif (this.statements != null) {", "+\t\t\tfor (int i = 0, max = this.statements.length; i < max; i++) {", "+\t\t\t\tthis.statements[i].generateCode(this.scope, codeStream);", "+\t\t\t}", "+\t\t}", "+\t\tif (this.needFreeReturn) {", "+\t\t\tcodeStream.return_();", "+\t\t}", "+\t\t// local variable attributes", "+\t\tcodeStream.exitUserScope(this.scope);", "+\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "+\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "+\t\tattributeNumber++;", "+\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "+", "+\t// if a problem got reported during code gen, then trigger problem method creation", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tthrow new AbortMethod(this.scope.referenceCompilationUnit().compilationResult, null);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c61b31b67f6f222ae24d7cc5e49be0a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["- */\r", "-public void generateCode(ClassScope classScope, ClassFile classFile) {\r", "-\tint clinitOffset = 0;\r", "-\tif (ignoreFurtherInvestigation) {\r", "-\t\t// should never have to add any <clinit> problem method\r", "-\t\treturn;\r", "-\t}\r", "-\ttry {\r", "-\t\tclinitOffset = classFile.contentsOffset;\r", "-\t\tConstantPool constantPool = classFile.constantPool;\r", "-\t\tint constantPoolOffset = constantPool.currentOffset;\r", "-\t\tint constantPoolIndex = constantPool.currentIndex;\r", "-\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "-\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\tcodeStream.reset(this, classFile);\r", "-\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "-\t\t// initialize local positions - including initializer scope.\r", "-\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "-\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "-\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream); // offset by the argument size\r", "-\r", "-\t\t// generate initializers\r", "-\t\tif (declaringType.fields != null) {\r", "-\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "-\t\t\t\tFieldDeclaration fieldDecl;\r", "-\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "-\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "-\t\tif (codeStream.position == 0) {\r", "-\t\t\t// do not need to output a Clinit if no bytecodes\r", "-\t\t\t// so we reset the offset inside the byte array contents.\r", "-\t\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "-\t\t\tclassFile.methodCount--;\r", "-\t\t\t// reset the constant pool to its state before the clinit\r", "-\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "-\t\t} else {\r", "-\t\t\tif (needFreeReturn) {\r", "-\t\t\t\tint oldPosition = codeStream.position;\r", "-\t\t\t\tcodeStream.return_();\r", "-\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "-\t\t\t}\r", "-\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "-\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "-\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "-\t\t}\r", "-\t} catch (AbortMethod e) {\r", "-\t\t// should never occur\r", "-\t\t// the clinit referenceContext is the type declaration\r", "-\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "-\t\t// reset the contentsOffset to the value before generating the clinit code\r", "-\t\t// decrement the number of method info as well.\r", "-\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "-\t\t// cases.\r", "-\t\tclassFile.contentsOffset = clinitOffset;\r", "-\t\tclassFile.methodCount--;\t\r", "-}\r", "+\t */\r", "+\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {\r", "+\t\tint clinitOffset = 0;\r", "+\t\tif (ignoreFurtherInvestigation) {\r", "+\t\t\t// should never have to add any <clinit> problem method\r", "+\t\t\treturn;\r", "+\t\t}\r", "+\t\ttry {\r", "+\t\t\tclinitOffset = classFile.contentsOffset;\r", "+\t\t\tConstantPool constantPool = classFile.constantPool;\r", "+\t\t\tint constantPoolOffset = constantPool.currentOffset;\r", "+\t\t\tint constantPoolIndex = constantPool.currentIndex;\r", "+\t\t\tclassFile.generateMethodInfoHeaderForClinit();\r", "+\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "+\t\t\tclassFile.generateCodeAttributeHeader();\r", "+\t\t\tCodeStream codeStream = classFile.codeStream;\r", "+\t\t\tthis.resolve(classScope);\r", "+\t\t\tcodeStream.reset(this, classFile);\r", "+\t\t\tTypeDeclaration declaringType = classScope.referenceContext;\r", "+\r", "+\t\t\t// initialize local positions - including initializer scope.\r", "+\t\t\tscope.computeLocalVariablePositions(0, codeStream); // should not be necessary\r", "+\t\t\tMethodScope staticInitializerScope = declaringType.staticInitializerScope;\r", "+\t\t\tstaticInitializerScope.computeLocalVariablePositions(0, codeStream);\r", "+\t\t\t// offset by the argument size\r", "+\r", "+\t\t\t// 1.4 feature\r", "+\t\t\t// This has to be done before any other initialization\r", "+\t\t\tif (this.assertionSyntheticFieldBinding != null) {\r", "+\t\t\t\t// generate code related to the activation of assertion for this class\r", "+\t\t\t\tcodeStream.generateClassLiteralAccessForType(\r", "+\t\t\t\t\tclassScope.enclosingSourceType(),\r", "+\t\t\t\t\tclassLiteralSyntheticField);\r", "+\t\t\t\tcodeStream.invokeJavaLangClassDesiredAssertionStatus();\r", "+\t\t\t\tLabel falseLabel = new Label(codeStream);\r", "+\t\t\t\tcodeStream.ifne(falseLabel);\r", "+\t\t\t\tcodeStream.iconst_1();\r", "+\t\t\t\tLabel jumpLabel = new Label(codeStream);\r", "+\t\t\t\tcodeStream.goto_(jumpLabel);\r", "+\t\t\t\tfalseLabel.place();\r", "+\t\t\t\tcodeStream.iconst_0();\r", "+\t\t\t\tjumpLabel.place();\r", "+\t\t\t\tcodeStream.putstatic(this.assertionSyntheticFieldBinding);\r", "+\t\t\t}\r", "+\t\t\t// generate initializers\r", "+\t\t\tif (declaringType.fields != null) {\r", "+\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {\r", "+\t\t\t\t\tFieldDeclaration fieldDecl;\r", "+\t\t\t\t\tif ((fieldDecl = declaringType.fields[i]).isStatic()) {\r", "+\t\t\t\t\t\tfieldDecl.generateCode(staticInitializerScope, codeStream);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tif (codeStream.position == 0) {\r", "+\t\t\t\t// do not need to output a Clinit if no bytecodes\r", "+\t\t\t\t// so we reset the offset inside the byte array contents.\r", "+\t\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\t\t// like we don't addd a method we need to undo the increment on the method count\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\t// reset the constant pool to its state before the clinit\r", "+\t\t\t\tconstantPool.resetForClinit(constantPoolIndex, constantPoolOffset);\r", "+\t\t\t} else {\r", "+\t\t\t\tif (needFreeReturn) {\r", "+\t\t\t\t\tint oldPosition = codeStream.position;\r", "+\t\t\t\t\tcodeStream.return_();\r", "+\t\t\t\t\tcodeStream.updateLocalVariablesAttribute(oldPosition);\r", "+\t\t\t\t}\r", "+\t\t\t\t// Record the end of the clinit: point to the declaration of the class\r", "+\t\t\t\tcodeStream.recordPositionsFrom(0, declaringType);\r", "+\t\t\t\tclassFile.completeCodeAttributeForClinit(codeAttributeOffset);\r", "+\t\t\t}\r", "+\t\t} catch (AbortMethod e) {\r", "+\t\t\t// should never occur\r", "+\t\t\t// the clinit referenceContext is the type declaration\r", "+\t\t\t// All clinit problems will be reported against the type: AbortType instead of AbortMethod\r", "+\t\t\t// reset the contentsOffset to the value before generating the clinit code\r", "+\t\t\t// decrement the number of method info as well.\r", "+\t\t\t// This is done in the addProblemMethod and addProblemConstructor for other\r", "+\t\t\t// cases.\r", "+\t\t\tclassFile.contentsOffset = clinitOffset;\r", "+\t\t\tclassFile.methodCount--;\r", "+\t\t}\r", "+\t}\r"]}], "num": 1007}