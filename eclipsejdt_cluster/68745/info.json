{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "06bcf0bee50dcd0f1458096d31852619", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16a176506bba880c52bfef4e5647f506", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "9fd5428ce736a6251b7049cd29424ae48e74034b", "commitAfterChange": "462fdbe66c95fe469d26ca4c9a495870e5915168", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " private FlowInfo addInfoFrom(FlowInfo inits, boolean handleInits)", "signatureAfterChange": " private FlowInfo addInfoFrom(FlowInfo inits, boolean handleInits)", "diff": ["-\t\t\tlong merge1 = (b1 = otherInits.nullBit1)", "-                \t\t\t\t| (a1 = this.nullBit1) & ((a3 = this.nullBit3)", "-                \t\t\t\t\t& (a4 = this.nullBit4) & (nb2 = ~(b2 = otherInits.nullBit2))", "+\t\t\ta1 = this.nullBit1;", "+\t\t\ta2 = this.nullBit2;", "+\t\t\ta3 = this.nullBit3;", "+\t\t\ta4 = this.nullBit4;", "+", "+\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "+\t\t\tlong protNN1111 = a1&a2&a3&a4;", "+", "+\t\t\t// filter 'a' using iNBit,iNNBit from otherInits:", "+\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "+\t\t\tlong acceptNonNull = otherInits.iNNBit;", "+\t\t\tlong acceptNull = otherInits.iNBit", "+\t\t\t\t\t\t\t\t| protNN1111; // for 1111 don't bother suppressing incoming null, logic operation would produce wrong result", "+\t\t\tlong dontResetToStart = ~protNN1111 | acceptNonNull; // for 1111 & ~acceptNonNull we reset all bits to 0000", "+", "+\t\t\ta1 &= dontResetToStart;", "+\t\t\ta2 = dontResetToStart & acceptNull & a2;", "+\t\t\ta3 = dontResetToStart & acceptNonNull & a3;", "+\t\t\ta4 &= dontResetToStart;", "+\t\t\ta1 &= (a2 | a3 | a4);\t\t// translate 1000 (undefined state) to 0000", "+\t\t\t", "+\t\t\tthis.nullBit1 = (b1 = otherInits.nullBit1)", "+                \t\t\t\t| a1 & (a3", "+                \t\t\t\t\t& a4 & (nb2 = ~(b2 = otherInits.nullBit2))", "-                        \t\t\t& ((na2 = ~(a2 = this.nullBit2)) & nb2", "+                        \t\t\t& ((na2 = ~a2) & nb2", "-\t\t\tlong merge2  = b2 & (nb4 | nb3)", "+\t\t\tthis.nullBit2  = b2 & (nb4 | nb3)", "-\t\t\tlong merge3 = b3 & (nb1 & (b2 | a2 | na1)", "+\t\t\tthis.nullBit3 = b3 & (nb1 & (b2 | a2 | na1)", "-\t\t\tlong merge4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+\t\t\tthis.nullBit4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "-\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "-\t\t\tlong protNN1111 = merge1&merge2&merge3&merge4;", "-", "-\t\t\t// filter 'merge' using iNBit,iNNBit from otherInits:", "-\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "-\t\t\tlong acceptNonNull = otherInits.iNNBit;", "-\t\t\tlong acceptNull = otherInits.iNBit", "-\t\t\t\t\t\t\t\t| b1&b2&b3&b4; // for 1111 don't bother suppressing incoming null (mixing 'merge' & 'b' would break in this case) ", "-\t\t\tthis.nullBit1 = merge1;", "-\t\t\tthis.nullBit2 = protNN1111 |", "-\t\t\t\t \t\t\t\t((acceptNull & merge2) | (~acceptNull & b2)); // iNBit selects between info from merge2 vs. b2", "-\t\t\tthis.nullBit3 = protNN1111 |", "-\t\t\t\t\t\t\t\t((acceptNonNull & merge3) | (~acceptNonNull & b3)); // iNNBit selects between info from merge3 vs. b3", "-\t\t\tthis.nullBit4 = merge4;", "-\t\t\tlong merge1 = (b1 = otherInits.extra[1 + 1][i])", "-                \t\t\t\t| (a1 = this.extra[1 + 1][i]) & ((a3 = this.extra[3 + 1][i])", "-                \t\t\t\t\t& (a4 = this.extra[4 + 1][i]) & (nb2 = ~(b2 = otherInits.extra[2 + 1][i]))", "+\t\t\ta1 = this.extra[1 + 1][i];", "+\t\t\ta2 = this.extra[2 + 1][i];", "+\t\t\ta3 = this.extra[3 + 1][i];", "+\t\t\ta4 = this.extra[4 + 1][i];", "+\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "+\t\t\tlong protNN1111 = a1&a2&a3&a4;", "+", "+\t\t\t// filter 'a' using iNBit,iNNBit from otherInits:", "+\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "+\t\t\tlong acceptNonNull = otherInits.extra[INN][i];", "+\t\t\tlong acceptNull = otherInits.extra[IN][i]", "+\t\t\t\t\t\t\t\t| protNN1111; // for 1111 don't bother suppressing incoming null, logic operation would produce wrong result", "+\t\t\tlong dontResetToStart = ~protNN1111 | acceptNonNull; // for 1111 & ~acceptNonNull we reset all bits to 0000", "+", "+\t\t\ta1 &= dontResetToStart;", "+\t\t\ta2 = dontResetToStart & acceptNull & a2;", "+\t\t\ta3 = dontResetToStart & acceptNonNull & a3;", "+\t\t\ta4 &= dontResetToStart;", "+\t\t\ta1 &= (a2 | a3 | a4);\t\t// translate 1000 (undefined state) to 0000", "+", "+\t\t\tthis.extra[1 + 1][i] = (b1 = otherInits.extra[1 + 1][i])", "+                \t\t\t\t| a1 & (a3 ", "+                \t\t\t\t\t& a4 & (nb2 = ~(b2 = otherInits.extra[2 + 1][i]))", "-                        \t\t\t& ((na2 = ~(a2 = this.extra[2 + 1][i])) & nb2", "+                        \t\t\t& ((na2 = ~a2) & nb2", "-\t\t\tlong merge2 = b2 & (nb4 | nb3)", "+\t\t\tthis.extra[2 + 1][i] = b2 & (nb4 | nb3)", "-\t\t\tlong merge3 = b3 & (nb1 & (b2 | a2 | na1)", "+\t\t\tthis.extra[3 + 1][i] = b3 & (nb1 & (b2 | a2 | na1)", "-\t\t\tlong merge4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+\t\t\tthis.extra[4 + 1][i] = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "-\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "-\t\t\tlong protNN1111 = merge1&merge2&merge3&merge4;", "-", "-\t\t\t// filter 'merge' using iNBit,iNNBit from otherInits:", "-\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "-\t\t\tlong acceptNonNull = otherInits.extra[INN][i];", "-\t\t\tlong acceptNull = otherInits.extra[IN][i]", "-\t\t\t\t\t\t\t\t| b1&b2&b3&b4; // for 1111 don't bother suppressing incoming null (mixing 'merge' & 'b' would break in this case) ", "-\t\t\tthis.extra[1 + 1][i] = merge1;", "-\t\t\tthis.extra[2 + 1][i] = protNN1111 |", "-\t\t\t\t \t\t\t\t((acceptNull & merge2) | (~acceptNull & b2)); // iNBit selects between info from merge2 vs. b2", "-\t\t\tthis.extra[3 + 1][i] = protNN1111 |", "-\t\t\t\t\t\t\t\t((acceptNonNull & merge3) | (~acceptNonNull & b3)); // iNNBit selects between info from merge3 vs. b3", "-\t\t\tthis.extra[4 + 1][i] = merge4;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "22000dd7768149eb110465d139692778", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "ec36c5b556303647a122217dbc357a0c1ccafd42", "commitAfterChange": "a25cead90931bbc9548552bec95aa6f79a389aa3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "signatureAfterChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "diff": ["-\t\t\t\t\t\tif (expressionType instanceof ReferenceBinding) {", "-\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\t\t\tif (match == null) {", "-\t\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, null, true);", "+\t\t\t\t\t\tTypeBinding match = expressionType.findSuperTypeWithSameErasure(castType);", "+\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "-\t\t\t\tif (castType instanceof ReferenceBinding) {", "-\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\tif (match != null) {", "-\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\tTypeBinding match = expressionType.findSuperTypeWithSameErasure(castType);", "+\t\t\t\tif (match != null) {", "+\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\tif (castType instanceof ReferenceBinding) {", "-\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\tif (match != null) {", "-\t\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\tmatch = expressionType.findSuperTypeWithSameErasure(castType);", "+\t\t\t\tif (match != null) {", "+\t\t\t\t\treturn checkUnsafeCast(scope, castType, expressionType, match, false);", "-\t\t\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "+\t\t\t\t\t\t\tmatch = expressionType.findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeWithSameErasure(interfaceType);", "+\t\t\t\t\t\t\t\tmatch = castType.findSuperTypeWithSameErasure(interfaceType);", "-\t\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeWithSameErasure(expressionType);", "+\t\t\t\t\t\t\t\t\tmatch = castType.findSuperTypeWithSameErasure(expressionType);", "-\t\t\t\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "+\t\t\t\t\t\t\tmatch = expressionType.findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeWithSameErasure(expressionType);", "+\t\t\t\t\t\t\t\tmatch = castType.findSuperTypeWithSameErasure(expressionType);", "-\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)expressionType).findSuperTypeWithSameErasure(castType);", "+\t\t\t\t\t\t\t\tmatch = expressionType.findSuperTypeWithSameErasure(castType);", "-\t\t\t\t\t\t\t\tmatch = ((ReferenceBinding)castType).findSuperTypeWithSameErasure(expressionType);", "+\t\t\t\t\t\t\t\tmatch = castType.findSuperTypeWithSameErasure(expressionType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f429b09973381d024d7934dc3ff60c7c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "35d3c94bac1e2208a31f158b8d7e6058b35282e2", "commitAfterChange": "2b6f2c5ab69f56c08d444fe8672c8fe1596db9c2", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprotected void setSourceComment(char[] source) throws ArrayIndexOutOfBoundsException", "signatureAfterChange": " \tprotected void setSourceComment(char[] source) throws ArrayIndexOutOfBoundsException", "diff": ["-\t\tthis.comments = new ArrayList();", "-\t\tthis.allTags = new ArrayList();", "+\t\tcomments = new ArrayList();", "+\t\tallTags = new ArrayList();", "-\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\t\t\telse buffer.append(chars);", "-\t\t\t\t\t\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\t\t\t\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\t\t\t\t\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\t\t\t\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\t\t\t\t\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\t\t\t\t\ti += (this.chars==null) ? 1 : this.chars.length();", "+\t\t\t\t\t\t\t\t\t\t\ti += (chars==null) ? 1 : chars.length();", "-\t\t\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\t\t\telse buffer.append(chars);", "-\t\t\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\t\t\telse buffer.append(chars);", "-\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\telse buffer.append(chars);", "-\t\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\t\telse buffer.append(this.chars);", "-\t\t\t\t\t\tthis.comments.add(buffer.toString());", "-\t\t\t\t\t\tthis.allTags.add(new ArrayList());", "+\t\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\t\telse buffer.append(chars);", "+\t\t\t\t\t\tcomments.add(buffer.toString());", "+\t\t\t\t\t\tallTags.add(new ArrayList());", "-\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\telse buffer.append(chars);", "-\t\t\t\t\t\tthis.comments.add(buffer.toString());", "-\t\t\t\t\t\tthis.allTags.add(tags);", "+\t\t\t\t\t\tcomments.add(buffer.toString());", "+\t\t\t\t\t\tallTags.add(tags);", "-\t\t\t\t\t\tthis.comments.add(buffer.toString());", "-\t\t\t\t\t\tthis.allTags.add(tags);", "+\t\t\t\t\t\tcomments.add(buffer.toString());", "+\t\t\t\t\t\tallTags.add(tags);", "-\t\t\t\t\t\tif (this.chars == null) buffer.append(currentChar);", "-\t\t\t\t\t\telse buffer.append(this.chars);", "+\t\t\t\t\t\tif (chars == null) buffer.append(currentChar);", "+\t\t\t\t\t\telse buffer.append(chars);"]}], "num": 68745}