{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dc08a07689376d05cdf4b22f40b27ea4", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03ab69315f44ac730df6d2e4712c75ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "ed03b97e41cec71a1f276a24a6c89d537dde57f2", "commitAfterChange": "3617e411ab09a4b93e5840b8e6d451f0c6a8a8c9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["+\t\t// curentMethod is always resolved as its defined by the source type BUT the inheritedMethod may not be", "+\t\t// so now with generics, the inheritedMethod should be resolved since we don't want to waste time dealing", "+\t\t// with Unresolved types over & over", "+\t\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "+", "+\t\t// must check each parameter pair to see if you have raw to parameterized conversions", "+\t\tTypeBinding[] currentArgs = currentMethod.parameters;", "+\t\tTypeBinding[] inheritedArgs = inheritedMethod.parameters;", "+\t\tif (currentArgs != inheritedArgs) {", "+\t\t\tfor (int j = 0, k = currentArgs.length; j < k; j++) {", "+\t\t\t\tTypeBinding currentArg = currentArgs[j];", "+\t\t\t\tTypeBinding inheritedArg = inheritedArgs[j];", "+\t\t\t\tif (currentArg != inheritedArg) {", "+\t\t\t\t\tif (inheritedArg.isArrayType()) {", "+\t\t\t\t\t\tinheritedArg = inheritedArg.leafComponentType();", "+\t\t\t\t\t\tcurrentArg = currentArg.leafComponentType();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (inheritedArg.isRawType()) {", "+\t\t\t\t\t\tif (currentArg.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) currentArg)) {", "+\t\t\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+", "-\t\tif (!super.areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "+\t\tif (currentMethod.returnType != inheritedMethod.returnType) {", "-\t\t\t} else if (inheritedMethod.typeVariables.length != currentMethod.typeVariables.length) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-//\t\t\t\tthis.problemReporter(currentMethod).nameClash(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "+\t\t\t}", "+", "+\t\t\tTypeBinding inheritedReturnType = inheritedMethod.returnType;", "+\t\t\tTypeBinding returnType = currentMethod.returnType;", "+\t\t\tif (inheritedReturnType.isArrayType()) {", "+\t\t\t\tinheritedReturnType = inheritedReturnType.leafComponentType();", "+\t\t\t\treturnType = returnType.leafComponentType();", "+\t\t\t}", "+\t\t\tif (inheritedReturnType.isRawType()) {", "+\t\t\t\tif (returnType.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) returnType)) {", "+\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "+\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t}", "+\t\t\t} else if (inheritedReturnType.isParameterizedType()) {", "+\t\t\t\tif (!returnType.isParameterizedType())", "+\t\t\t\t\tthis.problemReporter(currentMethod).returnTypeUncheckedConversion(currentMethod, inheritedMethod);", "+\t\t\t} else if (inheritedReturnType.isTypeVariable()) {", "+\t\t\t\tthis.problemReporter(currentMethod).returnTypeUncheckedConversion(currentMethod, inheritedMethod);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e7018623002c3029c09b85961ef69fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "1cdb6c1b0fb5ba08d4e282b871474685ab8baf3f", "commitAfterChange": "c3fe3a5d67fbf0c540d6fc63f233f6806516af9c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] otherInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] otherInheritedMethods)", "diff": ["+\t\tif (isAnnotationMember) { // annotation cannot override any method", "+\t\t\tproblemReporter().annotationCannotOverrideMethod(currentMethod, inheritedMethod);", "+\t\t\treturn; // do not repoort against subsequent inherited methods", "+\t\t}", "+\t\t\tcontinue nextMethod;", "+\t\t}", "+\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "+\t\t\tproblemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\tif (isAnnotationMember) {", "-\t\t\t// annotation cannot override any method", "-\t\t\tproblemReporter().annotationCannotOverrideMethod(currentMethod, inheritedMethod);", "-\t\t\treturn; // do not repoort against subsequent inherited methods", "-\t\t}\t\t", "-\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "-\t\t\tproblemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t} else {", "-\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "-\t\t\tif (inheritedMethod.isFinal())", "-\t\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "+\t\tif (inheritedMethod.isFinal())", "+\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "+\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t\t}", "+\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\tcheckForBridgeMethod(currentMethod, inheritedMethod, otherInheritedMethods);", "+\t\tcheckForBridgeMethod(currentMethod, inheritedMethod, otherInheritedMethods);"]}], "num": 56609}