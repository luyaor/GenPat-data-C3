{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8d622cb79500eafb1021c2bab3234ca3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b11efa9f97b4b47907465742b59a1215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "a0e794820a3e45ac013c44e55b82e935802d5378", "commitAfterChange": "a06fd70a66cd192fe200df3baf9406d9e87b6313", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "signatureAfterChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "diff": ["-\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, true);", "+\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, replaceWildcards);", "-\t\tTypeBinding [] typeArguments = this.arguments; // A1 ... An", "-\t\tif (typeArguments == null)", "-\t\t\ttypeArguments = Binding.NO_TYPES;", "-\t\tTypeVariableBinding [] typeParameters = genericType.typeVariables(); // P1 ... Pn", "-\t\tTypeBinding [] types = new TypeBinding[typeArguments.length];  // T1 ... Tn", "-\t\tfor (int i = 0, length = typeArguments.length; i < length; i++) {", "-\t\t\tTypeBinding typeArgument = typeArguments[i];", "-\t\t\tif (replaceWildcards && typeArgument.kind() == Binding.WILDCARD_TYPE) {", "-\t\t\t\tif (typeParameters[i].mentionsAny(typeParameters, i))", "-\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "-\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "-\t\t\t\tswitch(wildcard.boundKind) {", "-    \t\t\t\tcase Wildcard.EXTENDS :", "-    \t\t\t\t\t// If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi).", "-    \t\t\t\t\t// Note: neither Ui nor Bi is necessarily scalar -> need to collect all bounds", "-    \t\t\t\t\tTypeBinding[] otherUBounds = wildcard.otherBounds;", "-    \t\t\t\t\tTypeBinding[] otherBBounds = typeParameters[i].otherUpperBounds();", "-    \t\t\t\t\tint len = 1 + (otherUBounds != null ? otherUBounds.length : 0) + otherBBounds.length;", "-    \t\t\t\t\tif (typeParameters[i].firstBound != null)", "-    \t\t\t\t\t\tlen++;", "-    \t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[len];", "-    \t\t\t\t\ttry {", "-    \t\t\t\t\t\tint idx = 0;", "-    \t\t\t\t\t\t// Ui", "-\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) wildcard.bound;", "-\t    \t\t\t\t\tif (otherUBounds != null)", "-\t    \t\t\t\t\t\tfor (int j = 0; j < otherUBounds.length; j++)", "-\t    \t\t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherUBounds[j];", "-\t    \t\t\t\t\t// Bi", "-\t    \t\t\t\t\tif (typeParameters[i].firstBound != null)", "-\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) typeParameters[i].firstBound;", "-\t    \t\t\t\t\tfor (int j = 0; j < otherBBounds.length; j++)", "-\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherBBounds[j];", "-    \t\t\t\t\t} catch (ClassCastException cce) {", "-    \t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);\t\t    \t\t\t\t\t\t", "-    \t\t\t\t\t}", "-    \t\t\t\t\tReferenceBinding[] glb = Scope.greaterLowerBound(allBounds);", "-    \t\t\t\t\tif (glb == null || glb.length == 0) {", "-\t\t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "-\t\t\t\t\t\t} else if (glb.length == 1) {", "-\t\t\t\t\t\t\ttypes[i] = glb[0];", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\ttypes[i] = new IntersectionCastTypeBinding(glb, this.environment);", "-\t\t\t\t\t\t}", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.SUPER :", "-    \t\t\t\t\t// If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.", "-    \t\t\t\t\ttypes[i] = wildcard.bound;", "-    \t\t\t\t\tbreak;", "-    \t\t\t\tcase Wildcard.UNBOUND :", "-    \t\t\t\t\t// If Ai is an unbound wildcard ?, then Ti = Bi.", "-    \t\t\t\t\ttypes[i] = typeParameters[i].firstBound;", "-    \t\t\t\t\tif (types[i] == null)", "-    \t\t\t\t\t\ttypes[i] = typeParameters[i].superclass; // assumably j.l.Object?", "-    \t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// If Ai is a type, then Ti = Ai.", "-\t\t\t\ttypes[i] = typeArgument;", "-\t\t\t}", "+\t\tParameterizedTypeBinding declaringType = null;", "+\t\tTypeBinding [] types = this.arguments; ", "+\t\tif (replaceWildcards) {", "+\t\t\ttypes = getNonWildcardParameterization();", "+\t\t\tif (types == null)", "+\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t} else if (types == null) {", "+\t\t\ttypes = NO_TYPES;", "-\t\tParameterizedTypeBinding declaringType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());", "+\t\tdeclaringType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());", "+\t\tTypeVariableBinding [] typeParameters = genericType.typeVariables();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c88b4bc22f572c8a478b0ac739aacefb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "f8e06af2d64912de617f742baa744d8cff14ca39", "commitAfterChange": "799bcf90c7e5ed6ce45339b7f5c6f4ecccd1d29c", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope)", "signatureAfterChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "diff": ["-\tpublic MethodBinding getSingleAbstractMethod(final Scope scope) {", "+\tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards) {", "-\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);", "+\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, true);", "-\t\t\tswitch (typeArgument.kind()) {", "-\t\t\t\tcase Binding.WILDCARD_TYPE :", "-\t\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "-\t\t\t\t\tswitch(wildcard.boundKind) {", "-\t    \t\t\t\tcase Wildcard.EXTENDS :", "-\t    \t\t\t\tcase Wildcard.SUPER :", "-\t    \t\t\t\t\ttypes[i] = wildcard.bound;", "-\t    \t\t\t\t\tbreak;", "-\t    \t\t\t\tcase Wildcard.UNBOUND :", "-\t    \t\t\t\t\t// if Pi has upper bound Bi that mentions none of P1...Pn, then Ti = Bi; otherwise, Ti = Object", "-\t    \t\t\t\t\tfinal TypeBinding upperBound = typeParameters[i].firstBound;", "-\t\t\t\t\t\t\tif (upperBound == null || typeParametersMentioned(upperBound)) {", "-\t    \t\t\t\t\t\ttypes[i] = scope.getJavaLangObject();", "-\t    \t\t\t\t\t} else {", "-\t    \t\t\t\t\t\ttypes[i] = upperBound;", "-\t    \t\t\t\t\t}", "-\t    \t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault :", "-\t\t\t\t\ttypes[i] = typeArgument;", "-\t\t\t\t\tbreak;", "+\t\t\tif (replaceWildcards && typeArgument.kind() == Binding.WILDCARD_TYPE) {", "+\t\t\t\tif (typeParameters[i].mentionsAny(typeParameters, i))", "+\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "+\t\t\t\tswitch(wildcard.boundKind) {", "+    \t\t\t\tcase Wildcard.EXTENDS :", "+    \t\t\t\t\t// If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi).", "+    \t\t\t\t\t// Note: neither Ui nor Bi is necessarily scalar -> need to collect all bounds", "+    \t\t\t\t\tTypeBinding[] otherUBounds = wildcard.otherBounds;", "+    \t\t\t\t\tTypeBinding[] otherBBounds = typeParameters[i].otherUpperBounds();", "+    \t\t\t\t\tint len = 2 + (otherUBounds != null ? otherUBounds.length : 0) + otherBBounds.length;", "+    \t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[len];", "+    \t\t\t\t\ttry {", "+    \t\t\t\t\t\tint idx = 0;", "+    \t\t\t\t\t\t// Ui", "+\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) wildcard.bound;", "+\t    \t\t\t\t\tif (otherUBounds != null)", "+\t    \t\t\t\t\t\tfor (int j = 0; j < otherUBounds.length; j++)", "+\t    \t\t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherUBounds[j];", "+\t    \t\t\t\t\t// Bi", "+\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) typeParameters[i].firstBound;", "+\t    \t\t\t\t\tfor (int j = 0; j < otherBBounds.length; j++)", "+\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherBBounds[j];", "+    \t\t\t\t\t} catch (ClassCastException cce) {", "+    \t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);\t\t    \t\t\t\t\t\t", "+    \t\t\t\t\t}", "+    \t\t\t\t\tReferenceBinding[] glb = Scope.greaterLowerBound(allBounds);", "+    \t\t\t\t\tif (glb == null || glb.length == 0) {", "+\t\t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t\t\t\t\t} else if (glb.length == 1) {", "+\t\t\t\t\t\t\ttypes[i] = glb[0];", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\ttypes[i] = new IntersectionCastTypeBinding(glb, this.environment);", "+\t\t\t\t\t\t}", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.SUPER :", "+    \t\t\t\t\t// If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.", "+    \t\t\t\t\ttypes[i] = wildcard.bound;", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.UNBOUND :", "+    \t\t\t\t\t// If Ai is an unbound wildcard ?, then Ti = Bi.", "+    \t\t\t\t\ttypes[i] = typeParameters[i].firstBound;", "+    \t\t\t\t\tif (types[i] == null)", "+    \t\t\t\t\t\ttypes[i] = typeParameters[i].superclass; // assumably j.l.Object?", "+    \t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// If Ai is a type, then Ti = Ai.", "+\t\t\t\ttypes[i] = typeArgument;"]}], "num": 67339}