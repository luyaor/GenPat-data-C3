{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7017ecfb3af1e2443cb4aa83c25fafb8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64ce528a9354f692ed958eeb2528773f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "f875f4161e47c5087f589529b7e7ee5cf66c1b26", "commitAfterChange": "3e03e3984540d3907fa7739b419f89dad9725944", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 59, "signatureBeforeChange": " \tpublic boolean visit( \t\tArrayQualifiedTypeReference arrayQualifiedTypeReference, \t\tClassScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\tArrayQualifiedTypeReference arrayQualifiedTypeReference, \t\tClassScope scope)", "diff": ["-\t\t\tformatArrayQualifiedTypeReference(arrayQualifiedTypeReference);", "+\t\t\tfinal int numberOfParens = (arrayQualifiedTypeReference.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\t\tif (numberOfParens > 0) {", "+\t\t\t\tmanageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);", "+\t\t\t}", "+\t\t\tthis.scribe.printArrayQualifiedReference(arrayQualifiedTypeReference.tokens.length, arrayQualifiedTypeReference.sourceEnd);", "+\t\t\tint dimensions = getDimensions();", "+\t\t\tif (dimensions != 0) {", "+\t\t\t\tfor (int i = 0; i < dimensions; i++) {", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLBRACKET);", "+\t\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACKET);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (numberOfParens > 0) {", "+\t\t\t\tmanageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffda3bdfe11966e294969f55b9b78d93", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8fd47ede750ba6005aab3e86ceccb03a6e16dba8", "commitAfterChange": "e0664fc441b4961f478c3f32edb809e211e609ac", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprivate boolean isAdaptableRegion(int offset, int length)", "signatureAfterChange": " \tprivate boolean isAdaptableRegion(int offset, int length)", "diff": ["-\t\tint span = offset + length;", "+\t\tint regionEnd = offset + length + this.lineSeparator.length() - 1;", "-\t\tif (span > this.pageWidth) {", "+\t\tif (regionEnd > this.pageWidth) {", "-\t\t// more than one line selected", "-\t\tif (span > this.getLineEnd(this.scanner.getLineNumber(offset) + 1)) {", "-\t\t\treturn false;", "-\t\t// region is on a single line and CU has more than one line", "-\t\t} else if (this.lineEnds != null && this.lineEnds.length > 1) {", "-\t\t\treturn true;", "+\t\tint numberOfLineEnds = this.lineEnds != null && this.lineEnds.length > 0 ? this.lineEnds.length : 0;", "+\t\tif (this.line > 1 && numberOfLineEnds > 0) { // CU has more than one line", "+\t\t\tint lineNumber = Util.getLineNumber(offset, this.lineEnds, 0, this.line);", "+\t\t\tint lineEnd = this.getLineEnd(lineNumber);", "+\t\t\tif (regionEnd > lineEnd) {", "+\t\t\t\t// if more than one line selected, check whether selection is at line end", "+\t\t\t\tfor (int i = lineNumber + 1 ; i <=  numberOfLineEnds ; i++) {", "+\t\t\t\t\tif (regionEnd == this.getLineEnd(i)) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false; // more than one line selected, no need to adapt region", "+\t\t\t} else {", "+\t\t\t\tif (this.scannerEndPosition - 1 == lineEnd) { // EOF reached?", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\treturn true; // a single line was selected", "+\t\t\t}"]}], "num": 44813}