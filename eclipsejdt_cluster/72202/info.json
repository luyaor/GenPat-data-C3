{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "253eefa03fd38f558d4ac31d885c888b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "35730bc36a39d42396a4794715ea44e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "46bb2fc11bd9440d4fff5ca5f3078f9c39a1d152", "commitAfterChange": "cc1ae7d3e1f618e7e804996cc901b77df44b4213", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \t \tpublic LabeledStatement convert(org.eclipse.jdt.internal.compiler.ast.LabeledStatement statement)", "signatureAfterChange": "  \tpublic void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, PackageDeclaration packageDeclaration)", "diff": ["+", "+\tpublic void convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, PackageDeclaration packageDeclaration) {", "+\t\tif (ast.apiLevel == AST.JLS3 && packageDeclaration.getJavadoc() == null) {", "+\t\t\tif (javadoc != null) {", "+\t\t\t\tif (this.commentMapper == null || !this.commentMapper.hasSameTable(this.commentsTable)) {", "+\t\t\t\t\tthis.commentMapper = new DefaultCommentMapper(this.commentsTable);", "+\t\t\t\t}", "+\t\t\t\tComment comment = this.commentMapper.getComment(javadoc.sourceStart);", "+\t\t\t\tif (comment != null && comment.isDocComment() && comment.getParent() == null) {", "+\t\t\t\t\tJavadoc docComment = (Javadoc) comment;", "+\t\t\t\t\tif (this.resolveBindings) {", "+\t\t\t\t\t\trecordNodes(docComment, javadoc);", "+\t\t\t\t\t\t// resolve member and method references binding", "+\t\t\t\t\t\tIterator tags = docComment.tags().listIterator();", "+\t\t\t\t\t\twhile (tags.hasNext()) {", "+\t\t\t\t\t\t\trecordNodes(javadoc, (TagElement) tags.next());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tpackageDeclaration.setJavadoc(docComment);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c646fb41ae92df6abe42ea2d7486f38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "175caf4c91bc68c67c64b6e69e5b88fec75be023", "commitAfterChange": "2a90eeb9372f2a1a1f5e7c24d7c19363b361caf2", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tprivate TypeBinding resolveTypeForQualifiedAllocationExpression(BlockScope scope)", "signatureAfterChange": " \t \tprivate TypeBinding resolveTypeForQualifiedAllocationExpression(BlockScope scope)", "diff": ["-", "-\t\tthis.constant = Constant.NotAConstant;", "+\t\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "-\t\tReferenceBinding enclosingInstanceReference = null;", "-\t\tboolean hasError = false;", "-\t\tboolean enclosingInstanceContainsCast = false;", "-\t\tboolean argsContainCast = false;", "+\t\tlong sourceLevel = scope.compilerOptions().sourceLevel;", "+\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tReferenceBinding enclosingInstanceReference = null;", "+\t\t\tboolean hasError = false;", "+\t\t\tboolean enclosingInstanceContainsCast = false;", "-\t\tif (this.enclosingInstance != null) {", "-\t\t\tif (this.enclosingInstance instanceof CastExpression) {", "-\t\t\t\tthis.enclosingInstance.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\tenclosingInstanceContainsCast = true;", "-\t\t\t}", "-\t\t\tif ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null){", "-\t\t\t\thasError = true;", "-\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "-\t\t\t\tscope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(", "-\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\t\tthis.enclosingInstance);", "-\t\t\t\thasError = true;", "-\t\t\t} else if (this.type instanceof QualifiedTypeReference) {", "-\t\t\t\tscope.problemReporter().illegalUsageOfQualifiedTypeReference((QualifiedTypeReference)this.type);", "-\t\t\t\thasError = true;", "-\t\t\t} else if (!(enclosingInstanceReference = (ReferenceBinding) enclosingInstanceType).canBeSeenBy(scope)) {", "-\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317212", "-\t\t\t\tenclosingInstanceType = new ProblemReferenceBinding(", "+\t\t\tif (this.enclosingInstance != null) {", "+\t\t\t\tif (this.enclosingInstance instanceof CastExpression) {", "+\t\t\t\t\tthis.enclosingInstance.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tenclosingInstanceContainsCast = true;", "+\t\t\t\t}", "+\t\t\t\tif ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null){", "+\t\t\t\t\thasError = true;", "+\t\t\t\t} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {", "+\t\t\t\t\tscope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(", "+\t\t\t\t\t\t\tenclosingInstanceType,", "+\t\t\t\t\t\t\tthis.enclosingInstance);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t} else if (this.type instanceof QualifiedTypeReference) {", "+\t\t\t\t\tscope.problemReporter().illegalUsageOfQualifiedTypeReference((QualifiedTypeReference)this.type);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t} else if (!(enclosingInstanceReference = (ReferenceBinding) enclosingInstanceType).canBeSeenBy(scope)) {", "+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317212", "+\t\t\t\t\tenclosingInstanceType = new ProblemReferenceBinding(", "-\t\t\t\tscope.problemReporter().invalidType(this.enclosingInstance, enclosingInstanceType);", "-\t\t\t\thasError = true;", "-\t\t\t} else {", "-\t\t\t\treceiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);", "-\t\t\t\tcheckIllegalNullAnnotation(scope, receiverType);", "-\t\t\t\tif (receiverType != null && enclosingInstanceContainsCast) {", "-\t\t\t\t\tCastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} else {", "-\t\t\tif (this.type == null) {", "-\t\t\t\t// initialization of an enum constant", "-\t\t\t\treceiverType = scope.enclosingSourceType();", "-\t\t\t} else {", "-\t\t\t\treceiverType = this.type.resolveType(scope, true /* check bounds*/);", "-\t\t\t\tcheckIllegalNullAnnotation(scope, receiverType);", "-\t\t\t\tcheckParameterizedAllocation: {", "-\t\t\t\t\tif (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;", "-\t\t\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "-\t\t\t\t\t\tReferenceBinding currentType = (ReferenceBinding)receiverType;", "-\t\t\t\t\t\tdo {", "-\t\t\t\t\t\t\t// isStatic() is answering true for toplevel types", "-\t\t\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "-\t\t\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "-\t\t\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "-\t\t\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "-\t\t\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "-\t\t\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, receiverType);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (receiverType == null || !receiverType.isValidBinding()) {", "-\t\t\thasError = true;", "-\t\t}", "-", "-\t\t// resolve type arguments (for generic constructor call)", "-\t\tlong sourceLevel = scope.compilerOptions().sourceLevel;", "-\t\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "-\t\tif (this.typeArguments != null) {", "-\t\t\tint length = this.typeArguments.length;", "-\t\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "-\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\t\tthis.argumentsHaveErrors = true;", "-\t\t\t\t}", "-\t\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "-\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (isDiamond) {", "-\t\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t\tif (this.argumentsHaveErrors) {", "-\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "-\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "-\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t}", "-", "-\t\t// will check for null after args are resolved", "-\t\tthis.argumentTypes = Binding.NO_PARAMETERS;", "-\t\tif (this.arguments != null) {", "-\t\t\tint length = this.arguments.length;", "-\t\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\t\targument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\t\targsContainCast = true;", "-\t\t\t\t}", "-\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null){", "+\t\t\t\t\tscope.problemReporter().invalidType(this.enclosingInstance, enclosingInstanceType);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// limit of fault-tolerance", "-\t\tif (hasError) {", "-\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "-\t\t\t   No meaningful type resolution is possible since inference of the elided types is fully tied to argument types. Do", "-\t\t\t   not return the partially resolved type.", "-\t\t\t */", "-\t\t\tif (isDiamond) {", "-\t\t\t\treturn null; // not the partially cooked this.resolvedType", "-\t\t\t}", "-\t\t\tif (receiverType instanceof ReferenceBinding) {", "-\t\t\t\tReferenceBinding referenceReceiver = (ReferenceBinding) receiverType;", "-\t\t\t\tif (receiverType.isValidBinding()) {", "-\t\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "-\t\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "-\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "-\t\t\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.resolvedType = receiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);", "+\t\t\t\t\tcheckIllegalNullAnnotation(scope, receiverType);", "+\t\t\t\t\tif (receiverType != null && enclosingInstanceContainsCast) {", "+\t\t\t\t\t\tCastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);", "-\t\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this, false);", "-\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "-\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\t\t\t\t\tif (closestMatch != null) {", "-\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "-\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.binding = closestMatch;", "-\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "-\t\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "-\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (this.type == null) {", "+\t\t\t\t\t// initialization of an enum constant", "+\t\t\t\t\treceiverType = scope.enclosingSourceType();", "+\t\t\t\t} else {", "+\t\t\t\t\treceiverType = this.type.resolveType(scope, true /* check bounds*/);", "+\t\t\t\t\tcheckIllegalNullAnnotation(scope, receiverType);", "+\t\t\t\t\tcheckParameterizedAllocation: {", "+\t\t\t\t\t\tif (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;", "+\t\t\t\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "+\t\t\t\t\t\t\tReferenceBinding currentType = (ReferenceBinding)receiverType;", "+\t\t\t\t\t\t\tdo {", "+\t\t\t\t\t\t\t\t// isStatic() is answering true for toplevel types", "+\t\t\t\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "+\t\t\t\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "+\t\t\t\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "+\t\t\t\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "+\t\t\t\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "+\t\t\t\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, receiverType);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\tif (this.anonymousType != null) {", "-\t\t\t\t\t// insert anonymous type in scope (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210070)", "-\t\t\t\t\tscope.addAnonymousType(this.anonymousType, referenceReceiver);", "-\t\t\t\t\tthis.anonymousType.resolve(scope);", "-\t\t\t\t\treturn this.resolvedType = this.anonymousType.binding;", "-\t\t\t\t}", "-\t\t\treturn this.resolvedType = receiverType;", "-\t\t}", "-\t\tif (this.anonymousType == null) {", "-\t\t\t// qualified allocation with no anonymous type", "-\t\t\tif (!receiverType.canBeInstantiated()) {", "-\t\t\t\tscope.problemReporter().cannotInstantiate(this.type, receiverType);", "-\t\t\t\treturn this.resolvedType = receiverType;", "+\t\t\tif (receiverType == null || !receiverType.isValidBinding()) {", "+\t\t\t\thasError = true;", "-\t\t\tif (isDiamond) {", "-\t\t\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) receiverType, receiverType.enclosingType(), this.argumentTypes, scope);", "-\t\t\t\tif (inferredTypes == null) {", "-\t\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "-\t\t\t\t\treturn this.resolvedType = null;", "-\t\t\t\t}", "-\t\t\t\treceiverType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) receiverType).genericType(), inferredTypes, ((ParameterizedTypeBinding) receiverType).enclosingType());", "-\t\t\t}", "-\t\t\tReferenceBinding allocationType = (ReferenceBinding) receiverType;", "-\t\t\tthis.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);", "-\t\t\tif (this.binding.isValidBinding()) {\t", "-\t\t\t\tif (isMethodUseDeprecated(this.binding, scope, true)) {", "-\t\t\t\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\t\t\t// resolve type arguments (for generic constructor call)", "+\t\t\tif (this.typeArguments != null) {", "+\t\t\t\tint length = this.typeArguments.length;", "+\t\t\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "+\t\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\t\tthis.argumentsHaveErrors = true;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "+\t\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+\t\t\t\t\t}", "-\t\t\t\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, argsContainCast, this)) {", "-\t\t\t\t\tthis.bits |= ASTNode.Unchecked;", "-\t\t\t\t}", "-\t\t\t\tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (this.binding.declaringClass == null) {", "-\t\t\t\t\tthis.binding.declaringClass = allocationType;", "-\t\t\t\t}", "-\t\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "-\t\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\tif (isDiamond) {", "+\t\t\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "-\t\t\t\tscope.problemReporter().invalidConstructor(this, this.binding);", "-\t\t\t\treturn this.resolvedType = receiverType;", "+\t\t\t\tif (this.argumentsHaveErrors) {", "+\t\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "-\t\t\tif ((this.binding.tagBits & TagBits.HasMissingType) != 0) {", "-\t\t\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "-\t\t\t}", "-\t\t\tif (!isDiamond && receiverType.isParameterizedTypeWithActualArguments()) {", "-\t\t \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, receiverType.enclosingType(), this.argumentTypes , scope);", "-\t\t \t}", "-\t\t\t// The enclosing instance must be compatible with the innermost enclosing type", "-\t\t\tReferenceBinding expectedType = this.binding.declaringClass.enclosingType();", "-\t\t\tif (TypeBinding.notEquals(expectedType, enclosingInstanceType)) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\tscope.compilationUnitScope().recordTypeConversion(expectedType, enclosingInstanceType);", "-\t\t\tif (enclosingInstanceType.isCompatibleWith(expectedType) || scope.isBoxingCompatibleWith(enclosingInstanceType, expectedType)) {", "-\t\t\t\tthis.enclosingInstance.computeConversion(scope, expectedType, enclosingInstanceType);", "-\t\t\t\treturn this.resolvedType = receiverType;", "-\t\t\t}", "-\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);", "-\t\t\treturn this.resolvedType = receiverType;", "-\t\t} else {", "-\t\t\tif (isDiamond) {", "-\t\t\t\tscope.problemReporter().diamondNotWithAnoymousClasses(this.type);", "-\t\t\t\treturn null;", "-\t\t\t}\t", "-\t\t}", "-\t\tReferenceBinding superType = (ReferenceBinding) receiverType;", "-\t\tif (superType.isTypeVariable()) {", "-\t\t\tsuperType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);", "-\t\t\tscope.problemReporter().invalidType(this, superType);", "-\t\t\treturn null;", "-\t\t} else if (this.type != null && superType.isEnum()) { // tolerate enum constant body", "-\t\t\tscope.problemReporter().cannotInstantiate(this.type, superType);", "-\t\t\treturn this.resolvedType = superType;", "-\t\t}", "-\t\t// anonymous type scenario", "-\t\t// an anonymous class inherits from java.lang.Object when declared \"after\" an interface", "-\t\tReferenceBinding anonymousSuperclass = superType.isInterface() ? scope.getJavaLangObject() : superType;", "-\t\t// insert anonymous type in scope", "-\t\tscope.addAnonymousType(this.anonymousType, superType);", "-\t\tthis.anonymousType.resolve(scope);", "-\t\t// find anonymous super constructor", "-\t\tthis.resolvedType = this.anonymousType.binding; // 1.2 change", "-\t\tif ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {", "-\t\t\treturn null; // stop secondary errors", "+\t\t\t// will check for null after args are resolved", "+\t\t\tthis.argumentTypes = Binding.NO_PARAMETERS;", "+\t\t\tif (this.arguments != null) {", "+\t\t\t\tint length = this.arguments.length;", "+\t\t\t\tthis.argumentTypes = new TypeBinding[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\t\targument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\t\tthis.argsContainCast = true;", "+\t\t\t\t\t}", "+\t\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "+\t\t\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null){", "+\t\t\t\t\t\tthis.argumentsHaveErrors = hasError = true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// limit of fault-tolerance", "+\t\t\tif (hasError) {", "+\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "+\t\t\t       No meaningful type resolution is possible since inference of the elided types is fully tied to argument types. Do", "+\t\t\t       not return the partially resolved type.", "+\t\t\t\t */", "+\t\t\t\tif (isDiamond) {", "+\t\t\t\t\treturn null; // not the partially cooked this.resolvedType", "+\t\t\t\t}", "+\t\t\t\tif (receiverType instanceof ReferenceBinding) {", "+\t\t\t\t\tReferenceBinding referenceReceiver = (ReferenceBinding) receiverType;", "+\t\t\t\t\tif (receiverType.isValidBinding()) {", "+\t\t\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "+\t\t\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "+\t\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this, false);", "+\t\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.anonymousType != null) {", "+\t\t\t\t\t\t// insert anonymous type in scope (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210070)", "+\t\t\t\t\t\tscope.addAnonymousType(this.anonymousType, referenceReceiver);", "+\t\t\t\t\t\tthis.anonymousType.resolve(scope);", "+\t\t\t\t\t\treturn this.resolvedType = this.anonymousType.binding;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn this.resolvedType = receiverType;", "+\t\t\t}", "+\t\t\tif (this.anonymousType == null) {", "+\t\t\t\t// qualified allocation with no anonymous type", "+\t\t\t\tif (!receiverType.canBeInstantiated()) {", "+\t\t\t\t\tscope.problemReporter().cannotInstantiate(this.type, receiverType);", "+\t\t\t\t\treturn this.resolvedType = receiverType;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (isDiamond) {", "+\t\t\t\t\tscope.problemReporter().diamondNotWithAnoymousClasses(this.type);", "+\t\t\t\t\treturn null;", "+\t\t\t\t}\t", "+\t\t\t\tReferenceBinding superType = (ReferenceBinding) receiverType;", "+\t\t\t\tif (superType.isTypeVariable()) {", "+\t\t\t\t\tsuperType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\t\t\tscope.problemReporter().invalidType(this, superType);", "+\t\t\t\t\treturn null;", "+\t\t\t\t} else if (this.type != null && superType.isEnum()) { // tolerate enum constant body", "+\t\t\t\t\tscope.problemReporter().cannotInstantiate(this.type, superType);", "+\t\t\t\t\treturn this.resolvedType = superType;", "+\t\t\t\t}", "+\t\t\t\t// anonymous type scenario", "+\t\t\t\t// an anonymous class inherits from java.lang.Object when declared \"after\" an interface", "+\t\t\t\tReferenceBinding anonymousSuperclass = superType.isInterface() ? scope.getJavaLangObject() : superType;", "+\t\t\t\t// insert anonymous type in scope", "+\t\t\t\tscope.addAnonymousType(this.anonymousType, superType);", "+\t\t\t\tthis.anonymousType.resolve(scope);", "+", "+\t\t\t\t// find anonymous super constructor", "+\t\t\t\tthis.resolvedType = this.anonymousType.binding; // 1.2 change", "+\t\t\t\tif ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {", "+\t\t\t\t\treturn null; // stop secondary errors", "+\t\t\t\t}", "+\t\t\t\tMethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, this.argumentTypes);", "+", "+\t\t\t\tif (!inheritedBinding.isValidBinding()) {", "+\t\t\t\t\tif (inheritedBinding.declaringClass == null) {", "+\t\t\t\t\t\tinheritedBinding.declaringClass = anonymousSuperclass;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "+\t\t\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\tscope.problemReporter().invalidConstructor(this, inheritedBinding);", "+\t\t\t\t\treturn this.resolvedType;", "+\t\t\t\t}", "+\t\t\t\tif ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tscope.problemReporter().missingTypeInConstructor(this, inheritedBinding);", "+\t\t\t\t}", "+\t\t\t\tif (this.enclosingInstance != null) {", "+\t\t\t\t\tReferenceBinding targetEnclosing = inheritedBinding.declaringClass.enclosingType();", "+\t\t\t\t\tif (targetEnclosing == null) {", "+\t\t\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, superType);", "+\t\t\t\t\t\treturn this.resolvedType;", "+\t\t\t\t\t} else if (!enclosingInstanceType.isCompatibleWith(targetEnclosing) && !scope.isBoxingCompatibleWith(enclosingInstanceType, targetEnclosing)) {", "+\t\t\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);", "+\t\t\t\t\t\treturn this.resolvedType;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.enclosingInstance.computeConversion(scope, targetEnclosing, enclosingInstanceType);", "+\t\t\t\t}", "+\t\t\t\tif (this.arguments != null) {", "+\t\t\t\t\tif (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "+\t\t\t\t\t\tthis.bits |= ASTNode.Unchecked;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (this.typeArguments != null && inheritedBinding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(inheritedBinding, this.genericTypeArguments, this.typeArguments);", "+\t\t\t\t}", "+\t\t\t\t// Update the anonymous inner class : superclass, interface", "+\t\t\t\tthis.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding, \t(this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null);", "+\t\t\t\treturn this.resolvedType;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (this.enclosingInstance != null) {", "+\t\t\t\tenclosingInstanceType = this.enclosingInstance.resolvedType;", "+\t\t\t\tthis.resolvedType = receiverType = this.type.resolvedType;", "+\t\t\t}", "-\t\tMethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, this.argumentTypes);", "-\t\t\t", "-\t\tif (!inheritedBinding.isValidBinding()) {", "-\t\t\tif (inheritedBinding.declaringClass == null) {", "-\t\t\t\tinheritedBinding.declaringClass = anonymousSuperclass;", "+\t\tif (isDiamond) {", "+\t\t\tthis.binding = inferConstructorOfElidedParameterizedType(scope);", "+\t\t\tif (this.binding == null || !this.binding.isValidBinding()) {", "+\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\treturn this.resolvedType = null;", "+\t\t\t}", "+\t\t\tif (this.typeExpected == null && sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\t}", "+\t\t\tthis.resolvedType = this.type.resolvedType = receiverType = this.binding.declaringClass;", "+\t\t\tresolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);", "+\t\t} else {", "+\t\t\tthis.binding = findConstructorBinding(scope, this, (ReferenceBinding) receiverType, this.argumentTypes);", "+\t\t}", "+", "+\t\tif (this.binding.isValidBinding()) {\t", "+\t\t\tif (isMethodUseDeprecated(this.binding, scope, true)) {", "+\t\t\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\t\t\t}", "+\t\t\tif (checkInvocationArguments(scope, null, receiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "+\t\t\t\tthis.bits |= ASTNode.Unchecked;", "+\t\t\t}", "+\t\t\tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (this.binding.declaringClass == null) {", "+\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) receiverType;", "-\t\t\tscope.problemReporter().invalidConstructor(this, inheritedBinding);", "-\t\t\treturn this.resolvedType;", "+\t\t\tscope.problemReporter().invalidConstructor(this, this.binding);", "+\t\t\treturn this.resolvedType = receiverType;", "-\t\tif ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {", "-\t\t\tscope.problemReporter().missingTypeInConstructor(this, inheritedBinding);", "+\t\tif ((this.binding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "-\t\tif (this.enclosingInstance != null) {", "-\t\t\tReferenceBinding targetEnclosing = inheritedBinding.declaringClass.enclosingType();", "-\t\t\tif (targetEnclosing == null) {", "-\t\t\t\tscope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, superType);", "-\t\t\t\treturn this.resolvedType;", "-\t\t\t} else if (!enclosingInstanceType.isCompatibleWith(targetEnclosing) && !scope.isBoxingCompatibleWith(enclosingInstanceType, targetEnclosing)) {", "-\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);", "-\t\t\t\treturn this.resolvedType;", "-\t\t\t}", "-\t\t\tthis.enclosingInstance.computeConversion(scope, targetEnclosing, enclosingInstanceType);", "+\t\tif (!isDiamond && receiverType.isParameterizedTypeWithActualArguments()) {", "+\t\t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, scope);", "-\t\tif (this.arguments != null) {", "-\t\t\tif (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, this.argumentTypes, argsContainCast, this)) {", "-\t\t\t\tthis.bits |= ASTNode.Unchecked;", "-\t\t\t}", "+\t\t// The enclosing instance must be compatible with the innermost enclosing type", "+\t\tReferenceBinding expectedType = this.binding.declaringClass.enclosingType();", "+\t\tif (TypeBinding.notEquals(expectedType, enclosingInstanceType)) // must call before computeConversion() and typeMismatchError()", "+\t\t\tscope.compilationUnitScope().recordTypeConversion(expectedType, enclosingInstanceType);", "+\t\tif (enclosingInstanceType.isCompatibleWith(expectedType) || scope.isBoxingCompatibleWith(enclosingInstanceType, expectedType)) {", "+\t\t\tthis.enclosingInstance.computeConversion(scope, expectedType, enclosingInstanceType);", "+\t\t\treturn this.resolvedType = receiverType;", "-\t\tif (this.typeArguments != null && inheritedBinding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "-\t\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(inheritedBinding, this.genericTypeArguments, this.typeArguments);", "-\t\t}", "-\t\t// Update the anonymous inner class : superclass, interface", "-\t\tthis.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding, \t(this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null);", "-\t\treturn this.resolvedType;", "+\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);", "+\t\treturn this.resolvedType = receiverType;"]}], "num": 72202}