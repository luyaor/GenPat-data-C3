{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "194f185349610606dd001618e242ca5d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45a6f6809f903883a37c1ac021ed5fda", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/InternalNamingConventions.java", "commitBeforeChange": "442e537ccb6b39c7edc9c47a4881c13fd272b778", "commitAfterChange": "4c189e9ace1b80058cb5ffdc73af183713ebd908", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tprivate static void suggestNames( \t\tchar[] packageName, \t\tchar[] qualifiedTypeName, \t\tint dim, \t\tchar[][] prefixes, \t\tchar[][] suffixes, \t\tchar[][] excludedNames, \t\tScanner nameScanner, \t\tINamingRequestor requestor)", "signatureAfterChange": " \t \tprivate static void suggestNames( \t\tchar[] packageName, \t\tchar[] qualifiedTypeName, \t\tint dim, \t\tchar[][] prefixes, \t\tchar[][] suffixes, \t\tchar[][] excludedNames, \t\tScanner nameScanner, \t\tINamingRequestor requestor)", "diff": ["-\t\t\t\t\tSystem.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);", "-\t\t\t\t\ttempName[length] = 'e';", "-\t\t\t\t\ttempName[length+1] = 's';", "+\t\t\t\t\tif(tempName.length > 1 && tempName[length-2] == 's') {", "+\t\t\t\t\t\tSystem.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);", "+\t\t\t\t\t\ttempName[length] = 'e';", "+\t\t\t\t\t\ttempName[length+1] = 's';", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "659570bacbd809a8b47df88dce06b719", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "48d8b25fe48652384eaea784beaca4f2d5a7f1f1", "commitAfterChange": "d2bbe758aa36ed261c3b0452e9226ce41cb1f1bd", "methodNumberBeforeChange": 265, "methodNumberAfterChange": 265, "signatureBeforeChange": " public void recordPositionsFrom(int startPC, int sourcePos)", "signatureAfterChange": " public void recordPositionsFrom(int startPC, int sourcePos)", "diff": ["-\t\t\t\t\tif ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {", "-\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);", "-\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "-\t\t\t\t\t\tpcToSourceMap[insertionIndex] = newLine;\t\t\t\t\t\t", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 2] = startPC;", "+\t\t\t\t\t/* First we need to check if at the insertion position there is not an existing entry", "+\t\t\t\t\t * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.", "+\t\t\t\t\t * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion", "+\t\t\t\t\t * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.", "+\t\t\t\t\t */", "+\t\t\t\t\tif (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {", "+\t\t\t\t\t\tif ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {", "+\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);", "+\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = newLine;\t\t\t\t\t\t", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 2] = startPC;", "+\t\t\t\t\t\t}"]}], "num": 11533}