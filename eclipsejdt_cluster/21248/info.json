{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2ed7bbf01d10774ca35f2feed89741d7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e5de2872b92cac5ed9ec9c6a23362ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/FieldLocator.java", "commitBeforeChange": "203954a19427f44b197aa09593f6f49177e09606", "commitAfterChange": "3ed9acfe644f3aa92ee72abfaf147fb3ef3a87d3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public int match(FieldDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static field reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.name, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tFieldPattern fieldPattern = (FieldPattern) this.pattern;", "+\t\t\t\tchar[] declaringType = CharOperation.concat(fieldPattern.declaringQualification, fieldPattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8b9acf7023f9669f2c503579810b189", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "4043b8a88c35a2c1612858cff67743727f25247b", "commitAfterChange": "6b8da2bd2bb1367c9817dbe3821476ed638f0906", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": " protected void reportAccurateParameterizedTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException", "signatureAfterChange": " protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException", "diff": ["-protected void reportAccurateParameterizedTypeReference(ASTNode typeRef, char[] name, IJavaElement element, int accuracy) throws CoreException {", "+protected void reportAccurateParameterizedTypeReference(TypeReference typeRef, char[] name, int start, TypeReference[] typeArguments, IJavaElement element, int accuracy) throws CoreException {", "-\t// compute source positions of the qualified reference ", "-\tScanner scanner = this.parser.scanner;", "-\tscanner.setSource(this.currentPossibleMatch.getContents());", "-\tint sourceStart = typeRef.sourceStart;", "-\tint sourceEnd = scanner.eofPosition;", "-\tscanner.resetTo(sourceStart, sourceEnd);", "+\t// If there's type arguments, look for end (ie. char '>') of last one.", "+\tint end = typeRef.sourceEnd;", "+\tif (typeArguments != null) {", "-\tint token = -1;", "-\tint currentPosition;", "-\tdo {", "-\t\tcurrentPosition = scanner.currentPosition;", "-\t\ttry {", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t} catch (InvalidInputException e) {", "-\t\t\t// ignore", "+\t\t// Initialize scanner", "+\t\tScanner scanner = this.parser.scanner;", "+\t\tchar[] source = this.currentPossibleMatch.getContents();", "+\t\tscanner.setSource(source);", "+\t\tscanner.resetTo(end, source.length-1);", "+", "+\t\t// Set scanner position at end of last type argument", "+\t\tint depth = 0;", "+\t\tfor (int i=typeArguments.length-1; i>=0; i--) {", "+\t\t\tif (typeArguments[i] != null) {", "+\t\t\t\tdepth = resetScannerAfterLastTypeArgumentEnd(typeArguments[i], scanner, depth)+1;", "+\t\t\t\tbreak;", "+\t\t\t}", "-\t\tif (token == TerminalTokens.TokenNameIdentifier && this.pattern.matchesName(name, scanner.getCurrentTokenSource())) {", "-\t\t\t// extends selection end for parameterized types if necessary", "-\t\t\tint count = 0;", "-\t\t\tint ch = -1;", "-\t\t\twhile (ch != '>' || count > 0) {", "-\t\t\t\tch = scanner.getNextChar();", "-\t\t\t\tswitch (ch) {", "-\t\t\t\t\tcase '<':", "-\t\t\t\t\t\tcount++;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase '>':", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase -1:", "-\t\t\t\t\t\t// we missed type parameters declarations! => do not report match", "-\t\t\t\t\t\treturn;", "+", "+\t\t// Now, scan to search next closing '>'", "+\t\twhile (depth-- > 0) {", "+\t\t\twhile (!scanner.atEnd()) {", "+\t\t\t\tif (scanner.getNextChar() == '>') {", "+\t\t\t\t\tend = scanner.currentPosition - 1;", "+\t\t\t\t\tbreak;", "-\t\t\tint length = scanner.currentPosition-currentPosition;", "-\t\t\tSearchMatch match = newTypeReferenceMatch(element, accuracy, currentPosition, length, typeRef);", "-\t\t\treport(match);", "-\t\t\treturn;", "-\t} while (token != TerminalTokens.TokenNameEOF);", "-\tSearchMatch match = newTypeReferenceMatch(element, accuracy, sourceStart, sourceEnd-sourceStart+1, typeRef);", "+\t}", "+\t", "+\t// Report match", "+\tSearchMatch match = newTypeReferenceMatch(element, accuracy, start, end-start+1, typeRef);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d80291b3c61e8398c929fd9c13ed2904", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java", "commitBeforeChange": "fe9d56739c7ee5a42ad73e908441932d571ee55b", "commitAfterChange": "309aed033cc4257b36692ed1549ee0025e0800df", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "signatureAfterChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "diff": ["+\t\tif (!_processorEnabled) {", "+\t\t\t// Disable this processor unless we are intentionally performing the test.", "+\t\t\treturn false;", "+\t\t}", "-\t\t", "-\t\t// Selectively enable just one of the test routines", "-\t\tMap<String, String> options = processingEnv.getOptions();", "-\t\tif (!options.containsKey(CLASSNAME)) {", "-\t\t\t// Disable this processor unless we are intentionally performing the test.", "+\t\tif (_oneTest < 0 || _oneTest > testMethodNames.length) {", "+\t\t\treportError(\"Invalid test method specified: \" + processingEnv.getOptions().get(CLASSNAME));", "-\t\tString oneTest = options.get(CLASSNAME);", "-\t\tif (oneTest != null && oneTest.length() > 0) {", "-\t\t\tint enable = 0;", "-\t\t\ttry {", "-\t\t\t\tenable = Integer.parseInt(oneTest);", "+\t\t", "+\t\t// Reflectively invoke the specified tests.", "+\t\ttry {", "+\t\t\tif (_oneTest == 0) {", "+\t\t\t\tfor (Method testMethod : testMethods) {", "+\t\t\t\t\tObject success = testMethod.invoke(this);", "+\t\t\t\t\tif (!(success instanceof Boolean) || !(Boolean)success) {", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\tcatch (NumberFormatException e) {", "-\t\t\t\treportError(\"Option value '\" + oneTest + \"' must be an integer indicating what test to enable\");", "-\t\t\t\treturn false;", "+\t\t\telse {", "+\t\t\t\tObject success = testMethods[_oneTest - 1].invoke(this);", "+\t\t\t\tif (!(success instanceof Boolean) || !(Boolean)success) {", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "-\t\t\tif (enable > 5) {", "-\t\t\t\treportError(\"Option value must be an integer 1 to 5\");", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t\tif (enable >= 1) {", "-\t\t\t\ttestNegative1 = enable == 1;", "-\t\t\t\ttestNegative2 = enable == 2;", "-\t\t\t\ttestNegative3 = enable == 3;", "-\t\t\t\ttestNegative4 = enable == 4;", "-\t\t\t\ttestNegative5 = enable == 5;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\tif (testNegative1 && !checkNegative1()) {", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\tif (testNegative2 && !checkNegative2()) {", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\tif (testNegative3 && !checkNegative3()) {", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\tif (testNegative4 && !checkNegative4()) {", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\tif (testNegative5 && !checkNegative5()) {", "+\t\t} catch (Exception e) {", "+\t\t\te.printStackTrace();", "+\t\t\treportError(\"Exception thrown while invoking test method: \" + e);"]}], "num": 21248}