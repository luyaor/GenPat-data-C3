{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c6d2f8bd513f15b297fc25ed09163f84", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d74c1555b989484d5bfb18113426f4cd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "8a4bd8a6db890bd0552718e8332a5c8e90155329", "commitAfterChange": "595c4dea8c6828d0945e9c58025a82a9fd99c02b", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["-\t\t\t\tif (exactMethod.typeVariables != Binding.NO_TYPE_VARIABLES || invocationSite.genericTypeArguments() != null) {", "-\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);", "-\t\t\t\t\t// compatibleMethod should not be null thanks to the conditions guarding this block ", "-\t\t\t\t\tif (!compatibleMethod.isValidBinding() && exactMethod.typeVariables != Binding.NO_TYPE_VARIABLES) {", "-\t\t\t\t\t\treturn null; // could be a better generic method match (90423), which will be found by non exact match", "-\t\t\t\t\t}", "-\t\t\t\t\texactMethod = compatibleMethod;", "+\t\t\t\tif (invocationSite.genericTypeArguments() != null) {", "+\t\t\t\t\texactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa34043aff33f19c78cbb73720798ab4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["-\t\t\tif (receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this))", "+\t\t\t// special treatment for Object.getClass() in 1.5 mode (substitute parameterized return type)", "+\t\t\tif (receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t    if (receiverType.id != T_Object", "+\t\t\t            && argumentTypes == NoParameters", "+\t\t\t            && CharOperation.equals(selector, GETCLASS)", "+\t\t\t            && exactMethod.returnType.isParameterizedType()/*1.5*/) {", "+\t\t\t        return ParameterizedMethodBinding.instantiateGetClass(receiverType, exactMethod, this);", "+\t\t\t    }", "+\t\t\t    // targeting a generic method could find an exact match with variable return type", "+\t\t\t    if (exactMethod.typeVariables != NoTypeVariables || invocationSite.genericTypeArguments() != null)", "+\t\t\t    \texactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);", "+\t\t\t}"]}], "num": 37603}