{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2fdbf3638962f200c6a253e21c888092", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d5ebfed409c799c384117eec2b556522", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BuilderTests.java", "commitBeforeChange": "86b2736b1ff244cb248bf0457bce1e3bc8f80637", "commitAfterChange": "a2905241c8f7a3e3308dc841ede04f62d302de11", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 34, "signatureBeforeChange": "  \tpublic static Test suite()", "signatureAfterChange": "  \tpublic static Test suite()", "diff": ["-\tpublic static Test suite() {", "-\t\tTestSuite suite = new TestSuite();", "-", "-\t\t/* tests */", "-\t\tsuite.addTest(AbstractMethodTests.suite());", "-\t\tsuite.addTest(BasicBuildTests.suite());", "-\t\tsuite.addTest(BuildpathTests.suite());", "-\t\tsuite.addTest(CopyResourceTests.suite());", "-\t\tsuite.addTest(DependencyTests.suite());", "-\t\tsuite.addTest(ErrorsTests.suite());", "-\t\tsuite.addTest(EfficiencyTests.suite());", "-\t\tsuite.addTest(ExecutionTests.suite());", "-\t\tsuite.addTest(IncrementalTests.suite());", "-\t\tsuite.addTest(MultiProjectTests.suite());", "-\t\tsuite.addTest(MultiSourceFolderAndOutputFolderTests.suite());", "-\t\tsuite.addTest(OutputFolderTests.suite());", "-\t\tsuite.addTest(PackageTests.suite());", "-\t\tsuite.addTest(StaticFinalTests.suite());", "-\t\tsuite.addTest(GetResourcesTests.suite());", "-\t\t\tsuite.addTest(Java50Tests.suite());", "-            suite.addTest(PackageInfoTest.suite());", "-\t\t\tsuite.addTest(ParticipantBuildTests.suite());", "+", "+\tpublic static Test suite() {", "+\t\tTestSuite suite = new TestSuite(BuilderTests.class.getName());", "+", "+\t\t// Hack to load all classes before computing their suite of test cases", "+\t\t// this allow to reset test cases subsets while running all Builder tests...", "+\t\tClass[] classes = getAllTestClasses();", "+", "+\t\t// Reset forgotten subsets of tests", "+\t\tTestCase.TESTS_PREFIX = null;", "+\t\tTestCase.TESTS_NAMES = null;", "+\t\tTestCase.TESTS_NUMBERS = null;", "+\t\tTestCase.TESTS_RANGE = null;", "+\t\tTestCase.RUN_ONLY_ID = null;", "+", "+\t\t/* tests */", "+\t\tfor (int i = 0, length = classes.length; i < length; i++) {", "+\t\t\tClass clazz = classes[i];", "+\t\t\tMethod suiteMethod;", "+\t\t\ttry {", "+\t\t\t\tsuiteMethod = clazz.getDeclaredMethod(\"suite\", new Class[0]);", "+\t\t\t} catch (NoSuchMethodException e) {", "+\t\t\t\te.printStackTrace();", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tObject test;", "+\t\t\ttry {", "+\t\t\t\ttest = suiteMethod.invoke(null, new Object[0]);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\te.printStackTrace();", "+\t\t\t\tcontinue;", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\te.printStackTrace();", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tsuite.addTest((Test) test);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1cdd3a076ab652d3c06ce2fb5ecba6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "795236662f4c72deb433448a946f4a36cebbebd0", "commitAfterChange": "b74a7b82d9221b86893a88ea5453e92534ffe51b", "methodNumberBeforeChange": 124, "methodNumberAfterChange": 127, "signatureBeforeChange": " \t \tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException", "signatureAfterChange": " \t \tprivate ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException", "diff": ["-\t\t\tIPath resolvedPath;", "-\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "+\t\t\t\t\t\tresolvedEntry = manager.resolveVariableEntry(rawEntry, usePreviousSession);", "-\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "+\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\t\t\tClasspathEntry[] extraEntries = ((ClasspathEntry) resolvedEntry).resolvedChainedLibraries();", "+\t\t\t\t\t\t\tfor (int j = 0, length2 = extraEntries.length; j < length2; j++) {", "+\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[j], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "-\t\t\t\t\t\t// resolve \"..\" in library path", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// resolve \"..\" in library path", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\t\t\tClasspathEntry[] extraEntries = cEntry.resolvedChainedLibraries();", "+\t\t\t\t\t\t\tfor (int k = 0, length2 = extraEntries.length; k < length2; k++) {", "+\t\t\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {", "-\t\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, cEntry);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tresolvedEntries.add(cEntry);", "-\t\t\t\t\t\tif (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\taddToResult(rawEntry, cEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\t// resolve \"..\" in library path", "-\t\t\t\t\t// $FALL-THROUGH$ use the default code below", "-\t\t\t\tdefault :", "-\t\t\t\t\tif (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {", "-\t\t\t\t\t\tresult.rawReverseMap.put(resolvedPath , rawEntry);", "-\t\t\t\t\t\tresult.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);", "-\t\t\t\t\t}", "-\t\t\t\t\tresolvedEntries.add(resolvedEntry);", "-\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {", "-\t\t\t\t\t\texternalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered", "+\t\t\t\t\t", "+\t\t\t\t\t// resolve Class-Path: in manifest", "+\t\t\t\t\tClasspathEntry[] extraEntries = ((ClasspathEntry) resolvedEntry).resolvedChainedLibraries();", "+\t\t\t\t\tfor (int k = 0, length2 = extraEntries.length; k < length2; k++) {", "+\t\t\t\t\t\taddToResult(rawEntry, extraEntries[k], result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault :", "+\t\t\t\t\taddToResult(rawEntry, resolvedEntry, result, resolvedEntries, externalFoldersManager);", "+\t\t\t\t\tbreak;", "+\t}"]}], "num": 30442}