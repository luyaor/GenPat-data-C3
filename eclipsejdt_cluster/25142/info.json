{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f58e96fc752db8c733c1a97cbbef1476", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c9de3181086be9966d2422de7cea728", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java", "commitBeforeChange": "d4ec2cadb3e7536bb815d2a43adb7b51f267f01a", "commitAfterChange": "78310b6881d29e4104dd5ac0bf79c342409c9931", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate Annotation newAnnotation(AST ast, IAnnotationBinding annotation, ImportRewriteContext context)", "signatureAfterChange": " \tpublic Annotation addAnnotation(IAnnotationBinding annotation, AST ast, ImportRewriteContext context)", "diff": ["+\t */", "+\tpublic Annotation addAnnotation(IAnnotationBinding annotation, AST ast, ImportRewriteContext context) {", "+\t\tType type = addImport(annotation.getAnnotationType(), ast, context);", "+\t\tName name;", "+\t\tif (type instanceof SimpleType) {", "+\t\t\tSimpleType simpleType = (SimpleType) type;", "+\t\t\tname = simpleType.getName();", "+\t\t\t// cut 'name' loose from its parent, so that it can be reused", "+\t\t\tsimpleType.setName(ast.newName(\"a\")); //$NON-NLS-1$", "+\t\t} else {", "+\t\t\tname = ast.newName(\"invalid\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\tIMemberValuePairBinding[] mvps= annotation.getDeclaredMemberValuePairs();", "+\t\tif (mvps.length == 0) {", "+\t\t\tMarkerAnnotation result = ast.newMarkerAnnotation();", "+\t\t\tresult.setTypeName(name);", "+\t\t\treturn result;", "+\t\t} else if (mvps.length == 1 && \"value\".equals(mvps[0].getName())) { //$NON-NLS-1$", "+\t\t\tSingleMemberAnnotation result= ast.newSingleMemberAnnotation();", "+\t\t\tresult.setTypeName(name);", "+\t\t\tObject value = mvps[0].getValue();", "+\t\t\tif (value != null)", "+\t\t\t\tresult.setValue(addAnnotation(ast, value, context));", "+\t\t\treturn result;", "+\t\t} else {", "+\t\t\tNormalAnnotation result = ast.newNormalAnnotation();", "+\t\t\tresult.setTypeName(name);", "+\t\t\tfor (int i= 0; i < mvps.length; i++) {", "+\t\t\t\tIMemberValuePairBinding mvp = mvps[i];", "+\t\t\t\tMemberValuePair mvpNode = ast.newMemberValuePair();", "+\t\t\t\tmvpNode.setName(ast.newSimpleName(mvp.getName()));", "+\t\t\t\tObject value = mvp.getValue();", "+\t\t\t\tif (value != null)", "+\t\t\t\t\tmvpNode.setValue(addAnnotation(ast, value, context));", "+\t\t\t\tresult.values().add(mvpNode);", "+\t\t\t}", "+\t\t\treturn result;", "+\t\t}", "+\t}", "-\tprivate Annotation newAnnotation(AST ast, IAnnotationBinding annotation, ImportRewriteContext context) {", "-\t\tType type = addImport(annotation.getAnnotationType(), ast, context);", "-\t\tName name;", "-\t\tif (type instanceof SimpleType) {", "-\t\t\tSimpleType simpleType = (SimpleType) type;", "-\t\t\tname = simpleType.getName();", "-\t\t\t// cut 'name' loose from its parent, so that it can be reused", "-\t\t\tsimpleType.setName(ast.newName(\"a\")); //$NON-NLS-1$", "-\t\t} else {", "-\t\t\tname = ast.newName(\"invalid\"); //$NON-NLS-1$", "-\t\t}", "-", "-\t\tIMemberValuePairBinding[] mvps= annotation.getDeclaredMemberValuePairs();", "-\t\tif (mvps.length == 0) {", "-\t\t\tMarkerAnnotation result = ast.newMarkerAnnotation();", "-\t\t\tresult.setTypeName(name);", "-\t\t\treturn result;", "-\t\t} else if (mvps.length == 1 && \"value\".equals(mvps[0].getName())) { //$NON-NLS-1$", "-\t\t\tSingleMemberAnnotation result= ast.newSingleMemberAnnotation();", "-\t\t\tresult.setTypeName(name);", "-\t\t\tObject value = mvps[0].getValue();", "-\t\t\tif (value != null)", "-\t\t\t\tresult.setValue(newAnnotationValue(ast, value, context));", "-\t\t\treturn result;", "-\t\t} else {", "-\t\t\tNormalAnnotation result = ast.newNormalAnnotation();", "-\t\t\tresult.setTypeName(name);", "-\t\t\tfor (int i= 0; i < mvps.length; i++) {", "-\t\t\t\tIMemberValuePairBinding mvp = mvps[i];", "-\t\t\t\tMemberValuePair mvpNode = ast.newMemberValuePair();", "-\t\t\t\tmvpNode.setName(ast.newSimpleName(mvp.getName()));", "-\t\t\t\tObject value = mvp.getValue();", "-\t\t\t\tif (value != null)", "-\t\t\t\t\tmvpNode.setValue(newAnnotationValue(ast, value, context));", "-\t\t\t\tresult.values().add(mvpNode);", "-\t\t\t}", "-\t\t\treturn result;", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bea4025dc33fb174e431156111efa61e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java", "commitBeforeChange": "8f26d11c4ba332f2be7ec8dbf571250694ed7207", "commitAfterChange": "43a0c55f94ed86f30ef95f5f1ba26a35207a73d3", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 78, "signatureBeforeChange": " \tvoid basicMatch(ASTNode node)", "signatureAfterChange": " \tvoid basicMatch(ASTNode node)", "diff": ["-\t\tint count = nodeCount(node);", "+\t\tTestMatcher[] m = {", "+\t\t\tnew TestMatcher(),", "+\t\t\tnew TestMatcher(true),", "+\t\t\tnew TestMatcher(false)};", "+\t\tfor (int i = 0; i < m.length; i++) {", "+\t\t\t// check that matcher was called with right arguments", "+\t\t\t// and that matches succeed", "+\t\t\tTestMatcher m1 = m[i];", "+\t\t\tObject o1 = new Object();", "+\t\t\tm1.result = true;", "+\t\t\tboolean result = node.subtreeMatch(m1, o1);", "+\t\t\tassertTrue(m1.matchCalls == 1);", "+\t\t\tassertTrue(m1.receiverNode == node);", "+\t\t\tassertTrue(m1.otherNode == o1);", "+\t\t\tassertTrue(result == true);", "+\t\t}", "-\t\t// check that matcher was called with right arguments", "-\t\t// and that matches succeed", "-\t\tTestMatcher m1 = new TestMatcher();", "-\t\tObject o1 = new Object();", "-\t\tm1.result = true;", "-\t\tboolean result = node.subtreeMatch(m1, o1);", "-\t\tassertTrue(m1.matchCalls == 1);", "-\t\tassertTrue(m1.receiverNode == node);", "-\t\tassertTrue(m1.otherNode == o1);", "-\t\tassertTrue(result == true);", "+\t\tm = new TestMatcher[] {", "+\t\t\t\t\t\t\tnew TestMatcher(),", "+\t\t\t\t\t\t\tnew TestMatcher(true),", "+\t\t\t\t\t\t\tnew TestMatcher(false)};", "+\t\tfor (int i = 0; i < m.length; i++) {", "+\t\t\t// check that matcher was called with right arguments", "+\t\t\t// and that non-matches fail", "+\t\t\tTestMatcher m1 = m[i];", "+\t\t\tObject o1 = new Object();", "+\t\t\tm1.result = false;", "+\t\t\tboolean result = node.subtreeMatch(m1, o1);", "+\t\t\tassertTrue(m1.matchCalls == 1);", "+\t\t\tassertTrue(m1.receiverNode == node);", "+\t\t\tassertTrue(m1.otherNode == o1);", "+\t\t\tassertTrue(result == false);", "+\t\t}", "-\t\t// check that matcher was called with right arguments", "-\t\t// and that non-matches fail", "-\t\tm1 = new TestMatcher();", "-\t\to1 = new Object();", "-\t\tm1.result = false;", "-\t\tresult = node.subtreeMatch(m1, o1);", "-\t\tassertTrue(m1.matchCalls == 1);", "-\t\tassertTrue(m1.receiverNode == node);", "-\t\tassertTrue(m1.otherNode == o1);", "-\t\tassertTrue(result == false);", "+\t\t// check that ASTMatcher() default implementations delegate", "+\t\t{", "+\t\t\tint count = nodeCount(node, false); // ignore doc tags", "+\t\t\tTestMatcher m1 = new TestMatcher();", "+\t\t\tm1.superMatch = true;", "+\t\t\tboolean result = node.subtreeMatch(m1, node);", "+\t\t\tassertTrue(m1.matchCalls == count);", "+\t\t\tassertTrue(result == true);", "+\t\t}", "-\t\t// check that ASTMatcher default implementations delegate", "-\t\tm1 = new TestMatcher();", "-\t\tm1.superMatch = true;", "-\t\tresult = node.subtreeMatch(m1, node);", "-\t\tassertTrue(m1.matchCalls == count);", "-\t\tassertTrue(result == true);", "+\t\t// check that ASTMatcher(false) default implementations delegate", "+\t\t{", "+\t\t\tint count = nodeCount(node, false); // ignore doc tags", "+\t\t\tTestMatcher m1 = new TestMatcher(false);", "+\t\t\tm1.superMatch = true;", "+\t\t\tboolean result = node.subtreeMatch(m1, node);", "+\t\t\tassertTrue(m1.matchCalls == count);", "+\t\t\tassertTrue(result == true);", "+\t\t}", "+\t\t", "+\t\t// check that ASTMatcher(true) default implementations delegate", "+\t\t{", "+\t\t\tint count = nodeCount(node, true); // include doc tags", "+\t\t\tTestMatcher m1 = new TestMatcher(true);", "+\t\t\tm1.superMatch = true;", "+\t\t\tboolean result = node.subtreeMatch(m1, node);", "+\t\t\tassertTrue(m1.matchCalls == count);", "+\t\t\tassertTrue(result == true);", "+\t\t}"]}], "num": 25142}