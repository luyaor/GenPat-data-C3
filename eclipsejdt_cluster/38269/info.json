{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c15c9f6069803ae91e78077730e215c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2460db385be4f0210a8dcdbb9ff8bf1d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "08a9fdc71afa0132ac39c0b0527fded03b0bf377", "commitAfterChange": "41212d6ccde0d1bea3d4ddbc47774cebd313e943", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] rawClasspath, IPath projectOutputLocation)", "diff": ["+\t\t\tIPath path = resolvedEntry.getPath();", "-\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\tif ((index = indexOfMatchingPath(path, outputLocations, outputCount)) != -1){", "-\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(resolvedEntry.getPath().lastSegment());", "-\t\t\t\t\tif ((index = indexOfMatchingPath(resolvedEntry.getPath(), outputLocations, outputCount)) != -1){", "+\t\t\t\t\thasLibFolder |= !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(path.lastSegment());", "+\t\t\t\t\tif ((index = indexOfMatchingPath(path, outputLocations, outputCount)) != -1){", "-\t", "-\t", "+\t\t// ensure that no output is coincidating with another source folder (only allowed if matching current source folder)", "+\t\t// perform one separate iteration so as to not take precedence over previously checked scenarii (in particular should", "+\t\t// diagnose nesting source folder issue before this one, e.g. [src]\"Project/\", [src]\"Project/source/\" and output=\"Project/\" should", "+\t\t// first complain about missing exclusion pattern", "+\t\tfor (int i = 0 ; i < length; i++) {", "+\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\tif (entry == null) continue;", "+\t\t\tIPath entryPath = entry.getPath();", "+\t\t\tint kind = entry.getEntryKind();", "+", "+\t\t\tif (kind == IClasspathEntry.CPE_SOURCE) {", "+\t\t\t\tIPath output = entry.getOutputLocation();", "+\t\t\t\tif (output == null) output = projectOutputLocation; // if no specific output, still need to check using default output", "+\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\tIClasspathEntry otherEntry = classpath[j];", "+\t\t\t\t\tif (otherEntry == entry) continue;", "+\t\t\t\t\tswitch (otherEntry.getEntryKind()) {", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE :", "+\t\t\t\t\t\t\tif (otherEntry.getPath().equals(output)) {", "+\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotUseDistinctSourceFolderAsOutput\", entryPath.makeRelative().toString(), otherEntry.getPath().makeRelative().toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY :", "+\t\t\t\t\t\t\tif (otherEntry.getPath().equals(output)) {", "+\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotUseLibraryAsOutput\", entryPath.makeRelative().toString(), otherEntry.getPath().makeRelative().toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}\t\t\t", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b50041a45d0fd58e307e519cfd59b28", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java", "commitBeforeChange": "a118736b4df6d2c2d76c2e8540c6ee6242953cb2", "commitAfterChange": "d90e3df9ed4198288c27321fc19ea2323118c013", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "  \tboolean match(char patternTypeSuffix, char[] patternPkg, char[] patternTypeName, int matchRule, int typeKind, char[] pkg, char[] typeName)", "signatureAfterChange": "  \tboolean match(char patternTypeSuffix, char[] patternPkg, int matchRulePkg, char[] patternTypeName, int matchRuleType, int typeKind, char[] pkg, char[] typeName)", "diff": ["-\tboolean match(char patternTypeSuffix, char[] patternPkg, char[] patternTypeName, int matchRule, int typeKind, char[] pkg, char[] typeName) {", "+\tboolean match(char patternTypeSuffix, char[] patternPkg, int matchRulePkg, char[] patternTypeName, int matchRuleType, int typeKind, char[] pkg, char[] typeName) {", "-\t\treturn match(patternPkg, matchRule, patternTypeName, matchRule, pkg, typeName);", "-\t}", "+", "+\t\tboolean isCaseSensitive = (matchRuleType & SearchPattern.R_CASE_SENSITIVE) != 0;", "+\t\t\tboolean isCamelCase = (matchRuleType & (SearchPattern.R_CAMELCASE_MATCH | SearchPattern.R_CAMELCASE_SAME_PART_COUNT_MATCH)) != 0;", "+\t\t\tint matchMode = matchRuleType & JavaSearchPattern.MATCH_MODE_MASK;"]}], "num": 38269}