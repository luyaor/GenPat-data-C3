{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c225111c91fa6f9e716c769703bd18fd", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8c28015ca23939f6a774178bda48c3df", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e37ddd2cb60251da977bfe008d0c558febeb1616", "commitAfterChange": "ddff16f6a6b8fee88d497b4653d14d58ccda81b4", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["+\tboolean playingTrump = false;", "-\t\t\t// re-checking compatibility is needed for https://bugs.eclipse.org/346029", "-\t\t\tif (concreteMethod != null && !(isOverridden[i] && areMethodsCompatible(concreteMethod, methods[i]))) {", "-\t\t\t\t// 8.4.8.4 defines an exception for default methods if", "-\t\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "-\t\t\t\t// (b) that is override-equivalent with the two methods.", "-\t\t\t\tif (methods[i].isDefaultMethod() ", "-\t\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "-\t\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "-\t\t\t\t\t\t&& areParametersEqual(superClassMethod, concreteMethod)) {", "-\t\t\t\t\t// skip, class method trumps this default method", "-\t\t\t\t} else {", "+\t\t\t// 8.4.8.4 defines an exception for default methods if", "+\t\t\t// (a) there exists an abstract method declared in a superclass of C and inherited by C", "+\t\t\t// (b) that is override-equivalent with the two methods.", "+\t\t\tif (methods[i].isDefaultMethod()", "+\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t&& (concreteMethod == null || areParametersEqual(superClassMethod, concreteMethod))) {", "+\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\tplayingTrump = true;", "+\t\t\t} else {", "+\t\t\t\tplayingTrump = false;", "+\t\t\t\t// re-checking compatibility is needed for https://bugs.eclipse.org/346029", "+\t\t\t\tif (concreteMethod != null && !(isOverridden[i] && areMethodsCompatible(concreteMethod, methods[i]))) {", "+\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {", "+\t\t\tif (playingTrump) {", "+\t\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "+\t\t\t\tif (!this.type.isAbstract()) {", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tif (methods[i] == concreteMethod) continue;", "+\t\t\t\t\t\tif (!doesMethodOverride(concreteMethod, methods[i])) {", "+\t\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[i]);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (this.environment.globalOptions.complianceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\t\tif (!checkInheritedDefaultMethods(methods, length))", "+\t\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc57dcc2b26ca6aba7877699a64be8ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "11ebb7eac78033ed4b8b7f8bf2dae372f511166c", "commitAfterChange": "ba04cb6ba4b5497c184d335aa777690304f7e67a", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden)", "diff": ["-\tMethodBinding superClassMethod = null;", "-\tboolean playingTrump = false;", "+\tMethodBinding abstractSuperClassMethod = null;", "+\tboolean playingTrump = false; // invariant: playingTrump => (concreteMethod == null)", "-\t\tif (!methods[i].declaringClass.isInterface() && methods[i].declaringClass != this.type) {", "-\t\t\tsuperClassMethod = methods[i];", "+\t\tif (!methods[i].declaringClass.isInterface()", "+\t\t\t\t&& methods[i].declaringClass != this.type", "+\t\t\t\t&& methods[i].isAbstract())", "+\t\t{", "+\t\t\tabstractSuperClassMethod = methods[i];", "-\t\t\t\t\t&& superClassMethod != null\t\t\t\t\t\t\t// condition (a)", "-\t\t\t\t\t&& areParametersEqual(superClassMethod, methods[i]) // condition (b)...", "-\t\t\t\t\t&& (concreteMethod == null || areParametersEqual(superClassMethod, concreteMethod))) {", "-\t\t\t\t// skip, class method trumps this default method", "+\t\t\t\t\t&& abstractSuperClassMethod != null\t\t\t\t\t\t\t// condition (a)", "+\t\t\t\t\t&& areParametersEqual(abstractSuperClassMethod, methods[i]) // condition (b)...", "+\t\t\t\t\t&& concreteMethod == null) {", "+\t\t\t\t// skip, class method trumps this default method (concreteMethod remains null)", "+\t\t\t\tconcreteMethod = methods[i];", "-\t\t\tconcreteMethod = methods[i];", "-\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {", "-\t\t\tif (playingTrump) {", "-\t\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "-\t\t\t\tif (!this.type.isAbstract()) {", "-\t\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\t\tif (methods[i] == concreteMethod) continue;", "-\t\t\t\t\t\tif (!doesMethodOverride(concreteMethod, methods[i])) {", "-\t\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[i]);", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "+\t\tif (playingTrump) {", "+\t\t\t// multiple abstract & default methods are OK on this branch, but then the class must be declared abstract:", "+\t\t\tif (!this.type.isAbstract()) {", "+\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, abstractSuperClassMethod);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tif (concreteMethod != null && concreteMethod.isDefaultMethod()) {"]}], "num": 65654}