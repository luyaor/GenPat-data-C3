{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b6435b66035903077d56f3a635b40e6c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f41c767e8c1425d33dba2ee8066d300", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "f28c28de6ed3d2e9e475bca36caf25c219a92533", "commitAfterChange": "29530aea390a72e4225d01267051bcdef2bb5cd8", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tpublic ASTNode convert(boolean isInterface, org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": "  \tpublic ASTNode convert(boolean isInterface, org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\t\tif (block != null", "-\t\t\t\t\t&& (Modifier.isAbstract(methodDecl.getModifiers())", "-\t\t\t\t\t\t\t|| Modifier.isNative(methodDecl.getModifiers())", "-\t\t\t\t\t\t\t|| isInterface)) {", "-\t\t\t\tmethodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);", "+\t\t\tif (block != null) {", "+\t\t\t\tif ((methodDeclaration.modifiers & (ClassFileConstants.AccAbstract | ClassFileConstants.AccNative)) != 0", "+\t\t\t\t\t\t|| (isInterface && (this.ast.apiLevel < AST.JLS8 ||", "+\t\t\t\t\t\t\t(methodDeclaration.modifiers & (ClassFileConstants.AccStatic | ExtraCompilerModifiers.AccDefaultMethod)) == 0))) {", "+\t\t\t\t\tmethodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12dfdd1cf45db4eaccd218b7e6e236f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CaseStatement.java", "commitBeforeChange": "b418235473d69146fcb35be10bf158bb2b040cf7", "commitAfterChange": "eadf5ba6d44f28f071965cf829d67590b0a71974", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "signatureAfterChange": " public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement)", "diff": ["+ */", "+public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "+\t// switchExpressionType maybe null in error case", "+    scope.enclosingCase = this; // record entering in a switch case block", "+    ", "+\tif (this.constantExpression == null) {", "+\t\t// remember the default case into the associated switch statement", "+\t\tif (switchStatement.defaultCase != null)", "+\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t */", "-\tpublic Constant resolveCase(BlockScope scope, TypeBinding switchExpressionType, SwitchStatement switchStatement) {", "-\t\t// switchExpressionType maybe null in error case", "-\t    scope.enclosingCase = this; // record entering in a switch case block", "-\t    ", "-\t\tif (constantExpression == null) {", "-\t\t\t// remember the default case into the associated switch statement", "-\t\t\tif (switchStatement.defaultCase != null)", "-\t\t\t\tscope.problemReporter().duplicateDefaultCase(this);", "-\t", "-\t\t\t// on error the last default will be the selected one ...\t", "-\t\t\tswitchStatement.defaultCase = this;", "-\t\t\treturn Constant.NotAConstant;", "-\t\t}", "-\t\t// add into the collection of cases of the associated switch statement", "-\t\tswitchStatement.cases[switchStatement.caseCount++] = this;", "-\t\t// tag constant name with enum type for privileged access to its members", "-\t\tif (switchExpressionType != null && switchExpressionType.isEnum() && (constantExpression instanceof SingleNameReference)) {", "-\t\t\t((SingleNameReference) constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "-\t\t}", "-\t\tTypeBinding caseType = constantExpression.resolveType(scope);", "-\t\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "-\t\tif (constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "-\t\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "-\t\t\tif (caseType.isEnum()) {", "-\t\t\t\tthis.isEnumConstant = true;", "-\t\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "-\t\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "-\t\t\t\t}", "-", "-\t\t\t\tif (constantExpression instanceof NameReference", "-\t\t\t\t\t\t&& (constantExpression.bits & RestrictiveFlagMASK) == Binding.FIELD) {", "-\t\t\t\t\tNameReference reference = (NameReference) constantExpression;", "-\t\t\t\t\tFieldBinding field = reference.fieldBinding();", "-\t\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "-\t\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "-\t\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "-\t\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\treturn constantExpression.constant;", "-\t\t\t}", "-\t\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "-\t\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "-\t\t\t\t\t\t\t\t&& constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "-\t\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "-\t\t\treturn constantExpression.constant;", "-\t\t}", "-\t\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, constantExpression);", "+\t\t// on error the last default will be the selected one ...\t", "+\t\tswitchStatement.defaultCase = this;", "+\t// add into the collection of cases of the associated switch statement", "+\tswitchStatement.cases[switchStatement.caseCount++] = this;", "+\t// tag constant name with enum type for privileged access to its members", "+\tif (switchExpressionType != null && switchExpressionType.isEnum() && (this.constantExpression instanceof SingleNameReference)) {", "+\t\t((SingleNameReference) this.constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionType);", "+\tTypeBinding caseType = this.constantExpression.resolveType(scope);", "+\tif (caseType == null || switchExpressionType == null) return Constant.NotAConstant;", "+\tif (this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionType)", "+\t\t\t|| caseType.isCompatibleWith(switchExpressionType)) {", "+\t\tif (caseType.isEnum()) {", "+\t\t\tif (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {", "+\t\t\t\tscope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);", "+\t\t\t}", "+", "+\t\t\tif (this.constantExpression instanceof NameReference", "+\t\t\t\t\t&& (this.constantExpression.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {", "+\t\t\t\tNameReference reference = (NameReference) this.constantExpression;", "+\t\t\t\tFieldBinding field = reference.fieldBinding();", "+\t\t\t\tif ((field.modifiers & ClassFileConstants.AccEnum) == 0) {", "+\t\t\t\t\t scope.problemReporter().enumSwitchCannotTargetField(reference, field);", "+\t\t\t\t} else \tif (reference instanceof QualifiedNameReference) {", "+\t\t\t\t\t scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);", "+\t\t\t\t}", "+\t\t\t\treturn IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810", "+\t\t\t}", "+\t\t} else {", "+\t\t\treturn this.constantExpression.constant;", "+\t\t}", "+\t} else if (scope.isBoxingCompatibleWith(caseType, switchExpressionType)", "+\t\t\t\t\t|| (caseType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t&& scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t&& !switchExpressionType.isBaseType()", "+\t\t\t\t\t\t\t&& this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, scope.environment().computeBoxingType(switchExpressionType)))) {", "+\t\t// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion", "+\t\treturn this.constantExpression.constant;", "+\t}", "+\tscope.problemReporter().typeMismatchError(caseType, switchExpressionType, this.constantExpression);", "+\treturn Constant.NotAConstant;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28317dae35930a6e5511e4ecbf6ff37a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java", "commitBeforeChange": "ad30422de59b5093c5225e2a4599516c056303dc", "commitAfterChange": "c1c045ff9c256acaa6d98530fa4640b4cd80b7c6", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tconstant = NotAConstant;", "+\t\tthis.constant = NotAConstant;", "-\t\texpression.setExpectedType(lhsType); // needed in case of generic method invocation", "+\t\tthis.expression.setExpectedType(lhsType); // needed in case of generic method invocation", "-\t\tTypeBinding rhsType = expression.resolveType(scope);", "+\t\tTypeBinding rhsType = this.expression.resolveType(scope);", "-\t\tif ((expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "+\t\tif ((this.expression.isConstantValueOfTypeAssignableToType(rhsType, lhsType)", "-\t\t\texpression.computeConversion(scope, lhsType, rhsType);", "+\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType)) {", "-\t\t\texpression.computeConversion(scope, lhsType, rhsType);", "+\t\t} else if (scope.isBoxingCompatibleWith(rhsType, lhsType) ", "+\t\t\t\t\t\t\t|| (rhsType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t&& !lhsType.isBaseType()", "+\t\t\t\t\t\t\t\t\t&& this.expression.isConstantValueOfTypeAssignableToType(rhsType, scope.environment().computeBoxingType(lhsType)))) {", "+\t\t\tthis.expression.computeConversion(scope, lhsType, rhsType);", "-\t\tscope.problemReporter().typeMismatchError(rhsType, lhsType, expression);", "+\t\tscope.problemReporter().typeMismatchError(rhsType, lhsType, this.expression);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39e57b3398c319a0027aa01885f005c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveForCatch(BlockScope scope)", "diff": ["-\t\t\t\tcase Binding.ARRAY_TYPE :", "-\t\t\t\t\tif (((ArrayBinding) exceptionType).leafComponentType == TypeBinding.VOID) {", "-\t\t\t\t\t\tscope.problemReporter().variableTypeCannotBeVoidArray(this);", "-\t\t\t\t\t\thasError = true;", "-\t\t\t\t\t\t// fall thru to create the variable - avoids additional errors because the variable is missing", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-", "-\t\tthis.binding = new LocalVariableBinding(this, exceptionType, this.modifiers, false); // argument decl, but local var  (where isArgument = false)", "+\t\t", "+\t\tif ((this.type.bits & ASTNode.IsUnionType) != 0) {", "+\t\t\tthis.binding = new CatchParameterBinding(this, exceptionType, this.modifiers | ClassFileConstants.AccFinal, false); // argument decl, but local var  (where isArgument = false)", "+\t\t\tthis.binding.tagBits |= TagBits.MultiCatchParameter;", "+\t\t} else {", "+\t\t\tthis.binding = new CatchParameterBinding(this, exceptionType, this.modifiers, false); // argument decl, but local var  (where isArgument = false)", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48b3e78b634b88b3e09a0e7d68ba306f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java", "commitBeforeChange": "d9032a87dfcb69e19b4c3aae869d4a786d1fb149", "commitAfterChange": "eee6512d26cd1c50a9b02d1b4b78531f507d95fc", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r \tprivate char[] findSource(ClassFile classFile)", "signatureAfterChange": "\r \tprivate String getSourceFileName()", "diff": ["-\tprivate char[] findSource(ClassFile classFile) {\r", "-\t\t\tSourceMapper sourceMapper = classFile.getSourceMapper();\r", "-\t\t\t\tIType type = classFile.getType();\r", "-\t\t\t\tif (classFile.isOpen() && type.getDeclaringType() == null) {\r", "-\t\t\t\t\tsource = sourceMapper.findSource(type);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tClassFileReader reader = this.locator.classFileReader(type);\r", "-\t\t\t\t\tif (reader != null) {\r", "-\t\t\t\t\t\tsource = sourceMapper.findSource(type, reader);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "+\t */\r", "+\tprivate String getSourceFileName() {\r", "+\t\tif (this.sourceFileName != null) return this.sourceFileName;\r", "+\t\tthis.sourceFileName = NO_SOURCE_FILE_NAME; \r", "+\t\ttry {\r", "+\t\t\tSourceMapper sourceMapper = this.openable.getSourceMapper();\r", "+\t\t\tif (sourceMapper != null) {\r", "+\t\t\t\tIType type = ((ClassFile)this.openable).getType();\r", "+\t\t\t\tClassFileReader reader = this.locator.classFileReader(type);\r", "+\t\t\t\tif (reader != null) {\r", "+\t\t\t\t\tthis.sourceFileName = sourceMapper.findSourceFileName(type, reader);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t}\r", "+\t\treturn this.sourceFileName;\r", "+\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "515c1c57851cdecc2e5e522e4fd77dfe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "aec729ad3adcaa5e52d24a53651dd8b9e99d3639", "commitAfterChange": "44335de1fa884744b7a885d0019e36f5505aad65", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-        \tfinal boolean isStatic = someMethod.isStatic();", "-        \tif (isStatic && (this.haveReceiver || this.receiverType.isParameterizedTypeWithActualArguments())) {", "+    \t\tif (someMethod.isStatic() && (this.haveReceiver || this.receiverType.isParameterizedTypeWithActualArguments())) {", "-        \tif (!this.haveReceiver) {", "-        \t\tif (!isStatic && !someMethod.isConstructor()) {", "-        \t\t\tscope.problemReporter().methodMustBeAccessedWithInstance(this, someMethod);", "-        \t\t\treturn this.resolvedType = null;", "-        \t\t}", "-        \t} ", "-        \tif (anotherMethod != null && anotherMethod.isValidBinding() && anotherMethod.isStatic()) {", "-        \t\tscope.problemReporter().methodMustBeAccessedStatically(this, anotherMethod);", "-        \t\treturn this.resolvedType = null;", "-        \t}", "-        if (someMethod != null && someMethod.isValidBinding() && anotherMethod != null && anotherMethod.isValidBinding()) {", "+        if (someMethod != null && someMethod.isValidBinding() && someMethod.isStatic() && anotherMethod != null && anotherMethod.isValidBinding() && !anotherMethod.isStatic()) {", "-        if (someMethod != null && someMethod.isValidBinding()) {", "+        if (someMethod != null && someMethod.isValidBinding() && (anotherMethod == null || !anotherMethod.isValidBinding() || anotherMethod.isStatic())) {", "-        } else if (anotherMethod != null && anotherMethod.isValidBinding()) {", "+        \tif (!this.haveReceiver) {", "+        \t\tif (!someMethod.isStatic() && !someMethod.isConstructor()) {", "+        \t\t\tscope.problemReporter().methodMustBeAccessedWithInstance(this, someMethod);", "+        \t\t\treturn this.resolvedType = null;", "+        \t\t}", "+        \t} ", "+        } else if (anotherMethod != null && anotherMethod.isValidBinding() && (someMethod == null || !someMethod.isValidBinding() || !someMethod.isStatic())) {", "+        \tif (anotherMethod.isStatic()) {", "+        \t\tscope.problemReporter().methodMustBeAccessedStatically(this, anotherMethod);", "+        \t\treturn this.resolvedType = null;", "+        \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a46fd3390fdaa9e9aa4e81464834ccc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NaiveASTFlattener.java", "commitBeforeChange": "59119c56d69b798c59e5389db2508c4896e5dbdf", "commitAfterChange": "c861a0381ba1376aa01c18d9f68e1168bdac8aab", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tvoid printModifiers(int modifiers)", "signatureAfterChange": " \tvoid printModifiers(int modifiers)", "diff": ["-\t\t\tbuffer.append(\"public \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"public \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"protected \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"protected \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"private \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"private \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"static \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"static \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"abstract \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"abstract \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"final \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"final \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"synchronized \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"synchronized \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"volatile \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"volatile \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"native \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"native \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"strictfp \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"strictfp \");//$NON-NLS-1$", "-\t\t\tbuffer.append(\"transient \");//$NON-NLS-1$", "+\t\t\tthis.buffer.append(\"transient \");//$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f553bdedbc882b30bee24271a9b1333", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t */", "-\tpublic FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream) {", "-\t\t\t", "-\t\t// determine the rank until which we now we do not need any actual value for the field access", "-\t\tint otherBindingsCount = this.otherCodegenBindings == null ? 0 : otherCodegenBindings.length;", "-\t\tboolean needValue = otherBindingsCount == 0 || !this.otherBindings[0].isStatic();", "-\t\tFieldBinding lastFieldBinding = null;", "-\t\tTypeBinding lastGenericCast = null;", "-\t\tboolean complyTo14 = currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4;", "-", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD :", "-\t\t\t\tlastFieldBinding = (FieldBinding) this.codegenBinding;", "-\t\t\t\tlastGenericCast = this.genericCast;", "-\t\t\t\t// if first field is actually constant, we can inline it", "-\t\t\t\tif (lastFieldBinding.constant() != Constant.NotAConstant) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tif ((needValue && !lastFieldBinding.isStatic()) || lastGenericCast != null) {", "-\t\t\t\t\tint pc = codeStream.position;", "-\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "-\t\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tgenerateReceiver(codeStream);", "-\t\t\t\t\t}", "-\t\t\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase Binding.LOCAL : // reading the first local variable", "-\t\t\t\tif (!needValue) break; // no value needed", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "-\t\t\t\t// regular local variable read", "-\t\t\t\tConstant localConstant = localBinding.constant();", "-\t\t\t\tif (localConstant != Constant.NotAConstant) {", "-\t\t\t\t\tcodeStream.generateConstant(localConstant, 0);", "-\t\t\t\t\t// no implicit conversion", "-\t\t\t\t} else {", "-\t\t\t\t\t// outer local?", "-\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\t// outer local can be reached either through a synthetic arg or a synthetic field", "-\t\t\t\t\t\tVariableBinding[] path = currentScope.getEmulationPath(localBinding);", "-\t\t\t\t\t\tcodeStream.generateOuterAccess(path, this, localBinding, currentScope);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.load(localBinding);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t\t\t", "-\t\t// all intermediate field accesses are read accesses", "-\t\t// only the last field binding is a write access", "-\t\tint positionsLength = this.sourcePositions.length;", "-\t\tif (this.otherCodegenBindings != null) {", "-\t\t\tfor (int i = 0; i < otherBindingsCount; i++) {", "-\t\t\t\tint pc = codeStream.position;", "-\t\t\t\tFieldBinding nextField = this.otherCodegenBindings[i];", "-\t\t\t\tTypeBinding nextGenericCast = this.otherGenericCasts == null ? null : this.otherGenericCasts[i];", "-\t\t\t\tif (lastFieldBinding != null) {", "-\t\t\t\t\tneedValue = !nextField.isStatic();", "-\t\t\t\t\tConstant fieldConstant = lastFieldBinding.constant();", "-\t\t\t\t\tif (fieldConstant != Constant.NotAConstant) {", "-\t\t\t\t\t\tif (i > 0 && !lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\tcodeStream.invokeObjectGetClass(); // perform null check", "-\t\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (needValue) {", "-\t\t\t\t\t\t\tcodeStream.generateConstant(fieldConstant, 0);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (needValue || (i > 0 && complyTo14) || lastGenericCast != null) {", "-\t\t\t\t\t\t\tMethodBinding accessor = syntheticReadAccessors == null ? null : syntheticReadAccessors[i]; ", "-\t\t\t\t\t\t\tif (accessor == null) {", "-\t\t\t\t\t\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (lastGenericCast != null) codeStream.checkcast(lastGenericCast);", "-\t\t\t\t\t\t\tif (!needValue) codeStream.pop();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (this.codegenBinding == lastFieldBinding) {", "-\t\t\t\t\t\t\t\tif (lastFieldBinding.isStatic()){", "-\t\t\t\t\t\t\t\t\t// if no valueRequired, still need possible side-effects of <clinit> invocation, if field belongs to different class", "-\t\t\t\t\t\t\t\t\tif (((FieldBinding)binding).original().declaringClass != this.actualReceiverType.erasure()) {", "-\t\t\t\t\t\t\t\t\t\tMethodBinding accessor = syntheticReadAccessors == null ? null : syntheticReadAccessors[i]; ", "-\t\t\t\t\t\t\t\t\t\tif (accessor == null) {", "-\t\t\t\t\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\tcodeStream.invokestatic(accessor);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (!lastFieldBinding.isStatic()){", "-\t\t\t\t\t\t\t\tcodeStream.invokeObjectGetClass(); // perform null check", "-\t\t\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif ((positionsLength - otherBindingsCount + i - 1) >= 0) {", "-\t\t\t\t\t\t\tint fieldPosition = (int) (this.sourcePositions[positionsLength - otherBindingsCount + i - 1] >>>32);", "-\t\t\t\t\t\t\tcodeStream.recordPositionsFrom(pc, fieldPosition);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tlastFieldBinding = nextField;", "-\t\t\t\tlastGenericCast = nextGenericCast;", "-\t\treturn lastFieldBinding;", "+ */", "+public FieldBinding generateReadSequence(BlockScope currentScope, CodeStream codeStream) {", "+\t// determine the rank until which we now we do not need any actual value for the field access", "+\tint otherBindingsCount = this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length;", "+\tboolean needValue = otherBindingsCount == 0 || !this.otherBindings[0].isStatic();", "+\tFieldBinding lastFieldBinding = null;", "+\tTypeBinding lastGenericCast = null;", "+\tboolean complyTo14 = currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4;", "+", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD :", "+\t\t\tlastFieldBinding = (FieldBinding) this.codegenBinding;", "+\t\t\tlastGenericCast = this.genericCast;", "+\t\t\t// if first field is actually constant, we can inline it", "+\t\t\tif (lastFieldBinding.constant() != Constant.NotAConstant) {", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tif ((needValue && !lastFieldBinding.isStatic()) || lastGenericCast != null) {", "+\t\t\t\tint pc = codeStream.position;", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);", "+\t\t\t\t\tObject[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);", "+\t\t\t\t\tcodeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);", "+\t\t\t\t} else {", "+\t\t\t\t\tgenerateReceiver(codeStream);", "+\t\t\t\t}", "+\t\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase Binding.LOCAL : // reading the first local variable", "+\t\t\tif (!needValue) break; // no value needed", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;", "+\t\t\t// regular local variable read", "+\t\t\tConstant localConstant = localBinding.constant();", "+\t\t\tif (localConstant != Constant.NotAConstant) {", "+\t\t\t\tcodeStream.generateConstant(localConstant, 0);", "+\t\t\t\t// no implicit conversion", "+\t\t\t} else {", "+\t\t\t\t// outer local?", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\t// outer local can be reached either through a synthetic arg or a synthetic field", "+\t\t\t\t\tVariableBinding[] path = currentScope.getEmulationPath(localBinding);", "+\t\t\t\t\tcodeStream.generateOuterAccess(path, this, localBinding, currentScope);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.load(localBinding);", "+\t\t\t\t}", "+\t\t\t}", "+\t}", "+\t\t\t\t\t", "+\t// all intermediate field accesses are read accesses", "+\t// only the last field binding is a write access", "+\tint positionsLength = this.sourcePositions.length;", "+\tif (this.otherCodegenBindings != null) {", "+\t\tfor (int i = 0; i < otherBindingsCount; i++) {", "+\t\t\tint pc = codeStream.position;", "+\t\t\tFieldBinding nextField = this.otherCodegenBindings[i];", "+\t\t\tTypeBinding nextGenericCast = this.otherGenericCasts == null ? null : this.otherGenericCasts[i];", "+\t\t\tif (lastFieldBinding != null) {", "+\t\t\t\tneedValue = !nextField.isStatic();", "+\t\t\t\tConstant fieldConstant = lastFieldBinding.constant();", "+\t\t\t\tif (fieldConstant != Constant.NotAConstant) {", "+\t\t\t\t\tif (i > 0 && !lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\tcodeStream.invokeObjectGetClass(); // perform null check", "+\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (needValue) {", "+\t\t\t\t\t\tcodeStream.generateConstant(fieldConstant, 0);", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tif (needValue || (i > 0 && complyTo14) || lastGenericCast != null) {", "+\t\t\t\t\t\tMethodBinding accessor = this.syntheticReadAccessors == null ? null : this.syntheticReadAccessors[i]; ", "+\t\t\t\t\t\tif (accessor == null) {", "+\t\t\t\t\t\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tcodeStream.getfield(lastFieldBinding);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tcodeStream.invokestatic(accessor);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (lastGenericCast != null) codeStream.checkcast(lastGenericCast);", "+\t\t\t\t\t\tif (!needValue) codeStream.pop();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (this.codegenBinding == lastFieldBinding) {", "+\t\t\t\t\t\t\tif (lastFieldBinding.isStatic()){", "+\t\t\t\t\t\t\t\t// if no valueRequired, still need possible side-effects of <clinit> invocation, if field belongs to different class", "+\t\t\t\t\t\t\t\tif (((FieldBinding)this.binding).original().declaringClass != this.actualReceiverType.erasure()) {", "+\t\t\t\t\t\t\t\t\tMethodBinding accessor = this.syntheticReadAccessors == null ? null : this.syntheticReadAccessors[i]; ", "+\t\t\t\t\t\t\t\t\tif (accessor == null) {", "+\t\t\t\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tcodeStream.invokestatic(accessor);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\t\t\t\t}\t\t\t\t", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (!lastFieldBinding.isStatic()){", "+\t\t\t\t\t\t\tcodeStream.invokeObjectGetClass(); // perform null check", "+\t\t\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t\tif ((positionsLength - otherBindingsCount + i - 1) >= 0) {", "+\t\t\t\t\t\tint fieldPosition = (int) (this.sourcePositions[positionsLength - otherBindingsCount + i - 1] >>>32);", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(pc, fieldPosition);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tlastFieldBinding = nextField;", "+\t\t\tlastGenericCast = nextGenericCast;", "+\treturn lastFieldBinding;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70e09b2b8ff65b7a4bf10af25827d883", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\t\treceiver.generateCode(currentScope, codeStream, false);", "+\t\tthis.receiver.generateCode(currentScope, codeStream, false);", "-\t} else if ((bits & DepthMASK) != 0 && receiver.isImplicitThis()) { // outer access ?", "+\t} else if ((this.bits & ASTNode.DepthMASK) != 0 && this.receiver.isImplicitThis()) { // outer access ?", "-\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);\t\t", "+\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT);\t\t", "-\t\treceiver.generateCode(currentScope, codeStream, true);", "+\t\tthis.receiver.generateCode(currentScope, codeStream, true);", "-\tgenerateArguments(binding, arguments, currentScope, codeStream);", "+\tgenerateArguments(this.binding, this.arguments, currentScope, codeStream);", "-\tif (syntheticAccessor == null){", "+\tif (this.syntheticAccessor == null){", "-\t\t\tif( (receiver.isSuper()) || this.codegenBinding.isPrivate()){", "+\t\t\tif( (this.receiver.isSuper()) || this.codegenBinding.isPrivate()){", "-\t\tcodeStream.invokestatic(syntheticAccessor);", "+\t\tcodeStream.invokestatic(this.syntheticAccessor);", "-\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\tboolean isUnboxing = (implicitConversion & TypeIds.UNBOXING) != 0;", "+\t\tboolean isUnboxing = (this.implicitConversion & TypeIds.UNBOXING) != 0;", "-\t\tif (isUnboxing) codeStream.generateImplicitConversion(implicitConversion);", "+\t\tif (isUnboxing) codeStream.generateImplicitConversion(this.implicitConversion);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82ca4818590165d063924df0c09804da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t \tprivate LocalTypeBinding buildLocalType(SourceTypeBinding enclosingType, ReferenceBinding anonymousOriginalSuperType, PackageBinding packageBinding)", "signatureAfterChange": " \t \tprivate LocalTypeBinding buildLocalType(SourceTypeBinding enclosingType, ReferenceBinding anonymousOriginalSuperType, PackageBinding packageBinding)", "diff": ["-\t\treferenceContext.scope = this;", "-\t\treferenceContext.staticInitializerScope = new MethodScope(this, referenceContext, true);", "-\t\treferenceContext.initializerScope = new MethodScope(this, referenceContext, false);", "+\t\tthis.referenceContext.scope = this;", "+\t\tthis.referenceContext.staticInitializerScope = new MethodScope(this, this.referenceContext, true);", "+\t\tthis.referenceContext.initializerScope = new MethodScope(this, this.referenceContext, false);", "-\t\treferenceContext.binding = localType;", "+\t\tthis.referenceContext.binding = localType;", "-\t\tif (referenceContext.memberTypes != null) {", "-\t\t\tint size = referenceContext.memberTypes.length;", "+\t\tif (this.referenceContext.memberTypes != null) {", "+\t\t\tint size = this.referenceContext.memberTypes.length;", "-\t\t\t\tTypeDeclaration memberContext = referenceContext.memberTypes[i];", "+\t\t\t\tTypeDeclaration memberContext = this.referenceContext.memberTypes[i];", "-\t\t\t\t\tif (CharOperation.equals(referenceContext.memberTypes[j].name, memberContext.name)) {", "+\t\t\t\t\tif (CharOperation.equals(this.referenceContext.memberTypes[j].name, memberContext.name)) {", "-\t\t\t\tClassScope memberScope = new ClassScope(this, referenceContext.memberTypes[i]);", "+\t\t\t\tClassScope memberScope = new ClassScope(this, this.referenceContext.memberTypes[i]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "952e2a7ed0533fe458ef3ef06c23a878", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "14f89ca9b18a3480429e3f25bc68dd79b7e9f0db", "commitAfterChange": "eb21ce31e87e64ed6c3b487b0fe31d2556ab8015", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames)", "signatureAfterChange": " protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames)", "diff": ["-\tIJavaElement[] matches = new IJavaElement[] {};", "-\t\t\t\tmatches = growAndAddToArray(matches, methods[i]);", "+\t\t\t\taddElement(methods[i]);", "-\tif (matches.length == 0) {", "+\tif (this.elementIndex == -1) {", "-\t\tfElements = growAndAddToArray(fElements, type);", "+\t\taddElement(type);", "-\tif (matches.length == 1) {", "-\t\tfElements = growAndAddToArray(fElements, matches[0]);", "+\tif (this.elementIndex == 0) {", "-\t\t\tSystem.out.print(matches[0].toString());", "+\t\t\tSystem.out.print(this.elements[0].toString());", "-\tfor (int i = 0; i < matches.length; i++) {", "+\tIJavaElement[] matches = this.elements;", "+\tint matchesIndex = this.elementIndex;", "+\tthis.elements = JavaElement.NO_ELEMENTS;", "+\tthis.elementIndex = -1;", "+\tfor (int i = 0; i <= matchesIndex; i++) {", "-\t\t\tfElements = growAndAddToArray(fElements, method);", "+\t\t\taddElement(method);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac18a700c01870f306a11f3647b58e30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tSourceTypeBinding buildType(SourceTypeBinding enclosingType, PackageBinding packageBinding, AccessRestriction accessRestriction)", "signatureAfterChange": " \t \tSourceTypeBinding buildType(SourceTypeBinding enclosingType, PackageBinding packageBinding, AccessRestriction accessRestriction)", "diff": ["-\t\treferenceContext.scope = this;", "-\t\treferenceContext.staticInitializerScope = new MethodScope(this, referenceContext, true);", "-\t\treferenceContext.initializerScope = new MethodScope(this, referenceContext, false);", "+\t\tthis.referenceContext.scope = this;", "+\t\tthis.referenceContext.staticInitializerScope = new MethodScope(this, this.referenceContext, true);", "+\t\tthis.referenceContext.initializerScope = new MethodScope(this, this.referenceContext, false);", "-\t\t\tchar[][] className = CharOperation.arrayConcat(packageBinding.compoundName, referenceContext.name);", "-\t\t\treferenceContext.binding = new SourceTypeBinding(className, packageBinding, this);", "+\t\t\tchar[][] className = CharOperation.arrayConcat(packageBinding.compoundName, this.referenceContext.name);", "+\t\t\tthis.referenceContext.binding = new SourceTypeBinding(className, packageBinding, this);", "-\t\t\t\tCharOperation.concat(className[className.length - 1], referenceContext.name, '$');", "+\t\t\t\tCharOperation.concat(className[className.length - 1], this.referenceContext.name, '$');", "-\t\t\t\t\tthis.parent.problemReporter().duplicateNestedType(referenceContext);", "+\t\t\t\t\tthis.parent.problemReporter().duplicateNestedType(this.referenceContext);", "-\t\t\treferenceContext.binding = new MemberTypeBinding(className, this, enclosingType);", "+\t\t\tthis.referenceContext.binding = new MemberTypeBinding(className, this, enclosingType);", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;", "+\t\tSourceTypeBinding sourceType = this.referenceContext.binding;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ba49767a5286001073a814564780268c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java", "commitBeforeChange": "075f0337e26b45d6db80c1a335ec63cbf2bb29bc", "commitAfterChange": "8763fd61fbb9bac9c60358b19ee8908fb0b49d4b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic Openable createOpenable(String resourcePath, IJavaSearchScope scope)", "signatureAfterChange": " \tpublic Openable createOpenable(String resourcePath, IJavaSearchScope scope)", "diff": ["-\t\t\t\tIPackageFragmentRoot root= this.getJarPkgFragmentRoot(jarPath, scope);", "+\t\t\t\tPackageFragmentRoot root= getJarPkgFragmentRoot(jarPath, scope);", "-\t\t\t\tpkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);", "+\t\t\t\tpkgFragment= this.lastPkgFragmentRoot.getPackageFragment(pkgName);", "+\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isExcluded(resourcePath.toCharArray(), this.lastPkgFragmentRoot.fullInclusionPatternChars(), this.lastPkgFragmentRoot.fullExclusionPatternChars(), false)", "-\t\t\t\tIPackageFragmentRoot root= this.getPkgFragmentRoot(resourcePath);", "+\t\t\t\tPackageFragmentRoot root= getPkgFragmentRoot(resourcePath);", "-\t\t\t\tpkgFragment= ((PackageFragmentRoot) this.lastPkgFragmentRoot).getPackageFragment(pkgName);", "+\t\t\t\tpkgFragment= this.lastPkgFragmentRoot.getPackageFragment(pkgName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1f07f4186b589c7cde274b13d4d187f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java", "commitBeforeChange": "ea916b0462fec6996e619f84c30f348e2877686a", "commitAfterChange": "558c64a899c0debc518d6eb92e85f37b05902eba", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\tpublic TypeBinding resolveType(BlockScope blockScope) {", "+\tpublic /* @NonNull */ TypeBinding resolveType(BlockScope blockScope) {", "-\t\tMethodBinding singleAbstractMethod = this.expectedType == null ? null : this.expectedType.getSingleAbstractMethod();", "-\t\tif (singleAbstractMethod == null || !singleAbstractMethod.isValidBinding()) {", "+\t\tthis.singleAbstractMethod = this.expectedType == null ? null : this.expectedType.getSingleAbstractMethod();", "+\t\tif (this.singleAbstractMethod == null || !this.singleAbstractMethod.isValidBinding()) {", "-\t\t\treturn null;", "+\t\t\tchar [][] name = this.expectedType == null ? CharOperation.NO_CHAR_CHAR : CharOperation.splitOn('.', this.expectedType.shortReadableName());", "+\t\t\treturn this.functionalInterfaceType = new ProblemReferenceBinding(name, null, ProblemReasons.NotAFunctionalInterface);", "-\t\treturn this.expectedType;", "+\t\treturn this.functionalInterfaceType = (ReferenceBinding) this.expectedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c567b8476bb14f9739ae3212c891f11e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic ConstructorDeclaration createDefaultConstructor( \t\tboolean needExplicitConstructorCall, \t\tboolean needToInsert)", "signatureAfterChange": "  public ConstructorDeclaration createDefaultConstructor(\tboolean needExplicitConstructorCall, boolean needToInsert)", "diff": ["+", "+public ConstructorDeclaration createDefaultConstructor(\tboolean needExplicitConstructorCall, boolean needToInsert) {", "+\t//Add to method'set, the default constuctor that just recall the", "+\t//super constructor with no arguments", "+\t//The arguments' type will be positionned by the TC so just use", "+\t//the default int instead of just null (consistency purpose)", "+", "+\t//the constructor", "+\tConstructorDeclaration constructor = new ConstructorDeclaration(this.compilationResult);", "+\tconstructor.isDefaultConstructor = true;", "+\tconstructor.selector = this.name;", "+\tconstructor.modifiers = this.modifiers & ExtraCompilerModifiers.AccVisibilityMASK;", "+", "+\t//if you change this setting, please update the ", "+\t//SourceIndexer2.buildTypeDeclaration(TypeDeclaration,char[]) method", "+\tconstructor.declarationSourceStart = constructor.sourceStart = this.sourceStart;", "+\tconstructor.declarationSourceEnd =", "+\t\tconstructor.sourceEnd = constructor.bodyEnd = this.sourceEnd;", "+", "+\t//the super call inside the constructor", "+\tif (needExplicitConstructorCall) {", "+\t\tconstructor.constructorCall = SuperReference.implicitSuperConstructorCall();", "+\t\tconstructor.constructorCall.sourceStart = this.sourceStart;", "+\t\tconstructor.constructorCall.sourceEnd = this.sourceEnd;", "-\t", "-\tpublic ConstructorDeclaration createDefaultConstructor(", "-\t\tboolean needExplicitConstructorCall,", "-\t\tboolean needToInsert) {", "-", "-\t\t//Add to method'set, the default constuctor that just recall the", "-\t\t//super constructor with no arguments", "-\t\t//The arguments' type will be positionned by the TC so just use", "-\t\t//the default int instead of just null (consistency purpose)", "-", "-\t\t//the constructor", "-\t\tConstructorDeclaration constructor = new ConstructorDeclaration(this.compilationResult);", "-\t\tconstructor.isDefaultConstructor = true;", "-\t\tconstructor.selector = this.name;", "-\t\tif (modifiers != ClassFileConstants.AccDefault) {", "-\t\t\tconstructor.modifiers =", "-\t\t\t\t(((this.bits & ASTNode.IsMemberType) != 0) && (modifiers & ClassFileConstants.AccPrivate) != 0)", "-\t\t\t\t\t? ClassFileConstants.AccDefault", "-\t\t\t\t\t: modifiers & ExtraCompilerModifiers.AccVisibilityMASK;", "-\t\t}", "-", "-\t\t//if you change this setting, please update the ", "-\t\t//SourceIndexer2.buildTypeDeclaration(TypeDeclaration,char[]) method", "-\t\tconstructor.declarationSourceStart = constructor.sourceStart = sourceStart;", "-\t\tconstructor.declarationSourceEnd =", "-\t\t\tconstructor.sourceEnd = constructor.bodyEnd = sourceEnd;", "-", "-\t\t//the super call inside the constructor", "-\t\tif (needExplicitConstructorCall) {", "-\t\t\tconstructor.constructorCall = SuperReference.implicitSuperConstructorCall();", "-\t\t\tconstructor.constructorCall.sourceStart = sourceStart;", "-\t\t\tconstructor.constructorCall.sourceEnd = sourceEnd;", "-\t\t}", "-", "-\t\t//adding the constructor in the methods list", "-\t\tif (needToInsert) {", "-\t\t\tif (methods == null) {", "-\t\t\t\tmethods = new AbstractMethodDeclaration[] { constructor };", "-\t\t\t} else {", "-\t\t\t\tAbstractMethodDeclaration[] newMethods;", "-\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\tmethods,", "-\t\t\t\t\t0,", "-\t\t\t\t\tnewMethods = new AbstractMethodDeclaration[methods.length + 1],", "-\t\t\t\t\t1,", "-\t\t\t\t\tmethods.length);", "-\t\t\t\tnewMethods[0] = constructor;", "-\t\t\t\tmethods = newMethods;", "-\t\t\t}", "-\t\t}", "-\t\treturn constructor;", "-\t}", "+\t//adding the constructor in the methods list", "+\tif (needToInsert) {", "+\t\tif (this.methods == null) {", "+\t\t\tthis.methods = new AbstractMethodDeclaration[] { constructor };", "+\t\t\t\tthis.methods,", "+\t\t\t\tnewMethods = new AbstractMethodDeclaration[this.methods.length + 1],", "+\t\t\t\tthis.methods.length);", "+\t\t\tnewMethods[0] = constructor;", "+\t\t\tthis.methods = newMethods;", "+\t}", "+\treturn constructor;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb6563f67400f20d52c4d140c3593e1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultCommentMapper.java", "commitBeforeChange": "43c947b648b5a1fa1fb7d4f5ce5b7cea1d4fa7a2", "commitAfterChange": "eee151556fa5628da58c297d3e841df408f33c62", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tint storeTrailingComments(ASTNode node, int nextStart, Scanner scanner, boolean lastChild)", "signatureAfterChange": " \tint storeTrailingComments(ASTNode node, int nextStart,  boolean lastChild)", "diff": ["-\tint storeTrailingComments(ASTNode node, int nextStart, Scanner scanner, boolean lastChild) {", "+\tint storeTrailingComments(ASTNode node, int nextStart,  boolean lastChild) {", "+", "+\t\tif (nodeEnd == nextStart) {", "+\t\t\t// special case for last child of its parent", "+\t\t\tthis.trailingComments.put(node, new int[] { -1, -1 });", "+\t\t\treturn nodeEnd;", "+\t\t}", "-\t\tint nodeEndLine = scanner.getLineNumber(nodeEnd);", "+\t\tint nodeEndLine = this.scanner.getLineNumber(nodeEnd);", "-\t\tint idx = getCommentIndex(this.commentIndex, nodeEnd, 1);", "+\t\tint idx = getCommentIndex(0, nodeEnd, 1);", "-\t\t\t\tscanner.resetTo(previousEnd, commentStart);", "+\t\t\t\tthis.scanner.resetTo(previousEnd, commentStart);", "-\t\t\t\t\tint token = scanner.getNextToken();", "-\t\t\t\t\tif (token != TerminalTokens.TokenNameWHITESPACE || scanner.currentPosition != commentStart) {", "+\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t\t\tif (token != TerminalTokens.TokenNameWHITESPACE || this.scanner.currentPosition != commentStart) {", "-\t\t\t\tchar[] gap = scanner.getCurrentIdentifierSource();", "+\t\t\t\tchar[] gap = this.scanner.getCurrentIdentifierSource();", "-\t\t\tint commentLine = scanner.getLineNumber(commentStart);", "+\t\t\tint commentLine = this.scanner.getLineNumber(commentStart);", "-\t\t\t\tint nextLine = scanner.getLineNumber(nextStart);", "-\t\t\t\tint previousLine = scanner.getLineNumber(previousEnd);", "+\t\t\t\tint nextLine = this.scanner.getLineNumber(nextStart);", "+\t\t\t\tint previousLine = this.scanner.getLineNumber(previousEnd);", "-\t\t\tthis.commentIndex = endIdx;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd4885f57295631d9197e1298a85fc87", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/MultiOperation.java", "commitBeforeChange": "a3333bb335567ca03beac7199ab0f2b0e3a8fc03", "commitAfterChange": "e5c7fc4ae60b9d791500413e9c800c9fd02d03c3", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tprivate void initializeRenamings()", "signatureAfterChange": " \tprivate void initializeRenamings()", "diff": ["-\t\tif (fRenamingsList != null && fRenamingsList.length == fElementsToProcess.length) {", "-\t\t\tfRenamings = new HashMap(fRenamingsList.length);", "-\t\t\tfor (int i = 0; i < fRenamingsList.length; i++) {", "-\t\t\t\tif (fRenamingsList[i] != null) {", "-\t\t\t\t\tfRenamings.put(fElementsToProcess[i], fRenamingsList[i]);", "+\t\tif (this.renamingsList != null && this.renamingsList.length == fElementsToProcess.length) {", "+\t\t\tthis.renamings = new HashMap(this.renamingsList.length);", "+\t\t\tfor (int i = 0; i < this.renamingsList.length; i++) {", "+\t\t\t\tif (this.renamingsList[i] != null) {", "+\t\t\t\t\tthis.renamings.put(fElementsToProcess[i], this.renamingsList[i]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9e406f7b88baee59d57c41699971496", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "8257947b843e715f21b92a87dc4b423cbc1eed03", "commitAfterChange": "00cae100ff4808e2019f6a4d94df4143c8fabbd0", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 54, "signatureBeforeChange": " \tprivate boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, RootInfo rootInfo)", "signatureAfterChange": " \tpublic boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, RootInfo rootInfo)", "diff": ["-\tprivate boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, RootInfo rootInfo) {", "+\tpublic boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, RootInfo rootInfo) {", "-\t\t\t\t\tthis.updateRoots(deltaRes.getFullPath(), delta);", "+\t\t\t\t\tthis.state.updateRoots(deltaRes.getFullPath(), delta, this);", "-\t\t\t\t\tthis.updateRoots(deltaRes.getFullPath(), delta);", "+\t\t\t\t\tthis.state.updateRoots(deltaRes.getFullPath(), delta, this);", "-\t\t\t\t\t\t\tthis.updateRoots(res.getFullPath(), delta);", "+\t\t\t\t\t\t\tthis.state.updateRoots(res.getFullPath(), delta, this);", "-\t\t\t\t\t\t\t\tthis.indexManager.indexAll(res);", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.indexAll(res);", "-\t\t\t\t\t\t\t\tthis.indexManager.discardJobs(element.getElementName());", "-\t\t\t\t\t\t\t\tthis.indexManager.removeIndexFamily(res.getFullPath());", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.discardJobs(element.getElementName());", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.removeIndexFamily(res.getFullPath());", "-\t\t\t\t\t\t\t\tthis.indexManager.indexAll(res);", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.indexAll(res);", "-\t\t\t\t\t\t\t\tthis.indexManager.discardJobs(element.getElementName());", "-\t\t\t\t\t\t\t\tthis.indexManager.removeIndexFamily(res.getFullPath());", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.discardJobs(element.getElementName());", "+\t\t\t\t\t\t\t\tthis.manager.indexManager.removeIndexFamily(res.getFullPath());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2830cd322c82513379ac7c5614c84bf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetConstantPool.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public int literalIndex(MethodBinding aMethodBinding)", "signatureAfterChange": " public int literalIndex(MethodBinding aMethodBinding)", "diff": ["-\t\t\t\tif ((index = interfaceMethodCache.get(aMethodBinding)) < 0) {", "+\t\t\t\tif ((index = this.interfaceMethodCache.get(aMethodBinding)) < 0) {", "-\t\t\t\t\tindex = interfaceMethodCache.put(aMethodBinding, currentIndex++);", "+\t\t\t\t\tindex = this.interfaceMethodCache.put(aMethodBinding, this.currentIndex++);", "-\t\t\t\tif ((index = methodCache.get(aMethodBinding)) < 0) {", "+\t\t\t\tif ((index = this.methodCache.get(aMethodBinding)) < 0) {", "-\t\t\t\t\tindex = methodCache.put(aMethodBinding, currentIndex++);", "+\t\t\t\t\tindex = this.methodCache.put(aMethodBinding, this.currentIndex++);", "-\t\t\tif ((index = wellKnownMethods[indexWellKnownMethod]) == 0) {", "+\t\t\tif ((index = this.wellKnownMethods[indexWellKnownMethod]) == 0) {", "-\t\t\t\t\tindex = wellKnownMethods[indexWellKnownMethod] = currentIndex++;", "+\t\t\t\t\tindex = this.wellKnownMethods[indexWellKnownMethod] = this.currentIndex++;", "-\t\t\t\t\tindex = wellKnownMethods[indexWellKnownMethod] = currentIndex++;", "+\t\t\t\t\tindex = this.wellKnownMethods[indexWellKnownMethod] = this.currentIndex++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd509ef2ced3d1c455cd1d9a3961ec69", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 197, "methodNumberAfterChange": 197, "signatureBeforeChange": "   public int flushCommentsDefinedPriorTo(int position)", "signatureAfterChange": "   public int flushCommentsDefinedPriorTo(int position)", "diff": ["-\tint lastCommentIndex = scanner.commentPtr;", "+\tint lastCommentIndex = this.scanner.commentPtr;", "-\t\tint commentEnd = scanner.commentStops[index];", "+\t\tint commentEnd = this.scanner.commentStops[index];", "-\t\tint immediateCommentEnd = -scanner.commentStops[index+1]; //non-javadoc comment end positions are negative", "+\t\tint immediateCommentEnd = -this.scanner.commentStops[index+1]; //non-javadoc comment end positions are negative", "-\t\t\tif (scanner.getLineNumber(position) == scanner.getLineNumber(immediateCommentEnd)){", "+\t\t\tif (this.scanner.getLineNumber(position) == this.scanner.getLineNumber(immediateCommentEnd)){", "-\t\tSystem.arraycopy(scanner.commentStarts, index + 1, scanner.commentStarts, 0, validCount);", "-\t\tSystem.arraycopy(scanner.commentStops, index + 1, scanner.commentStops, 0, validCount);\t\t", "+\t\tSystem.arraycopy(this.scanner.commentStarts, index + 1, this.scanner.commentStarts, 0, validCount);", "+\t\tSystem.arraycopy(this.scanner.commentStops, index + 1, this.scanner.commentStops, 0, validCount);\t\t", "-\tscanner.commentPtr = validCount - 1;", "+\tthis.scanner.commentPtr = validCount - 1;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff0766b130d6a1020153d62042aa9356", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "1c4e30980d3a14b65dc5cd77977149f85c37b02a", "commitAfterChange": "72d09911302484497c2776b017dc226fd10250ec", "methodNumberBeforeChange": 259, "methodNumberAfterChange": 259, "signatureBeforeChange": " public void recoveryExitFromVariable()", "signatureAfterChange": " public void recoveryExitFromVariable()", "diff": ["-\tif(currentElement != null && currentElement.parent != null) {", "-\t\tif(currentElement instanceof RecoveredLocalVariable) {", "+\tif(this.currentElement != null && this.currentElement.parent != null) {", "+\t\tif(this.currentElement instanceof RecoveredLocalVariable) {", "-\t\t\tint end = ((RecoveredLocalVariable)currentElement).localDeclaration.sourceEnd;", "-\t\t\tcurrentElement.updateSourceEndIfNecessary(end);", "-\t\t\tcurrentElement = currentElement.parent;", "-\t\t} else if(currentElement instanceof RecoveredField", "-\t\t\t&& !(currentElement instanceof RecoveredInitializer)) {", "+\t\t\tint end = ((RecoveredLocalVariable)this.currentElement).localDeclaration.sourceEnd;", "+\t\t\tthis.currentElement.updateSourceEndIfNecessary(end);", "+\t\t\tthis.currentElement = this.currentElement.parent;", "+\t\t} else if(this.currentElement instanceof RecoveredField", "+\t\t\t&& !(this.currentElement instanceof RecoveredInitializer)) {", "-\t\t\tint end = ((RecoveredField)currentElement).fieldDeclaration.sourceEnd;", "-\t\t\tcurrentElement.updateSourceEndIfNecessary(end);", "-\t\t\tcurrentElement = currentElement.parent;", "+\t\t\tint end = ((RecoveredField)this.currentElement).fieldDeclaration.sourceEnd;", "+\t\t\tthis.currentElement.updateSourceEndIfNecessary(end);", "+\t\t\tthis.currentElement = this.currentElement.parent;"]}], "num": 27088}