{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c35c64910e75409eeccdd3dc53196b8e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a8ae50fb6f517d3746d2a52ea501180", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTModelBridgeTests.java", "commitBeforeChange": "2314c16241660b35014c2f51be7d9e9dcaef9a58", "commitAfterChange": "ceea24195947a1526b56f97d57fd4f7128a7bbd1", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void testCreateBindings01() throws JavaModelException", "signatureAfterChange": " \tpublic void testCreateBindings01() throws JavaModelException", "diff": ["-\t\tICompilationUnit[] workingCopies = new ICompilationUnit[3];", "-\t\ttry {", "-\t\t\tworkingCopies[0] = getWorkingCopy(", "-\t\t\t\t\"/P/src/X.java\", ", "-\t\t\t\t\"public class X {\\n\" +", "-\t\t\t\t\"  public void foo(int i, String s) {\\n\" +", "-\t\t\t\t\"  }\\n\" +", "-\t\t\t\t\"}\",", "-\t\t\t\towner, false);", "-\t\t\tworkingCopies[1] = getWorkingCopy(", "-\t\t\t\t\"/P/src/Y.java\", ", "-\t\t\t\t\"public class Y extends X {\\n\" +", "-\t\t\t\t\"  void bar() {\\n\" +", "-\t\t\t\t\"    new Y() {};\\n\" +", "-\t\t\t\t\"  }\\n\" +", "-\t\t\t\t\"}\",", "-\t\t\t\towner, false);", "-\t\t\tworkingCopies[2] = getWorkingCopy(", "-\t\t\t\t\"/P/src/I.java\", ", "-\t\t\t\t\"public interface I {\\n\" +", "-\t\t\t\t\"  int BAR;\\n\" +", "-\t\t\t\t\"}\",", "-\t\t\t\towner, false);", "-\t\t\tIType typeX = workingCopies[0].getType(\"X\");", "-\t\t\tIJavaElement[] elements = new IJavaElement[] {", "-\t\t\t\ttypeX, ", "-\t\t\t\tgetClassFile(\"P\", getExternalJCLPathString(), \"java.lang\", \"Object.class\").getType(),", "-\t\t\t\ttypeX.getMethod(\"foo\", new String[] {\"I\", \"QString;\"}),", "-\t\t\t\tworkingCopies[2].getType(\"I\").getField(\"BAR\"),", "-\t\t\t\tworkingCopies[1].getType(\"Y\").getMethod(\"bar\", new String[0]).getType(\"\", 1)", "-\t\t\t};", "-\t\t\tIBinding[] bindings = parser.createBindings(elements, null);", "-\t\t\tassertBindingsEqual(", "-\t\t\t\t\"LX;\\n\" + ", "-\t\t\t\t\"Ljava/lang/Object;\\n\" + ", "-\t\t\t\t\"LX;.foo(ILjava/lang/String;)V\\n\" + ", "-\t\t\t\t\"LI;.BAR\\n\" + ", "-\t\t\t\t\"LY$1;\",", "-\t\t\t\tbindings);", "-\t\t} finally {", "-\t\t\tfor (int i = 0, length = workingCopies.length; i < length; i++) {", "-\t\t\t\tif (workingCopies[i] != null)", "-\t\t\t\t\tworkingCopies[i].discardWorkingCopy();", "-\t\t\t}", "-\t\t}", "+\t\tthis.workingCopies = new ICompilationUnit[3];", "+\t\tthis.workingCopies[0] = getWorkingCopy(", "+\t\t\t\"/P/src/X.java\", ", "+\t\t\t\"public class X {\\n\" +", "+\t\t\t\"  public void foo(int i, String s) {\\n\" +", "+\t\t\t\"  }\\n\" +", "+\t\t\t\"}\",", "+\t\t\towner, false);", "+\t\tthis.workingCopies[1] = getWorkingCopy(", "+\t\t\t\"/P/src/Y.java\", ", "+\t\t\t\"public class Y extends X {\\n\" +", "+\t\t\t\"  void bar() {\\n\" +", "+\t\t\t\"    new Y() {};\\n\" +", "+\t\t\t\"  }\\n\" +", "+\t\t\t\"}\",", "+\t\t\towner, false);", "+\t\tthis.workingCopies[2] = getWorkingCopy(", "+\t\t\t\"/P/src/I.java\", ", "+\t\t\t\"public interface I {\\n\" +", "+\t\t\t\"  int BAR;\\n\" +", "+\t\t\t\"}\",", "+\t\t\towner, false);", "+\t\tIType typeX = this.workingCopies[0].getType(\"X\");", "+\t\tIJavaElement[] elements = new IJavaElement[] {", "+\t\t\ttypeX, ", "+\t\t\tgetClassFile(\"P\", getExternalJCLPathString(), \"java.lang\", \"Object.class\").getType(),", "+\t\t\ttypeX.getMethod(\"foo\", new String[] {\"I\", \"QString;\"}),", "+\t\t\tthis.workingCopies[2].getType(\"I\").getField(\"BAR\"),", "+\t\t\tthis.workingCopies[1].getType(\"Y\").getMethod(\"bar\", new String[0]).getType(\"\", 1)", "+\t\t};", "+\t\tIBinding[] bindings = parser.createBindings(elements, null);", "+\t\tassertBindingsEqual(", "+\t\t\t\"LX;\\n\" + ", "+\t\t\t\"Ljava/lang/Object;\\n\" + ", "+\t\t\t\"LX;.foo(ILjava/lang/String;)V\\n\" + ", "+\t\t\t\"LI;.BAR\\n\" + ", "+\t\t\t\"LY$1;\",", "+\t\t\tbindings);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6b7c6cf59c075debf6970c7cd2cc8ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "874e2c41609c64af417834df9af2e898d8dcf37a", "commitAfterChange": "4977ef90a9cbab898d33f6e3ba736939d7ac7a85", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse)", "signatureAfterChange": " \tprivate void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse)", "diff": ["-", "-\t\tboolean leftNonNullChecked = false;", "-\t\tboolean rightNonNullChecked = false;", "-", "-\t\t// check if either is a non-local expression known to be nonnull and compared to null, candidates are", "-\t\t// - method/field annotated @NonNull", "-\t\t// - allocation expression, some literals, this reference (see inside expressionNonNullComparison(..))", "-\t\tboolean checkForNull = ((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL;", "+\t\t// check if either is a method annotated @NonNull and compared to null:", "-\t\t\tleftNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.left, checkForNull);", "+\t\t\tif (this.left instanceof MessageSend) { ", "+\t\t\t\tscope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);", "+\t\t\t}", "+\t\t\t// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)", "-\t\t\trightNonNullChecked = scope.problemReporter().expressionNonNullComparison(this.right, checkForNull);", "-\t\t}", "-\t\t", "-\t\tif (!leftNonNullChecked) {", "-\t\t\tVariableBinding var = this.left.variableBinding(scope);", "-\t\t\tif (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {", "-\t\t\t\tcheckVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, rightStatus, this.left);", "+\t\t\tif (this.right instanceof MessageSend) {", "+\t\t\t\tscope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.right).binding, this.right);", "-\t\t}", "-\t\tif (!rightNonNullChecked) {", "-\t\t\tVariableBinding var = this.right.variableBinding(scope);", "-\t\t\tif (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {", "-\t\t\t\tcheckVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, leftStatus, this.right);", "-\t\t\t}", "+\t\t\t// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)", "-\t\tif (leftNonNullChecked || rightNonNullChecked) {", "-\t\t\t// above checks have not propagated unrechable into the corresponding branch, do it now:", "-\t\t\tif (checkForNull) {", "-\t\t\t\tinitsWhenTrue.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t} else {", "-\t\t\t\tinitsWhenFalse.setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t}", "+\t\tVariableBinding var = this.left.variableBinding(scope);", "+\t\tif (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {", "+\t\t\tcheckVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, rightStatus, this.left);", "+\t\t}", "+\t\tvar = this.right.variableBinding(scope);", "+\t\tif (var != null && (var.type.tagBits & TagBits.IsBaseType) == 0) {", "+\t\t\tcheckVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, var, leftStatus, this.right);"]}], "num": 22075}