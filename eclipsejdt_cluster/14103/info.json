{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3f67ca627d8b5bea69ae9285ae1bd8b3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3280d0e161debd5d461d1f49bd97db21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "def990b8509828ed437909a92c80eeb89428931a", "commitAfterChange": "59f8b1366dc6dc4f5af017fd8d5242b930c185da", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 40, "signatureBeforeChange": "  \tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": "  \tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum)", "diff": ["-\tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {", "+\tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum) {", "-\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "-\t\t\tdisassemble(fields[i], buffer, lineSeparator, tabNumber, mode);", "-\t\t}", "-\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "-\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "-\t\t\tdisassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);", "+\t\tif (isEnum && checkMode(mode, WORKING_COPY)) {", "+\t\t\tint index = 0;", "+\t\t\tfinal int fieldsLength = fields.length;", "+\t\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "+\t\t\tchar[][] constructorArguments = getConstructorArgumentsForEnum(methods);", "+\t\t\tenumConstantLoop: for (; index < fieldsLength; index++) {", "+\t\t\t\tfinal IFieldInfo fieldInfo = fields[index];", "+\t\t\t\tfinal int accessFlags = fieldInfo.getAccessFlags();", "+\t\t\t\tif ((accessFlags & IModifierConstants.ACC_ENUM) != 0) {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassembleEnumConstants(fields[index], buffer, lineSeparator, tabNumber, constructorArguments);", "+\t\t\t\t} else {", "+\t\t\t\t\tbreak enumConstantLoop;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(';');", "+\t\t\tboolean foundSyntheticField = false;", "+\t\t\tfieldLoop: for (; index < fieldsLength; index++) {", "+\t\t\t\tif (!foundSyntheticField && CharOperation.equals(TypeConstants.SYNTHETIC_ENUM_VALUES, fields[index].getName())) {", "+\t\t\t\t\tfoundSyntheticField = true;", "+\t\t\t\t\tcontinue fieldLoop;", "+\t\t\t\t}", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(fields[index], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}", "+\t\t\tmethodLoop: for (int i = 0, max = methods.length; i < max; i++) {", "+\t\t\t\tfinal IMethodInfo methodInfo = methods[i];", "+\t\t\t\tif (CharOperation.equals(methodInfo.getName(), TypeConstants.VALUES)) {", "+\t\t\t\t\tfinal char[] descriptor = methodInfo.getDescriptor();", "+\t\t\t\t\tCharOperation.replace(descriptor, '/', '.');", "+\t\t\t\t\tif (Signature.getParameterCount(descriptor) == 0) {", "+\t\t\t\t\t\tif (CharOperation.equals(returnClassName(Signature.getReturnType(descriptor), '.', mode),", "+\t\t\t\t\t\t\t\tCharOperation.concat(new char[] {'[', 'L'}, className, new char[] {';'}))) {", "+\t\t\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else if (CharOperation.equals(methodInfo.getName(), TypeConstants.VALUEOF)) {", "+\t\t\t\t\tfinal char[] descriptor = methodInfo.getDescriptor();", "+\t\t\t\t\tCharOperation.replace(descriptor, '/', '.');", "+\t\t\t\t\tfinal char[][] parameterTypes = Signature.getParameterTypes(descriptor);", "+\t\t\t\t\tif (parameterTypes.length == 1", "+\t\t\t\t\t\t\t&& CharOperation.equals(parameterTypes[0], \"Ljava.lang.String;\".toCharArray())) { //$NON-NLS-1$", "+\t\t\t\t\t\tif (CharOperation.equals(returnClassName(Signature.getReturnType(descriptor), '.', mode),", "+\t\t\t\t\t\t\t\tCharOperation.concat('L', className, ';'))) {", "+\t\t\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else if (methodInfo.isClinit()) {", "+\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t} else if (methodInfo.isConstructor()) {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassembleEnumConstructor(classFileReader, className, methodInfo, buffer, lineSeparator, tabNumber, mode);", "+\t\t\t\t} else {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassemble(classFileReader, className, methodInfo, buffer, lineSeparator, tabNumber, mode);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(fields[i], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}", "+\t\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "+\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42d7b2fbfe8f961b558628e0bf2320b0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "354ebb443c1299f35a4e7d9feb7df720666960e5", "commitAfterChange": "f5d7f3f14e69a955635d98e0e88aeb491988cae5", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 64, "signatureBeforeChange": "  \tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding)", "signatureAfterChange": "  \tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType)", "diff": ["-", "-\tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding) {", "-\t\tSolution solution = this.solutionsPerTargetType.get(targetType);", "-\t\tif (solution != null)", "-\t\t\treturn false; // no update", "-\t\tthis.solutionsPerTargetType.put(targetType, new Solution(updatedBinding, null));", "-\t\tthis.stepCompleted = Math.max(this.stepCompleted, TYPE_INFERRED);", "-\t\treturn true;", "+", "+\tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType) {", "+\t\tif (targetType != null)", "+\t\t\tinvocation.registerResult(targetType, pmb);", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression [] expressions = arguments[i].getPolyExpressions();", "+\t\t\tfor (int j = 0, jLength = expressions.length; j < jLength; j++) {", "+\t\t\t\tExpression expression = expressions[j];", "+\t\t\t\tif (!(expression instanceof Invocation))", "+\t\t\t\t\tcontinue;", "+\t\t\t\tInvocation polyInvocation = (Invocation) expression;", "+\t\t\t\tMethodBinding binding = polyInvocation.binding();", "+\t\t\t\tif (binding == null || !binding.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tParameterizedMethodBinding methodSubstitute = null;", "+\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(shallowOriginal.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tmethodSubstitute = this.environment.createParameterizedGenericMethod(shallowOriginal, solutions);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (!binding.isConstructor() || !(binding instanceof ParameterizedMethodBinding))", "+\t\t\t\t\t\tcontinue; // throw ISE ?", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tReferenceBinding genericType = shallowOriginal.declaringClass;", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(genericType.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tParameterizedTypeBinding parameterizedType = this.environment.createParameterizedType(genericType, solutions, binding.declaringClass.enclosingType());", "+\t\t\t\t\tfor (MethodBinding parameterizedMethod : parameterizedType.methods()) {", "+\t\t\t\t\t\tif (parameterizedMethod.original() == shallowOriginal) {", "+\t\t\t\t\t\t\tmethodSubstitute = (ParameterizedMethodBinding) parameterizedMethod;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (methodSubstitute == null || !methodSubstitute.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tboolean variableArity = pmb.isVarargs();", "+\t\t\t\tfinal TypeBinding[] parameters = pmb.parameters;", "+\t\t\t\tif (variableArity && parameters.length == arguments.length && i == length - 1) {", "+\t\t\t\t\tTypeBinding returnType = methodSubstitute.returnType.capture(this.scope, expression.sourceStart, expression.sourceEnd);", "+\t\t\t\t\tif (returnType.isCompatibleWith(parameters[parameters.length - 1], this.scope)) {", "+\t\t\t\t\t\tvariableArity = false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\t\tforwardResults(result, polyInvocation, methodSubstitute, parameterType);\t\t", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f1e3200e92e5732d755b8020e2338ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "8eff811a28d835d940585e1dd6e43b7e81d9c25c", "commitAfterChange": "ecd6b6b03e84e16fa2ef3316475695c9990930d4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " private boolean canSeeFocus(IPath projectOrJarPath)", "signatureAfterChange": " public static boolean canSeeFocus(IJavaElement focus, boolean isPolymorphicSearch, IPath projectOrJarPath)", "diff": ["- */", "-private boolean canSeeFocus(IPath projectOrJarPath) {", "-\t// if it is a workspace scope, focus is visible from everywhere", "-\t// if (this.searchScope instanceof JavaWorkspaceScope) return true;", "-\t", "-\treturn canSeeFocus(getProjectOrJar(this.focus), projectOrJarPath);", "+public static boolean canSeeFocus(IJavaElement focus, boolean isPolymorphicSearch, IPath projectOrJarPath) {", "+\t\tif (project == null) {", "+\t\t\t// projectOrJarPath is a jar", "+\t\t\t// it can see the focus only if it is on the classpath of a project that can see the focus", "+\t\t\tIJavaProject[] allProjects = model.getJavaProjects();", "+\t\t\tfor (int i = 0, length = allProjects.length; i < length; i++) {", "+\t\t\t\tIJavaProject otherProject = allProjects[i];", "+\t\t\t\tIClasspathEntry[] entries = otherProject.getResolvedClasspath(true);", "+\t\t\t\tfor (int j = 0, length2 = entries.length; j < length2; j++) {", "+\t\t\t\t\tIClasspathEntry entry = entries[j];", "+\t\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) ", "+\t\t\t\t\t\t&& entry.getPath().equals(projectOrJarPath)) {", "+\t\t\t\t\t\t\tif (canSeeFocus(focus, isPolymorphicSearch, otherProject.getPath())) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn false;", "+\t\t} else {", "+\t\t\t// projectOrJarPath is a project", "+\t\t\tJavaProject focusProject = focus instanceof JarPackageFragmentRoot ? (JavaProject)focus.getParent() : (JavaProject)focus;", "+\t\t\tif (isPolymorphicSearch) {", "+\t\t\t\t// look for refering project", "+\t\t\t\tIClasspathEntry[] entries = focusProject.getExpandedClasspath(true);", "+\t\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {", "+\t\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) ", "+\t\t\t\t\t\t&& entry.getPath().equals(projectOrJarPath)) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (focus instanceof JarPackageFragmentRoot) {", "+\t\t\t\t// focus is part of a jar", "+\t\t\t\tIPath focusPath = focus.getPath();", "+\t\t\t\t\t\t&& entry.getPath().equals(focusPath)) {", "+\t\t\t\t// focus is part of a project", "+\t\t\t\tif (focus.equals(project)) {", "+\t\t\t\t\t// look for dependent projects"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d31d654d63970b1e540e705f0a6d049d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){\r", "-/*\r", "+\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException {\r", "+\r", "-\t\t\r", "+\r", "+\t\tint projectLength = affectedProjects.length;\r", "-\t\tArrayList projectsToCheck = new ArrayList();\r", "+\t\tIClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];\r", "+\r", "+\t\t// filter out unmodified project containers\r", "+\t\tint remaining = 0;\r", "+\t\tfor (int i = 0; i < projectLength; i++){\r", "+\r", "+\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\t\tIJavaProject affectedProject = affectedProjects[i];\r", "+\t\t\tIClasspathContainer newContainer = newContainers[i];\r", "+\t\t\t\r", "+\t\t\tIClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();\r", "+\t\t\tboolean found = false;\r", "+\t\t\tfor (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {", "+\t\t\t\tIClasspathEntry entry = rawClasspath[j];\r", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){\r", "+\t\t\t\t\tfound = true;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}", "+\t\t\t}\r", "+\t\t\tif (!found){\r", "+\t\t\t\taffectedProjects[i] = null; // filter out this project - does not reference the container path\r", "+\t\t\t\tcontinue;\r", "+\t\t\t}\r", "+\t\t\tMap perProjectContainers = (Map)JavaModelManager.Containers.get(affectedProject);\r", "+\t\t\tif (perProjectContainers == null){\r", "+\t\t\t\tperProjectContainers = new HashMap();\r", "+\t\t\t\tJavaModelManager.Containers.put(affectedProject, perProjectContainers);\r", "+\t\t\t} else {\r", "+\t\t\t\tIClasspathContainer oldContainer = (IClasspathContainer) perProjectContainers.get(containerPath);\r", "+\t\t\t\tif (oldContainer != null && oldContainer.equals(newContainers[i])){\r", "+\t\t\t\t\taffectedProjects[i] = null; // filter out this project - container did not change\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tremaining++;\r", "+\t\t\toldResolvedPaths[i] = affectedProject.getResolvedClasspath(true);\r", "+\t\t\tperProjectContainers.put(containerPath, newContainer);\r", "+\t\t}\r", "-\t\tswitch (affectedElement.getElementType()){\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tprojectsToCheck.add(affectedElement);\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "-\t\t\t\tfor (int i = 0; i < projects.length; i++) {\r", "-\t\t\t\t\tprojectsToCheck.add(projects[i]);\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tdefault:\r", "-\t\t\t\t// no effect if affected element isn't one of the above case\r", "-\t\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\t// gather classpath information for updating\r", "-\t\tHashMap affectedProjects = new HashMap(5);\r", "-\r", "-\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\tnextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){\r", "-\t\t\tIJavaProject project = projectsToCheck[i];\r", "-\t\t\t\t\t\r", "-\t\t\t// check to see if any of the modified variables is present on the classpath\r", "-\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\tif (remaining == 0) return;\r", "+\t\t\r", "+\t\t// trigger model refresh\r", "+\t\tboolean wasFiring = manager.isFiring();\r", "+\t\tint count = 0;\r", "+\t\ttry {\r", "+\t\t\tif (wasFiring)\r", "+\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\tIClasspathEntry entry = classpath[j];\r", "-\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\t\t\tfor(int i = 0; i < projectLength; i++){\r", "-\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "-\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){\r", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\t\t\t\t\t\tif (entry.getPath().equals(containerPath)){\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\t\r", "-\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers\r", "-\t\t\t\t\t\t\tif (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){\r", "-\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);\r", "-\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];\r", "-\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tIPath sourcePath, sourceRootPath;\r", "-\t\t\t\t\t\tif (((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "-\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "-\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// reset saved container path\r", "-\t\tfor (int i = 0; i < \r", "-\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "-\t\tif (projectContainers != null){\r", "-\t\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "+\t\t\t\tJavaProject affectedProject = (JavaProject)affectedProjects[i];\r", "+\t\t\t\tif (affectedProject == null) continue; // was filtered out\r", "-\t\t// update affected project classpaths\r", "-\t\tif (!affectedProjects.isEmpty()) {\r", "-\t\t\tboolean wasFiring = manager.isFiring();\r", "-\t\t\ttry {\r", "-\t\t\t\tif (wasFiring)\r", "-\t\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\t// propagate classpath change\r", "-\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();\r", "-\t\t\t\twhile (projectsToUpdate.hasNext()) {\r", "-\r", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tif (!projectsToUpdate.hasNext()) {\r", "-\t\t\t\t\t\t// re-enable firing for the last operation\r", "-\t\t\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\t\t\twasFiring = false;\r", "-\t\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\tif (++count == remaining) { // re-enable firing for the last operation\r", "+\t\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\t\twasFiring = false;\r", "+\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\tproject\r", "-\t\t\t\t\t\t.setRawClasspath(\r", "-\t\t\t\t\t\t\tproject.getRawClasspath(),\r", "-\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "-\t\t\t\t\t\t\tmonitor,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tproject.getWorkspace().isAutoBuilding(),\r", "-\t\t\t\t\t\t\t// force build if in auto build mode\r", "-\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),\r", "-\t\t\t\t\t\t\tmayChangeProjectDependencies);\r", "-\t\t\t} finally {\r", "-\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t\r", "+\t\t\t\t// force a refresh of the affected project (will compute deltas)\r", "+\t\t\t\taffectedProject.setRawClasspath(\r", "+\t\t\t\t\t\taffectedProject.getRawClasspath(),\r", "+\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "+\t\t\t\t\t\tmonitor,\r", "+\t\t\t\t\t\ttrue,\r", "+\t\t\t\t\t\taffectedProject.getWorkspace().isAutoBuilding(),\r", "+\t\t\t\t\t\toldResolvedPaths[i],\r", "+\t\t\t\t\t\tremaining == 1); // no individual cycle check if more than 1 project\r", "+\t\t\t}\r", "+\t\t\tif (remaining > 1){\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// use workspace runnable so as to allow marker creation - workaround bug 14733\r", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(\r", "+\t\t\t\t\t\tnew IWorkspaceRunnable() {\r", "+\t\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {\r", "+\t\t\t\t\t\t\t\tJavaProject.updateAllCycleMarkers(); // update them all at once\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}, \r", "+\t\t\t\t\t\tmonitor);\t\t\t\t\t\r", "+\t\t\t\t} catch(CoreException e){\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t} finally {\r", "+\t\t\tif (wasFiring) {\r", "+\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t}\r", "-*/\r", "+\t\t\t\t\t\r"]}], "num": 14103}