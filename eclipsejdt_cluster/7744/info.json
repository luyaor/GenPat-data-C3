{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3130be9514f3f29cac25fcfb63612a1e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0269185b92e3d4529b269cf7a247b104", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NameEnvironmentWithProgress.java", "commitBeforeChange": "9359ba8e380aaa366dda637da6a8c80a24875b62", "commitAfterChange": "c39467a5717299e0743e249af795ac84f7541935", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName)", "signatureAfterChange": " \tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName)", "diff": ["-\t\treturn super.findType(typeName, packageName);", "+\t\tNameEnvironmentAnswer answer = super.findType(typeName, packageName);", "+\t\tif (answer == null) {", "+\t\t\tNameEnvironmentAnswer suggestedAnswer = null;", "+\t\t\tString qualifiedPackageName = new String(CharOperation.concatWith(packageName, '/'));", "+\t\t\tString qualifiedTypeName = new String(CharOperation.concatWith(packageName, typeName, '/'));", "+\t\t\tString qualifiedBinaryFileName = qualifiedTypeName + SUFFIX_STRING_class;", "+\t\t\tfor (int i = 0, length = this.classpaths.length; i < length; i++) {", "+\t\t\t\tif (!(this.classpaths[i] instanceof ClasspathDirectory)) continue;", "+\t\t\t\tClasspathDirectory classpathDirectory = (ClasspathDirectory) this.classpaths[i];", "+\t\t\t\tanswer = classpathDirectory.findSecondaryInClass(typeName, qualifiedPackageName, qualifiedBinaryFileName);", "+\t\t\t\tif (answer != null) {", "+\t\t\t\t\tif (!answer.ignoreIfBetter()) {", "+\t\t\t\t\t\tif (answer.isBetter(suggestedAnswer))", "+\t\t\t\t\t\t\treturn answer;", "+\t\t\t\t\t} else if (answer.isBetter(suggestedAnswer))", "+\t\t\t\t\t\t// remember suggestion and keep looking", "+\t\t\t\t\t\tsuggestedAnswer = answer;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn answer;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0677df1a10cb5d2bc4b3eae05ea692e9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "54bfec2a779f774d0ec94918b11965f709f8eea7", "commitAfterChange": "07b0f1c60d56e715370df7f24af276bdb1cfa324", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " protected boolean buildStructure(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException", "signatureAfterChange": " protected boolean buildStructure(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException", "diff": ["-\tboolean computeProblems = JavaProject.hasJavaNature(project.getProject()) && perWorkingCopyInfo != null && perWorkingCopyInfo.isActive();", "+", "+\tboolean createAST;", "+\tboolean resolveBindings;", "+\tHashMap problems;", "+\tif (info instanceof ASTHolderCUInfo) {", "+\t\tASTHolderCUInfo astHolder = (ASTHolderCUInfo) info;", "+\t\tcreateAST = astHolder.astLevel != NO_AST;", "+\t\tresolveBindings = astHolder.resolveBindings;", "+\t\tproblems = astHolder.problems;", "+\t} else {", "+\t\tcreateAST = false;", "+\t\tresolveBindings = false;", "+\t\tproblems = null;", "+\t}", "+\t", "+\tboolean computeProblems = perWorkingCopyInfo != null && perWorkingCopyInfo.isActive() && JavaProject.hasJavaNature(project.getProject());", "-\tboolean createAST = info instanceof ASTHolderCUInfo;", "-\tif (!computeProblems && !createAST) // disable javadoc parsing if not computing problems and not creating ast", "+\tif (!computeProblems && !resolveBindings && !createAST) // disable javadoc parsing if not computing problems, not resolving and not creating ast", "-\tCompilationUnitDeclaration unit = parser.parseCompilationUnit(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit() {", "+\tCompilationUnitDeclaration unit = parser.parseCompilationUnit(", "+\t\tnew org.eclipse.jdt.internal.compiler.env.ICompilationUnit() {", "-\t\t}, true /*full parse to find local elements*/);", "+\t\t}, ", "+\t\ttrue /*full parse to find local elements*/);", "-\t\tif (computeProblems){", "-\t\t\tperWorkingCopyInfo.beginReporting();", "-\t\t\tcompilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, perWorkingCopyInfo, createAST, pm);", "-\t\t\tperWorkingCopyInfo.endReporting();", "+\t\tif (computeProblems) {", "+\t\t\tif (problems == null) {", "+\t\t\t\t// report problems to the problem requestor", "+\t\t\t\tproblems = new HashMap();", "+\t\t\t\tcompilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, pm);", "+\t\t\t\ttry {", "+\t\t\t\t\tperWorkingCopyInfo.beginReporting();", "+\t\t\t\t\tfor (Iterator iteraror = problems.values().iterator(); iteraror.hasNext();) {", "+\t\t\t\t\t\tCategorizedProblem[] categorizedProblems = (CategorizedProblem[]) iteraror.next();", "+\t\t\t\t\t\tif (categorizedProblems == null) continue;", "+\t\t\t\t\t\tfor (int i = 0, length = categorizedProblems.length; i < length; i++) {", "+\t\t\t\t\t\t\tperWorkingCopyInfo.acceptProblem(categorizedProblems[i]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\tperWorkingCopyInfo.endReporting();", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// collect problems", "+\t\t\t\tcompilationUnitDeclaration = CompilationUnitProblemFinder.process(unit, this, contents, parser, this.owner, problems, createAST, pm);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "206060c672e63cfa1c6f5141a0d6fa41", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 94, "methodNumberAfterChange": 95, "signatureBeforeChange": "\r \t\r \tpublic void updateCycleMarkers(IClasspathEntry[] resolvedClasspath)", "signatureAfterChange": "\r \tpublic static void updateAllCycleMarkers() throws JavaModelException", "diff": ["-\t\r", "-\tpublic void updateCycleMarkers(IClasspathEntry[] resolvedClasspath) {\r", "-\t\tthis.flushClasspathProblemMarkers(true);\r", "-\t\tif (this.hasClasspathCycle(resolvedClasspath)){\r", "-\t\t\tthis.createClasspathProblemMarker(\r", "-\t\t\t\tUtil.bind(\"classpath.cycle\"), //$NON-NLS-1$\r", "-\t\t\t\tIMarker.SEVERITY_ERROR,\r", "-\t\t\t\ttrue); \r", "+\t */\r", "+\tpublic static void updateAllCycleMarkers() throws JavaModelException {\r", "+\t\t\r", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "+\t\tIWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();\r", "+\r", "+\t\tHashSet cycleParticipants = new HashSet();\r", "+\t\tHashSet visited = new HashSet();\r", "+\t\tint length = projects.length;\r", "+\t\tfor (int i = 0; i < length; i++){\r", "+\t\t\tJavaProject project = (JavaProject)projects[i];\r", "+\t\t\tif (!cycleParticipants.contains(project)){\r", "+\t\t\t\tvisited.clear();\r", "+\t\t\t\tproject.updateCycleParticipants(null, visited, cycleParticipants, workspaceRoot);\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tfor (int i = 0; i < length; i++){\r", "+\t\t\tJavaProject project = (JavaProject)projects[i];\r", "+\t\t\t\r", "+\t\t\tif (cycleParticipants.contains(project)){\r", "+\t\t\t\t\r", "+\t\t\t\tproject.createClasspathProblemMarker(\r", "+\t\t\t\t\tUtil.bind(\"classpath.cycle\"), //$NON-NLS-1$\r", "+\t\t\t\t\tIMarker.SEVERITY_ERROR,\r", "+\t\t\t\t\ttrue); \r", "+\t\t\t} else {\r", "+\t\t\t\tproject.flushClasspathProblemMarkers(true);\r", "+\t\t\t}\t\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91d714d8c282b5fbaaa3d0cb570ff071", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/BatchImageBuilder.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  protected void cleanOutputFolder() throws CoreException", "signatureAfterChange": "  protected void cleanOutputFolders() throws CoreException", "diff": ["-", "-protected void cleanOutputFolder() throws CoreException {", "-\tif (hasSeparateOutputFolder) {", "-\t\t// outputPath is not on the class path so wipe it clean then copy extra resources back", "-\t\tIResource[] members = outputFolder.members(); ", "-\t\tfor (int i = 0, length = members.length; i < length; i++)", "-\t\t\tmembers[i].delete(IResource.FORCE, null);", "-\t\tnotifier.checkCancel();", "-\t\tcopyExtraResourcesBack();", "-\t} else {", "-\t\t// outputPath == a source folder so just remove class files", "-\t\toutputFolder.accept(", "-\t\t\t\t\t\tif (JavaBuilder.CLASS_EXTENSION.equalsIgnoreCase(resource.getFileExtension()))", "-\t\t\t\t\t\t\tresource.delete(IResource.FORCE, null);", "-\tnotifier.checkCancel();", "+protected void cleanOutputFolders() throws CoreException {", "+\tboolean deleteAll = JavaCore.CLEAN.equals(", "+\t\tjavaBuilder.javaProject.getOption(JavaCore.CORE_JAVA_BUILD_CLEAN_OUTPUT_FOLDER, true));", "+\tArrayList visited = new ArrayList(sourceLocations.length);", "+\tnext : for (int i = 0, l = sourceLocations.length; i < l; i++) {", "+\t\tClasspathMultiDirectory sourceLocation = sourceLocations[i];", "+\t\tif (deleteAll && sourceLocation.hasIndependentOutputFolder) {", "+\t\t\tIContainer outputFolder = sourceLocation.binaryFolder;", "+\t\t\tif (visited.contains(outputFolder)) continue next;", "+\t\t\tvisited.add(outputFolder);", "+\t\t\tIResource[] members = outputFolder.members(); ", "+\t\t\tfor (int j = 0, m = members.length; j < m; j++)", "+\t\t\t\tmembers[j].delete(IResource.FORCE, null);", "+\t\t\tcopyExtraResourcesBack(sourceLocation);", "+\t\t} else {", "+\t\t\tfinal char[][] exclusionPatterns =", "+\t\t\t\tsourceLocation.sourceFolder.equals(sourceLocation.binaryFolder)", "+\t\t\t\t\t? sourceLocation.exclusionPatterns", "+\t\t\t\t\t: null; // ignore exclusionPatterns if output folder != source folder", "+\t\t\tsourceLocation.binaryFolder.accept(", "+\t\t\t\tnew IResourceVisitor() {", "+\t\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {", "+\t\t\t\t\t\tif (exclusionPatterns != null && Util.isExcluded(resource, exclusionPatterns))", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\tif (resource.getType() == IResource.FILE) {", "+\t\t\t\t\t\t\tif (JavaBuilder.CLASS_EXTENSION.equalsIgnoreCase(resource.getFileExtension()))", "+\t\t\t\t\t\t\t\tresource.delete(IResource.FORCE, null);", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t);", "+\t\t\tnotifier.checkCancel();", "+\t\t}", "+\t}", "+}"]}], "num": 7744}