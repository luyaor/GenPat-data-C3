{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8e834bd7fe73458fbb8fc3af36860bbf", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39b9517ea29fd5bf1e0ea009012d1bdf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "59ccdbf9540bdb894570a3ebe1e5cfa637624073", "commitAfterChange": "29911619e9eb038f230f09e2190cd9ca1e9cfd72", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t\t\t\tthis.isAnySubRoutineEscaping = true;", "+\t\t\t\tthis.bits |= ASTNode.IsAnySubRoutineEscaping;", "-\t\t\t\tthis.isSynchronized = true;", "+\t\t\t\tthis.bits |= ASTNode.IsSynchronized;", "-\t\tif (!this.isSynchronized && this.expression != null && this.expression.resolvedType == TypeBinding.BOOLEAN) {", "+\t\tif (((this.bits & ASTNode.IsSynchronized) == 0) && this.expression != null && this.expression.resolvedType == TypeBinding.BOOLEAN) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53184b079824db2c9c20ce0b254857dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "59ccdbf9540bdb894570a3ebe1e5cfa637624073", "commitAfterChange": "29911619e9eb038f230f09e2190cd9ca1e9cfd72", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["-\t\tif (this.isDefaultConstructor) break checkUnused;", "+\t\tif ((this.bits & ASTNode.IsDefaultConstructor) != 0) break checkUnused;", "-\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "+\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {", "+\t\t\tthis.bits |= ASTNode.NeedFreeReturn;", "+\t\t}", "-\t\t\t\t\t\tthis.isDefaultConstructor ? (ASTNode) this.scope.referenceType() : this);", "+\t\t\t\t\t\t((this.bits & ASTNode.IsDefaultConstructor) != 0) ? (ASTNode) this.scope.referenceType() : this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "98c6e75b8ff29a53336fc023a679220f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "59ccdbf9540bdb894570a3ebe1e5cfa637624073", "commitAfterChange": "29911619e9eb038f230f09e2190cd9ca1e9cfd72", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " void checkAndSetImports()", "signatureAfterChange": " void checkAndSetImports()", "diff": ["-\t\tif (importReference.onDemand && CharOperation.equals(JAVA_LANG, importReference.tokens) && !importReference.isStatic()) {", "+\t\tif (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(JAVA_LANG, importReference.tokens) && !importReference.isStatic()) {", "-\t\t\tif (resolved.onDemand == importReference.onDemand && resolved.isStatic() == importReference.isStatic())", "+\t\t\tif (resolved.onDemand == ((importReference.bits & ASTNode.OnDemand) != 0) && resolved.isStatic() == importReference.isStatic())", "-\t\tif (importReference.onDemand) {", "+\t\tif ((importReference.bits & ASTNode.OnDemand) != 0) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7e986c931c54ca6c06c31ed0f7c01a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "b418235473d69146fcb35be10bf158bb2b040cf7", "commitAfterChange": "eadf5ba6d44f28f071965cf829d67590b0a71974", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void resolve(MethodScope initializationScope)", "signatureAfterChange": "  public void resolve(MethodScope initializationScope)", "diff": ["+", "+public void resolve(MethodScope initializationScope) {", "+\t// the two <constant = Constant.NotAConstant> could be regrouped into", "+\t// a single line but it is clearer to have two lines while the reason of their", "+\t// existence is not at all the same. See comment for the second one.", "+", "+\t//--------------------------------------------------------", "+\tif ((this.bits & ASTNode.HasBeenResolved) != 0) return;", "+\tif (this.binding == null || !this.binding.isValidBinding()) return;", "+\t", "+\tthis.bits |= ASTNode.HasBeenResolved;", "+", "+\t// check if field is hiding some variable - issue is that field binding already got inserted in scope", "+\t// thus must lookup separately in super type and outer context", "+\tClassScope classScope = initializationScope.enclosingClassScope();", "+\t", "+\tif (classScope != null) {", "+\t\tcheckHiding: {", "+\t\t\tSourceTypeBinding declaringType = classScope.enclosingSourceType();", "+\t\t\tcheckHidingSuperField: {", "+\t\t\t\tif (declaringType.superclass == null) break checkHidingSuperField;", "+\t\t\t\tBinding existingVariable = classScope.findField(declaringType.superclass, this.name, this,  false /*do not resolve hidden field*/);", "+\t\t\t\tif (existingVariable == null) break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\tif (!existingVariable.isValidBinding())  break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\tif (existingVariable instanceof FieldBinding) {", "+\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "+\t\t\t\t\tif (existingField.original() == this.binding) break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\t// collision with supertype field", "+\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\t\tbreak checkHiding; // already found a matching field", "+\t\t\t}\t\t\t\t\t", "+\t\t\t// only corner case is: lookup of outer field through static declaringType, which isn't detected by #getBinding as lookup starts", "+\t\t\t// from outer scope. Subsequent static contexts are detected for free.", "+\t\t\tScope outerScope = classScope.parent;", "+\t\t\tif (outerScope.kind == Scope.COMPILATION_UNIT_SCOPE) break checkHiding;", "+\t\t\tBinding existingVariable = outerScope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);", "+\t\t\tif (existingVariable == null) break checkHiding;", "+\t\t\tif (!existingVariable.isValidBinding()) break checkHiding;", "+\t\t\tif (existingVariable == this.binding) break checkHiding;", "+\t\t\tif (existingVariable instanceof FieldBinding) {", "+\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "+\t\t\t\tif (existingField.original() == this.binding) break checkHiding;", "+\t\t\t\tif (!existingField.isStatic() && declaringType.isStatic()) break checkHiding;", "+\t\t\t// collision with outer field or local variable", "+\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\tif (this.type != null ) { // enum constants have no declared type", "+\t\tthis.type.resolvedType = this.binding.type; // update binding for type reference", "+\tFieldBinding previousField = initializationScope.initializedField;", "+\tint previousFieldID = initializationScope.lastVisibleFieldID;", "+\ttry {", "+\t\tinitializationScope.initializedField = this.binding;", "+\t\tinitializationScope.lastVisibleFieldID = this.binding.id;", "-\tpublic void resolve(MethodScope initializationScope) {", "-", "-\t\t// the two <constant = Constant.NotAConstant> could be regrouped into", "-\t\t// a single line but it is clearer to have two lines while the reason of their", "-\t\t// existence is not at all the same. See comment for the second one.", "-", "-\t\t//--------------------------------------------------------", "-\t\tif (!this.hasBeenResolved && this.binding != null && this.binding.isValidBinding()) {", "-", "-\t\t\tthis.hasBeenResolved = true;", "-", "-\t\t\t// check if field is hiding some variable - issue is that field binding already got inserted in scope", "-\t\t\t// thus must lookup separately in super type and outer context", "-\t\t\tClassScope classScope = initializationScope.enclosingClassScope();", "+\t\tresolveAnnotations(initializationScope, this.annotations, this.binding);", "+\t\t// check @Deprecated annotation presence", "+\t\tif ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0", "+\t\t\t\t&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0", "+\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\tinitializationScope.problemReporter().missingDeprecatedAnnotationForField(this);", "+\t\t}\t\t\t\t\t\t", "+\t\t// the resolution of the initialization hasn't been done", "+\t\tif (this.initialization == null) {", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t} else {", "+\t\t\t// break dead-lock cycles by forcing constant to NotAConstant", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\tif (classScope != null) {", "-\t\t\t\tcheckHiding: {", "-\t\t\t\t\tSourceTypeBinding declaringType = classScope.enclosingSourceType();", "-\t\t\t\t\tcheckHidingSuperField: {", "-\t\t\t\t\t\tif (declaringType.superclass == null) break checkHidingSuperField;", "-\t\t\t\t\t\tBinding existingVariable = classScope.findField(declaringType.superclass, this.name, this,  false /*do not resolve hidden field*/);", "-\t\t\t\t\t\tif (existingVariable == null) break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\tif (!existingVariable.isValidBinding())  break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\tif (existingVariable instanceof FieldBinding) {", "-\t\t\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "-\t\t\t\t\t\t\tif (existingField.original() == this.binding) break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// collision with supertype field", "-\t\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "-\t\t\t\t\t\tbreak checkHiding; // already found a matching field", "-\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t// only corner case is: lookup of outer field through static declaringType, which isn't detected by #getBinding as lookup starts", "-\t\t\t\t\t// from outer scope. Subsequent static contexts are detected for free.", "-\t\t\t\t\tScope outerScope = classScope.parent;", "-\t\t\t\t\tif (outerScope.kind == Scope.COMPILATION_UNIT_SCOPE) break checkHiding;", "-\t\t\t\t\tBinding existingVariable = outerScope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);", "-\t\t\t\t\tif (existingVariable == null) break checkHiding;", "-\t\t\t\t\tif (!existingVariable.isValidBinding()) break checkHiding;", "-\t\t\t\t\tif (existingVariable == this.binding) break checkHiding;", "-\t\t\t\t\tif (existingVariable instanceof FieldBinding) {", "-\t\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "-\t\t\t\t\t\tif (existingField.original() == this.binding) break checkHiding;", "-\t\t\t\t\t\tif (!existingField.isStatic() && declaringType.isStatic()) break checkHiding;", "-\t\t\t\t\t}", "-\t\t\t\t\t// collision with outer field or local variable", "-\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\tTypeBinding fieldType = this.binding.type;", "+\t\t\tTypeBinding initializationType;", "+\t\t\tthis.initialization.setExpectedType(fieldType); // needed in case of generic method invocation", "+\t\t\tif (this.initialization instanceof ArrayInitializer) {", "+", "+\t\t\t\tif ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {", "+\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t}", "-\t\t\t", "-\t\t\tif (this.type != null ) { // enum constants have no declared type", "-\t\t\t\tthis.type.resolvedType = this.binding.type; // update binding for type reference", "-\t\t\t}", "+\t\t\t} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {", "-\t\t\tFieldBinding previousField = initializationScope.initializedField;", "-\t\t\tint previousFieldID = initializationScope.lastVisibleFieldID;", "-\t\t\ttry {", "-\t\t\t\tinitializationScope.initializedField = this.binding;", "-\t\t\t\tinitializationScope.lastVisibleFieldID = this.binding.id;", "-", "-\t\t\t\tresolveAnnotations(initializationScope, this.annotations, this.binding);", "-\t\t\t\t// check @Deprecated annotation presence", "-\t\t\t\tif ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0", "-\t\t\t\t\t\t&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0", "-\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "-\t\t\t\t\tinitializationScope.problemReporter().missingDeprecatedAnnotationForField(this);", "-\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t// the resolution of the initialization hasn't been done", "-\t\t\t\tif (this.initialization == null) {", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t\tif (fieldType != initializationType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tinitializationScope.compilationUnitScope().recordTypeConversion(fieldType, initializationType);", "+\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)", "+\t\t\t\t\t\t|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))", "+\t\t\t\t\t\t|| initializationType.isCompatibleWith(fieldType)) {", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "+\t\t\t\t\tif (initializationType.needsUncheckedConversion(fieldType)) {", "+\t\t\t\t\t\t    initializationScope.problemReporter().unsafeTypeConversion(this.initialization, initializationType, fieldType);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.initialization instanceof CastExpression ", "+\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "+\t\t\t\t\t}\t\t\t\t\t\t\t\t", "+\t\t\t\t} else if (initializationScope.isBoxingCompatibleWith(initializationType, fieldType) ", "+\t\t\t\t\t\t\t\t\t|| (initializationType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t\t\t\t\t&& !fieldType.isBaseType()", "+\t\t\t\t\t\t\t\t\t\t\t&& initialization.isConstantValueOfTypeAssignableToType(initializationType, initializationScope.environment().computeBoxingType(fieldType)))) {", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "+\t\t\t\t\tif (this.initialization instanceof CastExpression ", "+\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "+\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t// break dead-lock cycles by forcing constant to NotAConstant", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\t\t\t", "-\t\t\t\t\tTypeBinding fieldType = this.binding.type;", "-\t\t\t\t\tTypeBinding initializationType;", "-\t\t\t\t\tthis.initialization.setExpectedType(fieldType); // needed in case of generic method invocation", "-\t\t\t\t\tif (this.initialization instanceof ArrayInitializer) {", "-", "-\t\t\t\t\t\tif ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {", "-\t\t\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {", "-", "-\t\t\t\t\t\tif (fieldType != initializationType) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\t\t\tinitializationScope.compilationUnitScope().recordTypeConversion(fieldType, initializationType);", "-\t\t\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)", "-\t\t\t\t\t\t\t\t|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))", "-\t\t\t\t\t\t\t\t|| initializationType.isCompatibleWith(fieldType)) {", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t\tif (initializationType.needsUncheckedConversion(fieldType)) {", "-\t\t\t\t\t\t\t\t    initializationScope.problemReporter().unsafeTypeConversion(this.initialization, initializationType, fieldType);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.initialization instanceof CastExpression ", "-\t\t\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else if (initializationScope.isBoxingCompatibleWith(initializationType, fieldType) ", "-\t\t\t\t\t\t\t\t\t\t\t|| (initializationType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& !fieldType.isBaseType()", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& initialization.isConstantValueOfTypeAssignableToType(initializationType, initializationScope.environment().computeBoxingType(fieldType)))) {", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t\tif (this.initialization instanceof CastExpression ", "-\t\t\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.binding.isFinal()){ // cast from constant actual type to variable type", "-\t\t\t\t\t\t\tthis.binding.setConstant(this.initialization.constant.castTo((this.binding.type.id << 4) + this.initialization.constant.typeID()));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\t\t\t}", "-\t\t\t\t\t// check for assignment with no effect", "-\t\t\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "-\t\t\t\t\t\tinitializationScope.problemReporter().assignmentHasNoEffect(this, this.name);", "-\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);", "-\t\t\t\t// Resolve Javadoc comment if one is present", "-\t\t\t\tif (this.javadoc != null) {", "-\t\t\t\t\t/*", "-\t\t\t\t\tif (classScope != null) {", "-\t\t\t\t\t\tthis.javadoc.resolve(classScope);", "-\t\t\t\t\t}", "-\t\t\t\t\t*/", "-\t\t\t\t\tthis.javadoc.resolve(initializationScope);", "-\t\t\t\t} else if (this.binding.declaringClass != null && !this.binding.declaringClass.isLocalType()) {", "-\t\t\t\t\tinitializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);", "+\t\t\t\tif (this.binding.isFinal()){ // cast from constant actual type to variable type", "+\t\t\t\t\tthis.binding.setConstant(this.initialization.constant.castTo((this.binding.type.id << 4) + this.initialization.constant.typeID()));", "-\t\t\t} finally {", "-\t\t\t\tinitializationScope.initializedField = previousField;", "-\t\t\t\tinitializationScope.lastVisibleFieldID = previousFieldID;", "-\t\t\t\tif (this.binding.constant() == null)", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t} else {", "+\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t// check for assignment with no effect", "+\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "+\t\t\t\tinitializationScope.problemReporter().assignmentHasNoEffect(this, this.name);", "+\t\t\t}\t\t\t\t\t", "-\t}", "+\t\t// Resolve Javadoc comment if one is present", "+\t\tif (this.javadoc != null) {", "+\t\t\t/*", "+\t\t\tif (classScope != null) {", "+\t\t\t\tthis.javadoc.resolve(classScope);", "+\t\t\t*/", "+\t\t\tthis.javadoc.resolve(initializationScope);", "+\t\t} else if (this.binding.declaringClass != null && !this.binding.declaringClass.isLocalType()) {", "+\t\t\tinitializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);", "+\t} finally {", "+\t\tinitializationScope.initializedField = previousField;", "+\t\tinitializationScope.lastVisibleFieldID = previousFieldID;", "+\t\tif (this.binding.constant() == null)", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);"]}], "num": 70758}