{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "669a99f38d526e49a8acfb45d88424f1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f091e8ba74300162238e53e2edac1ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "e5fda1d929f48b1ed961a5e3c698240a2263aa5e", "commitAfterChange": "492742130581f98e928eea7bd4ac7e448a4c7517", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "diff": ["+\t// need to find the overridden methods to avoid blaming this type for issues which are already reported against a supertype", "+\t// but cannot ignore an overridden inherited method completely when it comes to checking for bridge methods", "+\tint[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tproblemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// want to tag currentMethod even if return types are not equal", "-\t\tif (inheritedMethod.isAbstract()) {", "-\t\t\tif (inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing;", "-\t\t\t} else {", "-\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing | ExtraCompilerModifiers.AccOverriding;", "-\t\t\t}", "-// with the above change an abstract method is tagged as implementing the inherited abstract method", "-//\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-//\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-//\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "-\t\t\tif (reportIncompatibleReturnTypeError(currentMethod, inheritedMethod))", "+\t\tif (overriddenInheritedMethods == null || overriddenInheritedMethods[i] == 0) {", "+\t\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "+\t\t\t\tproblemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\t}", "-\t\tif (currentMethod.thrownExceptions != Binding.NO_EXCEPTIONS)", "-\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\t// want to tag currentMethod even if return types are not equal", "+\t\t\tif (inheritedMethod.isAbstract()) {", "+\t\t\t\tif (inheritedMethod.declaringClass.isInterface()) {", "+\t\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing;", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccImplementing | ExtraCompilerModifiers.AccOverriding;", "+\t\t\t\t}", "+//\t\t\twith the above change an abstract method is tagged as implementing the inherited abstract method", "+//\t\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "+//\t\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "+//\t\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "+\t\t\t} else {", "+\t\t\t\tcurrentMethod.modifiers |= ExtraCompilerModifiers.AccOverriding;", "+\t\t\t}", "+\t", "+\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "+\t\t\t\tif (reportIncompatibleReturnTypeError(currentMethod, inheritedMethod))", "+\t\t\t\t\tcontinue nextMethod;", "+\t", "+\t\t\tif (currentMethod.thrownExceptions != Binding.NO_EXCEPTIONS)", "+\t\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "+\t\t\tif (inheritedMethod.isFinal())", "+\t\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "+\t\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\t\tif (options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t", "+\t\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "628a9bdb6df3795f05ea612b580affc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["-}", "-void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t// methods includes the inherited methods that the currentMethod must comply with", "-\t// likely only 1 but could be more if mutiple declared supertypes define the method (1 superclass & 1 to many declared interfaces)", "-\tnextMethod : for (int i = length; --i >= 0;) {", "-\t\tMethodBinding inheritedMethod = methods[i];", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// curentMethod is always resolved as its defined by the source type BUT the inheritedMethod may not be", "-\t\t// so now with generics, the inheritedMethod should be resolved since we don't want to waste time dealing", "-\t\t// with Unresolved types over & over", "-\t\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "-\t\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "-", "-\t\tif (checkForNameClash(currentMethod, inheritedMethod)) {", "-\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType();", "-\t\tif (currentMethod.returnType != inheritedMethod.returnType) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t}", "-", "-\t\t\tTypeBinding inheritedReturnType = inheritedMethod.returnType.leafComponentType();", "-\t\t\tTypeBinding returnType = currentMethod.returnType.leafComponentType();", "-\t\t\tif (inheritedReturnType.isRawType()) {", "-\t\t\t\tif (returnType.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) returnType)) {", "-\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedReturnType.isParameterizedType()) {", "-\t\t\t\tif (!returnType.isParameterizedType()) ", "-\t\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod, ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t} else if (inheritedReturnType.isTypeVariable()) {", "-\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod,  ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t}", "-\t\t\taddBridgeMethod = true;", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!areReturnTypesEqual(original, currentMethod) || !areParametersEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+}", "+MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {", "+\tif (inheritedMethod == null) return null;", "+", "+\t// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved", "+\t// should we push these tests to where they're needed? returnType.isCompatibleWith && parameter isEquivalentTo ?", "+\tif (currentMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);", "+\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "+", "+\tTypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables();", "+\tif (inheritedTypeVariables == NoTypeVariables) return inheritedMethod;", "+\tTypeVariableBinding[] typeVariables = currentMethod == null ? NoTypeVariables : currentMethod.typeVariables;", "+", "+\tint inheritedLength = inheritedTypeVariables.length;", "+\tint length = typeVariables.length;", "+\tTypeBinding[] arguments = new TypeBinding[inheritedLength];", "+\tif (inheritedLength <= length) {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, inheritedLength);", "+\t} else {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, length);", "+\t\tfor (int i = length; i < inheritedLength; i++)", "+\t\t\targuments[i] = inheritedTypeVariables[i].erasure();", "+\t}", "+\tParameterizedGenericMethodBinding substitute =", "+\t\tnew ParameterizedGenericMethodBinding(inheritedMethod, arguments, this.environment);", "+\tfor (int i = 0; i < inheritedLength; i++)", "+\t    if (!inheritedTypeVariables[i].boundCheck(substitute, arguments[i]))", "+\t    \treturn inheritedMethod; // incompatible due to bound check", "+   return substitute;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d3d8279a5b0c0a4e2592651dba348c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "82dc67de142f757f6098e678017a2b32f752c9b7", "commitAfterChange": "5249d37677c0ce4d66ab262efb5c3dd4aa089796", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": "  void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\tif (length > 1) {", "-\t\tint[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);", "-\t\tif (overriddenInheritedMethods != null) {", "-\t\t\t// detected some overridden methods that can be ignored when checking return types", "-\t\t\t// but cannot ignore an overridden inherited method completely when it comes to checking for bridge methods", "-\t\t\tint index = 0;", "-\t\t\tMethodBinding[] closestMethods = new MethodBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif (overriddenInheritedMethods[i] == 0)", "-\t\t\t\t\tclosestMethods[index++] = methods[i];", "-\t\t\tif (index > 1 && !checkInheritedReturnTypes(closestMethods, index))", "-\t\t\t\treturn;", "-\t\t} else if (!checkInheritedReturnTypes(methods, length)) {", "-\t\t\treturn;", "-\t\t}", "-\t}", "+\t/*", "+\t1. find concrete method", "+\t2. if it doesn't exist then find first inherited abstract method whose return type is compatible with all others", "+\t   if no such method exists then report incompatible return type error", "+\t   otherwise report abstract method must be implemented", "+\t3. if concrete method exists, check to see if its return type is compatible with all others", "+\t   if it is then check concrete method against abstract methods", "+\t   if its not, then find most specific abstract method & report abstract method must be implemented since concrete method is insufficient", "+\t   if no most specific return type abstract method exists, then report incompatible return type with all inherited methods ", "+\t*/", "-\tMethodBinding concreteMethod = null;", "-\tif (!this.type.isInterface()) {  // ignore concrete methods for interfaces", "-\t\tfor (int i = length; --i >= 0;) {  // Remember that only one of the methods can be non-abstract", "-\t\t\tif (!methods[i].isAbstract()) {", "-\t\t\t\tconcreteMethod = methods[i];", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t}", "+\tMethodBinding concreteMethod = this.type.isInterface() || methods[0].isAbstract() ? null : methods[0];", "-\t\tif (!this.type.isAbstract()) {", "-\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\tif (mustImplementAbstractMethod(methods[i].declaringClass)) {", "-\t\t\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "-\t\t\t\t\tif (typeDeclaration != null) {", "-\t\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(methods[0]);", "-\t\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn;", "+\t\tMethodBinding bestAbstractMethod = length == 1 ? methods[0] : findBestInheritedAbstractMethod(methods, length);", "+\t\tif (bestAbstractMethod == null) {", "+\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "+\t\t} else if (mustImplementAbstractMethod(bestAbstractMethod.declaringClass)) {", "+\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "+\t\t\tMethodBinding superclassAbstractMethod = methods[0];", "+\t\t\tif (superclassAbstractMethod == bestAbstractMethod || superclassAbstractMethod.declaringClass.isInterface()) {", "+\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(bestAbstractMethod);", "+\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod);", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(bestAbstractMethod);", "+\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, superclassAbstractMethod);", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, superclassAbstractMethod);", "+\tif (length < 2) return; // nothing else to check", "-\tif (length > 1) {", "-\t\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];", "-\t\tint index = 0;", "-\t\tfor (int i = length; --i >= 0;)", "-\t\t\tif (methods[i] != concreteMethod)", "-\t\t\t\tabstractMethods[index++] = methods[i];", "-\t\tcheckConcreteInheritedMethod(concreteMethod, abstractMethods);", "+\tint index = length;", "+\twhile (--index > 0 && checkInheritedReturnTypes(concreteMethod, methods[index])) {/*empty*/}", "+\tif (index > 0) {", "+\t\t// concreteMethod is not the best match", "+\t\tMethodBinding bestAbstractMethod = findBestInheritedAbstractMethod(methods, length);", "+\t\tif (bestAbstractMethod == null)", "+\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "+\t\telse // can only happen in >= 1.5 since return types must be equal prior to 1.5", "+\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, concreteMethod);", "+\t\treturn;", "+", "+\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];", "+\tindex = 0;", "+\tfor (int i = 0; i < length; i++)", "+\t\tif (methods[i].isAbstract())", "+\t\t\tabstractMethods[index++] = methods[i];", "+\tif (index < abstractMethods.length)", "+\t\tSystem.arraycopy(abstractMethods, 0, abstractMethods = new MethodBinding[index], 0, index);", "+\tcheckConcreteInheritedMethod(concreteMethod, abstractMethods);"]}], "num": 52917}