{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5ebbe3eea351cf03ab2c423c877fdc08", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0488d290da998d278e3b35e0d18bb7c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 34, "signatureBeforeChange": "  \tUnconditionalFlowInfo()", "signatureAfterChange": "  public UnconditionalFlowInfo nullInfoLessUnconditionalCopy()", "diff": ["-\tUnconditionalFlowInfo() {", "-\t\tthis.reachMode = REACHABLE;", "+", "+public UnconditionalFlowInfo nullInfoLessUnconditionalCopy() {", "+\tif (this == DEAD_END) {", "+\t\treturn this;", "+\t}", "+\tUnconditionalFlowInfo copy = new UnconditionalFlowInfo();", "+\tcopy.definiteInits = this.definiteInits;", "+\tcopy.potentialInits = this.potentialInits;", "+\tcopy.tagBits = this.tagBits & ~NULL_FLAG_MASK;", "+\tcopy.maxFieldCount = this.maxFieldCount;", "+\tif (this.extra != null) {", "+\t\tint length;", "+\t\tcopy.extra = new long[extraLength][];", "+\t\tSystem.arraycopy(this.extra[0], 0, ", "+\t\t\t(copy.extra[0] = ", "+\t\t\t\tnew long[length = this.extra[0].length]), 0, length);", "+\t\tSystem.arraycopy(this.extra[1], 0, ", "+\t\t\t(copy.extra[1] = new long[length]), 0, length);", "+\t\tfor (int j = 2; j < extraLength; j++) {", "+\t\t\tcopy.extra[j] = new long[length];", "+\t\t}", "+\t}", "+\treturn copy;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06467c2013679bb2ac4ad8aad6eb8c11", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java", "commitBeforeChange": "8b644ce068ecf49daa5da8af14e814933ab3df61", "commitAfterChange": "23872cdac6fbbd78479a7f309cf6a923f8b64047", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " private FlowInfo addInfoFrom(FlowInfo inits, boolean handleInits)", "signatureAfterChange": " private FlowInfo addInfoFrom(FlowInfo inits, boolean handleInits)", "diff": ["+//\tif ((otherInits.iNNBit | otherInits.iNBit) == 0)", "+//\t\tthisHadNulls = false; // suppress incoming null info, if none shines through in other", "+\t\t\tthis.iNBit = otherInits.iNBit;", "+\t\t\tthis.iNNBit = otherInits.iNNBit;", "-\t\t\tthis.nullBit1 = (b1 = otherInits.nullBit1)", "+\t\t\tlong merge1 = (b1 = otherInits.nullBit1)", "-\t\t\tthis.nullBit2  = b2 & (nb4 | nb3)", "+\t\t\tlong merge2  = b2 & (nb4 | nb3)", "-\t\t\tthis.nullBit3 = b3 & (nb1 & (b2 | a2 | na1)", "+\t\t\tlong merge3 = b3 & (nb1 & (b2 | a2 | na1)", "-\t\t\tthis.nullBit4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+\t\t\tlong merge4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+", "+\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "+\t\t\tlong protNN1111 = merge1&merge2&merge3&merge4;", "+", "+\t\t\t// filter 'merge' using iNBit,iNNBit from otherInits:", "+\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "+\t\t\tlong acceptNonNull = otherInits.iNNBit;", "+\t\t\tlong acceptNull = otherInits.iNBit", "+\t\t\t\t\t\t\t\t| b1&b2&b3&b4; // for 1111 don't bother suppressing incoming null (mixing 'merge' & 'b' would break in this case) ", "+\t\t\tthis.nullBit1 = merge1;", "+\t\t\tthis.nullBit2 = protNN1111 |", "+\t\t\t\t \t\t\t\t((acceptNull & merge2) | (~acceptNull & b2)); // iNBit selects between info from merge2 vs. b2", "+\t\t\tthis.nullBit3 = protNN1111 |", "+\t\t\t\t\t\t\t\t((acceptNonNull & merge3) | (~acceptNonNull & b3)); // iNNBit selects between info from merge3 vs. b3", "+\t\t\tthis.nullBit4 = merge4;", "+\t\t\t// unconditional sequence, must shine through both to shine through in the end:", "+\t\t\tthis.iNBit &= otherInits.iNBit;", "+\t\t\tthis.iNNBit &= otherInits.iNNBit;", "+\t\t\t\tSystem.arraycopy(otherInits.extra[IN], 0, this.extra[IN], 0, otherLength);", "+\t\t\t\tSystem.arraycopy(otherInits.extra[INN], 0, this.extra[INN], 0, otherLength);", "-\t\t\tthis.extra[1 + 1][i] = (b1 = otherInits.extra[1 + 1][i])", "+\t\t\tlong merge1 = (b1 = otherInits.extra[1 + 1][i])", "-\t\t\tthis.extra[2 + 1][i]  = b2 & (nb4 | nb3)", "+\t\t\tlong merge2 = b2 & (nb4 | nb3)", "-\t\t\tthis.extra[3 + 1][i] = b3 & (nb1 & (b2 | a2 | na1)", "+\t\t\tlong merge3 = b3 & (nb1 & (b2 | a2 | na1)", "-\t\t\tthis.extra[4 + 1][i] = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+\t\t\tlong merge4 = nb1 & (a4 & (na3 & nb3\t| (a3 | na2) & nb2)", "+", "+\t\t\t// state that breaks the correlation between bits and n or nn, used below:", "+\t\t\tlong protNN1111 = merge1&merge2&merge3&merge4;", "+", "+\t\t\t// filter 'merge' using iNBit,iNNBit from otherInits:", "+\t\t\t// this implements that otherInit does not accept certain bits which are known to be superseded by info in otherInits.\t\t\t", "+\t\t\tlong acceptNonNull = otherInits.extra[INN][i];", "+\t\t\tlong acceptNull = otherInits.extra[IN][i]", "+\t\t\t\t\t\t\t\t| b1&b2&b3&b4; // for 1111 don't bother suppressing incoming null (mixing 'merge' & 'b' would break in this case) ", "+\t\t\tthis.extra[1 + 1][i] = merge1;", "+\t\t\tthis.extra[2 + 1][i] = protNN1111 |", "+\t\t\t\t \t\t\t\t((acceptNull & merge2) | (~acceptNull & b2)); // iNBit selects between info from merge2 vs. b2", "+\t\t\tthis.extra[3 + 1][i] = protNN1111 |", "+\t\t\t\t\t\t\t\t((acceptNonNull & merge3) | (~acceptNonNull & b3)); // iNNBit selects between info from merge3 vs. b3", "+\t\t\tthis.extra[4 + 1][i] = merge4;", "+\t\t\t// unconditional sequence, must shine through both to shine through in the end:", "+\t\t\tthis.extra[IN][i] &= otherInits.extra[IN][i];", "+\t\t\tthis.extra[INN][i] &= otherInits.extra[INN][i];", "+"]}], "num": 25560}