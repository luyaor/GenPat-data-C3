{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c5d5eae5d5dac991ecd169c18c645670", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38f86ca16765b98f8d5f7b0e8643995c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "bf4fd359c98503d2401041bd16d54a83079f69fe", "commitAfterChange": "7183d81a2458b7a9ecc9004f74bf12b52ac2eafc", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tprivate void addDependentProjects(IPath projectPath, HashSet result)", "signatureAfterChange": " \tprivate void addDependentProjects(IJavaProject project, HashMap projectDependencies, HashSet result)", "diff": ["-\tprivate void addDependentProjects(IPath projectPath, HashSet result) {", "-\t\tIJavaProject[] projects = null;", "-\t\ttry {", "-\t\t\tprojects = this.manager.getJavaModel().getJavaProjects();", "-\t\t} catch (JavaModelException e) {", "-\t\t\t// java model doesn't exist", "-\t\t\treturn;", "+\tprivate void addDependentProjects(IJavaProject project, HashMap projectDependencies, HashSet result) {", "+\t\tIJavaProject[] dependents = (IJavaProject[]) projectDependencies.get(project);", "+\t\tif (dependents == null) return;", "+\t\tfor (int i = 0, length = dependents.length; i < length; i++) {", "+\t\t\tIJavaProject dependent = dependents[i];", "+\t\t\tif (result.contains(dependent))", "+\t\t\t\tcontinue; // no need to go further as the project is already known", "+\t\t\tresult.add(dependent);", "+\t\t\taddDependentProjects(dependent, projectDependencies, result);", "-\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\tIJavaProject project = projects[i];", "-\t\t\tIClasspathEntry[] classpath = null;", "-\t\t\ttry {", "-\t\t\t\tclasspath = ((JavaProject)project).getExpandedClasspath(true);", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// project doesn't exist: continue with next project", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {", "-\t\t\t\tIClasspathEntry entry = classpath[j];", "-\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT", "-\t\t\t\t\t\t\t&& entry.getPath().equals(projectPath)) {", "-\t\t\t\t\t\tresult.add(project);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0834fc470720a2e8f63b6b9c727de6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "6dc2c6292eeb29ab819c1296b12d7a61265835da", "commitAfterChange": "d3d9c65ab8eabcabeb66c720711bcaf713684a64", "methodNumberBeforeChange": 78, "methodNumberAfterChange": 80, "signatureBeforeChange": "\r \tprotected void setRawClasspath0(IClasspathEntry[] rawEntries)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tprotected void setRawClasspath0(IClasspathEntry[] rawEntries)\r \t\tthrows JavaModelException", "diff": ["-\t\t\t// map of all immediate (resolved) entries\t\t\t\r", "-\t\t\tIClasspathEntry[] resolvedEntries = getResolvedClasspath(true);\r", "-\t\t\tHashtable immediateEntries = new Hashtable(resolvedEntries.length);\r", "-\t\t\tfor (int i = 0; i < resolvedEntries.length; i++) {\r", "-\t\t\t\timmediateEntries.put(resolvedEntries[i], this);\r", "-\t\t\t}\r", "-\t\t\tIClasspathEntry[] expandedEntries = getExpandedClasspath(true);\r", "-\t\t\tfor (int i = 0; i < expandedEntries.length; i++) {\r", "-\t\t\t\tIClasspathEntry entry = expandedEntries[i];\r", "-\t\t\t\tIPackageFragmentRoot[] roots = getPackageFragmentRoots(entry);\r", "-\t\t\t\tfor (int j = 0; j < roots.length; j++) {\r", "-\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) roots[j];\r", "-\t\t\t\t\tif (root.exists0()) {\r", "-\t\t\t\t\t\t// only trigger indexing of immediate libraries\r", "-\t\t\t\t\t\tif (immediateEntries.get(entry) != null){\r", "-\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_BINARY && indexManager != null) {\r", "-\t\t\t\t\t\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t\t\t\t\t\tindexManager.indexJarFile(root.getPath(), getUnderlyingResource().getName());\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tindexManager.indexBinaryFolder(\r", "-\t\t\t\t\t\t\t\t\t\t(IFolder) root.getUnderlyingResource(),\r", "-\t\t\t\t\t\t\t\t\t\t(IProject) this.getUnderlyingResource());\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tinfo.addChild(root);\r", "+\t\t\tObjectVector accumulatedRoots = new ObjectVector();\r", "+\t\t\tcomputePackageFragmentRoots(accumulatedRoots, new ObjectSet(5), true, true, false);\r", "+\t\t\tIJavaElement[] rootArray = new IJavaElement[accumulatedRoots.size()];\r", "+\t\t\taccumulatedRoots.copyInto(rootArray);\r", "+\t\t\tinfo.setChildren(rootArray);\t\t\t\t\t\r", "+\t\t\t\r", "+\t\t\t// only trigger indexing of immediate libraries\r", "+\t\t\tIPackageFragmentRoot[] immediateRoots = getPackageFragmentRoots();\t\t\t\t\t\t\r", "+\t\t\tfor(int i = 0, length = immediateRoots.length; i < length; i++){\r", "+\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)immediateRoots[i];\r", "+\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_BINARY && indexManager != null) {\r", "+\t\t\t\t\tif (root.isArchive()) {\r", "+\t\t\t\t\t\tindexManager.indexJarFile(root.getPath(), getUnderlyingResource().getName());\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tindexManager.indexBinaryFolder(\r", "+\t\t\t\t\t\t\t(IFolder) root.getUnderlyingResource(),\r", "+\t\t\t\t\t\t\t(IProject) this.getUnderlyingResource());\r", "+\t\t\t\r"]}], "num": 64429}