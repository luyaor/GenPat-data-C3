{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b65f894189fc3cf08e0c77b945d6732d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d767f2c20619fd432e4d66b001b95f26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "119ab5f40e72a2e48985fa6b9f7f154cd8ab7391", "commitAfterChange": "8f964ebcfbbe015096db590c4a751ad5a6ca4f58", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "diff": ["+\t\t\t\t} else if (castedExpressionType == NullBinding){", "+\t\t\t\t\tcontinue; // tolerate null argument cast"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0690c99db5b050b04e864e0008785ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "dd3bff4d99a5193497eb7e3c0e1bc46a32b7c36a", "commitAfterChange": "cc1c110e9641a2cecfab702ac9383376aefe030a", "methodNumberBeforeChange": 433, "methodNumberAfterChange": 421, "signatureBeforeChange": " public boolean atConflictScenario(int token)", "signatureAfterChange": " public boolean atConflictScenario(int token)", "diff": ["-\t   start of <type argument> and (b) the use of '(' in '(' expression ')' and '( type ')' and '(' lambda formal parameters ')'. When requested thus,", "-\t   the scanner helps by fabricating synthetic tokens and injecting them into the stream ahead of the tokens that trigger conflicts in the absence", "-\t   of these artificial tokens. These manufactured token help transform the grammar into LALR(1) by splitting the states so that they have unambigious", "-\t   prefixes.", "+\t   start of <type argument> and (b) the use of '(' in '(' expression ')' and '( type ')' and '(' lambda formal parameters ')'. (c) whether the token @", "+\t   begins a Java SE5 style declaration annotation or if it begins a SE8 style type annotation. When requested thus, the scanner helps by fabricating ", "+\t   synthetic tokens and injecting them into the stream ahead of the tokens that trigger conflicts in the absence of these artificial tokens. These ", "+\t   manufactured token help transform the grammar into LALR(1) by splitting the states so that they have unambigious prefixes.", "-\ttoken = token == TokenNameLPAREN ? TokenNameBeginLambda : TokenNameBeginTypeArguments;", "+\tif (token != TokenNameAT) {", "+\t\ttoken = token == TokenNameLPAREN ? TokenNameBeginLambda : TokenNameBeginTypeArguments;", "+\t}"]}], "num": 11550}