{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0f4099933ec79426fb88efc3b1ca35f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "193e848d3db92dd01082c51020e9504a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeleteElementsOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void replaceElementInBuffer(IBuffer buffer, IJavaElement elementToRemove, String cuName)", "signatureAfterChange": " \t \tprivate void deleteElement(IJavaElement elementToRemove, ICompilationUnit cu) throws JavaModelException", "diff": ["+\tprivate void deleteElement(IJavaElement elementToRemove, ICompilationUnit cu) throws JavaModelException {", "+\t\t// ensure cu is consistent (noop if already consistent)", "+\t\tcu.makeConsistent(this.progressMonitor);", "+\t\tthis.parser.setSource(cu);", "+\t\tCompilationUnit astCU = (CompilationUnit) this.parser.createAST(this.progressMonitor);", "+\t\tASTNode node = ((JavaElement) elementToRemove).findNode(astCU);", "+\t\tif (node == null) ", "+\t\t\tAssert.isTrue(false, \"Failed to locate \" + elementToRemove.getElementName() + \" in \" + cu.getElementName()); //$NON-NLS-1$//$NON-NLS-2$", "+\t\tIDocument document = getDocument(cu);", "+\t\tAST ast = astCU.getAST();", "+\t\tASTRewrite rewriter = ASTRewrite.create(ast);", "+\t\trewriter.remove(node, null);", "+ \t\tTextEdit edits = rewriter.rewriteAST(document, null);", "+ \t\ttry {", "+\t \t\tedits.apply(document);", "+ \t\t} catch (BadLocationException e) {", "+ \t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.INVALID_CONTENTS);", "+ \t\t}", "+\t}", "-    // TODO - JDOM - remove once model ported off of JDOM", "-\tprivate void replaceElementInBuffer(IBuffer buffer, IJavaElement elementToRemove, String cuName) {", "-\t\tIDOMCompilationUnit cuDOM = factory.createCompilationUnit(buffer.getCharacters(), cuName);", "-\t\torg.eclipse.jdt.internal.core.jdom.DOMNode node = (org.eclipse.jdt.internal.core.jdom.DOMNode)((JavaElement) elementToRemove).findNode(cuDOM);", "-\t\tif (node == null) Assert.isTrue(false, \"Failed to locate \" + elementToRemove.getElementName() + \" in \" + cuDOM.getName()); //$NON-NLS-1$//$NON-NLS-2$", "-", "-\t\tint startPosition = node.getStartPosition();", "-\t\tbuffer.replace(startPosition, node.getEndPosition() - startPosition + 1, CharOperation.NO_CHAR);", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f7b9de70876a0c1192d9e3bd6565109", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java", "commitBeforeChange": "ec36c5b556303647a122217dbc357a0c1ccafd42", "commitAfterChange": "a25cead90931bbc9548552bec95aa6f79a389aa3", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " protected void storeProblemsFor(SourceFile sourceFile, IProblem[] problems) throws CoreException", "signatureAfterChange": " protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException", "diff": ["-protected void storeProblemsFor(SourceFile sourceFile, IProblem[] problems) throws CoreException {", "+protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException {", "-\t\tIProblem problem = problems[i];", "+\t\tCategorizedProblem problem = problems[i];", "+//\t\t\tTODO need to ask problem for its marker type, once they are fully managed (clean/flush) ", "+\t\t\t//IMarker marker = resource.createMarker(problem.getMarkerType());", "+\t\t\t", "+\t\t\t// standard attributes", "-\t\t\t\t\tnew Integer(ProblemReporter.getProblemCategory(id)), // category ID", "+\t\t\t\t\tnew Integer(problem.getCategoryID()), // category ID", "+\t\t\t// optional extra attributes", "+\t\t\tString[] extraAttributeNames = problem.getExtraMarkerAttributeNames();", "+\t\t\tint extraLength = extraAttributeNames == null ? 0 : extraAttributeNames.length;", "+\t\t\tif (extraLength > 0) {", "+\t\t\t\tmarker.setAttributes(extraAttributeNames, problem.getExtraMarkerAttributeValues());", "+\t\t\t}", "-", "-/* Do NOT want to populate the Java Model just to find the matching Java element.", "- * Also cannot query compilation units located in folders with invalid package", "- * names such as 'a/b.c.d/e'.", "-", "-\t\t// compute a user-friendly location", "-\t\tIJavaElement element = JavaCore.create(resource);", "-\t\tif (element instanceof org.eclipse.jdt.core.ICompilationUnit) { // try to find a finer grain element", "-\t\t\torg.eclipse.jdt.core.ICompilationUnit unit = (org.eclipse.jdt.core.ICompilationUnit) element;", "-\t\t\tIJavaElement fragment = unit.getElementAt(problem.getSourceStart());", "-\t\t\tif (fragment != null) element = fragment;", "-\t\t}", "-\t\tString location = null;", "-\t\tif (element instanceof JavaElement)", "-\t\t\tlocation = ((JavaElement) element).readableName();", "-\t\tif (location != null)", "-\t\t\tmarker.setAttribute(IMarker.LOCATION, location);", "-*/", "-"]}], "num": 42428}