{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "363bd83c41ce8b6b62b142c84b981f94", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14fb38476c06d43b6ad5772c818f3645", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "ba623d582045575b43eee2b86be165ff58225746", "commitAfterChange": "5f25db2c9c02bf799108bff292447ab679c3c3b7", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods)", "diff": ["-void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod) {", "+void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {", "-\tif (inheritedMethod != originalInherited) {", "-\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "-\t\tif (toCheck.length > 1) {", "-\t\t\t// must check to see if a bridge method will collide with another current method (see 77861)", "-\t\t\tfor (int i = 0, length = toCheck.length; i < length; i++) {", "-\t\t\t\tif (currentMethod != toCheck[i] && toCheck[i].areParameterErasuresEqual(originalInherited)) {", "-\t\t\t\t\tproblemReporter(toCheck[i]).methodNameClash(toCheck[i], originalInherited); // bridge method will collide", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tthis.type.addSyntheticBridgeMethod(originalInherited, currentMethod);", "+", "+\tif (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod) != null) {", "+\t\tfor (int i = 0, l = otherInheritedMethods.length; i < l; i++) {", "+\t\t\tif (otherInheritedMethods[i] != null) {", "+\t\t\t\tMethodBinding otherOriginal = otherInheritedMethods[i].original();", "+\t\t\t\tif (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))", "+\t\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// there is an ordering issue with the comparison in checkMethods", "+\t\t// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)", "+\t\t// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method", "+\t\t//\t\tclass X implements Comparable<X> {", "+\t\t//\t\t\tpublic int compareTo(Object o) { return 0; }", "+\t\t//\t\t\tpublic int compareTo(X o) { return 1; }", "+\t\t//\t\t}", "+\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "+\t\tfor (int i = 0, l = toCheck.length; i < l; i++)", "+\t\t\tif (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))", "+\t\t\t\treturn;", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f960040f3103ec8e31b028779c40724", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "74ceca813d8e9be557353622cfb1779e5fa562ad", "commitAfterChange": "2d7d544af40c78aee4e80de194acd385e8eab51a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "diff": ["-void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {", "+void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods) {", "-\t\tfor (int i = 0, l = otherInheritedMethods.length; i < l; i++) {", "-\t\t\tif (otherInheritedMethods[i] != null) {", "-\t\t\t\tMethodBinding otherOriginal = otherInheritedMethods[i].original();", "-\t\t\t\tif (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))", "-\t\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-", "-\t\t// there is an ordering issue with the comparison in checkMethods", "-\t\t// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)", "-\t\t// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method", "-\t\t//\t\tclass X implements Comparable<X> {", "-\t\t//\t\t\tpublic int compareTo(Object o) { return 0; }", "-\t\t//\t\t\tpublic int compareTo(X o) { return 1; }", "-\t\t//\t\t}", "-\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "-\t\tfor (int i = 0, l = toCheck.length; i < l; i++)", "-\t\t\tif (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))", "+\t\tfor (int i = 0, l = allInheritedMethods.length; i < l; i++) {", "+\t\t\tMethodBinding otherInheritedMethod = allInheritedMethods[i];", "+\t\t\tMethodBinding otherOriginal = otherInheritedMethod.original();", "+\t\t\tif (otherOriginal == otherInheritedMethod || areMethodsEqual(inheritedMethod, otherInheritedMethod)) continue;", "+\t\t\tif (detectInheritedMethodClash(originalInherited, otherOriginal))", "+\t\t}"]}], "num": 4595}