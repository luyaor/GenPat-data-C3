{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "37e019c04ed3adb9cc86a0e5d423a37f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0f84e96e685c360f214fa1aaec89c3c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 64, "signatureBeforeChange": "  \tprivate int printJavadocBlockNodesNewLines(FormatJavadocBlock block, FormatJavadocNode node, int previousEnd)", "signatureAfterChange": "  \tprivate int printJavadocBlockNodesNewLines(FormatJavadocBlock block, FormatJavadocNode node, int previousEnd)", "diff": ["-\t    \tint token = this.scanner.getNextToken();", "-\t    \tint length = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "+\t    \tint length = 0;", "+\t\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "+\t\t\tif (this.commentIndentation != null) firstColumn += this.commentIndentation.length();", "+\t\t\tif (headerLine) maxColumn++;", "-\t\t\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "-\t\t\t\tif (headerLine) firstColumn++;", "-    \t\t\t\tint col = this.column + length;", "+    \t\t\t\tint lastColumn = this.column + length;", "-\t    \t\t\t\ttoken = this.scanner.getNextToken();", "+\t    \t\t\t\tint token = this.scanner.getNextToken();", "-\t    \t\t\t\tcol += length;", "-\t\t\t    \t\tif (headerLine) { // special case when text is on the same line of the javadoc's header", "-\t\t\t    \t\t\tif ((col-1) > maxColumn)  {", "-\t\t\t\t\t\t\t\tnewLines++;", "-\t\t\t\t\t\t\t\tcol = firstColumn;", "-\t\t\t\t\t\t\t\tfirstColumn--;", "+\t    \t\t\t\tlastColumn += length;", "+\t    \t\t\t\tif (lastColumn > maxColumn) {", "+\t\t\t\t\t\t\tnewLines++;", "+\t\t\t\t    \t\tif (headerLine) {", "+\t\t\t\t\t\t\t\tmaxColumn--;", "-\t\t\t    \t\t} else if (col > maxColumn) {", "-\t\t\t\t\t\t\tnewLines++;", "-\t\t\t\t\t\t\tcol = firstColumn;", "+\t\t\t\t\t\t\tlastColumn = firstColumn;", "+    \t\t\t\tif (text.getHtmlTagID() == JAVADOC_SINGLE_BREAK_TAG_ID) {", "+    \t\t\t\t\t// never break before single break tag", "+    \t\t\t\t\treturn 0;", "+    \t\t\t\t}", "+    \t\t\t\tthis.scanner.getNextToken();", "-\t    \t\t\t\ttoken = this.scanner.getNextToken();", "+\t    \t\t\t\tint token = this.scanner.getNextToken();", "-\t\t    \t\t\tif ((firstColumn + length + tokenLength) >= maxColumn) {", "+\t\t    \t\t\tlength += tokenLength;", "+\t\t    \t\t\tif ((this.column + length) >= maxColumn) {", "-\t\t    \t\t\tlength += tokenLength;", "-\t    \t\tlength += inlinedBlock.tagEnd - inlinedBlock.sourceStart + 1;", "+\t    \t\tlength += inlinedBlock.tagEnd - inlinedBlock.sourceStart + 1;  // tag length", "+\t    \t\tif (inlinedBlock.reference != null) {", "+\t\t    \t\tlength++; // space between tag and reference", "+\t\t\t\t\tthis.scanner.resetTo(inlinedBlock.reference.sourceStart, inlinedBlock.reference.sourceEnd);", "+\t\t\t\t\tint previousToken = -1;", "+\t\t\t\t\tloop: while (!this.scanner.atEnd()) {", "+\t\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "+\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\tif (previousToken == TerminalTokens.TokenNameCOMMA) { // space between method arguments", "+\t\t\t\t\t\t\t\t\tlength++;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tlength += tokenLength;", "+\t\t\t\t\t\t\t\tif ((this.column+length) > maxColumn) {", "+\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t    \t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tpreviousToken = token;", "+\t\t    \t\t}", "+\t    \t\t}", "+\t    \t\tlength++; // one more for closing brace", "+    \t\tif ((firstColumn + length) >= maxColumn && node == block.nodes[0]) {", "+    \t\t\t// Do not split in this peculiar case as length would be also over the max", "+    \t\t\t// length on next line", "+    \t\t\treturn 0;", "+    \t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bdecd75bfe4a3aed5e4dca7954d47d91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/PublicScanner.java", "commitBeforeChange": "6d986f90e46cead3f7ad9cda57050210e9706675", "commitAfterChange": "267a4d5e2c999ddd91f8f8fabb0312930f048c1a", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " public int getNextToken() throws InvalidInputException", "signatureAfterChange": " public int getNextToken() throws InvalidInputException", "diff": ["-\t\t\t\t\tif (getNextChar('\\\\'))", "+\t\t\t\t\tif (getNextChar('\\\\')) {", "+\t\t\t\t\t\tif (this.unicodeAsBackSlash) {", "+\t\t\t\t\t\t\t// consume next character", "+\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\') && (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.currentCharacter = this.source[this.currentPosition++];", "+\t\t\t\t\t\t}", "-\t\t\t\t\telse { // consume next character", "+\t\t\t\t\t} else { // consume next character", "-\t\t\t\t\t\t\t\tint escapeSize = this.currentPosition;", "-\t\t\t\t\t\t\t\tboolean backSlashAsUnicodeInString = this.unicodeAsBackSlash;", "-\t\t\t\t\t\t\t\t//scanEscapeCharacter make a side effect on this value and we need the previous value few lines down this one", "-\t\t\t\t\t\t\t\tscanEscapeCharacter();", "-\t\t\t\t\t\t\t\tescapeSize = this.currentPosition - escapeSize;", "-\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr == 0) {", "-\t\t\t\t\t\t\t\t\t//buffer all the entries that have been left aside....", "-\t\t\t\t\t\t\t\t    unicodeInitializeBuffer(this.currentPosition - escapeSize - 1 - this.startPosition);", "-\t\t\t\t\t\t\t\t    unicodeStore();", "-\t\t\t\t\t\t\t\t} else { //overwrite the / in the buffer", "-\t\t\t\t\t\t\t\t\tthis.withoutUnicodePtr--; // unicode store will increment", "-\t\t\t\t\t\t\t\t    unicodeStore();", "-\t\t\t\t\t\t\t\t\tif (backSlashAsUnicodeInString) { //there are TWO \\ in the stream where only one is correct", "+\t\t\t\t\t\t\t\tif (this.unicodeAsBackSlash) {", "+\t\t\t\t\t\t\t\t\tthis.withoutUnicodePtr--;", "+\t\t\t\t\t\t\t\t\t// consume next character", "+\t\t\t\t\t\t\t\t\tthis.unicodeAsBackSlash = false;", "+\t\t\t\t\t\t\t\t\tif (((this.currentCharacter = this.source[this.currentPosition++]) == '\\\\') && (this.source[this.currentPosition] == 'u')) {", "+\t\t\t\t\t\t\t\t\t\tgetNextUnicodeChar();", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr == 0) {", "+\t\t\t\t\t\t\t\t\t\tunicodeInitializeBuffer(this.currentPosition - this.startPosition);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.withoutUnicodePtr --;", "+\t\t\t\t\t\t\t\t\tthis.currentCharacter = this.source[this.currentPosition++];", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t// we need to compute the escape character in a separate buffer", "+\t\t\t\t\t\t\t\tscanEscapeCharacter();", "+\t\t\t\t\t\t\t\tif (this.withoutUnicodePtr != 0) {", "+\t\t\t\t\t\t\t\t\tunicodeStore();", "+\t\t\t\t\t\t\t\tint previous;", "-\t", "+", "+\t\t\t\t\t\t\t\tprevious = this.currentPosition;", "+\t\t\t\t\t\t\t\tint firstTag = 0;", "-\t\t\t\t\t\t\t\t\tstar = this.currentCharacter == '*';", "+\t\t\t\t\t\t\t\t\tswitch (this.currentCharacter) {", "+\t\t\t\t\t\t\t\t\t\tcase '*':", "+\t\t\t\t\t\t\t\t\t\t\tstar = true;", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\tcase '@':", "+\t\t\t\t\t\t\t\t\t\t\tif (firstTag == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\tfirstTag = previous;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t// fall through default case to set star to false", "+\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\tstar = false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tprevious = this.currentPosition;", "+\t\t\t\t\t\t\t\tthis.commentTagStarts[this.commentPtr] = firstTag;"]}], "num": 12074}