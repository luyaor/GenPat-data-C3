{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ffc233a1467ecef3f39ff4e709d8efdf", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14f1eaa886b89b9078f58ac30cdd4500", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3091564ff71d95ca83672941f8a4ec3464344683", "commitAfterChange": "ac6c2726bc9770d7575dff83ad9611f141165280", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public int match(MethodDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(ASTNode node, MatchingNodeSet nodeSet)", "diff": ["+public int match(ASTNode node, MatchingNodeSet nodeSet) {", "+\tint declarationsLevel = IMPOSSIBLE_MATCH;", "+\tif (this.pattern.findReferences) {", "+\t\tif (node instanceof ImportReference) {", "+\t\t\t// With static import, we can have static method reference in import reference", "+\t\t\tImportReference importRef = (ImportReference) node;", "+\t\t\tint length = importRef.tokens.length-1;", "+\t\t\tif (importRef.isStatic() && !importRef.onDemand && matchesName(this.pattern.selector, importRef.tokens[length])) {", "+\t\t\t\tchar[][] compoundName = new char[length][];", "+\t\t\t\tSystem.arraycopy(importRef.tokens, 0, compoundName, 0, length);", "+\t\t\t\tchar[] declaringType = CharOperation.concat(pattern.declaringQualification, pattern.declaringSimpleName, '.');", "+\t\t\t\tif (matchesName(declaringType, CharOperation.concatWith(compoundName, '.'))) {", "+\t\t\t\t\tdeclarationsLevel = ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn nodeSet.addMatch(node, declarationsLevel);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4effe03cf908de7acd0f3fbf56c52fae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "671178f1f1111f921cebcc377164efed75b9cfcb", "commitAfterChange": "635d7e113ce40e25df072667fd17a7c3dd9b4152", "methodNumberBeforeChange": 108, "methodNumberAfterChange": 108, "signatureBeforeChange": " \t \tprivate void recordNodes(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, TagElement tagElement)", "signatureAfterChange": " \t \tprivate void recordNodes(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc, TagElement tagElement)", "diff": ["-\t\t\t\t\tmemberRef.setQualifier(convert((org.eclipse.jdt.internal.compiler.ast.TypeReference) fieldRef.receiver));", "+\t\t\t\t\trecordName(memberRef.getQualifier(), fieldRef.receiver);", "+\t\t\t\tName name = methodRef.getName();", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(node.getStartPosition());", "+\t\t\t\tint start = name.getStartPosition();", "+\t\t\t\t// get compiler node and record nodes", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(start);", "-\t\t\t\t\trecordNodes(methodRef.getName(), compilerNode);", "+\t\t\t\t\trecordNodes(name, compilerNode);", "-\t\t\t\t\t\tmethodRef.setQualifier(convert(typeRef));", "+\t\t\t\t\t\trecordName(methodRef.getQualifier(), typeRef);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// Resolve parameters", "+\t\t\t\tIterator parameters = methodRef.parameters().listIterator();", "+\t\t\t\twhile (parameters.hasNext()) {", "+\t\t\t\t\tMethodRefParameter param = (MethodRefParameter) parameters.next();", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = (org.eclipse.jdt.internal.compiler.ast.Expression) javadoc.getNodeStartingAt(param.getStartPosition());", "+\t\t\t\t\tif (expression != null) {", "+\t\t\t\t\t\trecordNodes(param, expression);", "+\t\t\t\t\t\tif (expression instanceof JavadocArgumentExpression) {", "+\t\t\t\t\t\t\tJavadocArgumentExpression argExpr = (JavadocArgumentExpression) expression;", "+\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference typeRef = argExpr.argument.type;", "+\t\t\t\t\t\t\trecordNodes(param.getType(), typeRef);", "+\t\t\t\t\t\t\tif (param.getType().isSimpleType()) {", "+\t\t\t\t\t\t\t\tSimpleType type = (SimpleType)param.getType();", "+\t\t\t\t\t\t\t\trecordName(type.getName(), typeRef);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\tif (compilerNode != null) {", "-\t\t\t\t\tif (compilerNode instanceof org.eclipse.jdt.internal.compiler.ast.TypeReference) {", "-//\t\t\t\t\t\tconvert((org.eclipse.jdt.internal.compiler.ast.TypeReference) compilerNode);", "-\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference typeRef = (org.eclipse.jdt.internal.compiler.ast.TypeReference) compilerNode;", "-\t\t\t\t\t\tName name = (Name) node;", "-\t\t\t\t\t\tif (name.isQualifiedName()) {", "-\t\t\t\t\t\t\tSimpleName simpleName = null;", "-\t\t\t\t\t\t\twhile (name.isQualifiedName()) {", "-\t\t\t\t\t\t\t\tsimpleName = ((QualifiedName) name).getName();", "-\t\t\t\t\t\t\t\trecordNodes(simpleName, typeRef);", "-\t\t\t\t\t\t\t\tname = ((QualifiedName) name).getQualifier();", "-\t\t\t\t\t\t\t\trecordNodes(name, typeRef);", "-\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t\tsimpleName = ((QualifiedName) name).getName();", "-//\t\t\t\t\t\t\trecordNodes(simpleName, typeRef);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\trecordNodes(node, compilerNode);", "-\t\t\t\t}", "+\t\t\t\trecordName((Name) node, compilerNode);", "+\t\t\t}", "+\t\t}", "+\t}"]}], "num": 13283}