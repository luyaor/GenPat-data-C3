{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "82a19fa26cce564d9d71c8237f91af76", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7eb0e5e9e413b34972419c319a257397", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "8f838ccefdcacadaac662cb88a80fdb1a3657843", "commitAfterChange": "658041315da1052ce94c7e1b37be530cbc4e1f1d", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode)", "signatureAfterChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode)", "diff": ["+\t\tif (mode == CheckMode.BOUND_CHECK && requiredType instanceof TypeVariableBinding) {", "+\t\t\t// during bound check against a type variable check the provided type against all upper bounds:", "+\t\t\tTypeBinding superClass = requiredType.superclass();", "+\t\t\tif (superClass != null && superClass.hasNullTypeAnnotations()) {", "+\t\t\t\tNullAnnotationMatching status = analyse(superClass, providedType, null, nullStatus, mode);", "+\t\t\t\tseverity = Math.max(severity, status.severity);", "+\t\t\t\tif (severity == 2)", "+\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);", "+\t\t\t}", "+\t\t\tTypeBinding[] superInterfaces = requiredType.superInterfaces();", "+\t\t\tif (superInterfaces != null) {", "+\t\t\t\tfor (int i = 0; i < superInterfaces.length; i++) {", "+\t\t\t\t\tif (superInterfaces[i].hasNullTypeAnnotations()) {", "+\t\t\t\t\t\tNullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, nullStatus, mode);", "+\t\t\t\t\t\tseverity = Math.max(severity, status.severity);", "+\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\tlong requiredBits = requiredNullTagBits(requiredType);", "+\t\t\tlong requiredBits = requiredNullTagBits(requiredType, mode);", "-\t\t\t\tseverity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1);", "+\t\t\t\tint s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1);", "+\t\t\t\tseverity = Math.max(severity, s);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9d07a8d245ed46f9c31f668e277b276", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "6b8ea1fe34801155ff098e297d8447ae3bdf9761", "commitAfterChange": "a12821fa8f0e23855d8771487235dddff394d6b5", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode)", "signatureAfterChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode)", "diff": ["-\t\t\t\t\t\t\tif (i > 0)", "-\t\t\t\t\t\t\t\tcurrentNullStatus = -1; // don't use beyond the outermost dimension", "-\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));", "-\t\t\t\t\t\t\tif (severity == 2)", "-\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;", "+\t\t\t\t\t\t\tif (i == 0 && requiredBits == TagBits.AnnotationNullable && nullStatus != -1 && mode.requiredNullableMatchesAll()) {", "+\t\t\t\t\t\t\t\t// toplevel nullable array: no need to check ", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (i > 0)", "+\t\t\t\t\t\t\t\t\tcurrentNullStatus = -1; // don't use beyond the outermost dimension", "+\t\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));", "+\t\t\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;", "+\t\t\t\t\t\t\t}", "-\t\t\t\tif (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...", "-\t\t\t\t\t\t|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly", "-\t\t\t\t{", "+\t\t\t\tif (requiredBits == TagBits.AnnotationNullable && nullStatus != -1 && mode.requiredNullableMatchesAll()) {", "+\t\t\t\t\t// at toplevel (having a nullStatus) nullable matches all", "+\t\t\t\t} else {"]}], "num": 24581}