{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "635653eaaec7424c76b0b92961ed74fe", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "32534dd1d66047f83eec7caacd753932", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java", "commitBeforeChange": "d6e67d4c8518637d8a6205904d99263fcf72b512", "commitAfterChange": "25c3603d7bf5d103d47b791d11767b16968f4a1d", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tpublic boolean handleOption(String current, Iterator<String> remaining)", "signatureAfterChange": " \tpublic boolean handleOption(String current, Iterator<String> remaining)", "diff": ["-\t\t\t\t\tfinal Iterable<? extends File> bootclasspaths = getBootclasspathFrom(remaining.next());", "+\t\t\t\t\tfinal Iterable<? extends File> bootclasspaths = getPathsFrom(remaining.next());", "-\t\t\t\t\tfinal Iterable<? extends File> classpaths = getClasspathFrom(remaining.next());", "+\t\t\t\t\tfinal Iterable<? extends File> classpaths = getPathsFrom(remaining.next());", "-\t\t\t\t\tfinal Iterable<? extends File> sourcepaths = getSourcepathFrom(remaining.next());", "+\t\t\t\t\tfinal Iterable<? extends File> sourcepaths = getPathsFrom(remaining.next());", "-\t\t\tif (\"-d\".equals(current)) {//$NON-NLS-1$", "+\t\t\tif (\"-d\".equals(current)) { //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t\tremaining.remove();", "+\t\t\t\t\treturn true;", "+\t\t\t\t} else {", "+\t\t\t\t\tthrow new IllegalArgumentException();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (\"-s\".equals(current)) { //$NON-NLS-1$", "+\t\t\t\tremaining.remove(); // remove the current option", "+\t\t\t\tif (remaining.hasNext()) {", "+\t\t\t\t\tfinal Iterable<? extends File> outputDir = getOutputDir(remaining.next());", "+\t\t\t\t\tif (outputDir != null) {", "+\t\t\t\t\t\tsetLocation(StandardLocation.SOURCE_OUTPUT, outputDir);", "+\t\t\t\t\t}", "+\t\t\t\t\tremaining.remove();", "+\t\t\t\t\treturn true;", "+\t\t\t\t} else {", "+\t\t\t\t\tthrow new IllegalArgumentException();", "+\t\t\t\t}\t\t\t\t", "+\t\t\t}", "+\t\t\tif (\"-processorpath\".equals(current) || \"-cp\".equals(current)) {//$NON-NLS-1$//$NON-NLS-2$", "+\t\t\t\tremaining.remove(); // remove the current option", "+\t\t\t\tif (remaining.hasNext()) {", "+\t\t\t\t\tfinal Iterable<? extends File> processorpaths = getPathsFrom(remaining.next());", "+\t\t\t\t\tif (processorpaths != null) {", "+\t\t\t\t\t\tIterable<? extends File> iterable = getLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH);", "+\t\t\t\t\t\tsetLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, ", "+\t\t\t\t\t\t\tprependFiles(iterable, processorpaths));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93d3d69c0349a1486a68583cb3a39e52", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.pluggable.core/src/org/eclipse/jdt/internal/apt/pluggable/core/filer/IdeFilerImpl.java", "commitBeforeChange": "4aad3541005b227c1c4489d6142b68e14885b9dc", "commitAfterChange": "c69c700b22ba98a95d56e16f7365ecaf28392cdd", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t@Override \tpublic FileObject createResource(Location location, CharSequence pkg, \t\t\tCharSequence relativeName, Element... originatingElements) throws IOException", "signatureAfterChange": " \t@Override \tpublic FileObject createResource(Location location, CharSequence pkg, \t\t\tCharSequence relativeName, Element... originatingElements) throws IOException", "diff": ["-\t\t\tCharSequence relativeName, Element... originatingElements) throws IOException {", "-\t\t//TODO", "-\t\tthrow new UnsupportedOperationException(\"Creating resource files is not yet implemented\"); //$NON-NLS-1$", "+\t\t\tCharSequence relativeName, Element... originatingElements) throws IOException ", "+\t{", "+\t\t// Pre-emptively check parameters here, rather than later on when the resource is written and closed.", "+\t\tif (null == location) {", "+\t\t\tthrow new IllegalArgumentException(\"Location is null\");", "+\t\t}", "+\t\tif (!location.isOutputLocation()) {", "+\t\t\tthrow new IllegalArgumentException(\"Location \" + location.getName() + \" is not an output location\");", "+\t\t}", "+\t\t", "+\t\tif (null == pkg) {", "+\t\t\tthrow new IllegalArgumentException(\"Package is null\");", "+\t\t}", "+\t\tif (null == relativeName) {", "+\t\t\tthrow new IllegalArgumentException(\"Relative name is null\");", "+\t\t}", "+\t\tif ( relativeName.length() == 0) {", "+\t\t\tthrow new IllegalArgumentException(\"Relative name is zero length\");", "+\t\t}", "+\t\tIFile file = getOutputFileForLocation(location, pkg, relativeName);", "+\t\t", "+\t\t//TODO: check whether file has already been generated in this run", "+\t\tSet<IFile> parentFiles = new HashSet<IFile>(originatingElements.length);", "+\t\tfor (Element elem : originatingElements) {", "+\t\t\tIFile enclosing = _env.getEnclosingIFile(elem);", "+\t\t\tif (null != enclosing) {", "+\t\t\t\tparentFiles.add(enclosing);", "+\t\t\t}", "+\t\t}", "+\t\treturn new IdeOutputFileObject(_env, file, parentFiles);"]}], "num": 49727}