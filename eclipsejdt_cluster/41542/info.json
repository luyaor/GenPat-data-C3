{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6c5fb83d98da26db029a385473aeb33", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0b242c8faa039db342a08a2423c7b485", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 30, "signatureBeforeChange": " \t \tpublic char[] findSource(ClassFile classFile)", "signatureAfterChange": " \tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException", "diff": ["+\t */", "+\tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException {", "+\t\tMatchingNodeSet matchingNodeSet = null;", "+\t\ttry {", "+\t\t\tthis.currentPotentialMatch = this.matchesToProcess[i];", "+\t\t\tif (this.currentPotentialMatch == null) return;", "+\t\t\tmatchingNodeSet = this.currentPotentialMatch.matchingNodeSet;", "+\t\t\t", "+\t\t\tif (unit == null || unit.isEmpty()) {", "+\t\t\t\tif (this.currentPotentialMatch.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {", "+\t\t\t\t\tthis.currentPotentialMatch.locateMatchesInClassFile();", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (hasAlreadyDefinedType(unit)) {", "+\t\t\t\t// skip type has it is hidden so not visible", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tthis.parser.matchSet = this.currentPotentialMatch.matchingNodeSet;", "+\t\t\tgetMethodBodies(unit, i);", "+\t\t\t\t\t\t", "+\t\t\t// report matches that don't need resolve", "+\t\t\tmatchingNodeSet.cuHasBeenResolved = this.compilationAborted;", "+\t\t\tmatchingNodeSet.reportMatching(unit);", "+", "+\t\t\tif ((this.pattern.needsResolve || matchingNodeSet.needsResolve()/* TODO: do not need this check any longer */) ", "+\t\t\t\t\t&& unit.types != null ", "+\t\t\t\t\t&& !this.compilationAborted) {", "+", "+\t\t\t\tif (SearchEngine.VERBOSE) {", "+\t\t\t\t\tSystem.out.println(\"Resolving \" + this.currentPotentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t}", "+", "+\t\t\t\t// fault in fields & methods", "+\t\t\t\tif (unit.scope != null)", "+\t\t\t\t\tunit.scope.faultInTypes();", "+\t\t", "+\t\t\t\t// verify inherited methods", "+\t\t\t\tif (unit.scope != null)", "+\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "+\t\t", "+\t\t\t\t// type checking", "+\t\t\t\tunit.resolve();", "+\t\t", "+\t\t\t\t// refresh the total number of units known at this stage", "+\t\t\t\tunit.compilationResult.totalUnitsKnown = totalUnits;", "+", "+\t\t\t\t// report matches that needed resolve", "+\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "+\t\t\t\tmatchingNodeSet.reportMatching(unit);", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\t// could not resolve: report innacurate matches", "+\t\t\tif (matchingNodeSet != null) {", "+\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "+\t\t\t\tmatchingNodeSet.reportMatching(unit);", "+\t\t\t}", "+\t\t\tif (!(e instanceof AbortCompilationUnit)) {", "+\t\t\t\t// problem with class path", "+\t\t\t\tthrow e;", "+\t\t\t}", "+\t\t} finally {", "+\t\t\tthis.parser.matchSet = null;", "+\t\t\tthis.currentPotentialMatch = null;", "+\t\t}", "+\t}", "-\t", "-\tpublic char[] findSource(ClassFile classFile) {", "-\t\tchar[] source = null; ", "-\t\ttry {", "-\t\t\tSourceMapper sourceMapper = classFile.getSourceMapper();", "-\t\t\tif (sourceMapper != null) {", "-\t\t\t\tIType type = classFile.getType();", "-\t\t\t\tif (classFile.isOpen() && type.getDeclaringType() == null) {", "-\t\t\t\t\tsource = sourceMapper.findSource(type);", "-\t\t\t\t} else {", "-\t\t\t\t\tClassFileReader reader = this.classFileReader(type);", "-\t\t\t\t\tif (reader != null) {", "-\t\t\t\t\t\tString sourceFileName = sourceMapper.findSourceFileName(type, reader);", "-\t\t\t\t\t\tif (sourceFileName != null) {", "-\t\t\t\t\t\t\tsource = sourceMapper.findSource(type, sourceFileName);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} catch (JavaModelException e) {", "-\t\t}", "-\t\treturn source;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "19fe4a656167f55dfe1e564a36a7af7b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tpublic boolean compile(String[] argv)", "signatureAfterChange": " \tpublic boolean compile(String[] argv)", "diff": ["-\t\t\tif (proceed) {", "-\t\t\t\tif (showProgress)", "-\t\t\t\t\tout.println(Main.bind(\"progress.compiling\")); //$NON-NLS-1$", "-\t\t\t\tfor (int i = 0; i < repetitions; i++) {", "-\t\t\t\t\tglobalProblemsCount = 0;", "-\t\t\t\t\tglobalErrorsCount = 0;", "-\t\t\t\t\tglobalWarningsCount = 0;", "-\t\t\t\t\tlineCount = 0;", "-\t\t\t\t\texportedClassFilesCounter = 0;", "+\t\t\tif (this.proceed) {", "+\t\t\t\tif (this.showProgress)", "+\t\t\t\t\tthis.out.println(Main.bind(\"progress.compiling\")); //$NON-NLS-1$", "+\t\t\t\tfor (int i = 0; i < this.repetitions; i++) {", "+\t\t\t\t\tthis.globalProblemsCount = 0;", "+\t\t\t\t\tthis.globalErrorsCount = 0;", "+\t\t\t\t\tthis.globalWarningsCount = 0;", "+\t\t\t\t\tthis.lineCount = 0;", "+\t\t\t\t\tthis.exportedClassFilesCounter = 0;", "-\t\t\t\t\tif (repetitions > 1) {", "-\t\t\t\t\t\tout.flush();", "-\t\t\t\t\t\tout.println(", "+\t\t\t\t\tif (this.repetitions > 1) {", "+\t\t\t\t\t\tthis.out.flush();", "+\t\t\t\t\t\tthis.out.println(", "-\t\t\t\t\t\t\t\tString.valueOf(repetitions)));", "+\t\t\t\t\t\t\t\tString.valueOf(this.repetitions)));", "-\t\t\t\t\tif (timer) {", "+\t\t\t\t\tif (this.timer) {", "-\t\t\t\t\t\ttime = System.currentTimeMillis() - startTime;", "-\t\t\t\t\t\tif (lineCount != 0) {", "-\t\t\t\t\t\t\tout.println(", "+\t\t\t\t\t\tthis.time = System.currentTimeMillis() - startTime;", "+\t\t\t\t\t\tif (this.lineCount != 0) {", "+\t\t\t\t\t\t\tthis.out.println(", "-\t\t\t\t\t\t\t\t\t\tString.valueOf(lineCount),", "-\t\t\t\t\t\t\t\t\t\tString.valueOf(time),", "-\t\t\t\t\t\t\t\t\t\tString.valueOf(((int)(lineCount * 10000.0 / time)) / 10.0)}));", "+\t\t\t\t\t\t\t\t\t\tString.valueOf(this.lineCount),", "+\t\t\t\t\t\t\t\t\t\tString.valueOf(this.time),", "+\t\t\t\t\t\t\t\t\t\tString.valueOf(((int)(this.lineCount * 10000.0 / this.time)) / 10.0)}));", "-\t\t\t\t\t\t\tout.println(Main.bind(\"compile.totalTime\", String.valueOf(time))); //$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.out.println(Main.bind(\"compile.totalTime\", String.valueOf(this.time))); //$NON-NLS-1$", "-\t\t\t\t\tif (globalProblemsCount > 0) {", "-\t\t\t\t\t\tif (globalProblemsCount == 1) {", "-\t\t\t\t\t\t\terr.print(Main.bind(\"compile.oneProblem\")); //$NON-NLS-1$", "+\t\t\t\t\tif (this.globalProblemsCount > 0) {", "+\t\t\t\t\t\tif (this.globalProblemsCount == 1) {", "+\t\t\t\t\t\t\tthis.err.print(Main.bind(\"compile.oneProblem\")); //$NON-NLS-1$", "-\t\t\t\t\t\t\terr.print(", "-\t\t\t\t\t\t\t\tMain.bind(\"compile.severalProblems\", String.valueOf(globalProblemsCount))); \t//$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.err.print(", "+\t\t\t\t\t\t\t\tMain.bind(\"compile.severalProblems\", String.valueOf(this.globalProblemsCount))); \t//$NON-NLS-1$", "-\t\t\t\t\t\terr.print(\" (\"); //$NON-NLS-1$", "-\t\t\t\t\t\tif (globalErrorsCount > 0) {", "-\t\t\t\t\t\t\tif (globalErrorsCount == 1) {", "-\t\t\t\t\t\t\t\terr.print(Main.bind(\"compile.oneError\")); //$NON-NLS-1$", "+\t\t\t\t\t\tthis.err.print(\" (\"); //$NON-NLS-1$", "+\t\t\t\t\t\tif (this.globalErrorsCount > 0) {", "+\t\t\t\t\t\t\tif (this.globalErrorsCount == 1) {", "+\t\t\t\t\t\t\t\tthis.err.print(Main.bind(\"compile.oneError\")); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\terr.print(", "-\t\t\t\t\t\t\t\t\tMain.bind(\"compile.severalErrors\", String.valueOf(globalErrorsCount))); \t//$NON-NLS-1$", "+\t\t\t\t\t\t\t\tthis.err.print(", "+\t\t\t\t\t\t\t\t\tMain.bind(\"compile.severalErrors\", String.valueOf(this.globalErrorsCount))); \t//$NON-NLS-1$", "-\t\t\t\t\t\tif (globalWarningsCount > 0) {", "-\t\t\t\t\t\t\tif (globalErrorsCount > 0) {", "-\t\t\t\t\t\t\t\terr.print(\", \"); //$NON-NLS-1$", "+\t\t\t\t\t\tif (this.globalWarningsCount > 0) {", "+\t\t\t\t\t\t\tif (this.globalErrorsCount > 0) {", "+\t\t\t\t\t\t\t\tthis.err.print(\", \"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tif (globalWarningsCount == 1) {", "-\t\t\t\t\t\t\t\terr.print(Main.bind(\"compile.oneWarning\")); //$NON-NLS-1$", "+\t\t\t\t\t\t\tif (this.globalWarningsCount == 1) {", "+\t\t\t\t\t\t\t\tthis.err.print(Main.bind(\"compile.oneWarning\")); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\terr.print(", "-\t\t\t\t\t\t\t\t\tMain.bind(\"compile.severalWarnings\", String.valueOf(globalWarningsCount))); \t//$NON-NLS-1$", "+\t\t\t\t\t\t\t\tthis.err.print(", "+\t\t\t\t\t\t\t\t\tMain.bind(\"compile.severalWarnings\", String.valueOf(this.globalWarningsCount))); \t//$NON-NLS-1$", "-\t\t\t\t\t\terr.println(\")\"); //$NON-NLS-1$", "+\t\t\t\t\t\tthis.err.println(\")\"); //$NON-NLS-1$", "-\t\t\t\t\tif (exportedClassFilesCounter != 0", "+\t\t\t\t\tif (this.exportedClassFilesCounter != 0", "-\t\t\t\t\t\tif (exportedClassFilesCounter == 1) {", "-\t\t\t\t\t\t\tout.println(Main.bind(\"compile.oneClassFileGenerated\")); //$NON-NLS-1$", "+\t\t\t\t\t\tif (this.exportedClassFilesCounter == 1) {", "+\t\t\t\t\t\t\tthis.out.println(Main.bind(\"compile.oneClassFileGenerated\")); //$NON-NLS-1$", "-\t\t\t\t\t\t\tout.println(", "+\t\t\t\t\t\t\tthis.out.println(", "-\t\t\t\t\t\t\t\t\tString.valueOf(exportedClassFilesCounter)));", "+\t\t\t\t\t\t\t\t\tString.valueOf(this.exportedClassFilesCounter)));", "-\t\t\t\tif (showProgress)", "-\t\t\t\t\tout.println();", "+\t\t\t\tif (this.showProgress)", "+\t\t\t\t\tthis.out.println();", "-\t\t\tif (systemExitWhenFinished) {", "-\t\t\t\tout.flush();", "-\t\t\t\terr.flush();", "-\t\t\t\tSystem.exit(globalErrorsCount > 0 ? -1 : 0);", "+\t\t\tif (this.systemExitWhenFinished) {", "+\t\t\t\tthis.out.flush();", "+\t\t\t\tthis.err.flush();", "+\t\t\t\tSystem.exit(this.globalErrorsCount > 0 ? -1 : 0);", "-\t\t\terr.println(e.getMessage());", "-\t\t\terr.println(\"------------------------\"); //$NON-NLS-1$", "+\t\t\tthis.err.println(e.getMessage());", "+\t\t\tthis.err.println(\"------------------------\"); //$NON-NLS-1$", "-\t\t\tif (systemExitWhenFinished) {", "+\t\t\tif (this.systemExitWhenFinished) {", "-\t\t\tif (systemExitWhenFinished) {", "-\t\t\t\tout.flush();", "-\t\t\t\terr.flush();", "+\t\t\tif (this.systemExitWhenFinished) {", "+\t\t\t\tthis.out.flush();", "+\t\t\t\tthis.err.flush();", "-\t\t\t\t\terr.close();", "+\t\t\t\t\tthis.err.close();", "-\t\t\tout.flush();", "-\t\t\terr.flush();", "+\t\t\tthis.out.flush();", "+\t\t\tthis.err.flush();", "-\t\t\t\terr.close();", "+\t\t\t\tthis.err.close();", "-\t\tif (globalErrorsCount == 0){", "+\t\tif (this.globalErrorsCount == 0){"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aacab318a427d6b40bbf283fc3b248d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tconstant = Constant.NotAConstant;", "+\tthis.constant = Constant.NotAConstant;", "-\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\tthis.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\tthis.actualReceiverType = receiver.resolveType(scope); ", "-\tboolean receiverIsType = receiver instanceof NameReference && (((NameReference) receiver).bits & Binding.TYPE) != 0;", "+\tthis.actualReceiverType = this.receiver.resolveType(scope); ", "+\tboolean receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;", "-\tif (arguments != null) {", "+\tif (this.arguments != null) {", "-\t\tint length = arguments.length;", "+\t\tint length = this.arguments.length;", "-\t\t\tExpression argument = arguments[i];", "+\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\targument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\t\t\tif (actualReceiverType instanceof ReferenceBinding) {", "+\t\t\tif (this.actualReceiverType instanceof ReferenceBinding) {", "-\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? actualReceiverType : argumentTypes[i]; // replace args with errors with receiver", "+\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "-\t\t\t\t\treceiver.isImplicitThis()", "-\t\t\t\t\t\t? scope.getImplicitMethod(selector, pseudoArgs, this)", "-\t\t\t\t\t\t: scope.findMethod((ReferenceBinding) actualReceiverType, selector, pseudoArgs, this);", "-\t\t\t\tif (binding != null && !binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\t\t\t\tthis.receiver.isImplicitThis()", "+\t\t\t\t\t\t? scope.getImplicitMethod(this.selector, pseudoArgs, this)", "+\t\t\t\t\t\t: scope.findMethod((ReferenceBinding) this.actualReceiverType, this.selector, pseudoArgs, this);", "+\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif ((closestMatch.isPrivate() || closestMatch.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatch)) {", "+\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\tclosestMatch.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\t\treceiver.isImplicitThis()", "-\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(this.actualReceiverType, selector, argumentTypes, this); ", "-\tif (!binding.isValidBinding()) {", "-\t\tif (binding.declaringClass == null) {", "+\t\tthis.receiver.isImplicitThis()", "+\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "+\t\t\t: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this); ", "+\tif (!this.binding.isValidBinding()) {", "+\t\tif (this.binding.declaringClass == null) {", "-\t\t\t\tbinding.declaringClass = (ReferenceBinding) this.actualReceiverType;", "+\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;", "-\t\tscope.problemReporter().invalidMethod(this, binding);", "-\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\tscope.problemReporter().invalidMethod(this, this.binding);", "+\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\tif ((closestMatch.isPrivate() || closestMatch.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatch)) {", "+\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();\t\t\t", "+\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\tclosestMatch.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\tif (!binding.isStatic()) {", "+\tif (!this.binding.isStatic()) {", "-\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\t\t\t\t\t&& (this.receiver.bits & IgnoreRawTypeCheck) == 0 ", "+\t\t\t\t\t&& (this.receiver.bits & ASTNode.IgnoreRawTypeCheck) == 0 ", "-\t\t\treceiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "+\t\t\tthis.receiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "-\t\tif (!(receiver.isImplicitThis() || receiver.isSuper() || receiverIsType)) {", "-\t\t\tscope.problemReporter().nonStaticAccessToStaticMethod(this, binding);", "+\t\tif (!(this.receiver.isImplicitThis() || this.receiver.isSuper() || receiverIsType)) {", "+\t\t\tscope.problemReporter().nonStaticAccessToStaticMethod(this, this.binding);", "-\t\tif (!receiver.isImplicitThis() && binding.declaringClass != actualReceiverType) {", "-\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, binding);", "+\t\tif (!this.receiver.isImplicitThis() && this.binding.declaringClass != this.actualReceiverType) {", "+\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "-\tcheckInvocationArguments(scope, this.receiver, actualReceiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "+\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "-\tif (binding.isAbstract()) {", "-\t\tif (receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "+\tif (this.binding.isAbstract()) {", "+\t\tif (this.receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\tif (isMethodUseDeprecated(binding, scope, true))", "-\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+\tif (isMethodUseDeprecated(this.binding, scope, true))", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\tif (actualReceiverType.isArrayType() ", "+\tif (this.actualReceiverType.isArrayType() ", "-\t\t\t&& CharOperation.equals(this.binding.selector, CLONE)) {", "-\t\tthis.resolvedType = actualReceiverType;", "+\t\t\t&& CharOperation.equals(this.binding.selector, TypeConstants.CLONE)) {", "+\t\tthis.resolvedType = this.actualReceiverType;", "-\tif (receiver.isSuper() && compilerOptions.getSeverity(CompilerOptions.OverridingMethodWithoutSuperInvocation) != ProblemSeverities.Ignore) {", "+\tif (this.receiver.isSuper() && compilerOptions.getSeverity(CompilerOptions.OverridingMethodWithoutSuperInvocation) != ProblemSeverities.Ignore) {"]}], "num": 41542}