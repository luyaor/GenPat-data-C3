{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9c0f5429ff32da21da8da75db9e0ac40", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0b242c8faa039db342a08a2423c7b485", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "70416b46b1375461a92d89ffa1cb077778dc6e86", "commitAfterChange": "0c53505dd9d8f221929a96f99e04ff55bfc4fc05", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 30, "signatureBeforeChange": " \t \tpublic char[] findSource(ClassFile classFile)", "signatureAfterChange": " \tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException", "diff": ["+\t */", "+\tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException {", "+\t\tMatchingNodeSet matchingNodeSet = null;", "+\t\ttry {", "+\t\t\tthis.currentPotentialMatch = this.matchesToProcess[i];", "+\t\t\tif (this.currentPotentialMatch == null) return;", "+\t\t\tmatchingNodeSet = this.currentPotentialMatch.matchingNodeSet;", "+\t\t\t", "+\t\t\tif (unit == null || unit.isEmpty()) {", "+\t\t\t\tif (this.currentPotentialMatch.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {", "+\t\t\t\t\tthis.currentPotentialMatch.locateMatchesInClassFile();", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (hasAlreadyDefinedType(unit)) {", "+\t\t\t\t// skip type has it is hidden so not visible", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tthis.parser.matchSet = this.currentPotentialMatch.matchingNodeSet;", "+\t\t\tgetMethodBodies(unit, i);", "+\t\t\t\t\t\t", "+\t\t\t// report matches that don't need resolve", "+\t\t\tmatchingNodeSet.cuHasBeenResolved = this.compilationAborted;", "+\t\t\tmatchingNodeSet.reportMatching(unit);", "+", "+\t\t\tif ((this.pattern.needsResolve || matchingNodeSet.needsResolve()/* TODO: do not need this check any longer */) ", "+\t\t\t\t\t&& unit.types != null ", "+\t\t\t\t\t&& !this.compilationAborted) {", "+", "+\t\t\t\tif (SearchEngine.VERBOSE) {", "+\t\t\t\t\tSystem.out.println(\"Resolving \" + this.currentPotentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t}", "+", "+\t\t\t\t// fault in fields & methods", "+\t\t\t\tif (unit.scope != null)", "+\t\t\t\t\tunit.scope.faultInTypes();", "+\t\t", "+\t\t\t\t// verify inherited methods", "+\t\t\t\tif (unit.scope != null)", "+\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "+\t\t", "+\t\t\t\t// type checking", "+\t\t\t\tunit.resolve();", "+\t\t", "+\t\t\t\t// refresh the total number of units known at this stage", "+\t\t\t\tunit.compilationResult.totalUnitsKnown = totalUnits;", "+", "+\t\t\t\t// report matches that needed resolve", "+\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "+\t\t\t\tmatchingNodeSet.reportMatching(unit);", "+\t\t\t}", "+\t\t} catch (AbortCompilation e) {", "+\t\t\t// could not resolve: report innacurate matches", "+\t\t\tif (matchingNodeSet != null) {", "+\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "+\t\t\t\tmatchingNodeSet.reportMatching(unit);", "+\t\t\t}", "+\t\t\tif (!(e instanceof AbortCompilationUnit)) {", "+\t\t\t\t// problem with class path", "+\t\t\t\tthrow e;", "+\t\t\t}", "+\t\t} finally {", "+\t\t\tthis.parser.matchSet = null;", "+\t\t\tthis.currentPotentialMatch = null;", "+\t\t}", "+\t}", "-\t", "-\tpublic char[] findSource(ClassFile classFile) {", "-\t\tchar[] source = null; ", "-\t\ttry {", "-\t\t\tSourceMapper sourceMapper = classFile.getSourceMapper();", "-\t\t\tif (sourceMapper != null) {", "-\t\t\t\tIType type = classFile.getType();", "-\t\t\t\tif (classFile.isOpen() && type.getDeclaringType() == null) {", "-\t\t\t\t\tsource = sourceMapper.findSource(type);", "-\t\t\t\t} else {", "-\t\t\t\t\tClassFileReader reader = this.classFileReader(type);", "-\t\t\t\t\tif (reader != null) {", "-\t\t\t\t\t\tString sourceFileName = sourceMapper.findSourceFileName(type, reader);", "-\t\t\t\t\t\tif (sourceFileName != null) {", "-\t\t\t\t\t\t\tsource = sourceMapper.findSource(type, sourceFileName);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} catch (JavaModelException e) {", "-\t\t}", "-\t\treturn source;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "695adbbe95115adc32347267cc541383", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException", "signatureAfterChange": " protected void process(PotentialMatch potentialMatch, boolean bindingsWereCreated) throws CoreException", "diff": ["-\t */", "-\tpublic void process(CompilationUnitDeclaration unit, int i) throws CoreException {", "-\t\tMatchingNodeSet matchingNodeSet = null;", "-\t\ttry {", "-\t\t\tthis.currentPotentialMatch = this.matchesToProcess[i];", "-\t\t\tif (this.currentPotentialMatch == null) return;", "-\t\t\tmatchingNodeSet = this.currentPotentialMatch.matchingNodeSet;", "-\t\t\t", "-\t\t\tif (unit == null || unit.isEmpty()) {", "-\t\t\t\tif (this.currentPotentialMatch.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {", "-\t\t\t\t\tthis.currentPotentialMatch.locateMatchesInClassFile();", "-\t\t\t\t}", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\tif (hasAlreadyDefinedType(unit)) {", "-\t\t\t\t// skip type has it is hidden so not visible", "-\t\t\t\treturn;", "-\t\t\t}", "-\t", "-\t\t\tthis.parser.matchSet = this.currentPotentialMatch.matchingNodeSet;", "-\t\t\tgetMethodBodies(unit, i);", "-\t\t\t\t\t\t", "-\t\t\t// report matches that don't need resolve", "-\t\t\tmatchingNodeSet.cuHasBeenResolved = this.compilationAborted;", "-\t\t\tmatchingNodeSet.reportMatching(unit);", "-", "-\t\t\tif (this.pattern.mustResolve ", "-\t\t\t\t\t&& unit.types != null ", "-\t\t\t\t\t&& !this.compilationAborted) {", "-", "-\t\t\t\tif (SearchEngine.VERBOSE) {", "-\t\t\t\t\tSystem.out.println(\"Resolving \" + this.currentPotentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "-\t\t\t\t}", "-", "-\t\t\t\t// fault in fields & methods", "-\t\t\t\tif (unit.scope != null)", "-\t\t\t\t\tunit.scope.faultInTypes();", "-\t\t", "-\t\t\t\t// verify inherited methods", "-\t\t\t\tif (unit.scope != null)", "-\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "-\t\t", "-\t\t\t\t// type checking", "-\t\t\t\tunit.resolve();", "-\t\t", "-\t\t\t\t// refresh the total number of units known at this stage", "-\t\t\t\tunit.compilationResult.totalUnitsKnown = totalUnits;", "-", "-\t\t\t\t// report matches that needed resolve", "-\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "-\t\t\t\tmatchingNodeSet.reportMatching(unit);", "-\t\t\t}", "-\t\t} catch (AbortCompilation e) {", "-\t\t\t// could not resolve: report innacurate matches", "-\t\t\tif (matchingNodeSet != null) {", "-\t\t\t\tmatchingNodeSet.cuHasBeenResolved = true;", "-\t\t\t\tmatchingNodeSet.reportMatching(unit);", "-\t\t\t}", "-\t\t\tif (!(e instanceof AbortCompilationUnit)) {", "-\t\t\t\t// problem with class path", "-\t\t\t\tthrow e;", "-\t\t\t}", "-\t\t} finally {", "-\t\t\tthis.parser.matchSet = null;", "-\t\t\tthis.currentPotentialMatch = null;", "+ */", "+protected void process(PotentialMatch potentialMatch, boolean bindingsWereCreated) throws CoreException {", "+\tthis.currentPotentialMatch = potentialMatch;", "+\tCompilationUnitDeclaration unit = potentialMatch.parsedUnit;", "+\tMatchingNodeSet matchingNodeSet = null;", "+\ttry {", "+\t\tif (unit.isEmpty()) {", "+\t\t\tif (this.currentPotentialMatch.openable instanceof ClassFile)", "+\t\t\t\tthis.currentPotentialMatch.locateMatchesInClassFile();", "+\t\t\treturn;", "-\t}", "+\t\tif (hasAlreadyDefinedType(unit)) return; // skip type has it is hidden so not visible", "+\t\tmatchingNodeSet = this.currentPotentialMatch.matchingNodeSet;", "+\t\tgetMethodBodies(unit, matchingNodeSet);", "+", "+\t\tif (bindingsWereCreated && this.pattern.mustResolve && unit.types != null) {", "+\t\t\tif (SearchEngine.VERBOSE)", "+\t\t\t\tSystem.out.println(\"Resolving \" + this.currentPotentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$", "+", "+\t\t\tmatchingNodeSet.reduceParseTree(unit);", "+", "+\t\t\tif (unit.scope != null)", "+\t\t\t\tunit.scope.faultInTypes(); // fault in fields & methods", "+\t\t\tunit.resolve();", "+", "+\t\t\tmatchingNodeSet.reportMatching(unit, true);", "+\t\t} else {", "+\t\t\tmatchingNodeSet.reportMatching(unit, this.pattern.mustResolve);", "+\t} catch (AbortCompilation e) {", "+\t\t// could not resolve: report innacurate matches", "+\t\tif (matchingNodeSet != null)", "+\t\t\tmatchingNodeSet.reportMatching(unit, true); // was partially resolved", "+\t\tif (!(e instanceof AbortCompilationUnit)) {", "+\t\t\t// problem with class path", "+\t\t\tthrow e;", "+\t\t}", "+\t} finally {", "+\t\tthis.currentPotentialMatch = null;", "+}"]}], "num": 32713}