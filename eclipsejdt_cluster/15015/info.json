{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "88573fc1a52c2c6742b0d43d65d0d8b6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33c4a58d03f672871a12a3eb9d1bb70f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic void generateOptimizedLogicalOr( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tBranchLabel trueLabel, \t\tBranchLabel falseLabel, \t\tboolean valueRequired)", "signatureAfterChange": " public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeStream, BranchLabel trueLabel, BranchLabel falseLabel, boolean valueRequired)", "diff": ["-\t */", "-\tpublic void generateOptimizedLogicalOr(", "-\t\tBlockScope currentScope,", "-\t\tCodeStream codeStream,", "-\t\tBranchLabel trueLabel,", "-\t\tBranchLabel falseLabel,", "-\t\tboolean valueRequired) {", "-\t\t\t", "-\t\tConstant condConst;", "-\t\tif ((left.implicitConversion & COMPILE_TYPE_MASK) == T_boolean) {", "-\t\t\tif ((condConst = left.optimizedBooleanConstant()) != Constant.NotAConstant) {", "-\t\t\t\tif (condConst.booleanValue() == true) {", "-\t\t\t\t\t// <something equivalent to true> | x", "-\t\t\t\t\tleft.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t\tBranchLabel internalFalseLabel = new BranchLabel(codeStream);", "-\t\t\t\t\tright.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tinternalFalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t\tinternalFalseLabel.place();", "-\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\tif (trueLabel != null) {", "-\t\t\t\t\t\t\tcodeStream.goto_(trueLabel);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\t// reposition the endPC", "-\t\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "-\t\t\t\t} else {", "-\t\t\t\t\t// <something equivalent to false> | x", "-\t\t\t\t\tleft.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t\tright.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t}", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\tif ((condConst = right.optimizedBooleanConstant()) != Constant.NotAConstant) {", "-\t\t\t\tif (condConst.booleanValue() == true) {", "-\t\t\t\t\t// x | <something equivalent to true>", "-\t\t\t\t\tBranchLabel internalFalseLabel = new BranchLabel(codeStream);", "-\t\t\t\t\tleft.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tinternalFalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t\tinternalFalseLabel.place();", "-\t\t\t\t\tright.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t\tif (valueRequired) {", "-\t\t\t\t\t\tif (trueLabel != null) {", "-\t\t\t\t\t\t\tcodeStream.goto_(trueLabel);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\t// reposition the endPC", "-\t\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "-\t\t\t\t} else {", "-\t\t\t\t\t// x | <something equivalent to false>", "-\t\t\t\t\tleft.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tvalueRequired);", "-\t\t\t\t\tright.generateOptimizedBoolean(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcodeStream,", "-\t\t\t\t\t\ttrueLabel,", "-\t\t\t\t\t\tfalseLabel,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t}", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-\t\t// default case", "-\t\tleft.generateCode(currentScope, codeStream, valueRequired);", "-\t\tright.generateCode(currentScope, codeStream, valueRequired);", "-\t\tif (valueRequired) {", "-\t\t\tcodeStream.ior();", "-\t\t\tif (falseLabel == null) {", "-\t\t\t\tif (trueLabel != null) {", "-\t\t\t\t\t// implicit falling through the FALSE case", "-\t\t\t\t\tcodeStream.ifne(trueLabel);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// implicit falling through the TRUE case", "-\t\t\t\tif (trueLabel == null) {", "-\t\t\t\t\tcodeStream.ifeq(falseLabel);", "-\t\t\t\t} else {", "-\t\t\t\t\t// no implicit fall through TRUE/FALSE --> should never occur", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t// reposition the endPC", "-\t\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "-\t}", "+ */", "+public void generateOptimizedLogicalOr(BlockScope currentScope, CodeStream codeStream, BranchLabel trueLabel, BranchLabel falseLabel, boolean valueRequired) {", "+\tConstant condConst;", "+\tif ((this.left.implicitConversion & TypeIds.COMPILE_TYPE_MASK) == TypeIds.T_boolean) {", "+\t\tif ((condConst = this.left.optimizedBooleanConstant()) != Constant.NotAConstant) {", "+\t\t\tif (condConst.booleanValue() == true) {", "+\t\t\t\t// <something equivalent to true> | x", "+\t\t\t\tthis.left.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t\tBranchLabel internalFalseLabel = new BranchLabel(codeStream);", "+\t\t\t\tthis.right.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tinternalFalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t\tinternalFalseLabel.place();", "+\t\t\t\tif (valueRequired) {", "+\t\t\t\t\tif (trueLabel != null) {", "+\t\t\t\t\t\tcodeStream.goto_(trueLabel);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// reposition the endPC", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "+\t\t\t\t// <something equivalent to false> | x", "+\t\t\t\tthis.left.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t\tthis.right.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tvalueRequired);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t\tif ((condConst = this.right.optimizedBooleanConstant()) != Constant.NotAConstant) {", "+\t\t\tif (condConst.booleanValue() == true) {", "+\t\t\t\t// x | <something equivalent to true>", "+\t\t\t\tBranchLabel internalFalseLabel = new BranchLabel(codeStream);", "+\t\t\t\tthis.left.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tinternalFalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t\tinternalFalseLabel.place();", "+\t\t\t\tthis.right.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t\tif (valueRequired) {", "+\t\t\t\t\tif (trueLabel != null) {", "+\t\t\t\t\t\tcodeStream.goto_(trueLabel);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// reposition the endPC", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "+\t\t\t} else {", "+\t\t\t\t// x | <something equivalent to false>", "+\t\t\t\tthis.left.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tvalueRequired);", "+\t\t\t\tthis.right.generateOptimizedBoolean(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tcodeStream,", "+\t\t\t\t\ttrueLabel,", "+\t\t\t\t\tfalseLabel,", "+\t\t\t\t\tfalse);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t}", "+\t// default case", "+\tthis.left.generateCode(currentScope, codeStream, valueRequired);", "+\tthis.right.generateCode(currentScope, codeStream, valueRequired);", "+\tif (valueRequired) {", "+\t\tcodeStream.ior();", "+\t\tif (falseLabel == null) {", "+\t\t\tif (trueLabel != null) {", "+\t\t\t\t// implicit falling through the FALSE case", "+\t\t\t\tcodeStream.ifne(trueLabel);", "+\t\t\t// implicit falling through the TRUE case", "+\t\t\tif (trueLabel == null) {", "+\t\t\t\tcodeStream.ifeq(falseLabel);", "+\t\t\t} else {", "+\t\t\t\t// no implicit fall through TRUE/FALSE --> should never occur", "+\t\t\t}", "+\t// reposition the endPC", "+\tcodeStream.updateLastRecordedEndPC(currentScope, codeStream.position);\t\t\t\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f30d7883c0fccdc9491b0246105992c2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/compiler/ReconcileContext.java", "commitBeforeChange": "c1a19ba5a2ec5ff7020c56969301f2a78801c990", "commitAfterChange": "9e14a7ad0a6e3f6482ed519c4d45854b0211dde4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public org.eclipse.jdt.core.dom.CompilationUnit getAST(int astLevel, boolean resolveBindings) throws JavaModelException", "signatureAfterChange": " public org.eclipse.jdt.core.dom.CompilationUnit getAST(int astLevel, boolean resolveBindings) throws JavaModelException", "diff": ["-// TODO do we really want individual astLevel for participants ? or should they implicitly get the one from ongoing reconcile operation ?", "-\tif (this.operation.astLevel < astLevel) {", "-\t\tthis.operation.astLevel = astLevel;", "-\t\tthis.operation.ast = null; // force the AST to be re-created since the ast level was insufficient the first time", "+\tif (this.operation.astLevel != astLevel || !this.operation.resolveBindings & resolveBindings) {", "+\t\t// create AST (optionally resolving bindings)", "+\t\tASTParser parser = ASTParser.newParser(astLevel);", "+\t\tparser.setCompilerOptions(workingCopy.getJavaProject().getOptions(true));", "+\t\tif (resolveBindings && JavaProject.hasJavaNature(workingCopy.getJavaProject().getProject()))", "+\t\t\tparser.setResolveBindings(true);", "+\t\tparser.setSource(workingCopy);", "+\t\treturn (org.eclipse.jdt.core.dom.CompilationUnit) parser.createAST(this.operation.progressMonitor);\t\t", "-\tif (!this.operation.resolveBindings & resolveBindings) {", "-\t\tthis.operation.resolveBindings = true;", "-\t\tthis.operation.ast = null; // force the AST to be re-created since bindings were not computed the first time", "-\t}", "-\torg.eclipse.jdt.core.dom.CompilationUnit result = this.operation.makeConsistent(this.workingCopy, null/*don't report problems to the working copy's problem requestor*/);", "-\tif (result == null)", "-\t\tresult = this.operation.createAST(this.workingCopy);", "-\treturn result;", "+\treturn this.operation.makeConsistent(this.workingCopy, null/*don't report problems to the working copy's problem requestor*/);", "+}"]}], "num": 15015}