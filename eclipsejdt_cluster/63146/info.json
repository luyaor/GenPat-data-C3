{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4824fb551ccaa39efb4f6292fdc39d2a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "21e99b1716cb72802bb336a2699c190c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "45c680054b27b9c98f10c88da800e79c9dec8528", "commitAfterChange": "1d817cf86d6dbfa3bc80c59d0139cb561aace8b1", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic void generateOptimizedStringConcatenationCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "signatureAfterChange": " \tpublic void generateOptimizedStringConcatenationCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "diff": ["-\t\t// Optimization only for integers and strings", "-\t\tif (typeID == T_JavaLangObject) {", "-\t\t\t// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)", "-\t\t\t// append(Object) returns append(valueOf(Object)), which means that the null case is handled by append(String).", "-\t\t\tcodeStream.newStringContatenation();", "-\t\t\tcodeStream.dup();", "-\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\tgenerateCode(blockScope, codeStream, true);", "-\t\t\tcodeStream.invokeStringConcatenationAppendForType(T_JavaLangObject);", "-\t\t\treturn;", "-\t\t}", "-\t\tif (typeID == T_JavaLangString || typeID == T_null) {", "-\t\t\tif (constant != NotAConstant) {", "-\t\t\t\tString stringValue = constant.stringValue();", "-\t\t\t\tif (stringValue.length() == 0) {  // optimize \"\"+<str> ", "-\t\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\tcodeStream.ldc(stringValue);", "-\t\t\t} else {", "+\t\tswitch (typeID) {", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\t// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)", "+\t\t\t\t// append(Object) returns append(valueOf(Object)), which means that the null case is handled by append(String).", "+\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "-\t\t\t\tcodeStream.invokeStringValueOf(T_JavaLangObject);", "-\t\t\t}", "-\t\t} else {", "-\t\t\tgenerateCode(blockScope, codeStream, true);", "-\t\t\tcodeStream.invokeStringValueOf(typeID);", "+\t\t\t\tcodeStream.invokeStringConcatenationAppendForType(T_JavaLangObject);", "+\t\t\t\treturn;", "+", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_null :", "+\t\t\t\tif (constant != NotAConstant) {", "+\t\t\t\t\tString stringValue = constant.stringValue();", "+\t\t\t\t\tif (stringValue.length() == 0) {  // optimize \"\"+<str> ", "+\t\t\t\t\t\tcodeStream.invokeStringConcatenationDefaultConstructor();", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tcodeStream.ldc(stringValue);", "+\t\t\t\t} else {", "+\t\t\t\t\tgenerateCode(blockScope, codeStream, true);", "+\t\t\t\t\tcodeStream.invokeStringValueOf(T_JavaLangObject);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\tdefault :", "+\t\t\t\tgenerateCode(blockScope, codeStream, true);", "+\t\t\t\tcodeStream.invokeStringValueOf(typeID);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b34c7aec2438848b6913943797c30626", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "de542d47e7857076ff550f4560e517bc0773f2ce", "commitAfterChange": "29901dd2faebfaef1b4d98d076ffc43db80ce6e9", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "signatureAfterChange": " \tpublic void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, MethodBinding writeAccessor, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-\t\tif ((operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString || operationTypeID == T_JavaLangObject) {", "-\t\t\t// we enter here if the single name reference is a field of type java.lang.String or if the type of the ", "-\t\t\t// operation is java.lang.Object", "-\t\t\t// For example: o = o + \"\"; // where the compiled type of o is java.lang.Object.", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t\t// no need for generic cast on previous #getfield since using Object string buffer methods.\t\t\t", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);\t\t\t", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}\t\t", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t\tswitch(operationTypeID = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "+\t\t\tcase T_JavaLangString :", "+\t\t\tcase T_JavaLangObject :", "+\t\t\tcase T_undefined :", "+\t\t\t\t// we enter here if the single name reference is a field of type java.lang.String or if the type of the ", "+\t\t\t\t// operation is java.lang.Object", "+\t\t\t\t// For example: o = o + \"\"; // where the compiled type of o is java.lang.Object.", "+\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t\t\t\t// no need for generic cast on previous #getfield since using Object string buffer methods.\t\t\t", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\t// promote the array reference to the suitable operation type", "+\t\t\t\tcodeStream.generateImplicitConversion(implicitConversion);", "+\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\t\t\tif (expression == IntLiteral.One){ // prefix operation", "+\t\t\t\t\tcodeStream.generateConstant(expression.constant, implicitConversion);\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t\t\t}\t\t", "+\t\t\t\t// perform the operation", "+\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t\t\t// cast the value back to the array reference type", "+\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);"]}], "num": 63146}