{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "189d5281fb05cc19d46cca7002a6c6d8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16e3cc24e0078303e540f9f5f179dc37", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "1585d95aacd546d0fef8e25ddee2f5a6f64f7c62", "commitAfterChange": "bcf6d39cea27ed7bf3bf85709bd7e60dc5605058", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t\targumentCompatibility: {", "-\t\t\tint lastIndex = argLength;", "-\t\t\tif (isVarArgs) {", "-\t\t\t\tlastIndex = paramLength - 1;", "-\t\t\t\tif (paramLength == argLength) { // accept both X and X[] but not X[][]", "-\t\t\t\t\tTypeBinding varArgType = parameters[lastIndex]; // is an ArrayBinding by definition", "-\t\t\t\t\tTypeBinding lastArgument = arguments[lastIndex];", "-\t\t\t\t\tif (varArgType != lastArgument && !lastArgument.isCompatibleWith(varArgType)) {", "-\t\t\t\t\t\t// expect X[], called with X", "-\t\t\t\t\t\tvarArgType = ((ArrayBinding) varArgType).elementsType();", "-\t\t\t\t\t\tif (!lastArgument.isCompatibleWith(varArgType))", "-\t\t\t\t\t\t\tbreak argumentCompatibility;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType", "-\t\t\t\t\tTypeBinding varArgType = ((ArrayBinding) parameters[lastIndex]).elementsType();", "-\t\t\t\t\tfor (int i = lastIndex; i < argLength; i++)", "-\t\t\t\t\t\tif (varArgType != arguments[i] && !arguments[i].isCompatibleWith(varArgType))", "-\t\t\t\t\t\t\tbreak argumentCompatibility;", "-\t\t\t\t} else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();", "-\t\t\t\t\tbreak argumentCompatibility;", "-\t\t\t\t}", "-\t\t\t\t// now compare standard arguments from 0 to lastIndex", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < lastIndex; i++)", "-\t\t\t\tif (parameters[i] != arguments[i] && !arguments[i].isCompatibleWith(parameters[i]))", "-\t\t\t\t\tbreak argumentCompatibility;", "-\t\t\treturn method; // compatible", "-\t\t}", "+\t\tif (parameterCompatibilityLevel(method, arguments) > NOT_COMPATIBLE)", "+\t\t\treturn method;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c367e74cdc322ae7ed0d0b0b289c5e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "55f4964943e2f63287728b29450cbefa492d313d", "commitAfterChange": "ffcfe0dac7f476f076089d3cdae600b5982efdfb", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t\tif (argLength != parameters.length)", "-\t\t\treturn null; // incompatible", "+\t\tint paramLength = parameters.length;", "+\t\tboolean varArgCase = method.isVararg();", "+\t\tif (argLength != paramLength)", "+\t\t\tif (!varArgCase || argLength < paramLength - 1)", "+\t\t\t\treturn null; // incompatible", "-\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod); // attempt to invoke generic method of raw type with type hints <String>foo()", "+\t\t\t\t\t// attempt to invoke generic method of raw type with type hints <String>foo()", "+\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod);", "-\t\t", "+", "-\t\t\tfor (int i = 0; i < argLength; i++)", "+\t\t\tint lastIndex = argLength;", "+\t\t\tif (varArgCase) {", "+\t\t\t\tlastIndex = paramLength - 1;", "+\t\t\t\tif (paramLength == argLength) { // accept both X and X[] but not X[][]", "+\t\t\t\t\tTypeBinding varArgType = parameters[lastIndex]; // is an ArrayBinding by definition", "+\t\t\t\t\tint varArgDimension = varArgType.dimensions();", "+\t\t\t\t\tTypeBinding lastArgument = arguments[lastIndex];", "+\t\t\t\t\tint lastArgDimensions = lastArgument.dimensions();", "+\t\t\t\t\tif (varArgDimension == lastArgDimensions || varArgDimension - 1 == lastArgDimensions) {", "+\t\t\t\t\t\tvarArgType = varArgType.leafComponentType();", "+\t\t\t\t\t\tlastArgument = lastArgument.leafComponentType();", "+\t\t\t\t\t\tif (varArgType != lastArgument && !lastArgument.isCompatibleWith(varArgType))", "+\t\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t\t} else { // dimensions are not compatible", "+\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType", "+\t\t\t\t\tTypeBinding varArgType = ((ArrayBinding) parameters[lastIndex]).elementsType();", "+\t\t\t\t\tfor (int i = lastIndex; i < argLength; i++)", "+\t\t\t\t\t\tif (varArgType != arguments[i] && !arguments[i].isCompatibleWith(varArgType))", "+\t\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t} else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();", "+\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t}", "+\t\t\t\t// now compare standard arguments from 0 to lastIndex", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < lastIndex; i++)", "-\t\tif (genericTypeArguments != null) {", "+\t\tif (genericTypeArguments != null)", "-\t\t}"]}], "num": 15052}