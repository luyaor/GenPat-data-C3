{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "433aaf906579d28dded812bf676da868", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7db0f0b7bfae0567cf76d1811cda76fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor2.java", "commitBeforeChange": "74d059b3fbdc00070c70bee76509a44ccad7fb4d", "commitAfterChange": "31d2b0bac7c9b032f1ad8765fd4577eaff8d79fd", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 53, "signatureBeforeChange": "  \tpublic boolean visit(InfixExpression node)", "signatureAfterChange": "  \tpublic boolean visit(InfixExpression node)", "diff": ["-\t\t// TODO Auto-generated method stub", "-\t\treturn super.visit(node);", "+\t\t// active line wrapping", "+\t\tfinal InfixExpressionWrappingBuilder builder = new InfixExpressionWrappingBuilder();", "+\t\tnode.accept(builder);", "+\t\tfinal int fragmentsSize = builder.getFragmentsCounter();", "+\t\tthis.scribe.printComment();", "+\t\tAlignment2 binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$", "+\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\tboolean ok = false;", "+\t\tList fragments = builder.fragments;", "+\t\tint[] operators = builder.getOperators();", "+/*\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfinal boolean alignAfterOperator = false;", "+\t\t\t\tif (alignAfterOperator) {", "+\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t// a new line has been inserted by printTrailingComment()", "+\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, 0);", "+\t\t\t\t\t((Expression) fragments.get(0)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int i = 1; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\tthis.scribe.printNextToken(operators[i - 1], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[fragmentsSize - 2], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif (operators[fragmentsSize - 2] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);*/", "+\t\tdo {", "+\t\t\ttry {", "+\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "+\t\t\t\t\t((Expression) fragments.get(i)).accept(this);", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t\t\t|| (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t((Expression) fragments.get(fragmentsSize - 1)).accept(this);", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\tif (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {", "+\t\t\t\t\t\tbinaryExpressionAlignment.performFragmentEffect();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tok = true;", "+\t\t\t} catch(AlignmentException e){", "+\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t}", "+\t\t} while (!ok);\t\t", "+\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);\t\t", "+/*\t\t\tleftOperand.accept(this);", "+\t\t\tfinal int operator = extractInfixExpressionOperator(node);", "+\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "+\t\t\tif ( this.preferences.insert_space_after_binary_operator", "+\t\t\t\t\t|| (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {", "+\t\t\t\t// the next character is a minus (unary operator) or the preference is set to true", "+\t\t\t\tthis.scribe.space();", "+\t\t\t}", "+\t\t\trightOperand.accept(this);*/", "+\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c200736346bc38b9dee43e032362a104", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "signatureAfterChange": "  \tprivate boolean dumpBinaryExpression( \t\tBinaryExpression binaryExpression, \t\tint operator, \t\tBlockScope scope)", "diff": ["-\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "-\t\t\tthis.scribe.printComment();", "-\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "-\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "-\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "-\t\t\t\t\tAlignment.R_OUTERMOST,", "-\t\t\t\t\tfragmentsSize,", "-\t\t\t\t\tthis.scribe.scanner.currentPosition);", "-\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "-\t\t\tboolean ok = false;", "-\t\t\tASTNode[] fragments = builder.fragments();", "-\t\t\tint[] operators = builder.operators();", "-\t\t\tdo {", "-\t\t\t\ttry {", "-\t\t\t\t\tfor (int i = 0; i < fragmentsSize - 1; i++) {", "-\t\t\t\t\t\tASTNode fragment = fragments[i];", "-\t\t\t\t\t\tfragment.traverse(this, scope);", "-\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "-\t\t\t\t\t\t\t// a new line has been inserted by printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT)", "-\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "-\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\t\t\t\tthis.scribe.space();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tfragments[fragmentsSize - 1].traverse(this, scope);", "-\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "-\t\t\t\t\tok = true;", "-\t\t\t\t} catch(AlignmentException e){", "-\t\t\t\t\tthis.scribe.redoAlignment(e);", "-\t\t\t\t}", "-\t\t\t} while (!ok);", "-\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\tif (this.expressionsDepth < 0) {", "+\t\t\tthis.expressionsDepth = 0;", "-\t\t\tbinaryExpression.left.traverse(this, scope);", "-\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);", "-\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "-\t\t\t\t// the next character is a minus (unary operator)", "-\t\t\t\tthis.scribe.space();", "+\t\t\tthis.expressionsDepth++;", "+\t\t\tthis.expressionsPos <<= 2;", "+\t\t}", "+\t\ttry {", "+\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\tif ((builder.realFragmentsSize() > 1 || fragmentsSize > 4) && numberOfParens == 0) {", "+\t\t\t\tint scribeLine = this.scribe.line;", "+\t\t\t\tthis.scribe.printComment();", "+\t\t\t\tAlignment binaryExpressionAlignment = this.scribe.createAlignment(", "+\t\t\t\t\t\tAlignment.BINARY_EXPRESSION,", "+\t\t\t\t\t\tthis.preferences.alignment_for_binary_expression,", "+\t\t\t\t\t\tAlignment.R_OUTERMOST,", "+\t\t\t\t\t\tfragmentsSize,", "+\t\t\t\t\t\tthis.scribe.scanner.currentPosition);", "+\t\t\t\tthis.scribe.enterAlignment(binaryExpressionAlignment);", "+\t\t\t\tboolean ok = false;", "+\t\t\t\tASTNode[] fragments = builder.fragments();", "+\t\t\t\tint[] operators = builder.operators();", "+\t\t\t\tdo {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tfinal int max = fragmentsSize - 1;", "+\t\t\t\t\t\tfor (int i = 0; i < max; i++) {", "+\t\t\t\t\t\t\tASTNode fragment = fragments[i];", "+\t\t\t\t\t\t\tfragment.traverse(this, scope);", "+\t\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\t\tif (this.scribe.lastNumberOfNewLines == 1) {", "+\t\t\t\t\t\t\t\t// a new line has been inserted while printing the comment", "+\t\t\t\t\t\t\t\t// hence we need to use the break indentation level before printing next token...", "+\t\t\t\t\t\t\t\tthis.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.wrap_before_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthis.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);", "+\t\t\t\t\t\t\t\tthis.scribe.alignFragment(binaryExpressionAlignment, i);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfragments[max].traverse(this, scope);", "+\t\t\t\t\t\tthis.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);", "+\t\t\t\t\t\tok = true;", "+\t\t\t\t\t} catch(AlignmentException e){", "+\t\t\t\t\t\tthis.scribe.redoAlignment(e);", "+\t\t\t\t\t}", "+\t\t\t\t} while (!ok);", "+\t\t\t\tthis.scribe.exitAlignment(binaryExpressionAlignment, true);", "+\t\t\t\tif (this.scribe.line == scribeLine) {", "+\t\t\t\t\t// The expression was not broken => reset last break indentation", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = binaryExpressionAlignment.breakIndentationLevel;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_ENTER_TWO;", "+\t\t\t\tbinaryExpression.left.traverse(this, scope);", "+\t\t\t\tthis.expressionsPos &= ~EXPRESSIONS_POS_MASK;", "+\t\t\t\tthis.expressionsPos |= EXPRESSIONS_POS_BETWEEN_TWO;", "+\t\t\t\tthis.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator, Scribe.PRESERVE_EMPTY_LINES_IN_BINARY_EXPRESSION);", "+\t\t\t\tif (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {", "+\t\t\t\t\t// the next character is a minus (unary operator)", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tbinaryExpression.right.traverse(this, scope);", "-\t\t\tif (this.preferences.insert_space_after_binary_operator) {", "-\t\t\t\tthis.scribe.space();", "+\t\t}", "+\t\tfinally {", "+\t\t\tthis.expressionsDepth--;", "+\t\t\tthis.expressionsPos >>= 2;", "+\t\t\tif (this.expressionsDepth < 0) {", "+\t\t\t\tthis.lastBinaryExpressionAlignmentBreakIndentation = 0;", "-\t\t\tbinaryExpression.right.traverse(this, scope);"]}], "num": 59575}