{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "89b7d50c6a7e78fdae6bb69ea232e4a8", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4f658a8226da282521a995747709748", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java", "commitBeforeChange": "40ad9904e939ba54abece52421044021edd6e1c0", "commitAfterChange": "8d45cb26fc5ad244f93e8632d761d46ad4a120cf", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tpublic static LocalVariableBinding getTrackerForCloseCall(ASTNode invocationSite)", "signatureAfterChange": " \tprivate static FakedTrackingVariable findCloseTracker(BlockScope scope, FlowInfo flowInfo, Expression arg)", "diff": ["-\t/** if 'invocationSite' is a call to close() that has a registered tracking variable, answer that variable's binding. */", "-\tpublic static LocalVariableBinding getTrackerForCloseCall(ASTNode invocationSite) {", "-\t\tif (invocationSite instanceof MessageSend) {", "-\t\t\tMessageSend send = (MessageSend) invocationSite;", "-\t\t\tif (CharOperation.equals(TypeConstants.CLOSE, send.selector) && send.receiver instanceof SingleNameReference) {", "-\t\t\t\tBinding receiverBinding = ((SingleNameReference)send.receiver).binding;", "-\t\t\t\tif (receiverBinding instanceof LocalVariableBinding) {", "-\t\t\t\t\tFakedTrackingVariable trackingVariable = ((LocalVariableBinding)receiverBinding).closeTracker;", "-\t\t\t\t\tif (trackingVariable != null)", "-\t\t\t\t\t\treturn trackingVariable.binding;", "-\t\t\t\t}", "-\t\treturn null;", "+\t/** Find an existing tracking variable for the argument of an allocation for a resource wrapper. */", "+\tprivate static FakedTrackingVariable findCloseTracker(BlockScope scope, FlowInfo flowInfo, Expression arg)", "+\t{", "+\t\twhile (arg instanceof Assignment) {", "+\t\t\tAssignment assign = (Assignment)arg;", "+\t\t\tLocalVariableBinding innerLocal = assign.localVariableBinding();", "+\t\t\tif (innerLocal != null) {", "+\t\t\t\t// nested assignment has already been processed", "+\t\t\t\treturn innerLocal.closeTracker;", "+\t\t\t} else {", "+\t\t\t\targ = assign.expression; // unwrap assignment and fall through", "+\t\t\t}", "+\t\t}", "+\t\tif (arg instanceof SingleNameReference) {", "+\t\t\t// is allocation arg a reference to an existing closeable?", "+\t\t\tLocalVariableBinding local = arg.localVariableBinding();", "+\t\t\tif (local != null) {", "+\t\t\t\treturn local.closeTracker;", "+\t\t\t}", "+\t\t} else if (arg instanceof AllocationExpression) {", "+\t\t\t// nested allocation", "+\t\t\treturn ((AllocationExpression)arg).closeTracker;", "+\t\t}", "+\t\treturn null; // not a tracked expression"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0e8a74a99a62782558596a99cf63c3f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "bca01eadc82a3abb71100149fcbedb07d33a04ad", "commitAfterChange": "a6f21a01110fe95a43760ec08fc8cc1e27e1c4bc", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic boolean isPolyExpression() throws UnsupportedOperationException", "signatureAfterChange": " \t \tpublic boolean isPolyExpression() throws UnsupportedOperationException", "diff": ["+\t\tif (!this.use18specifics)", "+\t\t\treturn false;", "+\t\t", "+\t\tif (this.originalValueIfTrueType == null || this.originalValueIfFalseType == null) // resolution error.", "+\t\t\treturn false;", "+\t\t", "+\t\tif (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE || this.originalValueIfFalseType.kind() == Binding.POLY_TYPE)", "+\t\t\treturn true;", "+\t\t", "-\t\tTypeBinding opType = this.valueIfTrue.resolvedType;", "-\t\tif (opType != null && opType.id != TypeIds.T_null) {", "-\t\t\tif (opType.isBaseType() || (opType.id >= TypeIds.T_JavaLangByte && opType.id <= TypeIds.T_JavaLangBoolean))", "+\t\tif (this.originalValueIfTrueType.isBaseType() || (this.originalValueIfTrueType.id >= TypeIds.T_JavaLangByte && this.originalValueIfTrueType.id <= TypeIds.T_JavaLangBoolean)) {", "+\t\t\tif (this.originalValueIfFalseType.isBaseType() || (this.originalValueIfFalseType.id >= TypeIds.T_JavaLangByte && this.originalValueIfFalseType.id <= TypeIds.T_JavaLangBoolean))", "-\t\topType = this.valueIfFalse.resolvedType;", "-\t\tif (opType != null && opType.id != TypeIds.T_null) {", "-\t\t\tif (opType.isBaseType() || (opType.id >= TypeIds.T_JavaLangByte && opType.id <= TypeIds.T_JavaLangBoolean))", "-\t\t\t\treturn false;", "-\t\t}", "-", "+\t\t", "+\t\t// clause around generic method's return type prior to instantiation needs double check. "]}], "num": 49503}