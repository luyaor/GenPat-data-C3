{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "514945725d190890104810b5b5bdde70", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "677fad5293edad26b37f0cb1d7de4081", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " public MethodBinding getExactConstructor(TypeBinding[] argumentTypes)", "signatureAfterChange": " public MethodBinding getExactConstructor(TypeBinding[] argumentTypes)", "diff": ["-", "-\tif ((tagBits & TagBits.AreMethodsComplete) != 0) { // have resolved all arg types & return type of the methods", "-\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "-\t\t\tMethodBinding method = methods[m];", "-\t\t\tif (method.selector == TypeConstants.INIT && method.parameters.length == argCount) {", "-\t\t\t\tTypeBinding[] toMatch = method.parameters;", "-\t\t\t\tfor (int p = 0; p < argCount; p++)", "-\t\t\t\t\tif (toMatch[p] != argumentTypes[p])", "-\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\treturn method;", "-\t\t\t}", "-\t\t}", "-\t} else {", "-\t\tMethodBinding[] constructors = getMethods(TypeConstants.INIT); // takes care of duplicates & default abstract methods", "-\t\tnextConstructor : for (int c = constructors.length; --c >= 0;) {", "-\t\t\tMethodBinding constructor = constructors[c];", "-\t\t\tTypeBinding[] toMatch = constructor.parameters;", "-\t\t\tif (toMatch.length == argCount) {", "-\t\t\t\tfor (int p = 0; p < argCount; p++)", "-\t\t\t\t\tif (toMatch[p] != argumentTypes[p])", "-\t\t\t\t\t\tcontinue nextConstructor;", "-\t\t\t\treturn constructor;", "-\t\t\t}", "-\t\t}", "-\t}", "-\treturn null;", "-}", "+\tif ((this.tagBits & TagBits.AreMethodsComplete) != 0) { // have resolved all arg types & return type of the methods", "+\t\tlong range;", "+\t\tif ((range = ReferenceBinding.binarySearch(TypeConstants.INIT, this.methods)) >= 0) {", "+\t\t\tnextMethod: for (int imethod = (int)range, end = (int)(range >> 32); imethod <= end; imethod++) {", "+\t\t\t\tMethodBinding method = this.methods[imethod];\t\t\t", "+\t\t\t\t\tfor (int iarg = 0; iarg < argCount; iarg++)", "+\t\t\t\t\t\tif (toMatch[iarg] != argumentTypes[iarg])", "+\t\t// lazily sort methods", "+\t\tif ((this.tagBits & TagBits.AreMethodsSorted) == 0) {", "+\t\t\tint length = this.methods.length;", "+\t\t\tif (length > 1) \tReferenceBinding.sortMethods(this.methods, 0, length - 1);", "+\t\t\tthis.tagBits |= TagBits.AreMethodsSorted;", "+\t\t}\t\t", "+\t\tlong range;", "+\t\tif ((range = ReferenceBinding.binarySearch(TypeConstants.INIT, this.methods)) >= 0) {", "+\t\t\tnextMethod: for (int imethod = (int)range, end = (int)(range >> 32); imethod <= end; imethod++) {", "+\t\t\t\tMethodBinding method = this.methods[imethod];", "+\t\t\t\tif (resolveTypesFor(method) == null || method.returnType == null) {", "+\t\t\t\t\tmethods();", "+\t\t\t\t\treturn getExactConstructor(argumentTypes);  // try again since the problem methods have been removed", "+\t\t\t\t}", "+\t\t\t\tif (method.parameters.length == argCount) {", "+\t\t\t\t\tTypeBinding[] toMatch = method.parameters;", "+\t\t\t\t\tfor (int iarg = 0; iarg < argCount; iarg++)", "+\t\t\t\t\t\tif (toMatch[iarg] != argumentTypes[iarg])", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\treturn method;", "+\t\t\t\t}", "+\t\t}", "+\t}\t", "+\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2d72d46bf8121ee14c7b6dbacf74b7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " public MethodBinding getExactMethod(char[] selector, TypeBinding[] argumentTypes, CompilationUnitScope refScope)", "signatureAfterChange": " public MethodBinding getExactMethod(char[] selector, TypeBinding[] argumentTypes, CompilationUnitScope refScope)", "diff": ["-// searches up the hierarchy as long as no potential (but not exact) match was found.", "-public MethodBinding getExactMethod(char[] selector, TypeBinding[] argumentTypes, CompilationUnitScope refScope) {", "-\t// sender from refScope calls recordTypeReference(this)", "-\tint argCount = argumentTypes.length;", "-\tint selectorLength = selector.length;", "-\tboolean foundNothing = true;", "-", "-\tif ((tagBits & TagBits.AreMethodsComplete) != 0) { // have resolved all arg types & return type of the methods", "-\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "-\t\t\tMethodBinding method = methods[m];", "-\t\t\tif (method.selector.length == selectorLength && CharOperation.equals(method.selector, selector)) {", "-\t\t\t\tfoundNothing = false; // inner type lookups must know that a method with this name exists", "-\t\t\t\t\tfor (int p = 0; p < argCount; p++)", "-\t\t\t\t\t\tif (toMatch[p] != argumentTypes[p])", "-\t\tMethodBinding[] matchingMethods = getMethods(selector); // takes care of duplicates & default abstract methods", "-\t\tfoundNothing = matchingMethods == Binding.NO_METHODS;", "-\t\tnextMethod : for (int m = matchingMethods.length; --m >= 0;) {", "-\t\t\tMethodBinding method = matchingMethods[m];", "-\t\t\tTypeBinding[] toMatch = method.parameters;", "-\t\t\tif (toMatch.length == argCount) {", "-\t\t\t\tfor (int p = 0; p < argCount; p++)", "-\t\t\t\t\tif (toMatch[p] != argumentTypes[p])", "-\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\treturn method;", "+//searches up the hierarchy as long as no potential (but not exact) match was found.", "+public MethodBinding getExactMethod(char[] selector, TypeBinding[] argumentTypes, CompilationUnitScope refScope) {", "+\t// sender from refScope calls recordTypeReference(this)", "+\tint argCount = argumentTypes.length;", "+\tboolean foundNothing = true;", "+", "+\tif ((this.tagBits & TagBits.AreMethodsComplete) != 0) { // have resolved all arg types & return type of the methods", "+\t\tlong range;", "+\t\tif ((range = ReferenceBinding.binarySearch(selector, this.methods)) >= 0) {", "+\t\t\tnextMethod: for (int imethod = (int)range, end = (int)(range >> 32); imethod <= end; imethod++) {", "+\t\t\t\tMethodBinding method = this.methods[imethod];\t\t\t", "+\t\t\t\tfoundNothing = false; // inner type lookups must know that a method with this name exists", "+\t\t\t\tif (method.parameters.length == argCount) {", "+\t\t\t\t\tTypeBinding[] toMatch = method.parameters;", "+\t\t\t\t\tfor (int iarg = 0; iarg < argCount; iarg++)", "+\t\t\t\t\t\tif (toMatch[iarg] != argumentTypes[iarg])", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\treturn method;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t} else {", "+\t\t// lazily sort methods", "+\t\tif ((this.tagBits & TagBits.AreMethodsSorted) == 0) {", "+\t\t\tint length = this.methods.length;", "+\t\t\tif (length > 1) \tReferenceBinding.sortMethods(this.methods, 0, length - 1);", "+\t\t\tthis.tagBits |= TagBits.AreMethodsSorted;", "+\t\t}", "+\t\t", "+\t\tlong range;", "+\t\tif ((range = ReferenceBinding.binarySearch(selector, this.methods)) >= 0) {", "+\t\t\t// check unresolved method", "+\t\t\tint start = (int) range, end = (int) (range >> 32);", "+\t\t\tfor (int imethod = start; imethod <= end; imethod++) {", "+\t\t\t\tMethodBinding method = this.methods[imethod];\t\t\t", "+\t\t\t\tif (resolveTypesFor(method) == null || method.returnType == null) {", "+\t\t\t\t\tmethods();", "+\t\t\t\t\treturn getExactMethod(selector, argumentTypes, refScope); // try again since the problem methods have been removed", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// check dup collisions", "+\t\t\tboolean isSource15 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\t\tfor (int i = start; i <= end; i++) {", "+\t\t\t\tMethodBinding method1 = this.methods[i];", "+\t\t\t\tfor (int j = end; j > i; j--) {", "+\t\t\t\t\tMethodBinding method2 = this.methods[j];", "+\t\t\t\t\tboolean paramsMatch = isSource15", "+\t\t\t\t\t\t? method1.areParameterErasuresEqual(method2)", "+\t\t\t\t\t\t: method1.areParametersEqual(method2);", "+\t\t\t\t\tif (paramsMatch) {", "+\t\t\t\t\t\tmethods();", "+\t\t\t\t\t\treturn getExactMethod(selector, argumentTypes, refScope); // try again since the problem methods have been removed", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tnextMethod: for (int imethod = start; imethod <= end; imethod++) {", "+\t\t\t\tMethodBinding method = this.methods[imethod];\t\t\t\t\t\t", "+\t\t\t\tTypeBinding[] toMatch = method.parameters;", "+\t\t\t\tif (toMatch.length == argCount) {", "+\t\t\t\t\tfor (int iarg = 0; iarg < argCount; iarg++) {", "+\t\t\t\t\t\tif (toMatch[iarg] != argumentTypes[iarg]) {", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn method;", "+\t\t\t\t}", "+\t\t\t}\t\t\t\t", "-\t\t\t if (superInterfaces.length == 1) {", "+\t\t\t if (this.superInterfaces.length == 1) {", "-\t\t\t\t\trefScope.recordTypeReference(superInterfaces[0]);", "-\t\t\t\treturn superInterfaces[0].getExactMethod(selector, argumentTypes, refScope);", "+\t\t\t\t\trefScope.recordTypeReference(this.superInterfaces[0]);", "+\t\t\t\treturn this.superInterfaces[0].getExactMethod(selector, argumentTypes, refScope);", "-\t\t} else if (superclass != null) {", "+\t\t} else if (this.superclass != null) {", "-\t\t\t\trefScope.recordTypeReference(superclass);", "-\t\t\treturn superclass.getExactMethod(selector, argumentTypes, refScope);", "+\t\t\t\trefScope.recordTypeReference(this.superclass);", "+\t\t\treturn this.superclass.getExactMethod(selector, argumentTypes, refScope);"]}], "num": 67840}