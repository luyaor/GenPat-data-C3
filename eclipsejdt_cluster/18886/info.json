{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f299c428a1d93bbe2ce948770d8d5e1f", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60471210e126b3719f08515e52f23320", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "d35306cb5dcf7e4ac666fd0505f3086f50241fb2", "commitAfterChange": "3284f738bbf7a2dbd90434dea313c8629bed5722", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, final Scope someScope)", "diff": ["-\t\t\t\t\tthis.voidCompatible = ((Expression) this.body).statementExpression();", "-\t\t\t\t\t// TODO: in getResolvedCopyForInferenceTargeting() we need to check if the expression", "-\t\t\t\t\t//        *could* also produce a value and set valueCompatible accordingly.", "-\t\t\t\t\t//        Is that needed also here?", "+\t\t\t\t\tfinal Expression expressionBody = (Expression) this.body;", "+\t\t\t\t\tthis.voidCompatible = expressionBody.statementExpression();", "+\t\t\t\t\tthis.valueCompatible = expressionBody.resolvedType != TypeBinding.VOID;", "-\t\tif (!isPertinentToApplicability(left, null))  // This check should happen after return type check below, but for buggy javac compatibility we have left it in.", "-\t\t\treturn true;", "-", "+", "+\t\tif (!isPertinentToApplicability(left, null))", "+\t\t\treturn true;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f50dea3875ad08603344e8a53f3e3dd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 33, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\t\t\t\treturn !isPertinentToApplicability(left);", "+\t\t\t\t\treturn !isPertinentToApplicability(left, null);", "+\t\t\t\t\t// TODO: in getResolvedCopyForInferenceTargeting() we need to check if the expression", "+\t\t\t\t\t//        *could* also procude a value and set valueCompatible accordingly.", "+\t\t\t\t\t//        Is that needed also here?", "-\t\t\t\t\tif (!isPertinentToApplicability(left))", "+\t\t\t\t\tif (!isPertinentToApplicability(left, null))", "-\t\tif (!isPertinentToApplicability(left))  // This check should happen after return type check below, but for buggy javac compatibility we have left it in.", "+\t\tif (!isPertinentToApplicability(left, null))  // This check should happen after return type check below, but for buggy javac compatibility we have left it in.", "-\t\t\tExpression [] returnExpressions = this.resultExpressions;", "+\t\tExpression [] returnExpressions = this.resultExpressions;"]}], "num": 18886}