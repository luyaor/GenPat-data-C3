{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4bdced709877d9333ffbd25633b1a99d", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c828eb3ca5a93898d173376c2db4105", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4226b35883b85d7d8f258904527a118", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cef72aba261508321563b44993303142", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc3bb1ba75108847ac0b72ecc0d285d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}], "num": 9499}