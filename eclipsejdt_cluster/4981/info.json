{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "48ee352e6aa3ad5a8ab5caf1cf953a99", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39cd47642d8f4647797a78bf258c78d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java", "commitBeforeChange": "1c5e7e547be721f9ec87cd4dd76a42ec63ff0bb1", "commitAfterChange": "021e1bbe1df76f3c86c477a6dfa61edf287069ab", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-", "-\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "-\t\tif (index == null) return true;", "-\t\tReadWriteMonitor monitor = index.monitor;", "-\t\tif (monitor == null) return true; // index got deleted since acquired", "-", "+\t\t", "+\t\tReadWriteMonitor monitor = null;", "+\t\t\t// Get source folder entries. Libraries are done as a separate job", "+\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "+\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "+\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "+\t\t\tint length = entries.length;", "+\t\t\tIClasspathEntry[] sourceEntries = new IClasspathEntry[length];", "+\t\t\tint sourceEntriesNumber = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) ", "+\t\t\t\t\tsourceEntries[sourceEntriesNumber++] = entry;", "+\t\t\t}", "+\t\t\tif (sourceEntriesNumber == 0) ", "+\t\t\t\t// nothing to index", "+\t\t\t\t// also the project might be a library folder (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89815)", "+\t\t\t\treturn true;", "+\t\t\tif (sourceEntriesNumber != length)", "+\t\t\t\tSystem.arraycopy(sourceEntries, 0, sourceEntries = new IClasspathEntry[sourceEntriesNumber], 0, sourceEntriesNumber);", "+\t", "+\t\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\t\tif (index == null) return true;", "+\t\t\tmonitor = index.monitor;", "+\t\t\tif (monitor == null) return true; // index got deleted since acquired", "+\t\t\t", "-\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "-\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "-\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "-\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {", "+\t\t\tfor (int i = 0; i < sourceEntriesNumber; i++) {", "-\t\t\t\tIClasspathEntry entry = entries[i];", "-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) { // Index only source folders. Libraries are done as a separate job", "-\t\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "-\t\t\t\t\tif (sourceFolder != null) {", "-\t\t\t\t\t\t", "-\t\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "-\t\t\t\t\t\tfinal HashSet outputs = new HashSet();", "-\t\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "-\t\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "-\t\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "-\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\t\t\tIPath output = entries[j].getOutputLocation();", "-\t\t\t\t\t\t\t\tif (output != null) {", "-\t\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\tIClasspathEntry entry = sourceEntries[i];", "+\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "+\t\t\t\tif (sourceFolder != null) {", "+\t\t\t\t\t", "+\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "+\t\t\t\t\tfinal HashSet outputs = new HashSet();", "+\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "+\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "+\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "+\t\t\t\t\t\tfor (int j = 0; j < sourceEntriesNumber; j++) {", "+\t\t\t\t\t\t\tIPath output = sourceEntries[j].getOutputLocation();", "+\t\t\t\t\t\t\tif (output != null) {", "+\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "-\t\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "-\t\t\t\t\t\tif (max == 0) {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t}", "+\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "+\t\t\t\t\t", "+\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "+\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "+\t\t\t\t\tif (max == 0) {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "+\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "-\t\t\tfor (int i = 0, length = names.length; i < length; i++) {", "+\t\t\tfor (int i = 0, namesLength = names.length; i < namesLength; i++) {", "-\t\t\tmonitor.exitRead(); // free read lock", "+\t\t\tif (monitor != null)", "+\t\t\t\tmonitor.exitRead(); // free read lock"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a46abf14abd191d27dac86ca364e07ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java", "commitBeforeChange": "fdb8d62f1c901c375bd2aaf491776e68829346d4", "commitAfterChange": "abac83588fd8774146bd06b2319f52de11bc9846", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public static String[] concatWithClassLibs(String classpath, boolean inFront)", "signatureAfterChange": " public static String[] concatWithClassLibs(String[] classpaths, boolean inFront)", "diff": ["+public static String[] concatWithClassLibs(String[] classpaths, boolean inFront) {", "+\tString[] classLibs = getJavaClassLibs();", "+\tif (classpaths == null) return classLibs;", "+\tfinal int classLibsLength = classLibs.length;", "+\tfinal int classpathsLength = classpaths.length;", "+\tString[] defaultClassPaths = new String[classLibsLength + classpathsLength];", "+\tif (inFront) {", "+\t\tSystem.arraycopy(classLibs, 0, defaultClassPaths, classpathsLength, classLibsLength);", "+\t\tSystem.arraycopy(classpaths, 0, defaultClassPaths, 0, classpathsLength);", "+\t} else {", "+\t\tSystem.arraycopy(classLibs, 0, defaultClassPaths, 0, classLibsLength);", "+\t\tSystem.arraycopy(classpaths, 0, defaultClassPaths, classLibsLength, classpathsLength);", "+\t}", "+\tfor (int i = 0; i < classpathsLength; i++) {", "+\t\tFile file = new File(classpaths[i]);", "+\t\tif (!file.exists()) {", "+\t\t\tfile.mkdirs();", "+\t\t} ", "+\t}", "+\treturn defaultClassPaths;", "+}"]}], "num": 4981}