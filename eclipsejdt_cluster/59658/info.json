{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6a1c4187832a8f0a5f16d98660576d2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "105a149d5ac55c8e9b28922ab56c3277", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java", "commitBeforeChange": "0ef15ab3e77b7c293b04de9a99ac186cbe5a3c0f", "commitAfterChange": "dd6bc11628a6724c7599b64bbc9d6dfcf59daa40", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\treturn ((Reference) lhs)", "+\t\tLocalVariableBinding local = this.lhs.localVariableBinding();", "+\t\tint nullStatus = this.expression.nullStatus(flowInfo);", "+\t\tif (local != null && nullStatus == FlowInfo.NULL) {", "+\t\t\t\tif (flowInfo.isDefinitelyNull(local)) {", "+\t\t\t\t\tcurrentScope.problemReporter().localVariableCanOnlyBeNull(local, this.lhs);", "+\t\t\t\t}", "+\t\t}", "+\t\tflowInfo = ((Reference) lhs)", "+\t\tif (local != null) {", "+\t\t\tswitch(nullStatus) {", "+\t\t\t\tcase FlowInfo.NULL :", "+\t\t\t\t\tflowInfo.markAsDefinitelyNull(local);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FlowInfo.NON_NULL :", "+\t\t\t\t\tflowInfo.markAsDefinitelyNonNull(local);", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}\t\t", "+\t\treturn flowInfo;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "65e54ba2c1c08781b962134ce2c46e6d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/UserLibrary.java", "commitBeforeChange": "a9ee87c83d7d756655063cf50477aa2c78c21e73", "commitAfterChange": "fcb6b52dfb91300241dc1cd9c915f45219747f35", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  String serialize() throws IOException", "signatureAfterChange": "  String serialize() throws IOException", "diff": ["-\t\t\tIClasspathEntry curr= this.entries[i];", "-\t\t\t", "+\t\t\tClasspathEntry cpEntry = (ClasspathEntry) this.entries[i];", "+\t\t", "-\t\t\tarchive.put(TAG_PATH, curr.getPath().toString());", "-\t\t\tIPath sourceAttach= curr.getSourceAttachmentPath();", "+\t\t\tarchive.put(TAG_PATH, cpEntry.getPath().toString());", "+\t\t\tIPath sourceAttach= cpEntry.getSourceAttachmentPath();", "-\t\t\tIPath sourceAttachRoot= curr.getSourceAttachmentRootPath();", "+\t\t\tIPath sourceAttachRoot= cpEntry.getSourceAttachmentRootPath();", "-\t\t\txmlWriter.printTag(TAG_ARCHIVE, archive, true, true, true);", "+", "+\t\t\tboolean hasExtraAttributes = cpEntry.extraAttributes != null && cpEntry.extraAttributes.length != 0;", "+\t\t\tboolean hasRestrictions = cpEntry.getAccessRuleSet() != null; // access rule set is null if no access rules", "+\t\t\txmlWriter.printTag(TAG_ARCHIVE, archive, true, true, !(hasExtraAttributes || hasRestrictions));", "+", "+\t\t\t// write extra attributes if necessary", "+\t\t\tif (hasExtraAttributes) {", "+\t\t\t\tcpEntry.encodeExtraAttributes(xmlWriter, true, true);", "+\t\t\t}", "+", "+\t\t\t// write extra attributes and restriction if necessary", "+\t\t\tif (hasRestrictions) {", "+\t\t\t\tcpEntry.encodeAccessRules(xmlWriter, true, true);", "+\t\t\t}", "+", "+\t\t\t// write archive end tag if necessary", "+\t\t\tif (hasExtraAttributes || hasRestrictions) {", "+\t\t\t\txmlWriter.endTag(TAG_ARCHIVE, true);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9100ea0fcbd99919218290388c05a7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java", "commitBeforeChange": "94cf6b4f7af3fd80bbff88619e21ee7974889ee5", "commitAfterChange": "fe32c2fb1206f9aa293286057591b6614ed5e3a2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-", "+\t\tConstant cst = this.condition == null ? null : this.condition.optimizedBooleanConstant();", "+\t\tboolean isConditionOptimizedFalse = cst != null && (cst != Constant.NotAConstant && cst.booleanValue() == false);", "+\t\tif (isConditionOptimizedFalse) {", "+\t\t\tcondition.generateCode(scope, codeStream, false);", "+\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\tif (neededScope) {", "+\t\t\t\tcodeStream.exitUserScope(scope);", "+\t\t\t}", "+\t\t\tif (mergedInitStateIndex != -1) {", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t\t}", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\treturn;", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8d87a81bc47f46d4b668e97b5dcbcbf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "c16fc59ab5654c1c9ba882d21830089973cfaf23", "commitAfterChange": "d7e0c304d172fca497b655ba971da6ca54adad0f", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void generateOptimizedBoolean( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tBranchLabel trueLabel, \t\tBranchLabel falseLabel, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateOptimizedBoolean( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tBranchLabel trueLabel, \t\tBranchLabel falseLabel, \t\tboolean valueRequired)", "diff": ["-\t\t\t\tint position = codeStream.position;", "-\t\t\t\tcodeStream.goto_(endifLabel);", "-\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, position);", "+\t\t\t\tJumpEndif: {", "+\t\t\t\t\tif (falseLabel == null) {", "+\t\t\t\t\t\tif (trueLabel != null) {", "+\t\t\t\t\t\t\t// implicit falling through the FALSE case", "+\t\t\t\t\t\t\tcst = this.optimizedIfTrueConstant;", "+\t\t\t\t\t\t\tboolean isValueIfTrueOptimizedTrue = cst != null && cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\t\t\t\t\t\t\tif (isValueIfTrueOptimizedTrue) break JumpEndif; // no need to jump over, since branched to true already", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// implicit falling through the TRUE case", "+\t\t\t\t\t\tif (trueLabel == null) {", "+\t\t\t\t\t\t\tcst = this.optimizedIfTrueConstant;", "+\t\t\t\t\t\t\tboolean isValueIfTrueOptimizedFalse = cst != null && cst != Constant.NotAConstant && cst.booleanValue() == false;", "+\t\t\t\t\t\t\tif (isValueIfTrueOptimizedFalse) break JumpEndif; // no need to jump over, since branched to false already", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// no implicit fall through TRUE/FALSE --> should never occur", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tint position = codeStream.position;", "+\t\t\t\t\tcodeStream.goto_(endifLabel);", "+\t\t\t\t\tcodeStream.updateLastRecordedEndPC(currentScope, position);", "+\t\t\t\t}"]}], "num": 59658}