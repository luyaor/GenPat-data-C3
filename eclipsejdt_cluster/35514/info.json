{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "79bba0f9fccaabbee25a2cb4983e54e8", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f14b46f13f72ac802aac0cbb0491115", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "82d58f9af854b98a92f7d694d40ac1e84e13013c", "commitAfterChange": "6d114aac1fbfd4c23041534efbb02c24c883ba25", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void abstractMethodMustBeImplemented(SourceTypeBinding type, MethodBinding abstractMethod)", "signatureAfterChange": " public void abstractMethodMustBeImplemented(SourceTypeBinding type, MethodBinding abstractMethod)", "diff": ["-\tthis.handle(", "-\t\t// Must implement the inherited abstract method %1", "-\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "-\t\tIProblem.AbstractMethodMustBeImplemented,", "-\t\tnew String[] { ", "-\t\t        new String(abstractMethod.selector),", "-\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "-\t\t        new String(abstractMethod.declaringClass.readableName()), ", "-\t\t        new String(type.readableName()), ", "-\t\t},", "-\t\tnew String[] { ", "-\t\t        new String(abstractMethod.selector),", "-\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "-\t\t        new String(abstractMethod.declaringClass.shortReadableName()), ", "-\t\t        new String(type.shortReadableName()), ", "-\t\t},", "-\t\ttype.sourceStart(),", "-\t\ttype.sourceEnd());", "+\tif (type.isEnum() && type.isLocalType()) {", "+\t\tFieldBinding field = type.scope.enclosingMethodScope().initializedField;", "+\t\tFieldDeclaration decl = field.sourceField();", "+\t\tthis.handle(", "+\t\t\t// Must implement the inherited abstract method %1", "+\t\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "+\t\t\tIProblem.EnumConstantMustImplementAbstractMethod,", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "+\t\t\t        new String(decl.name), ", "+\t\t\t},", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "+\t\t\t        new String(decl.name), ", "+\t\t\t},", "+\t\t\tdecl.sourceStart(),", "+\t\t\tdecl.sourceEnd());", "+\t} else {", "+\t\tthis.handle(", "+\t\t\t// Must implement the inherited abstract method %1", "+\t\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "+\t\t\tIProblem.AbstractMethodMustBeImplemented,", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "+\t\t\t        new String(abstractMethod.declaringClass.readableName()), ", "+\t\t\t        new String(type.readableName()), ", "+\t\t\t},", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "+\t\t\t        new String(abstractMethod.declaringClass.shortReadableName()), ", "+\t\t\t        new String(type.shortReadableName()), ", "+\t\t\t},", "+\t\t\ttype.sourceStart(),", "+\t\t\ttype.sourceEnd());", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3022fbf8d5f32d2c8578b13aa75aba7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CopyResourceElementsOperation.java", "commitBeforeChange": "ddacd86a7b6e877d59dd0d74f0c64b31432e64d5", "commitAfterChange": "7806a28af49b091c5019a3f6cc2c2153a422eff3", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprivate void processPackageFragmentResource(IPackageFragment source, IPackageFragmentRoot root, String newName) throws JavaModelException", "signatureAfterChange": " \tprivate void processPackageFragmentResource(IPackageFragment source, IPackageFragmentRoot root, String newName) throws JavaModelException", "diff": ["-\t\t\t//register the correct change deltas", "-\t\t\tprepareDeltas(source, newFrag, isMove() && isEmpty);", "+\t\t\t// workaround for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=24505", "+\t\t\tif (isEmpty && isMove() && !(Util.isExcluded(source) || Util.isExcluded(newFrag))) {", "+\t\t\t\tIJavaProject sourceProject = source.getJavaProject();", "+\t\t\t\tgetDeltaFor(sourceProject).movedFrom(source, newFrag);", "+\t\t\t\tIJavaProject destProject = newFrag.getJavaProject();", "+\t\t\t\tgetDeltaFor(destProject).movedTo(newFrag, source);", "+\t\t\t}"]}], "num": 35514}