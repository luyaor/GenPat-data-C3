{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5c1b58e9e3694a80e7f83875bc709994", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c3c546c5bf9893248cf63a6023dc336", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t", "-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "-\t\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "-\t\t// to each of the traversed try statements, so that execution will terminate properly.", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// lookup the label, this should answer the returnContext", "-\t\tFlowContext targetContext = (label == null)", "-\t\t\t\t? flowContext.getTargetContextForDefaultContinue()", "-\t\t\t\t: flowContext.getTargetContextForContinueLabel(label);", "+\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "+\t// to each of the traversed try statements, so that execution will terminate properly.", "-\t\tif (targetContext == null) {", "-\t\t\tif (label == null) {", "-\t\t\t\tcurrentScope.problemReporter().invalidContinue(this);", "-\t\t\t} else {", "-\t\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\t\t}", "-\t\t\treturn flowInfo; // pretend it did not continue since no actual target\t\t\t", "-\t\t} ", "+\t// lookup the label, this should answer the returnContext", "+\tFlowContext targetContext = (label == null)", "+\t\t\t? flowContext.getTargetContextForDefaultContinue()", "+\t\t\t: flowContext.getTargetContextForContinueLabel(label);", "-\t\tif (targetContext == FlowContext.NotContinuableContext) {", "+\tif (targetContext == null) {", "+\t\tif (label == null) {", "-\t\t\treturn flowInfo; // pretend it did not continue since no actual target", "+\t\t} else {", "+\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\ttargetLabel = targetContext.continueLabel();", "-\t\tFlowContext traversedContext = flowContext;", "-\t\tint subIndex = 0, maxSub = 5;", "-\t\tsubroutines = new SubRoutineStatement[maxSub];", "+\t\treturn flowInfo; // pretend it did not continue since no actual target\t\t\t", "+\t} ", "-\t\tdo {", "-\t\t\tSubRoutineStatement sub;", "-\t\t\tif ((sub = traversedContext.subRoutine()) != null) {", "-\t\t\t\tif (subIndex == maxSub) {", "-\t\t\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[maxSub*=2]), 0, subIndex); // grow", "-\t\t\t\t}", "-\t\t\t\tsubroutines[subIndex++] = sub;", "-\t\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\tif (targetContext == FlowContext.NotContinuableContext) {", "+\t\tcurrentScope.problemReporter().invalidContinue(this);", "+\t\treturn flowInfo; // pretend it did not continue since no actual target", "+\t}", "+\ttargetLabel = targetContext.continueLabel();", "+\tFlowContext traversedContext = flowContext;", "+\tint subCount = 0;", "+\tsubroutines = new SubRoutineStatement[5];", "+", "+\tdo {", "+\t\tSubRoutineStatement sub;", "+\t\tif ((sub = traversedContext.subroutine()) != null) {", "+\t\t\tif (subCount == subroutines.length) {", "+\t\t\t\tSystem.arraycopy(subroutines, 0, subroutines = new SubRoutineStatement[subCount*2], 0, subCount); // grow", "-\t\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-", "-\t\t\tASTNode node;", "-\t\t\tif ((node = traversedContext.associatedNode) instanceof TryStatement) {", "-\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "-\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "-\t\t\t} else if (traversedContext == targetContext) {", "-\t\t\t\t// only record continue info once accumulated through subroutines, and only against target context", "-\t\t\t\ttargetContext.recordContinueFrom(flowContext, flowInfo);", "+\t\t\tsubroutines[subCount++] = sub;", "+\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t} while ((traversedContext = traversedContext.parent) != null);", "-\t\t", "-\t\t// resize subroutines", "-\t\tif (subIndex != maxSub) {", "-\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[subIndex]), 0, subIndex);", "-\t\treturn FlowInfo.DEAD_END;", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}\t\t", "+\t\t} else if (traversedContext == targetContext) {", "+\t\t\t// only record continue info once accumulated through subroutines, and only against target context", "+\t\t\ttargetContext.recordContinueFrom(flowContext, flowInfo);", "+\t\t\tbreak;", "+\t\t}", "+\t} while ((traversedContext = traversedContext.parent) != null);", "+\t", "+\t// resize subroutines", "+\tif (subCount != subroutines.length) {", "+\t\tSystem.arraycopy(subroutines, 0, subroutines = new SubRoutineStatement[subCount], 0, subCount);", "+\treturn FlowInfo.DEAD_END;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbfca4867e96a1b932dc4c3de49ed669", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "-\t\t// to each of the traversed try statements, so that execution will terminate properly.", "+\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "+\t// to each of the traversed try statements, so that execution will terminate properly.", "-\t\t// lookup the label, this should answer the returnContext", "-\t\tFlowContext targetContext = (label == null) ", "-\t\t\t? flowContext.getTargetContextForDefaultBreak()", "-\t\t\t: flowContext.getTargetContextForBreakLabel(label);", "+\t// lookup the label, this should answer the returnContext", "+\tFlowContext targetContext = (this.label == null) ", "+\t\t? flowContext.getTargetContextForDefaultBreak()", "+\t\t: flowContext.getTargetContextForBreakLabel(this.label);", "-\t\tif (targetContext == null) {", "-\t\t\tif (label == null) {", "-\t\t\t\tcurrentScope.problemReporter().invalidBreak(this);", "-\t\t\t} else {", "-\t\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\t\t}", "-\t\t\treturn flowInfo; // pretend it did not break since no actual target", "+\tif (targetContext == null) {", "+\t\tif (this.label == null) {", "+\t\t\tcurrentScope.problemReporter().invalidBreak(this);", "+\t\t} else {", "+\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\t", "-\t\ttargetLabel = targetContext.breakLabel();", "-\t\tFlowContext traversedContext = flowContext;", "-\t\tint subIndex = 0, maxSub = 5;", "-\t\tsubroutines = new SubRoutineStatement[maxSub];", "-\t\t", "-\t\tdo {", "-\t\t\tSubRoutineStatement sub;", "-\t\t\tif ((sub = traversedContext.subRoutine()) != null) {", "-\t\t\t\tif (subIndex == maxSub) {", "-\t\t\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[maxSub*=2]), 0, subIndex); // grow", "-\t\t\t\t}", "-\t\t\t\tsubroutines[subIndex++] = sub;", "-\t\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\treturn flowInfo; // pretend it did not break since no actual target", "+\t}", "+\t", "+\tthis.targetLabel = targetContext.breakLabel();", "+\tFlowContext traversedContext = flowContext;", "+\tint subCount = 0;", "+\tthis.subroutines = new SubRoutineStatement[5];", "+\t", "+\tdo {", "+\t\tSubRoutineStatement sub;", "+\t\tif ((sub = traversedContext.subroutine()) != null) {", "+\t\t\tif (subCount == this.subroutines.length) {", "+\t\t\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount*2]), 0, subCount); // grow", "-\t\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-", "-\t\t\tASTNode node;", "-\t\t\tif ((node = traversedContext.associatedNode) instanceof TryStatement) {", "-\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "-\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "-\t\t\t} else if (traversedContext == targetContext) {", "-\t\t\t\t// only record break info once accumulated through subroutines, and only against target context", "-\t\t\t\ttargetContext.recordBreakFrom(flowInfo);", "+\t\t\tthis.subroutines[subCount++] = sub;", "+\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t} while ((traversedContext = traversedContext.parent) != null);", "-\t\t", "-\t\t// resize subroutines", "-\t\tif (subIndex != maxSub) {", "-\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[subIndex]), 0, subIndex);", "-\t\treturn FlowInfo.DEAD_END;", "-\t}", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+\t\t", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}", "+\t\t} else if (traversedContext == targetContext) {", "+\t\t\t// only record break info once accumulated through subroutines, and only against target context", "+\t\t\ttargetContext.recordBreakFrom(flowInfo);", "+\t\t\tbreak;", "+\t\t}", "+\t} while ((traversedContext = traversedContext.parent) != null);", "+\t// resize subroutines", "+\tif (subCount != this.subroutines.length) {", "+\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount]), 0, subCount);", "+\treturn FlowInfo.DEAD_END;", "+}"]}], "num": 51088}