{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b6035212d62db84682244dd37692a46", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "31ecf85a6038ce21c663b20c0e82f6d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "264dd88468cd014ae7150e1040d5982ca933b94b", "commitAfterChange": "fc8ba03f9916b4ab5a789fe72fe040f0a158e1e5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\t\tif (current == null && this.type.isPublic()) {", "+\t\t\tint length = inherited.length;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\t\tif (inheritedMethod.isPublic() && !inheritedMethod.declaringClass.isPublic())", "+\t\t\t\t\tthis.type.addSyntheticBridgeMethod(inheritedMethod);", "+\t\t\t}", "+\t\t}", "+\t\t\tif (matchMethod == null && current != null && this.type.isPublic()) { // current == null case handled already.", "+\t\t\t\tMethodBinding inheritedMethod = inherited[i];", "+\t\t\t\tif (inheritedMethod.isPublic() && !inheritedMethod.declaringClass.isPublic()) {", "+\t\t\t\t\tthis.type.addSyntheticBridgeMethod(inheritedMethod);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "afcde8740199db5f51df984ffdee8cb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "12f65faa0a3b984e9751d243a3eab6e6ab078ed7", "commitAfterChange": "36d2cf066100445cbe45dd4cf851204404f7d76f", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 40, "signatureBeforeChange": " \tprotected boolean verifyEndLine(int textPosition)", "signatureAfterChange": " \tprotected boolean verifyEndLine(int textPosition)", "diff": ["-\t\tboolean domParser = (this.kind & DOM_PARSER) != 0;", "+\t\tboolean isDomParser = (this.kind & DOM_PARSER) != 0;", "+\t\tboolean isFormatterParser = (this.kind & FORMATTER_COMMENT_PARSER) != 0;", "-\t\t\t\tif (domParser) {", "+\t\t\t\tif (isDomParser || isFormatterParser) {", "+\t\tint spacePos = this.index;", "+\t\tchar previousChar = ch;", "-\t\t\t\t\tif (domParser) {", "+\t\t\t\t\tif (isDomParser || isFormatterParser) {", "-\t\t\t\t\t\tpushText(textPosition, previousPosition);", "+\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\ttextEndPosition = spacePos;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tpushText(textPosition, textEndPosition);", "+\t\t\t\t\tif (isFormatterParser && previousChar != ch && !ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\tthis.spacePosition = previousPosition;", "+\t\t\t\t\t}", "-\t\t\t\t\t\tif (domParser) {", "+\t\t\t\t\t\tif (isDomParser || isFormatterParser) {", "-\t\t\t\t\t\t\tpushText(textPosition, this.starPosition);", "+\t\t\t\t\t\t\tint textEndPosition = this.starPosition;", "+\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpushText(textPosition, textEndPosition);", "+\t\t\tpreviousChar = ch;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e34f34a6670fcc5cb36c21505cbab569", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "f5937020c6b957eed03745f57cfee671f23dd9b8", "commitAfterChange": "ad2aca1c2960107e50013b8f7866125addb168b4", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "signatureAfterChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "diff": ["+", "+\t\tif (annotations != null && length > 0 && recipient != null && recipient.isAnnotationType()) {", "+\t\t\t// See if this is meta-annotated as repeatable and if so validate constraints.", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tAnnotation annotation = sourceAnnotations[i];", "+\t\t\t\tMemberValuePair[] valuePairs = annotation.memberValuePairs();", "+\t\t\t\tReferenceBinding annotationType = annotations[i] != null ? annotations[i].getAnnotationType() : null;", "+\t\t\t\tif (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {", "+\t\t\t\t\tannotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\t\t\t\t\tAnnotation.checkAnnotationContainerTarget(sourceAnnotations[i], scope, annotationType, resolvedContainer);", "+\t\t\t\t\t\t\t\t// Validate the repeated *use* of a repeatable annotation.", "+\t\t\t\t\t\t\t\tAnnotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);", "+\t\t\t// Check for presence of repeating annotation together with the containing annotation"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcf9da7ce9eb32f7f3745469f436b079", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java", "commitBeforeChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "commitAfterChange": "66a4221dd418603b7f2bc6722d99e4e300585ef1", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": "  \tTypeBinding internalResolveType(Scope scope)", "diff": ["-\tprivate TypeBinding internalResolveType(Scope scope) {", "+\tTypeBinding internalResolveType(Scope scope) {", "+\t\t} else if (this.resolvedType.isMemberType()) { // inner class constructor reference must be qualified", "+\t\t\tint length = qualification.length;", "+\t\t\tReferenceBinding enclosingTypeBinding = allocationType;", "+\t\t\tif (type instanceof JavadocQualifiedTypeReference && (((JavadocQualifiedTypeReference)type).tokens.length != length)) {", "+\t\t\t\tscope.problemReporter().javadocInvalidConstructorQualification(this.memberStart+1, this.sourceEnd); //, scope.getDeclarationModifiers());", "+\t\t\t} else {", "+\t\t\t\tint idx = length;", "+\t\t\t\twhile (idx > 0 && CharOperation.equals(qualification[--idx], enclosingTypeBinding.sourceName) && (enclosingTypeBinding = enclosingTypeBinding.enclosingType()) != null) {", "+\t\t\t\t\t// verify that each qualification token matches enclosing types", "+\t\t\t\t}", "+\t\t\t\tif (idx > 0 || enclosingTypeBinding != null) {", "+\t\t\t\t\tscope.problemReporter().javadocInvalidConstructorQualification(this.memberStart+1, this.sourceEnd); //, scope.getDeclarationModifiers());", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 2744}