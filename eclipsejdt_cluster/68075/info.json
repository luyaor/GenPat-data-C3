{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fe43e6e62e8b1320ea088863f37f5446", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11f01f434dd1152b4f625d6429464a9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "bb811cafdba11489b23b9c8cd6c46c237bf0db24", "commitAfterChange": "2a64f816a9e1e382be3c6f39875e5c587a7235c0", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 28, "signatureBeforeChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException", "signatureAfterChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, FileOutputStream stream) throws IOException", "diff": ["-private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException {", "+private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, FileOutputStream stream) throws IOException {", "-\t\t\t\tvalues[i] = new Integer(stream.size());", "+\t\t\t\tvalues[i] = new Integer(this.streamEnd);", "-\tthis.categoryOffsets.put(categoryName, stream.size()); // remember the offset to the start of the table", "+\tthis.categoryOffsets.put(categoryName, this.streamEnd); // remember the offset to the start of the table", "-\tstream.writeInt(wordsToDocs.elementSize);", "+\twriteStreamInt(stream, wordsToDocs.elementSize);", "-\t\t\tUtil.writeUTF(stream, words[i]);", "+\t\t\twriteStreamChars(stream, words[i]);", "-\t\t\t\t\tstream.writeInt(-documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "+\t\t\t\t\twriteStreamInt(stream, -documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "-\t\t\t\tstream.writeInt(largeArraySize); // mark to identify that an offset follows", "-\t\t\t\tstream.writeInt(((Integer) o).intValue()); // offset in the file of the array of document numbers", "+\t\t\t\twriteStreamInt(stream, largeArraySize); // mark to identify that an offset follows", "+\t\t\t\twriteStreamInt(stream, ((Integer) o).intValue()); // offset in the file of the array of document numbers"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e8e30904abcb901bc782645b01a12fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "7ed8fb3f335f5407b01a590a0c668733ebc19aa6", "commitAfterChange": "3b0a2063dbdc61567393530ebaab7037ae911123", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException", "signatureAfterChange": " private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDocs, DataOutputStream stream) throws IOException", "diff": ["-\t// append the file with the document number arrays & remember the offsets", "+\t// the format of a category table is as follows:", "+\t// any document number arrays with >= 256 elements are written before the table (the offset to each array is remembered)", "+\t// then the number of word->int[] pairs in the table is written", "+\t// for each word -> int[] pair, the word is written followed by:", "+\t//\t\tan int <= 0 if the array size == 1", "+\t//\t\tan int > 1 & < 256 for the size of the array if its > 1 & < 256, the document array follows immediately", "+\t//\t\t256 if the array size >= 256 followed by another int which is the offset to the array (written prior to the table)", "+", "+\tint largeArraySize = 256;", "-\t\t\tint[] documentNumbers = o instanceof int[] ? (int[]) o : ((IntList) o).asArray();", "-\t\t\tint length = documentNumbers.length;", "-\t\t\tif (length == 1) {", "-\t\t\t\tvalues[i] = new Integer(-documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "-\t\t\t} else {", "+\t\t\tif (o instanceof IntList)", "+\t\t\t\to = values[i] = ((IntList) values[i]).asArray();", "+\t\t\tint[] documentNumbers = (int[]) o;", "+\t\t\tif (documentNumbers.length >= largeArraySize) {", "-\t// append the file with the arrays followed by the words & offsets", "-\t\tif (words[i] != null) {", "+\t\tObject o = values[i];", "+\t\tif (o != null) {", "-\t\t\tstream.writeInt(((Integer) values[i]).intValue()); // offset in the file of the array of document numbers", "+\t\t\tif (o instanceof int[]) {", "+\t\t\t\tint[] documentNumbers = (int[]) o;", "+\t\t\t\tif (documentNumbers.length == 1)", "+\t\t\t\t\tstream.writeInt(-documentNumbers[0]); // store an array of 1 element by negating the documentNumber (can be zero)", "+\t\t\t\telse", "+\t\t\t\t\twriteDocumentNumbers(documentNumbers, stream);", "+\t\t\t} else {", "+\t\t\t\tstream.writeInt(largeArraySize); // mark to identify that an offset follows", "+\t\t\t\tstream.writeInt(((Integer) o).intValue()); // offset in the file of the array of document numbers", "+\t\t\t}"]}], "num": 68075}