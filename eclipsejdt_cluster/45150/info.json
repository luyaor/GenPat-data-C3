{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9316b99485147b35b1c568901d46b02e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0e520f7301938ccb69a0c9a6a8169960", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "4880e7050cbb76e67af4ae410160ca2f22d74d64", "commitAfterChange": "39389abe47a577c54c69522deb2432e5ac3e85f5", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, int operator, int operatorSignature, Expression left, int leftTypeId, boolean leftIsCast, Expression right, int rightTypeId, boolean rightIsCast)", "signatureAfterChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, int operator, int operatorSignature, Expression left, int leftTypeId, boolean leftIsCast, Expression right, int rightTypeId, boolean rightIsCast)", "diff": ["-\t\tint alternateLeftTypeId;", "+\t\tint alternateLeftTypeId = leftTypeId;", "-\t\t\talternateLeftTypeId = ((CastExpression)left).expression.resolvedType.id;", "-\t\t\tif (alternateLeftTypeId == leftTypeId) { // obvious identity cast", "-\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)left); ", "-\t\t\t\tleftIsCast = false;", "-\t\t\t}\t", "-\t\t} else {", "-\t\t\talternateLeftTypeId = leftTypeId;", "+\t\t\tif ((left.bits & UnnecessaryCastMask) == 0 && left.resolvedType.isBaseType()) {", "+ \t\t\t\t// narrowing conversion on base type may change value, thus necessary", "+ \t\t\t\tleftIsCast = false;", "+\t\t\t} else  {", "+\t\t\t\talternateLeftTypeId = ((CastExpression)left).expression.resolvedType.id;", "+\t\t\t\tif (alternateLeftTypeId == leftTypeId) { // obvious identity cast", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)left); ", "+\t\t\t\t\tleftIsCast = false;", "+\t\t\t\t}\t", "+\t\t\t}", "-\t\tint alternateRightTypeId;", "+\t\tint alternateRightTypeId = rightTypeId;", "-\t\t\talternateRightTypeId = ((CastExpression)right).expression.resolvedType.id;", "-\t\t\tif (alternateRightTypeId == rightTypeId) { // obvious identity cast", "-\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)right); ", "-\t\t\t\trightIsCast = false;", "+\t\t\tif ((right.bits & UnnecessaryCastMask) == 0 && right.resolvedType.isBaseType()) {", "+ \t\t\t\t// narrowing conversion on base type may change value, thus necessary", "+ \t\t\t\trightIsCast = false;", "+\t\t\t} else {", "+\t\t\t\talternateRightTypeId = ((CastExpression)right).expression.resolvedType.id;", "+\t\t\t\tif (alternateRightTypeId == rightTypeId) { // obvious identity cast", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)right); ", "+\t\t\t\t\trightIsCast = false;", "+\t\t\t\t}", "-\t\t} else {", "-\t\t\talternateRightTypeId = rightTypeId;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f1a4798acde609cfbcbe617fd04a9276", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCast(BlockScope scope, int operator, int operatorSignature, Expression expression, int expressionTypeId)", "signatureAfterChange": " public static void checkNeedForArgumentCast(BlockScope scope, int operator, int operatorSignature, Expression expression, int expressionTypeId)", "diff": ["-\t */", "-\tpublic static void checkNeedForArgumentCast(BlockScope scope, int operator, int operatorSignature, Expression expression, int expressionTypeId) {", "-\t", "-\t\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;", "-\t", "-\t\t// check need for left operand cast", "-\t\tint alternateLeftTypeId = expressionTypeId;", "-\t\tif ((expression.bits & UnnecessaryCast) == 0 && expression.resolvedType.isBaseType()) {", "-\t\t\t// narrowing conversion on base type may change value, thus necessary", "+ */", "+public static void checkNeedForArgumentCast(BlockScope scope, int operator, int operatorSignature, Expression expression, int expressionTypeId) {", "+\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;", "+", "+\t// check need for left operand cast", "+\tint alternateLeftTypeId = expressionTypeId;", "+\tif ((expression.bits & ASTNode.UnnecessaryCast) == 0 && expression.resolvedType.isBaseType()) {", "+\t\t// narrowing conversion on base type may change value, thus necessary", "+\t\treturn;", "+\t} else  {", "+\t\tTypeBinding alternateLeftType = ((CastExpression)expression).expression.resolvedType;", "+\t\tif (alternateLeftType == null) return; // cannot do better", "+\t\tif ((alternateLeftTypeId = alternateLeftType.id) == expressionTypeId) { // obvious identity cast", "+\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)expression); ", "-\t\t} else  {", "-\t\t\tTypeBinding alternateLeftType = ((CastExpression)expression).expression.resolvedType;", "-\t\t\tif (alternateLeftType == null) return; // cannot do better", "-\t\t\tif ((alternateLeftTypeId = alternateLeftType.id) == expressionTypeId) { // obvious identity cast", "-\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)expression); ", "-\t\t\t\treturn;", "-\t\t\t} else if (alternateLeftTypeId == T_null) {", "-\t\t\t\talternateLeftTypeId = expressionTypeId;  // tolerate null argument cast", "-\t\t\t\treturn;", "-\t\t\t}", "+\t\t} else if (alternateLeftTypeId == TypeIds.T_null) {", "+\t\t\talternateLeftTypeId = expressionTypeId;  // tolerate null argument cast", "+\t\t\treturn;", "+\t}", "-\t}", "+}"]}], "num": 45150}