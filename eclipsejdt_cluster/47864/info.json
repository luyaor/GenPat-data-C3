{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "30f29ed23441e77f06b2bdeb71d3ec70", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e7ae383fdf99681bf81280629f79098", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ClassLiteralAccess.java", "commitBeforeChange": "4694cc0005ea017b2601e02ddce206da50b47138", "commitAfterChange": "6b1cf9545e376e005c20d9c5709294b65e338780", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\t", "+\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=320463", "+\t\t   https://bugs.eclipse.org/bugs/show_bug.cgi?id=312076", "+\t\t   JLS3 15.8.2 forbids the type named in the class literal expression from being a parameterized type.", "+\t\t   And the grammar in 18.1 disallows (where X and Y are some concrete types) constructs of the form", "+\t\t   Outer<X>.class, Outer<X>.Inner.class, Outer.Inner<X>.class, Outer<X>.Inner<Y>.class etc.", "+\t\t   Corollary wise, we should resolve the type of the class literal expression to be a raw type as", "+\t\t   class literals exist only for the raw underlying type. ", "+\t\t */", "+\t\tthis.targetType = scope.environment().convertToRawType(this.targetType, true /* force conversion of enclosing types*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ee3af6f734a460bdfdb0077e31c3a7af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java", "commitBeforeChange": "4ddddb5424dafb4b8650d4349863e03fece6ac06", "commitAfterChange": "21d3c1ac784a9ef78a64389e4df817ec0452ce19", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tprivate void readTargetInfo( \t\t\tint localTargetType, \t\t\tbyte[] classFileBytes, \t\t\tIConstantPool constantPool, \t\t\tint localOffset) throws ClassFormatException", "signatureAfterChange": " \t \tprivate void readTargetInfo( \t\t\tint localTargetType, \t\t\tbyte[] classFileBytes, \t\t\tIConstantPool constantPool, \t\t\tint localOffset) throws ClassFormatException", "diff": ["-\t\t\t\tthis.readOffset += 3; // skipping the 3rd byte which will be 0 for CAST", "+\t\t\t\tthis.readOffset += 2; ", "+\t\t\t\t// read type_argument_index", "+\t\t\t\tthis.annotationTypeIndex = u1At(classFileBytes, this.readOffset, localOffset);", "+\t\t\t\tthis.readOffset++;"]}], "num": 47864}