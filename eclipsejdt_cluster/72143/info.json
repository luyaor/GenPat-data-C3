{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d353c61d920cae72b00af3800f7fefc", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e404f4c4720f8d223d280e5ccd610f4c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "b25ed407ef1d09375524d9c9e824c1c1084b119b", "commitAfterChange": "0bd9f6472768db6e5f0062ffcfd17bd3adede039", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options, IProgressMonitor monitor)", "signatureAfterChange": " \t \tprivate static void rootNodeToCompilationUnit(AST ast, ASTConverter converter, ASTNode node)", "diff": ["-\t */", "-\tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options, IProgressMonitor monitor) {", "-\t\tif (options == null) {", "-\t\t\toptions = JavaCore.getOptions();", "-\t\t}", "-\t\tASTConverter converter = new ASTConverter(options, false, monitor);", "-\t\tconverter.compilationUnitSource = source;", "-\t\tconverter.scanner.setSource(source);", "-\t\t", "-\t\tAST ast = new AST();", "-\t\tast.setBindingResolver(new BindingResolver());", "-\t\tconverter.setAST(ast);", "-\t\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "-\t\tswitch(kind) {", "-\t\t\tcase K_STATEMENTS :", "-\t\t\t\tConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(source, offset, length, options);", "-\t\t\t\tif (constructorDeclaration != null) {", "-\t\t\t\t\tBlock block = ast.newBlock();", "-\t\t\t\t\tStatement[] statements = constructorDeclaration.statements;", "-\t\t\t\t\tif (statements != null) {", "-\t\t\t\t\t\tint statementsLength = statements.length;", "-\t\t\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "-\t\t\t\t\t\t\tblock.statements().add(converter.convert(statements[i]));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn block;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_EXPRESSION :", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = codeSnippetParsingUtil.parseExpression(source, offset, length, options);", "-\t\t\t\tif (expression != null) {", "-\t\t\t\t\treturn converter.convert(expression);", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_CLASS_BODY_DECLARATIONS :", "-\t\t\t\tfinal org.eclipse.jdt.internal.compiler.ast.ASTNode[] nodes = codeSnippetParsingUtil.parseClassBodyDeclarations(source, offset, length, options);", "-\t\t\t\tif (nodes != null) {", "-\t\t\t\t\treturn converter.convert(nodes);", "-\t\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t", "+\tprivate static void rootNodeToCompilationUnit(AST ast, ASTConverter converter, ASTNode node) {", "+\t\t// TODO record the comments information", "+\t\tCompilationUnit compilationUnit = ast.newCompilationUnit();", "+\t\tCompilationResult compilationResult = CodeSnippetParsingUtil.RecordedCompilationResult;", "+\t\tfinal int problemsCount = compilationResult.problemCount;", "+\t\tswitch(node.getNodeType()) {", "+\t\t\tcase ASTNode.BLOCK :", "+\t\t\t\t{", "+\t\t\t\t\tBlock block = (Block) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfor (int i = 0, max = block.statements().size(); i < max; i++) {", "+\t\t\t\t\t\t\tconverter.propagateErrors((ASTNode) block.statements().get(i), resizedProblems);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tTypeDeclaration typeDeclaration = ast.newTypeDeclaration();", "+\t\t\t\t\tInitializer initializer = ast.newInitializer();", "+\t\t\t\t\tinitializer.setBody(block);", "+\t\t\t\t\ttypeDeclaration.bodyDeclarations().add(initializer);", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase ASTNode.TYPE_DECLARATION :", "+\t\t\t\t{", "+\t\t\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfor (int i = 0, max = typeDeclaration.bodyDeclarations().size(); i < max; i++) {", "+\t\t\t\t\t\t\tconverter.propagateErrors((ASTNode) typeDeclaration.bodyDeclarations().get(i), resizedProblems);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\tif (node instanceof Expression) {", "+\t\t\t\t\tExpression expression = (Expression) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tconverter.propagateErrors(expression, resizedProblems);", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tExpressionStatement expressionStatement = ast.newExpressionStatement(expression);", "+\t\t\t\t\tBlock block = ast.newBlock();", "+\t\t\t\t\tblock.statements().add(expressionStatement);", "+\t\t\t\t\tInitializer initializer = ast.newInitializer();", "+\t\t\t\t\tinitializer.setBody(block);", "+\t\t\t\t\tTypeDeclaration typeDeclaration = ast.newTypeDeclaration();", "+\t\t\t\t\ttypeDeclaration.bodyDeclarations().add(initializer);", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t}", "+\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "+\t\tCodeSnippetParsingUtil.reset();", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "efdb18144494c196e9df69d5c0eb15a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "378f419edc5509790bbfa3083244109f6abafbe2", "commitAfterChange": "ec60c6997892bec30aa4ae01a8f63027630c4cdf", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": "  \tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source)", "signatureAfterChange": "  \tpublic CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source)", "diff": ["-\t\tif(unit.compilationResult.recoveryScannerData != null) {", "-\t\t\tRecoveryScanner recoveryScanner = new RecoveryScanner(this.scanner, unit.compilationResult.recoveryScannerData.removeUnused());", "-\t\t\tthis.scanner = recoveryScanner;", "-\t\t\tthis.docParser.scanner = this.scanner;", "-\t\t}", "-\t\tthis.compilationUnitSource = source;", "-\t\tthis.compilationUnitSourceLength = source.length;", "-\t\tthis.scanner.setSource(source, unit.compilationResult);", "-\t\tCompilationUnit compilationUnit = new CompilationUnit(this.ast);", "-\t\tcompilationUnit.setStatementsRecoveryData(unit.compilationResult.recoveryScannerData);", "-", "-\t\t// Parse comments", "-\t\tint[][] comments = unit.comments;", "-\t\tif (comments != null) {", "-\t\t\tbuildCommentsTable(compilationUnit, comments);", "-\t\t}", "-", "-\t\t// handle the package declaration immediately", "-\t\t// There is no node corresponding to the package declaration", "-\t\tif (this.resolveBindings) {", "-\t\t\trecordNodes(compilationUnit, unit);", "-\t\t}", "-\t\tif (unit.currentPackage != null) {", "-\t\t\tPackageDeclaration packageDeclaration = convertPackage(unit);", "-\t\t\tcompilationUnit.setPackage(packageDeclaration);", "-\t\t}", "-\t\torg.eclipse.jdt.internal.compiler.ast.ImportReference[] imports = unit.imports;", "-\t\tif (imports != null) {", "-\t\t\tint importLength = imports.length;", "-\t\t\tfor (int i = 0; i < importLength; i++) {", "-\t\t\t\tcompilationUnit.imports().add(convertImport(imports[i]));", "+\t\ttry {", "+\t\t\tif(unit.compilationResult.recoveryScannerData != null) {", "+\t\t\t\tRecoveryScanner recoveryScanner = new RecoveryScanner(this.scanner, unit.compilationResult.recoveryScannerData.removeUnused());", "+\t\t\t\tthis.scanner = recoveryScanner;", "+\t\t\t\tthis.docParser.scanner = this.scanner;", "-\t\t}", "-", "-\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;", "-\t\tif (types != null) {", "-\t\t\tint typesLength = types.length;", "-\t\t\tfor (int i = 0; i < typesLength; i++) {", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration declaration = types[i];", "-\t\t\t\tif (CharOperation.equals(declaration.name, TypeConstants.PACKAGE_INFO_NAME)) {", "-\t\t\t\t\tcontinue;", "+\t\t\tthis.compilationUnitSource = source;", "+\t\t\tthis.compilationUnitSourceLength = source.length;", "+\t\t\tthis.scanner.setSource(source, unit.compilationResult);", "+\t\t\tCompilationUnit compilationUnit = new CompilationUnit(this.ast);", "+\t\t\tcompilationUnit.setStatementsRecoveryData(unit.compilationResult.recoveryScannerData);", "+\t", "+\t\t\t// Parse comments", "+\t\t\tint[][] comments = unit.comments;", "+\t\t\tif (comments != null) {", "+\t\t\t\tbuildCommentsTable(compilationUnit, comments);", "+\t\t\t}", "+\t", "+\t\t\t// handle the package declaration immediately", "+\t\t\t// There is no node corresponding to the package declaration", "+\t\t\tif (this.resolveBindings) {", "+\t\t\t\trecordNodes(compilationUnit, unit);", "+\t\t\t}", "+\t\t\tif (unit.currentPackage != null) {", "+\t\t\t\tPackageDeclaration packageDeclaration = convertPackage(unit);", "+\t\t\t\tcompilationUnit.setPackage(packageDeclaration);", "+\t\t\t}", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.ImportReference[] imports = unit.imports;", "+\t\t\tif (imports != null) {", "+\t\t\t\tint importLength = imports.length;", "+\t\t\t\tfor (int i = 0; i < importLength; i++) {", "+\t\t\t\t\tcompilationUnit.imports().add(convertImport(imports[i]));", "-\t\t\t\tASTNode type = convert(declaration);", "-\t\t\t\tif (type == null) {", "-\t\t\t\t\tcompilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);", "+\t\t\t}", "+\t", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;", "+\t\t\tif (types != null) {", "+\t\t\t\tint typesLength = types.length;", "+\t\t\t\tfor (int i = 0; i < typesLength; i++) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration declaration = types[i];", "+\t\t\t\t\tif (CharOperation.equals(declaration.name, TypeConstants.PACKAGE_INFO_NAME)) {", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tASTNode type = convert(declaration);", "+\t\t\t\t\tif (type == null) {", "+\t\t\t\t\t\tcompilationUnit.setFlags(compilationUnit.getFlags() | ASTNode.MALFORMED);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcompilationUnit.types().add(type);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcompilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);", "+\t", "+\t\t\tint problemLength = unit.compilationResult.problemCount;", "+\t\t\tif (problemLength != 0) {", "+\t\t\t\tCategorizedProblem[] resizedProblems = null;", "+\t\t\t\tfinal CategorizedProblem[] problems = unit.compilationResult.getProblems();", "+\t\t\t\tfinal int realProblemLength=problems.length;", "+\t\t\t\tif (realProblemLength == problemLength) {", "+\t\t\t\t\tresizedProblems = problems;", "-\t\t\t\t\tcompilationUnit.types().add(type);", "+\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new CategorizedProblem[realProblemLength]), 0, realProblemLength);", "+\t\t\t\tASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(resizedProblems);", "+\t\t\t\tcompilationUnit.accept(syntaxErrorPropagator);", "+\t\t\t\tASTRecoveryPropagator recoveryPropagator =", "+\t\t\t\t\tnew ASTRecoveryPropagator(resizedProblems, unit.compilationResult.recoveryScannerData);", "+\t\t\t\tcompilationUnit.accept(recoveryPropagator);", "+\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "-\t\t}", "-\t\tcompilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);", "-", "-\t\tint problemLength = unit.compilationResult.problemCount;", "-\t\tif (problemLength != 0) {", "-\t\t\tCategorizedProblem[] resizedProblems = null;", "-\t\t\tfinal CategorizedProblem[] problems = unit.compilationResult.getProblems();", "-\t\t\tfinal int realProblemLength=problems.length;", "-\t\t\tif (realProblemLength == problemLength) {", "-\t\t\t\tresizedProblems = problems;", "-\t\t\t} else {", "-\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new CategorizedProblem[realProblemLength]), 0, realProblemLength);", "+\t\t\tif (this.resolveBindings) {", "+\t\t\t\tlookupForScopes();", "-\t\t\tASTSyntaxErrorPropagator syntaxErrorPropagator = new ASTSyntaxErrorPropagator(resizedProblems);", "-\t\t\tcompilationUnit.accept(syntaxErrorPropagator);", "-\t\t\tASTRecoveryPropagator recoveryPropagator =", "-\t\t\t\tnew ASTRecoveryPropagator(resizedProblems, unit.compilationResult.recoveryScannerData);", "-\t\t\tcompilationUnit.accept(recoveryPropagator);", "-\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\tcompilationUnit.initCommentMapper(this.scanner);", "+\t\t\treturn compilationUnit;", "+\t\t} catch(RuntimeException e) {", "+\t\t\tStringBuffer message = new StringBuffer(\"Exception occurred during compilation unit conversion:\");  //$NON-NLS-1$", "+\t\t\tString lineDelimiter = Util.findLineSeparator(source);", "+\t\t\tif (lineDelimiter == null) lineDelimiter = System.getProperty(\"line.separator\");//$NON-NLS-1$", "+\t\t\tmessage.append(lineDelimiter);", "+\t\t\tmessage.append(\"----------------------------------- SOURCE BEGIN -------------------------------------\"); //$NON-NLS-1$", "+\t\t\tmessage.append(lineDelimiter);", "+\t\t\tmessage.append(source);", "+\t\t\tmessage.append(lineDelimiter);", "+\t\t\tmessage.append(\"----------------------------------- SOURCE END -------------------------------------\"); //$NON-NLS-1$", "+\t\t\tUtil.log(e, message.toString());", "+\t\t\tthrow e;", "-\t\tif (this.resolveBindings) {", "-\t\t\tlookupForScopes();", "-\t\t}", "-\t\tcompilationUnit.initCommentMapper(this.scanner);", "-\t\treturn compilationUnit;"]}], "num": 72143}