{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2326c361fb894975df26a6e2fcb026dd", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e4379c7277b1e5ff0e074dba240ae3e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "25c51203fa7d4fa749cfa4587853bbf2ef950d7b", "commitAfterChange": "89e62e603e7ffb3443f38c2ffe0957cf9e555f67", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " boolean mustImplementAbstractMethod(ReferenceBinding declaringClass)", "signatureAfterChange": " boolean mustImplementAbstractMethod(ReferenceBinding declaringClass)", "diff": ["-\tif (!super.mustImplementAbstractMethod(declaringClass)) return false;", "-", "-\tif (!this.type.isEnum() || this.type.isAnonymousType()) return true; // want to test the actual enum type only", "-\tif (this.type.isAbstract()) return false; // is an enum that has since been tagged as abstract by the code below", "+\tif (!this.type.isEnum())", "+\t\treturn super.mustImplementAbstractMethod(declaringClass);", "+\tif (this.type.isAnonymousType())", "+\t\treturn true; // body of enum constant must implement any inherited abstract methods", "+\tif (this.type.isAbstract())", "+\t\treturn false; // is an enum that has since been tagged as abstract by the code below"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c2d0e4d7a222352e09f47f3a87592e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "1b6654cd80f53a2bb9b675efa0032a1013c4e291", "commitAfterChange": "0ab412e84edca675e938008720ddbff9326e27ed", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tfor (int i = 0, l = this.type.isAbstract() ? length - 2 : 0; i <= l;) {", "+\t// but if first method is concrete, then only check it against the rest", "+\tfor (int i = 0, l = methods[0].isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\t\t\tif (this.type.isInterface())", "+\t\t\t\tif (this.type.isInterface()) {", "+\t\t\t\t} else {", "+\t\t\t\t\tif (method.declaringClass.isClass() || !this.type.implementsInterface(method.declaringClass, false))", "+\t\t\t\t\t\tif (methods[j].declaringClass.isClass() || !this.type.implementsInterface(methods[j].declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the superclass already got blamed", "+\t\t\t\t}"]}], "num": 62832}