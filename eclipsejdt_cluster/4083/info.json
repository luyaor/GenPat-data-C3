{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3dcfdf83b8646b0a1a5a53e54931e6ac", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00e1d747412a565fa65b76a5e8955acf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["- */\r", "-protected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "-\tif (packageName == null)\r", "-\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\tIType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "-\tif (type == null) {\r", "-\t\t// look inside the compilation unit that is being searched currently\r", "-\t\t//for a non-public or inner type.\r", "-\t\tif (this.unitToLookInside != null) {\r", "-\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "-\t\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "-\t\t\t\t\t\t\ttype = allTypes[i];\r", "-\t\t\t\t\t\t\tbreak;\r", "+\t */\r", "+\tprotected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "+\t\tif (packageName == null)\r", "+\t\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\tIType type =\r", "+\t\t\tthis.nameLookup.findType(\r", "+\t\t\t\ttypeName,\r", "+\t\t\t\tpackageName,\r", "+\t\t\t\tfalse,\r", "+\t\t\t\tINameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "+\t\tif (type == null) {\r", "+\t\t\t// look inside the compilation unit that is being searched currently\r", "+\t\t\t//for a non-public or inner type.\r", "+\t\t\tif (this.unitToLookInside != null) {\r", "+\t\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "+\t\t\t\t\t\tfor (int i = 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "+\t\t\t\t\t\t\t\ttype = allTypes[i];\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t}\r", "-\tif (type != null) {\r", "-\t\tif (type instanceof BinaryType) {\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t} else { //SourceType\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "+\t\tif (type != null) {\r", "+\t\t\tif (type instanceof BinaryType) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(\r", "+\t\t\t\t\t\t(IBinaryType) ((BinaryType) type).getRawInfo());\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t} else { //SourceType\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// retrieve the requested type\r", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getRawInfo();\r", "+\t\t\t\t\tISourceType topLevelType = sourceType;\r", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {\r", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// find all siblings (other types declared in same unit, since may be used for name resolution)\r", "+\t\t\t\t\tIType[] types = sourceType.getHandle().getCompilationUnit().getTypes();\r", "+\t\t\t\t\tISourceType[] sourceTypes = new ISourceType[types.length];\r", "+\r", "+\t\t\t\t\t// in the resulting collection, ensure the requested type is the first one\r", "+\t\t\t\t\tsourceTypes[0] = sourceType;\r", "+\t\t\t\t\tfor (int i = 0, index = 1; i < types.length; i++) {\r", "+\t\t\t\t\t\tISourceType otherType =\r", "+\t\t\t\t\t\t\t(ISourceType) ((JavaElement) types[i]).getRawInfo();\r", "+\t\t\t\t\t\tif (!otherType.equals(topLevelType))\r", "+\t\t\t\t\t\t\tsourceTypes[index++] = otherType;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes);\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "-\t}\r", "-\treturn null;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7098805650c8d129cd97a92a5d326d14", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["- */\r", "-protected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "-\tif (packageName == null)\r", "-\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\tIType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "-\tif (type == null) {\r", "-\t\t// look inside the compilation unit that is being searched currently\r", "-\t\t//for a non-public or inner type.\r", "-\t\tif (this.unitToLookInside != null) {\r", "-\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "-\t\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "-\t\t\t\t\t\t\ttype = allTypes[i];\r", "-\t\t\t\t\t\t\tbreak;\r", "+\t */\r", "+\tprotected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "+\t\tif (packageName == null)\r", "+\t\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\tIType type =\r", "+\t\t\tthis.nameLookup.findType(\r", "+\t\t\t\ttypeName,\r", "+\t\t\t\tpackageName,\r", "+\t\t\t\tfalse,\r", "+\t\t\t\tINameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "+\t\tif (type == null) {\r", "+\t\t\t// look inside the compilation unit that is being searched currently\r", "+\t\t\t//for a non-public or inner type.\r", "+\t\t\tif (this.unitToLookInside != null) {\r", "+\t\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "+\t\t\t\t\t\tfor (int i = 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "+\t\t\t\t\t\t\t\ttype = allTypes[i];\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t}\r", "-\tif (type != null) {\r", "-\t\tif (type instanceof BinaryType) {\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t} else { //SourceType\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "+\t\tif (type != null) {\r", "+\t\t\tif (type instanceof BinaryType) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(\r", "+\t\t\t\t\t\t(IBinaryType) ((BinaryType) type).getRawInfo());\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t} else { //SourceType\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// retrieve the requested type\r", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getRawInfo();\r", "+\t\t\t\t\tISourceType topLevelType = sourceType;\r", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {\r", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// find all siblings (other types declared in same unit, since may be used for name resolution)\r", "+\t\t\t\t\tIType[] types = sourceType.getHandle().getCompilationUnit().getTypes();\r", "+\t\t\t\t\tISourceType[] sourceTypes = new ISourceType[types.length];\r", "+\r", "+\t\t\t\t\t// in the resulting collection, ensure the requested type is the first one\r", "+\t\t\t\t\tsourceTypes[0] = sourceType;\r", "+\t\t\t\t\tfor (int i = 0, index = 1; i < types.length; i++) {\r", "+\t\t\t\t\t\tISourceType otherType =\r", "+\t\t\t\t\t\t\t(ISourceType) ((JavaElement) types[i]).getRawInfo();\r", "+\t\t\t\t\t\tif (!otherType.equals(topLevelType))\r", "+\t\t\t\t\t\t\tsourceTypes[index++] = otherType;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes);\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "-\t}\r", "-\treturn null;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82041e5b0e2eaee4eb6f3124f0bab8b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["- */\r", "-protected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "-\tif (packageName == null)\r", "-\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\tIType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "-\tif (type == null) {\r", "-\t\t// look inside the compilation unit that is being searched currently\r", "-\t\t//for a non-public or inner type.\r", "-\t\tif (this.unitToLookInside != null) {\r", "-\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "-\t\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "-\t\t\t\t\t\t\ttype = allTypes[i];\r", "-\t\t\t\t\t\t\tbreak;\r", "+\t */\r", "+\tprotected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "+\t\tif (packageName == null)\r", "+\t\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\tIType type =\r", "+\t\t\tthis.nameLookup.findType(\r", "+\t\t\t\ttypeName,\r", "+\t\t\t\tpackageName,\r", "+\t\t\t\tfalse,\r", "+\t\t\t\tINameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "+\t\tif (type == null) {\r", "+\t\t\t// look inside the compilation unit that is being searched currently\r", "+\t\t\t//for a non-public or inner type.\r", "+\t\t\tif (this.unitToLookInside != null) {\r", "+\t\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "+\t\t\t\t\t\tfor (int i = 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "+\t\t\t\t\t\t\t\ttype = allTypes[i];\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t}\r", "-\tif (type != null) {\r", "-\t\tif (type instanceof BinaryType) {\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t} else { //SourceType\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "+\t\tif (type != null) {\r", "+\t\t\tif (type instanceof BinaryType) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(\r", "+\t\t\t\t\t\t(IBinaryType) ((BinaryType) type).getRawInfo());\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t} else { //SourceType\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// retrieve the requested type\r", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getRawInfo();\r", "+\t\t\t\t\tISourceType topLevelType = sourceType;\r", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {\r", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// find all siblings (other types declared in same unit, since may be used for name resolution)\r", "+\t\t\t\t\tIType[] types = sourceType.getHandle().getCompilationUnit().getTypes();\r", "+\t\t\t\t\tISourceType[] sourceTypes = new ISourceType[types.length];\r", "+\r", "+\t\t\t\t\t// in the resulting collection, ensure the requested type is the first one\r", "+\t\t\t\t\tsourceTypes[0] = sourceType;\r", "+\t\t\t\t\tfor (int i = 0, index = 1; i < types.length; i++) {\r", "+\t\t\t\t\t\tISourceType otherType =\r", "+\t\t\t\t\t\t\t(ISourceType) ((JavaElement) types[i]).getRawInfo();\r", "+\t\t\t\t\t\tif (!otherType.equals(topLevelType))\r", "+\t\t\t\t\t\t\tsourceTypes[index++] = otherType;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes);\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "-\t}\r", "-\treturn null;\r", "-}\r"]}], "num": 4083}