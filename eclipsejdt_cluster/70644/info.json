{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "677d8e98b0541bc8b6085a8b30204ecc", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "083907de8b0e37acf809804d896037d0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "42a5591e6405d9d5a9661e1fdb211c39440692e6", "commitAfterChange": "90b5d0d22a673acac5fa922f69ac563d54cf8a91", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tif (methods[0].declaringClass.isClass())", "-\t\treturn super.checkInheritedReturnTypes(methods, length);", "-", "+\t// assumes length > 1", "-\tfor (int i = 0, l = length - 1; i < l;) {", "+\tint[] areIncompatible = null;", "+\t// abstract classes must check every method against each other", "+\tfor (int i = 0, l = this.type.isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\tnextMethod : for (int j = i; j <= l; j++) {", "+\t\tnextMethod : for (int j = i; j < length; j++) {", "-\t\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "-\t\t\t\treturn false;", "+\t\t\t\t// check to see if this is just a warning, if so report it & skip to next method", "+\t\t\t\tif (isUnsafeReturnTypeOverride(method, methods[j])) {", "+\t\t\t\t\tproblemReporter(method).unsafeReturnTypeOverride(method, methods[j], this.type);", "+\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t}", "+\t\t\t\tif (areIncompatible == null)", "+\t\t\t\t\tareIncompatible = new int[length];", "+\t\t\t\tareIncompatible[i - 1] = -1;", "+\t\t\t\tareIncompatible[j] = -1;", "-\treturn true;", "+\tif (areIncompatible == null)", "+\t\treturn true;", "+", "+\tint count = 0;", "+\tfor (int i = 0; i < length; i++)", "+\t\tif (areIncompatible[i] == -1) count++;", "+\tif (count == length) {", "+\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "+\t\treturn false;", "+\t}", "+\tMethodBinding[] methodsToReport = new MethodBinding[count];", "+\tfor (int i = 0, index = 0; i < length; i++)", "+\t\tif (areIncompatible[i] == -1)", "+\t\t\tmethodsToReport[index++] = methods[i];", "+\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methodsToReport, count);", "+\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6484224726b0c9e14bf6927e696f2f7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "786bdcb54629de0c38fe45d8c9c539f76fe7da89", "commitAfterChange": "0f2bcb9853eb25fef3d26daa6737dcdc0dcad109", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tint[] areIncompatible = null;", "+\t// so find 1 method that is compatible with every other method", "-\tfor (int i = 0, l = methods[0].isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\tMethodBinding method = methods[i++];", "-\t\tnextMethod : for (int j = i; j < length; j++) {", "+\tmatch : for (int i = 0, l = methods[0].isAbstract() ? length - 1 : 0; i <= l; i++) {", "+\t\tMethodBinding method = methods[i];", "+\t\tnext : for (int j = 0; j < length; j++) {", "+\t\t\tif (i == j) continue;", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the super interface already got blamed", "+\t\t\t\t\t\t\treturn true; // do not complain since the super interface already got blamed", "-\t\t\t\t\tif (method.isAbstract() && method.declaringClass.isClass())", "-\t\t\t\t\t\tif (areReturnTypesCompatible(methods[j], method))", "-\t\t\t\t\t\t\tcontinue nextMethod; // return type of the superclass' inherited method is a supertype of the return type of the interface's method ", "-\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the superclass already got blamed", "+\t\t\t\t\t\t\tcontinue next; // do not complain since the superclass already got blamed", "-\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\tcontinue next;", "-\t\t\t\tif (areIncompatible == null)", "-\t\t\t\t\tareIncompatible = new int[length];", "-\t\t\t\tareIncompatible[i - 1] = -1;", "-\t\t\t\tareIncompatible[j] = -1;", "+\t\t\t\tcontinue match;", "-\t}", "-\tif (areIncompatible == null)", "-", "-\tint count = 0;", "-\tfor (int i = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1) count++;", "-\tif (count == length) {", "-\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "-\t\treturn false;", "-\tMethodBinding[] methodsToReport = new MethodBinding[count];", "-\tfor (int i = 0, index = 0; i < length; i++)", "-\t\tif (areIncompatible[i] == -1)", "-\t\t\tmethodsToReport[index++] = methods[i];", "-\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methodsToReport, count);", "+", "+\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);"]}], "num": 70644}