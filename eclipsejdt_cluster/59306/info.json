{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "beec73ed89a6a81a80706a874b241005", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2460948a354d5bd58671356a7dc087b9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 20, "signatureBeforeChange": "   private String[] getPathsOfDeclaringType()", "signatureAfterChange": " protected String[] getPathsOfDeclaringType()", "diff": ["-", "-private String[] getPathsOfDeclaringType() {", "-\tif (this.typeQualification != null || this.typeSimpleName != null) {", "-\t\tfinal PathCollector pathCollector = new PathCollector();", "-\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope();", "-\t", "-\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "-\t\tint detailLevel = IInfoConstants.PathInfo;", "-\t\tSearchPattern searchPattern = new TypeDeclarationPattern(", "-\t\t\tthis.typeSimpleName != null ? null : this.typeQualification, // use the qualification only if no simple name", "-\t\t\tnull, // do find member types", "-\t\t\tthis.typeSimpleName,", "-\t\t\tIIndexConstants.TYPE_SUFFIX,", "-\t\t\tthis.pattern.matchMode, ", "-\t\t\ttrue);", "-\t\tIIndexSearchRequestor searchRequestor = new IndexSearchAdapter(){", "-\t\t\tpublic void acceptClassDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {", "-\t\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes", "-\t\t\t\t\tpathCollector.acceptClassDeclaration(resourcePath, simpleTypeName, enclosingTypeNames, packageName);", "-\t\t\t\t}", "-\t\t\t}\t\t", "-\t\t\tpublic void acceptInterfaceDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {", "-\t\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes", "-\t\t\t\t\tpathCollector.acceptInterfaceDeclaration(resourcePath, simpleTypeName, enclosingTypeNames, packageName);", "-\t\t\t\t}", "-\t\t\t}\t\t", "-\t\t};\t\t", "-", "-\t\tindexManager.performConcurrentJob(", "-\t\t\tnew PatternSearchJob(", "-\t\t\t\tsearchPattern, ", "-\t\t\t\tscope, ", "-\t\t\t\tdetailLevel, ", "-\t\t\t\tsearchRequestor, ", "-\t\t\t\tindexManager),", "-\t\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "-\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));", "-\t\treturn pathCollector.getPaths();", "-", "-\t}", "-\treturn null;", "-}", "+}", "+protected String[] getPathsOfDeclaringType() {", "+\tif (this.typeQualification == null && this.typeSimpleName == null) return null;", "+", "+\tfinal PathCollector pathCollector = new PathCollector();", "+\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope();", "+\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();", "+\tint detailLevel = IInfoConstants.PathInfo;", "+\tSearchPattern searchPattern = new TypeDeclarationPattern(", "+\t\tthis.typeSimpleName != null ? null : this.typeQualification, // use the qualification only if no simple name", "+\t\tnull, // do find member types", "+\t\tthis.typeSimpleName,", "+\t\tIIndexConstants.TYPE_SUFFIX,", "+\t\tthis.pattern.matchMode, ", "+\t\ttrue);", "+\tIIndexSearchRequestor searchRequestor = new IndexSearchAdapter() {", "+\t\tpublic void acceptClassDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {", "+\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) // filter out local and anonymous classes", "+\t\t\t\tpathCollector.acceptClassDeclaration(resourcePath, simpleTypeName, enclosingTypeNames, packageName);", "+\t\t}\t\t", "+\t\tpublic void acceptInterfaceDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {", "+\t\t\tif (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) // filter out local and anonymous classes", "+\t\t\t\tpathCollector.acceptInterfaceDeclaration(resourcePath, simpleTypeName, enclosingTypeNames, packageName);", "+\t\t}\t\t", "+\t};\t\t", "+", "+\tindexManager.performConcurrentJob(", "+\t\tnew PatternSearchJob(", "+\t\t\tsearchPattern, ", "+\t\t\tscope, ", "+\t\t\tdetailLevel, ", "+\t\t\tsearchRequestor, ", "+\t\t\tindexManager),", "+\t\tIJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,", "+\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));", "+\treturn pathCollector.getPaths();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8e7912dea4c247db781aa97ec2d7002", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "59f63ebee2d26201a814fe525a701186855b7a34", "commitAfterChange": "625da6d5291673f01e323396ceb1f6773e9845a5", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["-\t\tJob job = new Job(Messages.javamodel_initialization) {", "-\t\t\tprotected IStatus run(IProgressMonitor progressMonitor) {", "-\t\t\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "-\t\t\t\tSearchEngine engine = new SearchEngine();", "-\t\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "-\t\t\t\ttry {", "-\t\t\t\t\tengine.searchAllTypeNames(", "-\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "-\t\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "-\t\t\t\t\t\tIJavaSearchConstants.CLASS,", "-\t\t\t\t\t\tscope, ", "-\t\t\t\t\t\tnew TypeNameRequestor() {", "-\t\t\t\t\t\t\tpublic void acceptType(", "-\t\t\t\t\t\t\t\tint modifiers,", "-\t\t\t\t\t\t\t\tchar[] packageName,", "-\t\t\t\t\t\t\t\tchar[] simpleTypeName,", "-\t\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "-\t\t\t\t\t\t\t\tString path) {", "-\t\t\t\t\t\t\t\t// no type to accept", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t},", "-\t\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "-\t\t\t\t\t\t// to wait until indexes are fully rebuild", "-\t\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "-\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 99) // 99% of the time is spent in the dummy search", "-\t\t\t\t\t); ", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// /search failed: ignore", "-\t\t\t\t} catch (OperationCanceledException e) {", "-\t\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled())", "-\t\t\t\t\t\tthrow e;", "-\t\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// check if the build state version number has changed since last session", "-\t\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "-\t\t\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "-\t\t\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "-\t\t\t\tString versionNumber = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tversionNumber = root.getPersistentProperty(qName);", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t// could not read version number: consider it is new", "-\t\t\t\t}", "-\t\t\t\tfinal JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "-\t\t\t\tString newVersionNumber = Byte.toString(State.VERSION);", "-\t\t\t\tif (!newVersionNumber.equals(versionNumber)) {", "-\t\t\t\t\t// build state version number has changed: touch every projects to force a rebuild", "-\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "-\t\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "-\t\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "-\t\t\t\t\t\t\tIJavaProject[] projects = null;", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tprojects = model.getJavaProjects();", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t// could not get Java projects: ignore", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (projects != null) {", "-\t\t\t\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\t\t\t\t\t\t\tIJavaProject project = projects[i];", "-\t\t\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "-\t\t\t\t\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t\t\t\t\t// could not touch this project: ignore", "-\t\t\t\t\t\t\t\t\t}", "+\t\ttry {", "+\t\t\tif (monitor != null) monitor.beginTask(Messages.javamodel_initialization, 100);", "+\t\t\t// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized", "+\t\t\tSearchEngine engine = new SearchEngine();", "+\t\t\tIJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables", "+\t\t\ttry {", "+\t\t\t\tengine.searchAllTypeNames(", "+\t\t\t\t\tnull,", "+\t\t\t\t\t\"!@$#!@\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\t\tSearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,", "+\t\t\t\t\tIJavaSearchConstants.CLASS,", "+\t\t\t\t\tscope, ", "+\t\t\t\t\tnew TypeNameRequestor() {", "+\t\t\t\t\t\tpublic void acceptType(", "+\t\t\t\t\t\t\tint modifiers,", "+\t\t\t\t\t\t\tchar[] packageName,", "+\t\t\t\t\t\t\tchar[] simpleTypeName,", "+\t\t\t\t\t\t\tchar[][] enclosingTypeNames,", "+\t\t\t\t\t\t\tString path) {", "+\t\t\t\t\t\t\t// no type to accept", "+\t\t\t\t\t\t}", "+\t\t\t\t\t},", "+\t\t\t\t\t// will not activate index query caches if indexes are not ready, since it would take to long", "+\t\t\t\t\t// to wait until indexes are fully rebuild", "+\t\t\t\t\tIJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,", "+\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search", "+\t\t\t\t); ", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// /search failed: ignore", "+\t\t\t} catch (OperationCanceledException e) {", "+\t\t\t\tif (monitor != null && monitor.isCanceled())", "+\t\t\t\t\tthrow e;", "+\t\t\t\t// else indexes were not ready: catch the exception so that jars are still refreshed", "+\t\t\t}", "+\t\t\t", "+\t\t\t// check if the build state version number has changed since last session", "+\t\t\t// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)", "+\t\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"stateVersionNumber\"); //$NON-NLS-1$", "+\t\t\tIWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();", "+\t\t\tString versionNumber = null;", "+\t\t\ttry {", "+\t\t\t\tversionNumber = root.getPersistentProperty(qName);", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\t// could not read version number: consider it is new", "+\t\t\t}", "+\t\t\tfinal JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "+\t\t\tString newVersionNumber = Byte.toString(State.VERSION);", "+\t\t\tif (!newVersionNumber.equals(versionNumber)) {", "+\t\t\t\t// build state version number has changed: touch every projects to force a rebuild", "+\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\tSystem.out.println(\"Build state version number has changed\"); //$NON-NLS-1$", "+\t\t\t\tIWorkspaceRunnable runnable = new IWorkspaceRunnable() {", "+\t\t\t\t\tpublic void run(IProgressMonitor progressMonitor2) throws CoreException {", "+\t\t\t\t\t\tIJavaProject[] projects = null;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tprojects = model.getJavaProjects();", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// could not get Java projects: ignore", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (projects != null) {", "+\t\t\t\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\t\t\t\tIJavaProject project = projects[i];", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"Touching \" + project.getElementName()); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tproject.getProject().touch(progressMonitor2);", "+\t\t\t\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\t\t\t\t// could not touch this project: ignore", "-\t\t\t\t\t};", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, progressMonitor);", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\t// could not touch all projects", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t\t\t};", "-\t\t\t\t\tmodel.refreshExternalArchives(", "-\t\t\t\t\t\tnull/*refresh all projects*/, ", "-\t\t\t\t\t\tprogressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1) // 1% of the time is spent in jar refresh", "-\t\t\t\t\t);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t// refreshing failed: ignore", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(runnable, monitor);", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t// could not touch all projects", "-\t\t\t\t", "-\t\t\t\treturn Status.OK_STATUS;", "+\t\t\t\ttry {", "+\t\t\t\t\troot.setPersistentProperty(qName, newVersionNumber);", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tUtil.log(e, \"Could not persist build state version number\"); //$NON-NLS-1$", "+\t\t\t\t}", "-\t\t\tpublic boolean belongsTo(Object family) {", "-\t\t\t\treturn PLUGIN_ID.equals(family);", "+\t\t\t", "+\t\t\t// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)", "+\t\t\ttry {", "+\t\t\t\tmodel.refreshExternalArchives(", "+\t\t\t\t\tnull/*refresh all projects*/, ", "+\t\t\t\t\tmonitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh", "+\t\t\t\t);", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// refreshing failed: ignore", "-\t\t};", "-\t\tjob.setPriority(Job.SHORT);", "-\t\tjob.schedule(2000);\t // wait for the startup activity to calm down", "-\t\t", "+\t\t} finally {", "+\t\t\tif (monitor != null) monitor.done();", "+\t\t}"]}], "num": 59306}