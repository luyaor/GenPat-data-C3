{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0bfacce870ce3dbdc7761b5907f4ca2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01b29daf49f7a768657d6c7632abdfe0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java", "commitBeforeChange": "d577fece07c4fdbce33b7bc16d2d2a9b7bf263e2", "commitAfterChange": "c4bece6f11e325ba67c44c784cdcd204e747008d", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 72, "signatureBeforeChange": " \tprivate static void quickSort(Object[] sortedCollection, int left, int right, int[] sortOrder)", "signatureAfterChange": " \tprivate static void quickSort(String[] sortedCollection, int left, int right)", "diff": ["-\t */", "-\tprivate static void quickSort(Object[] sortedCollection, int left, int right, int[] sortOrder) {", "-\t\tint original_left = left;", "-\t\tint original_right = right;", "-\t\tint mid = sortOrder[ (left + right) / 2];", "-\t\tdo {", "-\t\t\twhile (sortOrder[left] < mid) {", "-\t\t\t\tleft++;", "-\t\t\t}", "-\t\t\twhile (mid < sortOrder[right]) {", "-\t\t\t\tright--;", "-\t\t\t}", "-\t\t\tif (left <= right) {", "-\t\t\t\tObject tmp = sortedCollection[left];", "-\t\t\t\tsortedCollection[left] = sortedCollection[right];", "-\t\t\t\tsortedCollection[right] = tmp;", "-\t\t\t\tint tmp2 = sortOrder[left];", "-\t\t\t\tsortOrder[left] = sortOrder[right];", "-\t\t\t\tsortOrder[right] = tmp2;", "-\t\t\t\tleft++;", "-\t\t\t\tright--;", "-\t\t\t}", "-\t\t} while (left <= right);", "-\t\tif (original_left < right) {", "-\t\t\tquickSort(sortedCollection, original_left, right, sortOrder);", "-\t\t}", "-\t\tif (left < original_right) {", "-\t\t\tquickSort(sortedCollection, left, original_right, sortOrder);", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2182b13d969e91a185e30c2934b87977", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java", "commitBeforeChange": "e6d1c8eac73b65997182b9feaba7e190099afd1a", "commitAfterChange": "8771cbd26402d5e088df5bc8e18f1b0e8d601818", "methodNumberBeforeChange": 50, "methodNumberAfterChange": 50, "signatureBeforeChange": "  \tprivate Type getArrayType(Type elementType, AST ast, ImportRewriteContext context, ITypeBinding normalizedBinding)", "signatureAfterChange": "  \tprivate Type getArrayType(Type elementType, AST ast, ImportRewriteContext context, ITypeBinding normalizedBinding)", "diff": ["-\t\t\tIAnnotationBinding[][] annotationsOnDimensions = normalizedBinding.getTypeAnnotationsOnDimensions();", "-\t\t\tint length = annotationsOnDimensions != null ? annotationsOnDimensions.length : 0;", "-\t\t\tlength = length < noDimensions ? length : noDimensions; // should not be >, but preventive.", "-\t\t\tfor (int i = 0; i < length; ++i) {", "-\t\t\t\tList dimensions = arrayType.dimensions();", "-\t\t\t\tDimension dimension = (Dimension) dimensions.get(i);", "-\t\t\t\tIAnnotationBinding[] annotationOnDimension = annotationsOnDimensions[i];", "-\t\t\t\tif (annotationOnDimension == null) continue;", "-\t\t\t\tannotateList(dimension.annotations(), annotationOnDimension, ast, context);", "+\t\t\tfor (int i = 0; i < noDimensions; i++) {", "+\t\t\t\tIAnnotationBinding[] typeAnnotations = normalizedBinding.getTypeAnnotations();", "+\t\t\t\tif (typeAnnotations.length > 0) {", "+\t\t\t\t\tDimension dimension = (Dimension) arrayType.dimensions().get(i);", "+\t\t\t\t\tannotateList(dimension.annotations(), typeAnnotations, ast, context);", "+\t\t\t\t}", "+\t\t\t\tnormalizedBinding = normalizedBinding.getComponentType();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "531ae08590ccb0107d6ab04dc6529d5e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "7064f5cf4e1b20562054db6ff22e27e2bfde4008", "commitAfterChange": "c020688b25edf08bbc7d8d68981663ad78d2a9d8", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 60, "signatureBeforeChange": " \tprivate void createICompilationUnits()", "signatureAfterChange": " \tprivate void createICompilationUnits()", "diff": ["-\t\tfinal int len = _files.length;", "-\t\t_units = new ICompilationUnit[len];\t\t", "-\t\tint count = 0;", "-\t\tfor( int i=0; i<len; i++ ){", "-\t\t\t_units[i] = JavaCore.createCompilationUnitFrom(_files[i]);", "-\t\t\tif( _units[i] != null )", "-\t\t\t\tcount ++;", "-\t\t}", "+\t\t_units = createICUsFrom(_filesWithAnnotation);", "-\t\tif(count != len){", "-\t\t\tfinal IFile[] newFiles = new IFile[count];", "-\t\t\tfinal ICompilationUnit[] newUnits = new ICompilationUnit[count];", "+\t\tfinal int actualLen = getNumberNonNulls(_units);", "+\t\tif(actualLen != _filesWithAnnotation.length ){", "+\t\t\tfinal IFile[] newFiles = new IFile[actualLen];", "+\t\t\tfinal ICompilationUnit[] newUnits = new ICompilationUnit[actualLen];", "-\t\t\tfor( int i=0; i<len; i++ ){", "+\t\t\tfor( int i=0; i<_filesWithAnnotation.length ; i++ ){", "-\t\t\t\t\tnewFiles[newIndex] = _files[i];", "+\t\t\t\t\tnewFiles[newIndex] = _filesWithAnnotation[i];", "-\t\t\t_files = newFiles;", "+\t\t\t_filesWithAnnotation = newFiles;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91240ecb2db811ea5e884b8f4e5f8c62", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t */", "-\tpublic void generateCode(BlockScope currentScope, CodeStream codeStream) {", "-\t\tif ((this.bits & ASTNode.IsReachable) == 0) {", "-\t\t\treturn;", "+ */", "+public void generateCode(BlockScope currentScope, CodeStream codeStream) {", "+\tif ((this.bits & ASTNode.IsReachable) == 0) {", "+\t\treturn;", "+\t}", "+\t// in case the labels needs to be reinitialized", "+\t// when the code generation is restarted in wide mode", "+\tthis.anyExceptionLabel = null;", "+\tthis.reusableJSRTargets = null;", "+\tthis.reusableJSRSequenceStartLabels = null;", "+\tthis.reusableJSRTargetsCount = 0;", "+", "+\tint pc = codeStream.position;", "+\tint finallyMode = finallyMode();", "+\t", "+\tboolean requiresNaturalExit = false;", "+\t// preparing exception labels", "+\tint maxCatches = this.catchArguments == null ? 0 : this.catchArguments.length;", "+\tExceptionLabel[] exceptionLabels;", "+\tif (maxCatches > 0) {", "+\t\texceptionLabels = new ExceptionLabel[maxCatches];", "+\t\tfor (int i = 0; i < maxCatches; i++) {", "+\t\t\tExceptionLabel exceptionLabel = new ExceptionLabel(codeStream, this.catchArguments[i].binding.type);", "+\t\t\texceptionLabel.placeStart();", "+\t\t\texceptionLabels[i] = exceptionLabel;", "-\t\t// in case the labels needs to be reinitialized", "-\t\t// when the code generation is restarted in wide mode", "-\t\tthis.anyExceptionLabel = null;", "+\t} else {", "+\t\texceptionLabels = null;", "+\t}", "+\tif (this.subRoutineStartLabel != null) {", "+\t\tthis.subRoutineStartLabel.initialize(codeStream);", "+\t\tthis.enterAnyExceptionHandler(codeStream);", "+\t}", "+\t// generate the try block", "+\ttry {", "+\t\tthis.declaredExceptionLabels = exceptionLabels;", "+\t\tthis.tryBlock.generateCode(this.scope, codeStream);", "+\t} finally {", "+\t\tthis.declaredExceptionLabels = null;", "+\t}", "+\tboolean tryBlockHasSomeCode = codeStream.position != pc;", "+\t// flag telling if some bytecodes were issued inside the try block", "-\t\tint pc = codeStream.position;", "-\t\tfinal int NO_FINALLY = 0;\t\t\t\t\t\t\t\t\t\t// no finally block", "-\t\tfinal int FINALLY_SUBROUTINE = 1; \t\t\t\t\t// finally is generated as a subroutine (using jsr/ret bytecodes)", "-\t\tfinal int FINALLY_DOES_NOT_COMPLETE = 2;\t\t// non returning finally is optimized with only one instance of finally block", "-\t\tfinal int FINALLY_INLINE = 3;\t\t\t\t\t\t\t\t// finally block must be inlined since cannot use jsr/ret bytecodes >1.5", "-", "-\t\tint finallyMode;", "-\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\tfinallyMode = NO_FINALLY;", "-\t\t} else {", "-\t\t\tif (isSubRoutineEscaping()) {", "-\t\t\t\tfinallyMode = FINALLY_DOES_NOT_COMPLETE;", "-\t\t\t} else if (currentScope.compilerOptions().inlineJsrBytecode) {", "-\t\t\t\tfinallyMode = FINALLY_INLINE;", "-\t\t\t} else {", "-\t\t\t\tfinallyMode = FINALLY_SUBROUTINE;", "+\t// place end positions of user-defined exception labels", "+\tif (tryBlockHasSomeCode) {", "+\t\t// natural exit may require subroutine invocation (if finally != null)", "+\t\tBranchLabel naturalExitLabel = new BranchLabel(codeStream);", "+\t\tif ((this.bits & ASTNode.IsTryBlockExiting) == 0) {", "+\t\t\tint position = codeStream.position;", "+\t\t\tswitch(finallyMode) {", "+\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\tcase FINALLY_INLINE :", "+\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t// fall through", "+\t\t\t\tcase NO_FINALLY :", "+\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "+\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "+\t\t\t\t\tbreak;", "+\t\t\tcodeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);", "+\t\t\t//goto is tagged as part of the try block", "-\t\tboolean requiresNaturalExit = false;", "-\t\t// preparing exception labels", "-\t\tint maxCatches = this.catchArguments == null ? 0 : this.catchArguments.length;", "-\t\tExceptionLabel[] exceptionLabels;", "-\t\tif (maxCatches > 0) {", "-\t\t\texceptionLabels = new ExceptionLabel[maxCatches];", "+\t\tfor (int i = 0; i < maxCatches; i++) {", "+\t\t\texceptionLabels[i].placeEnd();", "+\t\t}", "+\t\t/* generate sequence of handler, all starting by storing the TOS (exception", "+\t\tthrown) into their own catch variables, the one specified in the source", "+\t\tthat must denote the handled exception.", "+\t\t*/", "+\t\tif (this.catchArguments != null) {", "-\t\t\t\tExceptionLabel exceptionLabel = new ExceptionLabel(codeStream, this.catchArguments[i].binding.type);", "-\t\t\t\texceptionLabel.placeStart();", "-\t\t\t\texceptionLabels[i] = exceptionLabel;", "-\t\t\t}", "-\t\t} else {", "-\t\t\texceptionLabels = null;", "-\t\t}", "-\t\tif (this.subRoutineStartLabel != null) {", "-\t\t\tthis.subRoutineStartLabel.initialize(codeStream);", "-\t\t\tthis.enterAnyExceptionHandler(codeStream);", "-\t\t}", "-\t\t// generate the try block", "-\t\ttry {", "-\t\t\tthis.enclosingExceptionLabels = exceptionLabels;", "-\t\t\tthis.tryBlock.generateCode(this.scope, codeStream);", "-\t\t} finally {", "-\t\t\tthis.enclosingExceptionLabels = null;", "-\t\t}", "-\t\tboolean tryBlockHasSomeCode = codeStream.position != pc;", "-\t\t// flag telling if some bytecodes were issued inside the try block", "-", "-\t\t// place end positions of user-defined exception labels", "-\t\tif (tryBlockHasSomeCode) {", "-\t\t\t// natural exit may require subroutine invocation (if finally != null)", "-\t\t\tBranchLabel naturalExitLabel = new BranchLabel(codeStream);", "-\t\t\tif ((this.bits & IsTryBlockExiting) == 0) {", "-\t\t\t\tint position = codeStream.position;", "-\t\t\t\tswitch(finallyMode) {", "-\t\t\t\t\tcase FINALLY_SUBROUTINE :", "-\t\t\t\t\tcase FINALLY_INLINE :", "-\t\t\t\t\t\trequiresNaturalExit = true;", "-\t\t\t\t\t\t// fall through", "-\t\t\t\t\tcase NO_FINALLY :", "-\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "-\t\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tcodeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);", "-\t\t\t\t//goto is tagged as part of the try block", "-\t\t\t}", "-\t\t\tfor (int i = 0; i < maxCatches; i++) {", "-\t\t\t\texceptionLabels[i].placeEnd();", "-\t\t\t}", "-\t\t\t/* generate sequence of handler, all starting by storing the TOS (exception", "-\t\t\tthrown) into their own catch variables, the one specified in the source", "-\t\t\tthat must denote the handled exception.", "-\t\t\t*/", "-\t\t\tif (this.catchArguments != null) {", "-\t\t\t\tfor (int i = 0; i < maxCatches; i++) {", "-\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t}", "-\t\t\t\t\tcodeStream.pushOnStack(exceptionLabels[i].exceptionType);", "-\t\t\t\t\texceptionLabels[i].place();", "-\t\t\t\t\t// optimizing the case where the exception variable is not actually used", "-\t\t\t\t\tLocalVariableBinding catchVar;", "-\t\t\t\t\tint varPC = codeStream.position;", "-\t\t\t\t\tif ((catchVar = this.catchArguments[i].binding).resolvedPosition != -1) {", "-\t\t\t\t\t\tcodeStream.store(catchVar, false);", "-\t\t\t\t\t\tcatchVar.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t\t\tcodeStream.addVisibleLocalVariable(catchVar);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t}", "-\t\t\t\t\tcodeStream.recordPositionsFrom(varPC, this.catchArguments[i].sourceStart);", "-\t\t\t\t\t// Keep track of the pcs at diverging point for computing the local attribute", "-\t\t\t\t\t// since not passing the catchScope, the block generation will exitUserScope(catchScope)", "-\t\t\t\t\tthis.catchBlocks[i].generateCode(this.scope, codeStream);", "-\t\t\t\t\tif (!this.catchExits[i]) {", "-\t\t\t\t\t\tswitch(finallyMode) {", "-\t\t\t\t\t\t\tcase FINALLY_SUBROUTINE :", "-\t\t\t\t\t\t\tcase FINALLY_INLINE :", "-\t\t\t\t\t\t\t\trequiresNaturalExit = true;", "-\t\t\t\t\t\t\t\t// fall through", "-\t\t\t\t\t\t\tcase NO_FINALLY :", "-\t\t\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "-\t\t\t\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tthis.exitAnyExceptionHandler();", "-\t\t\t// extra handler for trailing natural exit (will be fixed up later on when natural exit is generated below)", "-\t\t\tExceptionLabel naturalExitExceptionHandler = requiresNaturalExit && (finallyMode == FINALLY_SUBROUTINE) ", "-\t\t\t\t\t\t? new ExceptionLabel(codeStream, null) ", "-\t\t\t\t\t\t: null;", "-", "-\t\t\t// addition of a special handler so as to ensure that any uncaught exception (or exception thrown", "-\t\t\t// inside catch blocks) will run the finally block", "-\t\t\tint finallySequenceStartPC = codeStream.position;", "-\t\t\tif (this.subRoutineStartLabel != null) {", "-\t\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "+\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\t\t\t// reset initialization state, as for a normal catch block", "-\t\t\t\tthis.placeAllAnyExceptionHandler();", "-\t\t\t\tif (naturalExitExceptionHandler != null) naturalExitExceptionHandler.place();", "-\t\t\t\t", "-//\t\t\t\tCaseLabel defaultReturnLocationLabel = null; // only used when emulating RET instruction", "-//\t\t\t\tCaseLabel naturalExitReturnLocationLabel = null; // only used when emulating RET instruction", "-\t\t\t\tswitch(finallyMode) {", "-\t\t\t\t\tcase FINALLY_SUBROUTINE :", "-\t\t\t\t\t\t// any exception handler", "-\t\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "-\t\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t\t", "-\t\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "-\t\t\t\t\t\t// subroutine", "-\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "-\t\t\t\t\t\tposition = codeStream.position;\t", "-\t\t\t\t\t\tcodeStream.store(this.returnAddressVariable, false);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t\t\t\t\tposition = codeStream.position;", "-\t\t\t\t\t\tcodeStream.ret(this.returnAddressVariable.resolvedPosition);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\t\tposition,", "-\t\t\t\t\t\t\tthis.finallyBlock.sourceEnd);", "-\t\t\t\t\t\t// the ret bytecode is part of the subroutine", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase FINALLY_INLINE :", "-\t\t\t\t\t\t// any exception handler", "-\t\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\t// subroutine", "-\t\t\t\t\t\tthis.finallyBlock.generateCode(currentScope, codeStream);", "-\t\t\t\t\t\tposition = codeStream.position;", "-\t\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "-\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "-\t\t\t\t\t\t// any exception handler", "-\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t\tthis.subRoutineStartLabel.place();", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "-\t\t\t\t\t\t// subroutine", "-\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t\t\t\t\tbreak;", "+\t\t\t\tcodeStream.pushOnStack(exceptionLabels[i].exceptionType);", "+\t\t\t\texceptionLabels[i].place();", "+\t\t\t\t// optimizing the case where the exception variable is not actually used", "+\t\t\t\tLocalVariableBinding catchVar;", "+\t\t\t\tint varPC = codeStream.position;", "+\t\t\t\tif ((catchVar = this.catchArguments[i].binding).resolvedPosition != -1) {", "+\t\t\t\t\tcodeStream.store(catchVar, false);", "+\t\t\t\t\tcatchVar.recordInitializationStartPC(codeStream.position);", "+\t\t\t\t\tcodeStream.addVisibleLocalVariable(catchVar);", "+\t\t\t\t} else {", "+\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t// will naturally fall into subsequent code after subroutine invocation", "-\t\t\t\tnaturalExitLabel.place();", "-\t\t\t\tif (requiresNaturalExit) {", "+\t\t\t\tcodeStream.recordPositionsFrom(varPC, this.catchArguments[i].sourceStart);", "+\t\t\t\t// Keep track of the pcs at diverging point for computing the local attribute", "+\t\t\t\t// since not passing the catchScope, the block generation will exitUserScope(catchScope)", "+\t\t\t\tthis.catchBlocks[i].generateCode(this.scope, codeStream);", "+\t\t\t\tif (!this.catchExits[i]) {", "-\t\t\t\t\t\t\tint position = codeStream.position;", "-\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "-\t\t\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "-\t\t\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "-\t\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "-\t\t\t\t\t\t\t\tposition,", "-\t\t\t\t\t\t\t\tthis.finallyBlock.sourceEnd);\t", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "-\t\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "-\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "-\t\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\t\t\trequiresNaturalExit = true;", "+\t\t\t\t\t\t\t// fall through", "+\t\t\t\t\t\tcase NO_FINALLY :", "+\t\t\t\t\t\t\tcodeStream.goto_(naturalExitLabel);", "+\t\t\t\t\t\t\tcodeStream.goto_(this.subRoutineStartLabel);", "-\t\t\t} else {", "-\t\t\t\t// no subroutine, simply position end label (natural exit == end)", "-\t\t\t\tnaturalExitLabel.place();", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// try block had no effect, only generate the body of the finally block if any", "-\t\t\tif (this.subRoutineStartLabel != null) {", "-\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "-\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\tif (this.mergedInitStateIndex != -1) {", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);", "-\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);", "-\t\t}", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t}", "+\t\tthis.exitAnyExceptionHandler();", "+\t\t// extra handler for trailing natural exit (will be fixed up later on when natural exit is generated below)", "+\t\tExceptionLabel naturalExitExceptionHandler = requiresNaturalExit && (finallyMode == FINALLY_SUBROUTINE) ", "+\t\t\t\t\t? new ExceptionLabel(codeStream, null) ", "+\t\t\t\t\t: null;", "+\t\t// addition of a special handler so as to ensure that any uncaught exception (or exception thrown", "+\t\t// inside catch blocks) will run the finally block", "+\t\tint finallySequenceStartPC = codeStream.position;", "+\t\tif (this.subRoutineStartLabel != null) {", "+\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "+\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t// reset initialization state, as for a normal catch block", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\tthis.placeAllAnyExceptionHandler();", "+\t\t\tif (naturalExitExceptionHandler != null) naturalExitExceptionHandler.place();", "+\t\t\t", "+//\t\t\t\tCaseLabel defaultReturnLocationLabel = null; // only used when emulating RET instruction", "+//\t\t\t\tCaseLabel naturalExitReturnLocationLabel = null; // only used when emulating RET instruction", "+\t\t\tswitch(finallyMode) {", "+\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t// any exception handler", "+\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "+\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "+\t\t\t\t\tint position = codeStream.position;\t\t\t\t\t\t", "+\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "+\t\t\t\t\t// subroutine", "+\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\tcodeStream.pushOnStack(this.scope.getJavaLangThrowable());", "+\t\t\t\t\tposition = codeStream.position;\t", "+\t\t\t\t\tcodeStream.store(this.returnAddressVariable, false);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceStart);", "+\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\tposition = codeStream.position;", "+\t\t\t\t\tcodeStream.ret(this.returnAddressVariable.resolvedPosition);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\tposition,", "+\t\t\t\t\t\tthis.finallyBlock.sourceEnd);", "+\t\t\t\t\t// the ret bytecode is part of the subroutine", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FINALLY_INLINE :", "+\t\t\t\t\t// any exception handler", "+\t\t\t\t\tcodeStream.store(this.anyExceptionVariable, false);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "+\t\t\t\t\t// subroutine", "+\t\t\t\t\tthis.finallyBlock.generateCode(currentScope, codeStream);", "+\t\t\t\t\tposition = codeStream.position;", "+\t\t\t\t\tcodeStream.throwAnyException(this.anyExceptionVariable);", "+\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\tcodeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "+\t\t\t\t\t// any exception handler", "+\t\t\t\t\tcodeStream.pop();", "+\t\t\t\t\tthis.subRoutineStartLabel.place();", "+\t\t\t\t\tcodeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);", "+\t\t\t\t\t// subroutine", "+\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\tbreak;", "+\t\t\t// will naturally fall into subsequent code after subroutine invocation", "+\t\t\tnaturalExitLabel.place();", "+\t\t\tif (requiresNaturalExit) {", "+\t\t\t\tswitch(finallyMode) {", "+\t\t\t\t\tcase FINALLY_SUBROUTINE :", "+\t\t\t\t\t\tint position = codeStream.position;", "+\t\t\t\t\t\tnaturalExitExceptionHandler.placeStart();", "+\t\t\t\t\t\tcodeStream.jsr(this.subRoutineStartLabel);", "+\t\t\t\t\t\tnaturalExitExceptionHandler.placeEnd();", "+\t\t\t\t\t\tcodeStream.recordPositionsFrom(", "+\t\t\t\t\t\t\tposition,", "+\t\t\t\t\t\t\tthis.finallyBlock.sourceEnd);\t", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase FINALLY_INLINE :", "+\t\t\t\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\t\t\t\t// needed since any exception handler got inlined subroutine", "+\t\t\t\t\t\tif (this.preTryInitStateIndex != -1) {", "+\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);", "+\t\t\t\t\t\t// entire sequence for finally is associated to finally block", "+\t\t\t\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase FINALLY_DOES_NOT_COMPLETE :", "+\t\t\t\t\t\tbreak;", "+\t\t\t// no subroutine, simply position end label (natural exit == end)", "+\t\t\tnaturalExitLabel.place();", "+\t} else {", "+\t\t// try block had no effect, only generate the body of the finally block if any", "+\t\tif (this.subRoutineStartLabel != null) {", "+\t\t\tthis.finallyBlock.generateCode(this.scope, codeStream);", "+\t// May loose some local variable initializations : affecting the local variable attributes", "+\tif (this.mergedInitStateIndex != -1) {", "+\t\tcodeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);", "+\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);", "+\t}", "+\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b950368781251d3cdd9ac93c75d8ce8a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "af60458069f14dd1b42612d075df4c51d6608d2d", "commitAfterChange": "22d76cb44cc4a2aa3afa5a732ef27b4f46c352c3", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void initializeIndexLocations()", "signatureAfterChange": " private void initializeIndexLocations()", "diff": ["-\tSimpleSet locations = new SimpleSet();", "+\t// use a linked set to preserve the order during search: see bug 348507", "+\tLinkedHashSet locations = new LinkedHashSet();", "-\tthis.indexLocations = new IPath[locations.elementSize];", "-\tObject[] values = locations.values;", "-\tint count = 0;", "-\tfor (int i = values.length; --i >= 0;)", "-\t\tif (values[i] != null)", "-\t\t\tthis.indexLocations[count++] = (IPath) values[i];", "+\tlocations.remove(null); // Ensure no nulls", "+\tthis.indexLocations = (IPath[]) locations.toArray(new IPath[locations.size()]);"]}], "num": 44544}