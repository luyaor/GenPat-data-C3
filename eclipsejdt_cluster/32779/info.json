{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "70ae3eef2dda16d58de224b5698ce792", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "446fda15b66909816064c0153d5f284e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "7eeea60289161cbc82181c2049d38d6375b340c4", "commitAfterChange": "bac0b688c9760eba84723fa01c9ef8fce3bf0175", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic TypeBinding[] getSolutions(TypeVariableBinding[] typeParameters, InvocationSite site, BoundSet boundSet)", "signatureAfterChange": " \tpublic TypeBinding[] getSolutions(TypeVariableBinding[] typeParameters, InvocationSite site, BoundSet boundSet)", "diff": ["+\t\tInferenceVariable[] outerVariables = null;", "+\t\tif (this.outerContext != null && this.outerContext.stepCompleted < TYPE_INFERRED)", "+\t\t\touterVariables = this.outerContext.inferenceVariables;", "-\t\t\t\t\tsubstitutions[i] = boundSet.getInstantiation(variable, this.environment);", "+\t\t\t\t\tTypeBinding outerVar = null;", "+\t\t\t\t\tif (outerVariables != null && (outerVar = boundSet.getEquivalentOuterVariable(variable, outerVariables)) != null)", "+\t\t\t\t\t\tsubstitutions[i] = outerVar;", "+\t\t\t\t\telse", "+\t\t\t\t\t\tsubstitutions[i] = boundSet.getInstantiation(variable, this.environment);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5692e64dc91949a52f1bb75e78672a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["+\t\tInferenceContext inferenceContext = null;", "-\t\t\tInferenceContext inferenceContext = new InferenceContext(originalMethod);", "+\t\t\tinferenceContext = new InferenceContext(originalMethod);", "-\t\t// bounds check", "+\t\t/* bounds check: https://bugs.eclipse.org/bugs/show_bug.cgi?id=242159, Inferred types may contain self reference", "+\t\t   in formal bounds. If \"T extends I<T>\" is a original type variable and T was inferred to be I<T> due possibly", "+\t\t   to under constraints and resultant glb application per 15.12.2.8, using this.typeArguments to drive the bounds", "+\t\t   check against itself is doomed to fail. For, the variable T would after substitution be I<I<T>> and would fail", "+\t\t   bounds check against I<T>. Use the inferred types from the context directly - see that there is one round of", "+\t\t   extra substitution that has taken place to properly substitute a remaining unresolved variable which also appears", "+\t\t   in a formal bound  (So we really have a bounds mismatch between I<I<T>> and I<I<I<T>>>, in the absence of a fix.)", "+\t\t*/", "+\t\tSubstitution substitution = null;", "+\t\tif (inferenceContext != null) {", "+\t\t\tsubstitution = new LingeringTypeVariableEliminator(typeVariables, inferenceContext.substitutes, scope);", "+\t\t} else {", "+\t\t\tsubstitution = methodSubstitute;", "+\t\t}", "-\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i]; // retain for diagnostics", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t\tswitch (typeVariable.boundCheck(methodSubstitute, substitute)) {", "+\t\t\tswitch (typeVariable.boundCheck(substitution, substituteForChecks)) {"]}], "num": 32779}