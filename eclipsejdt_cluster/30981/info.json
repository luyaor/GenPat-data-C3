{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "83d22b66fb0bc7d7ba3628d160111765", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00582376047108f8154a1cee8aba1ca8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java", "commitBeforeChange": "30d3376aba31f8f9ef1e5500c7a86c4b7fc25032", "commitAfterChange": "f6a20c30e007a8356ebe3368f563d0b2f3eb9676", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static ParameterizedMethodBinding instantiateGetClass(TypeBinding receiverType, MethodBinding originalMethod, Scope scope)", "signatureAfterChange": " \tpublic static ParameterizedMethodBinding instantiateGetClass(TypeBinding receiverType, MethodBinding originalMethod, Scope scope)", "diff": ["-\t\tParameterizedMethodBinding method = new ParameterizedMethodBinding();", "+\t\tParameterizedMethodBinding method;", "+\t\tif (getClassMethodBindingCache != null) {", "+\t\t\tWeakReference w = (WeakReference) getClassMethodBindingCache.get(receiverType);", "+\t\t\tif (w != null) {", "+\t\t\t\tmethod = (ParameterizedMethodBinding) w.get();", "+\t\t\t\tif (method != null) {", "+\t\t\t\t\treturn method;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tmethod = new ParameterizedMethodBinding();", "+\t\tif (getClassMethodBindingCache == null) {", "+\t\t\tgetClassMethodBindingCache = new WeakHashMap();", "+\t\t}", "+\t\tgetClassMethodBindingCache.put(receiverType, new WeakReference(method));  // method refers back to key"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "241750fbb056055580986544c6b4d0bf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "0f841a0360389f0f91aef636ca6531276c4a074d", "commitAfterChange": "4e57894c46e6fdc6da393db7e5519e070814fd68", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "signatureAfterChange": " \tsynchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding)", "diff": ["-\t\t\t\t\t\tTypeBinding binding = (TypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(binding2);", "+\t\t\t\t\t\tITypeBinding binding = (ITypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(binding2);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase ProblemReasons.NotFound :", "+\t\t\t\t\tif (this.isRecoveredBinding) {", "+\t\t\t\t\t\tITypeBinding binding = (ITypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(referenceBinding);", "+\t\t\t\t\t\tif (binding != null) {", "+\t\t\t\t\t\t\treturn binding;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbinding = new RecoveredTypeBinding(this, referenceBinding);", "+\t\t\t\t\t\tthis.bindingTables.compilerBindingsToASTBindings.put(referenceBinding, binding);", "+\t\t\t\t\t\treturn binding;", "+\t\t\t\t\t}", "-\t\t\tTypeBinding binding = (TypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(referenceBinding);", "+\t\t\tITypeBinding binding = (ITypeBinding) this.bindingTables.compilerBindingsToASTBindings.get(referenceBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b56bc8629bb675ffa2e2ddbe486f229", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ImportRewriteAnalyzer.java", "commitBeforeChange": "6654820265cfe7764e384e0eaabd31ce71d5edd3", "commitAfterChange": "4eaab794bf6dc1418675f45525d0cd74715d55ef", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  \tpublic MultiTextEdit getResultingEdits(IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": "  \tpublic MultiTextEdit getResultingEdits(IProgressMonitor monitor) throws JavaModelException", "diff": ["+\t\t\t\t\t\tIRegion rangeBefore = currDecl.getPrecedingCommentRange();", "+\t\t\t\t\t\tif (rangeBefore != null && currPos > rangeBefore.getOffset()) {", "+\t\t\t\t\t\t\t// moved ahead of the leading comments, bring the currPos back", "+\t\t\t\t\t\t\tcurrPos = rangeBefore.getOffset();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (rangeBefore != null) {", "+\t\t\t\t\t\t\tstringsToInsert.add(buffer.getText(rangeBefore.getOffset(), rangeBefore.getLength()));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (rangeBefore != null && currPos > rangeBefore.getOffset()) {", "+\t\t\t\t\t\t\t\t// moved ahead of the leading comments, bring the currPos back", "+\t\t\t\t\t\t\t\tcurrPos = rangeBefore.getOffset();", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "349ff1187a2677c97fb6d42a029491ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "2c7a59198ef0accc78a3ea8fb276fbfe877a83c2", "commitAfterChange": "a55be3089b1474701c6009071b6792ce21fce5bc", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public SyntheticMethodBinding addSyntheticMethod(LambdaExpression lambda)", "signatureAfterChange": " public SyntheticMethodBinding addSyntheticMethod(LambdaExpression lambda)", "diff": ["+\t", "+\t// Create a $deserializeLambda$ method if necessary, one is shared amongst all lambdas", "+\tif (lambda.isSerializable) {", "+\t\tSyntheticMethodBinding[] deserializeLambdaMethods = (SyntheticMethodBinding[]) this.synthetics[SourceTypeBinding.METHOD_EMUL].get(TypeConstants.DESERIALIZE_LAMBDA);", "+\t\tif (deserializeLambdaMethods == null) {", "+\t\t\tSyntheticMethodBinding deserializeLambdaMethod = new SyntheticMethodBinding(this);", "+\t\t\tthis.synthetics[SourceTypeBinding.METHOD_EMUL].put(TypeConstants.DESERIALIZE_LAMBDA,deserializeLambdaMethods = new SyntheticMethodBinding[1]);", "+\t\t\tdeserializeLambdaMethods[0] = deserializeLambdaMethod;", "+\t\t}", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "375cd5d106795928eddb4468b6c17567", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java", "commitBeforeChange": "394f9dd17363cb38ab41ca621f834f2ad413fdce", "commitAfterChange": "2b23d6b4deb8c097d394f2fa06fcc5a5e664d549", "methodNumberBeforeChange": 87, "methodNumberAfterChange": 87, "signatureBeforeChange": " \tprivate void runTest( \t\t\tboolean shouldFlushOutputDirectory, \t\t\tString[] testFiles, \t\t\tString[] classLibraries, \t\t\tMap customOptions, \t\t\tboolean performStatementsRecovery, \t\t\tICompilerRequestor customRequestor, \t\t\tboolean expectingCompilerErrors, \t\t\tString expectedCompilerLog, \t\t\tboolean forceExecution, \t\t\tString[] vmArguments, \t\t\tString expectedOutputString, \t\t\tString expectedErrorString, \t\t\tJavacTestOptions javacTestOptions)", "signatureAfterChange": " \tprivate void runTest( \t\t\tboolean shouldFlushOutputDirectory, \t\t\tString[] testFiles, \t\t\tString[] classLibraries, \t\t\tMap customOptions, \t\t\tboolean performStatementsRecovery, \t\t\tICompilerRequestor customRequestor, \t\t\tboolean expectingCompilerErrors, \t\t\tString expectedCompilerLog, \t\t\tboolean forceExecution, \t\t\tString[] vmArguments, \t\t\tString expectedOutputString, \t\t\tString expectedErrorString, \t\t\tJavacTestOptions javacTestOptions)", "diff": ["+\t\t\t\tString execErrorString = this.verifier.getExecutionError();", "+\t\t\t\tif (execErrorString != null && execErrorString.length() > 0) {", "+\t\t\t\t\tSystem.out.println(\"[ERR]:\"+execErrorString); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tString execOutputString = this.verifier.getExecutionOutput();", "+\t\t\t\tif (execOutputString != null && execOutputString.length() > 0) {", "+\t\t\t\t\tSystem.out.println(\"[OUT]:\"+execOutputString); //$NON-NLS-1$", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64ccab64f33c863a3d29450f3eb159d1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java", "commitBeforeChange": "5a8e0ebcbe7a48bae1be079e6a906d2255f8238d", "commitAfterChange": "f746ae56082e88bc2dddd35d7563e5b9b706f5c1", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " private void readHeaderInfo(FileInputStream stream) throws IOException", "signatureAfterChange": " private void readHeaderInfo(FileInputStream stream) throws IOException", "diff": ["-", "+\tlong fileLength = this.indexFile.length();", "+\tif (this.numberOfChunks > fileLength ) {", "+\t\t// not an accurate check, but good enough https://bugs.eclipse.org/bugs/show_bug.cgi?id=350612", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(\"Index file is corrupted \" + this.indexFile); //$NON-NLS-1$", "+\t\tthrow new IOException(\"Index file is corrupted \" + this.indexFile); //$NON-NLS-1$", "+\t}", "+\tif (size > fileLength) {", "+\t\t//  not an accurate check, but good enough  https://bugs.eclipse.org/bugs/show_bug.cgi?id=350612", "+\t\tif (DEBUG)", "+\t\t\tSystem.out.println(\"Index file is corrupted \" + this.indexFile); //$NON-NLS-1$", "+\t\tthrow new IOException(\"Index file is corrupted \" + this.indexFile); //$NON-NLS-1$", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4613b31be327652f26758efbf860db4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragment.java", "commitBeforeChange": "9a282e201d7bcf805a911be644106295038b1f1b", "commitAfterChange": "e6d78cda375a26ce6fdb882d62ed50fe3c6a25b5", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public String getAttachedJavadoc(IProgressMonitor monitor, String defaultEncoding) throws JavaModelException", "signatureAfterChange": " public String getAttachedJavadoc(IProgressMonitor monitor, String defaultEncoding) throws JavaModelException", "diff": ["+\tPerProjectInfo projectInfo = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(this.getJavaProject().getProject());", "+\tif (projectInfo.javadocCache != null) {", "+\t\tfinal String cachedJavadoc = (String) projectInfo.javadocCache.get(this);", "+\t\tif (cachedJavadoc != null) {", "+\t\t\treturn cachedJavadoc;", "+\t\t}", "+\t} else {", "+\t\tprojectInfo.javadocCache = new HashMap();", "+\t}", "+\tprojectInfo.javadocCache.put(this, contents);"]}], "num": 30981}