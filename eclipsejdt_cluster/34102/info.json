{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "45bc2fcdfc62c6edada66c480a0fc640", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ada8e59cb483eca2477f346f3c74bd7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "8a0b8147f0cecac2ce3556609ced767532ecf02f", "commitAfterChange": "f7ac9a023a19399b6d2bc4bf79cc66ebc7cf056e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "signatureAfterChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "diff": ["-", "+\t\t\t", "-\t\t\t\tint depth = 0;", "+\t\t\t\t// rebuild and store (in reverse order) compound name to handle embedded inner class", "+\t\t\t\tint packageLength = topLevelType.fPackage.compoundName.length;", "+\t\t\t\tint depth = resolvedType.depth();", "+\t\t\t\tint idx = depth + packageLength;", "+\t\t\t\tchar[][] computedCompoundName = new char[idx+1][];", "+\t\t\t\tcomputedCompoundName[idx] = topLevelType.sourceName;", "-\t\t\t\t\tdepth++;", "+\t\t\t\t\tcomputedCompoundName[--idx] = topLevelType.sourceName;", "+\t\t\t\t", "+\t\t\t\t// add package information", "+\t\t\t\tfor (int i = packageLength; --i >= 0;) {", "+\t\t\t\t\tcomputedCompoundName[--idx] = topLevelType.fPackage.compoundName[i];", "+\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t// search for corresponding import", "+\t\t\t\t\t\t\tboolean hasValidImport = false;", "+\t\t\t\t\t\t\tif (source15) {", "+\t\t\t\t\t\t\t\tCompilationUnitScope unitScope = topLevelScope.compilationUnitScope();", "+\t\t\t\t\t\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\t\t\t\t\t\tint length = imports == null ? 0 : imports.length;", "+\t\t\t\t\t\t\t\tmainLoop: for (int i=0; i<length; i++) {", "+\t\t\t\t\t\t\t\t\tchar[][] compoundName = imports[i].compoundName;", "+\t\t\t\t\t\t\t\t\tint compoundNameLength = compoundName.length;", "+\t\t\t\t\t\t\t\t\tif ((imports[i].onDemand && compoundNameLength == computedCompoundName.length-1) ||", "+\t\t\t\t\t\t\t\t\t\t(compoundNameLength == computedCompoundName.length))", "+\t\t\t\t\t\t\t\t\t{", "+\t\t\t\t\t\t\t\t\t\tfor (int j = compoundNameLength; --j >= 0;) {", "+\t\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(imports[i].compoundName[j], computedCompoundName[j])) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (j == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\thasValidImport = true;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak mainLoop;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (!hasValidImport) {", "+\t\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d1c9da11cf238068f7601bb5cdacc79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "b2ae5b84e851673c2a38346fddf34788249a797b", "commitAfterChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "-\t\t/* validate output location */", "-\t\tif (outputLocation == null) {", "+\t\t/* validate output locations */", "+\t\tif (projectOutputLocation == null) {", "-\t\tif (outputLocation.isAbsolute()) {", "-\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t}", "-\t\t} else {", "-\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t}", "-\t", "-\t\tboolean allowNestingInOutput = false;", "-\t\tboolean hasSource = false;", "-\t\tboolean hasLibFolder = false;", "-\t", "+\t\t// collect other output locations", "+\t\tint outputsLength = length+1;", "+\t\tIPath[] outputLocations = new IPath[outputsLength];", "+\t\toutputLocations[length] = projectOutputLocation;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\tIPath outputLocation = entry.getOutputLocation();", "+\t\t\tif (outputLocation != null) {", "+\t\t\t\tif (outputLocation.isAbsolute()) {", "+\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\toutputLocations[i] = outputLocation;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean hasSource = false;", "+\t\tboolean hasLibFolder = false;", "+\t\t", "-\t\t\tswitch(rawEntry.getEntryKind()){", "+\t\t\tint kind = rawEntry.getEntryKind();", "+\t\t\tswitch(kind){", "-\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "+\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "+\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "+\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "+\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "-\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "+\t\t\t\tfor (int j = 0; j < length; j++){", "-\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t}", "-\t", "-\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\tif (outputLocation != null) {", "+\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t", "+\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}"]}], "num": 34102}