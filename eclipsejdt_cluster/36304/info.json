{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "88b2b104bbe7db66f63b60916fe32b78", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9224a77e3e13e759ba2c0756cc57c9c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "8a765fa23ce703d1d5f2388d447ea40d7aad9f99", "commitAfterChange": "988b834a35e1571af05adddd8db1ce5aaa1f0ff0", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (use18specifics) { ", "-\t\t\tif (this.valueIfTrue.isPolyExpression()) // context propagated already.", "+\t\tif (use18specifics) {", "+\t\t\tif (this.expressionContext == ASSIGNMENT_CONTEXT || this.expressionContext == INVOCATION_CONTEXT) {", "+\t\t\t\t/* 15.25.3 : Where a poly reference conditional expression appears in a context of a particular kind with target ", "+\t\t\t\t   type T (5), its second and third operand expressions similarly appear in a context of the same kind with target", "+\t\t\t\t   type T. We eagerly propagate the context and target type here, but that should be harmless. Nonpoly expressions", "+\t\t\t\t   won't respond to it at all. If someone down below does get influenced, then the conditional is poly.", "+\t\t\t\t*/", "+\t\t\t\tthis.valueIfTrue.setExpressionContext(this.expressionContext);", "-\t\t\tif (this.valueIfFalse.isPolyExpression())", "+", "+\t\t\t\tthis.valueIfFalse.setExpressionContext(this.expressionContext);", "+\t\t\t}", "+\t\tif (use18specifics && this.expectedType != null) { // so the story is still untold for invocations.", "+\t\t\t", "+\t\t\t    TypeBinding trueType = originalValueIfTrueType;", "+\t\t\t    TypeBinding falseType = originalValueIfFalseType;", "+\t\t\t    if (this.valueIfTrue instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfTrue;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\ttrueType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    if (this.valueIfFalse instanceof MessageSend) {", "+\t\t\t    \tMessageSend message = (MessageSend) this.valueIfFalse;", "+\t\t\t    \tif (message.binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t    \t\tParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) message.binding;", "+\t\t\t    \t\tif (pgmb.inferredReturnType) {", "+\t\t\t    \t\t\tfalseType = pgmb.original().returnType;", "+\t\t\t    \t\t}", "+\t\t\t    \t}", "+\t\t\t    }", "+\t\t\t    ", "+\t\t\t    if (!trueType.isPrimitiveOrBoxedPrimitiveType() || !falseType.isPrimitiveOrBoxedPrimitiveType()) { // reference conditional ==> poly expression.", "+\t\t\t    \tif (!originalValueIfTrueType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfTrueType, this.expectedType, this.valueIfTrue, null);", "+\t\t\t    \tif (!originalValueIfFalseType.isCompatibleWith(this.expectedType, scope))", "+\t\t\t    \t\tscope.problemReporter().typeMismatchError(originalValueIfFalseType, this.expectedType, this.valueIfFalse, null);", "+\t\t\t    \t// 15.25.3: The type of a poly reference conditional expression is the same as its target type.", "+\t\t\t    \treturn this.resolvedType = this.expectedType;", "+\t\t\t    }", "+\t\t\t", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a7ffd3027c9cfb98693fbd8f09bb3215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "feb6545df47d2c5c5dddbb92489d5f562545b32e", "commitAfterChange": "f2175e743261684fe3de1337b02bb7bc5e74c85c", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int parentType)", "signatureAfterChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject currentProject)", "diff": ["-\tprotected boolean traverseDelta(IResourceDelta delta, int parentType) {\r", "+\tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject currentProject) {\r", "-\t\tboolean isOnClasspath = false;\r", "+\t\tIPath fullPath = res.getFullPath();\r", "+\t\tIJavaProject projectOfRoot = (IJavaProject)this.roots.get(fullPath);\r", "-\t\tswitch (parentType) {\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tisOnClasspath = this.isOnClasspath(res.getFullPath());\r", "-\t\t\t\tif (isOnClasspath) {\r", "-\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\telementType = IJavaElement.JAVA_PROJECT; // not yet in a package fragment root\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:\r", "-\t\t\tcase IJavaElement.PACKAGE_FRAGMENT:\r", "-\t\t\t\tisOnClasspath = true;\r", "-\t\t\t\tif (res instanceof IFolder) {\r", "-\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT;\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tString extension = res.getFileExtension();\r", "-\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\telementType = IJavaElement.COMPILATION_UNIT;\r", "-\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\telementType = IJavaElement.CLASS_FILE;\r", "+\t\tif (projectOfRoot != null) {\r", "+\t\t\tcurrentProject = projectOfRoot;\r", "+\t\t\tif (parentType == IJavaElement.JAVA_MODEL && delta.getKind() != IResourceDelta.CHANGED) {\r", "+\t\t\t\t// project is added or removed\r", "+\t\t\t\telementType = IJavaElement.JAVA_PROJECT;\r", "+\t\t\t} else {\r", "+\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tswitch (parentType) {\r", "+\t\t\t\tcase IJavaElement.JAVA_MODEL:\r", "+\t\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "+\t\t\t\t\tif (currentProject != null) {\r", "+\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\telementType = IJavaElement.JAVA_PROJECT; // not yet in a package fragment root\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t}\t\t\t\t\t\t\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT:\r", "+\t\t\t\t\tif (res instanceof IFolder) {\r", "+\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tString extension = res.getFileExtension();\r", "+\t\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\telementType = IJavaElement.COMPILATION_UNIT;\r", "+\t\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\telementType = IJavaElement.CLASS_FILE;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t}\r", "+\t\t}\r", "-\t\tif (isOnClasspath) {\r", "+\t\tif (currentProject != null) {\r", "+\t\t\tif (this.currentElement == null || !this.currentElement.getJavaProject().equals(currentProject)) {\r", "+\t\t\t\t// force the currentProject to be used\r", "+\t\t\t\tthis.currentElement = (Openable)currentProject;\r", "+\t\t\t}\r", "+\t\tboolean result;\r", "-\t\t\t\tif (!traverseDelta(child, elementType)) {\r", "+\t\t\t\tif (!traverseDelta(child, elementType, currentProject)) {\r", "-\t\t\t\t\t\tif (isOnClasspath) { \r", "+\t\t\t\t\t\tif (currentProject != null) { \r", "+\t\t\t\t\t\t\t\tif (this.currentElement == null || !this.currentElement.getJavaProject().equals(currentProject)) {\r", "+\t\t\t\t\t\t\t\t\t// force the currentProject to be used\r", "+\t\t\t\t\t\t\t\t\tthis.currentElement = (Openable)currentProject;\r", "+\t\t\t\t\t\t\t\t}\r", "-\t\t\t\tJavaProject project = (JavaProject)JavaCore.getJavaCore().create(res.getProject());\r", "-\t\t\t\tif (project != null) {\r", "+\t\t\t\tJavaProject adoptiveProject = (JavaProject)JavaCore.getJavaCore().create(res.getProject());\r", "+\t\t\t\tif (adoptiveProject != null) {\r", "-\t\t\t\t\t\t\t\tnonJavaResourcesChanged(project, orphanChildren[i]);\r", "+\t\t\t\t\t\t\t\tnonJavaResourcesChanged(adoptiveProject, orphanChildren[i]);\r", "-\t\t\treturn isOnClasspath || oneChildOnClasspath;\r", "+\t\t\tresult = currentProject != null || oneChildOnClasspath;\r", "-\t\t\treturn \r", "-\t\t\t\tisOnClasspath \r", "+\t\t\tresult = \r", "+\t\t\t\tcurrentProject != null \r", "+\t\t\r", "+\t\t// other roots\r", "+\t\tHashSet set;\r", "+\t\tif ((set = (HashSet)this.otherRoots.get(fullPath)) != null) {\r", "+\t\t\tIterator iterator = set.iterator();\r", "+\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\tIJavaProject project = (IJavaProject) iterator.next();", "+\t\t\t\tthis.cloneCurrentDelta(project, res);", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r", "+\t\treturn result;\r"]}], "num": 36304}