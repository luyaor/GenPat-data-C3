{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0abca389c9a18165c79bc4e7339662e8", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0db621fe268263bddb94cffe9842c8d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9fff7ba189be037b4cf4f61956b7e287259b8f6d", "commitAfterChange": "8f52c3e814b7d9e86327e186704f1c7e2be78c75", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tint[] sortedIndexes = new int[caseCount];", "-\t\tint[] localKeysCopy;", "-\t\tif ((bits & IsReachableMASK) == 0) {", "-\t\t\treturn;", "-\t\t}", "-\t\tint pc = codeStream.position;", "-", "-\t\t// prepare the labels and constants", "-\t\tbreakLabel.codeStream = codeStream;", "-\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "-\t\tint[] constants = new int[caseCount];", "-\t\tboolean needSwitch = caseCount != 0;", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "-\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "-\t\t}", "-", "-\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tsortedIndexes[i] = i;", "-\t\t}", "-\t\tSystem.arraycopy(", "-\t\t\tconstants,", "-\t\t\t0,", "-\t\t\t(localKeysCopy = new int[caseCount]),", "-\t\t\t0,", "-\t\t\tcaseCount);", "-\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "-\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "-\t\tif (defaultCase != null) {", "-\t\t\tdefaultCase.targetLabel = defaultLabel;", "-\t\t}", "-\t\t// generate expression testes", "-\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "-", "-\t\t// generate the appropriate switch table/lookup bytecode", "-\t\tif (needSwitch) {", "-\t\t\tint max = localKeysCopy[caseCount - 1];", "-\t\t\tint min = localKeysCopy[0];", "-\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "-\t\t\t\t", "-\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "-\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "-\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "-\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "-", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.tableswitch(", "-\t\t\t\t\t\tdefaultLabel,", "-\t\t\t\t\t\tmin,", "-\t\t\t\t\t\tmax,", "-\t\t\t\t\t\tconstants,", "-\t\t\t\t\t\tsortedIndexes,", "-\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t    try {", "+\t\t\tint[] sortedIndexes = new int[caseCount];", "+\t\t\tint[] localKeysCopy;", "+\t\t\tif ((bits & IsReachableMASK) == 0) {", "+\t\t\t\treturn;", "-\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "-\t\t}", "-\t\t", "-\t\t// generate the switch block statements", "-\t\tint caseIndex = 0;", "-\t\tif (statements != null) {", "-\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "-\t\t\t\tStatement statement = statements[i];", "-\t\t\t\tif ((caseIndex < caseCount)", "-\t\t\t\t\t&& (statement == cases[caseIndex])) { // statements[i] is a case", "-\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "-\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "-\t\t\t\t\t\tcaseIndex++;", "+\t\t\tint pc = codeStream.position;", "+\t", "+\t\t\t// prepare the labels and constants", "+\t\t\tbreakLabel.codeStream = codeStream;", "+\t\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "+\t\t\tint[] constants = new int[caseCount];", "+\t\t\tboolean needSwitch = caseCount != 0;", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "+\t\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "+\t\t\t}", "+\t", "+\t\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tsortedIndexes[i] = i;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(", "+\t\t\t\tconstants,", "+\t\t\t\t0,", "+\t\t\t\t(localKeysCopy = new int[caseCount]),", "+\t\t\t\t0,", "+\t\t\t\tcaseCount);", "+\t\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "+\t\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "+\t\t\tif (defaultCase != null) {", "+\t\t\t\tdefaultCase.targetLabel = defaultLabel;", "+\t\t\t}", "+\t\t\t// generate expression testes", "+\t\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "+\t", "+\t\t\t// generate the appropriate switch table/lookup bytecode", "+\t\t\tif (needSwitch) {", "+\t\t\t\tint max = localKeysCopy[caseCount - 1];", "+\t\t\t\tint min = localKeysCopy[0];", "+\t\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "+\t\t\t\t\t", "+\t\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "+\t\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "+\t\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.tableswitch(", "+\t\t\t\t\t\t\tdefaultLabel,", "+\t\t\t\t\t\t\tmin,", "+\t\t\t\t\t\t\tmax,", "+\t\t\t\t\t\t\tconstants,", "+\t\t\t\t\t\t\tsortedIndexes,", "+\t\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t\t\t\t}", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// generate the switch block statements", "+\t\t\tint caseIndex = 0;", "+\t\t\tif (statements != null) {", "+\t\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "+\t\t\t\t\tStatement statement = statements[i];", "+\t\t\t\t\tif ((caseIndex < caseCount) && (statement == cases[caseIndex])) { // statements[i] is a case", "+\t\t\t\t\t\tthis.scope.switchCase = cases[caseIndex]; // record entering in a switch case block", "+\t\t\t\t\t\tcaseIndex++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\t\t\tthis.scope.switchCase = defaultCase; // record entering in a switch case block", "+\t\t\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t}", "-\t\t// place the trailing labels (for break and default case)", "-\t\tbreakLabel.place();", "-\t\tif (defaultCase == null) {", "-\t\t\tdefaultLabel.place();", "-\t\t}", "-\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\tif (mergedInitStateIndex != -1) {", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tmergedInitStateIndex);", "-\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "-\t\t}", "-\t\tif (scope != currentScope) {", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t}", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\t// place the trailing labels (for break and default case)", "+\t\t\tbreakLabel.place();", "+\t\t\tif (defaultCase == null) {", "+\t\t\t\tdefaultLabel.place();", "+\t\t\t}", "+\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\tif (mergedInitStateIndex != -1) {", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tmergedInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t\t}", "+\t\t\tif (scope != currentScope) {", "+\t\t\t\tcodeStream.exitUserScope(scope);", "+\t\t\t}", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t    } finally {", "+\t        if (this.scope != null) this.scope.switchCase = null; // no longer inside switch case block", "+\t    }\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9a240a2393869c0e0c3dd9dea11d4d0e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9fff7ba189be037b4cf4f61956b7e287259b8f6d", "commitAfterChange": "8f52c3e814b7d9e86327e186704f1c7e2be78c75", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\t\tBlockScope currentScope, \t\t\tFlowContext flowContext, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\t\tBlockScope currentScope, \t\t\tFlowContext flowContext, \t\t\tFlowInfo flowInfo)", "diff": ["-\t\t\t", "-\t\tflowInfo = expression.analyseCode(currentScope, flowContext, flowInfo);", "-\t\tSwitchFlowContext switchContext =", "-\t\t\tnew SwitchFlowContext(flowContext, this, (breakLabel = new Label()));", "-\t\t// analyse the block by considering specially the case/default statements (need to bind them ", "-\t\t// to the entry point)", "-\t\tFlowInfo caseInits = FlowInfo.DEAD_END;", "-\t\t// in case of statements before the first case", "-\t\tpreSwitchInitStateIndex =", "-\t\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "-\t\tint caseIndex = 0;", "-\t\tif (statements != null) {", "-\t\t\tboolean didAlreadyComplain = false;", "-\t\t\tfor (int i = 0, max = statements.length; i < max; i++) {", "-\t\t\t\tStatement statement = statements[i];", "-\t\t\t\tif ((caseIndex < caseCount) && (statement == cases[caseIndex])) { // statement is a case", "-\t\t\t\t\tcaseIndex++;", "-\t\t\t\t\tcaseInits = caseInits.mergedWith(flowInfo.copy().unconditionalInits());", "-\t\t\t\t\tdidAlreadyComplain = false; // reset complaint", "-\t\t\t\t} else if (statement == defaultCase) { // statement is the default case", "-\t\t\t\t\tcaseInits = caseInits.mergedWith(flowInfo.copy().unconditionalInits());", "-\t\t\t\t\tdidAlreadyComplain = false; // reset complaint", "-\t\t\t\t}", "-\t\t\t\tif (!statement.complainIfUnreachable(caseInits, scope, didAlreadyComplain)) {", "-\t\t\t\t\tcaseInits = statement.analyseCode(scope, switchContext, caseInits);", "-\t\t\t\t} else {", "-\t\t\t\t\tdidAlreadyComplain = true;", "+\t    try {", "+\t\t\tflowInfo = expression.analyseCode(currentScope, flowContext, flowInfo);", "+\t\t\tSwitchFlowContext switchContext =", "+\t\t\t\tnew SwitchFlowContext(flowContext, this, (breakLabel = new Label()));", "+\t", "+\t\t\t// analyse the block by considering specially the case/default statements (need to bind them ", "+\t\t\t// to the entry point)", "+\t\t\tFlowInfo caseInits = FlowInfo.DEAD_END;", "+\t\t\t// in case of statements before the first case", "+\t\t\tpreSwitchInitStateIndex =", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "+\t\t\tint caseIndex = 0;", "+\t\t\tif (statements != null) {", "+\t\t\t\tboolean didAlreadyComplain = false;", "+\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++) {", "+\t\t\t\t\tStatement statement = statements[i];", "+\t\t\t\t\tif ((caseIndex < caseCount) && (statement == cases[caseIndex])) { // statement is a case", "+\t\t\t\t\t\tthis.scope.switchCase = cases[caseIndex]; // record entering in a switch case block", "+\t\t\t\t\t\tcaseIndex++;", "+\t\t\t\t\t\tcaseInits = caseInits.mergedWith(flowInfo.copy().unconditionalInits());", "+\t\t\t\t\t\tdidAlreadyComplain = false; // reset complaint", "+\t\t\t\t\t} else if (statement == defaultCase) { // statement is the default case", "+\t\t\t\t\t\tthis.scope.switchCase = defaultCase; // record entering in a switch case block", "+\t\t\t\t\t\tcaseInits = caseInits.mergedWith(flowInfo.copy().unconditionalInits());", "+\t\t\t\t\t\tdidAlreadyComplain = false; // reset complaint", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!statement.complainIfUnreachable(caseInits, scope, didAlreadyComplain)) {", "+\t\t\t\t\t\tcaseInits = statement.analyseCode(scope, switchContext, caseInits);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tdidAlreadyComplain = true;", "+\t\t\t\t\t}", "-\t\t}", "-", "-\t\t// if no default case, then record it may jump over the block directly to the end", "-\t\tif (defaultCase == null) {", "-\t\t\t// only retain the potential initializations", "-\t\t\tflowInfo.addPotentialInitializationsFrom(", "-\t\t\t\tcaseInits.mergedWith(switchContext.initsOnBreak));", "+\t", "+\t\t\t// if no default case, then record it may jump over the block directly to the end", "+\t\t\tif (defaultCase == null) {", "+\t\t\t\t// only retain the potential initializations", "+\t\t\t\tflowInfo.addPotentialInitializationsFrom(", "+\t\t\t\t\tcaseInits.mergedWith(switchContext.initsOnBreak));", "+\t\t\t\tmergedInitStateIndex =", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "+\t\t\t\treturn flowInfo;", "+\t\t\t}", "+\t", "+\t\t\t// merge all branches inits", "+\t\t\tFlowInfo mergedInfo = caseInits.mergedWith(switchContext.initsOnBreak);", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(flowInfo);", "-\t\t\treturn flowInfo;", "-\t\t}", "-", "-\t\t// merge all branches inits", "-\t\tFlowInfo mergedInfo = caseInits.mergedWith(switchContext.initsOnBreak);", "-\t\tmergedInitStateIndex =", "-\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "+\t\t\treturn mergedInfo;", "+\t    } finally {", "+\t        if (this.scope != null) this.scope.switchCase = null; // no longer inside switch case block", "+\t    }"]}], "num": 11020}