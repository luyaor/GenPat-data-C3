{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d16863ac4d4ce5d73df68be651c4bede", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3db518e587bb0e12edbaa3823fd8eb9d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tif (left instanceof CastExpression) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\tTypeBinding leftType = left.resolveType(scope);", "+", "+\t\tif (right instanceof CastExpression) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\tTypeBinding rightType = right.resolveType(scope);", "+", "-\t\tTypeBinding leftTb = left.resolveType(scope);", "-\t\tTypeBinding rightTb = right.resolveType(scope);", "-\t\tif (leftTb == null || rightTb == null) {", "+\t\tif (leftType == null || rightType == null) {", "-\t\tint leftId = leftTb.id;", "-\t\tint rightId = rightTb.id;", "+\t\tint leftId = leftType.id;", "+\t\tint rightId = rightType.id;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftTb, rightTb);", "+\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\t&& rightTb.isArrayType()", "-\t\t\t\t&& ((ArrayBinding) rightTb).elementsType(scope) == CharBinding)", "-\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(", "-\t\t\t\t\tright);", "-\t\t\telse if (", "-\t\t\t\trightId == T_String", "-\t\t\t\t\t&& leftTb.isArrayType()", "-\t\t\t\t\t&& ((ArrayBinding) leftTb).elementsType(scope) == CharBinding)", "-\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(", "-\t\t\t\t\tleft);", "+\t\t\t\t\t&& rightType.isArrayType()", "+\t\t\t\t\t&& ((ArrayBinding) rightType).elementsType(scope) == CharBinding) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(right);", "+\t\t\t\t\t} else if (rightId == T_String", "+\t\t\t\t\t\t\t&& leftType.isArrayType()", "+\t\t\t\t\t\t\t&& ((ArrayBinding) leftType).elementsType(scope) == CharBinding) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(left);", "+\t\t\t}", "-\t\t// (cast)  left   Op (cast)  rigth --> result", "+\t\t// (cast)  left   Op (cast)  right --> result", "-\t\tint result =", "-\t\t\tResolveTypeTables[(bits & OperatorMASK) >> OperatorSHIFT][(leftId << 4)", "-\t\t\t\t+ rightId];", "+\t\tint operator = (bits & OperatorMASK) >> OperatorSHIFT;", "+\t\tint result = ResolveTypeTables[operator][(leftId << 4) + rightId];", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftTb, rightTb);", "+\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\t\t// check need for operand cast", "+\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "+\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "+\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "+\t\t\tint alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftId;", "+\t\t\tint alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightId;", "+\t\t\tint alternateResult = ResolveTypeTables[operator][(alternateLeftId << 4) + alternateRightId];", "+\t\t\t// (cast)  left   Op (cast)  right --> result", "+\t\t\t//  1111   0000       1111   0000     1111", "+\t\t\t//  <<16   <<12       <<8    <<4       <<0", "+\t\t\tfinal int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types", "+\t\t\tif ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result", "+\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "+\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4462307de9320b9b38c21f6e250605ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "00b719c0d7c4b5271c818d210d84b349bc0324e3", "commitAfterChange": "f90ca993824b1d0e38aec24edba147ca4e8ec0d1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t// always return BooleanBinding", "+", "+\tif (left instanceof CastExpression) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+", "+\tif (right instanceof CastExpression) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+", "+\t// always return BooleanBinding", "-\t\t// (cast)  left   == (cast)  rigth --> result", "+\t\t// (cast)  left   == (cast)  right --> result", "+\t\t// check need for operand cast", "+\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "+\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "+\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "+\t\t\tint alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftType.id;", "+\t\t\tint alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightType.id;", "+\t\t\tint alternateResult = ResolveTypeTables[EQUAL_EQUAL][(alternateLeftId << 4) + alternateRightId];", "+\t\t\t// (cast)  left   Op (cast)  right --> result", "+\t\t\t//  1111   0000       1111   0000     1111", "+\t\t\t//  <<16   <<12       <<8    <<4       <<0", "+\t\t\tfinal int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types", "+\t\t\tif ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result", "+\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "+\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "+\t\t\t}", "+\t\t}\t\t", "-\t\tthis.resolvedType = BooleanBinding;", "-\t\treturn BooleanBinding;", "+\t\treturn this.resolvedType = BooleanBinding;", "-\t\tif ((rightType.id == T_String) && (leftType.id == T_String))", "+\t\tif ((rightType.id == T_String) && (leftType.id == T_String)) {", "-\t\telse", "+\t\t} else {", "-\t\tif (rightType.id == T_String)", "+\t\t}", "+\t\tif (rightType.id == T_String) {", "-\t\tif (leftType.id == T_String)", "+\t\t}", "+\t\tif (leftType.id == T_String) {", "-\t\tthis.resolvedType = BooleanBinding;", "-\t\treturn BooleanBinding;", "+\t\t}", "+\t\t// check need for operand cast", "+\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "+\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "+\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "+\t\t\tTypeBinding alternateLeftType = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType : leftType;", "+\t\t\tTypeBinding alternateRightType = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType : rightType;", "+\t\t\tif (areTypesCastCompatible(scope, alternateLeftType, alternateRightType)", "+\t\t\t\t\t|| areTypesCastCompatible(scope, alternateRightType, alternateLeftType)) {", "+\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "+\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "+\t\t\t}", "+\t\t}", "+\t\treturn this.resolvedType = BooleanBinding;"]}], "num": 13342}