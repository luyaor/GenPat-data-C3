{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a2c0451b58e9f9e347ad291199332f1e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb84936e5be61120b89e8d6e5720ef68", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "89566b19098686deffb54767a28967337579ef90", "commitAfterChange": "907520562618c52ad9275f3500852726a78168ff", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "diff": ["-\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0)", "+\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0) {", "+\t\t\t\t\t// cleanup remaining units", "+\t\t\t\t\tfor (; i < this.totalUnits; i++) {", "+\t\t\t\t\t\tthis.unitsToProcess[i].cleanUp();", "+\t\t\t\t\t\tthis.unitsToProcess[i] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "-\t\t\t\t\t", "-\t\t\t\t\t// only process requested units", "-\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "-\t\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "+\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "-\t\t\t\t\t\t// requested AST", "-\t\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "-\t\t\t\t\t\tif (source != null) {", "-\t\t\t\t\t\t\t// convert AST", "-\t\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "-\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "-\t\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "-\t\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "-\t\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "-\t\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "-\t\t\t\t\t\t\tast.setBindingResolver(resolver);", "-\t\t\t\t\t\t\tconverter.setAST(ast);", "-\t\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "-\t\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "-\t\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "-\t\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t// pass it to requestor", "-\t\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t} ", "+\t\t\t\t\t// requested AST", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();\t\t\t\t\t", "+\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "+\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "+\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "+\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "+\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t// requested binding", "-\t\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "-\t\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "-\t\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} ", "+\t\t\t\t\t", "+\t\t\t\t\t// requested binding", "+\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "+\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "+\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} else if (key instanceof ArrayList) {", "+\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "+\t\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t} else if (key instanceof ArrayList) {", "-\t\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "-\t\t\t\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "+\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "+\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "-\t\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "-\t\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "-\t\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "+/*\tCode used to fault in types and resolve which is no longer necessary as all questions asked to forward references are", "+ * lazily resolved.", "+ * Code used to be:", "+\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "+\t\t\t\t\t   ...", "+", "-/*", "+", "-\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e11e546790c769763713c1517af11818", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "058f4956c302999db0dab277cf91883f2d016e2b", "commitAfterChange": "27d9d524a3b624cfc1260a727d1dfb92d53ae22a", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "signatureAfterChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "diff": ["-\t\t\t\treportIllegalCast(scope, castType, expressionType);", "-\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "+\t\t\t\tthis.bits |= UnsafeCastMask;", "-\t\t\t\t\tscope.problemReporter().unsafeCast(this, scope);", "+\t\t\t\t\tthis.bits |= UnsafeCastMask;", "-\t\t\tscope.problemReporter().unsafeCast(this, scope);", "+\t\t\tthis.bits |= UnsafeCastMask;"]}], "num": 60550}