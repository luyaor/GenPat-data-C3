{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0df00efc2696b6cc82383e7820c229e3", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1a3abbed962eb42fd080668c822c42c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "4412fcf3d168e3c5cc3b92c0b70e5bcf2376f3fc", "commitAfterChange": "8bf9953e1351888d8d186166d8f2000b15a08f07", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " public void locateMatches(SearchDocument[] searchDocuments) throws JavaModelException", "signatureAfterChange": " public void locateMatches(SearchDocument[] searchDocuments) throws CoreException", "diff": ["-public void locateMatches(SearchDocument[] searchDocuments) throws JavaModelException {", "+public void locateMatches(SearchDocument[] searchDocuments) throws CoreException {", "-\t\t\ttry {", "-\t\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();", "-\t\t\t\tresource = workingCopy != null ? workingCopy.getResource() : openable.getResource();", "-\t\t\t\tif (resource == null)", "-\t\t\t\t\tresource = javaProject.getProject(); // case of a file in an external jar", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {", "-\t\t\t\t\t// locate matches in previous project", "-\t\t\t\t\tif (previousJavaProject != null) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "-\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "-\t\t\t\t\t\t\t// problem with classpath in this project -> skip it", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tmatchSet.reset();", "+\t\t\tJavaProject javaProject = (JavaProject) openable.getJavaProject();", "+\t\t\tresource = workingCopy != null ? workingCopy.getResource() : openable.getResource();", "+\t\t\tif (resource == null)", "+\t\t\t\tresource = javaProject.getProject(); // case of a file in an external jar", "+\t\t\tif (!javaProject.equals(previousJavaProject)) {", "+\t\t\t\t// locate matches in previous project", "+\t\t\t\tif (previousJavaProject != null) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tlocateMatches(previousJavaProject, matchSet);", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// problem with classpath in this project -> skip it", "-\t\t\t\t\tpreviousJavaProject = javaProject;", "+\t\t\t\t\tmatchSet.reset();", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// file doesn't exist -> skip it", "-\t\t\t\tcontinue;", "+\t\t\t\tpreviousJavaProject = javaProject;", "-\t\t\t\tif (e.getException() instanceof CoreException) throw e;", "-\t\t\t\t// problem with classpath in last project -> skip it", "+\t\t\t\t// problem with classpath in last project -> ignore"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64c3fa8270c47141009047ccff61e1e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java", "commitBeforeChange": "4c1d7dbf50aec44bcaa78488f6494cabd5c936ec", "commitAfterChange": "1159f42f3e1e1aaac22ff9f396ef841945f2fbd4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public boolean contains(IResource resource)", "signatureAfterChange": " public boolean contains(IResource resource)", "diff": ["+\tswitch (resource.getType()) {", "+\t\tcase IResource.ROOT:", "+\t\tcase IResource.PROJECT:", "+\t\t\treturn true;", "+\t}", "+\t// file or folder", "-\t\tif (!resource.isAccessible()) return false;", "+", "-\t\t\t\tif (entryPath.isPrefixOf(path) ", "-\t\t\t\t\t\t&& (innerMostEntry == null || innerMostEntry.getPath().isPrefixOf(entryPath))) {", "+\t\t\t\tif ((innerMostEntry == null || innerMostEntry.getPath().isPrefixOf(entryPath))", "+\t\t\t\t\t\t&& entryPath.isPrefixOf(path)) {", "-\t\t\t\t\tbreak; // don't return here as we could have src=bin or lib=bin", "-\t\t\t\tif (innerMostEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {", "-\t\t\t\t\t// .class files are not visible in source folders ", "-\t\t\t\t\treturn !Util.isClassFileName(path.lastSegment());", "-\t\t\t\t} else {", "-\t\t\t\t\t// .java files are not visible in library folders", "-\t\t\t\t\treturn !Util.isJavaFileName(path.lastSegment());", "+\t\t\t\tif  (resource instanceof IFolder) {", "+\t\t\t\t\t // folders are always included in src/lib entries", "+\t\t\t\t\t return true;", "+\t\t\t\t}", "+\t\t\t\tswitch (innerMostEntry.getEntryKind()) {", "+\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE:", "+\t\t\t\t\t\t// .class files are not visible in source folders ", "+\t\t\t\t\t\treturn !Util.isClassFileName(path.lastSegment());", "+\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\t\t\t// .java files are not visible in library folders", "+\t\t\t\t\t\treturn !Util.isJavaFileName(path.lastSegment());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6fa9e926925da55904e71b7e531833dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaWorkspaceScope.java", "commitBeforeChange": "e4f6d0091f68bf4b6ecb46943ad5d4d6a5ce0095", "commitAfterChange": "3a73dbc8d9839c0eb87857ef97f640371d15a626", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": " public IPath[] enclosingProjectsAndJars()", "signatureAfterChange": " public IPath[] enclosingProjectsAndJars()", "diff": ["+ */", "-\tif (this.needsInitialize) {", "-\t\tthis.initialize(5);", "+\tif (this.enclosingPaths != null) {", "+\t\treturn this.enclosingPaths;", "-\treturn super.enclosingProjectsAndJars();", "+\tlong start = BasicSearchEngine.VERBOSE ? System.currentTimeMillis() : -1;", "+\ttry {", "+\t\tIJavaProject[] projects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();", "+\t\tSet paths = new HashSet(projects.length * 2);", "+\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "+\t\t\t", "+\t\t\t// Add project full path", "+\t\t\tIPath projectPath = javaProject.getProject().getFullPath();", "+\t\t\tpaths.add(projectPath);", "+", "+\t\t\t// Add project libraries paths", "+\t\t\tIClasspathEntry[] entries = javaProject.getResolvedClasspath();", "+\t\t\tfor (int j = 0, eLength = entries.length; j < eLength; j++) {", "+\t\t\t\tIClasspathEntry entry = entries[j];", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tObject target = JavaModel.getTarget(path, false/*don't check existence*/);", "+\t\t\t\t\tif (target instanceof IFolder) // case of an external folder", "+\t\t\t\t\t\tpath = ((IFolder) target).getFullPath();", "+\t\t\t\t\tpaths.add(entry.getPath());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tIPath[] result = new IPath[paths.size()];", "+\t\tpaths.toArray(result);", "+\t\treturn this.enclosingPaths = result;", "+\t} catch (JavaModelException e) {", "+\t\tUtil.log(e, \"Exception while computing workspace scope's enclosing projects and jars\"); //$NON-NLS-1$", "+\t\treturn new IPath[0];", "+\t} finally {", "+\t\tif (BasicSearchEngine.VERBOSE) {", "+\t\t\tlong time = System.currentTimeMillis() - start;", "+\t\t\tint length = this.enclosingPaths == null ? 0 : this.enclosingPaths.length;", "+\t\t\tUtil.verbose(\"JavaWorkspaceScope.enclosingProjectsAndJars: \"+length+\" paths computed in \"+time+\"ms.\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ed1445c437efba0407e4a7c51b15a3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 57, "signatureBeforeChange": " \tprivate void updateClasspathMarkers(IResourceDelta delta, HashSet affectedProjects, Map preferredClasspaths, Map preferredOutputs)", "signatureAfterChange": "  \tprivate void validateClasspaths(IResourceDelta delta, HashSet affectedProjects)", "diff": ["-\t */", "-\tprivate void updateClasspathMarkers(IResourceDelta delta, HashSet affectedProjects, Map preferredClasspaths, Map preferredOutputs) {", "+\tprivate void validateClasspaths(IResourceDelta delta, HashSet affectedProjects) {", "-", "-\t", "-\t\t\t\t\t\t\t\tjavaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs); // in case .classpath got modified while closed", "+\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject); // in case .classpath got modified while closed", "-\t\t\t\t\t\t\t\taffectedProjects.add(project.getFullPath());", "-\t\t\t\t\t\t\t\t// flush classpath markers", "-\t\t\t\t\t\t\t\tjavaProject.", "-\t\t\t\t\t\t\t\t\tflushClasspathProblemMarkers(", "-\t\t\t\t\t\t\t\t\t\ttrue, // flush cycle markers", "-\t\t\t\t\t\t\t\t\t\ttrue  //flush classpath format markers", "-\t\t\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t// remove problems and tasks created  by the builder", "-\t\t\t\t\t\t\t\tJavaBuilder.removeProblemsAndTasksFor(project);", "+\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject); ", "+", "+\t\t\t\t\t\t\t\taffectedProjects.add(project.getFullPath());", "+\t\t\t\t\t\t\t} if (isJavaProject) {", "+\t\t\t\t\t\t\t\t// check if all entries exist", "+\t\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject); ", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "-\t\t\t\t\t\t\t\tjavaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, \ttrue/*generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);", "-\t\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t\t\t// project doesn't exist: ignore", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(project);", "+\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject); ", "-\t\t\t\t\tjavaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs);", "+\t\t\t\t\tthis.state.addClasspathValidation(javaProject); ", "-//\t\t\t\t/* check custom preference file change */", "-//\t\t\t\tif (file.getName().equals(JavaProject.PREF_FILENAME)) {", "-//\t\t\t\t\treconcilePreferenceFileUpdate(delta, file, project);", "-//\t\t\t\t\tbreak;", "-//\t\t\t\t}", "-\t\t\t\tupdateClasspathMarkers(children[i], affectedProjects, preferredClasspaths, preferredOutputs);", "+\t\t\t\tvalidateClasspaths(children[i], affectedProjects);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "965fac1b7998f555dbff7901759a8214", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java", "commitBeforeChange": "a7e6b3d174d33a8a3b8d03f466c6cb3381f5f0c9", "commitAfterChange": "2e2e66f7f68b994d0931afecfd3c1e559acd59d5", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r private void createTypeHierarchyBasedOnRegion(Vector allTypesInRegion)", "signatureAfterChange": "\r \tprivate void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion)", "diff": ["- */\r", "-private void createTypeHierarchyBasedOnRegion(Vector allTypesInRegion) {\r", "-\tint size = allTypesInRegion.size();\r", "-\tif (size != 0) {\r", "-\t\tthis.infoToHandle= new Hashtable(size);\r", "-\t}\r", "-\tVector temp = new Vector(size);\r", "-\ttypes : for (int i = 0; i < size; i++) {\r", "-\t\ttry {\r", "-\t\t\tIType type = (IType) allTypesInRegion.elementAt(i);\r", "-\t\t\tIGenericType info= (IGenericType) ((JavaElement) type).getRawInfo(); \r", "-\t\t\ttemp.addElement(info);\r", "-\t\t\tif (info.isBinaryType()) {\r", "-\t\t\t\tthis.infoToHandle.put(info, type.getParent());\r", "-\t\t\t}\r", "-\t\t\tworked(1);\r", "-\t\t} catch (JavaModelException npe) {\r", "-\t\t\tcontinue types;\r", "-\t\t}\r", "-\t}\r", "-\r", "-\tsize = temp.size();\r", "-\tif (size > 0) {\r", "-\t\tIGenericType[] genericTypes = new IGenericType[size];\r", "-\t\ttemp.copyInto(genericTypes);\r", "-\t\tIType focusType = this.getType();\r", "-\t\tif (focusType != null) {\r", "-\t\t\tthis.searchableEnvironment.unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();\r", "-\t\t}\r", "-\t\tthis.hierarchyResolver.resolve(genericTypes);\r", "-\t\tif (focusType != null) {\r", "-\t\t\tthis.searchableEnvironment.unitToLookInside = null;\r", "-\t\t}\r", "-\r", "-\t}\r", "-}\r", "+\t */\r", "+\tprivate void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {\r", "+\t\t\r", "+\t\tint size = allTypesInRegion.size();\r", "+\t\tif (size != 0) {\r", "+\t\t\tthis.infoToHandle = new HashMap(size);\r", "+\t\t}\r", "+\t\tArrayList temp = new ArrayList(size);\r", "+\t\ttypes : for (int i = 0; i < size; i++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tIType type = (IType) allTypesInRegion.get(i);\r", "+\t\t\t\tIGenericType info = (IGenericType) ((JavaElement) type).getRawInfo();\r", "+\t\t\t\ttemp.add(info);\r", "+\t\t\t\tif (info.isBinaryType()) {\r", "+\t\t\t\t\tthis.infoToHandle.put(info, type.getParent());\r", "+\t\t\t\t}\r", "+\t\t\t\tworked(1);\r", "+\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\tcontinue types;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tsize = temp.size();\r", "+\t\tif (size > 0) {\r", "+\t\t\tIGenericType[] genericTypes = new IGenericType[size];\r", "+\t\t\ttemp.toArray(genericTypes);\r", "+\t\t\tIType focusType = this.getType();\r", "+\t\t\tif (focusType != null) {\r", "+\t\t\t\tthis.searchableEnvironment.unitToLookInside =\r", "+\t\t\t\t\t(CompilationUnit) focusType.getCompilationUnit();\r", "+\t\t\t}\r", "+\t\t\tthis.hierarchyResolver.resolve(genericTypes);\r", "+\t\t\tif (focusType != null) {\r", "+\t\t\t\tthis.searchableEnvironment.unitToLookInside = null;\r", "+\t\t\t}\r", "+\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9eeae7300cc56c69d499f518261e186", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "94923d3acfa7fb7266e9eb4199d83aab0f8b9fca", "commitAfterChange": "3300bd0a2560c278ec7d1063d301ade85a3f2d14", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor)", "diff": ["-\tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor) throws JavaModelException {", "+\tprivate boolean createExternalArchiveDelta(IProgressMonitor monitor) {", "-\t\t\t\t\t\tIClasspathEntry[] classpath = project.getResolvedClasspath(true);", "-\t\t\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){", "-\t\t\t\t\t\t\tif (classpath[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY){", "-\t\t\t\t\t\t\t\tarchivePathsToRefresh.add(classpath[j].getPath());", "+\t\t\t\t\t\tIClasspathEntry[] classpath;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tclasspath = project.getResolvedClasspath(true);", "+\t\t\t\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){", "+\t\t\t\t\t\t\t\tif (classpath[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY){", "+\t\t\t\t\t\t\t\t\tarchivePathsToRefresh.add(classpath[j].getPath());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// project doesn't exist -> ignore", "-\t\t\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();", "+\t\t\t\t\t\tIJavaProject[] projects;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tprojects = manager.getJavaModel().getOldJavaProjectsList();", "+\t\t\t\t\t\t} catch (JavaModelException e1) {", "+\t\t\t\t\t\t\t// cannot retrieve old projects list -> ignore", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tclasspath = project.getResolvedClasspath(true);", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tclasspath = project.getResolvedClasspath(true);", "+\t\t\t\t\t\t\t} catch (JavaModelException e2) {", "+\t\t\t\t\t\t\t\t// project doesn't exist -> ignore", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t}", "-\t\tIJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();", "+\t\tIJavaProject[] projects;", "+\t\ttry {", "+\t\t\tprojects = manager.getJavaModel().getOldJavaProjectsList();", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// cannot retrieve old projects list -> give up", "+\t\t\treturn false;", "+\t\t}", "-\t\t\tIClasspathEntry[] entries = project.getResolvedClasspath(true);", "+\t\t\tIClasspathEntry[] entries;", "+\t\t\ttry {", "+\t\t\t\tentries = project.getResolvedClasspath(true);", "+\t\t\t} catch (JavaModelException e1) {", "+\t\t\t\t// project does not exist -> ignore", "+\t\t\t\tcontinue;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "becb63d5411d5f4bd8c15dec3310e443", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "9edf0a990e69fc752ead21c476a00fb874aa8f40", "commitAfterChange": "a5351a8c92738db988d5e1c19e4b7b0af64944e3", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 21, "signatureBeforeChange": "\r private void initializeRoots()", "signatureAfterChange": "\r \t\r private void initializeRoots(IJavaModel model)", "diff": ["-\t}\r", "-private void initializeRoots() {\r", "-\tthis.roots = new HashMap();\r", "-\tthis.otherRoots = new HashMap();\r", "-\tIJavaProject[] projects;\r", "-\ttry {\r", "-\t\tprojects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();\r", "-\t} catch (JavaModelException e) {\r", "-\t\t// nothing can be done\r", "-\t\treturn;\r", "-\t}\r", "-\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "-\t\tIJavaProject project = projects[i];", "-\t\tIClasspathEntry[] classpath;\r", "-\t\t\tclasspath = project.getResolvedClasspath(true);\r", "-\t\t} catch (JavaModelException e) {\r", "-\t\t\t// continue with next project\r", "-\t\t\tcontinue;\r", "-\t\tfor (int j= 0, classpathLength = classpath.length; j < classpathLength; j++) {", "-\t\t\tIClasspathEntry entry = classpath[j];\r", "-\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) continue;\r", "-\t\t\tIPath path = entry.getPath();\r", "-\t\t\tif (this.roots.get(path) == null) {\r", "-\t\t\t\tthis.roots.put(path, project);\r", "-\t\t\t} else {\r", "-\t\t\t\tHashSet set = (HashSet)this.otherRoots.get(path);\r", "-\t\t\t\tif (set == null) {\r", "-\t\t\t\t\tset = new HashSet();\r", "-\t\t\t\t\tthis.otherRoots.put(path, set);\r", "-\t\t\t\t}\r", "-\t\t\t\tset.add(project);\r", "-\t\t\t}", "-\t\t}", "+private void initializeRoots(IJavaModel model) {\r", "+\tthis.roots = new HashMap();\r", "+\tthis.otherRoots = new HashMap();\r", "+\tIJavaProject[] projects;\r", "+\ttry {\r", "+\t\tprojects = model.getJavaProjects();\r", "+\t} catch (JavaModelException e) {\r", "+\t\t// nothing can be done\r", "+\t\treturn;\r", "+\t}\r", "+\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "+\t\tIJavaProject project = projects[i];\r", "+\t\tIClasspathEntry[] classpath;\r", "+\t\ttry {\r", "+\t\t\tclasspath = project.getResolvedClasspath(true);\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// continue with next project\r", "+\t\t\tcontinue;\r", "+\t\t}\r", "+\t\tfor (int j= 0, classpathLength = classpath.length; j < classpathLength; j++) {\r", "+\t\t\tIClasspathEntry entry = classpath[j];\r", "+\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) continue;\r", "+\t\t\tIPath path = entry.getPath();\r", "+\t\t\tif (this.roots.get(path) == null) {\r", "+\t\t\t\tthis.roots.put(path, project);\r", "+\t\t\t} else {\r", "+\t\t\t\tHashSet set = (HashSet)this.otherRoots.get(path);\r", "+\t\t\t\tif (set == null) {\r", "+\t\t\t\t\tset = new HashSet();\r", "+\t\t\t\t\tthis.otherRoots.put(path, set);\r", "+\t\t\t\t}\r", "+\t\t\t\tset.add(project);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe7aee2170ca854174f01af532fffaef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java", "commitBeforeChange": "cbd955fb2a4598f2699dd195e39c5cb17dbd967e", "commitAfterChange": "4923f7bf4c07fe4ddafc97e39d6c8df65941fe37", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public boolean contains(IResource resource)", "signatureAfterChange": " public boolean contains(IResource resource)", "diff": ["+\tIJavaProject[] projects;", "-\t\tIPath path = resource.getFullPath();", "-\t\tIJavaProject[] projects = this.getJavaProjects();", "-\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\tIJavaProject project = projects[i];", "-\t\t\tIClasspathEntry[] classpath = project.getResolvedClasspath(true);", "-\t\t\t", "-\t\t\tIPath output = project.getOutputLocation();", "-\t\t\tIPath innerMostOutput = output.isPrefixOf(path) ? output : null;", "-\t\t\tIClasspathEntry innerMostEntry = null;", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++) {", "-\t\t\t\tIClasspathEntry entry = classpath[j];", "-", "-\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\tif ((innerMostEntry == null || innerMostEntry.getPath().isPrefixOf(entryPath))", "-\t\t\t\t\t\t&& entryPath.isPrefixOf(path)) {", "-\t\t\t\t\tinnerMostEntry = entry;", "-\t\t\t\t}", "-\t\t\t\tIPath entryOutput = classpath[j].getOutputLocation();", "-\t\t\t\tif (entryOutput != null && entryOutput.isPrefixOf(path)) {", "-\t\t\t\t\tinnerMostOutput = entryOutput;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (innerMostEntry != null) {", "-\t\t\t\t// special case prj==src and nested output location", "-\t\t\t\tif (innerMostOutput != null && innerMostOutput.segmentCount() > 1 // output isn't project", "-\t\t\t\t\t\t&& innerMostEntry.getPath().segmentCount() == 1) { // 1 segment must be project name", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\tif  (resource instanceof IFolder) {", "-\t\t\t\t\t // folders are always included in src/lib entries", "-\t\t\t\t\t return true;", "-\t\t\t\t}", "-\t\t\t\tswitch (innerMostEntry.getEntryKind()) {", "-\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE:", "-\t\t\t\t\t\t// .class files are not visible in source folders ", "-\t\t\t\t\t\treturn !Util.isClassFileName(path.lastSegment());", "-\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "-\t\t\t\t\t\t// .java files are not visible in library folders", "-\t\t\t\t\t\treturn !Util.isJavaFileName(path.lastSegment());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (innerMostOutput != null) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\treturn true;", "+\t\tprojects = this.getJavaProjects();", "+\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\tJavaProject project = (JavaProject)projects[i];", "+\t\tif (!project.contains(resource)) {", "+\t\t\treturn false;", "+\t\t}", "+\t}", "+\treturn true;"]}], "num": 59220}