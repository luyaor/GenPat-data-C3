{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6815562b80da9f8b298560fcdaa30c2b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4e21ca1b329d154fab622d7715d9e22", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java", "commitBeforeChange": "d87930da4cf6fdf6432300f38d83b317530103f3", "commitAfterChange": "397b4e3ed0763b9154b9457179f3bf00dfce6fda", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r protected char[][][] collectSuperTypeNames(char[] declaringQualification, char[] declaringSimpleName, int matchMode, LookupEnvironment env)", "signatureAfterChange": "\r protected char[][][] collectSuperTypeNames(char[] declaringQualification, char[] declaringSimpleName, int matchMode, LookupEnvironment env)", "diff": ["-\tchar[][] declaringTypeName = null;\r", "-\tif (declaringQualification != null \r", "-\t\t\t&& declaringSimpleName != null\r", "-\t\t\t&& matchMode == EXACT_MATCH) {\r", "-\t\tchar[][] qualification = CharOperation.splitOn('.', declaringQualification);\r", "-\t\tdeclaringTypeName = CharOperation.arrayConcat(qualification, declaringSimpleName);\r", "-\t}\r", "-\tif (declaringTypeName != null) {\r", "-\t\tfor (int i = 0, max = declaringTypeName.length; i < max; i++) {\r", "-\t\t\tReferenceBinding matchingDeclaringType = env.askForType(declaringTypeName);\r", "-\t\t\tif (matchingDeclaringType != null \r", "-\t\t\t\t&& (matchingDeclaringType.isValidBinding()\r", "-\t\t\t\t\t|| matchingDeclaringType.problemId() != ProblemReasons.NotFound)) {\r", "-\t\t\t\treturn this.collectSuperTypeNames(matchingDeclaringType);\r", "-\t\t\t}\r", "-\t\t\t// if nothing is in the cache, it could have been a member type (A.B.C.D --> A.B.C$D)\r", "-\t\t\tint last = declaringTypeName.length - 1;\r", "-\t\t\tif (last == 0) break; \r", "-\t\t\tdeclaringTypeName[last-1] = CharOperation.concat(declaringTypeName[last-1], declaringTypeName[last], '$'); // try nested type\r", "-\t\t\tdeclaringTypeName = CharOperation.subarray(declaringTypeName, 0, last);\r", "+\ttry {\r", "+\t\tchar[][] declaringTypeName = null;\r", "+\t\tif (declaringQualification != null \r", "+\t\t\t\t&& declaringSimpleName != null\r", "+\t\t\t\t&& matchMode == EXACT_MATCH) {\r", "+\t\t\tchar[][] qualification = CharOperation.splitOn('.', declaringQualification);\r", "+\t\t\tdeclaringTypeName = CharOperation.arrayConcat(qualification, declaringSimpleName);\r", "-\t\treturn NOT_FOUND_DECLARING_TYPE; // the declaring type was not found \r", "-\t} else {\r", "-\t\t// non exact match: use the null value so that matches is more tolerant\r", "+\t\tif (declaringTypeName != null) {\r", "+\t\t\tfor (int i = 0, max = declaringTypeName.length; i < max; i++) {\r", "+\t\t\t\tReferenceBinding matchingDeclaringType = env.askForType(declaringTypeName);\r", "+\t\t\t\tif (matchingDeclaringType != null \r", "+\t\t\t\t\t&& (matchingDeclaringType.isValidBinding()\r", "+\t\t\t\t\t\t|| matchingDeclaringType.problemId() != ProblemReasons.NotFound)) {\r", "+\t\t\t\t\treturn this.collectSuperTypeNames(matchingDeclaringType);\r", "+\t\t\t\t}\r", "+\t\t\t\t// if nothing is in the cache, it could have been a member type (A.B.C.D --> A.B.C$D)\r", "+\t\t\t\tint last = declaringTypeName.length - 1;\r", "+\t\t\t\tif (last == 0) break; \r", "+\t\t\t\tdeclaringTypeName[last-1] = CharOperation.concat(declaringTypeName[last-1], declaringTypeName[last], '$'); // try nested type\r", "+\t\t\t\tdeclaringTypeName = CharOperation.subarray(declaringTypeName, 0, last);\r", "+\t\t\t}\r", "+\t\t\treturn NOT_FOUND_DECLARING_TYPE; // the declaring type was not found \r", "+\t\t} else {\r", "+\t\t\t// non exact match: use the null value so that matches is more tolerant\r", "+\t\t\treturn null;\r", "+\t\t}\r", "+\t} catch (AbortCompilation e) {\r", "+\t\t// classpath problem: default to null value so that matches is more tolerant\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e68eaab5dc293b7bd2f3544064e2d146", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "e8cc2a8f8e9efcff6e76a3ee15d5b53d1a958057", "commitAfterChange": "7e8c39a9e3d7dea3d8b022efbc3b049165785892", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic static CompilationUnitDeclaration buildCompilationUnit( \t\tISourceType[] sourceTypes, \t\tint flags, \t\tProblemReporter problemReporter, \t\tCompilationResult compilationResult)", "signatureAfterChange": " \tpublic static CompilationUnitDeclaration buildCompilationUnit( \t\tISourceType[] sourceTypes, \t\tint flags, \t\tProblemReporter problemReporter, \t\tCompilationResult compilationResult)", "diff": ["-\t\treturn ", "-\t\t\tnew SourceTypeConverter(flags, problemReporter).convert(sourceTypes, compilationResult);", "+\t\ttry {", "+\t\t\treturn new SourceTypeConverter(flags, problemReporter).convert(sourceTypes, compilationResult);", "+\t\t} catch (JavaModelException e) {", "+\t\t\treturn null;", "+\t\t}"]}], "num": 68355}