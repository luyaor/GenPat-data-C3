{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "74b23a6cfa7689fbfd7d04134ed55055", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9194c824bbe1989aee650a96b32fbd21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/TypeNameMatchRequestorWrapper.java", "commitBeforeChange": "c93b7fc02953335388042ab5bd4ec34f70464821", "commitAfterChange": "c9213ae595dd32af0d2b3bd7c31b733e8b1d0dd1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access)", "signatureAfterChange": " public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access)", "diff": ["-\t\tif (this.scope instanceof JavaSearchScope) {", "-\t\t\tString projectPath = ((JavaSearchScope)this.scope).projectPathFor(path);", "-\t\t\tif (projectPath == null) {", "-\t\t\t\tif (this.workingCopies == null) {", "-\t\t\t\t\t// Internal resource, project path won't be store as it can be computed from path", "-\t\t\t\t\tTypeNameMatch match = new TypeNameMatch(modifiers, packageName, simpleTypeName, enclosingTypeNames, path);", "-\t\t\t\t\tthis.requestor.acceptTypeNameMatch(match);", "-\t\t\t\t} else {", "-\t\t\t\t\t// Internal working copy, project path won't be store as it can be computed from path", "-\t\t\t\t\tWorkingCopiesTypeNameMatch match = new WorkingCopiesTypeNameMatch(modifiers, packageName, simpleTypeName, enclosingTypeNames, path, this.workingCopies);", "-\t\t\t\t\tthis.requestor.acceptTypeNameMatch(match);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// External resource, store specific project path", "-\t\t\t\tExternalTypeNameMatch match = new ExternalTypeNameMatch(modifiers, packageName, simpleTypeName, enclosingTypeNames, path, projectPath);", "-\t\t\t\tthis.requestor.acceptTypeNameMatch(match);", "+//\t\tif (this.handleFactory == null) {", "+//\t\t\tthis.handleFactory = new HandleFactory();", "+//\t\t}", "+//\t\tOpenable openable = this.handleFactory.createOpenable(path, this.scope);", "+//\t\tif (openable != null) {", "+//\t\t\ttry {", "+//\t\t\t\tIType type = null;", "+//\t\t\t\tswitch (openable.getElementType()) {", "+//\t\t\t\t\tcase IJavaElement.CLASS_FILE:", "+//\t\t\t\t\t\ttype = ((IClassFile)openable).getType();", "+//\t\t\t\t\t\tbreak;", "+//\t\t\t\t\tcase IJavaElement.COMPILATION_UNIT:", "+//\t\t\t\t\t\tint length = enclosingTypeNames == null ? 0 : enclosingTypeNames.length;", "+//\t\t\t\t\t\tif (length == 0) {", "+//\t\t\t\t\t\t\ttype = ((ICompilationUnit)openable).getType(new String(simpleTypeName));", "+//\t\t\t\t\t\t} else {", "+//\t\t\t\t\t\t\ttype = ((ICompilationUnit)openable).getType(new String(enclosingTypeNames[0]));", "+//\t\t\t\t\t\t\tfor (int i=1; i<length; i++) {", "+//\t\t\t\t\t\t\t\ttype = type.getType(new String(enclosingTypeNames[i]));", "+//\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t\ttype = type.getType(new String(simpleTypeName));", "+//\t\t\t\t\t\t}", "+//\t\t\t\t\t\tbreak;", "+//\t\t\t\t}", "+//\t\t\t\tif (type != null) {", "+//\t\t\t\t\tthis.requestor.acceptTypeNameMatch(new TypeNameMatch(type, modifiers));", "+//\t\t\t\t}", "+//\t\t\t} catch (JavaModelException e) {", "+//\t\t\t\t// skip", "+//\t\t\t}", "+//\t\t}", "+\t\ttry {", "+\t\t\tint separatorIndex= path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);", "+\t\t\tIType type = separatorIndex == -1", "+\t\t\t\t? createTypeFromPath(path, new String(simpleTypeName), enclosingTypeNames)", "+\t\t\t\t: createTypeFromJar(path, separatorIndex);", "+\t\t\tif (type != null) {", "+\t\t\t\tthis.requestor.acceptTypeNameMatch(new TypeNameMatch(type, modifiers));", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// skip"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "adef4a599a4cff5d2d043dc199fa442a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "333e183ebe56f659f1083c452edbf2ef4089fa56", "commitAfterChange": "f09e5b387a9b27a1161db6587b5598aa2acd37a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 2, "signatureBeforeChange": " int matchOverriddenMethod(ReferenceBinding type)", "signatureAfterChange": " private boolean isErasureMethodOverride(ReferenceBinding type, MethodBinding method)", "diff": ["+ */", "+private boolean isErasureMethodOverride(ReferenceBinding type, MethodBinding method) {", "+\tif (type == null) return false;", "+", "+\t// matches superclass", "+\tif (!type.isInterface() && !CharOperation.equals(type.compoundName, TypeConstants.JAVA_LANG_OBJECT)) {", "+\t\tReferenceBinding superClass = type.superclass();", "+\t\tif (superClass.isParameterizedType()) {", "+\t\t\tTypeBinding erasure = ((ParameterizedTypeBinding)superClass).erasure();", "+\t\t\tif (erasure instanceof ReferenceBinding) {", "+\t\t\t\tMethodBinding[] methods = superClass.getMethods(this.pattern.selector);", "+\t\t\t\tint length = methods.length;", "+\t\t\t\tfor (int i = 0; i<length; i++) {", "+\t\t\t\t\tif (methods[i].areParametersEqual(method)) return true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isErasureMethodOverride(superClass, method)) {", "+\t\t\treturn true;", "+\t\t}", "+\t}", "+", "+\t// matches interfaces", "+\tReferenceBinding[] interfaces = type.superInterfaces();", "+\tif (interfaces == null) return false;", "+\tint iLength = interfaces.length;", "+\tfor (int i = 0; i<iLength; i++) {", "+\t\tif (interfaces[i].isParameterizedType()) {", "+\t\t\tTypeBinding erasure = ((ParameterizedTypeBinding)interfaces[i]).erasure();", "+\t\t\tif (erasure instanceof ReferenceBinding) {", "+\t\t\t\tMethodBinding[] methods = ((ReferenceBinding)erasure).getMethods(this.pattern.selector);", "+\t\t\t\tint length = methods.length;", "+\t\t\t\tfor (int j = 0; j<length; j++) {", "+\t\t\t\t\tif (methods[i].areParametersEqual(method)) return true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isErasureMethodOverride(interfaces[i], method)) {", "+\t\t\treturn true;", "+\t\t}", "+\t}", "+\treturn false;", "+}", "- */", "-int matchOverriddenMethod(ReferenceBinding type) {", "-\tif (type == null) return INACCURATE_MATCH;", "-\tint level = IMPOSSIBLE_MATCH;", "-", "-\t// matches superclass", "-\tif (!type.isInterface() && !CharOperation.equals(type.compoundName, TypeConstants.JAVA_LANG_OBJECT)) {", "-\t\tif (type.superclass().isParameterizedType()) {", "-\t\t\tTypeBinding erasure = ((ParameterizedTypeBinding)type.superclass()).erasure();", "-\t\t\tif (erasure instanceof ReferenceBinding) {", "-\t\t\t\tMethodBinding[] methods = ((ReferenceBinding)erasure).getMethods(this.pattern.selector);", "-\t\t\t\tint length = methods.length;", "-\t\t\t\tfor (int i = 0; i<length && level == IMPOSSIBLE_MATCH; i++) {", "-\t\t\t\t\tlevel = matchMethod(methods[i]);", "-\t\t\t\t}", "-\t\t\t\tif (level != IMPOSSIBLE_MATCH) return level;", "-\t\t\t}", "-\t\t}", "-\t\tlevel = matchOverriddenMethod(type.superclass());", "-\t\tif (level != IMPOSSIBLE_MATCH) return level;", "-\t}", "-", "-\t// matches interfaces", "-\tReferenceBinding[] interfaces = type.superInterfaces();", "-\tif (interfaces == null) return INACCURATE_MATCH;", "-\tint iLength = interfaces.length;", "-\tfor (int i = 0; i<iLength; i++) {", "-\t\tif (interfaces[i].isParameterizedType()) {", "-\t\t\tTypeBinding erasure = ((ParameterizedTypeBinding)interfaces[i]).erasure();", "-\t\t\tif (erasure instanceof ReferenceBinding) {", "-\t\t\t\tMethodBinding[] methods = ((ReferenceBinding)erasure).getMethods(this.pattern.selector);", "-\t\t\t\tint mLength = methods.length;", "-\t\t\t\tfor (int j = 0; j<mLength && level == IMPOSSIBLE_MATCH; j++) {", "-\t\t\t\t\tlevel = matchMethod(methods[j]);", "-\t\t\t\t}", "-\t\t\t\tif (level != IMPOSSIBLE_MATCH) return level;", "-\t\t\t}", "-\t\t}", "-\t\tlevel = matchOverriddenMethod(interfaces[i]);", "-\t\tif (level != IMPOSSIBLE_MATCH) return level;", "-\t}", "-\treturn IMPOSSIBLE_MATCH;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d667b14552c85471146e5b961b75284b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java", "commitBeforeChange": "841af85ab99e4b15e2a10d11233f480a3f381ff0", "commitAfterChange": "01bd53f266d07ca177ff8e7fb927b7206b4c562d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue)", "signatureAfterChange": " public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue)", "diff": ["+ */", "+public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue) {", "+", "+\tif (this.alreadyCompletedFieldInitialization) {", "+\t\treturn super.add(expression, bracketBalanceValue);", "+\t} else {", "+\t\tif (expression.sourceEnd > 0)", "+\t\t\t\tthis.alreadyCompletedFieldInitialization = true;", "+\t\t// else we may still be inside the initialization, having parsed only a part of it yet", "+\t\tthis.fieldDeclaration.initialization = expression;", "+\t\tthis.fieldDeclaration.declarationSourceEnd = expression.sourceEnd;", "+\t\tthis.fieldDeclaration.declarationEnd = expression.sourceEnd;", "+\t\treturn this.initializer = new RecoveredLambdaExpression(expression, this, bracketBalanceValue);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa99a3446c926daceebff2f4dc8bccd7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "1585d95aacd546d0fef8e25ddee2f5a6f64f7c62", "commitAfterChange": "bcf6d39cea27ed7bf3bf85709bd7e60dc5605058", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 72, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tboolean varargsStatus = visible[0].isVarargs();", "-\t\tfor (int i = 1; i < visibleSize; i++) {", "-\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "-\t\t\t\t// visible can be a mix of fixed & variable arity methods, so re-check the varargs methods but consider their last arg as a fixed array", "-\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "-\t\t\t\tint newSize = 0;", "-\t\t\t\tint argLength = argumentTypes.length;", "-\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "-\t\t\t\t\tif (visible[j].isVarargs())", "-\t\t\t\t\t\tif (visible[j].parameters.length != argLength", "-\t\t\t\t\t\t\t|| !argumentTypes[argLength - 1].isCompatibleWith(visible[j].parameters[argLength - 1]))", "-\t\t\t\t\t\t\t\tcontinue; // forget this varargs method since its last arg is not an exact match", "-\t\t\t\t\ttemp[newSize++] = visible[j];", "-\t\t\t\t}", "-\t\t\t\tvisible = temp;", "-\t\t\t\tvisibleSize = newSize;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "+\t\tint[] compatibilityLevels = new int[visibleSize];", "+\t\tfor (int i = 0; i < visibleSize; i++)", "+\t\t\tcompatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);", "-\t\tMethodBinding method = null;", "-\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "-\t\t\tmethod = visible[i];", "-\t\t\tfor (int j = 0; j < visibleSize; j++) {", "-\t\t\t\tif (i == j) continue;", "-\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "-\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "-\t\t\t\t\t\tint paramLength = method.parameters.length;", "-\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "-\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "+\t\tfor (int level = 0; level <= 2; level++) {", "+\t\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "+\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now", "+\t\t\t\tMethodBinding method = visible[i];", "+\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\t\tif (i == j || compatibilityLevels[j] != level) continue;", "+\t\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "+\t\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "+\t\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "+\t\t\t\t\t\t\tint paramLength = method.parameters.length;", "+\t\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "+\t\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "+\t\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "+\t\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "+\t\t\t\treturn method;", "-\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\treturn method;"]}], "num": 1486}