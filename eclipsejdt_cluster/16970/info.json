{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8501e4157f26c989d1f88738a1939dfb", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76d5505d77ef75b272d246167993a8a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "354ebb443c1299f35a4e7d9feb7df720666960e5", "commitAfterChange": "f5d7f3f14e69a955635d98e0e88aeb491988cae5", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 117, "signatureBeforeChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["-\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "-\t\t\t\t\tif (shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "+\t\t\t\t\tif (context.stepCompleted >= InferenceContext18.TYPE_INFERRED)", "-\t\t\t\t\t", "+\t\t\t\t\t// Next 6 lines have dubious sanction. Needs a rigorous solution.", "+\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (!shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tif (((Invocation) site).arguments()[i] instanceof ReferenceExpression)", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\treturn NOT_COMPATIBLE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e70eef0bdfc801fdaa76d4bfd8a1e08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "1a542c460a449efbae14d1057ba233825602248d", "commitAfterChange": "1ddc6abfe5d6cd8ad8c71d5100cfa53f4e84487a", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 119, "signatureBeforeChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["-\t\t\t\tMethodBinding shallowOriginal = method.shallowOriginal();", "-\t\t\t\t\t// Next 6 lines have dubious sanction. Needs a rigorous solution.", "-\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "-\t\t\t\t\tif (!shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tif (((Invocation) site).arguments()[i] instanceof ReferenceExpression)", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\treturn NOT_COMPATIBLE;", "-\t\t\t\t\t/* We ask the inverted question here, because we do want to check compatibility against lambdas and reference expressions that are not pertinent to", "-\t\t\t\t\t  applicability on account of being type elided and not being an exact method reference respectively i.e if we call ", "-\t\t\t\t\t  argument.isPertinentToApplicability(shallowParameter, shallowOriginal), it will answer true if type elided and we will miss catching incompatibilities.", "-\t\t\t\t\t*/ ", "+\t\t\t\t\tcontinue; // Engine has already asserted potential compatibility and that is all we can do."]}], "num": 16970}