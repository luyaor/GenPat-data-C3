{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "944448519397b07bc1e130b6e2157c7f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02edce0b4682c2df399d7bdfa07b2949", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "04b81cf15831bfe4330d81980faeafc08a8dde64", "commitAfterChange": "2648bf4db83bb49e8d037c44e11a0a6a32668be2", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\t\t", "+\t\t\t\t// all classpaths in the workspace are going to be resolved, ensure that containers are initialized in one batch", "+\t\t\t\tmanager.batchContainerInitializations = true; ", "+\t\t\t\t", "+\t\t\t\t// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413)", "+\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();", "+\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\tIClasspathEntry[] classpath = ((JavaProject) projects[i]).getResolvedClasspath();", "+\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {", "+\t\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "+\t\t\t\t\t\t\tif (entry.getSourceAttachmentPath() != null)", "+\t\t\t\t\t\t\t\tUtil.setSourceAttachmentProperty(entry.getPath(), null);", "+\t\t\t\t\t\t\t// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// initialize delta state", "+\t\t\t\tmanager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment proprties", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac99193536c43ef6f9eb831a2bf5466a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java", "commitBeforeChange": "9170036b60b531a506b4ffe0efeda8e18d918bef", "commitAfterChange": "f8aee71b6b129d09f997301cd8500148a6feb325", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprotected void assertSearchResults(String message, String expected, JavaSearchResultCollector collector)", "signatureAfterChange": " \tprotected void assertSearchResults(String message, String expected, JavaSearchResultCollector collector)", "diff": ["+\t\t\tif (this.workingCopies != null) {", "+\t\t\t\tint length = this.workingCopies.length;", "+\t\t\t\tString[] sources = new String[length*2];", "+\t\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\t\tsources[i*2] = this.workingCopies[i].getPath().toString();", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tsources[i*2+1] = this.workingCopies[i].getSource();", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// ignore", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tSystem.out.println(\"--------------------------------------------------------------------------------\");", "+\t\t\t\tfor (int i=0; i<length; i+=2) {", "+\t\t\t\t\tSystem.out.println(sources[i]);", "+\t\t\t\t\tSystem.out.println(sources[i+1]);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fccd9d80889ff927c0c66de8b25160e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e87f51d941d6cbe203d8b543bd1f01e26d5c134d", "commitAfterChange": "1ffd151549eccf4f346b9688b80b9066e8dc6a10", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "diff": ["+\t\tif (SearchEngine.VERBOSE) {\r", "+\t\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$\r", "+\t\t\tfor (int i = 0, length = filePaths.length; i < length; i++) {\r", "+\t\t\t\tString path = filePaths[i];\r", "+\t\t\t\tSystem.out.println(\"\\t\" + path);\r", "+\t\t\t}\r", "+\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$\r", "+\t\t\tif (workingCopies != null) {\r", "+\t\t\t\t System.out.println(\" and working copies [\"); //$NON-NLS-1$\r", "+\t\t\t\tfor (int i = 0, length = workingCopies.length; i < length; i++) {\r", "+\t\t\t\t\tIWorkingCopy wc = workingCopies[i];\r", "+\t\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement)wc).toStringWithAncestors()); //$NON-NLS-1$\r", "+\t\t\t\t}\r", "+\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r"]}], "num": 43107}