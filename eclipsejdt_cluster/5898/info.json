{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b2a44e513d2caaa5d74b1568b6dc1718", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4fb9b0e75bf9a1745a01d6ed5930ada9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "4d4c077960caad3dac6f1440a1eec3349b581bc3", "commitAfterChange": "84e94fe061dc975da80dda85572c99f5b95d09f2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private IIndex[] computeIndexes()", "signatureAfterChange": " private void initializeIndexKeys()", "diff": ["-private IIndex[] computeIndexes() {", "+private void initializeIndexKeys() {", "-\tboolean areAllIndexesReady = true;", "-\t", "-\tArrayList indexesInScope = new ArrayList();", "+\tArrayList requiredIndexKeys = new ArrayList();", "-\t\t\tIIndex index = this.indexManager.getIndex(path, true /*reuse index file*/, false /*do not create if none*/);", "-\t\t\tif (index == null) areAllIndexesReady = false;", "-\t\t\tif (index != null && indexesInScope.indexOf(index) == -1) {", "-\t\t\t\tindexesInScope.add(index);", "+\t\t\tif (requiredIndexKeys.indexOf(path) == -1) {", "+\t\t\t\trequiredIndexKeys.add(path);", "-\tIIndex[] availableIndexes = new IIndex[indexesInScope.size()];", "-\tindexesInScope.toArray(availableIndexes);", "-", "-\t// only cache available indexes if all of them were ready (if not, next call will recompute)", "-\tif (areAllIndexesReady) this.indexes = availableIndexes;", "-\treturn availableIndexes;", "+\tthis.indexKeys = new IPath[requiredIndexKeys.size()];", "+\trequiredIndexKeys.toArray(this.indexKeys);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3f51eef9c945b2a1e36d6b1fc9c926f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "faf66774125063b945b9059a75de1139a8d6264a", "commitAfterChange": "df7c7252bb25d1124375e0f48ecdac3fe62712d0", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private void computeIndexes()", "signatureAfterChange": " private IIndex[] computeIndexes()", "diff": ["-private void computeIndexes() {", "+ */", "+private IIndex[] computeIndexes() {", "+\t", "+\tboolean areAllIndexesReady = true;", "+\t", "+\t\t\tif (index == null) areAllIndexesReady = false;", "-\tthis.indexes = new IIndex[indexesInScope.size()];", "-\tindexesInScope.toArray(this.indexes);", "+\tIIndex[] availableIndexes = new IIndex[indexesInScope.size()];", "+\tindexesInScope.toArray(availableIndexes);", "+", "+\t// only cache available indexes if all of them were ready (if not, next call will recompute)", "+\tif (areAllIndexesReady) this.indexes = availableIndexes;", "+\treturn availableIndexes;"]}], "num": 5898}