{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "eee51700eb82582311a5593bd9d43fe0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39a0759d918f30470e101b3de53d40b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "b9de5f3466a9b4d6687de837720c445097067b16", "commitAfterChange": "39416e9e4305b172d90b88aed3085d98ded0a86c", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "signatureAfterChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "diff": ["-\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t} else if (currentNestedType.isLocalType()) {\r", "-\t\t\t\t// direct enclosing instance link\r", "-\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "-\t\t\t\tcurrentType = currentNestedType.enclosingType;\r", "-\t\t\t\tif (methodScope().isInsideInitializerOrConstructor())\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "-\t\t\t\t// further indirect cases\r", "-\t\t\t\twhile (currentType.isNestedType()\r", "-\t\t\t\t\t&& currentType != targetEnclosingType\r", "-\t\t\t\t\t&& !targetEnclosingType.isSuperclassOf(currentType)) {\r", "-\r", "-\t\t\t\t\tcurrentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\t\t\r", "+\t\t\t} else { // indirect reference sequence\r", "+\t\t\t\tint depth = 0;\r", "+\t\t\t\t\r", "+\t\t\t\t// saturate all the way up until reaching compatible enclosing type\r", "+\t\t\t\twhile (currentType.isLocalType()){\r", "+\t\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif (depth == 0){\r", "+\t\t\t\t\t\tif (methodScope().isInsideInitializerOrConstructor()) {\r", "+\t\t\t\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\t}\t\t\t\t\t\r", "+\t\t\t\t\t} else if (currentNestedType == targetEnclosingType \r", "+\t\t\t\t\t\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentNestedType)) {\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t} \r", "+\t\t\t\t\tdepth++;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1270fa81c50fb57923c4209c73e201d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "4b1cb82b00b0f3c43755c37280deb732ae600c1a", "commitAfterChange": "1caf2b41c370e66c328190589dd64f01b35d7384", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " \tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "diff": ["-\t\tif (!flowInfo.isReachable()) return;", "+ \t\tif (!flowInfo.isReachable()) return;", "-", "-\t\t\tnestedType.addSyntheticArgumentAndField(binding.enclosingType());\t", "+\t\t\tnestedType.addSyntheticArgumentAndField(nestedType.enclosingType());\t", "-\t\tif (binding.isAnonymousType()) { ", "-\t\t\tReferenceBinding superclassBinding = (ReferenceBinding)binding.superclass.erasure();", "+\t\tif (nestedType.isAnonymousType()) {", "+\t\t\tReferenceBinding superclassBinding = (ReferenceBinding)nestedType.superclass.erasure();", "+\t\t\t// From 1.5 on, provide access to enclosing instance synthetic constructor argument when declared inside constructor call", "+\t\t\t// only for direct anonymous type", "+\t\t\t//public class X {", "+\t\t\t//\tvoid foo() {}", "+\t\t\t//\tclass M {", "+\t\t\t//\t\tM(Object o) {}", "+\t\t\t//\t\tM() { this(new Object() { void baz() { foo(); }}); } // access to #foo() indirects through constructor synthetic arg: val$this$0", "+\t\t\t//\t}", "+\t\t\t//}", "+\t\t\tif (!methodScope.isStatic && methodScope.isConstructorCall && currentScope.environment().options.complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t\tReferenceBinding enclosing = nestedType.enclosingType();", "+\t\t\t\tif (enclosing.isNestedType()) {", "+\t\t\t\t\tNestedTypeBinding nestedEnclosing = (NestedTypeBinding)enclosing;", "+//\t\t\t\t\tif (nestedEnclosing.findSuperTypeErasingTo(nestedEnclosing.enclosingType()) == null) { // only if not inheriting", "+\t\t\t\t\t\tSyntheticArgumentBinding syntheticEnclosingInstanceArgument = nestedEnclosing.getSyntheticArgument(nestedEnclosing.enclosingType(), true);", "+\t\t\t\t\t\tif (syntheticEnclosingInstanceArgument != null) {", "+\t\t\t\t\t\t\tnestedType.addSyntheticArgumentAndField(syntheticEnclosingInstanceArgument);\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+//\t\t\t\t}", "+\t\t\t}"]}], "num": 24752}