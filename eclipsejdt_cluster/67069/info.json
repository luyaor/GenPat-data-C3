{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d8d5c4a0f9023a3731000ca9535752ab", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17b6bd0566bdb49ec5b4dd16cad67b34", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DocCommentParser.java", "commitBeforeChange": "1ddaa88ca7b93ac6c1dc13d6d1d7c697fa81b2a7", "commitAfterChange": "640dca164a379d10390fa11e5cf245ab3efaf152", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tprotected void createTag()", "signatureAfterChange": " \tprotected void createTag()", "diff": ["+\t\tint position = this.scanner.currentPosition;", "+\t\tthis.scanner.resetTo(this.tagSourceStart, this.tagSourceEnd);", "+\t\tStringBuffer tagName = new StringBuffer();", "-\t\tString tagName = new String(this.source, start, this.tagSourceEnd-start+1);", "-\t\tswitch (tagName.charAt(0)) {", "-\t\t\tcase 'a':", "-\t\t\t\tif (tagName.equals(TagElement.TAG_AUTHOR)) {", "-\t\t\t\t\ttagName = TagElement.TAG_AUTHOR;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase 'd':", "-\t\t\t\tif (tagName.equals(TagElement.TAG_DOCROOT)) {", "-\t\t\t\t\ttagName = TagElement.TAG_DOCROOT;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase 'r':", "-\t\t\t\tif (tagName.equals(TagElement.TAG_RETURN)) {", "-\t\t\t\t\ttagName = TagElement.TAG_RETURN;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase 's':", "-\t\t\t\tif (tagName.equals(TagElement.TAG_SERIAL)) {", "-\t\t\t\t\ttagName = TagElement.TAG_SERIAL;", "-\t\t\t\t} else  if (tagName.equals(TagElement.TAG_SERIALDATA)) {", "-\t\t\t\t\ttagName = TagElement.TAG_SERIALDATA;", "-\t\t\t\t} else if (tagName.equals(TagElement.TAG_SERIALFIELD)) {", "-\t\t\t\t\ttagName = TagElement.TAG_SERIALFIELD;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase 'v':", "-\t\t\t\tif (tagName.equals(TagElement.TAG_VERSION)) {", "-\t\t\t\t\ttagName = TagElement.TAG_VERSION;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "+\t\tthis.scanner.getNextChar();", "+\t\twhile (this.scanner.currentPosition <= (this.tagSourceEnd+1)) {", "+\t\t\ttagName.append(this.scanner.currentCharacter);", "+\t\t\tthis.scanner.getNextChar();", "-\t\ttagElement.setTagName(tagName);", "+\t\ttagElement.setTagName(tagName.toString());", "-//\t\treturn true;", "+\t\tthis.scanner.resetTo(position, this.javadocEnd);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1e1d581c4389604c837ffdbd0ddd7085", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java", "commitBeforeChange": "7511ce8ac2a616c416b32731f4d10587027e3f25", "commitAfterChange": "71d14c28198258a4d6a7c5df6309a1aa1f387bf3", "methodNumberBeforeChange": 115, "methodNumberAfterChange": 115, "signatureBeforeChange": "\t\t  \tpublic void testStringLiteralUnicode()", "signatureAfterChange": "\t\t  \tpublic void testStringLiteralUnicode()", "diff": ["-\t\tAST localAst;", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tAST localAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());", "-\t\tif (ast.apiLevel() == AST.LEVEL_2_0) {", "-\t\t\tlocalAst = AST.newAST2();", "-\t\t} else {", "-\t\t\tlocalAst = AST.newAST3();", "-\t\t}", "+\t\tlocalAst = AST.newAST(ast.apiLevel());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2076a5019fee861086f8914274076709", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "f238d59edecc5d87c39084d60c9040567d09deaf", "commitAfterChange": "ce0032759c3236d2ea392944fcdfb033987155c8", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject parentProject)", "signatureAfterChange": "\r \tprotected boolean traverseDelta(IResourceDelta delta, int elementType, IJavaProject currentProject)", "diff": ["-\tprotected boolean traverseDelta(IResourceDelta delta, int parentType, IJavaProject parentProject) {\r", "+\tprotected boolean traverseDelta(IResourceDelta delta, int elementType, IJavaProject currentProject) {\r", "-\t\t// check if current resource is now on classpath and determine the element type\r", "-\t\tIJavaProject currentProject = parentProject;\r", "-\t\tIPath fullPath = res.getFullPath();\r", "-\t\tIJavaProject projectOfRoot = (IJavaProject)this.roots.get(fullPath);\r", "-\t\tint elementType = -1;\r", "-\t\tif (projectOfRoot != null) {\r", "-\t\t\tcurrentProject = projectOfRoot;\r", "-\t\t\tif (parentType == IJavaElement.JAVA_MODEL && delta.getKind() != IResourceDelta.CHANGED) {\r", "-\t\t\t\t// project is added or removed\r", "-\t\t\t\telementType = IJavaElement.JAVA_PROJECT;\r", "-\t\t\t} else {\r", "-\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "-\t\t\t}\r", "-\t\t} else {\r", "-\t\t\tswitch (parentType) {\r", "-\t\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\t\tif (currentProject != null) {\r", "-\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT_ROOT;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\telementType = IJavaElement.JAVA_PROJECT; // not yet in a package fragment root\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT:\r", "-\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT:\r", "-\t\t\t\t\tif (res instanceof IFolder) {\r", "-\t\t\t\t\t\telementType = IJavaElement.PACKAGE_FRAGMENT;\r", "-\t\t\t\t\t} else {\r", "-\t\t\t\t\t\tString extension = res.getFileExtension();\r", "-\t\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\t\telementType = IJavaElement.COMPILATION_UNIT;\r", "-\t\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "-\t\t\t\t\t\t\telementType = IJavaElement.CLASS_FILE;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t\r", "+\t\t// process current delta\r", "-\t\tboolean result;\r", "+\r", "+\t\t// process children if needed\r", "-\t\t\tOpenable element = null;\r", "+\t\t\tOpenable parent = null;\r", "-\t\t\t\tif (!traverseDelta(child, elementType, currentProject)) {\r", "+\t\t\t\tIResource childRes = child.getResource();\r", "+\t\t\t\tIPath childPath = childRes.getFullPath();\r", "+\r", "+\t\t\t\t// find out whether the child is a package fragment root of the current project\r", "+\t\t\t\tIJavaProject projectOfRoot = (IJavaProject)this.roots.get(childPath);\r", "+\t\t\t\tboolean isPkgFragmentRoot = \r", "+\t\t\t\t\tprojectOfRoot != null \r", "+\t\t\t\t\t&& (projectOfRoot.getProject().getFullPath().isPrefixOf(childPath));\r", "+\t\t\t\tint childType = this.elementType(child, elementType, isPkgFragmentRoot);\r", "+\t\t\t\t\r", "+\t\t\t\t// traverse delta for child in the same project\r", "+\t\t\t\tif (!this.traverseDelta(child, childType, (currentProject == null && isPkgFragmentRoot) ? projectOfRoot : currentProject)) {\r", "-\t\t\t\t\t\t\tif (element == null) {\r", "+\t\t\t\t\t\t\tif (parent == null) {\r", "-\t\t\t\t\t\t\t\tif (fullPath.equals(currentProject.getProject().getFullPath())) {\r", "-\t\t\t\t\t\t\t\t\telement = (Openable)currentProject;\r", "+\t\t\t\t\t\t\t\tif (elementType == IJavaElement.JAVA_PROJECT) {\r", "+\t\t\t\t\t\t\t\t\tparent = (Openable)currentProject;\r", "-\t\t\t\t\t\t\t\t\telement = this.createElement(res, elementType, currentProject);\r", "+\t\t\t\t\t\t\t\t\tparent = this.createElement(res, elementType, currentProject);\r", "-\t\t\t\t\t\t\t\tif (element == null) continue;\r", "+\t\t\t\t\t\t\t\tif (parent == null) continue;\r", "-\t\t\t\t\t\t\t// add child as non java resource if current element on classpath\r", "-\t\t\t\t\t\t\tnonJavaResourcesChanged(element, child);\r", "+\t\t\t\t\t\t\t// add child as non java resource\r", "+\t\t\t\t\t\t\tnonJavaResourcesChanged(parent, child);\r", "+\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\t// if child is a package fragment root of another project, traverse delta too\r", "+\t\t\t\tif (projectOfRoot != null && !isPkgFragmentRoot) {\r", "+\t\t\t\t\tthis.traverseDelta(child, IJavaElement.PACKAGE_FRAGMENT_ROOT, projectOfRoot);\r", "+\t\t\t\t\t// NB: No need to check the return value as the child can only be on the classpath\r", "+\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\t// if the child is a package fragment root of one or several other projects\r", "+\t\t\t\tHashSet set;\r", "+\t\t\t\tif ((set = (HashSet)this.otherRoots.get(childPath)) != null) {\r", "+\t\t\t\t\tIPackageFragmentRoot currentRoot = \r", "+\t\t\t\t\t\t(currentProject == null ? \r", "+\t\t\t\t\t\t\tprojectOfRoot : \r", "+\t\t\t\t\t\t\tcurrentProject).getPackageFragmentRoot(childRes);\r", "+\t\t\t\t\tIterator iterator = set.iterator();\r", "+\t\t\t\t\twhile (iterator.hasNext()) {\r", "+\t\t\t\t\t\tIJavaProject project = (IJavaProject) iterator.next();\r", "+\t\t\t\t\t\tthis.cloneCurrentDelta(project, currentRoot);\r", "+\t\t\t\t\t}\r", "-\t\t\tresult = currentProject != null || oneChildOnClasspath;\r", "+\t\t\treturn currentProject != null || oneChildOnClasspath;\r", "-\t\t\t// if we changed the current project or if the element type is -1, \r", "+\t\t\t// if not on classpath or if the element type is -1, \r", "-\t\t\tresult = \r", "-\t\t\t\tcurrentProject != null \r", "-\t\t\t\t&& currentProject.equals(parentProject)\r", "-\t\t\t\t&& elementType != -1;\r", "+\t\t\treturn currentProject != null && elementType != -1;\r", "-\t\t\r", "-\t\t// other roots\r", "-\t\tHashSet set;\r", "-\t\tif ((set = (HashSet)this.otherRoots.get(fullPath)) != null) {\r", "-\t\t\tIPackageFragmentRoot currentRoot = currentProject.getPackageFragmentRoot(res);\r", "-\t\t\tIterator iterator = set.iterator();\r", "-\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\tIJavaProject project = (IJavaProject) iterator.next();", "-\t\t\t\tthis.cloneCurrentDelta(project, currentRoot);", "-\t\t\t}\r", "+\t}\r", "-\t\t\r", "-\t\treturn result;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4166f6ad09a3ee2f9cefb9103f3014ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "408302f5651c0f3bdb87a0de2c60492173de703b", "commitAfterChange": "854aca9c52e0b62eeec0af763519f02672c03791", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r private boolean projectCanSeeFocusElement(IJavaProject project)", "signatureAfterChange": "\r private boolean referencingProjectsIncludes(IJavaProject javaProject, IPath path) throws JavaModelException", "diff": ["- */\r", "-private boolean projectCanSeeFocusElement(IJavaProject project) {\r", "-\ttry {\r", "-\t\twhile (!(this.focus instanceof IJavaProject) && !(this.focus instanceof JarPackageFragmentRoot)) {\r", "-\t\t\tthis.focus = this.focus.getParent();\r", "-\t\t}\r", "-\t\tif (this.focus instanceof JarPackageFragmentRoot) {\r", "-\t\t\t// this.focus is part of a jar\r", "-\t\t\tJarPackageFragmentRoot root = (JarPackageFragmentRoot)this.focus;\r", "-\t\t\tIPath rootPath = root.getPath();\r", "-\t\t\tIClasspathEntry[] entries = ((JavaProject)project).getExpandedClasspath(true);\r", "-\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {\r", "-\t\t\t\tIClasspathEntry entry = entries[i];\r", "-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) \r", "-\t\t\t\t\t&& entry.getPath().equals(rootPath)) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\treturn false;\r", "-\t\t} else {\r", "-\t\t\t// this.focus is part of a project\r", "-\t\t\tIJavaProject focusProject = (IJavaProject)this.focus;\r", "-\t\t\tif (project.equals(focusProject)) {\r", "+private boolean referencingProjectsIncludes(IJavaProject javaProject, IPath path) throws JavaModelException {\r", "+\tIJavaModel model = javaProject.getJavaModel();\r", "+\tIProject[] projects = javaProject.getProject().getReferencingProjects();\r", "+\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "+\t\tIProject project = projects[i];\r", "+\t\tIJavaProject referencingProject = model.getJavaProject(project.getName());\r", "+\t\tIClasspathEntry[] classpath = referencingProject.getResolvedClasspath(true);\r", "+\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {\r", "+\t\t\tIClasspathEntry entry = classpath[j];\r", "+\t\t\tif (entry.getPath().equals(path)) {\r", "-\t\t\t} else {\r", "-\t\t\t\tIPath focusPath = focusProject.getProject().getFullPath();\r", "-\t\t\t\tIClasspathEntry[] entries = ((JavaProject)project).getExpandedClasspath(true);\r", "-\t\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {\r", "-\t\t\t\t\tIClasspathEntry entry = entries[i];\r", "-\t\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) \r", "-\t\t\t\t\t\t&& entry.getPath().equals(focusPath)) {\r", "-\t\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t\treturn false;\r", "-\t} catch (JavaModelException e) {\r", "-\t\treturn false;\r", "+\t\tif (this.referencingProjectsIncludes(referencingProject, path)) {\r", "+\t\t\treturn true;\r", "+\t\t}\r", "+\treturn false;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78156fb9303710ddaa4cc9c75a57d6f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "5f3b6ac7e5dc164337a0c0b8a1d4f4f78e6d48c8", "commitAfterChange": "fbfdac6d7ce3e57d87b2a41c24ca19b307df27cb", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " protected void reportDeclaration(MethodBinding methodBinding, MatchLocator locator, SimpleSet knownMethods) throws CoreException", "signatureAfterChange": " protected void reportDeclaration(MethodBinding methodBinding, MatchLocator locator, SimpleSet knownMethods) throws CoreException", "diff": ["-\tchar[] bindingSelector = methodBinding.selector;", "-\tboolean isBinary = type.isBinary();", "-\tIMethod method = null;", "-\tTypeBinding[] parameters = methodBinding.original().parameters;", "-\tint parameterLength = parameters.length;", "-\tif (isBinary) {", "+\t// Report match for binary", "+\tif (type.isBinary()) {", "+\t\tIMethod method = null;", "+\t\tTypeBinding[] parameters = methodBinding.original().parameters;", "+\t\tint parameterLength = parameters.length;", "-\t} else {", "-\t\tString[] parameterTypes = new String[parameterLength];", "-\t\tfor (int i = 0; i  < parameterLength; i++) {", "-\t\t\tchar[] typeName = parameters[i].shortReadableName();", "-\t\t\tif (parameters[i].isMemberType()) {", "-\t\t\t\ttypeName = CharOperation.subarray(typeName, CharOperation.indexOf('.', typeName)+1, typeName.length);", "-\t\t\t}", "-\t\t\tparameterTypes[i] = Signature.createTypeSignature(typeName, false);", "-\t\t}", "-\t\tmethod = type.getMethod(new String(bindingSelector), parameterTypes);", "-\t}", "-\tif (method == null || knownMethods.addIfNotIncluded(method) == null) return;", "-", "-\tIResource resource = type.getResource();", "-\tIBinaryType info = null;", "-\tif (isBinary) {", "+\t\tif (method == null || knownMethods.addIfNotIncluded(method) == null) return;", "+\t", "+\t\tIResource resource = type.getResource();", "-\t\tinfo = locator.getBinaryInfo((org.eclipse.jdt.internal.core.ClassFile)type.getClassFile(), resource);", "+\t\tIBinaryType info = locator.getBinaryInfo((org.eclipse.jdt.internal.core.ClassFile)type.getClassFile(), resource);", "-\t} else {", "-\t\tif (declaringClass instanceof ParameterizedTypeBinding)", "-\t\t\tdeclaringClass = ((ParameterizedTypeBinding) declaringClass).genericType();", "-\t\tClassScope scope = ((SourceTypeBinding) declaringClass).scope;", "-\t\tif (scope != null) {", "-\t\t\tTypeDeclaration typeDecl = scope.referenceContext;", "-\t\t\tAbstractMethodDeclaration methodDecl = null;", "-\t\t\tAbstractMethodDeclaration[] methodDecls = typeDecl.methods;", "-\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "-\t\t\t\tif (CharOperation.equals(bindingSelector, methodDecls[i].selector)) {", "-\t\t\t\t\tmethodDecl = methodDecls[i];", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\treturn;", "+\t}", "+", "+\t// When source is available, report match if method is found in the declaring type", "+\tIResource resource = type.getResource();", "+\tif (declaringClass instanceof ParameterizedTypeBinding)", "+\t\tdeclaringClass = ((ParameterizedTypeBinding) declaringClass).genericType();", "+\tClassScope scope = ((SourceTypeBinding) declaringClass).scope;", "+\tif (scope != null) {", "+\t\tTypeDeclaration typeDecl = scope.referenceContext;", "+\t\tAbstractMethodDeclaration methodDecl = typeDecl.declarationOf(methodBinding.original());", "+\t\tif (methodDecl != null) {", "+\t\t\t// Create method handle from method declaration", "+\t\t\tString methodName = new String(methodBinding.selector);", "+\t\t\tArgument[] arguments = methodDecl.arguments;", "+\t\t\tint length = arguments == null ? 0 : arguments.length;", "+\t\t\tString[] parameterTypes = new String[length];", "+\t\t\tfor (int i = 0; i  < length; i++) {", "+\t\t\t\tchar[][] typeName = arguments[i].type.getParameterizedTypeName();", "+\t\t\t\tparameterTypes[i] = Signature.createTypeSignature(CharOperation.concatWith(typeName, '.'), false);", "-\t\t\tif (methodDecl != null) {", "-\t\t\t\tint offset = methodDecl.sourceStart;", "-\t\t\t\tBinding binding = methodDecl.binding;", "-\t\t\t\tif (binding != null)", "-\t\t\t\t\tmethod = (IMethod) ((JavaElement) method).resolved(binding);", "-\t\t\t\tthis.match = new MethodDeclarationMatch(method, SearchMatch.A_ACCURATE, offset, methodDecl.sourceEnd-offset+1, locator.getParticipant(), resource);", "-\t\t\t\tlocator.report(this.match);", "-\t\t\t}", "+\t\t\tIMethod method = type.getMethod(methodName, parameterTypes);", "+\t\t\tif (method == null || knownMethods.addIfNotIncluded(method) == null) return;", "+", "+\t\t\t// Create and report corresponding match", "+\t\t\tint offset = methodDecl.sourceStart;", "+\t\t\tthis.match = new MethodDeclarationMatch(method, SearchMatch.A_ACCURATE, offset, methodDecl.sourceEnd-offset+1, locator.getParticipant(), resource);", "+\t\t\tlocator.report(this.match);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "812848af2320d1b3f1295b879b92e0ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java", "commitBeforeChange": "8ca0d4068ff2e48c52b6cad25c5d2f5c2d9eace8", "commitAfterChange": "dedf5307e666f4e1475605b0b89aaf9292d38bf4", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r \r private boolean hasStructuralFieldChanges(FieldInfo currentFieldInfo, FieldInfo otherFieldInfo)", "signatureAfterChange": "\r private boolean hasStructuralFieldChanges(FieldInfo currentFieldInfo, FieldInfo otherFieldInfo)", "diff": ["-private boolean hasStructuralFieldChanges(FieldInfo currentFieldInfo, FieldInfo otherFieldInfo) {\r", "-\r", "-\tif (currentFieldInfo.getModifiers() != otherFieldInfo.getModifiers()) {\r", "-\t\treturn true;\r", "-\t}\r", "-\tif (!CharOperation.equals(currentFieldInfo.getName(), otherFieldInfo.getName())) {\r", "-\t\treturn true;\r", "-\t}\r", "-\tif (!CharOperation.equals(currentFieldInfo.getTypeName(), otherFieldInfo.getTypeName())) {\r", "-\t\treturn true;\r", "-\t}\r", "-\tif (currentFieldInfo.hasConstant()) {\r", "-\t\tif (!otherFieldInfo.hasConstant()) {\r", "-\t\t\treturn true;\r", "+}\r", "+private boolean hasStructuralFieldChanges(FieldInfo currentFieldInfo, FieldInfo otherFieldInfo) {\r", "+\tif (currentFieldInfo.getModifiers() != otherFieldInfo.getModifiers())\r", "+\t\treturn true;\r", "+\tif (!CharOperation.equals(currentFieldInfo.getName(), otherFieldInfo.getName()))\r", "+\t\treturn true;\r", "+\tif (!CharOperation.equals(currentFieldInfo.getTypeName(), otherFieldInfo.getTypeName()))\r", "+\t\treturn true;\r", "+\tif (currentFieldInfo.hasConstant() != otherFieldInfo.hasConstant())\r", "+\t\treturn true;\r", "+\tif (currentFieldInfo.hasConstant()) {\r", "-\t\tif (!currentConstant.getClass().equals(otherConstant.getClass())) {\r", "+\t\tif (currentConstant.typeID() != otherConstant.typeID())\r", "-\t\t} \r", "+\t\tif (!currentConstant.getClass().equals(otherConstant.getClass()))\r", "+\t\t\treturn true;\r", "-\t\t\t\tcase TypeIds.T_int : \r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_int) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.intValue() != currentConstant.intValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_byte :\r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_byte) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.byteValue() != currentConstant.byteValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_short : \r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_short) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.shortValue() != currentConstant.shortValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_char : \r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_char) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.charValue() != currentConstant.charValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_float :\r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_float) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.floatValue() != currentConstant.floatValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_double :\r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_double) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.doubleValue() != currentConstant.doubleValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_boolean : \r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_boolean) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.booleanValue() != currentConstant.booleanValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_String : \r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_String) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant.stringValue() != currentConstant.stringValue()) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tbreak;\r", "-\t\t\t\tcase TypeIds.T_null :\r", "-\t\t\t\t\tif (otherConstant.typeID() != TypeIds.T_null) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tif (otherConstant != NullConstant.Default) {\r", "-\t\t\t\t\t\treturn true;\r", "-\t\t\t\t\t}\r", "+\t\t\tcase TypeIds.T_int :\r", "+\t\t\t\treturn currentConstant.intValue() != otherConstant.intValue();\r", "+\t\t\tcase TypeIds.T_byte :\r", "+\t\t\t\treturn currentConstant.byteValue() != otherConstant.byteValue();\r", "+\t\t\tcase TypeIds.T_short :\r", "+\t\t\t\treturn currentConstant.shortValue() != otherConstant.shortValue();\r", "+\t\t\tcase TypeIds.T_char :\r", "+\t\t\t\treturn currentConstant.charValue() != otherConstant.charValue();\r", "+\t\t\tcase TypeIds.T_float :\r", "+\t\t\t\treturn currentConstant.floatValue() != otherConstant.floatValue();\r", "+\t\t\tcase TypeIds.T_double :\r", "+\t\t\t\treturn currentConstant.doubleValue() != otherConstant.doubleValue();\r", "+\t\t\tcase TypeIds.T_boolean :\r", "+\t\t\t\treturn currentConstant.booleanValue() != otherConstant.booleanValue();\r", "+\t\t\tcase TypeIds.T_String :\r", "+\t\t\t\treturn !currentConstant.stringValue().equals(otherConstant.stringValue());\r", "+\t\t\tcase TypeIds.T_null :\r", "+\t\t\t\treturn otherConstant != NullConstant.Default;\r", "-\t} else if (otherFieldInfo.hasConstant()) {\r", "-\t\treturn true;\r", "+\t}\r", "+\treturn false;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f16d6a86e623b147e7d478645829f26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "d32899eb4e5db96c386fe27007db09842d368980", "commitAfterChange": "454c09645419e42e424c8ed7d147ba861f3f0f93", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 58, "signatureBeforeChange": " \tprivate static void updateVariableValues( \t\tString[] variableNames, \t\tIPath[] variablePaths, \t\tIProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tprivate static void updateVariableValues( \t\tString[] variableNames, \t\tIPath[] variablePaths, \t\tIProgressMonitor monitor) throws JavaModelException", "diff": ["-\t\tboolean needCycleCheck = false;", "-\t\tHashMap affectedProjects = new HashMap(5);", "+\t\tfinal HashMap affectedProjects = new HashMap(5);", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers", "-\t\t\t\t\t\t\t\tif (!needCycleCheck && entry.getPath().segmentCount() ==  1){", "-\t\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.variableGet(variableName);", "-\t\t\t\t\t\t\t\t\tif (oldPath == JavaModelManager.VariableInitializationInProgress) oldPath = null;", "-\t\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {", "-\t\t\t\t\t\t\t\t\t\tneedCycleCheck = true;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];", "-\t\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {", "-\t\t\t\t\t\t\t\t\t\t\tneedCycleCheck = true;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\tboolean wasFiring = manager.isFiring();", "-\t\t\t\tif (wasFiring)", "-\t\t\t\t\tmanager.stopDeltas();", "-\t\t\t\t// propagate classpath change", "-\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();", "-\t\t\t\twhile (projectsToUpdate.hasNext()) {", "-", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;", "-", "-\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();", "-\t\t\t\t\t", "-\t\t\t\t\tif (!projectsToUpdate.hasNext()) {", "-\t\t\t\t\t\t// re-enable firing for the last operation", "-\t\t\t\t\t\tif (wasFiring) {", "-\t\t\t\t\t\t\twasFiring = false;", "-\t\t\t\t\t\t\tmanager.startDeltas();", "+\t\t\t\tJavaCore.run(", "+\t\t\t\t\tnew IWorkspaceRunnable() {", "+\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "+\t\t\t\t\t\t\t// propagate classpath change", "+\t\t\t\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();", "+\t\t\t\t\t\t\twhile (projectsToUpdate.hasNext()) {", "+\t\t\t", "+\t\t\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;", "+\t\t\t", "+\t\t\t\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tproject", "+\t\t\t\t\t\t\t\t\t.setRawClasspath(", "+\t\t\t\t\t\t\t\t\t\tproject.getRawClasspath(),", "+\t\t\t\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,", "+\t\t\t\t\t\t\t\t\t\tmonitor,", "+\t\t\t\t\t\t\t\t\t\t!JavaModelManager.IsResourceTreeLocked, // can change resources", "+\t\t\t\t\t\t\t\t\t\t!JavaModelManager.IsResourceTreeLocked && project.getWorkspace().isAutoBuilding(),// force build if in auto build mode", "+\t\t\t\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),", "+\t\t\t\t\t\t\t\t\t\tfalse); // updating - no validation", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tproject", "-\t\t\t\t\t\t.setRawClasspath(", "-\t\t\t\t\t\t\tproject.getRawClasspath(),", "-\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,", "-\t\t\t\t\t\t\tmonitor,", "-\t\t\t\t\t\t\t!JavaModelManager.IsResourceTreeLocked, // can change resources", "-\t\t\t\t\t\t\t!JavaModelManager.IsResourceTreeLocked && project.getWorkspace().isAutoBuilding(),// force build if in auto build mode", "-\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),", "-\t\t\t\t\t\t\tsize == 1 && needCycleCheck, // no individual check if more than 1 project to update", "-\t\t\t\t\t\t\tfalse); // updating - no validation", "-\t\t\t\t}", "-\t\t\t\tif (size > 1 && needCycleCheck){", "-\t\t\t\t\t// use workspace runnable for protecting marker manipulation", "-//\t\t\t\t\tResourcesPlugin.getWorkspace().run(", "-//\t\t\t\t\t\tnew IWorkspaceRunnable() {", "-//\t\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "-\t\t\t\t\t\t\t\tJavaProject.updateAllCycleMarkers(); // update them all at once", "-//\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t}, ", "-//\t\t\t\t\t\tmonitor);\t\t\t\t\t", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tif (wasFiring) {", "-\t\t\t\t\tmanager.startDeltas();", "-\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration", "+\t\t\t\t\t},", "+\t\t\t\t\tmonitor);", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\tif (e instanceof JavaModelException) {", "+\t\t\t\t\tthrow (JavaModelException)e;", "+\t\t\t\t} else {", "+\t\t\t\t\tthrow new JavaModelException(e);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ebf569a492dc77cdc73a1e370d23a0a8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/Constant.java", "commitBeforeChange": "8970b012a4c030df2da75433f5a255c033afe448", "commitAfterChange": "c6ea2a72647dce31af35c91712fb9d7b45a7c96d", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \t\t \tpublic static final Constant computeConstantOperationPLUS(Constant left, int leftId, Constant right, int rightId)", "signatureAfterChange": " \t\t \tpublic static final Constant computeConstantOperationPLUS(Constant left, int leftId, Constant right, int rightId)", "diff": ["-\t\t\t\t\tcase T_char :\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_float:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_double:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_byte:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_short:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_int:\t\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_long:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "+\t\t\t\t\tcase T_char :\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.charValue()));", "+\t\t\t\t\tcase T_float:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.floatValue()));", "+\t\t\t\t\tcase T_double:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.doubleValue()));", "+\t\t\t\t\tcase T_byte:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.byteValue()));", "+\t\t\t\t\tcase T_short:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.shortValue()));", "+\t\t\t\t\tcase T_int:\t\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.intValue()));", "+\t\t\t\t\tcase T_long:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.longValue()));", "-\t\t\t\t\tcase T_boolean:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "+\t\t\t\t\tcase T_boolean:\treturn Constant.fromValue(left.stringValue() + right.booleanValue());", "-\t\t\tcase T_null :", "-\t\t\t\tswitch (rightId){", "-\t\t\t\t\tcase T_char :\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_float:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_double:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_byte:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_short:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_int:\t\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_long:\treturn Constant.fromValue(left.stringValue() + right.stringValue());", "-\t\t\t\t\tcase T_JavaLangString:\treturn Constant.fromValue(left.stringValue() + right.stringValue()); ", "-\t\t\t\t}", "-\t\t\t\t", "+//\t\t\tcase T_null :", "+//\t\t\t\tswitch (rightId){", "+//\t\t\t\t\tcase T_char :\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.charValue()));", "+//\t\t\t\t\tcase T_float:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.floatValue()));", "+//\t\t\t\t\tcase T_double:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.doubleValue()));", "+//\t\t\t\t\tcase T_byte:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.byteValue()));", "+//\t\t\t\t\tcase T_short:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.shortValue()));", "+//\t\t\t\t\tcase T_int:\t\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.intValue()));", "+//\t\t\t\t\tcase T_long:\treturn Constant.fromValue(left.stringValue() + String.valueOf(right.longValue()));", "+//\t\t\t\t\tcase T_JavaLangString:\treturn Constant.fromValue(left.stringValue() + right.stringValue()); ", "+//\t\t\t\t\tcase T_boolean:\treturn Constant.fromValue(left.stringValue() + right.booleanValue());", "+//\t\t\t\t}\t\t\t\t"]}], "num": 67069}