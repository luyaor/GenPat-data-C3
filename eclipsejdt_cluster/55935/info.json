{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9d995eb288e34a5ae6ad2208af447baf", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03bf4b75043bab0508525a824bc49782", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "fb8f376e81332a8e2eb0b6ab7b009417715a2326", "commitAfterChange": "504159d7229f244fe60c96f9b15d6167193a85b6", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "signatureAfterChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType, \t\tExpression expression)", "diff": ["-\t\t\t} else if (", "-\t\t\t\tcastType.isClass()) {", "+\t\t\t} else if (castType.isTypeVariable()) {", "+\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\tif (match == null) {", "+\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t}", "+\t\t\t\t// recursively on the type variable upper bound", "+\t\t\t\treturn checkCastTypesCompatibility(", "+\t\t\t\t\tscope,", "+\t\t\t\t\tcastType.erasure(),", "+\t\t\t\t\texpressionType,", "+\t\t\t\t\texpression);", "+\t\t\t} else if (castType.isClass()) {", "-\t", "+\t\tif (expressionType.isTypeVariable() || expressionType.isWildcard()) {", "+\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\tif (match != null) {", "+\t\t\t\ttagAsUnnecessaryCast(scope, castType);", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t// recursively on the type variable upper bound", "+\t\t\treturn checkCastTypesCompatibility(", "+\t\t\t\tscope,", "+\t\t\t\tcastType,", "+\t\t\t\texpressionType.erasure(),", "+\t\t\t\texpression);", "+\t\t}", "+\t\t", "+\t\t\t} else if (castType.isTypeVariable()) {", "+\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\t\tif (match == null) {", "+\t\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t\t}", "+\t\t\t\t// recursively on the type variable upper bound", "+\t\t\t\treturn checkCastTypesCompatibility(", "+\t\t\t\t\tscope,", "+\t\t\t\t\tcastType.erasure(),", "+\t\t\t\t\texpressionType,", "+\t\t\t\t\texpression);", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo(castType.isTypeVariable() ? (ReferenceBinding)castType : (ReferenceBinding)castType.erasure());", "+\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\t\tif (!castType.isTypeVariable() || (((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure()) == null)) {", "-\t\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\t}", "+\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo(castType.isTypeVariable() ? (ReferenceBinding)castType : (ReferenceBinding)castType.erasure());", "+\t\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\t\tif (!castType.isTypeVariable() || (((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure()) == null)) {", "-\t\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t\t}", "+\t\t\t\t\ttagAsNeedCheckCast();", "+\t\t} else if (castType.isTypeVariable()) {", "+\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType);", "+\t\t\tif (match == null) {", "+\t\t\t\tcheckUnsafeCast(scope, castType, expressionType, match, true);", "+\t\t\t}", "+\t\t\t// recursively on the type variable upper bound", "+\t\t\treturn checkCastTypesCompatibility(", "+\t\t\t\tscope,", "+\t\t\t\tcastType.erasure(),", "+\t\t\t\texpressionType,", "+\t\t\t\texpression);", "-\t\t\t\tTypeBinding match = ((ReferenceBinding)castType).findSuperTypeErasingTo(expressionType.isTypeVariable() ? (ReferenceBinding)expressionType : (ReferenceBinding)expressionType.erasure());", "+\t\t\t\tTypeBinding match = ((ReferenceBinding)castType).findSuperTypeErasingTo((ReferenceBinding)expressionType.erasure());", "-\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo(castType.isTypeVariable() ? (ReferenceBinding)castType : (ReferenceBinding)castType.erasure());", "+\t\t\tTypeBinding match = ((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure());", "-\t\t\t\tif (!castType.isTypeVariable() || (((ReferenceBinding)expressionType).findSuperTypeErasingTo((ReferenceBinding)castType.erasure()) == null)) {", "-\t\t\t\t\ttagAsNeedCheckCast();", "-\t\t\t\t}", "+\t\t\t\ttagAsNeedCheckCast();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3fc3c606bbcba3f200ab288e38130af", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java", "commitBeforeChange": "8ad7ea4a3e807d9d57eeeda9a3a7bd6598dfbdb1", "commitAfterChange": "b7a41e13e2a80300225883c3cc5ff3990406ce0a", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "diff": ["+\t\t\t\t\t\tcase ProblemReasons.InheritedNameHidesEnclosingName :", "-\t\t} ", "+\t\t}", "+\t\tboolean hasGenericError = false;", "+\t\tReferenceBinding currentType;", "-\t\t\tif (!(this.resolvedType.isValidBinding())) {", "+\t\t\tif (this.resolvedType.isValidBinding()) {", "+\t\t\t\tcurrentType = (ReferenceBinding) this.resolvedType;", "+\t\t\t} else {", "+\t\t\t\thasGenericError = true;", "-\t\t\t\t// be resilient, still attempt resolving arguments", "-\t\t\t\tboolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "-\t\t\t\tint argLength = this.typeArguments.length;", "-\t\t\t\tfor (int i = 0; i < argLength; i++) {", "-\t\t\t\t\tTypeReference typeArgument = this.typeArguments[i];", "-\t\t\t\t\tif (isClassScope) {", "-\t\t\t\t\t\ttypeArgument.resolveType((ClassScope) scope);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\ttypeArgument.resolveType((BlockScope) scope, checkBounds);", "+\t\t\t\tswitch (this.resolvedType.problemId()) {", "+\t\t\t\t\tcase ProblemReasons.NotFound :", "+\t\t\t\t\tcase ProblemReasons.NotVisible :", "+\t\t\t\t\tcase ProblemReasons.InheritedNameHidesEnclosingName :", "+\t\t\t\t\t\tTypeBinding type = this.resolvedType.closestMatch();", "+\t\t\t\t\t\tif (type instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tcurrentType = (ReferenceBinding) type;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fallthrough - unable to complete type binding, but still resolve type arguments", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tboolean isClassScope = scope.kind == Scope.CLASS_SCOPE;", "+\t\t\t\t\tint argLength = this.typeArguments.length;", "+\t\t\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\t\t\tTypeReference typeArgument = this.typeArguments[i];", "+\t\t\t\t\t\tif (isClassScope) {", "+\t\t\t\t\t\t\ttypeArgument.resolveType((ClassScope) scope);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\ttypeArgument.resolveType((BlockScope) scope, checkBounds);", "+\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn null;", "+\t\t\t\t\treturn null;", "+\t\t\t\t}\t\t\t", "+\t\t\t\t// be resilient, still attempt resolving arguments", "-\t\t\tenclosingType = this.resolvedType.enclosingType(); // if member type", "-\t\t\tif (enclosingType != null && (enclosingType.isGenericType() || enclosingType.isParameterizedType())) {", "-\t\t\t\tReferenceBinding referenceType = (ReferenceBinding) this.resolvedType;", "-\t\t\t\tenclosingType = referenceType.isStatic()", "+\t\t\tenclosingType = currentType.enclosingType(); // if member type", "+\t\t\tif (enclosingType != null) {", "+\t\t\t\tenclosingType = currentType.isStatic()", "-\t\t\t\tthis.resolvedType = scope.environment().createParameterizedType((ReferenceBinding) referenceType.erasure(), null /* no arg */, enclosingType);", "+\t\t\t\tcurrentType = scope.environment().createParameterizedType((ReferenceBinding) currentType.erasure(), null /* no arg */, enclosingType);", "-\t\t\tthis.resolvedType = scope.getMemberType(token, enclosingType);", "+\t\t\tthis.resolvedType = currentType = scope.getMemberType(token, enclosingType);", "-\t\t\t\tscope.problemReporter().invalidEnclosingType(this, this.resolvedType, enclosingType);", "+\t\t\t\thasGenericError = true;", "+\t\t\t\tscope.problemReporter().invalidEnclosingType(this, currentType, enclosingType);", "-\t\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\t\tscope.problemReporter().deprecatedType(this.resolvedType, this);", "+\t\t\tif (isTypeUseDeprecated(currentType, scope))", "+\t\t\t\tscope.problemReporter().deprecatedType(currentType, this);", "-\t\tReferenceBinding currentType = (ReferenceBinding) this.resolvedType;", "+\t\tReferenceBinding currentErasure = (ReferenceBinding)currentType.erasure();", "-\t\t\t\t? typeArgument.resolveTypeArgument((ClassScope) scope, currentType, i)", "-\t\t\t\t: typeArgument.resolveTypeArgument((BlockScope) scope, currentType, i);", "+\t\t\t\t? typeArgument.resolveTypeArgument((ClassScope) scope, currentErasure, i)", "+\t\t\t\t: typeArgument.resolveTypeArgument((BlockScope) scope, currentErasure, i);", "-\t\tif (argHasError) return null;", "+\t\tif (argHasError) {", "+\t\t\treturn null;", "+\t\t}", "-\t\t\tif (((ClassScope) scope).detectHierarchyCycle(currentType, this))", "+\t\t\tif (((ClassScope) scope).detectHierarchyCycle(currentErasure, this))", "-\t\tTypeVariableBinding[] typeVariables = currentType.typeVariables();", "-\t\tif (typeVariables == Binding.NO_TYPE_VARIABLES) { // check generic", "-\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) { // below 1.5, already reported as syntax error", "-\t\t\t\tscope.problemReporter().nonGenericTypeCannotBeParameterized(0, this, currentType, argTypes);", "-\t\t\t\treturn null;", "+\t\tTypeVariableBinding[] typeVariables = currentErasure.typeVariables();", "+\t\tif (typeVariables == Binding.NO_TYPE_VARIABLES) { // non generic invoked with arguments", "+\t\t\tboolean isCompliant15 = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\t\tif ((currentErasure.tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t\tif (isCompliant15) { // below 1.5, already reported as syntax error", "+\t\t\t\t\tthis.resolvedType = currentType;", "+\t\t\t\t\tscope.problemReporter().nonGenericTypeCannotBeParameterized(0, this, currentType, argTypes);", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "-\t\t\tthis.resolvedType = currentType;", "-\t\t\t// array type ?", "-\t\t\tif (this.dimensions > 0) {", "-\t\t\t\tif (dimensions > 255) ", "-\t\t\t\t\tscope.problemReporter().tooManyDimensions(this);", "-\t\t\t\tthis.resolvedType = scope.createArrayType(this.resolvedType, dimensions);", "-\t\t\t}\t\t\t", "-\t\t\treturn this.resolvedType;", "+\t\t\t// resilience do not rebuild a parameterized type unless compliance is allowing it", "+\t\t\tif (!isCompliant15) {", "+\t\t\t\t// array type ?", "+\t\t\t\tTypeBinding type = currentType;", "+\t\t\t\tif (this.dimensions > 0) {", "+\t\t\t\t\tif (this.dimensions > 255) ", "+\t\t\t\t\t\tscope.problemReporter().tooManyDimensions(this);", "+\t\t\t\t\ttype = scope.createArrayType(type, dimensions);", "+\t\t\t\t}\t\t\t", "+\t\t\t\tif (hasGenericError) ", "+\t\t\t\t\treturn type;", "+\t\t\t\treturn this.resolvedType = type;", "+\t\t\t}", "+\t\t\t// if missing generic type, and compliance >= 1.5, then will rebuild a parameterized binding", "-\t\t\t\t\t\tthis, scope.environment().createRawType((ReferenceBinding)currentType.erasure(), actualEnclosing), argTypes);", "+\t\t\t\t\t\tthis, scope.environment().createRawType(currentErasure, actualEnclosing), argTypes);", "-    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "+    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(currentErasure, argTypes, enclosingType);", "-\t\tthis.resolvedType = parameterizedType;", "-\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\treportDeprecatedType(this.resolvedType, scope);", "+\t\tif (isTypeUseDeprecated(parameterizedType, scope))", "+\t\t\treportDeprecatedType(parameterizedType, scope);", "+\t\tTypeBinding type = parameterizedType;", "-\t\t\tif (dimensions > 255)", "+\t\t\tif (this.dimensions > 255) ", "-\t\t\tthis.resolvedType = scope.createArrayType(this.resolvedType, dimensions);", "+\t\t\ttype = scope.createArrayType(type, dimensions);", "-\t\treturn this.resolvedType;", "+\t\tif (hasGenericError) {", "+\t\t\treturn type;", "+\t\t}", "+\t\treturn this.resolvedType = type;\t\t"]}], "num": 55935}