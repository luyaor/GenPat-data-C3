{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "723eb6687d1685a635c15e5ef0e002a9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87630dede8ce2809ddf7719dda913eeb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredType.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " public void updateFromParserState()", "signatureAfterChange": " public void updateFromParserState()", "diff": ["+\t\t} else if (parser.listTypeParameterLength > 0) {", "+\t\t\tint length = parser.listTypeParameterLength;", "+\t\t\tint genericsPtr = parser.genericsPtr;", "+\t\t\tboolean canConsume = genericsPtr + 1 >= length && parser.astPtr > -1;", "+\t\t\tif(canConsume) {", "+\t\t\t\tif (!(parser.astStack[parser.astPtr] instanceof TypeDeclaration)) {", "+\t\t\t\t\tcanConsume = false;", "+\t\t\t\t}", "+\t\t\t\twhile(genericsPtr + 1 > length && !(parser.genericsStack[genericsPtr] instanceof TypeParameter)) {", "+\t\t\t\t\tgenericsPtr--;", "+\t\t\t\t}", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tif(!(parser.genericsStack[genericsPtr - i] instanceof TypeParameter)) {", "+\t\t\t\t\t\tcanConsume = false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif(canConsume) {", "+\t\t\t\tTypeDeclaration typeDecl = (TypeDeclaration)parser.astStack[parser.astPtr];", "+\t\t\t\tSystem.arraycopy(parser.genericsStack, genericsPtr - length + 1, typeDecl.typeParameters = new TypeParameter[length], 0, length);", "+\t\t\t\ttypeDecl.bodyStart = typeDecl.typeParameters[length-1].declarationSourceEnd + 1;", "+\t\t\t\tparser.listTypeParameterLength = 0;", "+\t\t\t\tparser.lastCheckPoint = typeDecl.bodyStart;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8c4c01749b3a79e960ff33349d958025", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ReferenceCollection.java", "commitBeforeChange": "c4112ab397da10b85cbb2a3f081c4c91ed7c7975", "commitAfterChange": "2077df1da6fa132fd5beb7d042b102e760cf8cbf", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  public boolean includes(char[][][] qualifiedNames, char[][] simpleNames)", "signatureAfterChange": "  public boolean includes(char[][][] qualifiedNames, char[][] simpleNames, char[][] rootNames)", "diff": ["-public boolean includes(char[][][] qualifiedNames, char[][] simpleNames) {", "+public boolean includes(char[][][] qualifiedNames, char[][] simpleNames, char[][] rootNames) {", "+\tif (rootNames != null) {", "+\t\tboolean foundRoot = false;", "+\t\tfor (int i = 0, l = rootNames.length; !foundRoot && i < l; i++) {", "+\t\t\tfoundRoot = insideRoot(rootNames[i]);", "+\t\t\tif (JavaBuilder.DEBUG && foundRoot)", "+\t\t\t\tSystem.out.println(\"Found match in root \" + new String(rootNames[i])); //$NON-NLS-1$", "+\t\t}", "+\t\tif (!foundRoot)", "+\t\t\treturn false;", "+\t}", "-\t} else {", "-\t\tfor (int i = 0, l = simpleNames.length; i < l; i++) {", "+\t\treturn false;", "+\t}", "+", "+\tint sLength = simpleNames.length;", "+\tint qLength = qualifiedNames.length;", "+\tif (sLength <= qLength) {", "+\t\tfor (int i = 0; i < sLength; i++) {", "-\t\t\t\tfor (int j = 0, m = qualifiedNames.length; j < m; j++) {", "+\t\t\t\tfor (int j = 0; j < qLength; j++) {", "+\t} else {", "+\t\tfor (int i = 0; i < qLength; i++) {", "+\t\t\tchar[][] qualifiedName = qualifiedNames[i];", "+\t\t\tif (qualifiedName.length == 1 ? includes(qualifiedName[0]) : includes(qualifiedName)) {", "+\t\t\t\tfor (int j = 0; j < sLength; j++) {", "+\t\t\t\t\tif (includes(simpleNames[j])) {", "+\t\t\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\t\t\tSystem.out.println(\"Found match in \" + CharOperation.toString(qualifiedName) //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t+ \" to \" + new String(simpleNames[j])); //$NON-NLS-1$", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\treturn false;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2a0281d459b49ed3b370dc8f9e12234", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "d2d42dc68198e20f3f5cc7326a07cced2c751eb5", "commitAfterChange": "add5c6babb13b20df1267306ec710a4efca88a4d", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \tprivate IMethod createMethodHandle(\r \t\tAbstractMethodDeclaration method,\r \t\tchar[][] definingTypeNames)", "signatureAfterChange": "\r \tprivate IMethod createMethodHandle(\r \t\tAbstractMethodDeclaration method,\r \t\tchar[][] definingTypeNames)", "diff": ["+\t\tif (type == null) return null;\r", "-\t\tString[] parameterTypeSignatures = new String[length];\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tTypeReference parameterType = arguments[i].type;\r", "-\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');\r", "-\t\t\tfor (int j = 0; j < parameterType.dimensions(); j++) {\r", "-\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$\r", "+\t\tif (type.isBinary()) {\r", "+\t\t\tString selector = new String(method.selector);\r", "+\t\t\tIMethod[] methods;\r", "+\t\t\ttry {\r", "+\t\t\t\tmethods = type.getMethods();\r", "+\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\treturn null;\r", "-\t\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);\r", "+\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "+\t\t\t\tIMethod methodHandle = methods[i];\r", "+\t\t\t\tif (methodHandle.getElementName().equals(selector) && length == methodHandle.getNumberOfParameters()) {\r", "+\t\t\t\t\tboolean sameParameters = true;\r", "+\t\t\t\t\tString[] parameterTypes = methodHandle.getParameterTypes();\r", "+\t\t\t\t\tfor (int j = 0; j < length; j++) {\r", "+\t\t\t\t\t\tTypeReference parameterType = arguments[j].type;\r", "+\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');\r", "+\t\t\t\t\t\tfor (int k = 0; k < parameterType.dimensions(); k++) {\r", "+\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tString parameterTypeName = parameterTypes[j];\r", "+\t\t\t\t\t\tif (!Signature.toString(parameterTypeName).endsWith(new String(typeName))) {\r", "+\t\t\t\t\t\t\tsameParameters = false;\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (sameParameters) return methodHandle;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\treturn null;\r", "+\t\t} else {\r", "+\t\t\tString[] parameterTypeSignatures = new String[length];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tTypeReference parameterType = arguments[i].type;\r", "+\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');\r", "+\t\t\t\tfor (int j = 0; j < parameterType.dimensions(); j++) {\r", "+\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$\r", "+\t\t\t\t}\r", "+\t\t\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);\r", "+\t\t\t}\r", "+\t\t\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);\r", "-\t\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b047e75ae169ec3239be3a248d5bc555", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "d90d9bd95abe34cc0cfe3b06356eb1c26ea7d5bf", "commitAfterChange": "a1fcf7304168cfe820abddf9b4c29fb602e9a7cd", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": "\r \t\r \tprivate char[][] findMethodParameterNames(MethodBinding method, char[][] parameterTypeNames)", "signatureAfterChange": "\r \t\r \tprivate char[][] findMethodParameterNames(MethodBinding method, char[][] parameterTypeNames)", "diff": ["-//??\tif(bindingType.isBinaryBinding()) return null;\r", "-\t\t\r", "+\r", "+\t\t\r", "+\t\t\t\t} else if(answer.isBinaryType()) {\r", "+\t\t\t\t\tIBinaryType binaryType = answer.getBinaryType();\r", "+\t\t\t\t\tIBinaryMethod[] binaryMethods = binaryType.getMethods();\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tfor(int i = 0; i < binaryMethods.length ; i++){\r", "+\t\t\t\t\t\tIBinaryMethod binaryMethod = binaryMethods[i];\r", "+\t\t\t\t\t\tString[] argTypeStringNames = Signature.getParameterTypes(new String(binaryMethod.getMethodDescriptor()));\r", "+\t\t\t\t\t\tchar[][] argTypeNames = new char[argTypeStringNames.length][];\r", "+\t\t\t\t\t\tfor(int j = 0; j < argTypeStringNames.length; j++){\r", "+\t\t\t\t\t\t\targTypeNames[j] = argTypeStringNames[j].toCharArray();\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif(argTypeNames != null &&\r", "+\t\t\t\t\t\t\tCharOperation.equals(method.selector,binaryMethod.getSelector()) &&\r", "+\t\t\t\t\t\t\tCharOperation.equals(argTypeNames,parameterTypeNames)){\r", "+\t\t\t\t\t\t\tparameterNames = binaryMethod.getArgumentNames();\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\r", "-\r", "+\t\t// default parameters name\r", "+\t\tif(parameterNames == null) {\r", "+\t\t\tparameterNames = new char[length][];\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tparameterNames[i] = CharOperation.concat(ARG, String.valueOf(i).toCharArray());\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "baf2958a536396f4d429ea0941fb1a5d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "2510c8dbf38be0fd8d0b3e1c2fc8a96e80b0f2ee", "commitAfterChange": "e7a6f0c78fa0f5d341ebeb12cbf333c7e2a289ca", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "signatureAfterChange": " \t \tpublic boolean checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)", "diff": ["+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// if I2<T,U> extends I1<T>, then cast from I1<T> to I2<T,U> is unchecked", "+\t\t\t\t\t\t\t\t\tParameterizedTypeBinding paramCastType = (ParameterizedTypeBinding) castType;", "+\t\t\t\t\t\t\t\t\tParameterizedTypeBinding paramMatch = (ParameterizedTypeBinding) match;", "+\t\t\t\t\t\t\t\t\t// easy case if less parameters on match", "+\t\t\t\t\t\t\t\t\tTypeBinding[] castArguments = paramCastType.arguments;", "+\t\t\t\t\t\t\t\t\tint length = castArguments.length;", "+\t\t\t\t\t\t\t\t\tif (length > paramMatch.arguments.length) {", "+\t\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "+\t\t\t\t\t\t\t\t\t} else if ((paramCastType.tagBits & (TagBits.HasDirectWildcard|TagBits.HasTypeVariable)) != 0) {", "+\t\t\t\t\t\t\t\t\t\t// verify alternate cast type, substituting different type arguments", "+\t\t\t\t\t\t\t\t\t\tLookupEnvironment environment = scope.environment();", "+\t\t\t\t\t\t\t\t\t\tnextAlternateArgument: for (int i = 0; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\t\tswitch (castArguments[i].kind()) {", "+\t\t\t\t\t\t\t\t\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t\t\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak; // check substituting with other", "+\t\t\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nextAlternateArgument; // no alternative possible", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tTypeBinding[] alternateArguments;", "+\t\t\t\t\t\t\t\t\t\t\t// need to clone for each iteration to avoid env paramtype cache interference", "+\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(paramCastType.arguments, 0, alternateArguments = new TypeBinding[length], 0, length);", "+\t\t\t\t\t\t\t\t\t\t\talternateArguments[i] = scope.getJavaLangObject();", "+\t\t\t\t\t\t\t\t\t\t\tParameterizedTypeBinding alternateCastType = environment.createParameterizedType((ReferenceBinding)genericCastType, alternateArguments, castType.enclosingType());", "+\t\t\t\t\t\t\t\t\t\t\tif (alternateCastType.findSuperTypeOriginatingFrom(expressionType) == match) {", "+\t\t\t\t\t\t\t\t\t\t\t\tthis.bits |= UnsafeCast;", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}"]}], "num": 32808}