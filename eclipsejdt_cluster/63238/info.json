{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "927e9863cc50c6f5727f4dcc97a7ea0d", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "67ab077e1336e87a0411485d8d05a1f0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "132971f23d5ad724e7abdb8444fe685456f8fc05", "commitAfterChange": "243454d9ddff3b98b1fa12e536cfddbd176702ef", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  public TypeBinding[] inferElidedTypes(ReferenceBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope)", "signatureAfterChange": "  public TypeBinding[] inferElidedTypes(ReferenceBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope)", "diff": ["+\t\t// this is our last chance to inspect the result of the inference that is connected to the throw-away factory binding", "+\t\tInferenceContext18 infCtx18 = getInferenceContext(genericFactory);", "+\t\tif (infCtx18 != null && infCtx18.stepCompleted == InferenceContext18.BINDINGS_UPDATED) {", "+\t\t\t// refresh argumentTypes from updated bindings in arguments:", "+\t\t\t// (this shouldn't be strictly necessary, as FunctionExpression.isCompatibleWith() should give the same result,", "+\t\t\t//  but it's probably be a good idea to avoid the necessity to call isCompatibleWith() in the first place). ", "+\t\t\tfor (int i = 0; i < argumentTypes.length; i++) {", "+\t\t\t\tif (argumentTypes[i] instanceof PolyTypeBinding)", "+\t\t\t\t\targumentTypes[i] = this.arguments[i].resolvedType;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd3312610b3f141a7e1d93d610af2f25", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope)", "signatureAfterChange": "  public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope)", "diff": ["-public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {", "+public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {", "-\tMethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTypes, this);", "+\tMethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);", "-\t\t\tfor (int i = 0; i < argumentTypes.length; i++) {", "-\t\t\t\tif (argumentTypes[i] instanceof PolyTypeBinding)", "-\t\t\t\t\targumentTypes[i] = this.arguments[i].resolvedType;", "+\t\t\tfor (int i = 0; i < argumentTyps.length; i++) {", "+\t\t\t\tif (argumentTyps[i] instanceof PolyTypeBinding)", "+\t\t\t\t\targumentTyps[i] = this.arguments[i].resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da4be9efd143245d094c4087e47ea2ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope)", "signatureAfterChange": "  public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope)", "diff": ["-public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {", "+", "+public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope) {", "-\t\t// this is our last chance to inspect the result of the inference that is connected to the throw-away factory binding", "-\t\tInferenceContext18 infCtx18 = getInferenceContext(genericFactory);", "-\t\tif (infCtx18 != null && infCtx18.stepCompleted == InferenceContext18.BINDINGS_UPDATED) {", "-\t\t\t// refresh argumentTypes from updated bindings in arguments:", "-\t\t\t// (this shouldn't be strictly necessary, as FunctionExpression.isCompatibleWith() should give the same result,", "-\t\t\t//  but it's probably be a good idea to avoid the necessity to call isCompatibleWith() in the first place). ", "-\t\t\tfor (int i = 0; i < argumentTyps.length; i++) {", "-\t\t\t\tif (argumentTyps[i] instanceof PolyTypeBinding)", "-\t\t\t\t\targumentTyps[i] = this.arguments[i].resolvedType;", "-\t\t\t}", "-\t\t}"]}], "num": 63238}