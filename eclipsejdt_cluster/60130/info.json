{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a6484759ce91577bdad68e8d34d096c7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "392c3792aebf623cd7eac652a693ab38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "59140085e82a007301fe719ac3a015cad7f7cf84", "commitAfterChange": "848c4ddf1895eb24711ea8c54b1168746cb07972", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic MethodBinding getConstructor( \t\tReferenceBinding receiverType, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic boolean isBlockScope()", "diff": ["-\t */", "-\tpublic MethodBinding getConstructor(", "-\t\tReferenceBinding receiverType,", "-\t\tTypeBinding[] argumentTypes,", "-\t\tInvocationSite invocationSite) {", "-", "-\t\tcompilationUnitScope().recordTypeReference(receiverType);", "-\t\tcompilationUnitScope().recordTypeReferences(argumentTypes);", "-\t\tMethodBinding methodBinding = receiverType.getExactConstructor(argumentTypes);", "-\t\tif (methodBinding != null) {", "-\t\t\tif (methodBinding.canBeSeenBy(invocationSite, this))", "-\t\t\t\treturn methodBinding;", "-\t\t}", "-\t\tMethodBinding[] methods =", "-\t\t\treceiverType.getMethods(ConstructorDeclaration.ConstantPoolName);", "-\t\tif (methods == NoMethods) {", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\targumentTypes,", "-\t\t\t\tNotFound);", "-\t\t}", "-\t\tMethodBinding[] compatible = new MethodBinding[methods.length];", "-\t\tint compatibleIndex = 0;", "-\t\tfor (int i = 0, length = methods.length; i < length; i++)", "-\t\t\tif (areParametersAssignable(methods[i].parameters, argumentTypes))", "-\t\t\t\tcompatible[compatibleIndex++] = methods[i];", "-\t\tif (compatibleIndex == 0)", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\targumentTypes,", "-\t\t\t\tNotFound);", "-\t\t// need a more descriptive error... cannot convert from X to Y", "-", "-\t\tMethodBinding[] visible = new MethodBinding[compatibleIndex];", "-\t\tint visibleIndex = 0;", "-\t\tfor (int i = 0; i < compatibleIndex; i++) {", "-\t\t\tMethodBinding method = compatible[i];", "-\t\t\tif (method.canBeSeenBy(invocationSite, this))", "-\t\t\t\tvisible[visibleIndex++] = method;", "-\t\t}", "-\t\tif (visibleIndex == 1)", "-\t\t\treturn visible[0];", "-\t\tif (visibleIndex == 0)", "-\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\tcompatible[0],", "-\t\t\t\tConstructorDeclaration.ConstantPoolName,", "-\t\t\t\tcompatible[0].parameters,", "-\t\t\t\tNotVisible);", "-\t\treturn mostSpecificClassMethodBinding(visible, visibleIndex);", "-\t}", "+\t */", "+\tpublic boolean isBlockScope() {", "+\t\treturn true;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea2e0f80688dbfd1ace37158e303f912", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "commitAfterChange": "e6bf96fd82847410c46479a652f4e58f9a6dd052", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-", "-\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "-\t\t\tInitializationFlowContext initializerContext =", "-\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "-\t\t\t", "-\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\t", "-\t\t\tif (fields != null) {", "-\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\tFieldDeclaration field = fields[i];", "-\t\t\t\t\t/*if (field.isField() && !this.binding.isAnonymousType()){", "-\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tfieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);", "-\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (memberTypes != null) {", "-\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (methods != null) {", "-\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tif (method.isConstructor()) { // constructor", "-\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "-\t\t\t\t\t} else { // regular method", "-\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tinternalAnalyseCode(flowContext, flowInfo); ", "+", "+//\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "+//\t\t\tInitializationFlowContext initializerContext =", "+//\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "+//\t\t\t", "+//\t\t\tFlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\t", "+//\t\t\tif (fields != null) {", "+//\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "+//\t\t\t\t\tFieldDeclaration field = fields[i];", "+//\t\t\t\t\t/*if (field.isField() && !this.binding.isAnonymousType()){", "+//\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous", "+//\t\t\t\t\t} else {*/", "+//\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "+//\t\t\t\t\t/*}*/", "+//\t\t\t\t\tfieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);", "+//\t\t\t\t\tif (fieldInfo == FlowInfo.DEAD_END) {", "+//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "+//\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "+//\t\t\t\t\t\tfieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (memberTypes != null) {", "+//\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "+//\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());", "+//\t\t\t\t}", "+//\t\t\t}", "+//\t\t\tif (methods != null) {", "+//\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "+//\t\t\t\tFlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "+//\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "+//\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "+//\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "+//\t\t\t\t\t\tcontinue;", "+//\t\t\t\t\tif (method.isConstructor()) { // constructor", "+//\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "+//\t\t\t\t\t} else { // regular method", "+//\t\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "+//\t\t\t\t\t}", "+//\t\t\t\t}", "+//\t\t\t}"]}], "num": 60130}