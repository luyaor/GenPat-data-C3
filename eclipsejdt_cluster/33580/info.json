{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "738820cfdf9cdde9144b519645686f2f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5812333d77792e6af0ec5a862d7317f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "cd405a8db634596f85cfafeafe4d4ea561cbd638", "commitAfterChange": "928bbf160d6f9d1eb9d492c7bd7fb73692671b03", "methodNumberBeforeChange": 157, "methodNumberAfterChange": 157, "signatureBeforeChange": " protected boolean moveRecoveryCheckpoint()", "signatureAfterChange": " protected boolean moveRecoveryCheckpoint()", "diff": ["-\tif (completionScanner.record) {", "-\t\tcompletionScanner.currentToken = -1;", "-\t\tcompletionScanner.currentTokenStart = 0;", "+\tboolean recordIdentifers = completionScanner.record;", "+\tif (!recordIdentifers) {", "+\t\treturn super.moveRecoveryCheckpoint();", "-\treturn super.moveRecoveryCheckpoint();", "+\t", "+\tcompletionScanner.record = false;", "+\t", "+\tint pos = this.lastCheckPoint;", "+\tint curTok = completionScanner.lastUsedToken;", "+\tint curTokStart = completionScanner.lastUsedTokenStart;", "+\t", "+\t/* reset this.scanner, and move checkpoint by one token */", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.diet = false; // quit jumping over method bodies", "+\t", "+\tcompletionScanner.currentToken = curTok;", "+\tcompletionScanner.currentTokenStart = curTokStart;", "+\t", "+\t/* if about to restart, then no need to shift token */", "+\tif (this.restartRecovery){", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.scanner.insideRecovery = true;\t\t", "+\t\tcompletionScanner.record = true;", "+\t\treturn true;", "+\t}", "+\t", "+\t/* protect against shifting on an invalid token */", "+\tthis.lastIgnoredToken = this.nextIgnoredToken;", "+\tthis.nextIgnoredToken = -1;", "+\tdo {", "+\t\ttry {", "+\t\t\tthis.nextIgnoredToken = this.scanner.getNextToken();", "+\t\t\tif(this.scanner.currentPosition == this.scanner.startPosition){", "+\t\t\t\tthis.scanner.currentPosition++; // on fake completion identifier", "+\t\t\t\tthis.nextIgnoredToken = -1;", "+\t\t\t}", "+\t\t\t", "+\t\t} catch(InvalidInputException e){", "+\t\t\tpos = this.scanner.currentPosition;", "+\t\t}", "+\t} while (this.nextIgnoredToken < 0);", "+\t", "+\tif (this.nextIgnoredToken == TokenNameEOF) { // no more recovery after this point", "+\t\tif (this.currentToken == TokenNameEOF) { // already tried one iteration on EOF", "+\t\t\tcompletionScanner.record = true;", "+\t\t\treturn false;", "+\t\t}", "+\t}", "+\tthis.lastCheckPoint = this.scanner.currentPosition;", "+\tcompletionScanner.lastUsedToken = this.nextIgnoredToken;", "+\tcompletionScanner.lastUsedTokenStart = this.lastCheckPoint;", "+\t", "+\t/* reset this.scanner again to previous checkpoint location*/", "+\tthis.scanner.startPosition = pos;", "+\tthis.scanner.currentPosition = pos;", "+\tthis.scanner.commentPtr = -1;", "+\tthis.scanner.foundTaskCount = 0;", "+\t", "+\tcompletionScanner.currentToken = curTok;", "+\tcompletionScanner.currentTokenStart = curTokStart;", "+\tcompletionScanner.record = true;", "+\t\t", "+\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0ace4cecc7654cc5639607c770aa1ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "6e2621b16cebac618a0b920fb0898b360d0eb4c5", "commitAfterChange": "080a42c1d10403c7486b8cde9973df6dc09a8d9d", "methodNumberBeforeChange": 44, "methodNumberAfterChange": 44, "signatureBeforeChange": "  \tprivate void printIndentationIfNecessary(StringBuffer buffer)", "signatureAfterChange": "  \tprivate void printIndentationIfNecessary(StringBuffer buffer)", "diff": ["-\t\t\t\twhile (this.column <= this.indentationLevel) {", "-\t\t\t\t\tbuffer.append('\\t');", "-\t\t\t\t\tthis.lastNumberOfNewLines = 0;", "-\t\t\t\t\tint complement = this.tabLength - ((this.column - 1) % this.tabLength); // amount of space", "-\t\t\t\t\tthis.column += complement;", "-\t\t\t\t\tthis.needSpace = false;", "+\t\t\t\tboolean useTabsForLeadingIndents = this.useTabsOnlyForLeadingIndents;", "+\t\t\t\tint numberOfLeadingIndents = this.numberOfIndentations;", "+\t\t\t\tint indentationsAsTab = 0;", "+\t\t\t\tif (useTabsForLeadingIndents) {", "+\t\t\t\t\twhile (this.column <= this.indentationLevel) {", "+\t\t\t\t\t\tif (indentationsAsTab < numberOfLeadingIndents) {", "+\t\t\t\t\t\t\tbuffer.append('\\t');", "+\t\t\t\t\t\t\tindentationsAsTab++;", "+\t\t\t\t\t\t\tthis.lastNumberOfNewLines = 0;", "+\t\t\t\t\t\t\tint complement = this.tabLength - ((this.column - 1) % this.tabLength); // amount of space", "+\t\t\t\t\t\t\tthis.column += complement;", "+\t\t\t\t\t\t\tthis.needSpace = false;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\tthis.needSpace = false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\twhile (this.column <= this.indentationLevel) {", "+\t\t\t\t\t\tbuffer.append('\\t');", "+\t\t\t\t\t\tthis.lastNumberOfNewLines = 0;", "+\t\t\t\t\t\tint complement = this.tabLength - ((this.column - 1) % this.tabLength); // amount of space", "+\t\t\t\t\t\tthis.column += complement;", "+\t\t\t\t\t\tthis.needSpace = false;", "+\t\t\t\t\t}", "-\t\t\t\twhile (this.column <= this.indentationLevel) {", "-\t\t\t\t\tif ((this.column - 1 + this.tabLength) <= this.indentationLevel) {", "-\t\t\t\t\t\tbuffer.append('\\t');", "-\t\t\t\t\t\tthis.column += this.tabLength;", "-\t\t\t\t\t} else if ((this.column - 1 + this.indentationSize) <= this.indentationLevel) {", "-\t\t\t\t\t\t// print one indentation", "-\t\t\t\t\t\tfor (int i = 0, max = this.indentationSize; i < max; i++) {", "+\t\t\t\tuseTabsForLeadingIndents = this.useTabsOnlyForLeadingIndents;", "+\t\t\t\tnumberOfLeadingIndents = this.numberOfIndentations;", "+\t\t\t\tindentationsAsTab = 0;", "+\t\t\t\tif (useTabsForLeadingIndents) {", "+\t\t\t\t\tfinal int columnForLeadingIndents = numberOfLeadingIndents * this.indentationSize;", "+\t\t\t\t\twhile (this.column <= this.indentationLevel) {", "+\t\t\t\t\t\tif (this.column <= columnForLeadingIndents) {", "+\t\t\t\t\t\t\tif ((this.column - 1 + this.tabLength) <= this.indentationLevel) {", "+\t\t\t\t\t\t\t\tbuffer.append('\\t');", "+\t\t\t\t\t\t\t\tthis.column += this.tabLength;", "+\t\t\t\t\t\t\t} else if ((this.column - 1 + this.indentationSize) <= this.indentationLevel) {", "+\t\t\t\t\t\t\t\t// print one indentation", "+\t\t\t\t\t\t\t\tfor (int i = 0, max = this.indentationSize; i < max; i++) {", "+\t\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tfor (int i = this.column, max = this.indentationLevel; i <= max; i++) {", "+\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.needSpace = false;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\twhile (this.column <= this.indentationLevel) {", "+\t\t\t\t\t\tif ((this.column - 1 + this.tabLength) <= this.indentationLevel) {", "+\t\t\t\t\t\t\tbuffer.append('\\t');", "+\t\t\t\t\t\t\tthis.column += this.tabLength;", "+\t\t\t\t\t\t} else if ((this.column - 1 + this.indentationSize) <= this.indentationLevel) {", "+\t\t\t\t\t\t\t// print one indentation", "+\t\t\t\t\t\t\tfor (int i = 0, max = this.indentationSize; i < max; i++) {", "+\t\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\tthis.needSpace = false;", "-\t\t\t\t\tthis.needSpace = false;"]}], "num": 33580}