{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9e4f6b1106ad5f78f05dcbd3713cd36", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "119dbe6f5be18fa0f028f5ee6dec7ca4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "d5bfe063c252b2db98f4d11e1c90a755611d0a56", "commitAfterChange": "bc1023a3db35de5f11d5861f411b9a4de78ba0ab", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tpublic synchronized int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "signatureAfterChange": " \tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "diff": ["-\tpublic synchronized int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException {", "+\tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException {", "+\t\t", "+\t\t// create the delta builder (this remembers the current content of the working copy)", "+\t\t// outside the perWorkingCopyInfos lock (see bug 50667)", "+\t\tJavaElementDeltaBuilder deltaBuilder = null;", "+\t\tif (workingCopy.isPrimary()) {", "+\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "+\t\t}", "+\t\tPerWorkingCopyInfo info = null;", "-\t\t\tPerWorkingCopyInfo info = (PerWorkingCopyInfo)workingCopyToInfos.get(workingCopy);", "+\t\t\tinfo = (PerWorkingCopyInfo)workingCopyToInfos.get(workingCopy);", "-\t\t\t\t// create the delta builder (this remembers the current content of the working copy)", "-\t\t\t\tJavaElementDeltaBuilder deltaBuilder = null;", "-\t\t\t\tif (workingCopy.isPrimary()) {", "-\t\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "-\t\t\t\t}", "-", "-", "-\t\t\t\t// remove infos + close buffer (since no longer working copy)", "-\t\t\t\tremoveInfoAndChildren(workingCopy);", "-\t\t\t\tworkingCopy.closeBuffer();", "-", "-\t\t\t\t// compute the delta if needed and register it if there are changes", "-\t\t\t\tif (deltaBuilder != null) {", "-\t\t\t\t\tdeltaBuilder.buildDeltas();", "-\t\t\t\t\tif ((deltaBuilder.delta != null) && (deltaBuilder.delta.getAffectedChildren().length > 0)) {", "-\t\t\t\t\t\tgetDeltaProcessor().registerJavaModelDelta(deltaBuilder.delta);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\treturn info.useCount;", "+\t\tif (info.useCount == 0) { // info cannot be null here (check was done above)", "+\t\t\t// remove infos + close buffer (since no longer working copy)", "+\t\t\t// outside the perWorkingCopyInfos lock (see bug 50667)", "+\t\t\tremoveInfoAndChildren(workingCopy);", "+\t\t\tworkingCopy.closeBuffer();", "+", "+\t\t\t// compute the delta if needed and register it if there are changes", "+\t\t\tif (deltaBuilder != null) {", "+\t\t\t\tdeltaBuilder.buildDeltas();", "+\t\t\t\tif ((deltaBuilder.delta != null) && (deltaBuilder.delta.getAffectedChildren().length > 0)) {", "+\t\t\t\t\tgetDeltaProcessor().registerJavaModelDelta(deltaBuilder.delta);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn info.useCount;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79d22eb8b918ab1c25367f128f0c8fd0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyTests.java", "commitBeforeChange": "54aac0437c44b25b70bb8f51692a810dc70acaf9", "commitAfterChange": "e09428ece4109f2ed53a5b654918b21f327e1ef3", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 54, "signatureBeforeChange": " public void testNonExistingCU() throws JavaModelException", "signatureAfterChange": " public void testNonExistingCU() throws JavaModelException", "diff": ["-\tICompilationUnit cu = this.getCompilationUnit(\"P/src/x/y/NonExisting.java\");", "-\tIWorkingCopy copy = null;", "+\tICompilationUnit nonExistingCU = this.getCompilationUnit(\"P/src/x/y/NonExisting.java\");", "+\tIWorkingCopy workingCopy = null;", "-\t\tcopy = (IWorkingCopy)cu.getWorkingCopy();", "-\t\tassertSourceEquals(\"Buffer should be empty\", \"\", ((IOpenable)copy).getBuffer().getContents());", "+\t\tworkingCopy = (IWorkingCopy)nonExistingCU.getWorkingCopy();", "+\t\tassertSourceEquals(\"Buffer should be empty\", \"\", ((IOpenable)workingCopy).getBuffer().getContents());", "-\t\tassertTrue(\"Working copy should exists\", ((IJavaElement)copy).exists());", "+\t\tassertTrue(\"Working copy should exists\", ((IJavaElement)workingCopy).exists());", "-\t\tassertEquals(\"Corresponding resource should be null\", null, ((IJavaElement)copy).getCorrespondingResource());", "+\t\tassertEquals(\"Corresponding resource should be null\", null, ((IJavaElement)workingCopy).getCorrespondingResource());", "-\t\tassertEquals(\"Unexpected orginal element\", cu, copy.getOriginalElement());", "+\t\tassertEquals(\"Unexpected orginal element\", nonExistingCU, workingCopy.getOriginalElement());", "-\t\tassertEquals(\"Unexpected path\", new Path(\"/P/src/x/y/NonExisting.java\"), ((IJavaElement)copy).getPath());", "+\t\tassertEquals(\"Unexpected path\", new Path(\"/P/src/x/y/NonExisting.java\"), ((IJavaElement)workingCopy).getPath());", "-\t\tassertEquals(\"Unexpected resource\", null, ((IJavaElement)copy).getResource());", "+\t\tassertEquals(\"Unexpected resource\", null, ((IJavaElement)workingCopy).getResource());", "-\t\tassertTrue(\"Working copy should be consistent\", ((IOpenable)copy).isConsistent());", "+\t\tassertTrue(\"Working copy should be consistent\", ((IOpenable)workingCopy).isConsistent());", "-\t\t\tcopy.restore();", "+\t\t\tworkingCopy.restore();", "-\t\t((IOpenable)copy).getBuffer().setContents(", "+\t\t((IOpenable)workingCopy).getBuffer().setContents(", "-\t\tassertTrue(\"Working copy should not be consistent\", !((IOpenable)copy).isConsistent());", "-\t\t((IOpenable)copy).makeConsistent(null);", "-\t\tassertTrue(\"Working copy should be consistent\", ((IOpenable)copy).isConsistent());", "+\t\tassertTrue(\"Working copy should not be consistent\", !((IOpenable)workingCopy).isConsistent());", "+\t\t((IOpenable)workingCopy).makeConsistent(null);", "+\t\tassertTrue(\"Working copy should be consistent\", ((IOpenable)workingCopy).isConsistent());", "-\t\t((IOpenable)copy).getBuffer().setContents(", "+\t\t((IOpenable)workingCopy).getBuffer().setContents(", "-\t\t((IOpenable)copy).save(null, false);", "-\t\tassertTrue(\"Working copy should be consistent after save\", ((IOpenable)copy).isConsistent());", "-\t\tassertTrue(\"Original cu should not exist\", !cu.exists());", "+\t\t((IOpenable)workingCopy).save(null, false);", "+\t\tassertTrue(\"Working copy should be consistent after save\", ((IOpenable)workingCopy).isConsistent());", "+\t\tassertTrue(\"Original cu should not exist\", !nonExistingCU.exists());", "-\t\tcopy.commit(false, null);", "-\t\tassertTrue(\"Original cu should exist\", cu.exists());", "+\t\tworkingCopy.commit(false, null);", "+\t\tassertTrue(\"Original cu should exist\", nonExistingCU.exists());", "-\t\tassertTrue(\"Working copy should not be based on original resource\", !copy.isBasedOn(cu.getResource()));", "+\t\tassertTrue(\"Working copy should not be based on original resource\", !workingCopy.isBasedOn(nonExistingCU.getResource()));", "-\t\tif (copy != null) {", "-\t\t\tcopy.destroy();", "+\t\tif (workingCopy != null) {", "+\t\t\tworkingCopy.destroy();", "-\t\tif (cu.exists()) {", "-\t\t\tcu.delete(true, null);", "+\t\tif (nonExistingCU.exists()) {", "+\t\t\tnonExistingCU.delete(true, null);"]}], "num": 70161}