{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c3f4a7ce41799956b877e0e1bca7fd5c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "27879784d9433978777be763946ed32d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "0e8ca24e8451f1d91ed53a269d184ea21d12301f", "commitAfterChange": "369ffd3db09511488e039ba2575df2eeea055320", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r private boolean updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta)", "signatureAfterChange": "\r private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType)", "diff": ["-private boolean updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta) {\r", "+private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType) {\r", "+\tOpenable element;\r", "+\t\t\telement = this.createElement(delta.getResource(), elementType);\r", "+\t\t\tif (element == null) return false;\r", "-\t\t\tif (element instanceof IPackageFragmentRoot) {\r", "-\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");//$NON-NLS-1$\r", "-\t\t\t}\r", "-\t\t\tif (element instanceof IPackageFragment) {\r", "-\t\t\t\t// add subpackages\r", "-\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "-\t\t\t\tString name = element.getElementName();\r", "-\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "-\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "-\t\t\t\t\tIResourceDelta child = children[i];\r", "-\t\t\t\t\tIResource resource = child.getResource();\r", "-\t\t\t\t\tif (resource instanceof IFolder) {", "-\t\t\t\t\t\tString subpkgName = \r", "-\t\t\t\t\t\t\tname.length() == 0 ? \r", "-\t\t\t\t\t\t\t\tresource.getName() : \r", "-\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "-\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "-\t\t\t\t\t\tthis.updateCurrentDeltaAndIndex(subpkg, child);\r", "-\t\t\t\t\t}", "-\t\t\t\t}\r", "-\t\t\t}\r", "+\t\t\telement = this.createElement(delta.getResource(), elementType);\r", "+\t\t\tif (element == null) return false;\r", "-\t\t\tif (element instanceof IPackageFragmentRoot) {\r", "-\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");//$NON-NLS-1$\r", "-\t\t\t}\r", "-\t\t\tif (element instanceof IPackageFragment) {\r", "-\t\t\t\t// remove subpackages\r", "-\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "-\t\t\t\tString name = element.getElementName();\r", "-\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "-\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "-\t\t\t\t\tIResourceDelta child = children[i];\r", "-\t\t\t\t\tIResource resource = child.getResource();\r", "-\t\t\t\t\tif (resource instanceof IFolder) {\r", "-\t\t\t\t\t\tString subpkgName = \r", "-\t\t\t\t\t\t\tname.length() == 0 ? \r", "-\t\t\t\t\t\t\t\tresource.getName() : \r", "-\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "-\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "-\t\t\t\t\t\tthis.updateCurrentDeltaAndIndex(subpkg, child);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "+\t\t\t\telement = this.createElement(delta.getResource(), elementType);\r", "+\t\t\t\tif (element == null) return false;\r", "+\t\t\t\telement = this.createElement(delta.getResource(), elementType);\r", "+\t\t\t\tif (element == null) return false;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "54f805dec643eb2cd94b8e2d0dcc4fd0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "08c5b9004bde27fb4063ce300ce881966676fe74", "commitAfterChange": "28d58bf6eb942015446b8ffce8f446f86e9686d9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\tif ((this.binding = scope.getConstructor(allocationType, argumentTypes, this)).isValidBinding()) {", "-\t\t\t\tif (polyExpressionSeen) {", "-\t\t\t\t\tboolean variableArity = this.binding.isVarargs();", "-\t\t\t\t\tfinal TypeBinding[] parameters = this.binding.parameters;", "-\t\t\t\t\tfinal int parametersLength = parameters.length;", "-\t\t\t\t\tfor (int i = 0, length = this.arguments == null ? 0 : this.arguments.length; i < length; i++) {", "-\t\t\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\t\t\tTypeBinding parameterType = i < parametersLength ? parameters[i] : parameters[parametersLength - 1];", "-\t\t\t\t\t\tif (argumentTypes[i] instanceof PolyTypeBinding) {", "-\t\t\t\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\t\t\t\t\tif (variableArity && i >= parametersLength - 1)", "-\t\t\t\t\t\t\t\targument.tagAsEllipsisArgument();", "-\t\t\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\t\t\targumentTypes[i] = argument.resolveType(scope);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\tthis.binding = scope.getConstructor(allocationType, argumentTypes, this);", "+\t\t\tif (polyExpressionSeen && polyExpressionsHaveErrors(scope, this.binding, this.arguments, argumentTypes))", "+\t\t\t\treturn null;", "+\t\t\tif (this.binding.isValidBinding()) {\t", "+\t\tif (polyExpressionSeen && polyExpressionsHaveErrors(scope, inheritedBinding, this.arguments, argumentTypes))", "+\t\t\treturn null;", "-\t\t}", "-\t\tif (polyExpressionSeen) {", "-\t\t\tboolean variableArity = inheritedBinding.isVarargs();", "-\t\t\tfinal TypeBinding[] parameters = inheritedBinding.parameters;", "-\t\t\tfinal int parametersLength = parameters.length;", "-\t\t\tfor (int i = 0, length = this.arguments == null ? 0 : this.arguments.length; i < length; i++) {", "-\t\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\tTypeBinding parameterType = i < parametersLength ? parameters[i] : parameters[parametersLength - 1];", "-\t\t\t\tif (argumentTypes[i] instanceof PolyTypeBinding) {", "-\t\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\t\t\tif (variableArity && i >= parametersLength - 1)", "-\t\t\t\t\t\targument.tagAsEllipsisArgument();", "-\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\targumentTypes[i] = argument.resolveType(scope);", "-\t\t\t\t}", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e870a862a13fd1ea3dcac8a71b81017d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "99d47e4046e97803f75625986f5eb5ffc13cddfe", "commitAfterChange": "8282cb3c46786d73ca763e64384724ac9c0798d9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 0, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["+\t */\t", "+\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "+\t\t", "+\t\tParameterizedGenericMethodBinding methodSubstitute;", "+\t\tTypeVariableBinding[] typeVariables = originalMethod.typeVariables;", "+\t\tTypeBinding[] substitutes = invocationSite.genericTypeArguments();", "+\t\t", "+\t\tcomputeSubstitutes: {", "+\t\t\tif (substitutes != null) {", "+\t\t\t\t// explicit type arguments got supplied", "+\t\t\t\tif (substitutes.length != typeVariables.length) {", "+\t\t\t        // incompatible due to wrong arity", "+\t\t\t        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, TypeParameterArityMismatch);", "+\t\t\t\t}", "+\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "+\t\t\t\tbreak computeSubstitutes;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// perform type argument inference (15.12.2.7)", "+\t\t\t\t", "+\t\t\t// initializes the map of substitutes (var --> type[][]{ equal, extends, super}", "+\t\t\tTypeBinding[] parameters = originalMethod.parameters;", "+\t\t\tint varLength = typeVariables.length;", "+\t\t\tMap collectedSubstitutes = new HashMap(varLength);", "+\t\t\tfor (int i = 0; i < varLength; i++)", "+\t\t\t\tcollectedSubstitutes.put(typeVariables[i], new TypeBinding[3][]);", "+\t\t\t", "+\t\t\tsubstitutes = new TypeBinding[varLength];", "+\t\t\tmethodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, collectedSubstitutes, substitutes);", "+\t\t\tif (methodSubstitute == null) ", "+\t\t\t\treturn null;", "+\t\t\t// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method", "+\t\t\t", "+\t\t\t// 15.12.2.8 - inferring unresolved type arguments", "+\t\t\tif (hasUnresolvedTypeArgument(substitutes)) {", "+\t\t\t\tTypeBinding expectedType = null;", "+\t\t\t\t// if message invocation has expected type", "+\t\t\t\tif (invocationSite instanceof MessageSend) {", "+\t\t\t\t\tMessageSend message = (MessageSend) invocationSite;", "+\t\t\t\t\texpectedType = message.expectedType;", "+\t\t\t\t} ", "+\t\t\t\tif (expectedType == null) {", "+\t\t\t\t\tif (methodSubstitute.returnType.isTypeVariable()) {", "+\t\t\t\t\t\t// should be: if no expected type, then assume Object", "+\t\t\t\t\t\t// actually it rather seems to handle the returned variable case by expecting its erasure instead", "+\t\t\t\t\t\texpectedType = methodSubstitute.returnType.erasure();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\texpectedType = scope.getJavaLangObject(); ", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, expectedType, collectedSubstitutes, substitutes);", "+\t\t\t\tif (methodSubstitute == null) ", "+\t\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\t// bounds check", "+\t\tif (!methodSubstitute.isRaw) {", "+\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "+\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "+\t\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitute))", "+\t\t\t        // incompatible due to bound check", "+\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitute, typeVariables[i] }, ParameterBoundMismatch);", "+\t\t\t}", "+\t\t}", "+", "+\t\treturn methodSubstitute;", "+\t}", "-\t */\t", "-\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "-\t\t", "-\t\tParameterizedGenericMethodBinding methodSubstitute;", "-\t\tTypeVariableBinding[] typeVariables = originalMethod.typeVariables;", "-\t\tTypeBinding[] substitutes = invocationSite.genericTypeArguments();", "-\t\t", "-\t\tif (substitutes != null) {", "-\t\t\tif (substitutes.length != typeVariables.length) {", "-\t\t        // incompatible due to wrong arity", "-\t\t        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, TypeParameterArityMismatch);", "-\t\t\t}", "-\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t} else {", "-\t\t\t// perform type inference based on argument types and expected type", "-\t\t\t", "-\t\t\t// collect substitutes by pattern matching parameters and arguments", "-\t\t\tTypeBinding[] parameters = originalMethod.parameters;", "-\t\t\tint varLength = typeVariables.length;", "-\t\t\tHashMap collectedSubstitutes = new HashMap(varLength);", "-\t\t\tfor (int i = 0; i < varLength; i++)", "-\t\t\t\tcollectedSubstitutes.put(typeVariables[i], new TypeBinding[1]);", "-\t\t\t", "-\t\t\t// collect argument type mapping, handling varargs", "-\t\t\tif (originalMethod.isVarargs()) {", "-\t\t\t\tint paramLength = parameters.length;", "-\t\t\t\tint minArgLength = paramLength - 1;", "-\t\t\t\tint argLength = arguments.length;", "-\t\t\t\t// process mandatory arguments", "-\t\t\t\tfor (int i = 0; i < minArgLength; i++)", "-\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t\t// process optional arguments", "-\t\t\t\tif (minArgLength < argLength) {", "-\t\t\t\t\tTypeBinding varargType = parameters[minArgLength]; // last arg type - as is ?", "-\t\t\t\t\tif (paramLength != argLength // argument is passed as is ?", "-\t\t\t\t\t\t\t||  (arguments[minArgLength] != NullBinding", "-\t\t\t\t\t\t\t\t\t&& (arguments[minArgLength].dimensions() == 0))) { ", "-\t\t\t\t\t\tvarargType = ((ArrayBinding)varargType).elementsType(); // eliminate one array dimension", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int i = minArgLength; i < argLength; i++)", "-\t\t\t\t\t\tvarargType.collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tint paramLength = parameters.length;", "-\t\t\t\tfor (int i = 0; i < paramLength; i++)", "-\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t}", "-\t\t\tboolean needReturnTypeInference = false;", "-\t\t\tif (collectedSubstitutes.isEmpty()) {", "-\t\t\t\t// raw generic method inferred", "-\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, (RawTypeBinding)null, scope.environment());", "-\t\t\t} else {", "-\t\t\t\tsubstitutes = new TypeBinding[varLength];", "-\t\t\t\tfor (int i = 0; i < varLength; i++) {", "-\t\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) collectedSubstitutes.get(typeVariables[i]);", "-\t\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\t\t\tif (mostSpecificSubstitute == null)", "-\t\t\t\t\t\treturn null; // incompatible", "-\t\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "-\t\t\t\t\t\tneedReturnTypeInference = true;", "-\t\t\t\t\t    mostSpecificSubstitute = typeVariables[i];", "-\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tsubstitutes[i] = mostSpecificSubstitute;", "-\t\t\t\t}", "-\t\t\t\t// apply inferred variable substitutions", "-\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t\t}", "-\t", "-\t\t\tif (needReturnTypeInference && invocationSite instanceof MessageSend) {", "-\t\t\t\tMessageSend message = (MessageSend) invocationSite;", "-\t\t\t\tTypeBinding expectedType = message.expectedType;", "-\t\t\t\tif (expectedType == null) {", "-\t\t\t\t\t// 15.12.2.8 - if no expected type, then assume Object", "-\t\t\t\t\t// actually it rather seems to handle the returned variable case by expecting its erasure instead", "-\t\t\t\t\tif (methodSubstitute.returnType.isTypeVariable()) {", "-\t\t\t\t\t\texpectedType = methodSubstitute.returnType.erasure();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\texpectedType =scope.getJavaLangObject(); ", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tmethodSubstitute.inferFromExpectedType(expectedType, scope);", "-\t\t\t}", "-\t\t}", "-\t\t// check bounds", "-\t\tif (!methodSubstitute.isRaw) {", "-\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "-\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "-\t\t\t    TypeBinding substitute = substitutes[i];", "-\t\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitute))", "-\t\t\t        // incompatible due to bound check", "-\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitutes[i], typeVariables[i] }, ParameterBoundMismatch);", "-\t\t\t}", "-\t\t}", "-\t\treturn methodSubstitute;"]}], "num": 13180}