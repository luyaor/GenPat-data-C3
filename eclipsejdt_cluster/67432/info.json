{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c0d13f802d12b78a3a0ac8859473874e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ee783f04bddb519b13b3d8556447840", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "f8e06af2d64912de617f742baa744d8cff14ca39", "commitAfterChange": "799bcf90c7e5ed6ce45339b7f5c6f4ecccd1d29c", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["+\t\t\t}", "+\t\t}", "+\t\tif (!argumentsTypeElided && !buggyArguments) {", "+\t\t\tParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(this.expectedType);", "+\t\t\tif (withWildCards != null) {", "+\t\t\t\t// invoke 18.5.3 Functional Interface Parameterization Inference", "+\t\t\t\tInferenceContext18 ctx = new InferenceContext18(methodScope);", "+\t\t\t\tTypeBinding[] q = ctx.createBoundsForFunctionalInterfaceParameterizationInference(withWildCards);", "+\t\t\t\tif (q.length != this.arguments.length) {", "+\t\t\t\t\t// fail  TODO: can this still happen here?", "+\t\t\t\t} else {", "+\t\t\t\t\tif (ctx.reduceWithEqualityConstraints(this.argumentTypes, q)) {", "+\t\t\t\t\t\tTypeBinding[] a = withWildCards.arguments;", "+\t\t\t\t\t\tTypeBinding[] aprime = ctx.getFunctionInterfaceArgumentSolutions(a);", "+\t\t\t\t\t\t// TODO If F<A'1, ..., A'm> is a well-formed type, ...", "+\t\t\t\t\t\tReferenceBinding genericType = withWildCards.genericType();", "+\t\t\t\t\t\tthis.resolvedType = blockScope.environment().createParameterizedType(genericType, aprime, genericType.enclosingType());", "+\t\t\t\t\t\tthis.descriptor = this.resolvedType.getSingleAbstractMethod(blockScope, false);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tArgument argument = this.arguments[i];", "+\t\t\tTypeBinding parameterType;", "+\t\t\tfinal TypeBinding expectedParameterType = haveDescriptor && i < this.descriptor.parameters.length ? this.descriptor.parameters[i] : null;", "+\t\t\tparameterType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];", "+\t\t\tif (parameterType != null && parameterType != TypeBinding.VOID) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48b6161903cbe7df230ca46177bc7b07", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/compiler/tool/EclipseFileManager.java", "commitBeforeChange": "05ca87fa79cdcdbf8adddd11b0044e5bbc381076", "commitAfterChange": "1a08d829c1b17811d102043c26cfbba0a6765570", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic JavaFileObject getJavaFileForOutput(Location location, String className, Kind kind, FileObject sibling) \t\t\tthrows IOException", "signatureAfterChange": " \tpublic JavaFileObject getJavaFileForOutput(Location location, String className, Kind kind, FileObject sibling) \t\t\tthrows IOException", "diff": ["-\t\t\tthrow new IllegalArgumentException(\"Unknown location : \" + location);//$NON-NLS-1$", "+\t\t\tif (!location.equals(StandardLocation.CLASS_OUTPUT))", "+\t\t\t\tthrow new IllegalArgumentException(\"Unknown location : \" + location);//$NON-NLS-1$", "+\t\t\t// we will use either the sibling or user.dir", "+\t\t\tif (sibling != null) {", "+\t\t\t\tString normalizedFileName = normalized(className);", "+\t\t\t\tint index = normalizedFileName.lastIndexOf('/');", "+\t\t\t\tif (index != -1) {", "+\t\t\t\t\tnormalizedFileName = normalizedFileName.substring(index + 1);", "+\t\t\t\t}", "+\t\t\t\tnormalizedFileName += kind.extension;", "+\t\t\t\tURI uri = sibling.toUri();", "+\t\t\t\tURI uri2 = null;", "+\t\t\t\ttry {", "+\t\t\t\t\tString path = uri.getPath();", "+\t\t\t\t\tindex = path.lastIndexOf('/');", "+\t\t\t\t\tif (index != -1) {", "+\t\t\t\t\t\tpath = path.substring(0, index + 1);", "+\t\t\t\t\t\tpath += normalizedFileName;", "+\t\t\t\t\t}", "+\t\t\t\t\turi2 = new URI(uri.getScheme(), uri.getHost(), path, uri.getFragment());", "+\t\t\t\t} catch (URISyntaxException e) {", "+\t\t\t\t\tthrow new IllegalArgumentException(\"invalid sibling\");//$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\treturn new EclipseFileObject(className, uri2, kind, this.charset);", "+\t\t\t} else {", "+\t\t\t\tString normalizedFileName = normalized(className);", "+\t\t\t\tint index = normalizedFileName.lastIndexOf('/');", "+\t\t\t\tif (index != -1) {", "+\t\t\t\t\tnormalizedFileName = normalizedFileName.substring(index + 1);", "+\t\t\t\t}", "+\t\t\t\tnormalizedFileName += kind.extension;", "+\t\t\t\tFile f = new File(System.getProperty(\"user.dir\"), normalizedFileName);//$NON-NLS-1$", "+\t\t\t\treturn new EclipseFileObject(className, f.toURI(), kind, this.charset);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7b7edd694158c2f6b3f25048dff8affd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "d5a32e245b27c645dcf70347396d7253765682d3", "commitAfterChange": "562bd70d52b78a80d9ea0f036f9a91cfb91468db", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+\tboolean wasInsideAssert = ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0);", "+\tFlowInfo conditionFlowInfo;", "-\t\t\tif ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {", "-\t\t\t\tthis.arguments[i].checkNPE(currentScope, flowContext, flowInfo);", "+\t\t\tExpression argument = this.arguments[i];", "+\t\t\tif ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {", "+\t\t\t\targument.checkNPE(currentScope, flowContext, flowInfo);", "-\t\t\tflowInfo = this.arguments[i].analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\t\t\tif (this.receiver.resolvedType != null ", "+\t\t\t\t\t&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert", "+\t\t\t\t\t&& argument.resolvedType != null", "+\t\t\t\t\t&& argument.resolvedType.id == TypeIds.T_boolean) {", "+\t\t\t\tConstant cst = argument.optimizedBooleanConstant();", "+\t\t\t\tboolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\t\t\t\tboolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+\t\t\t\tflowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;", "+\t\t\t\tconditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());", "+\t\t\t\tif (!wasInsideAssert) {", "+\t\t\t\t\tflowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;", "+\t\t\t\t}", "+\t\t\t\tUnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();", "+\t\t\t\tFlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();", "+\t\t\t\tif (isOptimizedTrueAssertion) {", "+\t\t\t\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "+\t\t\t\t}", "+\t\t\t\tif (!isOptimizedFalseAssertion) {", "+\t\t\t\t\t// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.", "+\t\t\t\t\t// if the code does reach ahead, it means the assert didn't cause an exit, and so", "+\t\t\t\t\t// the expression inside it shouldn't change the prior flowinfo", "+\t\t\t\t\t// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)", "+\t\t\t\t\t", "+\t\t\t\t\t// keep the merge from the initial code for the definite assignment", "+\t\t\t\t\t// analysis, tweak the null part to influence nulls downstream", "+\t\t\t\t\tflowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "+\t\t\t\t\t\taddInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tflowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\t\t\t}", "-\t\t\t\tflowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, false);", "+\t\t\t\tflowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, argument, flowInfo, false);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a57e8d3a4cd9f2776927fe53d8703215", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "c67ad5667d81e7ca8719e3b0faf6c7f2b84f03ce", "commitAfterChange": "55a2e1357c3327be6468ccea0fa1bd5884ed35ad", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "signatureAfterChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "diff": ["-\t    if (argumentType.isWildcard()) {", "-\t        WildcardBinding wildcard = (WildcardBinding) argumentType;", "-\t        switch (wildcard.boundKind) {", "-\t        \tcase Wildcard.SUPER :", "-//\t\t            if (boundCheck(substitution, wildcard.bound) != TypeConstants.OK) return TypeConstants.MISMATCH;", "-//\t\t            break;", "-\t\t            return boundCheck(substitution, wildcard.bound); // only check the lower bound", "+\t\tif (argumentType.isWildcard()) {", "+\t\t\tWildcardBinding wildcard = (WildcardBinding) argumentType;", "+\t\t\tswitch(wildcard.boundKind) {", "+\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\tReferenceBinding superclassBound = (ReferenceBinding)Scope.substitute(substitution, this.superclass());", "+\t\t\t\t\tTypeBinding wildcardBound = wildcard.bound;", "+\t\t\t\t\tboolean isArrayBound = wildcardBound.isArrayType();", "+\t\t\t\t\tif (!wildcardBound.isInterface()) {", "+\t\t\t\t\t\tif (isArrayBound) {", "+\t\t\t\t\t\t\tif (!wildcardBound.isCompatibleWith(superclassBound))", "+\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superclassBound.erasure());", "+\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\tif (!match.isIntersectingWith(superclassBound)) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tReferenceBinding[] superInterfaceBounds = Scope.substitute(substitution, this.superInterfaces());", "+\t\t\t\t\tint length = superInterfaceBounds.length;", "+\t\t\t\t\tboolean mustImplement = isArrayBound || ((ReferenceBinding)wildcardBound).isFinal();", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tTypeBinding superInterfaceBound = superInterfaceBounds[i];", "+\t\t\t\t\t\tif (isArrayBound) {", "+\t\t\t\t\t\t\tif (!wildcardBound.isCompatibleWith(superInterfaceBound))", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superInterfaceBound.erasure());", "+\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\tif (!match.isIntersectingWith(superInterfaceBound)) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (mustImplement) {", "+\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH; // cannot be extended further to satisfy missing bounds", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t\t", "+\t\t\t\tcase Wildcard.SUPER :", "+\t\t\t\t\treturn boundCheck(substitution, wildcard.bound);", "+\t\t\t\t\t", "-\t\t\t\t\tif (this == wildcard.typeVariable()) ", "-\t\t\t\t\t\treturn TypeConstants.OK;", "-\t\t\t\t\tbreak;\t        \t\t", "-\t        }", "-\t    }", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\treturn TypeConstants.OK;", "+\t\t}", "-\t\t\t}", "+\t\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e838f225bb26dc29420500195fe1b890", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "97881e1f65dad02c5fcba69e18ae3332573c3839", "commitAfterChange": "5ae43aadc33d93b5c6af6a0612729105eee79d4f", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options)", "signatureAfterChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options)", "diff": ["-\t\t// TODO (olivier) missing implementation", "-\t\tthrow new RuntimeException();", "+\t\tASTConverter converter = new ASTConverter(options, false, null);", "+\t\tconverter.compilationUnitSource = source;", "+\t\tconverter.scanner.setSource(source);", "+\t\t", "+\t\tAST ast = new AST();", "+\t\tast.setBindingResolver(new BindingResolver());", "+\t\tconverter.setAST(ast);", "+\t\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "+\t\tswitch(kind) {", "+\t\t\tcase K_STATEMENTS :", "+\t\t\t\tConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(source, offset, length, options);", "+\t\t\t\tif (constructorDeclaration != null) {", "+\t\t\t\t\tBlock block = ast.newBlock();", "+\t\t\t\t\tStatement[] statements = constructorDeclaration.statements;", "+\t\t\t\t\tif (statements != null) {", "+\t\t\t\t\t\tint statementsLength = statements.length;", "+\t\t\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "+\t\t\t\t\t\t\tblock.statements().add(converter.convert(statements[i]));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// TODO Root the block to a compilation unit", "+\t\t\t\t\t// record the problems, comments and line numbers", "+\t\t\t\t\treturn block;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase K_EXPRESSION :", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = codeSnippetParsingUtil.parseExpression(source, offset, length, options);", "+\t\t\t\tif (expression != null) {", "+\t\t\t\t\tExpression expression2 = converter.convert(expression);", "+\t\t\t\t\t// TODO Root the expression to a compilation unit", "+\t\t\t\t\t// record the problems, comments and line numbers", "+\t\t\t\t\treturn expression2;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase K_CLASS_BODY_DECLARATIONS :", "+\t\t\t\tfinal org.eclipse.jdt.internal.compiler.ast.ASTNode[] nodes = codeSnippetParsingUtil.parseClassBodyDeclarations(source, offset, length, options);", "+\t\t\t\tif (nodes != null) {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = converter.convert(nodes);", "+\t\t\t\t\t// TODO Root the expression to a compilation unit", "+\t\t\t\t\t// record the problems, comments and line numbers", "+\t\t\t\t\treturn typeDeclaration;", "+\t\t\t\t}", "+\t\t}", "+\t\tthrow new IllegalArgumentException();"]}], "num": 67432}