{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "11f166d73e49f79ced8baba7860c39c4", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17f79128c02144acd9f7a7de08889d66", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "9f63437bec67bc6f1450b706ffa6a59a67485b74", "commitAfterChange": "2b5868a69a1295fe1d99f9e80995ceed273132ed", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": " public static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "diff": ["-\t */", "-\tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite) {", "-\t\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;", "-\t\t", "-\t\tint length = argumentTypes.length;", "-", "-\t\t// iterate over arguments, and retrieve original argument types (before cast)", "-\t\tTypeBinding[] rawArgumentTypes = argumentTypes;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression argument = arguments[i];", "-\t\t\tif (argument instanceof CastExpression) {", "- \t\t\t\t// narrowing conversion on base type may change value, thus necessary", "-\t\t\t\tif ((argument.bits & UnnecessaryCast) == 0 && argument.resolvedType.isBaseType()) {", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}\t\t", "-\t\t\t\tTypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;", "-\t\t\t\tif (castedExpressionType == null) return; // cannot do better", "-\t\t\t\t// obvious identity cast", "-\t\t\t\tif (castedExpressionType == argumentTypes[i]) { ", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)argument);", "-\t\t\t\t} else if (castedExpressionType == TypeBinding.NULL){", "-\t\t\t\t\tcontinue; // tolerate null argument cast", "-\t\t\t\t} else if ((argument.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\tcontinue; // boxing has a side effect: (int) char   is not boxed as simple char", "-\t\t\t\t} else {", "-\t\t\t\t\tif (rawArgumentTypes == argumentTypes) {", "-\t\t\t\t\t\tSystem.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);", "-\t\t\t\t\t}", "-\t\t\t\t\t// retain original argument type", "-\t\t\t\t\trawArgumentTypes[i] = castedExpressionType; ", "-\t\t\t\t}", "-\t\t\t}\t\t\t\t", "-\t\t}", "-\t\t// perform alternate lookup with original types", "-\t\tif (rawArgumentTypes != argumentTypes) {", "-\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);", "-\t\t}", "-\t}", "+ */", "+public static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite) {", "+\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;", "+\tint length = argumentTypes.length;", "+", "+\t// iterate over arguments, and retrieve original argument types (before cast)", "+\tTypeBinding[] rawArgumentTypes = argumentTypes;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tExpression argument = arguments[i];", "+\t\tif (argument instanceof CastExpression) {", "+\t\t\t// narrowing conversion on base type may change value, thus necessary", "+\t\t\tif ((argument.bits & ASTNode.UnnecessaryCast) == 0 && argument.resolvedType.isBaseType()) {", "+\t\t\t\tcontinue;", "+\t\t\t}\t\t", "+\t\t\tTypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;", "+\t\t\tif (castedExpressionType == null) return; // cannot do better", "+\t\t\t// obvious identity cast", "+\t\t\tif (castedExpressionType == argumentTypes[i]) { ", "+\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)argument);", "+\t\t\t} else if (castedExpressionType == TypeBinding.NULL){", "+\t\t\t\tcontinue; // tolerate null argument cast", "+\t\t\t} else if ((argument.implicitConversion & TypeIds.BOXING) != 0) {", "+\t\t\t\tcontinue; // boxing has a side effect: (int) char   is not boxed as simple char", "+\t\t\t} else {", "+\t\t\t\tif (rawArgumentTypes == argumentTypes) {", "+\t\t\t\t\tSystem.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);", "+\t\t\t\t}", "+\t\t\t\t// retain original argument type", "+\t\t\t\trawArgumentTypes[i] = castedExpressionType; ", "+\t\t}\t\t\t\t", "+\t}", "+\t// perform alternate lookup with original types", "+\tif (rawArgumentTypes != argumentTypes) {", "+\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36f0861935dc6b2cc065bed1efec6e1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "653b549b2ec915800fe34bbb2ab9809b71ca66a5", "commitAfterChange": "2caa59d033a9b6c8ec71aab586472ad7fe749893", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "signatureAfterChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "diff": ["-\tif (arguments != null && methodBinding.parameterNonNullness != null) {", "-", "-\t\t// check if varargs need special treatment:", "+\tif (arguments != null) {", "+\t\tCompilerOptions compilerOptions = currentScope.compilerOptions();", "+\t\tboolean considerTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8", "+\t\t\t\t&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tboolean hasJDK15NullAnnotations = methodBinding.parameterNonNullness != null;", "-\t\tboolean passThrough = false;", "-\t\tif (methodBinding.isVarargs()) {", "-\t\t\tint varArgPos = numParamsToCheck-1;", "-\t\t\t// this if-block essentially copied from generateArguments(..):", "-\t\t\tif (numParamsToCheck == arguments.length) {", "-\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "-\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "-\t\t\t\tif (lastType == TypeBinding.NULL", "-\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "-\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "-\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\tif (considerTypeAnnotations || hasJDK15NullAnnotations) {", "+\t\t\t// check if varargs need special treatment:", "+\t\t\tboolean passThrough = false;", "+\t\t\tif (methodBinding.isVarargs()) {", "+\t\t\t\tint varArgPos = numParamsToCheck-1;", "+\t\t\t\t// this if-block essentially copied from generateArguments(..):", "+\t\t\t\tif (numParamsToCheck == arguments.length) {", "+\t\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "+\t\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "+\t\t\t\t\tif (lastType == TypeBinding.NULL", "+\t\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "+\t\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "+\t\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\t\t\t}", "+\t\t\t\tif (!passThrough)", "+\t\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-\t\t\tif (!passThrough)", "-\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-", "-\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "-\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\tif (considerTypeAnnotations) {", "+\t\t\tfor (int i=0; i<numParamsToCheck; i++) {", "-\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "-\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "-\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t// prefer check based on type annotations:", "+\t\t\t\tint severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType);", "+\t\t\t\tif (severity > 0) {", "+\t\t\t\t\t// immediate reporting:", "+\t\t\t\t\tcurrentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity==1, currentScope.environment());", "+\t\t\t\t\t// next check flow-based null status against null JDK15-style annotations:", "+\t\t\t\t} else if (hasJDK15NullAnnotations && methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "-\t\t}", "+\t\t} else if (hasJDK15NullAnnotations) {", "+\t\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "+\t\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tTypeBinding expectedType = methodBinding.parameters[i];", "+\t\t\t\t\tExpression argument = arguments[i];", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} "]}], "num": 27708}