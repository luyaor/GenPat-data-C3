{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0cec37ccae9ead1bfd9b5446ed7a17d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2319475039cafff3929820bd2625c9c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8a64589617f7b80b7f12bb3f773ab58c605663c7", "commitAfterChange": "6585c7471e2cc73387fb0d652a600f2678de9051", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc)", "signatureAfterChange": " \tprivate void printBlockComment(char[] s, boolean isJavadoc)", "diff": ["-\tpublic void printBlockComment(char[] s, int commentStart, boolean isJavadoc) {", "-\t\tString commentSource = new String(s);", "-\t\tStringTokenizer tokenizer = new StringTokenizer(commentSource, \"\\r\\n\");\t//$NON-NLS-1$", "-\t\tprintIndentationIfNecessary();", "-\t\tLocation location = null;", "-\t\tint lineCounter = 0;", "-\t\tint startSearchIndex = 0;", "+\tprivate void printBlockComment(char[] s, boolean isJavadoc) {", "-\t\twhile(tokenizer.hasMoreElements()) {", "-\t\t\tString lineContents = tokenizer.nextToken();", "-\t\t\tif (lineContents.length() != 0) {", "-\t\t\t\tprintIndentationIfNecessary();", "-\t\t\t\tif (lineCounter >= 1) {", "-\t\t\t\t\tbuffer.append(\" \");//$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\t// remove leading whitespaces", "-\t\t\t\tint lineStartPosition = currentTokenStartPosition + commentSource.indexOf(lineContents, startSearchIndex);", "-\t\t\t\tthis.scanner.resetTo(lineStartPosition, this.scannerEndPosition - 1);", "-\t\t\t\tString reduceLine = null;", "-\t\t\t\ttry {", "-\t\t\t\t\t// TODO need investigation in term of edits", "-\t\t\t\t\tif (this.scanner.getNextToken() == ITerminalSymbols.TokenNameWHITESPACE) {", "-\t\t\t\t\t\tint begin = this.scanner.getCurrentTokenEndPosition() + 1 - lineStartPosition;", "-\t\t\t\t\t\tif (begin < lineContents.length()) {", "-\t\t\t\t\t\t\treduceLine = lineContents.substring(begin);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\treduceLine = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treduceLine = lineContents;", "+\t\tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "+\t\tint currentCharacter;", "+\t\tboolean isNewLine = false;", "+\t\tint start = currentTokenStartPosition;", "+\t\tint nextCharacterStart = currentTokenStartPosition;", "+\t\tprintIndentationIfNecessary();", "+\t\tint previousStart = currentTokenStartPosition;", "+", "+\t\twhile (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "+\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+", "+\t\t\tswitch(currentCharacter) {", "+\t\t\t\tcase '\\r' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tif (this.scanner.getNextChar('\\n')) {", "+\t\t\t\t\t\tcurrentCharacter = '\\n';", "+\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "-\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t// should not happen", "-\t\t\t\t}", "-\t\t\t\tfinal int reduceLineLength = reduceLine.length();", "-\t\t\t\t// add position mapping", "-\t\t\t\tint start = commentSource.indexOf(reduceLine, startSearchIndex);", "-\t\t\t\tif (this.positionsToMap != null) {", "-\t\t\t\t\tmapPositions(start + commentStart, this.buffer.length(), reduceLineLength);", "-\t\t\t\t}", "-\t\t\t\tstartSearchIndex = start + reduceLineLength + 1;", "-\t\t\t\tbuffer.append(reduceLine);", "-\t\t\t\tcolumn += reduceLineLength;", "-\t\t\t\tlocation = new Location(this, 0);", "-\t\t\t\tbuffer.append(this.lineSeparator);", "-\t\t\t\tthis.line++;", "-\t\t\t\tlineCounter++;", "-\t\t\t\tcolumn = 1;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase '\\n' :", "+\t\t\t\t\tstart = previousStart;", "+\t\t\t\t\tisNewLine = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (isNewLine) {", "+\t\t\t\t\t\tif (Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\twhile(currentCharacter != -1 && currentCharacter != '\\r' && currentCharacter != '\\n' && Character.isWhitespace((char) currentCharacter)) {", "+\t\t\t\t\t\t\t\tpreviousStart = nextCharacterStart;", "+\t\t\t\t\t\t\t\tcurrentCharacter = this.scanner.getNextChar();", "+\t\t\t\t\t\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.column = 1;", "+\t\t\t\t\t\tthis.line++;", "+", "+\t\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\t\tbuffer.append(this.lineSeparator);", "+\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\t\tbuffer.append(this.fillingSpace);", "+\t\t\t\t", "+\t\t\t\t\t\taddReplaceEdit(start, previousStart - 1, String.valueOf(buffer)); //$NON-NLS-1$", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.column += (nextCharacterStart - previousStart);", "+\t\t\t\t\t}", "+\t\t\t\t\tisNewLine = false;", "-\t\t}", "-\t\tif (location != null) {", "-\t\t\tresetAt(location);", "+\t\t\tpreviousStart = nextCharacterStart;", "+\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);", "-\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc03587a7ca732ddf047f6e426efd5ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "605463bb98397b59c78b7fc56ee33e7e22fd8367", "commitAfterChange": "7428bd3b18a16b1860e6a1a28fbc6cd63967fdc6", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 54, "signatureBeforeChange": " \t \tprivate void printLineComment()", "signatureAfterChange": " \t \tprivate void printLineComment()", "diff": ["-\t\tint currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\tint currentTokenEndPosition = this.scanner.getCurrentTokenEndPosition() + 1;", "-\t\tif (CharOperation.indexOf(Scanner.TAG_PREFIX, this.scanner.source, true, currentTokenStartPosition, currentTokenEndPosition) != -1) {", "-\t\t\tthis.nlsTagCounter = 0;", "-\t\t}", "-\t\tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "-\t\tint currentCharacter;", "-\t\tint start = currentTokenStartPosition;", "-\t\tint nextCharacterStart = currentTokenStartPosition;", "-\t\t", "-\t\tif (this.indentationLevel != 0) {", "-\t\t\tif (!this.formatter.preferences.never_indent_line_comments_on_first_column", "-\t\t\t\t\t|| !isOnFirstColumn(start)) {", "-\t\t\t\tprintIndentationIfNecessary();", "-\t\t\t}", "-\t\t}", "-\t\tif (this.pendingSpace) {", "-\t\t\tthis.addInsertEdit(currentTokenStartPosition, \" \"); //$NON-NLS-1$", "-\t\t}", "-\t\tthis.needSpace = false;", "-\t\tthis.pendingSpace = false;", "-\t\tint previousStart = currentTokenStartPosition;", "+    \tint currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();", "+    \tint currentTokenEndPosition = this.scanner.getCurrentTokenEndPosition() + 1;", "+    \tboolean isNlsTag = false;", "+    \tif (CharOperation.indexOf(Scanner.TAG_PREFIX, this.scanner.source, true, currentTokenStartPosition, currentTokenEndPosition) != -1) {", "+    \t\tthis.nlsTagCounter = 0;", "+    \t\tisNlsTag = true;", "+    \t}", "+    \tthis.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);", "+    \tint currentCharacter;", "+    \tint start = currentTokenStartPosition;", "+    \tint nextCharacterStart = currentTokenStartPosition;", "+    \t", "+    \tif (this.indentationLevel != 0) {", "+    \t\tif (!this.formatter.preferences.never_indent_line_comments_on_first_column", "+    \t\t\t\t|| !isOnFirstColumn(start)) {", "+    \t\t\tprintIndentationIfNecessary();", "+    \t\t}", "+    \t}", "+    \tif (this.pendingSpace) {", "+    \t\tthis.addInsertEdit(currentTokenStartPosition, \" \"); //$NON-NLS-1$", "+    \t}", "+    \tthis.needSpace = false;", "+    \tthis.pendingSpace = false;", "+    \tint previousStart = currentTokenStartPosition;", "-\t\tloop: while (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "-\t\t\tnextCharacterStart = this.scanner.currentPosition;", "+\t\tif (!isNlsTag && includesLineComments()) {", "+\t\t\tprintLineComment(currentTokenStartPosition, currentTokenEndPosition);", "+\t\t} else {", "+\t\t\t// do nothing!?", "+\t    \tloop: while (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {", "+\t    \t\tnextCharacterStart = this.scanner.currentPosition;", "+\t    ", "+\t    \t\tswitch(currentCharacter) {", "+\t    \t\t\tcase '\\r' :", "+\t    \t\t\t\tstart = previousStart;", "+\t    \t\t\t\tbreak loop;", "+\t    \t\t\tcase '\\n' :", "+\t    \t\t\t\tstart = previousStart;", "+\t    \t\t\t\tbreak loop;", "+\t    \t\t}", "+\t    \t\tpreviousStart = nextCharacterStart;", "+\t    \t}", "+\t    \tif (start != currentTokenStartPosition) {", "+\t    \t\t// this means that the line comment doesn't end the file", "+\t    \t\taddReplaceEdit(start, currentTokenEndPosition - 1, lineSeparator);", "+\t    \t\tthis.line++; ", "+\t    \t\tthis.column = 1;", "+\t    \t\tthis.lastNumberOfNewLines = 1;", "+\t    \t}", "+\t\t}", "+    \tthis.needSpace = false;", "+    \tthis.pendingSpace = false;", "+    \t// realign to the proper value", "+    \tif (this.currentAlignment != null) {", "+    \t\tif (this.memberAlignment != null) {", "+    \t\t\t// select the last alignment", "+    \t\t\tif (this.currentAlignment.location.inputOffset > this.memberAlignment.location.inputOffset) {", "+    \t\t\t\tif (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "+    \t\t\t\t\tthis.currentAlignment.performFragmentEffect();", "+    \t\t\t\t}", "+    \t\t\t} else {", "+    \t\t\t\tthis.indentationLevel = Math.max(this.indentationLevel, this.memberAlignment.breakIndentationLevel);", "+    \t\t\t}", "+    \t\t} else if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "+    \t\t\tthis.currentAlignment.performFragmentEffect();", "+    \t\t}", "+    \t}", "+    \tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);", "+    }", "-\t\t\tswitch(currentCharacter) {", "-\t\t\t\tcase '\\r' :", "-\t\t\t\t\tstart = previousStart;", "-\t\t\t\t\tbreak loop;", "-\t\t\t\tcase '\\n' :", "-\t\t\t\t\tstart = previousStart;", "-\t\t\t\t\tbreak loop;", "-\t\t\t}", "-\t\t\tpreviousStart = nextCharacterStart;", "-\t\t}", "-\t\tif (start != currentTokenStartPosition) {", "-\t\t\t// this means that the line comment doesn't end the file", "-\t\t\taddReplaceEdit(start, currentTokenEndPosition - 1, lineSeparator);", "-\t\t\tthis.line++; ", "-\t\t\tthis.column = 1;", "-\t\t\tthis.lastNumberOfNewLines = 1;", "-\t\t}", "-\t\tthis.needSpace = false;", "-\t\tthis.pendingSpace = false;", "-\t\t// realign to the proper value", "-\t\tif (this.currentAlignment != null) {", "-\t\t\tif (this.memberAlignment != null) {", "-\t\t\t\t// select the last alignment", "-\t\t\t\tif (this.currentAlignment.location.inputOffset > this.memberAlignment.location.inputOffset) {", "-\t\t\t\t\tif (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "-\t\t\t\t\t\tthis.currentAlignment.performFragmentEffect();", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.indentationLevel = Math.max(this.indentationLevel, this.memberAlignment.breakIndentationLevel);", "-\t\t\t} else if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {", "-\t\t\t\tthis.currentAlignment.performFragmentEffect();", "-\t\tthis.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);"]}], "num": 59775}