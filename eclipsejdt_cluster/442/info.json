{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "44368796cd1ca8e46c067fb8f6533a35", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3bbcfa33fb1c9244afc500e43e4336e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java", "commitBeforeChange": "8ad7ea4a3e807d9d57eeeda9a3a7bd6598dfbdb1", "commitAfterChange": "b7a41e13e2a80300225883c3cc5ff3990406ce0a", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void initializeBounds(Scope scope, ParameterizedTypeBinding capturedParameterizedType)", "signatureAfterChange": " \tpublic void initializeBounds(Scope scope, ParameterizedTypeBinding capturedParameterizedType)", "diff": ["+\t\tif (wildcardVariable == null) {", "+\t\t\t// error resilience when capturing Zork<?>", "+\t\t\t// no substitution for wildcard bound (only formal bounds from type variables are to be substituted: 104082)", "+\t\t\tTypeBinding originalWildcardBound = wildcard.bound;\t\t\t", "+\t\t\tswitch (wildcard.boundKind) {", "+\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\t// still need to capture bound supertype as well so as not to expose wildcards to the outside (111208)", "+\t\t\t\t\tTypeBinding capturedWildcardBound = originalWildcardBound.capture(scope, this.position);", "+\t\t\t\t\tif (originalWildcardBound.isInterface()) {", "+\t\t\t\t\t\tthis.superclass = scope.getJavaLangObject();", "+\t\t\t\t\t\tthis.superInterfaces = new ReferenceBinding[] { (ReferenceBinding) capturedWildcardBound };", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// the wildcard bound should be a subtype of variable superclass", "+\t\t\t\t\t\t// it may occur that the bound is less specific, then consider glb (202404)", "+\t\t\t\t\t\tif (capturedWildcardBound.isArrayType() || capturedWildcardBound == this) {", "+\t\t\t\t\t\t\tthis.superclass = scope.getJavaLangObject();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.superclass = (ReferenceBinding) capturedWildcardBound;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.firstBound =  capturedWildcardBound;", "+\t\t\t\t\tif ((capturedWildcardBound.tagBits & TagBits.HasTypeVariable) == 0)", "+\t\t\t\t\t\tthis.tagBits &= ~TagBits.HasTypeVariable;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.UNBOUND :", "+\t\t\t\t\tthis.superclass = scope.getJavaLangObject();", "+\t\t\t\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "+\t\t\t\t\tthis.tagBits &= ~TagBits.HasTypeVariable;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.SUPER :", "+\t\t\t\t\tthis.superclass = scope.getJavaLangObject();", "+\t\t\t\t\tthis.superInterfaces = Binding.NO_SUPERINTERFACES;", "+\t\t\t\t\tthis.lowerBound = wildcard.bound;", "+\t\t\t\t\tif ((originalWildcardBound.tagBits & TagBits.HasTypeVariable) == 0)", "+\t\t\t\t\t\tthis.tagBits &= ~TagBits.HasTypeVariable;\t\t\t\t\t", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "-\t\t\t\tif (wildcard.bound.isInterface()) {", "+\t\t\t\tif (originalWildcardBound.isInterface()) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da8ee83b8c86f543a17e3c7459372964", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java", "commitBeforeChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "commitAfterChange": "c01ae722f1b8e267f566f56a56228af04d49effb", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public Object getConstant() throws JavaModelException", "signatureAfterChange": " public Object getConstant() throws JavaModelException", "diff": ["+\tif (this.constant != null) {", "+\t\treturn this.constant;", "+\t}", "-\treturn info.initializationSource;", "+\tif (info.initializationSource == null) {", "+\t\treturn null;", "+\t}", "+\t\t\t", "+\tString constantSource = new String(info.initializationSource);", "+\tString signature = info.getTypeSignature();", "+\tif (signature.equals(Signature.SIG_INT)) {", "+\t\tthis.constant = new Integer(constantSource);", "+\t} else if (signature.equals(Signature.SIG_SHORT)) {", "+\t\tthis.constant = new Short(constantSource);", "+\t} else if (signature.equals(Signature.SIG_BYTE)) {", "+\t\tthis.constant = new Byte(constantSource);", "+\t} else if (signature.equals(Signature.SIG_BOOLEAN)) {", "+\t\tthis.constant = new Boolean(constantSource);", "+\t} else if (signature.equals(Signature.SIG_CHAR)) {", "+\t\tthis.constant = new Character(constantSource.charAt(0));", "+\t} else if (signature.equals(Signature.SIG_DOUBLE)) {", "+\t\tthis.constant = new Double(constantSource);", "+\t} else if (signature.equals(Signature.SIG_FLOAT)) {", "+\t\tthis.constant = new Float(constantSource);", "+\t} else if (signature.equals(Signature.SIG_LONG)) { ", "+\t\tthis.constant = new Long(constantSource);", "+\t} else if (signature.equals(\"QString;\")) {//$NON-NLS-1$", "+\t\tthis.constant = constantSource;", "+\t}", "+\treturn this.constant;"]}], "num": 442}