{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "712b3732e3a718626cd57c1f3c80f639", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90c32cae9542fc417fdd00891970dd1a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\tTypeBinding testType = expression.resolveType(upperScope);", "-\t\t\tif (testType == null)", "+\t\t\tTypeBinding expressionType = expression.resolveType(upperScope);", "+\t\t\tif (expressionType == null)", "-\t\t\texpression.computeConversion(upperScope, testType, testType);", "-\t\t\tif (!(expression.isConstantValueOfTypeAssignableToType(testType, IntBinding))) {", "-\t\t\t\tif (!testType.isCompatibleWith(IntBinding)) {", "-\t\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, testType);", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "+\t\t\texpression.computeConversion(upperScope, expressionType, expressionType);", "+\t\t\tcheckType: {", "+\t\t\t\tif (expressionType.isBaseType()) {", "+\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionType, IntBinding))", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t\tif (expressionType.isCompatibleWith(IntBinding))", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t} else if (expressionType.isEnum())", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, expressionType);", "+\t\t\t\t// TODO (philippe) could keep analyzing switch statements in case of error", "+\t\t\t\treturn;", "-\t\t\t\tint[] casesValues = new int[length];", "+\t\t\t\tthis.constants = new int[length];", "-\t\t\t\t\tif ((constant = statement.resolveCase(scope, testType, this)) != null) {", "+\t\t\t\t\tif ((constant = statement.resolveCase(scope, expressionType, this)) != Constant.NotAConstant) {", "+\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\tif (constant != NotAConstant) {", "-\t\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "-\t\t\t\t\t\t\t\tif (casesValues[j] == key) {", "-\t\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "-\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "+\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "+\t\t\t\t\t\t\tif (this.constants[j] == key) {", "+\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "+\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tboolean found = false;", "+\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "+\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "+\t\t\t\t\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "-\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tboolean found = false;", "-\t\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "-\t\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "-\t\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tcasesValues[counter++] = key;", "+\t\t\t\t\t\tthis.constants[counter++] = key;", "+\t\t\t\tif (length != counter) { // resize constants array", "+\t\t\t\t\tSystem.arraycopy(this.constants, 0, this.constants = new int[counter], 0, counter);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e371e3336e34878d079ab2b949b21bb8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9fff7ba189be037b4cf4f61956b7e287259b8f6d", "commitAfterChange": "8f52c3e814b7d9e86327e186704f1c7e2be78c75", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\tTypeBinding testType = expression.resolveType(upperScope);", "-\t\tif (testType == null)", "-\t\t\treturn;", "-\t\texpression.implicitWidening(testType, testType);", "-\t\tif (!(expression.isConstantValueOfTypeAssignableToType(testType, IntBinding))) {", "-\t\t\tif (!testType.isCompatibleWith(IntBinding)) {", "-\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, testType);", "+\t    try {", "+\t\t\tTypeBinding testType = expression.resolveType(upperScope);", "+\t\t\tif (testType == null)", "+\t\t\texpression.implicitWidening(testType, testType);", "+\t\t\tif (!(expression.isConstantValueOfTypeAssignableToType(testType, IntBinding))) {", "+\t\t\t\tif (!testType.isCompatibleWith(IntBinding)) {", "+\t\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, testType);", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "-\t\t}", "-\t\tif (statements != null) {", "-\t\t\tscope = explicitDeclarations == 0 ? upperScope : new BlockScope(upperScope);", "-\t\t\tint length;", "-\t\t\t// collection of cases is too big but we will only iterate until caseCount", "-\t\t\tcases = new CaseStatement[length = statements.length];", "-\t\t\tint[] casesValues = new int[length];", "-\t\t\tCaseStatement[] duplicateCaseStatements = null;", "-\t\t\tint duplicateCaseStatementsCounter = 0;", "-\t\t\tint counter = 0;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tConstant constant;", "-\t\t\t\tfinal Statement statement = statements[i];", "-\t\t\t\tif ((constant = statement.resolveCase(scope, testType, this)) != null) {", "-\t\t\t\t\t//----check for duplicate case statement------------", "-\t\t\t\t\tif (constant != NotAConstant) {", "-\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "-\t\t\t\t\t\t\tif (casesValues[j] == key) {", "-\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "-\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "-\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tboolean found = false;", "-\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "-\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "-\t\t\t\t\t\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (!found) {", "+\t\t\tif (statements != null) {", "+\t\t\t\tscope = explicitDeclarations == 0 ? upperScope : new BlockScope(upperScope);", "+\t\t\t\tint length;", "+\t\t\t\t// collection of cases is too big but we will only iterate until caseCount", "+\t\t\t\tcases = new CaseStatement[length = statements.length];", "+\t\t\t\tint[] casesValues = new int[length];", "+\t\t\t\tCaseStatement[] duplicateCaseStatements = null;", "+\t\t\t\tint duplicateCaseStatementsCounter = 0;", "+\t\t\t\tint counter = 0;", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tConstant constant;", "+\t\t\t\t\tfinal Statement statement = statements[i];", "+\t\t\t\t\tif ((constant = statement.resolveCase(scope, testType, this)) != null) {", "+\t\t\t\t\t\t//----check for duplicate case statement------------", "+\t\t\t\t\t\tif (constant != NotAConstant) {", "+\t\t\t\t\t\t\tint key = constant.intValue();", "+\t\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "+\t\t\t\t\t\t\t\tif (casesValues[j] == key) {", "+\t\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "+\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "+\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "+\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tboolean found = false;", "+\t\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "+\t\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "+\t\t\t\t\t\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tif (!found) {", "+\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "+\t\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcasesValues[counter++] = key;", "-\t\t\t\t\t\tcasesValues[counter++] = key;", "+\t\t\t} else {", "+\t\t\t\tif ((this.bits & UndocumentedEmptyBlockMASK) != 0) {", "+\t\t\t\t\tupperScope.problemReporter().undocumentedEmptyBlock(this.blockStart, this.sourceEnd);", "+\t\t\t\t}", "-\t\t} else {", "-\t\t\tif ((this.bits & UndocumentedEmptyBlockMASK) != 0) {", "-\t\t\t\tupperScope.problemReporter().undocumentedEmptyBlock(this.blockStart, this.sourceEnd);", "-\t\t\t}", "-\t\t}", "+\t    } finally {", "+\t        if (this.scope != null) this.scope.switchCase = null; // no longer inside switch case block", "+\t    }"]}], "num": 9397}