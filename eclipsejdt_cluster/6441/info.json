{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3372092d0e7bfac41c4c92c624c5cdd7", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "604f657b33d5102effcfa6d5e90752b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java", "commitBeforeChange": "c2d93f84777a172153dcbac16d43bc3ee8d7d762", "commitAfterChange": "e1d010570c5db8a931b881b6acf90e4de06ed138", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprotected void addReconcileDelta(IWorkingCopy workingCopy, IJavaElementDelta delta)", "signatureAfterChange": " \tprotected void addReconcileDelta(IWorkingCopy workingCopy, IJavaElementDelta delta)", "diff": ["-\t\t// TODO: (jerome) should merge deltas if previous reconcile delta was already registered for this working copy", "-\t\tJavaModelManager.getJavaModelManager().reconcileDeltas.put(workingCopy, delta);", "+\t\tHashMap reconcileDeltas = JavaModelManager.getJavaModelManager().reconcileDeltas;", "+\t\tJavaElementDelta previousDelta = (JavaElementDelta)reconcileDeltas.get(workingCopy);", "+\t\tif (previousDelta != null) {", "+\t\t\tIJavaElementDelta[] children = delta.getAffectedChildren();", "+\t\t\tfor (int i = 0, length = children.length; i < length; i++) {", "+\t\t\t\tJavaElementDelta child = (JavaElementDelta)children[i];", "+\t\t\t\tpreviousDelta.insertDeltaTree(child.getElement(), child);", "+\t\t\t}", "+\t\t} else {", "+\t\t\treconcileDeltas.put(workingCopy, delta);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f6d86c15d6c924470736ff5f2a0683e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJarFileToIndex.java", "commitBeforeChange": "2d03a3a42577e7f87a7097ee67df247c7332b65d", "commitAfterChange": "f865f170bb115429495719dbfc2d017403d7b163", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-\t\t\t\tfinal HashSet indexedFileNames = new HashSet(100);", "-\t\t\t\tint resultLength = results == null ? 0 : results.length;", "-\t\t\t\tif (resultLength != 0) {", "+\t\t\t\tint max = results == null ? 0 : results.length;", "+\t\t\t\tif (max != 0) {", "-\t\t\t\t\t * one entry is missing then we ", "+\t\t\t\t\t * one entry is missing then we recreate the index", "-\t\t\t\t\tfor (int i = 0; i < resultLength; i++)", "-\t\t\t\t\t\tindexedFileNames.add(results[i].getPath());", "-\t\t\t\t\tboolean needToReindex = false;", "+\t\t\t\t\tString EXISTS = \"OK\"; //$NON-NLS-1$", "+\t\t\t\t\tString DELETED = \"DELETED\"; //$NON-NLS-1$", "+\t\t\t\t\tSimpleLookupTable indexedFileNames = new SimpleLookupTable(max == 0 ? 33 : max + 11);", "+\t\t\t\t\tfor (int i = 0; i < max; i++)", "+\t\t\t\t\t\tindexedFileNames.put(results[i].getPath(), DELETED);", "-\t\t\t\t\t\t\tif (!indexedFileNames.remove(entryDocument.getName())) {", "-\t\t\t\t\t\t\t\tneedToReindex = true;", "+\t\t\t\t\t\t\tindexedFileNames.put(entryDocument.getName(), EXISTS);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tboolean needToReindex = indexedFileNames.elementSize != max; // a new file was added", "+\t\t\t\t\tif (!needToReindex) {", "+\t\t\t\t\t\tObject[] valueTable = indexedFileNames.valueTable;", "+\t\t\t\t\t\tfor (int i = 0, l = valueTable.length; i < l; i++) {", "+\t\t\t\t\t\t\tif (valueTable[i] == DELETED) {", "+\t\t\t\t\t\t\t\tneedToReindex = true; // a file was deleted so re-index", "-\t\t\t\t\t}", "-\t\t\t\t\tif (!needToReindex && indexedFileNames.size() == 0) {", "-\t\t\t\t\t\tif (JobManager.VERBOSE)", "-\t\t\t\t\t\t\tJobManager.verbose(\"-> no indexing required (index is consistent with library) for \" //$NON-NLS-1$", "-\t\t\t\t\t\t\t+ zip.getName() + \" (\" //$NON-NLS-1$", "-\t\t\t\t\t\t\t+ (System.currentTimeMillis() - initialTime) + \"ms)\"); //$NON-NLS-1$", "-\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\tif (!needToReindex) {", "+\t\t\t\t\t\t\tif (JobManager.VERBOSE)", "+\t\t\t\t\t\t\t\tJobManager.verbose(\"-> no indexing required (index is consistent with library) for \" //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t+ zip.getName() + \" (\" //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t+ (System.currentTimeMillis() - initialTime) + \"ms)\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}"]}], "num": 6441}