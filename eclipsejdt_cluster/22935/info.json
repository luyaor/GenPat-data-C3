{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "05e01c97ec1cc4ba0b8461408ad2d530", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04012057cc3c55907ff6285f1baf291d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "8e2ef31cf8fd6f75aa20407e8ef5b91a95949af6", "commitAfterChange": "7b76bd109981132b10232dab12b61206fb5d8435", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tprivate synchronized List<ICompilationUnit> calculateHiddenTypes(IFile parentFile, Set<IFile> newlyGeneratedFiles, \t\t\tCompilationUnitHelper cuHelper)", "signatureAfterChange": " \t\tprivate synchronized void computeObsoleteReconcileTypes( \t\t\t\tIFile parentFile, Set<IFile> newlyGeneratedFiles,  \t\t\t\tCompilationUnitHelper cuh, \t\t\t\tList<ICompilationUnit> toSetBlank, List<ICompilationUnit> toDiscard)", "diff": ["-\t */", "-\tprivate synchronized List<ICompilationUnit> calculateHiddenTypes(IFile parentFile, Set<IFile> newlyGeneratedFiles,", "-\t\t\tCompilationUnitHelper cuHelper)", "-\t{", "-\t\tIPackageFragmentRoot root = _generatedPackageFragmentRoot.get().root;", "-\t\tList<ICompilationUnit> toSetBlank = new ArrayList<ICompilationUnit>();", "-", "-\t\t// Hide types that were generated during build and thus exist on disk.", "-\t\t// Only hide them if they have no other parents.", "-\t\tSet<IFile> generatedFromBuild = _parentToGenFiles.getValues(parentFile);", "-\t\tfor (IFile generatedFile : generatedFromBuild) {", "-\t\t\t// spare types generated in the last round", "-\t\t\tif (!newlyGeneratedFiles.contains(generatedFile)) {", "-\t\t\t\tSet<IFile> parentsOfGeneratedFile = _parentToGenFiles.getKeys(generatedFile);", "-\t\t\t\tif (parentsOfGeneratedFile.size() == 1 && parentsOfGeneratedFile.contains(parentFile)) {", "-\t\t\t\t\tICompilationUnit workingCopy = _workingCopies.get(generatedFile);", "-\t\t\t\t\tif (null != workingCopy) {", "-\t\t\t\t\t\t// move existing WC from _workingCopies to _hidden", "-\t\t\t\t\t\t_workingCopies.remove(generatedFile);", "-\t\t\t\t\t\tboolean removed = _parentToGenWorkingCopies.remove(parentFile, workingCopy);", "-\t\t\t\t\t\tassert removed : \"Working copy found in list but not in dependency map: \" + workingCopy.getElementName(); //$NON-NLS-1$", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace( ", "-\t\t\t\t\t\t\t\t\"creating blank working copy to hide type: \" + generatedFile); //$NON-NLS-1$", "-\t\t\t\t\t\tString typeName = getTypeNameForDerivedFile(generatedFile);", "-\t\t\t\t\t\tworkingCopy = cuHelper.createWorkingCopy(typeName, root);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace(", "-\t\t\t\t\t\t\t\"adding working copy to hidden types list: \" + generatedFile); //$NON-NLS-1$", "-\t\t\t\t\tassert workingCopy.isWorkingCopy() : ", "-\t\t\t\t\t\t\"Attempted to add a non-working copy to hidden types list\"; //$NON-NLS-1$", "-\t\t\t\t\t_hiddenBuiltTypes.put(generatedFile, workingCopy);", "-", "-\t\t\t\t\tICompilationUnit wc = workingCopy;", "-\t\t\t\t\ttoSetBlank.add(wc);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassert checkIntegrity();", "-\t\treturn toSetBlank;", "-\t}", "+\t\t */", "+\t\tprivate synchronized void computeObsoleteReconcileTypes(", "+\t\t\t\tIFile parentFile, Set<IFile> newlyGeneratedFiles, ", "+\t\t\t\tCompilationUnitHelper cuh,", "+\t\t\t\tList<ICompilationUnit> toSetBlank, List<ICompilationUnit> toDiscard) ", "+\t\t{", "+\t\t\t// Get types previously but no longer generated during reconcile", "+\t\t\tSet<IFile> obsoleteFiles = _reconcileDeps.getValues(parentFile);", "+\t\t\tMap<IFile, ICompilationUnit> typesToDiscard = new HashMap<IFile, ICompilationUnit>();", "+\t\t\tobsoleteFiles.removeAll(newlyGeneratedFiles);", "+\t\t\tfor (IFile obsoleteFile : obsoleteFiles) {", "+\t\t\t\t_reconcileDeps.remove(parentFile, obsoleteFile);", "+\t\t\t\tif (_reconcileDeps.getKeys(obsoleteFile).isEmpty()) {", "+\t\t\t\t\tICompilationUnit wc = _reconcileGenTypes.remove(obsoleteFile);", "+\t\t\t\t\tassert wc != null : ", "+\t\t\t\t\t\t\"Value in reconcile deps missing from reconcile type list: \" + obsoleteFile; //$NON-NLS-1$", "+\t\t\t\t\ttypesToDiscard.put(obsoleteFile, wc);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tSet<IFile> builtChildren = _buildDeps.getValues(parentFile);", "+\t\t\tbuiltChildren.removeAll(newlyGeneratedFiles);", "+\t\t\tfor (IFile builtChild : builtChildren) {", "+\t\t\t\t_reconcileNonDeps.put(parentFile, builtChild);", "+\t\t\t\t// If it's on typesToDiscard there are no other reconcile-time parents.", "+\t\t\t\t// If there are no other parents that are not masked by a nonDep entry...", "+\t\t\t\tboolean foundOtherParent = false;", "+\t\t\t\tSet<IFile> parents = _buildDeps.getKeys(builtChild);", "+\t\t\t\tparents.remove(parentFile);", "+\t\t\t\tfor (IFile otherParent : parents) {", "+\t\t\t\t\tif (!_reconcileNonDeps.containsKeyValuePair(otherParent, builtChild)) {", "+\t\t\t\t\t\tfoundOtherParent = true;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (!foundOtherParent) {", "+\t\t\t\t\tICompilationUnit wc = typesToDiscard.remove(builtChild);", "+\t\t\t\t\tif (wc == null) {", "+\t\t\t\t\t\tIPackageFragmentRoot root = _generatedPackageFragmentRoot.get().root;", "+\t\t\t\t\t\tString typeName = getTypeNameForDerivedFile(builtChild);", "+\t\t\t\t\t\twc = cuh.getWorkingCopy(typeName, root);", "+\t\t\t\t\t}", "+\t\t\t\t\t_hiddenBuiltTypes.put(builtChild, wc);", "+\t\t\t\t\ttoSetBlank.add(wc);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t", "+\t\t\t// discard any working copies that we're not setting blank", "+\t\t\ttoDiscard.addAll(typesToDiscard.values());", "+\t\t\t", "+\t\t\tassert checkIntegrity();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c96d8d457d9a2a57ee276c60857b8b1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "6b22001068ed91ead38729b06cb63f4a79acaa87", "commitAfterChange": "09b2a60a289857be8b68f0bdade8ca62b9081359", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tprivate boolean checkTypeArgument(Scanner scanner, CheckState state) throws InvalidInputException", "signatureAfterChange": " \tprivate boolean checkTypeArgument(Scanner scanner) throws InvalidInputException", "diff": ["-\tprivate boolean checkTypeArgument(Scanner scanner, CheckState state) throws InvalidInputException {", "-\t\tboolean expectingIdentifier = true;", "-\t\t", "+\tprivate boolean checkTypeArgument(Scanner scanner) throws InvalidInputException {", "+\t\tint depth = 1;", "+\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\tcase TerminalTokens.TokenNameDOT :", "-\t\t\t\t\tif (expectingIdentifier)", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\texpectingIdentifier = true;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (!expectingIdentifier)", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\texpectingIdentifier = false;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase TerminalTokens.TokenNameCOMMA :", "-\t\t\t\t\tif (expectingIdentifier)", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\texpectingIdentifier = true;", "-\t\t\t\t\tbreak;", "-\t\t\t\t\tint oldDepth = state.depth;", "-\t\t\t\t\tstate.depth++;", "-\t\t\t\t\tif(checkTypeArgument(scanner, state)) {", "-\t\t\t\t\t\tif(state.depth < oldDepth) {", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "+\t\t\t\t\tdepth++;", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "-\t\t\t\t\tstate.depth--;", "-\t\t\t\t\treturn state.depth >= 0;", "-\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT :", "-\t\t\t\t\tstate.depth-=2;", "-\t\t\t\t\treturn state.depth >= 0;", "-\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT :", "-\t\t\t\t\tstate.depth-=3;", "-\t\t\t\t\treturn state.depth >= 0;", "-\t\t\t\tcase TerminalTokens.TokenNameQUESTION :\t", "-\t\t\t\t\ttoken = scanner.getNextToken();", "-\t\t\t\t\tif(token != TerminalTokens.TokenNameextends &&", "-\t\t\t\t\t\t\ttoken != TerminalTokens.TokenNamesuper) {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\ttoken = scanner.getNextToken();", "-\t\t\t\t\tif(token != TerminalTokens.TokenNameIdentifier)", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t", "-\t\t\t\t\texpectingIdentifier = false;", "+\t\t\t\t\tdepth--;", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "-\t\t\t\tdefault:", "-\t\t\t\t\treturn false;", "+\t\t\t\tcase TerminalTokens.TokenNameRIGHT_SHIFT :", "+\t\t\t\t\tdepth-=2;", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameUNSIGNED_RIGHT_SHIFT :", "+\t\t\t\t\tdepth-=3;", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameextends :", "+\t\t\t\tcase TerminalTokens.TokenNamesuper :", "+\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "+\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase TerminalTokens.TokenNameCOMMA :", "+\t\t\t\t\tif(depth == 1) {", "+\t\t\t\t\t\tint length = buffer.length();", "+\t\t\t\t\t\tchar[] typeRef = new char[length];", "+\t\t\t\t\t\tbuffer.getChars(0, length, typeRef, 0);", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tSignature.createTypeSignature(typeRef, true);", "+\t\t\t\t\t\t\tbuffer = new StringBuffer();", "+\t\t\t\t\t\t} catch(IllegalArgumentException e) {", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault :", "+\t\t\t\t\tbuffer.append(scanner.getCurrentTokenSource());", "+\t\t\t\t\tbreak;", "+\t\t\t\t", "-\t\t} while (token != TerminalTokens.TokenNameEOF);", "+\t\t\tif(depth < 0) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t} while (depth != 0 && token != TerminalTokens.TokenNameEOF);", "+\t\t", "+\t\tif(depth == 0) {", "+\t\t\tint length = buffer.length() - 1;", "+\t\t\tchar[] typeRef = new char[length];", "+\t\t\tbuffer.getChars(0, length, typeRef, 0);", "+\t\t\ttry {", "+\t\t\t\tSignature.createTypeSignature(typeRef, true);", "+\t\t\t\treturn true;", "+\t\t\t} catch(IllegalArgumentException e) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}"]}], "num": 22935}