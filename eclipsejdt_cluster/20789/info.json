{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9d5a5d4cf42b5736d30171bf895ee9b9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "160f6a37168a4454839135168279f0a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "03e37ed5506ed50fa30b9f5aa42ff423995a94bd", "commitAfterChange": "4111f058addae7e2d753cc95bd7546b1f787e4c8", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 37, "signatureBeforeChange": " public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "signatureAfterChange": " public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "diff": ["-\treturn toCharArray(methodSignature, methodName, parameterNames, fullyQualifyTypeNames, includeReturnType, false, false);", "-}", "+\tint firstParen = CharOperation.indexOf(C_PARAM_START, methodSignature);", "+\tif (firstParen == -1) {", "+\t}", "+\t", "+\tStringBuffer buffer = new StringBuffer(methodSignature.length + 10);", "+\t", "+\t// return type", "+\tif (includeReturnType) {", "+\t\tchar[] rts = getReturnType(methodSignature);", "+\t\tappendTypeSignature(rts, 0 , fullyQualifyTypeNames, buffer);", "+\t\tbuffer.append(' ');", "+\t}", "+\t", "+\t// selector", "+\tif (methodName != null) {", "+\t\tbuffer.append(methodName);", "+\t}", "+\t", "+\t// parameters", "+\tbuffer.append('(');", "+\tchar[][] pts = getParameterTypes(methodSignature);", "+\tfor (int i = 0; i < pts.length; i++) {", "+\t\tappendTypeSignature(pts[i], 0 , fullyQualifyTypeNames, buffer);", "+\t\tif (parameterNames != null) {", "+\t\t\tbuffer.append(' ');", "+\t\t\tbuffer.append(parameterNames[i]);", "+\t\t}", "+\t\tif (i != pts.length - 1) {", "+\t\t\tbuffer.append(',');", "+\t\t\tbuffer.append(' ');", "+\t\t}", "+\t}", "+\tbuffer.append(')');", "+\tchar[] result = new char[buffer.length()];", "+\tbuffer.getChars(0, buffer.length(), result, 0);", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "316970d7caa95ec4184408f572e6b5ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": " \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess expression)", "signatureAfterChange": "  \tpublic EnumDeclaration convert(org.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDeclaration)", "diff": ["-\t}", "-\tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess expression) {", "-\t\tTypeLiteral typeLiteral = this.ast.newTypeLiteral();", "-\t\tif (this.resolveBindings) {", "-\t\t\tthis.recordNodes(typeLiteral, expression);", "-\t\t}", "-\t\ttypeLiteral.setSourceRange(expression.sourceStart, expression.sourceEnd - expression.sourceStart + 1);", "-\t\ttypeLiteral.setType(convertType(expression.type));", "-\t\treturn typeLiteral;", "-\t}", "+", "+\tpublic EnumDeclaration convert(org.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDeclaration) {", "+\t\tcheckCanceled();", "+\t\tEnumDeclaration enumDeclaration2 = this.ast.newEnumDeclaration();", "+\t\tint modifiers = enumDeclaration.modifiers;", "+\t\tmodifiers &= ~IConstants.AccInterface; // remove AccInterface flags", "+\t\tmodifiers &= CompilerModifiers.AccJustFlag;", "+\t\tif (modifiers != 0) {", "+\t\t\tsetModifiers(enumDeclaration2, enumDeclaration);", "+\t\t}", "+\t\tSimpleName typeName = this.ast.newSimpleName(new String(enumDeclaration.name));", "+\t\ttypeName.setSourceRange(enumDeclaration.sourceStart, enumDeclaration.sourceEnd - enumDeclaration.sourceStart + 1);", "+\t\tenumDeclaration2.setName(typeName);", "+\t\tenumDeclaration2.setSourceRange(enumDeclaration.declarationSourceStart, enumDeclaration.bodyEnd - enumDeclaration.declarationSourceStart + 1);", "+\t\t", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference[] superInterfaces = enumDeclaration.superInterfaces;", "+\t\tif (superInterfaces != null) {", "+\t\t\tfor (int index = 0, length = superInterfaces.length; index < length; index++) {", "+\t\t\t\tenumDeclaration2.superInterfaceTypes().add(convertType(superInterfaces[index]));", "+\t\t\t}\t\t\t\t\t", "+\t\t}", "+\t\tbuildBodyDeclarations(enumDeclaration, enumDeclaration2);", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(enumDeclaration2, enumDeclaration);", "+\t\t\trecordNodes(typeName, enumDeclaration);", "+\t\t\tenumDeclaration2.resolveBinding();", "+\t\t}", "+\t\treturn enumDeclaration2;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46a6a807d7345f461132bd2958692ada", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "66f0e8b8112bb13bbbf568db765302c9834a0001", "commitAfterChange": "8173bc34d19a76799af83a37be998ec65b3a1874", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["+\t\tboolean isFirstAttribute = true;", "+\t\t\tisFirstAttribute = false;", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute);", "+\t\t\t} else {", "+\t\t\t\tdumpTab(tabNumberForLineAttribute, buffer);", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t}", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\t} else {", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t\tdumpTab(tabNumberForLocalVariableAttribute, buffer);", "+\t\t\t}", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\t} else {", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t\tdumpTab(tabNumberForLocalVariableAttribute, buffer);", "+\t\t\t}", "-\t\t\t\t\tdisassemble((StackMapTableAttribute) attribute, buffer, lineSeparator, tabNumber + 1, mode);", "+\t\t\t\t\tIStackMapTableAttribute stackMapTableAttribute = (IStackMapTableAttribute) attribute;", "+\t\t\t\t\tif (!isFirstAttribute) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tisFirstAttribute = false;", "+\t\t\t\t\t\tdumpTab(tabNumber + 1, buffer);", "+\t\t\t\t\t}", "+\t\t\t\t\tint numberOfEntries = stackMapTableAttribute.getNumberOfEntries();", "+\t\t\t\t\tbuffer.append(Messages.bind(Messages.disassembler_stackmaptableattributeheader, Integer.toString(numberOfEntries)));", "+\t\t\t\t\tif (numberOfEntries != 0) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 3);", "+\t\t\t\t\t\tfinal IStackMapFrame[] stackMapFrames = stackMapTableAttribute.getStackMapFrame();", "+\t\t\t\t\t\tfor (int j = 0; j < numberOfEntries; j++) {", "+\t\t\t\t\t\t\tdisassemble(stackMapFrames[j], buffer, lineSeparator, tabNumber + 2, mode);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\tdisassemble(attribute, buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t\tif (!isFirstAttribute) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tisFirstAttribute = false;", "+\t\t\t\t\t\tdumpTab(tabNumber + 1, buffer);", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(Messages.bind(Messages.disassembler_genericattributeheader,", "+\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\tnew String(attribute.getAttributeName()),", "+\t\t\t\t\t\t\tLong.toString(attribute.getAttributeLength())", "+\t\t\t\t\t\t}));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b47b735f25348f7dd7600652e2e8101", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "2a762b85f858691a63d4547af177cc649d7b1329", "commitAfterChange": "7675c409a4b3b1e15b1cc476a0a66b988b5fb4a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tIClasspathEntry[] originalClasspath = classpath;\r", "+\tArrayList resolvedEntries = new ArrayList();\r", "-\t\t// use resolved variable\r", "-\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_VARIABLE){\r", "-\t\t\tif (classpath == originalClasspath) System.arraycopy(originalClasspath, 0, classpath = new IClasspathEntry[length], 0, length);\r", "-\t\t\tclasspath[i] = JavaCore.getResolvedClasspathEntry(classpath[i]);\r", "-\t\t}\r", "-\t\tif (classpath[i] != null){\r", "-\t\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "-\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "-\t\t\tif (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\tIClasspathEntry rawEntry = classpath[i];\r", "+\t\tswitch(rawEntry.getEntryKind()){\r", "+\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_VARIABLE :\r", "+\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);\r", "+\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\tcase IClasspathEntry.CPE_CONTAINER :\r", "+\t\t\t\tIClasspathEntry[] containerEntries = javaProject.getResolvedClasspathContainer(rawEntry.getPath());\r", "+\t\t\t\tif (containerEntries != null){\r", "+\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){\r", "+\t\t\t\t\t\t resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);\r", "+\t\t\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_SOURCE :\r", "+\t\t\t\thasSource = true;\r", "+\t\t\tdefault :\r", "+\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\tresolvedEntries.add(rawEntry);\r", "+\t\t\t\tbreak;\r", "+\t\r", "+\tlength = resolvedEntries.size();\r", "+\tclasspath = new IClasspathEntry[length];\r", "+\tresolvedEntries.toArray(classpath);\r"]}], "num": 20789}