{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b78b763f9fd6276df10f62630c4f2aff", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "32c4de98f9d78474f1beebb77539726b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java", "commitBeforeChange": "d5bb78582d4992003bc3f1aa67226d9e44bea956", "commitAfterChange": "08113b25540cfe36a65c669bfa7d7d71cc964096", "methodNumberBeforeChange": 323, "methodNumberAfterChange": 323, "signatureBeforeChange": " \tpublic void test0676() throws JavaModelException", "signatureAfterChange": " \tpublic void test0676() throws JavaModelException", "diff": ["-\t\tICompilationUnit workingCopy = null;", "-\t\ttry {", "-\t\t\tString contents =", "-\t\t\t\t\"package p;\\n\" +", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tB foo() {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\";", "-\t\t\tworkingCopy = getWorkingCopy(\"/Converter/src/p/X.java\", true/*resolve*/);", "-\t\t\tworkingCopy.getBuffer().setContents(contents);", "-\t\t\tASTNode node = runConversion(AST.JLS3, workingCopy, true, true, true);", "-\t\t\tassertEquals(\"Not a compilation unit\", ASTNode.COMPILATION_UNIT, node.getNodeType());", "-\t\t\tCompilationUnit unit = (CompilationUnit) node;", "-\t\t\tassertTrue(\"no binding recovery\", unit.getAST().hasBindingsRecovery());", "-\t\t\tassertTrue(\"no statement recovery\", unit.getAST().hasStatementsRecovery());", "-\t\t\tassertTrue(\"no binding resolution\", unit.getAST().hasResolvedBindings());", "-\t\t\tString expectedError = \"B cannot be resolved to a type\";", "-\t\t\tassertProblemsSize(unit, 1, expectedError);", "-\t\t\tassertTrue(\"No binding recovery\", unit.getAST().hasBindingsRecovery());", "-\t\t\tnode = getASTNode(unit, 0, 0);", "-\t\t\tassertEquals(\"Not a method declaration\", ASTNode.METHOD_DECLARATION, node.getNodeType());", "-\t\t\tMethodDeclaration methodDeclaration = (MethodDeclaration) node;", "-\t\t\tType type = methodDeclaration.getReturnType2();", "-\t\t\tassertNotNull(\"No type\", type);", "-\t\t\tITypeBinding typeBinding = type.resolveBinding();", "-\t\t\tassertNotNull(\"No type binding\", typeBinding);", "-\t\t\tassertTrue(\"Not a recovered binding\", typeBinding.isRecovered());", "-\t\t\tIJavaElement javaElement = typeBinding.getJavaElement();", "-\t\t\tassertNotNull(\"No java element\", javaElement);", "-\t\t\tassertTrue(\"Javalement exists\", !javaElement.exists());", "-\t\t\tIPackageBinding packageBinding = typeBinding.getPackage();", "-\t\t\tassertNotNull(\"No package\", packageBinding);", "-\t\t\tassertEquals(\"Not the package p\", \"p\", packageBinding.getName());", "-\t\t\tITypeBinding arrayBinding = typeBinding.createArrayType(2);", "-\t\t\tassertNotNull(\"No array binding\", arrayBinding);", "-\t\t\tassertEquals(\"Wrong dimensions\", 2, arrayBinding.getDimensions());", "-\t\t\tITypeBinding elementType = arrayBinding.getElementType();", "-\t\t\tassertNotNull(\"No element type\", elementType);", "-\t\t\tassertNotNull(\"No key\", typeBinding.getKey());", "-\t\t\tassertTrue(\"Not equals\", elementType.isEqualTo(typeBinding));", "-\t\t\t", "-\t\t\tnode = getASTNode(unit, 0);", "-\t\t\tassertEquals(\"Not a type declaration\", ASTNode.TYPE_DECLARATION, node.getNodeType());", "-\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;", "-\t\t\tITypeBinding typeBinding2 = typeDeclaration.resolveBinding();", "-\t\t\tITypeBinding javaLangObject = typeBinding2.getSuperclass();", "-\t\t\tassertEquals(\"Not java.lang.Object\", \"java.lang.Object\", javaLangObject.getQualifiedName());", "-\t\t\tassertTrue(\"Not isCastCompatible\", typeBinding.isCastCompatible(javaLangObject));", "-\t\t\tassertTrue(\"Not isCastCompatible\", typeBinding.isCastCompatible(elementType));", "+\t\tICompilationUnit sourceUnit = getCompilationUnit(\"Converter\" , \"src\", \"test0676\", \"X.java\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$", "+\t\tASTNode node = runConversion(AST.JLS3, sourceUnit, true, true, true);", "+\t\tassertEquals(\"Not a compilation unit\", ASTNode.COMPILATION_UNIT, node.getNodeType());", "+\t\tCompilationUnit unit = (CompilationUnit) node;", "+\t\tassertTrue(\"no binding recovery\", unit.getAST().hasBindingsRecovery());", "+\t\tassertTrue(\"no statement recovery\", unit.getAST().hasStatementsRecovery());", "+\t\tassertTrue(\"no binding resolution\", unit.getAST().hasResolvedBindings());", "+\t\tString expectedError = \"B cannot be resolved to a type\";", "+\t\tassertProblemsSize(unit, 1, expectedError);", "+\t\tassertTrue(\"No binding recovery\", unit.getAST().hasBindingsRecovery());", "+\t\tnode = getASTNode(unit, 0, 0);", "+\t\tassertEquals(\"Not a method declaration\", ASTNode.METHOD_DECLARATION, node.getNodeType());", "+\t\tMethodDeclaration methodDeclaration = (MethodDeclaration) node;", "+\t\tType type = methodDeclaration.getReturnType2();", "+\t\tassertNotNull(\"No type\", type);", "+\t\tITypeBinding typeBinding = type.resolveBinding();", "+\t\tassertNotNull(\"No type binding\", typeBinding);", "+\t\tassertTrue(\"Not a recovered binding\", typeBinding.isRecovered());", "+\t\tIJavaElement javaElement = typeBinding.getJavaElement();", "+\t\tassertNotNull(\"No java element\", javaElement);", "+\t\tassertTrue(\"Java element exists\", !javaElement.exists());", "+\t\tIPackageBinding packageBinding = typeBinding.getPackage();", "+\t\tassertNotNull(\"No package\", packageBinding);", "+\t\tassertNotNull(\"No java element for package\", packageBinding.getJavaElement());", "+\t\tassertEquals(\"Not the package test0676\", \"test0676\", packageBinding.getName());", "+\t\tITypeBinding arrayBinding = typeBinding.createArrayType(2);", "+\t\tassertNotNull(\"No array binding\", arrayBinding);", "+\t\tassertEquals(\"Wrong dimensions\", 2, arrayBinding.getDimensions());", "+\t\tITypeBinding elementType = arrayBinding.getElementType();", "+\t\tassertNotNull(\"No element type\", elementType);", "+\t\tassertNotNull(\"No key\", typeBinding.getKey());", "+\t\tassertTrue(\"Not equals\", elementType.isEqualTo(typeBinding));", "+\t\t", "+\t\tnode = getASTNode(unit, 0);", "+\t\tassertEquals(\"Not a type declaration\", ASTNode.TYPE_DECLARATION, node.getNodeType());", "+\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;", "+\t\tITypeBinding typeBinding2 = typeDeclaration.resolveBinding();", "+\t\tITypeBinding javaLangObject = typeBinding2.getSuperclass();", "+\t\tassertEquals(\"Not java.lang.Object\", \"java.lang.Object\", javaLangObject.getQualifiedName());", "+\t\tassertTrue(\"Not isCastCompatible\", typeBinding.isCastCompatible(javaLangObject));", "+\t\tassertTrue(\"Not isCastCompatible\", typeBinding.isCastCompatible(elementType));", "-\t\t\tassertTrue(\"Not isSubTypeCompatible\", typeBinding.isSubTypeCompatible(javaLangObject));", "-\t\t\tassertTrue(\"Not isSubTypeCompatible\", typeBinding.isSubTypeCompatible(elementType));", "+\t\tassertTrue(\"Not isSubTypeCompatible\", typeBinding.isSubTypeCompatible(javaLangObject));", "+\t\tassertTrue(\"Not isSubTypeCompatible\", typeBinding.isSubTypeCompatible(elementType));", "-\t\t\tassertTrue(\"Not isAssignmentCompatible\", typeBinding.isAssignmentCompatible(javaLangObject));", "-\t\t\tassertTrue(\"Not isAssignmentCompatible\", typeBinding.isAssignmentCompatible(elementType));", "-\t\t} finally {", "-\t\t\tif (workingCopy != null)", "-\t\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t}", "+\t\tassertTrue(\"Not isAssignmentCompatible\", typeBinding.isAssignmentCompatible(javaLangObject));", "+\t\tassertTrue(\"Not isAssignmentCompatible\", typeBinding.isAssignmentCompatible(elementType));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39afbcd105f8bdb8cbbf0abf95132a65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java", "commitBeforeChange": "f09e5b387a9b27a1161db6587b5598aa2acd37a0", "commitAfterChange": "11f5a7cc7c9c65b20b52b279ac1ac913311b9b45", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public void testWarningAssert()", "signatureAfterChange": " public void testWarningTokens()", "diff": ["-public void testWarningAssert() {", "+public void testWarningTokens() {", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedConstructor));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.OverridingDeprecatedMethod));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedType));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedMethod));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedField));", "+\tassertEquals(\"wrong token\", \"boxing\", CorrectionEngine.getWarningToken(IProblem.BoxingConversion));", "+\tassertEquals(\"wrong token\", \"boxing\", CorrectionEngine.getWarningToken(IProblem.UnboxingConversion));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.FieldMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.MethodMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.TypeMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"finally\", CorrectionEngine.getWarningToken(IProblem.FinallyMustCompleteNormally));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.FieldHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.FieldHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.LocalVariableHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.LocalVariableHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.ArgumentHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.ArgumentHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.MaskedCatch));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.TypeParameterHidingType));", "+\tassertEquals(\"wrong token\", \"nls\", CorrectionEngine.getWarningToken(IProblem.NonExternalizedStringLiteral));", "+\tassertEquals(\"wrong token\", \"incomplete-switch\", CorrectionEngine.getWarningToken(IProblem.MissingEnumConstantCase));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedImport));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.LocalVariableIsNeverUsed));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.ArgumentIsNeverUsed));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateConstructor));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateMethod));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateField));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateType));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedMethodDeclaredThrownException));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedConstructorDeclaredThrownException));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticMethod));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticField));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticType));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.NonStaticAccessToStaticMethod));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.NonStaticAccessToStaticField));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateFieldReadAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateFieldWriteAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateMethodAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateConstructorAccess));", "+\tassertEquals(\"wrong token\", \"unqualified-field-access\", CorrectionEngine.getWarningToken(IProblem.UnqualifiedFieldAccess));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawConstructorInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawMethodInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeTypeConversion));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawFieldAssignment));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeGenericCast));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeReturnTypeOverride));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawGenericMethodInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawGenericConstructorInvocation));", "+\tassertEquals(\"wrong token\", \"serial\", CorrectionEngine.getWarningToken(IProblem.MissingSerialVersion));"]}], "num": 45279}