{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8d9503d28f38b48a1934485314a26e33", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0866d3ebba625cd4dfd04f1667ed8976", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java", "commitBeforeChange": "bb7b9521196186c5be108c1f350a453c12233137", "commitAfterChange": "871cac4ba4cecfc6322ce0af5777177652a514a9", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \t@Override \tpublic boolean visit(SwitchStatement node)", "signatureAfterChange": "  \t@Override \tpublic boolean visit(SwitchStatement node)", "diff": ["+\t\tList<Statement> statements = node.statements();", "-\t\t\tint openBraceIndex = this.tm.firstIndexIn(node, TokenNameLBRACE);", "-\t\t\tthis.tm.get(openBraceIndex + 1).indent();", "-\t\t\tint closeBraceIndex = this.tm.lastIndexIn(node, TokenNameRBRACE);", "-\t\t\tthis.tm.get(closeBraceIndex).unindent();", "+\t\t\tint nonBreakStatementEnd = -1;", "+\t\t\tfor (Statement statement : statements) {", "+\t\t\t\tif (statement instanceof SwitchCase) {", "+\t\t\t\t\tif (nonBreakStatementEnd >= 0) {", "+\t\t\t\t\t\t// indent only comments between previous and current statement", "+\t\t\t\t\t\tthis.tm.get(nonBreakStatementEnd + 1).indent();", "+\t\t\t\t\t\tthis.tm.firstTokenIn(statement, -1).unindent();", "+\t\t\t\t\t}", "+\t\t\t\t} else if (!(statement instanceof BreakStatement || statement instanceof Block)) {", "+\t\t\t\t\tindent(statement);", "+\t\t\t\t}", "+\t\t\t\tnonBreakStatementEnd = (statement instanceof BreakStatement || statement instanceof ReturnStatement)", "+\t\t\t\t\t\t? -1 : this.tm.lastIndexIn(statement, -1);", "+\t\t\t}", "+\t\t\tif (nonBreakStatementEnd >= 0) {", "+\t\t\t\t// indent comments between last statement and closing brace ", "+\t\t\t\tthis.tm.get(nonBreakStatementEnd + 1).indent();", "+\t\t\t\tthis.tm.lastTokenIn(node, TokenNameRBRACE).unindent();", "+\t\t\t}", "+\t\t}", "+\t\tif (this.options.indent_breaks_compare_to_cases) {", "+\t\t\tfor (Statement statement : statements) {", "+\t\t\t\tif (statement instanceof BreakStatement)", "+\t\t\t\t\tindent(statement);", "+\t\t\t}", "-\t\tboolean isBreakStatement = false;", "-\t\tList<Statement> statements = node.statements();", "-\t\t\tif (isBreakStatement) // actually, was break statement", "-\t\t\t\tthis.tm.firstTokenIn(statement, -1).indent();", "-\t\t\tisBreakStatement = statement instanceof BreakStatement;", "-\t\t\tif (this.options.indent_switchstatements_compare_to_cases", "-\t\t\t\t\t&& (isBreakStatement || statement instanceof SwitchCase || statement instanceof Block)) {", "-\t\t\t\tunindent(statement);", "-\t\t\t}", "-\t\t\tif (isBreakStatement) {", "-\t\t\t\tif (this.options.indent_breaks_compare_to_cases)", "-\t\t\t\t\tindent(statement);", "-\t\t\t\tthis.tm.firstTokenAfter(statement, -1).unindent();", "-\t\t\t}", "-\t\tif (isBreakStatement) // actually, was break statement", "-\t\t\tthis.tm.lastTokenIn(node, -1).indent();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "096ba91f599a5cb5905c7dfb44ee9a1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, Scope scope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope)", "diff": ["-\tpublic boolean isCompatibleWith(TypeBinding left, Scope scope) {", "-\t\tif (this.binding != null && this.binding.isValidBinding() // binding indicates if full resolution has already happened", "-\t\t\t\t&& this.resolvedType != null && this.resolvedType.isValidBinding()) {", "-\t\t\treturn this.resolvedType.isCompatibleWith(left, scope);", "-\t\t}", "+\tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope) {", "+\t\tReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "+\t\tif (copy != null)", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "+\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tfinal MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\tboolean isCompatible;", "-\t\tsetExpectedType(left);", "-\t\t\tthis.binding = null;", "-\t\t\tthis.trialResolution = true;", "-\t\t\tthis.binding = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(left) : null;", "-\t\t\tif (this.binding == null) {", "-\t\t\t\tresolveType(this.enclosingScope);", "-\t\t\t\tregisterResult(left, this.binding);", "+\t\t\tcopy = copy();", "+\t\t\tif (copy == null) { // should never happen even for code assist.", "+\t\t\t\treturn false;", "+\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\tcopy.setExpectedType(targetType);", "+\t\t\tcopy.resolveType(this.enclosingScope);", "+\t\t\tregisterCopy(targetType, copy);", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "-\t\t\tisCompatible = this.binding != null && this.binding.isValidBinding();", "-\t\t\tthis.binding = null;", "-\t\t\tsetExpectedType(null);", "-\t\t\tthis.trialResolution = false;", "-\t\treturn isCompatible;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bbdc44851b594296a2afce9a4bd8b2b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "eedafe9176d5ca60193623550822839844fd4aae", "commitAfterChange": "16a0328cb89c7e4d508e8edfc85e1af4879c13c7", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic void computePackageFragmentRoots( \t\tIClasspathEntry resolvedEntry, \t\tObjectVector accumulatedRoots,  \t\tHashSet rootIDs,  \t\tboolean insideOriginalProject, \t\tboolean checkExistency, \t\tboolean retrieveExportedRoots) throws JavaModelException", "signatureAfterChange": " \tpublic void computePackageFragmentRoots( \t\tIClasspathEntry resolvedEntry, \t\tObjectVector accumulatedRoots,  \t\tHashSet rootIDs,  \t\tIClasspathEntry referringEntry, \t\tboolean checkExistency, \t\tboolean retrieveExportedRoots, \t\tMap rootToResolvedEntries) throws JavaModelException", "diff": ["-\t\tboolean insideOriginalProject,", "+\t\tIClasspathEntry referringEntry,", "-\t\tboolean retrieveExportedRoots) throws JavaModelException {", "+\t\tboolean retrieveExportedRoots,", "+\t\tMap rootToResolvedEntries) throws JavaModelException {", "+\t\tIPackageFragmentRoot root = null;", "-\t\t\t\t\t\t\taccumulatedRoots.add(", "-\t\t\t\t\t\t\t\tgetPackageFragmentRoot((IResource)target));", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "+\t\t\t\t\t\t\troot = getPackageFragmentRoot((IResource)target);", "-\t\t\t\t\t\tIPackageFragmentRoot root = getFolderPackageFragmentRoot(entryPath);", "-\t\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\troot = getFolderPackageFragmentRoot(entryPath);", "-\t\t\t\tif (!insideOriginalProject && !resolvedEntry.isExported()) return;", "+\t\t\t\tif (referringEntry != null  && !resolvedEntry.isExported()) return;", "-\t\t\t\t\t\tIResource resource = (IResource) target;", "-\t\t\t\t\t\tIPackageFragmentRoot root = getPackageFragmentRoot(resource);", "-\t\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\troot = getPackageFragmentRoot((IResource) target);", "-\t\t\t\t\t\t\taccumulatedRoots.add(", "-\t\t\t\t\t\t\t\tnew JarPackageFragmentRoot(entryPath, this));", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "+\t\t\t\t\t\t\troot = new JarPackageFragmentRoot(entryPath, this);", "-\t\t\t\t\tIPackageFragmentRoot root = getPackageFragmentRoot(entryPath);", "-\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t}", "+\t\t\t\t\troot = getPackageFragmentRoot(entryPath);", "-\t\t\t\tif (!insideOriginalProject && !resolvedEntry.isExported()) return;", "+\t\t\t\tif (referringEntry != null && !resolvedEntry.isExported()) return;", "-\t\t\t\t\t\t\tfalse, ", "+\t\t\t\t\t\t\trootToResolvedEntries == null ? resolvedEntry : ((ClasspathEntry)resolvedEntry).combineWith(referringEntry), // only combine if need to build the reverse map ", "-\t\t\t\t\t\t\tretrieveExportedRoots);", "+\t\t\t\t\t\t\tretrieveExportedRoots,", "+\t\t\t\t\t\t\trootToResolvedEntries);", "+\t\t}", "+\t\tif (root != null) {", "+\t\t\taccumulatedRoots.add(root);", "+\t\t\trootIDs.add(rootID);", "+\t\t\tif (rootToResolvedEntries != null) rootToResolvedEntries.put(root, ((ClasspathEntry)resolvedEntry).combineWith(referringEntry));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "683947e3048a6a1388c3a7e4fa718ece", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java", "commitBeforeChange": "4c2a905aadc81c8c888c5fc5a111e98f871b85f1", "commitAfterChange": "2837bd360df1c376bc39df62191694b92b14b919", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate boolean checkAnnotations()", "signatureAfterChange": " \tprivate boolean checkNegative2()", "diff": ["-\tprivate boolean checkAnnotations() {", "+\t */", "+\tprivate boolean checkNegative2() {", "+\t\tList<? extends Element> enclosedElements = _elementN2.getEnclosedElements();", "+\t\tfor (Element element : enclosedElements) {", "+\t\t\tString name = element.getSimpleName().toString();", "+\t\t\tif (\"m1\".equals(name)) {", "+\t\t\t\tAnnotationMirror am2 = findAnnotation(element, \"Anno2\");", "+\t\t\t\tif (_reportFailingCases && null == am2) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno2 on method Negative2.m1\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m2\".equals(name)) {", "+\t\t\t\tAnnotationMirror am1 = findAnnotation(element, \"Anno1\");", "+\t\t\t\tif (_reportFailingCases && null == am1) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno1 on method Negative2.m2\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tAnnotationMirror am3 = findAnnotation(element, \"FakeAnno3\");", "+\t\t\t\tif (_reportFailingCases && null == am3) {", "+\t\t\t\t\treportError(\"Couldn't find annotation FakeAnno3 on method Negative2.m2\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m3\".equals(name)) {", "+\t\t\t\tAnnotationMirror am2 = findAnnotation(element, \"Anno2\");", "+\t\t\t\tif (_reportFailingCases && null == am2) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno2 on method Negative2.m3\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tAnnotationMirror am3 = findAnnotation(element, \"FakeAnno3\");", "+\t\t\t\tif (_reportFailingCases && null == am3) {", "+\t\t\t\t\treportError(\"Couldn't find annotation FakeAnno3 on method Negative2.m3\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m4\".equals(name)) {", "+\t\t\t\tAnnotationMirror am4 = findAnnotation(element, \"Anno4\");", "+\t\t\t\tif (_reportFailingCases && null == am4) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno4 on method Negative2.m4\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tMap<? extends ExecutableElement, ? extends AnnotationValue> values = am4.getElementValues();", "+\t\t\t\tfor (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : values.entrySet()) {", "+\t\t\t\t\tif (\"value\".equals(entry.getKey().getSimpleName().toString())) {", "+\t\t\t\t\t\tString value = entry.getValue().getValue().toString();", "+\t\t\t\t\t\tif (!\"123\".equals(value) && !\"<error>\".equals(value)) {", "+\t\t\t\t\t\t\treportError(\"Unexpected value for Anno4 on Negative1.s1: \" + value);", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn true;", "+\t}"]}], "num": 35821}