{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1c694030b8426496ddc7ca83e72f7550", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bec096efcc6d198f80e2939e6b24a3a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "8c93d4e99b8a943865cb7391e781eba5bb83dfc9", "commitAfterChange": "bd0edd7688142c1743cb6b10766dfc576040f113", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo)", "diff": ["-public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo) {", "+public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo) {", "+\t// fieldResetInfo: in this info we collect all information required for UnconditionalFlowInfo.resetNullInfoForFields:", "+\t// - which fields should never reset their null status? (constants and @NonNull)", "+\t// - for other fields: to what status should it be reset at each MessageSend? (unknown or pot.null)", "+\tboolean isConstant = this.binding.isFinal() && this.binding.isStatic();", "+\tboolean includeFieldsInNullAnalysis = initializationScope.compilerOptions().includeFieldsInNullAnalysis;", "-\t\tif (this.binding.isFinal() && this.binding.isStatic()) {", "+\t\tif (isConstant && includeFieldsInNullAnalysis) {", "-//\t\t\tthis.binding.setNullStatusForStaticFinalField(nullStatus);", "+\t}", "+\tif (isConstant && includeFieldsInNullAnalysis) {", "+\t\t// never reset null status for constants", "+\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "+\t}", "+\tlong tagBits = this.binding.tagBits;", "+\tif ((tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\tif (this.initialization != null) {", "+\t\t\tint nullStatus = this.initialization.nullStatus(flowInfo);", "+\t\t\t// check against annotation @NonNull:", "+\t\t\tif (nullStatus != FlowInfo.NON_NULL) {", "+\t\t\t\tchar[][] annotationName = initializationScope.environment().getNonNullAnnotationName();", "+\t\t\t\tinitializationScope.problemReporter().nullityMismatch(this.initialization, this.binding.type, nullStatus, annotationName);", "+\t\t\t}", "+\t\t}", "+\t\t// record nonnull for use by methods:", "+\t\tdeclaringClassFlowInfo.markAsDefinitelyNonNull(this.binding);", "+", "+\t\t// tell resetNullInfoForFields not to update this field's status", "+\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "+\t} else if ((tagBits & TagBits.AnnotationNullable) != 0) {", "+\t\t// record pot.null for use by methods:", "+\t\tdeclaringClassFlowInfo.resetNullInfo(this.binding);", "+\t\tdeclaringClassFlowInfo.markPotentiallyNullBit(this.binding);", "+", "+\t\t// tell resetNullInfoForFields to reset this field to pot.null:", "+\t\t// (note that this info is ineffective if the field is also constant)", "+\t\tfieldResetInfo.resetNullInfo(this.binding);", "+\t\tfieldResetInfo.markPotentiallyNullBit(this.binding);", "+\t} else if (!isConstant && includeFieldsInNullAnalysis) {", "+\t\t// tell resetNullInfoForFields to reset this field to def.unknown:", "+\t\tfieldResetInfo.markAsDefinitelyUnknown(this.binding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcaf0dcef3daf004547bcbc22285f7c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "874e2c41609c64af417834df9af2e898d8dcf37a", "commitAfterChange": "4977ef90a9cbab898d33f6e3ba736939d7ac7a85", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo) {", "-\t// fieldResetInfo: in this info we collect all information required for UnconditionalFlowInfo.resetNullInfoForFields:", "-\t// - which fields should never reset their null status? (constants and @NonNull)", "-\t// - for other fields: to what status should it be reset at each MessageSend? (unknown or pot.null)", "+public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\tboolean isConstant = this.binding.isFinal() && this.binding.isStatic();", "-\tboolean includeFieldsInNullAnalysis = initializationScope.compilerOptions().includeFieldsInNullAnalysis;", "-\t\tif (isConstant && includeFieldsInNullAnalysis) {", "+\t\tif (this.binding.isFinal() && this.binding.isStatic()) {", "+//\t\t\tthis.binding.setNullStatusForStaticFinalField(nullStatus);", "-\t}", "-\tif (isConstant && includeFieldsInNullAnalysis) {", "-\t\t// never reset null status for constants", "-\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "-\t}", "-\tlong tagBits = this.binding.tagBits;", "-\tif ((tagBits & TagBits.AnnotationNonNull) != 0) {", "-\t\tif (this.initialization != null) {", "-\t\t\tint nullStatus = this.initialization.nullStatus(flowInfo);", "-\t\t\t// check against annotation @NonNull:", "-\t\t\tif (nullStatus != FlowInfo.NON_NULL) {", "-\t\t\t\tchar[][] annotationName = initializationScope.environment().getNonNullAnnotationName();", "-\t\t\t\tinitializationScope.problemReporter().nullityMismatch(this.initialization, this.binding.type, nullStatus, annotationName);", "-\t\t\t}", "-\t\t}", "-\t\t// record nonnull for use by methods:", "-\t\tdeclaringClassFlowInfo.markAsDefinitelyNonNull(this.binding);", "-", "-\t\t// tell resetNullInfoForFields not to update this field's status", "-\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "-\t} else if ((tagBits & TagBits.AnnotationNullable) != 0) {", "-\t\t// record pot.null for use by methods:", "-\t\tdeclaringClassFlowInfo.resetNullInfo(this.binding);", "-\t\tdeclaringClassFlowInfo.markPotentiallyNullBit(this.binding);", "-", "-\t\t// tell resetNullInfoForFields to reset this field to pot.null:", "-\t\t// (note that this info is ineffective if the field is also constant)", "-\t\tfieldResetInfo.resetNullInfo(this.binding);", "-\t\tfieldResetInfo.markPotentiallyNullBit(this.binding);", "-\t} else if (!isConstant && includeFieldsInNullAnalysis) {", "-\t\t// tell resetNullInfoForFields to reset this field to def.unknown:", "-\t\tfieldResetInfo.markAsDefinitelyUnknown(this.binding);"]}], "num": 60052}