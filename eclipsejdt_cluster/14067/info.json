{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6908d1360f770cdd7a58771a495169b2", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "997f08108ce649d68f2041112eb145a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "0de5167791884524f72d9d44c10f0e243af65d00", "commitAfterChange": "07ab76f69fbeeb2f2fd54cdf3d01ee69344b9ae0", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "signatureAfterChange": "  \tprivate void resolve( \t\t\tString[] sourceCompilationUnits, \t\t\tString[] encodings, \t\t\tString[] bindingKeys, \t\t\tFileASTRequestor astRequestor, \t\t\tint apiLevel, \t\t\tMap compilerOptions, \t\t\tint flags)", "diff": ["+", "+\tprivate void resolve(", "+\t\t\tString[] sourceCompilationUnits,", "+\t\t\tString[] encodings,", "+\t\t\tString[] bindingKeys,", "+\t\t\tFileASTRequestor astRequestor,", "+\t\t\tint apiLevel,", "+\t\t\tMap compilerOptions,", "+\t\t\tint flags) {", "+", "+\t\t// temporarily connect ourselves to the ASTResolver - must disconnect when done", "+\t\tastRequestor.compilationUnitResolver = this;", "+\t\tthis.bindingTables = new DefaultBindingResolver.BindingTables();", "+\t\tCompilationUnitDeclaration unit = null;", "+\t\ttry {", "+\t\t\tint length = sourceCompilationUnits.length;", "+\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit[] sourceUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[length];", "+\t\t\tint count = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tchar[] contents = null;", "+\t\t\t\tString encoding = encodings != null ? encodings[i] : null;", "+\t\t\t\tString sourceUnitPath = sourceCompilationUnits[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tcontents = Util.getFileCharContent(new File(sourceUnitPath), encoding);", "+\t\t\t\t} catch(IOException e) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (contents == null) {", "+\t\t\t\t\t// go to the next unit", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tsourceUnits[count++] = new org.eclipse.jdt.internal.compiler.batch.CompilationUnit(contents, sourceUnitPath, encoding);", "+\t\t\t}", "+\t\t\tbeginToCompile(sourceUnits, bindingKeys);", "+\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "+\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "+\t\t\t\tif (resolvedRequestedSourcesAndKeys(i)) {", "+\t\t\t\t\t// no need to keep resolving if no more ASTs and no more binding keys are needed", "+\t\t\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=114935", "+\t\t\t\t\t// cleanup remaining units", "+\t\t\t\t\tfor (; i < this.totalUnits; i++) {", "+\t\t\t\t\t\tthis.unitsToProcess[i].cleanUp();", "+\t\t\t\t\t\tthis.unitsToProcess[i] = null;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tunit = this.unitsToProcess[i];", "+\t\t\t\ttry {", "+\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "+", "+\t\t\t\t\t// requested AST", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit source = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) this.requestedSources.get(fileName);", "+\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\tast.setFlag(flags | AST.RESOLVED_BINDINGS);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, null, this.bindingTables, (flags & ICompilationUnit.ENABLE_BINDINGS_RECOVERY) != 0, this.fromJavaProject);", "+\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\tcompilationUnit.setTypeRoot(null);", "+\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "+\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "+", "+\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\tastRequestor.acceptAST(new String(source.getFileName()), compilationUnit);", "+", "+\t\t\t\t\t\tworked(1);", "+", "+\t\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "+\t\t\t\t\t\tthis.requestedSources.put(fileName, null); // mark it as removed", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t// requested binding", "+\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "+\t\t\t\t\tif (key != null) {", "+\t\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "+\t\t\t\t\t\t\treportBinding(key, astRequestor, unit);", "+\t\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t\t} else if (key instanceof ArrayList) {", "+\t\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "+\t\t\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, unit);", "+\t\t\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "+\t\t\t\t\t\tthis.requestedKeys.put(fileName, null); // mark it as removed", "+\t\t\t\t\t}", "+\t\t\t\t} finally {", "+\t\t\t\t\t// cleanup compilation unit result", "+\t\t\t\t\tunit.cleanUp();", "+\t\t\t\t}", "+\t\t\t\tthis.unitsToProcess[i] = null; // release reference to processed unit declaration", "+\t\t\t\tthis.requestor.acceptResult(unit.compilationResult.tagAsAccepted());", "+\t\t\t}", "+", "+\t\t\t// remaining binding keys", "+\t\t\tDefaultBindingResolver resolver = new DefaultBindingResolver(this.lookupEnvironment, null, this.bindingTables, (flags & ICompilationUnit.ENABLE_BINDINGS_RECOVERY) != 0, true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb84936e5be61120b89e8d6e5720ef68", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "89566b19098686deffb54767a28967337579ef90", "commitAfterChange": "907520562618c52ad9275f3500852726a78168ff", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "signatureAfterChange": "  \tprivate void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner)", "diff": ["-\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0)", "+\t\t\t\tif (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0) {", "+\t\t\t\t\t// cleanup remaining units", "+\t\t\t\t\tfor (; i < this.totalUnits; i++) {", "+\t\t\t\t\t\tthis.unitsToProcess[i].cleanUp();", "+\t\t\t\t\t\tthis.unitsToProcess[i] = null;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();", "-\t\t\t\t\t", "-\t\t\t\t\t// only process requested units", "-\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "-\t\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "+\t\t\t\t\tsuper.process(unit, i); // this.process(...) is optimized to not process already known units", "-\t\t\t\t\t\t// requested AST", "-\t\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "-\t\t\t\t\t\tif (source != null) {", "-\t\t\t\t\t\t\t// convert AST", "-\t\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "-\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "-\t\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "-\t\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "-\t\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "-\t\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "-\t\t\t\t\t\t\tast.setBindingResolver(resolver);", "-\t\t\t\t\t\t\tconverter.setAST(ast);", "-\t\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "-\t\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "-\t\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "-\t\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "-\t\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t// pass it to requestor", "-\t\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t} ", "+\t\t\t\t\t// requested AST", "+\t\t\t\t\tchar[] fileName = unit.compilationResult.getFileName();\t\t\t\t\t", "+\t\t\t\t\tICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);", "+\t\t\t\t\tif (source != null) {", "+\t\t\t\t\t\t// convert AST", "+\t\t\t\t\t\tCompilationResult compilationResult = unit.compilationResult;", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;", "+\t\t\t\t\t\tchar[] contents = sourceUnit.getContents();", "+\t\t\t\t\t\tAST ast = AST.newAST(apiLevel);", "+\t\t\t\t\t\tast.setDefaultNodeFlag(ASTNode.ORIGINAL);", "+\t\t\t\t\t\tASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);", "+\t\t\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);", "+\t\t\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\t\t\tconverter.setAST(ast);", "+\t\t\t\t\t\tCompilationUnit compilationUnit = converter.convert(unit, contents);", "+\t\t\t\t\t\tcompilationUnit.setJavaElement(source);", "+\t\t\t\t\t\tcompilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());", "+\t\t\t\t\t\tast.setDefaultNodeFlag(0);", "+\t\t\t\t\t\tast.setOriginalModificationCount(ast.modificationCount());", "-\t\t\t\t\t\t// requested binding", "-\t\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "-\t\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "-\t\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\t// pass it to requestor", "+\t\t\t\t\t\tastRequestor.acceptAST(source, compilationUnit);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} ", "+\t\t\t\t\t", "+\t\t\t\t\t// requested binding", "+\t\t\t\t\tObject key = this.requestedKeys.get(fileName);", "+\t\t\t\t\tif (key instanceof BindingKeyResolver) {", "+\t\t\t\t\t\treportBinding(key, astRequestor, owner, unit);", "+\t\t\t\t\t\tworked(1);", "+\t\t\t\t\t} else if (key instanceof ArrayList) {", "+\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "+\t\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t} else if (key instanceof ArrayList) {", "-\t\t\t\t\t\t\tIterator iterator = ((ArrayList) key).iterator();", "-\t\t\t\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\t\t\t\treportBinding(iterator.next(), astRequestor, owner, unit);", "-\t\t\t\t\t\t\t\tworked(1);", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "+\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "+\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "-\t\t\t\t\t\t// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested", "-\t\t\t\t\t\tthis.requestedSources.removeKey(fileName);", "-\t\t\t\t\t\tthis.requestedKeys.removeKey(fileName);", "+/*\tCode used to fault in types and resolve which is no longer necessary as all questions asked to forward references are", "+ * lazily resolved.", "+ * Code used to be:", "+\t\t\t\t\tif (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {", "+\t\t\t\t\t   ...", "+", "-/*", "+", "-\t\t\t\t\t}"]}], "num": 14067}