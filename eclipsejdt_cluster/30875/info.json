{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "26435c257e8d6f9b0f1612a4cc63c15e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7320cb8a13b78c7ec5dcadecb229b0a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic MethodBinding findMethodForArray( \t\tArrayBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethodForArray( \t\tArrayBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["-\t\t\tif (argumentTypes == NoParameters && CharOperation.equals(selector, CLONE))", "-\t\t\t\treturn new UpdatedMethodBinding(", "-\t\t\t\t\tenvironment().options.targetJDK >= ClassFileConstants.JDK1_4 ? (TypeBinding)receiverType : (TypeBinding)object, // remember its array type for codegen purpose on target>=1.4.0", "-\t\t\t\t\t(methodBinding.modifiers ^ AccProtected) | AccPublic,", "-\t\t\t\t\tCLONE,", "-\t\t\t\t\tmethodBinding.returnType,", "-\t\t\t\t\targumentTypes,", "-\t\t\t\t\tnull,", "-\t\t\t\t\tobject);", "+\t\t\tif (argumentTypes == NoParameters) {", "+\t\t\t    switch (selector[0]) {", "+\t\t\t        case 'c': ", "+\t\t\t            if (CharOperation.equals(selector, CLONE))", "+\t\t\t\t\t\t\treturn new UpdatedMethodBinding(", "+\t\t\t\t\t\t\t\tenvironment().options.targetJDK >= ClassFileConstants.JDK1_4 ? (TypeBinding)receiverType : (TypeBinding)object, // remember its array type for codegen purpose on target>=1.4.0", "+\t\t\t\t\t\t\t\t(methodBinding.modifiers ^ AccProtected) | AccPublic,", "+\t\t\t\t\t\t\t\tCLONE,", "+\t\t\t\t\t\t\t\tmethodBinding.returnType,", "+\t\t\t\t\t\t\t\targumentTypes,", "+\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\tobject);", "+\t\t\t            break;", "+\t\t\t        case 'g': ", "+\t\t\t            if (CharOperation.equals(selector, GETCLASS) && methodBinding.returnType.isParameterizedType()/*1.5*/) {", "+\t\t\t\t\t\t\treturn ParameterizedMethodBinding.instantiateGetClass(receiverType, methodBinding, this);", "+\t\t\t            }", "+\t\t\t            break;", "+\t\t\t    }", "+\t\t\t}", "-\t\t\tif (!areParametersAssignable(methodBinding.parameters, argumentTypes))", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\targumentTypes,", "-\t\t\t\t\tNotFound);", "+\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "+\t\t\tif (compatibleMethod == null)", "+\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, NotFound);", "+\t\t\tif (!compatibleMethod.isValidBinding())", "+\t\t\t\treturn compatibleMethod;", "+", "+\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\tmethodBinding,", "-\t\t\t\t\tselector,", "-\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\tNotVisible);", "+\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa34043aff33f19c78cbb73720798ab4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findExactMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "diff": ["-\t\t\tif (receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this))", "+\t\t\t// special treatment for Object.getClass() in 1.5 mode (substitute parameterized return type)", "+\t\t\tif (receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t    if (receiverType.id != T_Object", "+\t\t\t            && argumentTypes == NoParameters", "+\t\t\t            && CharOperation.equals(selector, GETCLASS)", "+\t\t\t            && exactMethod.returnType.isParameterizedType()/*1.5*/) {", "+\t\t\t        return ParameterizedMethodBinding.instantiateGetClass(receiverType, exactMethod, this);", "+\t\t\t    }", "+\t\t\t    // targeting a generic method could find an exact match with variable return type", "+\t\t\t    if (exactMethod.typeVariables != NoTypeVariables || invocationSite.genericTypeArguments() != null)", "+\t\t\t    \texactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);", "+\t\t\t}"]}], "num": 30875}