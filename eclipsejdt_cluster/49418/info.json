{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4667aa7ded2f0217b7eb07ac4a00eeeb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c47ced3ebce67de1bd7312c1c30420b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java", "commitBeforeChange": "c7e61e314902d7cf48e71c1a1c0437bb40107c2e", "commitAfterChange": "8a1621e802c664e59aba36b8a87f59ae57902e37", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tvoid checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod,  \t\t\tboolean hasNonNullDefault, boolean shouldComplain, \t\t\tMethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "signatureAfterChange": " \tvoid checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclaration srcMethod,  \t\t\tboolean hasNonNullDefault, boolean shouldComplain, \t\t\tMethodBinding inheritedMethod, Scope scope, InheritedNonNullnessInfo[] inheritedNonNullnessInfos)", "diff": ["-\t\tlong inheritedBits = inheritedMethod.tagBits;", "-\t\tlong inheritedNullnessBits = inheritedBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);", "-\t\tlong currentBits = currentMethod.tagBits;", "-\t\tlong currentNullnessBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);", "-\t\t", "+\t\tboolean useTypeAnnotations = environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;", "+\t\tlong inheritedNullnessBits = getReturnTypeNullnessTagBits(inheritedMethod, useTypeAnnotations);", "+\t\tlong currentNullnessBits = getReturnTypeNullnessTagBits(currentMethod, useTypeAnnotations);", "+\t\t", "-\t\t\t\t\t\t\tcurrentMethod.tagBits |= inheritedNullnessBits;", "+\t\t\t\t\t\t\tapplyReturnNullBits(currentMethod, inheritedNullnessBits, environment);", "-\t\t\t\t\tcurrentMethod.tagBits |= (currentNullnessBits = TagBits.AnnotationNonNull); ", "+\t\t\t\t\tcurrentNullnessBits = TagBits.AnnotationNonNull;", "+\t\t\t\t\tapplyReturnNullBits(currentMethod, currentNullnessBits, environment);", "+\t\tif (useTypeAnnotations) // need to look for type annotations on all parameters:", "+\t\t\tlength = currentMethod.parameters.length;", "-\t\t\tBoolean inheritedNonNullNess = (inheritedMethod.parameterNonNullness == null)", "-\t\t\t\t\t\t\t\t\t\t? null : inheritedMethod.parameterNonNullness[i];", "-\t\t\tBoolean currentNonNullNess = (currentMethod.parameterNonNullness == null)", "-\t\t\t\t\t\t\t\t\t\t? null : currentMethod.parameterNonNullness[i];", "+\t\t\tBoolean inheritedNonNullNess = getParameterNonNullness(inheritedMethod, i, useTypeAnnotations);", "+\t\t\tBoolean currentNonNullNess = getParameterNonNullness(currentMethod, i, useTypeAnnotations);", "-\t\t\t\t\t\t\trecordArgNonNullness(currentMethod, length, i, currentArgument, inheritedNonNullNess);", "+\t\t\t\t\t\t\tif (!useTypeAnnotations)", "+\t\t\t\t\t\t\t\trecordArgNonNullness(currentMethod, length, i, currentArgument, inheritedNonNullNess);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\trecordArgNonNullness18(currentMethod, i, currentArgument, inheritedNonNullNess, environment);", "-\t\t\t\t\trecordArgNonNullness(currentMethod, length, i, currentArgument, Boolean.TRUE);", "+\t\t\t\t\tif (!useTypeAnnotations)", "+\t\t\t\t\t\trecordArgNonNullness(currentMethod, length, i, currentArgument, Boolean.TRUE);", "+\t\t\t\t\telse", "+\t\t\t\t\t\trecordArgNonNullness18(currentMethod, i, currentArgument, Boolean.TRUE, environment);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "926ba12e4bc4f390fb307e293c56bd39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "ee88edc6852ca240266a0a82beb39fc6a3f8a578", "commitAfterChange": "321d0d2c500c247f0447784febbb6a14ba5499be", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " public SearchMatch newDeclarationMatch(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator)", "signatureAfterChange": " public SearchMatch newDeclarationMatch(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator)", "diff": ["-\t\t// Redo arguments verif as in this case previous filter may accept different ones", "-\t\tboolean equals = true;", "-\t\tif (this.pattern.parameterSimpleNames != null) {", "-\t\t\tint paramLength = this.pattern.parameterSimpleNames.length;", "-\t\t\tfor (int i=0; equals && i<paramLength; i++) {", "-\t\t\t\tint level = resolveLevelForType(this.pattern.parameterSimpleNames[i], this.pattern.parameterQualifications[i], methodBinding.parameters[i]);", "-\t\t\t\tif (level == IMPOSSIBLE_MATCH) equals = false;", "+\t\t// If method parameters verification was not valid, then try to see if method arguments can match a method in hierarchy", "+\t\tif (this.methodDeclarationsWithInvalidParam.containsKey(reference)) {", "+\t\t\t// First see if this reference has already been resolved => report match if validated", "+\t\t\tBoolean report = (Boolean) this.methodDeclarationsWithInvalidParam.get(reference);", "+\t\t\tif (report != null) {", "+\t\t\t\tif (report.booleanValue()) {", "+\t\t\t\t\treturn super.newDeclarationMatch(reference, element, elementBinding, accuracy, length, locator);", "+\t\t\t\t}", "+\t\t\t\treturn null;", "-\t\t}", "-\t\t// If arguments are not equals then try to see if method arguments can match erasures in hierarchy", "-\t\tif (!equals && this.pattern.findDeclarations && this.mayBeGeneric) {", "-\t\t\tif (isErasureMethodOverride(methodBinding.declaringClass, methodBinding)) {", "+\t\t\tif (matchOverriddenMethod(methodBinding.declaringClass, methodBinding, null)) {", "+\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.TRUE);", "-\t\t\t\t\tpatternBinding = patternBinding.original();", "-\t\t\t\t\tif (!isErasureMethodOverride(patternBinding.declaringClass, patternBinding)) {", "+\t\t\t\t\tif (!matchOverriddenMethod(patternBinding.declaringClass, patternBinding, methodBinding)) {", "+\t\t\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.FALSE);", "+\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.TRUE);", "+\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.FALSE);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a38543a192f3a5cbd0f73a8aa7740b36", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java", "commitBeforeChange": "1bcc314de8ecb33755f26c04c2cbb843edde9199", "commitAfterChange": "dbe6aca431faafcf7eddb9a34689b7f814a6a0d3", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tpublic static char[][] getJavaLikeExtensions()", "signatureAfterChange": " \tpublic static char[][] getJavaLikeExtensions()", "diff": ["-\t\t\t\tString[] fileExtensions = javaContentType == null ? null : javaContentType.getFileSpecs(IContentType.FILE_EXTENSION_SPEC);", "-\t\t\t\t// note that file extensions contains \"java\" as it is defined in JDT Core's plugin.xml", "-\t\t\t\tint length = fileExtensions == null ? 0 : fileExtensions.length;", "-\t\t\t\tchar[][] extensions = new char[length][];", "-\t\t\t\tSimpleWordSet knownExtensions = new SimpleWordSet(length); // used to ensure no duplicate extensions", "-\t\t\t\textensions[0] = SuffixConstants.EXTENSION_java.toCharArray(); // ensure that \"java\" is first", "-\t\t\t\tknownExtensions.add(extensions[0]);", "-\t\t\t\tint index = 1;", "-\t\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\t\tString fileExtension = fileExtensions[i];", "-\t\t\t\t\tchar[] extension = fileExtension.toCharArray();", "-\t\t\t\t\tif (!knownExtensions.includes(extension)) {", "-\t\t\t\t\t\textensions[index++] = extension;", "-\t\t\t\t\t\tknownExtensions.add(extension);", "+\t\t\t\tHashSet fileExtensions = new HashSet();", "+\t\t\t\t// content types derived from java content type should be included (https://bugs.eclipse.org/bugs/show_bug.cgi?id=121715)", "+\t\t\t\tIContentType[] contentTypes = Platform.getContentTypeManager().getAllContentTypes();", "+\t\t\t\tfor (int i = 0, length = contentTypes.length; i < length; i++) {", "+\t\t\t\t\tif (contentTypes[i].isKindOf(javaContentType)) { // note that javaContentType.isKindOf(javaContentType) == true", "+\t\t\t\t\t\tString[] fileExtension = contentTypes[i].getFileSpecs(IContentType.FILE_EXTENSION_SPEC);", "+\t\t\t\t\t\tfor (int j = 0, length2 = fileExtension.length; j < length2; j++) {", "+\t\t\t\t\t\t\tfileExtensions.add(fileExtension[j]);", "+\t\t\t\t\t\t}", "-\t\t\t\tif (index != length)", "-\t\t\t\t\tSystem.arraycopy(extensions, 0, extensions = new char[index][], 0, index);", "+\t\t\t\tint length = fileExtensions.size();", "+\t\t\t\t// note that file extensions contains \"java\" as it is defined in JDT Core's plugin.xml", "+\t\t\t\tchar[][] extensions = new char[length][];", "+\t\t\t\textensions[0] = SuffixConstants.EXTENSION_java.toCharArray(); // ensure that \"java\" is first", "+\t\t\t\tint index = 1;", "+\t\t\t\tIterator iterator = fileExtensions.iterator();", "+\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\tString fileExtension = (String) iterator.next();", "+\t\t\t\t\tif (SuffixConstants.EXTENSION_java.equals(fileExtension))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\textensions[index++] = fileExtension.toCharArray();", "+\t\t\t\t}"]}], "num": 49418}