{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "150d958a121db4d125753777bbe9875c", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c170a221543c6e0856e705f930b10e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/CharOperation.java", "commitBeforeChange": "b8a20093bfb53c812e4e5b346e3aa791a4136ca4", "commitAfterChange": "44731467d9fdac9a7d80b255708d1b40800e1d02", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "signatureAfterChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "diff": ["-\t", "-\tchar[][] patternSegments = splitOn(pathSeparator, pattern);", "-\tchar[][] pathSegments = splitOn(pathSeparator, path);", "-\tchar[] patternSegment = null;", "-\t", "-\tint iPatternSegment = 0, patternSegmentLength = patternSegments.length;", "-\tint iPathSegment = 0, pathSegmentLength = pathSegments.length;", "-\t", "-\tfinal char[] doubleStar = new char[] { '*', '*' };", "-\tfor (int i = 0; i < patternSegmentLength; i++) {", "-\t\tif (patternSegments[i].length == 2 && patternSegments[i][0] == '*' && patternSegments[i][1] == '*') {", "-\t\t\tpatternSegments[i] = doubleStar;", "-\t\t}", "-\t}", "+", "+\tint iPattern = 0, patternLength = pattern.length;", "+\tint patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);", "+\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+", "+\tint iPath = 0, pathLength = path.length;", "+\tint pathSegmentEnd = CharOperation.indexOf(pathSeparator, path);", "+\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\twhile (iPatternSegment < patternSegmentLength && (patternSegment = patternSegments[iPatternSegment]) != doubleStar) {", "-\t\tif (iPathSegment == pathSegmentLength) return false;", "-\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "+\twhile (iPattern < patternLength", "+\t\t\t\t&& !(patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*')) {", "+\t\t\t\t\t", "+\t\tif (iPath >= pathLength) return false;", "+\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+", "+\t\t// jump to next segment\t\t", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "-\t\tiPatternSegment++;", "-\t\tiPathSegment++;", "+\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "+\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\tif (patternSegment == doubleStar){", "-\t\tsegmentStart = ++iPatternSegment; // skip star", "+\tif (patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*'){", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\tsegmentStart = iPattern;", "-\t\tsegmentStart = 0; // force iName check", "+\t\tsegmentStart = 0; // force iPath check", "-\tint prefixStart = iPathSegment;", "-\tcheckSegment: while (iPathSegment < pathSegmentLength && iPatternSegment < patternSegmentLength){", "+\tint prefixStart = iPath;", "+\tcheckSegment: while (iPath < pathLength && iPattern < patternLength){", "-\t\tif ((patternSegment = patternSegments[iPatternSegment]) == doubleStar){", "-\t\t\tsegmentStart = ++iPatternSegment; // skip start", "-\t\t\tprefixStart = iPathSegment;", "+\t\tif (patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*') {", "+\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\t\tsegmentStart = iPattern;", "+\t\t\tprefixStart = iPath;", "-\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "-\t\t\tiPatternSegment = segmentStart; // mismatch - restart current segment", "-\t\t\tiPathSegment = ++prefixStart;", "+\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+\t\t\t// mismatch - restart current segment", "+\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = segmentStart);", "+\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+", "+\t\t\tprefixStart = CharOperation.indexOf(pathSeparator, path, prefixStart+1); // skip separator", "+\t\t\tif (prefixStart < 0) {", "+\t\t\t\tprefixStart = pathLength;", "+\t\t\t} else {", "+\t\t\t\tprefixStart++;", "+\t\t\t}", "+\t\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = prefixStart);", "+\t\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\t\tiPathSegment++;", "-\t\tiPatternSegment++;", "+\t\t// jump to next segment\t\t", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\t", "+\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "+\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\treturn (segmentStart == patternSegmentLength)", "-\t\t\t|| (iPathSegment == pathSegmentLength && iPatternSegment == patternSegmentLength)\t", "-\t\t\t|| (iPatternSegment == patternSegmentLength - 1 && patternSegments[iPatternSegment] == doubleStar); ", "+\treturn (segmentStart >= patternSegmentEnd)", "+\t\t\t|| (iPath >= pathLength && iPattern >= patternLength)\t", "+\t\t\t|| (iPattern == patternLength - 2 && pattern[iPattern] == '*' && pattern[iPattern+1] == '*'); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aac9ca6c875b40cf91f40a3023030f43", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "36df18a67d193edba794a82365d3362cff21d1dc", "commitAfterChange": "50016e218da94faa790cc0eac00a2cb312fa37ee", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "signatureAfterChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "diff": ["-\ttry {", "-\t\tScanner scanner = new Scanner();", "-\t\tscanner.setSource(typeName);", "-\t\tint token = scanner.getNextToken();", "-\t\tboolean primitive = true;", "-\t\tchar primitiveSig = ' ';", "-\t\tStringBuffer sig = null;", "-\t\tint arrayCount = 0;", "-\t\tswitch (token) {", "-\t\t\tcase ITerminalSymbols.TokenNameIdentifier :", "-\t\t\t\tchar[] idSource = scanner.getCurrentIdentifierSource();", "-\t\t\t\tsig = new StringBuffer(idSource.length);", "-\t\t\t\tsig.append(idSource);", "-\t\t\t\tprimitive = false;", "+", "+\tif (typeName == null) throw new IllegalArgumentException(new String(typeName));", "+\tint length = typeName.length;", "+\tif (length == 0) throw new IllegalArgumentException(new String(typeName));", "+", "+\tboolean primitive = false;", "+\tchar primitiveSig = ' ';", "+\tint index = 0;", "+\t", "+\t// primitive type?", "+\tswitch (typeName[index]) {", "+\t\tcase 'b' :", "+\t\t\tif (CharOperation.fragmentEquals(BOOLEAN, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_BOOLEAN;", "+\t\t\t\tindex += BOOLEAN.length;\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNameboolean :", "-\t\t\t\tprimitiveSig = Signature.C_BOOLEAN;", "+\t\t\t} else if (CharOperation.fragmentEquals(BYTE, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_BYTE;", "+\t\t\t\tindex += BYTE.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamebyte :", "-\t\t\t\tprimitiveSig = Signature.C_BYTE;", "+\t\t\t}", "+\t\tcase 'c':", "+\t\t\tif (CharOperation.fragmentEquals(CHAR, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_CHAR;", "+\t\t\t\tindex += CHAR.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamechar :", "-\t\t\t\tprimitiveSig = Signature.C_CHAR;", "+\t\t\t}", "+\t\tcase 'd':", "+\t\t\tif (CharOperation.fragmentEquals(DOUBLE, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_DOUBLE;", "+\t\t\t\tindex += DOUBLE.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamedouble :", "-\t\t\t\tprimitiveSig = Signature.C_DOUBLE;", "+\t\t\t}", "+\t\tcase 'f':", "+\t\t\tif (CharOperation.fragmentEquals(FLOAT, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_FLOAT;", "+\t\t\t\tindex += FLOAT.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamefloat :", "-\t\t\t\tprimitiveSig = Signature.C_FLOAT;", "+\t\t\t}", "+\t\tcase 'i':", "+\t\t\tif (CharOperation.fragmentEquals(INT, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_INT;", "+\t\t\t\tindex += INT.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNameint :", "-\t\t\t\tprimitiveSig = Signature.C_INT;", "+\t\t\t}", "+\t\tcase 'l':", "+\t\t\tif (CharOperation.fragmentEquals(LONG, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_LONG;", "+\t\t\t\tindex += LONG.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamelong :", "-\t\t\t\tprimitiveSig = Signature.C_LONG;", "+\t\t\t}", "+\t\tcase 's':", "+\t\t\tif (CharOperation.fragmentEquals(SHORT, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_SHORT;", "+\t\t\t\tindex += SHORT.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNameshort :", "-\t\t\t\tprimitiveSig = Signature.C_SHORT;", "+\t\t\t}", "+\t\tcase 'v':", "+\t\t\tif (CharOperation.fragmentEquals(VOID, typeName, index, true)) {", "+\t\t\t\tprimitiveSig = C_VOID;", "+\t\t\t\tindex += SHORT.length;\t\t\t\t", "+\t\t\t\tprimitive = true;\t\t\t", "-\t\t\tcase ITerminalSymbols.TokenNamevoid :", "-\t\t\t\tprimitiveSig = Signature.C_VOID;", "+\t\t\t}", "+\t}", "+", "+\t// non primitive type and array count", "+\tchar[] sig = primitive ? null : new char[length];", "+\tint sigIndex = 0;", "+\tint arrayCount = 0;", "+\tint startID = primitive ? -1 : 0;", "+\twhile (index < length) {", "+\t\tchar currentChar = typeName[index];", "+\t\tswitch (currentChar) {", "+\t\t\tcase '.':", "+\t\t\t\tif (startID == -1) throw new IllegalArgumentException(new String(typeName));", "+\t\t\t\tif (startID < index) {", "+\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t}", "+\t\t\t\tint sigLength = sig.length;", "+\t\t\t\tif (sigIndex >= sigLength) {", "+\t\t\t\t\tSystem.arraycopy(sig, 0, sig = new char[sigLength*2], 0, sigLength);", "+\t\t\t\t}", "+\t\t\t\tsig[sigIndex++] = C_DOT;", "+\t\t\t\tindex++;", "+\t\t\t\tstartID = index;", "+\t\t\t\tbreak;", "+\t\t\tcase '[':", "+\t\t\t\tarrayCount++;", "+\t\t\t\tif (startID != -1) {", "+\t\t\t\t\tif (startID < index) {", "+\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartID = -1; // no more id after []", "+\t\t\t\t}", "+\t\t\t\tindex++;", "-\t\t\t\tthrow new IllegalArgumentException();", "+\t\t\t\tif (startID != -1 && CharOperation.isWhitespace(currentChar)) {", "+\t\t\t\t\tif (startID < index) {", "+\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t\t}", "+\t\t\t\t\tstartID = index+1;", "+\t\t\t\t}", "+\t\t\t\tindex++;", "+\t\t\t\tbreak;", "-\t\ttoken = scanner.getNextToken();", "-\t\twhile (!primitive && token == ITerminalSymbols.TokenNameDOT) {", "-\t\t\tsig.append(scanner.getCurrentIdentifierSource());", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t\tif (token == ITerminalSymbols.TokenNameIdentifier) {", "-\t\t\t\tsig.append(scanner.getCurrentIdentifierSource());", "-\t\t\t\ttoken = scanner.getNextToken();", "-\t\t\t} else {", "-\t\t\t\tthrow new IllegalArgumentException();", "-\t\t\t}", "-\t\t}", "-\t\twhile (token == ITerminalSymbols.TokenNameLBRACKET) {", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t\tif (token != ITerminalSymbols.TokenNameRBRACKET)", "-\t\t\t\tthrow new IllegalArgumentException();", "-\t\t\tarrayCount++;", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t}", "-\t\tif (token != ITerminalSymbols.TokenNameEOF)", "-\t\t\tthrow new IllegalArgumentException();", "-\t\tchar[] result;", "-\t\tif (primitive) {", "-\t\t\tresult = new char[arrayCount+1];", "-\t\t\tresult[arrayCount] = primitiveSig;", "-\t\t} else {", "-\t\t\tint sigLength = sig.length(); ", "-\t\t\tint resultLength = arrayCount + 1 + sigLength + 1; // e.g. '[[[Ljava.lang.String;'", "-\t\t\tresult = new char[resultLength];", "-\t\t\tsig.getChars(0, sigLength, result, arrayCount + 1);", "-\t\t\tresult[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;", "-\t\t\tresult[resultLength-1] = C_NAME_END;", "-\t\t}", "-\t\tfor (int i = 0; i < arrayCount; i++) {", "-\t\t\tresult[i] = C_ARRAY;", "-\t\t}", "-\t\treturn result;", "-\t} catch (InvalidInputException e) {", "-\t\tthrow new IllegalArgumentException();", "+\t// last id", "+\tif (startID != -1 && startID < index) {", "+\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\tsigIndex += index-startID;", "+\t}", "+\t", "+\t// build result", "+\tchar[] result;", "+\tif (primitive) {", "+\t\tresult = new char[arrayCount+1];", "+\t\tresult[arrayCount] = primitiveSig;", "+\t} else {", "+\t\tint resultLength = arrayCount + 1 + sigIndex + 1; // e.g. '[[[Ljava.lang.String;'", "+\t\tresult = new char[resultLength];", "+\t\tSystem.arraycopy(sig, 0, result, arrayCount + 1, sigIndex);", "+\t\tresult[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;", "+\t\tresult[resultLength-1] = C_NAME_END;", "+\t}", "+\tfor (int i = 0; i < arrayCount; i++) {", "+\t\tresult[i] = C_ARRAY;", "+\t}", "+\treturn result;"]}], "num": 46822}