{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b2bf1cdc0f5a504ddd785b89093739c6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "390113a1bcddfce68834f00564e35455", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java", "commitBeforeChange": "442cfec5b0ec5f78f613dac66413d02e26889f22", "commitAfterChange": "d42d74dc89c043581d93318957eb6b633b137649", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic final boolean checkCastTypesCompatibility( \t\tBlockScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType)", "signatureAfterChange": " \tpublic void tagAsUnnecessaryCast(Scope scope, TypeBinding castType)", "diff": ["-\t */", "-\tpublic final boolean checkCastTypesCompatibility(", "-\t\tBlockScope scope,", "-\t\tTypeBinding castType,", "-\t\tTypeBinding expressionType) {", "-\t", "-\t\t//A more complete version of this method is provided on", "-\t\t//CastExpression (it deals with constant and need runtime checkcast)", "-\t\tif (castType == expressionType) return false;", "-\t\t", "-\t\t//by grammatical construction, the base type check is not necessary", "-", "-\t\tif (castType == null || expressionType == null) return true;", "-\t", "-\t\t//-----------cast to something which is NOT a base type--------------------------\t", "-\t\tif (expressionType == NullBinding) {", "-\t\t\t//\tif (castType.isArrayType()){ // 26903 - need checkcast when casting null to array type", "-\t\t\t//\t\tneedRuntimeCheckcast = true;", "-\t\t\t//\t}", "-\t\t\treturn false; //null is compatible with every thing", "-\t\t}", "-\t\tif (expressionType.isBaseType()) {", "-\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\treturn true;", "-\t\t}", "-\t", "-\t\tif (expressionType.isArrayType()) {", "-\t\t\tif (castType == expressionType) return false; // identity conversion", "-\t", "-\t\t\tif (castType.isArrayType()) {", "-\t\t\t\t//------- (castType.isArray) expressionType.isArray -----------", "-\t\t\t\tTypeBinding exprElementType = ((ArrayBinding) expressionType).elementsType();", "-\t\t\t\tif (exprElementType.isBaseType()) {", "-\t\t\t\t\t// <---stop the recursion------- ", "-\t\t\t\t\tif (((ArrayBinding) castType).elementsType() != exprElementType)", "-\t\t\t\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\t// recursively on the elements...", "-\t\t\t\treturn checkCastTypesCompatibility(", "-\t\t\t\t\tscope,", "-\t\t\t\t\t((ArrayBinding) castType).elementsType(),", "-\t\t\t\t\texprElementType);", "-\t\t\t} else if (", "-\t\t\t\tcastType.isClass()) {", "-\t\t\t\t//------(castType.isClass) expressionType.isArray ---------------\t", "-\t\t\t\tif (castType.id == T_Object) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t} else { //------- (castType.isInterface) expressionType.isArray -----------", "-\t\t\t\tif (castType.id == T_JavaLangCloneable || castType.id == T_JavaIoSerializable) {", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\treturn true;", "-\t\t}", "-\t", "-\t\tif (expressionType.isClass()) {", "-\t\t\tif (castType.isArrayType()) {", "-\t\t\t\t// ---- (castType.isArray) expressionType.isClass -------", "-\t\t\t\tif (expressionType.id == T_Object) { // potential runtime error", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t} else if (castType.isClass()) { // ----- (castType.isClass) expressionType.isClass ------", "-\t\t\t\tif (expressionType.isCompatibleWith(castType)){ // no runtime error", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\tif (castType.isCompatibleWith(expressionType)) {", "-\t\t\t\t\t// potential runtime  error", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t} else { // ----- (castType.isInterface) expressionType.isClass -------  ", "-\t\t\t\tif (expressionType.isCompatibleWith(castType)) ", "-\t\t\t\t\treturn false;", "-\t\t\t\tif (!((ReferenceBinding) expressionType).isFinal()) {", "-\t\t\t\t    // a subclass may implement the interface ==> no check at compile time", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t\t// no subclass for expressionType, thus compile-time check is valid", "-\t\t\t}", "-\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\treturn true;", "-\t\t}", "-\t", "-\t\t//\tif (expressionType.isInterface()) { cannot be anything else", "-\t\tif (castType.isArrayType()) {", "-\t\t\t// ----- (castType.isArray) expressionType.isInterface ------", "-\t\t\tif (!(expressionType.id == T_JavaLangCloneable", "-\t\t\t\t\t|| expressionType.id == T_JavaIoSerializable)) {// potential runtime error", "-\t\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\t}", "-\t\t\treturn true;", "-\t\t} else if (castType.isClass()) { // ----- (castType.isClass) expressionType.isInterface --------", "-\t\t\tif (castType.id == T_Object) { // no runtime error", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t\tif (((ReferenceBinding) castType).isFinal()) {", "-\t\t\t\t// no subclass for castType, thus compile-time check is valid", "-\t\t\t\tif (!castType.isCompatibleWith(expressionType)) {", "-\t\t\t\t\t// potential runtime error", "-\t\t\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\t\t\treturn true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t} else { // ----- (castType.isInterface) expressionType.isInterface -------", "-\t\t\tif (expressionType.isCompatibleWith(castType)) { ", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t\tif (!castType.isCompatibleWith(expressionType)) {", "-\t\t\t\tMethodBinding[] castTypeMethods = ((ReferenceBinding) castType).methods();", "-\t\t\t\tMethodBinding[] expressionTypeMethods =", "-\t\t\t\t\t((ReferenceBinding) expressionType).methods();", "-\t\t\t\tint exprMethodsLength = expressionTypeMethods.length;", "-\t\t\t\tfor (int i = 0, castMethodsLength = castTypeMethods.length; i < castMethodsLength; i++)", "-\t\t\t\t\tfor (int j = 0; j < exprMethodsLength; j++) {", "-\t\t\t\t\t\tif ((castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)", "-\t\t\t\t\t\t\t\t&& CharOperation.equals(castTypeMethods[i].selector, expressionTypeMethods[j].selector)", "-\t\t\t\t\t\t\t\t&& castTypeMethods[i].areParametersEqual(expressionTypeMethods[j])) {", "-\t\t\t\t\t\t\tscope.problemReporter().notCompatibleTypesError(this, expressionType, castType);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\treturn true;", "-\t}", "+\t */", "+\tpublic void tagAsUnnecessaryCast(Scope scope, TypeBinding castType) {", "+\t\tscope.problemReporter().unnecessaryInstanceof(this, castType);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7f27c5f71557b219e847d947151fe85", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "cbfd7db0bb53f26158d0852adc3e2f21478a9415", "commitAfterChange": "86cd4406415b3c44c6ae3f955ab9070cd474074b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic final void areTypesCastCompatible( \t\tBlockScope scope, \t\tTypeBinding castTb, \t\tTypeBinding expressionTb)", "signatureAfterChange": "  \tpublic final void areTypesCastCompatible( \t\tBlockScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType)", "diff": ["-\t\tTypeBinding castTb,", "-\t\tTypeBinding expressionTb) {", "+\t\tTypeBinding castType,", "+\t\tTypeBinding expressionType) {", "-\t\tif (castTb == null || expressionTb == null)", "-\t\t\treturn;", "-\t\tif (castTb.isBaseType()) {", "-\t\t\tif (expressionTb.isBaseType()) {", "-\t\t\t\tif (expressionTb == castTb) {", "-\t\t\t\t\texpression.implicitWidening(castTb, expressionTb);", "+\t\tif (castType == null || expressionType == null) return;", "+\t\t", "+\t\tif (castType.isBaseType()) {", "+\t\t\tif (expressionType.isBaseType()) {", "+\t\t\t\tif (expressionType == castType) {", "+\t\t\t\t\texpression.implicitWidening(castType, expressionType);", "-\t\t\t\tif (Scope.areTypesCompatible(expressionTb, castTb)", "-\t\t\t\t\t|| BaseTypeBinding.isNarrowing(castTb.id, expressionTb.id)) {", "-\t\t\t\t\texpression.implicitConversion = (castTb.id << 4) + expressionTb.id;", "+\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType)", "+\t\t\t\t\t|| BaseTypeBinding.isNarrowing(castType.id, expressionType.id)) {", "+\t\t\t\t\texpression.implicitConversion = (castType.id << 4) + expressionType.id;", "-\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\tif (expressionTb == NullBinding)", "+\t\tif (expressionType == NullBinding) {", "+\t\t\tconstant = expression.constant;", "-", "-\t\tif (expressionTb.isBaseType()) {", "-\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t}", "+\t\tif (expressionType.isBaseType()) {", "+\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\tif (expressionTb.isArrayType()) {", "-\t\t\tif (castTb.isArrayType()) {", "-\t\t\t\t//------- (castTb.isArray) expressionTb.isArray -----------", "-\t\t\t\tTypeBinding expressionEltTb = ((ArrayBinding) expressionTb).elementsType(scope);", "+\t\tif (expressionType.isArrayType()) {", "+\t\t\tif (castType.isArrayType()) {", "+\t\t\t\t//------- (castType.isArray) expressionType.isArray -----------", "+\t\t\t\tTypeBinding expressionEltTb = ((ArrayBinding) expressionType).elementsType(scope);", "-\t\t\t\t\tif (((ArrayBinding) castTb).elementsType(scope) == expressionEltTb)", "+\t\t\t\t\tif (((ArrayBinding) castType).elementsType(scope) == expressionEltTb)", "-\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\t\t\t\t((ArrayBinding) castTb).elementsType(scope),", "+\t\t\t\t\t((ArrayBinding) castType).elementsType(scope),", "-\t\t\t\tcastTb.isClass()) {", "-\t\t\t\t//------(castTb.isClass) expressionTb.isArray ---------------\t", "-\t\t\t\tif (scope.isJavaLangObject(castTb))", "+\t\t\t\tcastType.isClass()) {", "+\t\t\t\t//------(castType.isClass) expressionType.isArray ---------------\t", "+\t\t\t\tif (scope.isJavaLangObject(castType))", "-\t\t\t} else { //------- (castTb.isInterface) expressionTb.isArray -----------", "-\t\t\t\tif (scope.isJavaLangCloneable(castTb) || scope.isJavaIoSerializable(castTb)) {", "+\t\t\t} else { //------- (castType.isInterface) expressionType.isArray -----------", "+\t\t\t\tif (scope.isJavaLangCloneable(castType) || scope.isJavaIoSerializable(castType)) {", "-\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\tif (expressionTb.isClass()) {", "-\t\t\tif (castTb.isArrayType()) {", "-\t\t\t\t// ---- (castTb.isArray) expressionTb.isClass -------", "-\t\t\t\tif (scope.isJavaLangObject(expressionTb)) { // potential runtime error", "+\t\tif (expressionType.isClass()) {", "+\t\t\tif (castType.isArrayType()) {", "+\t\t\t\t// ---- (castType.isArray) expressionType.isClass -------", "+\t\t\t\tif (scope.isJavaLangObject(expressionType)) { // potential runtime error", "-\t\t\t\tcastTb.isClass()) { // ----- (castTb.isClass) expressionTb.isClass ------", "-\t\t\t\tif (Scope.areTypesCompatible(expressionTb, castTb)) // no runtime error", "-\t\t\t\t\treturn;", "-\t\t\t\tif (Scope.areTypesCompatible(castTb, expressionTb)) {", "+\t\t\t\tcastType.isClass()) { // ----- (castType.isClass) expressionType.isClass ------", "+\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType)){ // no runtime error", "+\t\t\t\t\tif (castType.id == T_String && expression.constant != Constant.NotAConstant){", "+\t\t\t\t\t\tconstant = expression.constant; // (String) cst is still a constant", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (Scope.areTypesCompatible(castType, expressionType)) {", "-\t\t\t} else { // ----- (castTb.isInterface) expressionTb.isClass -------  ", "-\t\t\t\tif (((ReferenceBinding) expressionTb).isFinal()) {", "-\t\t\t\t\t// no subclass for expressionTb, thus compile-time check is valid", "-\t\t\t\t\tif (Scope.areTypesCompatible(expressionTb, castTb))", "+\t\t\t} else { // ----- (castType.isInterface) expressionType.isClass -------  ", "+\t\t\t\tif (((ReferenceBinding) expressionType).isFinal()) {", "+\t\t\t\t\t// no subclass for expressionType, thus compile-time check is valid", "+\t\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType))", "-\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\t//\tif (expressionTb.isInterface()) { cannot be anything else", "-\t\tif (castTb.isArrayType()) {", "-\t\t\t// ----- (castTb.isArray) expressionTb.isInterface ------", "-\t\t\tif (scope.isJavaLangCloneable(expressionTb)", "-\t\t\t\t|| scope.isJavaIoSerializable(expressionTb)) // potential runtime error", "+\t\t//\tif (expressionType.isInterface()) { cannot be anything else", "+\t\tif (castType.isArrayType()) {", "+\t\t\t// ----- (castType.isArray) expressionType.isInterface ------", "+\t\t\tif (scope.isJavaLangCloneable(expressionType)", "+\t\t\t\t|| scope.isJavaIoSerializable(expressionType)) // potential runtime error", "-\t\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\t\tcastTb.isClass()) { // ----- (castTb.isClass) expressionTb.isInterface --------", "-\t\t\tif (scope.isJavaLangObject(castTb)) // no runtime error", "+\t\t\tcastType.isClass()) { // ----- (castType.isClass) expressionType.isInterface --------", "+\t\t\tif (scope.isJavaLangObject(castType)) // no runtime error", "-\t\t\tif (((ReferenceBinding) castTb).isFinal()) {", "-\t\t\t\t// no subclass for castTb, thus compile-time check is valid", "-\t\t\t\tif (!Scope.areTypesCompatible(castTb, expressionTb)) {", "+\t\t\tif (((ReferenceBinding) castType).isFinal()) {", "+\t\t\t\t// no subclass for castType, thus compile-time check is valid", "+\t\t\t\tif (!Scope.areTypesCompatible(castType, expressionType)) {", "-\t\t\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);", "-\t\t} else { // ----- (castTb.isInterface) expressionTb.isInterface -------", "-\t\t\tif (castTb != expressionTb", "-\t\t\t\t&& (Scope.compareTypes(castTb, expressionTb) == NotRelated)) {", "-\t\t\t\tMethodBinding[] castTbMethods = ((ReferenceBinding) castTb).methods();", "-\t\t\t\tMethodBinding[] expressionTbMethods =", "-\t\t\t\t\t((ReferenceBinding) expressionTb).methods();", "-\t\t\t\tint exprMethodsLength = expressionTbMethods.length;", "-\t\t\t\tfor (int i = 0, castMethodsLength = castTbMethods.length;", "+\t\t} else { // ----- (castType.isInterface) expressionType.isInterface -------", "+\t\t\tif (castType != expressionType", "+\t\t\t\t&& (Scope.compareTypes(castType, expressionType) == NotRelated)) {", "+\t\t\t\tMethodBinding[] castTypeMethods = ((ReferenceBinding) castType).methods();", "+\t\t\t\tMethodBinding[] expressionTypeMethods =", "+\t\t\t\t\t((ReferenceBinding) expressionType).methods();", "+\t\t\t\tint exprMethodsLength = expressionTypeMethods.length;", "+\t\t\t\tfor (int i = 0, castMethodsLength = castTypeMethods.length;", "-\t\t\t\t\t\tif (castTbMethods[i].returnType != expressionTbMethods[j].returnType)", "-\t\t\t\t\t\t\tif (castTbMethods[i].selector == expressionTbMethods[j].selector)", "-\t\t\t\t\t\t\t\tif (castTbMethods[i].areParametersEqual(expressionTbMethods[j]))", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castTb, expressionTb);", "+\t\t\t\t\t\tif (castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)", "+\t\t\t\t\t\t\tif (castTypeMethods[i].selector == expressionTypeMethods[j].selector)", "+\t\t\t\t\t\t\t\tif (castTypeMethods[i].areParametersEqual(expressionTypeMethods[j]))", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().typeCastError(this, castType, expressionType);"]}], "num": 28273}