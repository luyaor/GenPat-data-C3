{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d1b8068d37cde701a854fe067cfdbf7e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4eb541da3de61637975eb45998a7d032", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "644c4d9043a8634631a6c37637807f9484dbb1d4", "commitAfterChange": "fff3d1bb7cd12822df70202db7e6a801aeeb63a2", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": " \tpublic BoundSet solve(boolean inferringApplicability) throws InferenceFailureException", "signatureAfterChange": " \tpublic BoundSet solve(boolean inferringApplicability) throws InferenceFailureException", "diff": ["+", "-\t\treturn resolve(this.inferenceVariables);", "+\t\tBoundSet solution = resolve(this.inferenceVariables);", "+\t\t", "+\t\t/* If inferring applicability make a final pass over the initial constraints preserved as final constraints to make sure they hold true at a macroscopic level.", "+\t\t   See https://bugs.eclipse.org/bugs/show_bug.cgi?id=426537#c55 onwards.", "+\t\t*/", "+\t\tif (inferringApplicability && solution != null && this.finalConstraints != null) {", "+\t\t\tfor (ConstraintExpressionFormula constraint: this.finalConstraints) {", "+\t\t\t\tif (constraint.left.isPolyExpression())", "+\t\t\t\t\tcontinue; // avoid redundant re-inference, inner poly's own constraints get validated in its own context & poly invocation type inference proved compatibility against target. ", "+\t\t\t\tconstraint.applySubstitution(solution, this.inferenceVariables);", "+\t\t\t\tif (!this.currentBounds.reduceOneConstraint(this, constraint)) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn solution;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "58b95765b2c1518d79fce00865cd48f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java", "commitBeforeChange": "9ef16bbd886b16521464fbe002994d5fbaed976f", "commitAfterChange": "b27f301e84866741a3cab27f0e35cc886c5fd2e8", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "          public List<AnnotationProcessorFactory> getFactoriesForProject( IProject p )", "signatureAfterChange": "          public synchronized List<AnnotationProcessorFactory> getFactoriesForProject( IJavaProject jproj )", "diff": ["-    public List<AnnotationProcessorFactory> getFactoriesForProject( IProject p ) {", "-    \tList<AnnotationProcessorFactory> factories = _project2factories.get(p);", "-    \tif ( factories == null )", "-    \t\tfactories = Collections.unmodifiableList( _workspaceFactories );", "-    \treturn factories;", "+    public synchronized List<AnnotationProcessorFactory> getFactoriesForProject( IJavaProject jproj ) {", "+    \t", "+    \tList<AnnotationProcessorFactory> factories = null;", "+    \t", "+\t\tif (_projectsLoaded.contains(jproj)) {", "+    \t\tfactories = _project2Factories.get(jproj);", "+    \t\tif (factories != null) {", "+    \t\t\treturn factories;", "+    \t\t}", "+\t\t}", "+\t\t// Load the project", "+\t\tList<FactoryContainer> containers = AptConfig.getContainers(jproj);", "+\t\tfactories = loadFactories(containers);", "+\t\t_projectsLoaded.add(jproj);", "+\t\t_project2Factories.put(jproj, factories);", "+\t\treturn factories;", "+    \t", "+    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70accad36931ea0990b5e3ef3a7be7b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "3d4c211d581e5ab7a648e648f6e07c2d98cd2b06", "commitAfterChange": "985d5704b5812718c29d572a9f4e88e4ef1e7e81", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t// check on demand imports", "-\t\t\t\t\tif (importBinding.isStatic() && importBinding.onDemand) {", "+\t\t\t\t\tif (importBinding.isStatic()) {", "-\t\t\t\t\t\tif (resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\tMethodBinding possible = null;", "+\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding && !importBinding.onDemand) {", "+\t\t\t\t\t\t\tMethodBinding staticMethod = (MethodBinding) resolvedImport;", "-\t\t\t\t\t\t\tMethodBinding temp = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\tif (temp != null) {", "-\t\t\t\t\t\t\t\tif (!temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null)", "-\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "-\t\t\t\t\t\t\t\t} else if (temp.isStatic()) {", "-\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(temp, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\t\tif (compatibleMethod != null) {", "-\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, Ambiguous);", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "-\t\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tpossible = findMethod(staticMethod.declaringClass, staticMethod.selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t} else if (resolvedImport instanceof ReferenceBinding && importBinding.onDemand) {", "+\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\t\t\t\t\tpossible = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (possible != null) {", "+\t\t\t\t\t\t\tif (!possible.isValidBinding()) {", "+\t\t\t\t\t\t\t\tif (foundMethod == null)", "+\t\t\t\t\t\t\t\t\tfoundMethod = possible; // answer as error case match", "+\t\t\t\t\t\t\t} else if (possible.isStatic()) {", "+\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t\tif (compatibleMethod != null) {", "+\t\t\t\t\t\t\t\t\tif (compatibleMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tif (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\t\tif (!importBinding.onDemand) // single method selector import", "+\t\t\t\t\t\t\t\t\t\t\t\treturn compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, Ambiguous);", "+\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(temp, selector, argumentTypes, NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(possible, selector, argumentTypes, NotFound);"]}], "num": 71766}