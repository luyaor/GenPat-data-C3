{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "93a9d7d9001d7456c22938cb94d946dc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7f7fee0583470618d29be39e4ee80617", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "a708a833352a17a462cbe9e9346d660fa6317a1e", "commitAfterChange": "0e8e783b8823e467b82792c7ef9289caad32e202", "methodNumberBeforeChange": 84, "methodNumberAfterChange": 85, "signatureBeforeChange": " \tprivate void printNewLinesBeforeDisablingComment()", "signatureAfterChange": " \tprivate void printNewLinesBeforeDisablingComment()", "diff": ["-\t\t\tStringBuffer indentationBuffer = new StringBuffer();", "+\t\t\tString indentationString;", "-\t\t\t\tprintIndentationIfNecessary(indentationBuffer);", "+\t\t\t\tthis.tempBuffer.setLength(0);", "+\t\t\t\tprintIndentationIfNecessary(this.tempBuffer);", "+\t\t\t\tindentationString = this.tempBuffer.toString();", "+\t\t\t} else {", "+\t\t\t\tindentationString = Util.EMPTY_STRING;", "-\t\t\t\tthis.edits[this.editsIndex-1] = new OptimizedReplaceEdit(beginningOfLine, offset+length-beginningOfLine, indentationBuffer.toString());", "+\t\t\t\tthis.edits[this.editsIndex-1] = new OptimizedReplaceEdit(beginningOfLine, offset+length-beginningOfLine, indentationString);", "-\t\t\t\t\tStringBuffer buffer = new StringBuffer(replacement.substring(0, start));", "-\t\t\t\t\tbuffer.append(indentationBuffer);", "-\t\t\t\t\tthis.edits[this.editsIndex-1] = new OptimizedReplaceEdit(offset, length, buffer.toString());", "+\t\t\t\t\tthis.tempBuffer.setLength(0);", "+\t\t\t\t\tthis.tempBuffer.append(replacement.substring(0, start));", "+\t\t\t\t\tif (indentationString != Util.EMPTY_STRING) {", "+\t\t\t\t\t\tthis.tempBuffer.append(indentationString);", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.edits[this.editsIndex-1] = new OptimizedReplaceEdit(offset, length, this.tempBuffer.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7644c93638e7032a4d651b4970e2c30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java", "commitBeforeChange": "e6021d67f030c85737aa105da719e9a09cfc30ed", "commitAfterChange": "47da1e1f50b1360a7b560d74dfe1c60303fec552", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public synchronized Index getIndex(IPath containerPath, IPath indexLocation, boolean reuseExistingFile, boolean createIfMissing)", "signatureAfterChange": " public synchronized Index getIndex(IPath containerPath, IndexLocation indexLocation, boolean reuseExistingFile, boolean createIfMissing)", "diff": ["-public synchronized Index getIndex(IPath containerPath, IPath indexLocation, boolean reuseExistingFile, boolean createIfMissing) {", "+public synchronized Index getIndex(IPath containerPath, IndexLocation indexLocation, boolean reuseExistingFile, boolean createIfMissing) {", "-\t\tString indexLocationString = indexLocation.toOSString();", "-\t\t\tFile indexFile = new File(indexLocationString);", "-\t\t\tif (indexFile.exists()) { // check before creating index so as to avoid creating a new empty index if file is missing", "+\t\t\tif (indexLocation.exists()) { // check before creating index so as to avoid creating a new empty index if file is missing", "-\t\t\t\t\tindex = new Index(indexLocationString, containerPathString, true /*reuse index file*/);", "+\t\t\t\t\tindex = new Index(indexLocation, containerPathString, true /*reuse index file*/);", "-\t\t\t\t\tif (currentIndexState != REBUILDING_STATE) { // rebuild index if existing file is corrupt, unless the index is already being rebuilt", "+\t\t\t\t\tif (currentIndexState != REBUILDING_STATE && currentIndexState != REUSE_STATE) { // rebuild index if existing file is corrupt, unless the index is already being rebuilt", "-\t\t\t\t\t\t\tUtil.verbose(\"-> cannot reuse existing index: \"+indexLocationString+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t\t\t\tUtil.verbose(\"-> cannot reuse existing index: \"+indexLocation+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\tif (currentIndexState == REUSE_STATE) {", "+\t\t\t\t// supposed to be in reuse state but error in the index file, so reindex.", "+\t\t\t\tif (VERBOSE)", "+\t\t\t\t\tUtil.verbose(\"-> cannot reuse given index: \"+indexLocation+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\tthis.indexLocations.put(containerPath, null);", "+\t\t\t\tindexLocation = computeIndexLocation(containerPath);", "+\t\t\t\trebuildIndex(indexLocation, containerPath);", "+\t\t\t\treturn null;", "+\t\t\t}", "-\t\t\t\t\tUtil.verbose(\"-> create empty index: \"+indexLocationString+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\tindex = new Index(indexLocationString, containerPathString, false /*do not reuse index file*/);", "+\t\t\t\t\tUtil.verbose(\"-> create empty index: \"+indexLocation+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\tindex = new Index(indexLocation, containerPathString, false /*do not reuse index file*/);", "-\t\t\t\t\tUtil.verbose(\"-> unable to create empty index: \"+indexLocationString+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t\tUtil.verbose(\"-> unable to create empty index: \"+indexLocation+\" path: \"+containerPathString); //$NON-NLS-1$ //$NON-NLS-2$"]}], "num": 23626}