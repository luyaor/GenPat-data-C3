{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3e9eea4fc31d98dbf87ead23ad184c1e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0b2dfdebb32cd593bed650085d67487a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 83, "signatureBeforeChange": " \tpublic IClasspathEntry[] getRawClasspath() throws JavaModelException", "signatureAfterChange": " \tpublic IClasspathEntry[] getRawClasspath() throws JavaModelException", "diff": ["-\t\t// Do not create marker but log problems while getting raw classpath", "-\t\treturn getRawClasspath(false, true);", "-\t}", "+\t\tJavaModelManager.PerProjectInfo perProjectInfo = getPerProjectInfo();", "+\t\tIClasspathEntry[] classpath = perProjectInfo.rawClasspath;", "+\t\tif (classpath != null) return classpath;", "+\t\t", "+\t\tclasspath = perProjectInfo.readAndCacheClasspath(this);", "+\t\tif (classpath == JavaProject.INVALID_CLASSPATH)", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "110d027d9fedbfd59531806d6ad83fba", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java", "commitBeforeChange": "16a26bc49f78acb9a7d0c10a9d6bedce29952111", "commitAfterChange": "e70f557904c0f4a9dab2a8974c294cadedac3b10", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r \r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "signatureAfterChange": "\r \r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "diff": ["-\t\t//    OR the field is a static field accessed directly through a type\r", "+\t\t//    OR the method is a static method accessed directly through a type\r", "+\t\t//    OR previous assertions are true for one of the enclosing type\r", "-\t\tif (declaringClass.isSuperclassOf(invocationType)) {\r", "-\t\t\tif (invocationSite.isSuperAccess()) return true;\r", "-\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "-\t\t\tif (receiverType instanceof ArrayBinding)\r", "-\t\t\t\treturn false;\r", "-\t\t\tif (invocationType == receiverType || invocationType.isSuperclassOf((ReferenceBinding) receiverType))\r", "-\t\t\t\treturn true;\r", "-\t\t\tif (isStatic())\r", "-\t\t\t\treturn true; // see 1FMEPDL - return invocationSite.isTypeAccess();\r", "-\t\t}\r", "+\t\t\r", "+\t\tReferenceBinding currentType = invocationType;\r", "+\t\tint depth = 0;\r", "+\t\tdo {\r", "+\t\t\tif (declaringClass.isSuperclassOf(currentType)) {\r", "+\t\t\t\tif (invocationSite.isSuperAccess()){\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\t}\r", "+\t\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "+\t\t\t\tif (receiverType instanceof ArrayBinding){\r", "+\t\t\t\t\treturn false;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (isStatic()){\r", "+\t\t\t\t\treturn true; // see 1FMEPDL - return invocationSite.isTypeAccess();\r", "+\t\t\t\t}\r", "+\t\t\t\tif (currentType == receiverType || currentType.isSuperclassOf((ReferenceBinding) receiverType)){\r", "+\t\t\t\t\tif (depth > 0) invocationSite.setDepth(depth);\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tdepth++;\r", "+\t\t\tcurrentType = currentType.enclosingType();\r", "+\t\t} while (currentType != null);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ce2f03213269bd2a9f4d2c41f1fa788", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java", "commitBeforeChange": "fffe0226b316a10993369d727f8c3eea5e70ad6e", "commitAfterChange": "b9a24a44a980bf3229c906639157a97b45b07dd7", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate Object[] computeNonJavaResources(JavaProject project)", "signatureAfterChange": " \tprivate Object[] computeNonJavaResources(JavaProject project)", "diff": ["+\t\tIPath projectOutput = null;", "-\t\t\tclasspath = project.getExpandedClasspath(true);", "+\t\t\tclasspath = project.getResolvedClasspath(true/*ignore unresolved variable*/);", "-\t\t\tbinIsProject = projectPath.equals(project.getOutputLocation());", "+\t\t\tprojectOutput = project.getOutputLocation();", "+\t\t\tbinIsProject = projectPath.equals(projectOutput);", "-\t\t\t\t\t\t// ignore this file if referred to on the build path", "-\t\t\t\t\t\tif (project.findPackageFragmentRoot0(resFullPath) == null) {", "-\t\t\t\t\t\t\t// ignore .java file if src == project", "-\t\t\t\t\t\t\tif (srcIsProject ", "-\t\t\t\t\t\t\t\t&& Util.isValidCompilationUnitName(resName)", "-\t\t\t\t\t\t\t\t&& !Util.isExcluded(res, exclusionPatterns)) {", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// ignore .class file if bin == project", "-\t\t\t\t\t\t\tif (binIsProject && Util.isValidClassFileName(resName)) {", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// else add non java resource", "-\t\t\t\t\t\t\tif (nonJavaResources.length == nonJavaResourcesCounter) {", "-\t\t\t\t\t\t\t\t// resize", "-\t\t\t\t\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\t\t\t\t\tnonJavaResources,", "-\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\t(nonJavaResources = new IResource[nonJavaResourcesCounter * 2]),", "-\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\tnonJavaResourcesCounter);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tnonJavaResources[nonJavaResourcesCounter++] = res;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// ignore a jar file on the classpath", "+\t\t\t\t\t\tif (Util.isArchiveFileName(resName) && this.isClasspathEntryOrOutputLocation(resFullPath, classpath, projectOutput)) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t// ignore .java file if src == project", "+\t\t\t\t\t\tif (srcIsProject ", "+\t\t\t\t\t\t\t&& Util.isValidCompilationUnitName(resName)", "+\t\t\t\t\t\t\t&& !Util.isExcluded(res, exclusionPatterns)) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// ignore .class file if bin == project", "+\t\t\t\t\t\tif (binIsProject && Util.isValidClassFileName(resName)) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// else add non java resource", "+\t\t\t\t\t\tif (nonJavaResources.length == nonJavaResourcesCounter) {", "+\t\t\t\t\t\t\t// resize", "+\t\t\t\t\t\t\tSystem.arraycopy(", "+\t\t\t\t\t\t\t\tnonJavaResources,", "+\t\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t\t(nonJavaResources = new IResource[nonJavaResourcesCounter * 2]),", "+\t\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t\tnonJavaResourcesCounter);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tnonJavaResources[nonJavaResourcesCounter++] = res;", "-\t\t\t\t\t\tif (!this.isOutputLocation(resFullPath, classpath, project.getOutputLocation())", "-\t\t\t\t\t\t\t&& project.findPackageFragmentRoot0(resFullPath) == null", "-\t\t\t\t\t\t\t&& project.findPackageFragment0(resFullPath) == null) {", "-\t\t\t\t\t\t\tif (nonJavaResources.length == nonJavaResourcesCounter) {", "-\t\t\t\t\t\t\t\t// resize", "-\t\t\t\t\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\t\t\t\t\tnonJavaResources,", "-\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\t(nonJavaResources = new IResource[nonJavaResourcesCounter * 2]),", "-\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\tnonJavaResourcesCounter);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tnonJavaResources[nonJavaResourcesCounter++] = res;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// ignore folders on the classpath or that correspond to an output location", "+\t\t\t\t\t\tif (this.isClasspathEntryOrOutputLocation(resFullPath, classpath, projectOutput)) {", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t// else add non java resource", "+\t\t\t\t\t\tif (nonJavaResources.length == nonJavaResourcesCounter) {", "+\t\t\t\t\t\t\t// resize", "+\t\t\t\t\t\t\tSystem.arraycopy(", "+\t\t\t\t\t\t\t\tnonJavaResources,", "+\t\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t\t(nonJavaResources = new IResource[nonJavaResourcesCounter * 2]),", "+\t\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t\tnonJavaResourcesCounter);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tnonJavaResources[nonJavaResourcesCounter++] = res;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1db3f20228dd6a4af5aa862e2b43adbc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "1bd28947ec61a68bcbaa48e5f62a38f1082dad74", "commitAfterChange": "158f15ed7305b84f608a44b2b3e60c3a50fa4c1b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void boundCheck(Scope scope, TypeReference[] argumentReferences)", "signatureAfterChange": " \tpublic void boundCheck(Scope scope, TypeReference[] argumentReferences)", "diff": ["-\t\t\t\t    if (typeVariables[i].boundCheck(this, this.arguments[i], scope)  != TypeConstants.OK) {", "-\t\t\t\t    \thasErrors = true;", "-\t\t\t\t    \tif ((this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {", "-\t\t\t\t    \t\t// do not report secondary error, if type reference already got complained against", "-\t\t\t\t\t\t\tscope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);", "-\t\t\t\t    \t}", "-\t\t\t\t    }", "+\t\t\t\t    BoundCheckStatus checkStatus = typeVariables[i].boundCheck(this, this.arguments[i], scope, argumentReferences[i]);", "+\t\t\t\t    hasErrors |= checkStatus != BoundCheckStatus.OK;", "+\t\t\t    \tif (!checkStatus.isOKbyJLS() && (this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t    \t\t// do not report secondary error, if type reference already got complained against", "+\t\t\t\t\t\tscope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);", "+\t\t\t    \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23e4e5836cef72321ee02c857d6aa6ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "d0b9fa49059380aa33c580ecd386773dc780db14", "commitAfterChange": "297d21321fa4e0f1df8ca75fc42ba95a96cc17a8", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "signatureAfterChange": " \tpublic int boundCheck(Substitution substitution, TypeBinding argumentType)", "diff": ["-\t\t\t\t\t\t\t\tTypeBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeWithSameErasure(superclassBound);", "+\t\t\t\t\t\t\t\tTypeBinding match = wildcardBound.findSuperTypeWithSameErasure(superclassBound);", "-\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t\tmatch =  superclassBound.findSuperTypeWithSameErasure(wildcardBound);", "+\t\t\t\t\t\t\t\t\tif (match != null) {", "+\t\t\t\t\t\t\t\t\t\tif (!match.isIntersectingWith(wildcardBound)) {", "+\t\t\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tif (!wildcardBound.isTypeVariable() && !superclassBound.isTypeVariable()) {", "+\t\t\t\t\t\t\t\t\t\t\treturn TypeConstants.MISMATCH;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2667e89b10d4f41734cbf850f007843b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "c67d112c20f07c2dcda11714ef23687a9781a753", "commitAfterChange": "af79dfe4ab6f88841082d7727b71d3b65b4f7778", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 10, "signatureBeforeChange": " protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus)", "signatureAfterChange": " protected static NullAnnotationStatus findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus)", "diff": ["-protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {", "+protected static NullAnnotationStatus findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {", "+\tTypeBinding superTypeHint = null;", "-\t\t\t\t\t\t\treturn severity;", "+\t\t\t\t\t\t\treturn NULL_ANNOTATIONS_MISMATCH;", "-\t\t\t\t\treturn 2;", "+\t\t\t\t\treturn NULL_ANNOTATIONS_MISMATCH;", "-\t\t\tif (requiredType.isParameterizedType()  && providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()", "+\t\t\tTypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);", "+\t\t\tif (providedSuper != providedType)", "+\t\t\t\tsuperTypeHint = providedSuper;", "+\t\t\tif (requiredType.isParameterizedType()  && providedSuper instanceof ParameterizedTypeBinding) { // TODO(stephan): handle providedType.isRaw()", "-\t\t\t\tTypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;", "+\t\t\t\tTypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedSuper).arguments;", "-\t\t\t\t\t\tseverity = Math.max(severity, findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1));", "+\t\t\t\t\t\tNullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1);", "+\t\t\t\t\t\tseverity = Math.max(severity, status.severity);", "-\t\t\t\t\t\t\treturn severity;", "+\t\t\t\t\t\t\treturn new NullAnnotationStatus(severity, superTypeHint);", "-\t\t\t\tseverity = Math.max(severity, findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus));", "+\t\t\t\tNullAnnotationStatus status = findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus);", "+\t\t\t\tseverity = Math.max(severity, status.severity);", "-\t\t\tif (requiredEnclosing != null && providedEnclosing != null)", "-\t\t\t\tseverity = Math.max(severity, findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1));", "+\t\t\tif (requiredEnclosing != null && providedEnclosing != null) {", "+\t\t\t\tNullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1);", "+\t\t\t\tseverity = Math.max(severity, status.severity);", "+\t\t\t}", "-\treturn severity;", "+\tif (severity == 0)", "+\t\treturn NULL_ANNOTATIONS_OK;", "+\treturn new NullAnnotationStatus(severity, superTypeHint);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "310f9dc0e0ecb120fe262d4c2915c724", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor2.java", "commitBeforeChange": "4cb2c570d3aefe494107c2340c1d84687aeb83ac", "commitAfterChange": "dbd0d1d22c0c3005a7b77030231806c749e2cebd", "methodNumberBeforeChange": 57, "methodNumberAfterChange": 58, "signatureBeforeChange": "  \tpublic boolean visit(MethodDeclaration node)", "signatureAfterChange": "  \tpublic boolean visit(MethodDeclaration node)", "diff": ["-\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, this.preferences.insert_space_before_opening_paren_in_method_declaration); ", "+\t\tboolean spaceBeforeParen = this.preferences.insert_space_before_opening_paren_in_method_declaration;", "+\t\tif (node.isConstructor()) {", "+\t\t\tspaceBeforeParen = this.preferences.insert_space_before_opening_paren_in_constructor_declaration;", "+\t\t}", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, spaceBeforeParen); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39a0759d918f30470e101b3de53d40b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "b9de5f3466a9b4d6687de837720c445097067b16", "commitAfterChange": "39416e9e4305b172d90b88aed3085d98ded0a86c", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "signatureAfterChange": "\r \r \tpublic void emulateOuterAccess(\r \t\tReferenceBinding targetEnclosingType,\r \t\tboolean useDirectReference)", "diff": ["-\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t} else if (currentNestedType.isLocalType()) {\r", "-\t\t\t\t// direct enclosing instance link\r", "-\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "-\t\t\t\tcurrentType = currentNestedType.enclosingType;\r", "-\t\t\t\tif (methodScope().isInsideInitializerOrConstructor())\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "-\t\t\t\t// further indirect cases\r", "-\t\t\t\twhile (currentType.isNestedType()\r", "-\t\t\t\t\t&& currentType != targetEnclosingType\r", "-\t\t\t\t\t&& !targetEnclosingType.isSuperclassOf(currentType)) {\r", "-\r", "-\t\t\t\t\tcurrentNestedType = (NestedTypeBinding) currentType;\r", "+\t\t\t\t\t\r", "+\t\t\t} else { // indirect reference sequence\r", "+\t\t\t\tint depth = 0;\r", "+\t\t\t\t\r", "+\t\t\t\t// saturate all the way up until reaching compatible enclosing type\r", "+\t\t\t\twhile (currentType.isLocalType()){\r", "+\t\t\t\t\tNestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;\r", "-\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\r", "+\t\t\t\t\tif (depth == 0){\r", "+\t\t\t\t\t\tif (methodScope().isInsideInitializerOrConstructor()) {\r", "+\t\t\t\t\t\t\t// must also add a synthetic field if we're not inside a constructor\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgument(currentType);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t\t}\t\t\t\t\t\r", "+\t\t\t\t\t} else if (currentNestedType == targetEnclosingType \r", "+\t\t\t\t\t\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentNestedType)) {\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcurrentNestedType.addSyntheticArgumentAndField(currentType);\r", "+\t\t\t\t\t} \r", "+\t\t\t\t\tdepth++;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fc04c5fcd5a3589c127d158133e0ffd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "e90dfab1761bccc6555735320e283aaf05372db5", "commitAfterChange": "2360be30596f096b30c40d59f0ef4f349bd446d6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tpublic static void checkAnnotationValue(TypeBinding requiredType, TypeBinding annotationType, char[] memberName, Expression memberValue, Scope scope)", "signatureAfterChange": " \t \tpublic static void checkAnnotationValue(TypeBinding requiredType, TypeBinding annotationType, char[] memberName, Expression memberValue, Scope scope)", "diff": ["+\t\tTypeBinding memberValueType = memberValue.resolvedType;", "+\t\tif (memberValueType != null) {", "+\t\t\tif (!memberValueType.isCompatibleWith(requiredType)) {", "+\t\t\t\tscope.problemReporter().typeMismatchError(memberValueType, requiredType, memberValue);", "+\t\t\t\treturn; // may allow to proceed to find more errors at once", "+\t\t\t} else {", "+\t\t\t\tscope.compilationUnitScope().recordTypeConversion(requiredType, memberValueType);", "+\t\t\t}", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44215e2e769886476e87e6027c59ce1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "72643ddaac52d3ea6e2573fbe40b9af5d9586d1e", "commitAfterChange": "965ee55c83771df9f7f21b38b9a78903a86f630d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic ICompilationUnit generateFileDuringReconcile( \t\t\tICompilationUnit parentCompilationUnit, String typeName, \t\t\tString contents, WorkingCopyOwner workingCopyOwner, \t\t\tIProblemRequestor problemRequestor, IProgressMonitor progressMonitor )", "signatureAfterChange": " \tpublic synchronized FileGenerationResult generateFileDuringReconcile( \t\t\tICompilationUnit parentCompilationUnit, String typeName, \t\t\tString contents, WorkingCopyOwner workingCopyOwner, \t\t\tIProblemRequestor problemRequestor, IProgressMonitor progressMonitor )", "diff": ["-\tpublic ICompilationUnit generateFileDuringReconcile(", "+\tpublic synchronized FileGenerationResult generateFileDuringReconcile(", "+\t\tFileGenerationResult result = null;", "-\t\t\tworkingCopy = getWorkingCopy( ", "-\t\t\t\tparentCompilationUnit,  typeName, contents,  ", "-\t\t\t\tworkingCopyOwner, problemRequestor,  progressMonitor);", "+\t\t\tworkingCopy = getCachedWorkingCopy( parentCompilationUnit, typeName );", "-\t\t\t//", "-\t\t\t//  Update working copy's buffer with the contents of the type ", "-\t\t\t// ", "-\t\t\tupdateWorkingCopy( contents, workingCopy, workingCopyOwner, progressMonitor );", "+\t\t\tif ( workingCopy == null )", "+\t\t\t{", "+\t\t\t\t// create a new working copy", "+\t\t\t\tworkingCopy = createNewWorkingCopy(  ", "+\t\t\t\t\t\tparentCompilationUnit,  typeName, contents,  ", "+\t\t\t\t\t\tworkingCopyOwner, problemRequestor,  progressMonitor);", "+\t\t\t\tworkingCopy.reconcile(AST.JLS3, true, workingCopyOwner,", "+\t\t\t\t\t\tprogressMonitor);", "+\t\t\t\tresult = new FileGenerationResult((IFile)workingCopy.getResource(), true);", "+\t\t\t}", "+\t\t\telse", "+\t\t\t{", "+", "+\t\t\t\t//", "+\t\t\t\t//  Update working copy's buffer with the contents of the type ", "+\t\t\t\t// ", "+\t\t\t\tboolean modified = updateWorkingCopy( contents, workingCopy, workingCopyOwner, progressMonitor );", "+\t\t\t\tresult = new FileGenerationResult((IFile)workingCopy.getResource(), modified);", "+\t\t\t}", "-\t\t\treturn workingCopy;", "-\t\t", "+\t\t\treturn result;", "-\t\treturn workingCopy;", "+\t\treturn new FileGenerationResult((IFile)workingCopy.getResource(), true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46973a05370c34e7d0b7bfa8087e8db5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "809c21ac086d44a312f3c31c6951126c6520aeaa", "commitAfterChange": "495067f03b4b0bfec29183e25c4db2e6b2a1dc02", "methodNumberBeforeChange": 62, "methodNumberAfterChange": 62, "signatureBeforeChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tIPath projectOutputLocation, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError) \t\tthrows JavaModelException", "signatureAfterChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tIPath projectOutputLocation, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError, \t\tMap reverseMap) \t\tthrows JavaModelException", "diff": ["-\t\tboolean ignoreUnresolvedEntry,", "-\t\tboolean generateMarkerOnError) // if unresolved entries are met, should it trigger initializations", "+\t\tboolean ignoreUnresolvedEntry, // if unresolved entries are met, should it trigger initializations", "+\t\tboolean generateMarkerOnError,", "+\t\tMap reverseMap) // can be null if not interested in reverse mapping", "+\t\t\t\t\t\tif (reverseMap != null) reverseMap.put(resolvedEntry.getPath(), rawEntry);", "+\t\t\t\t\t\tif (reverseMap != null) reverseMap.put(cEntry.getPath(), rawEntry);", "+\t\t\t\t\tif (reverseMap != null) reverseMap.put(rawEntry.getPath(), rawEntry);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a3675f4e10a80c3cb00f0891c3eb6a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "40c99687ccd3cd2f32c7182f6dd3a3815c599017", "commitAfterChange": "2e79ccb3e74d7d6d092288c2beec68b5a73c3ab5", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\tboolean foundProblemVisible = false;", "-\t\t\t\t\t\t\t\t\t\tif (foundProblem != null && foundProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\tif (foundProblemVisible) {", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (foundProblem == null || (foundProblem.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() == ProblemReasons.NotFound))", "+\t\t\t\t\t\t\t\t\tif (foundProblem == null) {", "+\t\t\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\t\t\tif (! foundProblemVisible && methodBinding.problemId() == ProblemReasons.NotFound) {", "+\t\t\t\t\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding) methodBinding).closestMatch;", "+\t\t\t\t\t\t\t\t\t\tif (closestMatch != null && closestMatch.canBeSeenBy(receiverType, invocationSite, this)) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundProblem = methodBinding; // hold onto the first not visible/found error and keep the second not found if first is not visible", "+\t\t\t\t\t\t\t\t\t\t\tfoundProblemVisible = true;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\tif (foundProblem.problemId() == ProblemReasons.NotFound) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding) foundProblem).closestMatch;", "-\t\t\t\t\tif (closestMatch != null && closestMatch.canBeSeenBy(invocationSite, this))", "-\t\t\t\t\t\treturn foundProblem; // visible method selectors take precedence", "+\t\t\t\tif (foundProblem.problemId() == ProblemReasons.NotFound && foundProblemVisible) {", "+\t\t\t\t\treturn foundProblem; // visible method selectors take precedence"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5290a4e252b4e1d9fc50e9e1c23d7c95", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java", "commitBeforeChange": "bf51a4aa47223fadb7f3b17b32863e3b3b80475e", "commitAfterChange": "8319f0253498a6982b033633a715ec109582ac03", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void accept(ISourceType[] sourceTypes, PackageBinding packageBinding, AccessRestriction accessRestriction)", "signatureAfterChange": " \tpublic void accept(ISourceType[] sourceTypes, PackageBinding packageBinding, AccessRestriction accessRestriction)", "diff": ["-//\t\twhile (sourceTypes[0].getEnclosingType() != null)", "-//\t\t\tsourceTypes[0] = sourceTypes[0].getEnclosingType();", "+\t\twhile (sourceTypes[0].getEnclosingType() != null) {", "+\t\t\tsourceTypes[0] = sourceTypes[0].getEnclosingType();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "532c87598c8712a57a0976cb70cda671", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "c099c1c915ea3c2425fc3259553c0cf5526a58b0", "commitAfterChange": "c712e524fc146f884a167061179343b82ef9e12d", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\t\t\t\t\t\t// 30805 - non-visible (abstract) method still needs to be implemented even if similar method defined below (overridesPackageDefaultMethod) ", "-\t\t\t\t\t\tif (!(method.isDefault() && method.isAbstract() && (method.declaringClass.fPackage != type.fPackage))) { ", "-\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "-\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "-\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "+\t\t\t\t\t\t\tMethodBinding existingMethod = existingMethods[i];", "+\t\t\t\t\t\t\tif (method.returnType == existingMethod.returnType", "+\t\t\t\t\t\t\t\t\t&& !(method.isDefault() // (31398,30805) keep non-visible default abstract, if no implementation exists in same package", "+\t\t\t\t\t\t\t\t\t\t\t\t&& method.isAbstract() ", "+\t\t\t\t\t\t\t\t\t\t\t\t&& method.declaringClass.fPackage != existingMethod.declaringClass.fPackage)", "+\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(existingMethod)) {", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tif (nonVisibleDefaultMethods != null)", "-\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)", "-\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector))", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))", "+\t\t\t\t\tif (nonVisibleDefaultMethods != null) {", "+\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++) {", "+\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType", "+\t\t\t\t\t\t\t\t\t&& CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(nonVisibleDefaultMethods[i])) {", "-", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\t\tif (existingMethods == null)", "+\t\t\t\t\t\tif (existingMethods == null) {", "-\t\t\t\t\t\telse", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)", "+\t\t\t\t\t\tif (nonVisibleDefaultMethods == null) {", "-\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)", "+\t\t\t\t\t\t} else if (nonVisibleCount == nonVisibleDefaultMethods.length) {", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) { // non visible abstract methods cannot be overridden so the type must be defined abstract", "-", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {", "-\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "-\t\t\t\t\t\t\t\t\t\tbreak foundMatch;", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType", "+\t\t\t\t\t\t\t\t\t\t&& method.areParametersEqual(current[i])) {", "+\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "+\t\t\t\t\t\t\t\t\tbreak foundMatch;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f4030624800a4a24be544983742466b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java", "commitBeforeChange": "a0bf175365121b2ce6109fd510a1295aae7ead4c", "commitAfterChange": "bc334d447f9fedc80a94198538b7c7d486280e6a", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \r public final boolean canBeSeenBy(ReferenceBinding receiverType, SourceTypeBinding invocationType)", "signatureAfterChange": "\r \r public final boolean canBeSeenBy(ReferenceBinding receiverType, SourceTypeBinding invocationType)", "diff": ["-\t\t// answer true if the invocationType is the receiver (or its enclosingType) or they are in the same package\r", "-\t\t// OR the invocationType is a subclass of the enclosingType\r", "-\t\t//    AND the receiverType is the invocationType or its subclass\r", "+\r", "+\t\t// answer true if the invocationType is the declaringClass or they are in the same package\r", "+\t\t// OR the invocationType is a subclass of the declaringClass\r", "+\t\t//    AND the invocationType is the invocationType or its subclass\r", "+\t\t//    OR the type is a static method accessed directly through a type\r", "+\t\t//    OR previous assertions are true for one of the enclosing type\r", "-\t\tReferenceBinding declaringClass = enclosingType();\r", "-\t\tif (declaringClass != null){ // could be null if incorrect top-level protected type\r", "-\t\t\tif (invocationType == declaringClass) return true;\r", "-\t\t\tif (declaringClass.isSuperclassOf(invocationType))\r", "-\t\t\t\treturn invocationType == receiverType || invocationType.isSuperclassOf(receiverType);\r", "-\t\t}\r", "+\r", "+\t\tReferenceBinding currentType = invocationType;\r", "+\t\tReferenceBinding declaringClass = enclosingType(); // protected types always have an enclosing one\r", "+\t\tif (declaringClass == null) return false; // could be null if incorrect top-level protected type\r", "+\t\t//int depth = 0;\r", "+\t\tdo {\r", "+\t\t\tif (declaringClass == invocationType) return true;\r", "+\t\t\tif (declaringClass.isSuperclassOf(currentType)) return true;\r", "+\t\t\t//depth++;\r", "+\t\t\tcurrentType = currentType.enclosingType();\r", "+\t\t} while (currentType != null);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77780d879e4053b04e2a6cb8e79c8dcd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "ca349eb1728a54f5c4569863d8f64340b099c4ce", "commitAfterChange": "2575bc1675526f9cf1bae80cf41843bf7eedd3c4", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tpublic static ParameterizedGenericMethodBinding checkForContraditions( \t\t\tfinal ParameterizedGenericMethodBinding method, final InvocationSite invocationSite, final Scope scope)", "signatureAfterChange": " \tpublic static MethodBinding checkForContraditions( \t\t\tfinal MethodBinding method, final InvocationSite invocationSite, final Scope scope)", "diff": ["-\tpublic static ParameterizedGenericMethodBinding checkForContraditions(", "-\t\t\tfinal ParameterizedGenericMethodBinding method, final InvocationSite invocationSite, final Scope scope) {", "+\t */", "+\tpublic static MethodBinding checkForContraditions(", "+\t\t\tfinal MethodBinding method, final InvocationSite invocationSite, final Scope scope) {", "+\t\t\tif (scope == null)", "+\t\t\t\treturn new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.ContradictoryNullAnnotations);", "+\t\t\t\tif (scope == null)", "+\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.ContradictoryNullAnnotations);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79d1fb3fb25e3cf574e6d3865531a7ae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic void generateOptimizedStringBufferCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "signatureAfterChange": " \tpublic void generateOptimizedStringBufferCreation( \t\tBlockScope blockScope, \t\tCodeStream codeStream, \t\tint typeID)", "diff": ["-\t\t\t\tcodeStream.ldc(constant.stringValue());", "+\t\t\t\tString stringValue = constant.stringValue();", "+\t\t\t\tif (stringValue.length() == 0) {  // optimize \"\"+<str> ", "+\t\t\t\t\tcodeStream.invokeStringBufferDefaultConstructor();", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tcodeStream.ldc(stringValue);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a42aeb38ef60cd7e1bef61a63143391", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "5a88f6644c0454e2aeddcfeff61f92e0af6ee853", "commitAfterChange": "fbe3f3aabed3fd943703368b065a95bc68cf5a8d", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["-\r", "+\t\t\t\t\tISourceType topLevelType = sourceType;\r", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {\r", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\t\tif (!otherType.equals(sourceType))\r", "+\t\t\t\t\t\tif (!otherType.equals(topLevelType))\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83fa42aa9a00307f998459d63ac19ae2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java", "commitBeforeChange": "ac3d830e6e8728fac5ab5382119bdddda1d9f7df", "commitAfterChange": "f6481dd9693bf03828e045ffe5a565f52edfa2f0", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "      public Declaration getOwner()", "signatureAfterChange": "      public Declaration getOwner()", "diff": ["-        // TODO: (theodora) uncomment the following code when we get the next version of jdt.core", "-\t/*", "-\t\treturn Factory.createDeclaration(owner, _env);", "-\t\t", "-\t*/\t", "-        throw new UnsupportedOperationException(\"Need version 1.44 of jdt.core.dom.ITypeBinding.java. tyeung@bea.com\"); //$NON-NLS-1$", "+\t\treturn Factory.createDeclaration(owner, _env);    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85528946a78150512be875791e36c5fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CopyMoveResourcesTests.java", "commitBeforeChange": "ada5a33ef9764ab2fd532e79eecbd29d36d5cbaa", "commitAfterChange": "3fbf7d7b491dc22f98214e330c97192346d8c2e9", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public void testCopyReadOnlyPackageFragment() throws CoreException", "signatureAfterChange": " public void testCopyReadOnlyPackageFragment() throws CoreException", "diff": ["+\t\tIFile xSrcFile = getFile(\"/P/src/p1/p2/p3/X.java\");", "+\t\tif (xSrcFile != null) {", "+\t\t\txSrcFile.setReadOnly(false);", "+\t\t}", "+\t\t}", "+\t\tIPackageFragment p1Fragment = getPackage(\"/P/src2/p1\");", "+\t\tif (p1Fragment != null) {", "+\t\t\tp1Fragment.getResource().setReadOnly(false);", "+\t\t}", "+\t\tIPackageFragment p3Fragment = getPackage(\"/P/src2/p1/p2/p3\");", "+\t\tif (p3Fragment != null) {", "+\t\t\tp3Fragment.getResource().setReadOnly(false);", "+\t\t}", "+\t\tIFile xFile = getFile(\"/P/src2/p1/p2/p3/X.java\");", "+\t\tif (xFile != null) {", "+\t\t\txFile.setReadOnly(false);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87db92143ce9f3b525df860a17eadcde", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 121, "methodNumberAfterChange": 121, "signatureBeforeChange": " \tpublic MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final InvocationSite allocationSite)", "signatureAfterChange": " \tpublic MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final Invocation allocationSite)", "diff": ["-\tpublic MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final InvocationSite allocationSite) {", "+\tpublic MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final Invocation allocationSite) {", "-\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite);", "+\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite, APPLICABILITY);", "+\t\t}", "+\t\tif (visibleIndex == 1) {", "+\t\t\t// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):", "+\t\t\tvisible[0] = inferInvocationType(allocationSite, visible[0], argumentTypes);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8e31e9f5cca2bf787da87f19558fb47b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "4b4dbca0bb97a8d7d91d56de2e2d0246704ead9c", "commitAfterChange": "f45c88f3e7a99f05a0822482d3d6807236a1c216", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 9, "signatureBeforeChange": " \t \tpublic static IClasspathEntry elementDecode(Element element, IJavaProject project)", "signatureAfterChange": " \t \tpublic static IClasspathEntry elementDecode(Element element, IJavaProject project)", "diff": ["+\t\t// accessible files patterns (optional)", "+\t\tIPath[] accessibleFiles = decodePatterns(element, TAG_ACCESSIBLE);", "+\t\tif (accessibleFiles == null) accessibleFiles = inclusionPatterns; // backward compatible", "+\t\t", "+\t\t// non accessible files patterns (optional)", "+\t\tIPath[] nonAccessibleFiles = decodePatterns(element, TAG_NONACCESSIBLE);", "+\t\tif (nonAccessibleFiles == null) nonAccessibleFiles = exclusionPatterns; // backward compatible", "+\t\t", "+\t\t// extra attributes (optional)", "+\t\tIClasspathAttribute[] extraAttributes = decodeExtraAttributes(element);", "+\t\t", "-\t\t\t\t\t\t\t\t\t\t\t\tinclusionPatterns,", "-\t\t\t\t\t\t\t\t\t\t\t\texclusionPatterns,", "+\t\t\t\t\t\t\t\t\t\t\t\taccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\tnonAccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\textraAttributes,", "-\t\t\t\t\t\t\t\t\t\t\t\tinclusionPatterns,", "-\t\t\t\t\t\t\t\t\t\t\t\texclusionPatterns,", "+\t\t\t\t\t\t\t\t\t\t\t\taccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\tnonAccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\textraAttributes,", "-\t\t\t\t\treturn JavaCore.newSourceEntry(path, inclusionPatterns, exclusionPatterns, outputLocation);", "+\t\t\t\t\treturn JavaCore.newSourceEntry(path, inclusionPatterns, exclusionPatterns, outputLocation, extraAttributes);", "-\t\t\t\t\t\t\t\t\t\t\t\tinclusionPatterns,", "-\t\t\t\t\t\t\t\t\t\t\t\texclusionPatterns,", "+\t\t\t\t\t\t\t\t\t\t\t\taccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\tnonAccessibleFiles,", "+\t\t\t\t\t\t\t\t\t\t\t\textraAttributes,", "-\t\t\t\t\t\treturn JavaCore.newSourceEntry(path, inclusionPatterns, exclusionPatterns, outputLocation);", "+\t\t\t\t\t\treturn JavaCore.newSourceEntry(path, inclusionPatterns, exclusionPatterns, outputLocation, extraAttributes);", "-\t\t\t\t\t\tinclusionPatterns,", "-\t\t\t\t\t\texclusionPatterns,", "+\t\t\t\t\t\taccessibleFiles,", "+\t\t\t\t\t\tnonAccessibleFiles,", "+\t\t\t\t\t\textraAttributes,", "-\t\t\t\t\t\tinclusionPatterns,", "-\t\t\t\t\t\texclusionPatterns,", "+\t\t\t\t\t\taccessibleFiles,", "+\t\t\t\t\t\tnonAccessibleFiles,", "+\t\t\t\t\t\textraAttributes,", "-\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\tINCLUDE_ALL, ", "+\t\t\t\t\t\tEXCLUDE_NONE,", "+\t\t\t\t\t\tNO_EXTRA_ATTRIBUTES);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ff8b845d390560a9d4f3996c0181efa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e657b912c1ef94d48e9749f2cbf91c83fff8728f", "commitAfterChange": "a34df737b5102c35af6a4e4a81e1b17f0f972c06", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["+\t\t// fall thru if its a constructor with a synthetic argument... find it the slower way", "-\t\tif (reader == null) return null;", "-", "-\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\tif (methods != null) {", "-\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "-\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "-\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "-\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "-\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "-\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "-\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "-\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "-\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\tif (reader != null) {", "+\t\t\tIBinaryMethod[] methods = reader.getMethods();", "+\t\t\tif (methods != null) {", "+\t\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "+\t\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "+\t\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "+\t\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "+\t\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "+\t\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "+\t\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "+\t\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "+\t\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "+\t\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\treturn null;", "-\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tIMethod handle = type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tif (type.isBinary() && !handle.exists()) return null; // element doesn't exist in the .class file", "+\treturn handle;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1c5a9db2ba66435ca4ede55dc5b7e78", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "1ba6cf1a1cd58ea6964d3e53d500ba37300ad6c5", "commitAfterChange": "122386dad13a4daa4a6eb3fe318a2c079a2655ef", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r \r \tpublic SingleVariableDeclaration convert(Argument argument)", "signatureAfterChange": "\r \r \tpublic SingleVariableDeclaration convert(Argument argument)", "diff": ["-\t\tvariableDecl.setType(convertType(argument.type));\r", "-\t\tvariableDecl.setSourceRange(argument.declarationSourceStart, argument.declarationSourceEnd - argument.declarationSourceStart + 1);\r", "+\t\tType type = convertType(argument.type);\r", "+\t\tvariableDecl.setType(type);\r", "+\t\tint typeEnd = type.getStartPosition() + type.getLength() - 1;\r", "+\t\tint rightEnd = Math.max(typeEnd, argument.declarationSourceEnd);\r", "+\t\tvariableDecl.setSourceRange(argument.declarationSourceStart, rightEnd - argument.declarationSourceStart + 1);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b49e5a82096bdb6fc53e1fef161935f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "bae98ccb647b46a2d5cfccf36593de0c5db401c9", "commitAfterChange": "230a5cd410205aeead21b12e1ec93eae10a08fda", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": " \t \tpublic NormalAnnotation convert(org.eclipse.jdt.internal.compiler.ast.NormalAnnotation annotation)", "signatureAfterChange": " \t \tpublic NormalAnnotation convert(org.eclipse.jdt.internal.compiler.ast.NormalAnnotation annotation)", "diff": ["+\t\t", "+\t\tint start = annotation.sourceStart;", "+\t\tint end = annotation.declarationSourceEnd;", "+\t\t", "-\t\t\t\tnormalAnnotation.values().add(convert(memberValuePairs[i]));", "+\t\t\t\tMemberValuePair memberValuePair = convert(memberValuePairs[i]);", "+\t\t\t\tint memberValuePairEnd = memberValuePair.getStartPosition() + memberValuePair.getLength() - 1;", "+\t\t\t\tif (end == memberValuePairEnd) {", "+\t\t\t\t\tnormalAnnotation.setFlags(normalAnnotation.getFlags() | ASTNode.RECOVERED);", "+\t\t\t\t}", "+\t\t\t\tnormalAnnotation.values().add(memberValuePair);", "-\t\tint start = annotation.sourceStart;", "-\t\tint end = annotation.declarationSourceEnd;", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1ee8167bfc648a5f51020f9a8eca443", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "ce0032759c3236d2ea392944fcdfb033987155c8", "commitAfterChange": "5033818fa872fa58eee8c84922d0bad01293db14", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r public final boolean canBeSeenBy(TypeBinding receiverType, boolean isSuperAccess, Scope scope)", "signatureAfterChange": "\r public final boolean canBeSeenBy(TypeBinding receiverType, boolean isSuperAccess, Scope scope)", "diff": ["+\t\t//    OR previous assertions are true for one of the enclosing type\r", "-\t\tif (declaringClass.isSuperclassOf(invocationType)) {\r", "-\t\t\tif (isSuperAccess) return true;\r", "-\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "-\t\t\tif (receiverType instanceof ArrayBinding)\r", "-\t\t\t\treturn false;\r", "-\t\t\tif (invocationType == receiverType || invocationType.isSuperclassOf((ReferenceBinding) receiverType))\r", "-\t\t\t\treturn true;\r", "-\t\t\tif (isStatic())\r", "-\t\t\t\treturn true; // see 1FMEPDL - return invocationSite.isTypeAccess();\r", "-\t\t}\r", "+\t\t\r", "+\t\tReferenceBinding currentType = invocationType;\r", "+\t\tdo {\r", "+\t\t\tif (declaringClass.isSuperclassOf(currentType)) {\r", "+\t\t\t\tif (isSuperAccess) return true;\r", "+\t\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "+\t\t\t\tif (receiverType instanceof ArrayBinding)\r", "+\t\t\t\t\treturn false;\r", "+\t\t\t\tif (currentType == receiverType || currentType.isSuperclassOf((ReferenceBinding) receiverType))\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\tif (isStatic())\r", "+\t\t\t\t\treturn true; // see 1FMEPDL - return invocationSite.isTypeAccess();\r", "+\t\t\t}\r", "+\t\t\tcurrentType = currentType.enclosingType();\r", "+\t\t} while (currentType != null);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d134ce9d13489295edb0da5058cd7f90", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "b057a7f41b354df00fc836971733f7e56ec9e0f7", "commitAfterChange": "ed892004e9d31324e06eb4780bfb7eecc5b91586", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 43, "signatureBeforeChange": " \tprivate void findLocalMethodDeclarations( \t\tchar[] methodName, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType)", "signatureAfterChange": " \tprivate void findLocalMethodDeclarations( \t\tchar[] methodName, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType)", "diff": ["-\t\t\tif (onlyStaticMethods && !method.isStatic()) continue next;", "+\t\t\tif(method.isStatic()) {", "+\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "+\t\t\t\t", "+\t\t\t\tif(receiverType.isMemberType() && !receiverType.isStatic()) continue next;", "+\t\t\t\t", "+\t\t\t\tif(receiverType.isLocalType()) continue next;", "+\t\t\t} else  {", "+\t\t\t\tif(onlyStaticMethods) continue next;", "+\t\t\t}", "+\t\t\trelevance += computeRelevanceForStaticOveride(method.isStatic());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e83ddb5fb946307666bfdb083f6f7b69", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CopyMoveResourcesTests.java", "commitBeforeChange": "7a7863e26d078771aa16ec2c24b37b93343d0529", "commitAfterChange": "1c413c5bfedbd5e52b224e291c0f8a4c59fbd8ff", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " public void testMoveReadOnlyPackageFragment() throws CoreException", "signatureAfterChange": " public void testMoveReadOnlyPackageFragment() throws CoreException", "diff": ["+\t\tIFile xSrcFile = getFile(\"/P/src/p1/p2/p3/X.java\");", "+\t\tif (xSrcFile != null) {", "+\t\t\txSrcFile.setReadOnly(false);", "+\t\t}", "+\t\tif (pkg2 != null) {", "+\t\t\tpkg2.getResource().setReadOnly(false);", "+\t\t}", "+\t\tif (pkgSource != null) {", "+\t\t\tpkgSource.getResource().setReadOnly(false);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ef540c373db419a22e0eb72691fb99dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "8b61d97704a2b67ed3d29404b8692bdbf30b8b5d", "commitAfterChange": "7fa6d6b6f60d0d2345e743063241c3eb3452b00f", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 47, "signatureBeforeChange": "  public SearchMatch newDeclarationMatch( \t\tIJavaElement element, \t\tint accuracy, \t\tint offset,   \t\tint length, \t\tSearchParticipant participant,  \t\tIResource resource)", "signatureAfterChange": "  public SearchMatch newDeclarationMatch( \t\tIJavaElement element, \t\tBinding binding, \t\tint accuracy, \t\tint offset,   \t\tint length, \t\tSearchParticipant participant,  \t\tIResource resource)", "diff": ["+\t\tBinding binding,", "-\t\t\treturn new TypeDeclarationMatch(element, accuracy, offset, length, participant, resource);", "+\t\t\treturn new TypeDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);", "-\t\t\treturn new FieldDeclarationMatch(element, accuracy, offset, length, participant, resource);", "+\t\t\treturn new FieldDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);", "-\t\t\treturn new MethodDeclarationMatch(element, accuracy, offset, length, participant, resource);", "+\t\t\treturn new MethodDeclarationMatch(binding == null ? element : ((JavaElement) element).resolved(binding), accuracy, offset, length, participant, resource);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f637de9eb7fc4e15f9972fcb1c8ae556", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java", "commitBeforeChange": "1a94a1e6652f1701b8c360d56d755e5438b79c26", "commitAfterChange": "3b002cab97d2ee77b59be67feaf705de255bc1fb", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " static Classpath getClasspath(String classpathName, String encoding, boolean isSourceOnly, AccessRuleSet accessRuleSet)", "signatureAfterChange": " static Classpath getClasspath(String classpathName, String encoding,  \t\tboolean isSourceOnly, AccessRuleSet accessRuleSet,  \t\tString destinationPath)", "diff": ["-static Classpath getClasspath(String classpathName, String encoding, boolean isSourceOnly, AccessRuleSet accessRuleSet) {", "+static Classpath getClasspath(String classpathName, String encoding, ", "+\t\tboolean isSourceOnly, AccessRuleSet accessRuleSet, ", "+\t\tString destinationPath) {", "-\t\t\tresult = new ClasspathDirectory(file, encoding, isSourceOnly ? ClasspathLocation.SOURCE : ClasspathLocation.SOURCE | ClasspathLocation.BINARY, accessRuleSet);", "+\t\t\tresult = new ClasspathDirectory(file, encoding, ", "+\t\t\t\t\tisSourceOnly ? ClasspathLocation.SOURCE : ", "+\t\t\t\t\t\tClasspathLocation.SOURCE | ClasspathLocation.BINARY, ", "+\t\t\t\t\taccessRuleSet,", "+\t\t\t\t\tdestinationPath == null || destinationPath == Main.NONE ?", "+\t\t\t\t\t\tdestinationPath : // keep == comparison valid", "+\t\t\t\t\t\tconvertPathSeparators(destinationPath));", "-\t} else {", "+\t} else { ", "-\t\t\t\tresult = new ClasspathSourceJar(file, true, accessRuleSet, encoding);\t\t\t", "+\t\t\t\tresult = new ClasspathSourceJar(file, true, accessRuleSet, ", "+\t\t\t\t\tencoding, ", "+\t\t\t\t\tdestinationPath == null || destinationPath == Main.NONE ?", "+\t\t\t\t\t\tdestinationPath : // keep == comparison valid", "+\t\t\t\t\t\tconvertPathSeparators(destinationPath));", "-\t\t\t\tresult = new ClasspathJar(file, true, accessRuleSet);", "+\t\t\t\tif (destinationPath != null) {", "+\t\t\t\t\tresult = null; // [-d dir] not allowed for binaries only jar", "+\t\t\t\t} else {", "+\t\t\t\t\tresult = new ClasspathJar(file, true, accessRuleSet, null);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc4e1b8f99a401f8b635e81a66c3114b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalFoldersManager.java", "commitBeforeChange": "69c59f0267102692d57da5d57d379c16633b234c", "commitAfterChange": "a7da40a1a62439fc4b1ece4f5221022e1778c205", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 19, "signatureBeforeChange": " \t\t\t\tprotected IStatus run(IProgressMonitor pm)", "signatureAfterChange": " \t\t \t\tprotected IStatus run(IProgressMonitor pm)", "diff": ["-\t\t\t\t}", "-\t\t\t\tprotected IStatus run(IProgressMonitor pm) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\t\t\tIPath externalPath = (IPath) iterator.next();", "-\t\t\t\t\t\t\tIFolder folder = getFolder(externalPath);", "-\t\t\t\t\t\t\tif (folder != null)", "-\t\t\t\t\t\t\t\tfolder.refreshLocal(IResource.DEPTH_INFINITE, pm);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\t\treturn e.getStatus();", "-\t\t\t\t\t}", "-\t\t\t\t\treturn Status.OK_STATUS;", "-\t\t\t\t}", "+\t\t", "+\t\tprotected IStatus run(IProgressMonitor pm) {", "+\t\t\ttry {", "+\t\t\t\twhile (this.externalFolders.hasNext()) {", "+\t\t\t\t\tIPath externalPath = (IPath) this.externalFolders.next();", "+\t\t\t\t\tIFolder folder = getFolder(externalPath);", "+\t\t\t\t\tif (folder != null) {", "+\t\t\t\t\t\tfolder.refreshLocal(IResource.DEPTH_INFINITE, pm);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\treturn e.getStatus();", "+\t\t\t}", "+\t\t\treturn Status.OK_STATUS;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fec66f5586536cd2da0bf32c69abefbc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "8022992d2babd233cd628feec0fce3d9f7562016", "commitAfterChange": "6bea0f6636d15fbdebc7403f71192f16cc7a0c9c", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " void checkTypeVariableMethods()", "signatureAfterChange": " void checkTypeVariableMethods()", "diff": ["-\t\t\tif (index > 0)", "-\t\t\t\tcheckInheritedMethods(matchingInherited, index + 1); // pass in the length of matching", "+\t\t\tif (index > 0) {", "+\t\t\t\tMethodBinding first = matchingInherited[0];", "+\t\t\t\tint count = index + 1;", "+\t\t\t\twhile (--count > 0 && areReturnTypesEqual(first, matchingInherited[count])){/*empty*/}", "+\t\t\t\tif (count > 0) {  // All inherited methods do NOT have the same vmSignature", "+\t\t\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, matchingInherited, index + 1);", "+\t\t\t\t\tcontinue nextSelector;", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 46336}