{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c23faff6cac77e97206546050743fd4b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07217eda3ef64729794a3e28b2ba0998", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["- */\r", "-protected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "-\tif (packageName == null)\r", "-\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\tIType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "-\tif (type == null) {\r", "-\t\t// look inside the compilation unit that is being searched currently\r", "-\t\t//for a non-public or inner type.\r", "-\t\tif (this.unitToLookInside != null) {\r", "-\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "-\t\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "-\t\t\t\t\t\t\ttype = allTypes[i];\r", "-\t\t\t\t\t\t\tbreak;\r", "+\t */\r", "+\tprotected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "+\t\tif (packageName == null)\r", "+\t\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\tIType type =\r", "+\t\t\tthis.nameLookup.findType(\r", "+\t\t\t\ttypeName,\r", "+\t\t\t\tpackageName,\r", "+\t\t\t\tfalse,\r", "+\t\t\t\tINameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "+\t\tif (type == null) {\r", "+\t\t\t// look inside the compilation unit that is being searched currently\r", "+\t\t\t//for a non-public or inner type.\r", "+\t\t\tif (this.unitToLookInside != null) {\r", "+\t\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "+\t\t\t\t\t\tfor (int i = 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "+\t\t\t\t\t\t\t\ttype = allTypes[i];\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t}\r", "-\tif (type != null) {\r", "-\t\tif (type instanceof BinaryType) {\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t} else { //SourceType\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "+\t\tif (type != null) {\r", "+\t\t\tif (type instanceof BinaryType) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(\r", "+\t\t\t\t\t\t(IBinaryType) ((BinaryType) type).getRawInfo());\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t} else { //SourceType\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// retrieve the requested type\r", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getRawInfo();\r", "+\t\t\t\t\tISourceType topLevelType = sourceType;\r", "+\t\t\t\t\twhile (topLevelType.getEnclosingType() != null) {\r", "+\t\t\t\t\t\ttopLevelType = topLevelType.getEnclosingType();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// find all siblings (other types declared in same unit, since may be used for name resolution)\r", "+\t\t\t\t\tIType[] types = sourceType.getHandle().getCompilationUnit().getTypes();\r", "+\t\t\t\t\tISourceType[] sourceTypes = new ISourceType[types.length];\r", "+\r", "+\t\t\t\t\t// in the resulting collection, ensure the requested type is the first one\r", "+\t\t\t\t\tsourceTypes[0] = sourceType;\r", "+\t\t\t\t\tfor (int i = 0, index = 1; i < types.length; i++) {\r", "+\t\t\t\t\t\tISourceType otherType =\r", "+\t\t\t\t\t\t\t(ISourceType) ((JavaElement) types[i]).getRawInfo();\r", "+\t\t\t\t\t\tif (!otherType.equals(topLevelType))\r", "+\t\t\t\t\t\t\tsourceTypes[index++] = otherType;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes);\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "-\t}\r", "-\treturn null;\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8355f19041c66bb3994fc051db663a9d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "dcdb11f13a905cc2d9eed5c3bf38034e243f753b", "commitAfterChange": "454e4bb996219ce871816b02f759355d9d6facb0", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r protected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": "\r \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["- */\r", "-protected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "-\tif (packageName == null)\r", "-\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "-\tIType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "-\tif (type == null) {\r", "-\t\t// look inside the compilation unit that is being searched currently\r", "-\t\t//for a non-public or inner type.\r", "-\t\tif (this.unitToLookInside != null) {\r", "-\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "-\t\t\t\t\tfor (int i= 0; i < allTypes.length; i++) {\r", "-\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "-\t\t\t\t\t\t\ttype = allTypes[i];\r", "-\t\t\t\t\t\t\tbreak;\r", "+\t */\r", "+\tprotected NameEnvironmentAnswer find(String typeName, String packageName) {\r", "+\t\tif (packageName == null)\r", "+\t\t\tpackageName = IPackageFragment.DEFAULT_PACKAGE_NAME;\r", "+\t\tIType type =\r", "+\t\t\tthis.nameLookup.findType(\r", "+\t\t\t\ttypeName,\r", "+\t\t\t\tpackageName,\r", "+\t\t\t\tfalse,\r", "+\t\t\t\tINameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);\r", "+\t\tif (type == null) {\r", "+\t\t\t// look inside the compilation unit that is being searched currently\r", "+\t\t\t//for a non-public or inner type.\r", "+\t\t\tif (this.unitToLookInside != null) {\r", "+\t\t\t\tif (this.unitToLookInside.getParent().getElementName().equals(packageName)) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIType[] allTypes = this.unitToLookInside.getTypes();\r", "+\t\t\t\t\t\tfor (int i = 0; i < allTypes.length; i++) {\r", "+\t\t\t\t\t\t\tif (allTypes[i].getElementName().equals(typeName)) {\r", "+\t\t\t\t\t\t\t\ttype = allTypes[i];\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t}\r", "-\tif (type != null) {\r", "-\t\tif (type instanceof BinaryType) {\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "-\t\t\t}\r", "-\t\t} else { //SourceType\r", "-\t\t\ttry {\r", "-\t\t\t\treturn new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());\r", "-\t\t\t} catch (JavaModelException npe) {\r", "-\t\t\t\treturn null;\r", "+\t\tif (type != null) {\r", "+\t\t\tif (type instanceof BinaryType) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(\r", "+\t\t\t\t\t\t(IBinaryType) ((BinaryType) type).getRawInfo());\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "+\t\t\t} else { //SourceType\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// retrieve the requested type\r", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getRawInfo();\r", "+\r", "+\t\t\t\t\t// find all siblings (other types declared in same unit, since may be used for name resolution)\r", "+\t\t\t\t\tIType[] types = sourceType.getHandle().getCompilationUnit().getTypes();\r", "+\t\t\t\t\tISourceType[] sourceTypes = new ISourceType[types.length];\r", "+\r", "+\t\t\t\t\t// in the resulting collection, ensure the requested type is the first one\r", "+\t\t\t\t\tsourceTypes[0] = sourceType;\r", "+\t\t\t\t\tfor (int i = 0, index = 1; i < types.length; i++) {\r", "+\t\t\t\t\t\tISourceType otherType =\r", "+\t\t\t\t\t\t\t(ISourceType) ((JavaElement) types[i]).getRawInfo();\r", "+\t\t\t\t\t\tif (!otherType.equals(sourceType))\r", "+\t\t\t\t\t\t\tsourceTypes[index++] = otherType;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes);\r", "+\t\t\t\t} catch (JavaModelException npe) {\r", "+\t\t\t\t\treturn null;\r", "+\t\t\t\t}\r", "-\t}\r", "-\treturn null;\r", "-}\r"]}], "num": 69664}