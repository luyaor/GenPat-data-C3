{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db6365e78c91040ec4767964d411378a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44671be381841d966b5156e55f45234e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java", "commitBeforeChange": "1af26d01cfd72849d8c290dd25ccb7fc62852780", "commitAfterChange": "72895982cdfd43c6e856c9e0af3d1d64cc3e0181", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void attachSource(IPath zipPath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException", "diff": ["-public void attachSource(IPath zipPath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException {", "-\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES, this));", "+public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException {", "+\ttry {", "+\t\tverifyAttachSource(sourcePath);", "+\t\tif (monitor != null) {", "+\t\t\tmonitor.beginTask(Util.bind(\"element.attachingSource\"), 2); //$NON-NLS-1$", "+\t\t}", "+\t\tSourceMapper mapper= null;", "+\t\tSourceMapper oldMapper= getSourceMapper();", "+\t\tIWorkspace workspace= getJavaModel().getWorkspace();", "+\t\tboolean rootNeedsToBeClosed= false;", "+", "+\t\tif (sourcePath == null) {", "+\t\t\t//source being detached", "+\t\t\trootNeedsToBeClosed= true;", "+\t\t/* Disable deltas (see 1GDTUSD)", "+\t\t\t// fire a delta to notify the UI about the source detachement.", "+\t\t\tJavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();", "+\t\t\tJavaModel model = (JavaModel) getJavaModel();", "+\t\t\tJavaElementDelta attachedSourceDelta = new JavaElementDelta(model);", "+\t\t\tattachedSourceDelta .sourceDetached(this); // this would be a PackageFragmentRoot", "+\t\t\tmanager.registerResourceDelta(attachedSourceDelta );", "+\t\t\tmanager.fire(); // maybe you want to fire the change later. Let us know about it.", "+\t\t*/", "+\t\t} else {", "+\t\t/*", "+\t\t\t// fire a delta to notify the UI about the source attachement.", "+\t\t\tJavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();", "+\t\t\tJavaModel model = (JavaModel) getJavaModel();", "+\t\t\tJavaElementDelta attachedSourceDelta = new JavaElementDelta(model);", "+\t\t\tattachedSourceDelta .sourceAttached(this); // this would be a PackageFragmentRoot", "+\t\t\tmanager.registerResourceDelta(attachedSourceDelta );", "+\t\t\tmanager.fire(); // maybe you want to fire the change later. Let us know about it.", "+\t\t */", "+", "+\t\t\t//check if different from the current attachment", "+\t\t\tIPath storedSourcePath= getSourceAttachmentPath();", "+\t\t\tIPath storedRootPath= getSourceAttachmentRootPath();", "+\t\t\tif (monitor != null) {", "+\t\t\t\tmonitor.worked(1);", "+\t\t\t}", "+\t\t\tif (storedSourcePath != null) {", "+\t\t\t\tif (!(storedSourcePath.equals(sourcePath) && rootPath.equals(storedRootPath))) {", "+\t\t\t\t\trootNeedsToBeClosed= true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// check if source path is valid", "+\t\t\tObject target = JavaModel.getTarget(workspace.getRoot(), sourcePath, false);", "+\t\t\tif (target == null) {", "+\t\t\t\tif (monitor != null) {", "+\t\t\t\t\tmonitor.done();", "+\t\t\t\t}", "+\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, sourcePath));", "+\t\t\t}", "+\t\t\tmapper= new SourceMapper(", "+\t\t\t\tsourcePath, ", "+\t\t\t\trootPath.toOSString(), ", "+\t\t\t\tthis.isExternal() ? JavaCore.getOptions() : this.getJavaProject().getOptions(true)); // only project options if associated with resource", "+\t\t}", "+\t\tsetSourceMapper(mapper);", "+\t\tif (sourcePath == null) {", "+\t\t\tsetSourceAttachmentProperty(null); //remove the property", "+\t\t} else {", "+\t\t\t//set the property to the path of the mapped source", "+\t\t\tsetSourceAttachmentProperty(sourcePath.toString() + ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString());", "+\t\t}", "+\t\tif (rootNeedsToBeClosed) {", "+\t\t\tif (oldMapper != null) {", "+\t\t\t\toldMapper.close();", "+\t\t\t}", "+\t\t\tBufferManager manager= BufferManager.getDefaultBufferManager();", "+\t\t\tEnumeration openBuffers= manager.getOpenBuffers();", "+\t\t\twhile (openBuffers.hasMoreElements()) {", "+\t\t\t\tIBuffer buffer= (IBuffer) openBuffers.nextElement();", "+\t\t\t\tIOpenable possibleMember= buffer.getOwner();", "+\t\t\t\tif (isAncestorOf((IJavaElement) possibleMember)) {", "+\t\t\t\t\tbuffer.close();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (monitor != null) {", "+\t\t\t\tmonitor.worked(1);", "+\t\t\t}", "+\t\t}", "+\t} catch (JavaModelException e) {", "+\t\tsetSourceAttachmentProperty(null); // loose info - will be recomputed", "+\t\tthrow e;", "+\t} finally {", "+\t\tif (monitor != null) {", "+\t\t\tmonitor.done();", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "85f7dfcb3b843bb04b7181883bbc1845", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java", "commitBeforeChange": "c55e27c5f4006c1661c0244de499b795ab7c7b74", "commitAfterChange": "60ae573720ab8958f2d1c67e0742d44a98afc95c", "methodNumberBeforeChange": 613, "methodNumberAfterChange": 613, "signatureBeforeChange": " public void testBug286379c() throws CoreException", "signatureAfterChange": " public void testBug286379c() throws CoreException", "diff": ["+\tclass TestResourceChangeListener implements IResourceChangeListener {", "+\t\tboolean valid = false;", "+\t\tpublic void resourceChanged(IResourceChangeEvent event) {", "+\t\t\tSystem.out.println(\"ResourceChangeEvent event:\");", "+\t\t\tSystem.out.println(\"\t- event type: \"+event.getType());", "+\t\t\tSystem.out.println(\"\t- resource: \"+event.getResource());", "+\t\t\tthis.valid = true;", "+\t\t}", "+\t}", "+", "+\tTestResourceChangeListener changeListener = new TestResourceChangeListener();", "-\t\t// Create resource and wait for the refresh as we do not want the", "-\t\t// indexing to be triggered by the resource change event after the", "-\t\t// Java Source content type will be added", "-\t\tIJavaProject proj = createJavaProject(\"P\");", "-\t\tIPath projPath = proj.getPath();", "+\t\t// Create resource", "+\t\tcreateJavaProject(\"P\");", "-\t\trefresh(proj);", "-\t\t// Wait to be sure that indexes are ready as we want to see whether", "-\t\t// they'll be updated or not while adding a Java Source content type", "+\t\t// Wait to be sure that indexes are ready after the resource creation", "-\t\t", "+", "+\t\t// Add the resource listener", "+\t\tgetWorkspace().addResourceChangeListener(changeListener, IResourceChangeEvent.POST_CHANGE);", "+", "+\t\t// Change the file extension", "+\t\t", "+\t\t// Wait for all the resource event before continuing", "+\t\t// Note that if we are not waiting for this event occurring then the search may", "+\t\t// fail as we don't get any specific event from the platform to refresh the indexes.", "+\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=118619", "+\t\tint counter = 0;", "+\t\twhile (!changeListener.valid) {", "+\t\t\ttry {", "+\t\t\t\tThread.sleep(100);", "+\t\t\t}", "+\t\t\tcatch (InterruptedException ie) {", "+\t\t\t\t// skip", "+\t\t\t}", "+\t\t\tassertTrue(\"We should have got a resource event within a 10s delay!\", counter++ < 100);", "+\t\t}", "+", "+\t\t// Search for the new type with new extension", "-\t\t// Actually it would be great if we could get the file in the search result, ", "-\t\t// but currently this doesn't happen as we don't get the appropriate delta", "-\t\t// events from the platform. We should change the test if this is fixed.", "-\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=118619", "-\t\tassertSearchResults(\"No search results expected\", \"\", collector, false /*do not fail if not equals (debug bug 293697)*/);", "+\t\tassertSearchResults(\"Unexpected search results!\",", "+\t\t\t\"Xtorem (not open) [in Xtorem.torem [in p [in <project root> [in P]]]]\",", "+\t\t\tcollector);", "-\t\t// Restarting should make the search to succeed. ", "+\t\t// Delete the file specification", "+\t\tjavaContentType.removeFileSpec(\"torem\", IContentType.FILE_EXTENSION_SPEC);", "+\t\t", "+\t\t// Restarting should update the index file to remove the references of any .torem files", "+\t\twaitUntilIndexesReady();", "+", "+\t\t// Search for the new type with new extension", "-\t\tString expected = \"Xtorem (not open) [in Xtorem.torem [in p [in <project root> [in P]]]]\";", "-\t\tassertSearchResults(expected, collector);", "-\t\tjavaContentType.removeFileSpec(\"torem\", IContentType.FILE_EXTENSION_SPEC);", "-\t\t", "-\t\t// Get the time stamp of the index file", "-\t\tIndexManager manager = JavaModelManager.getIndexManager();", "-\t\tIndex index = manager.getIndex(projPath, true, false);", "-\t\tFile indexFile = index.getIndexFile();", "-\t\tlong lastModified = indexFile.lastModified();", "-\t\t", "-\t\t// Restarting should update the index file to remove the references of any .torem files", "-\t\tsimulateExit();\t\t", "-\t\ttry {", "-\t\t\tThread.sleep(1500); // wait more than one second to be sure that modified time will be different", "-\t\t}", "-\t\tcatch (InterruptedException ie) {", "-\t\t\t// skip", "-\t\t}", "-\t\tsimulateRestart();\t\t", "-\t\t", "-\t\twaitUntilIndexesReady();", "-\t\tIndex newIndex = manager.getIndex(projPath , true, false);", "-\t\tassertTrue(\"Index file should be changed!!!\", newIndex.getIndexFile().lastModified() - lastModified != 0);", "-\t\t", "+\t\tassertSearchResults(\"No search results expected\", \"\", collector);", "+\t\tgetWorkspace().removeResourceChangeListener(changeListener);"]}], "num": 72386}