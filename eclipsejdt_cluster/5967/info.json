{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9096ef9bfab99a1901693c205e124432", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c7f25e0ac7ce52e24e75d50f0f6de6b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java", "commitBeforeChange": "1bd28947ec61a68bcbaa48e5f62a38f1082dad74", "commitAfterChange": "158f15ed7305b84f608a44b2b3e60c3a50fa4c1b", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode)", "signatureAfterChange": " \tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode)", "diff": ["-\tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode) {", "+\tpublic static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode) {", "+\t\t\tif (requiredType instanceof TypeVariableBinding && substitution != null && (mode == CheckMode.EXACT || mode == CheckMode.COMPATIBLE)) {", "+\t\t\t\trequiredType.exitRecursiveFunction();", "+\t\t\t\trequiredType = Scope.substitute(substitution, requiredType);", "+\t\t\t\tif (!requiredType.enterRecursiveFunction())", "+\t\t\t\t\treturn NullAnnotationMatching.NULL_ANNOTATIONS_OK;", "+\t\t\t}", "-\t\t\t\t// during bound check against a type variable check the provided type against all upper bounds:", "-\t\t\t\tTypeBinding superClass = requiredType.superclass();", "-\t\t\t\tif (superClass != null && superClass.hasNullTypeAnnotations()) {", "-\t\t\t\t\tNullAnnotationMatching status = analyse(superClass, providedType, null, nullStatus, mode);", "-\t\t\t\t\tseverity = Math.max(severity, status.severity);", "-\t\t\t\t\tif (severity == 2)", "-\t\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);", "-\t\t\t\t}", "-\t\t\t\tTypeBinding[] superInterfaces = requiredType.superInterfaces();", "-\t\t\t\tif (superInterfaces != null) {", "-\t\t\t\t\tfor (int i = 0; i < superInterfaces.length; i++) {", "-\t\t\t\t\t\tif (superInterfaces[i].hasNullTypeAnnotations()) {", "-\t\t\t\t\t\t\tNullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, nullStatus, mode);", "-\t\t\t\t\t\t\tseverity = Math.max(severity, status.severity);", "-\t\t\t\t\t\t\tif (severity == 2)", "-\t\t\t\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);\t\t\t\t\t\t", "+\t\t\t\tboolean passedBoundCheck = (substitution instanceof ParameterizedTypeBinding) && (((ParameterizedTypeBinding) substitution).tagBits & TagBits.PassedBoundCheck) != 0;", "+\t\t\t\tif (!passedBoundCheck) {", "+\t\t\t\t\t// during bound check against a type variable check the provided type against all upper bounds:", "+\t\t\t\t\tTypeBinding superClass = requiredType.superclass();", "+\t\t\t\t\tif (superClass != null && (superClass.hasNullTypeAnnotations() || substitution != null)) { // annotations may enter when substituting a nested type variable", "+\t\t\t\t\t\tNullAnnotationMatching status = analyse(superClass, providedType, null, substitution, nullStatus, CheckMode.COMPATIBLE);", "+\t\t\t\t\t\tseverity = Math.max(severity, status.severity);", "+\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);", "+\t\t\t\t\t}", "+\t\t\t\t\tTypeBinding[] superInterfaces = requiredType.superInterfaces();", "+\t\t\t\t\tif (superInterfaces != null) {", "+\t\t\t\t\t\tfor (int i = 0; i < superInterfaces.length; i++) {", "+\t\t\t\t\t\t\tif (superInterfaces[i].hasNullTypeAnnotations() || substitution != null) { // annotations may enter when substituting a nested type variable", "+\t\t\t\t\t\t\t\tNullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, substitution, nullStatus, CheckMode.COMPATIBLE);", "+\t\t\t\t\t\t\t\tseverity = Math.max(severity, status.severity);", "+\t\t\t\t\t\t\t\tif (severity == 2)", "+\t\t\t\t\t\t\t\t\treturn new NullAnnotationMatching(severity, nullStatus, superTypeHint);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1));", "+\t\t\t\t\t\t\tseverity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));", "-\t\t\t\t\tint s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1);", "+\t\t\t\t\tint s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode, requiredType.isTypeVariable());", "-\t\t\t\t\t\t\t\tNullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], providedArgSubstitute, -1, mode);", "+\t\t\t\t\t\t\t\tNullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], providedArgSubstitute, substitution, -1, mode.toDetail());", "-\t\t\t\t\t\tNullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, providedEnclSubstitute, -1, mode);", "+\t\t\t\t\t\tNullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, providedEnclSubstitute, substitution, -1, mode);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ba047fb69a14ac49f9e0f888403f8d0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "3c8db8654fc8e2927c75863ec1232c9bc3800c9b", "commitAfterChange": "533660d1560f1a7aff4c5ccabdcd0cb35c0194c1", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "  \tpublic static void checkContainerAnnotationType(ASTNode culpritNode, BlockScope scope, ReferenceBinding containerAnnotationType, ReferenceBinding repeatableAnnotationType, boolean useSite)", "signatureAfterChange": "  \tpublic static void checkContainerAnnotationType(ASTNode culpritNode, BlockScope scope, ReferenceBinding containerAnnotationType, ReferenceBinding repeatableAnnotationType, boolean useSite)", "diff": ["-\t\t\t\tscope.problemReporter().containingAnnotationHasWrongValueType(culpritNode, containerAnnotationType, repeatableAnnotationType, method.returnType);", "+\t\t\t\tscope.problemReporter().containerAnnotationTypeHasWrongValueType(culpritNode, containerAnnotationType, repeatableAnnotationType, method.returnType);", "-\t\t\t\t\tscope.problemReporter().containingAnnotationHasNonDefaultMembers(culpritNode, containerAnnotationType, method.selector);", "+\t\t\t\t\tscope.problemReporter().containerAnnotationTypeHasNonDefaultMembers(culpritNode, containerAnnotationType, method.selector);", "-\t\t\tscope.problemReporter().containingAnnotationMustHaveValue(culpritNode, containerAnnotationType);", "+\t\t\tscope.problemReporter().containerAnnotationTypeMustHaveValue(culpritNode, containerAnnotationType);", "-\t\t", "-\t\tcheckContainingAnnotationRetention(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "-\t\t", "+", "-\t\tcheckContaintAnnotationDocumented(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "-\t\tcheckContaintAnnotationInherited(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "+\t\tlong annotationTypeBits = getAnnotationRetention(repeatableAnnotationType);", "+\t\tlong containerTypeBits = getAnnotationRetention(containerAnnotationType); ", "+\t\t// Due to clever layout of the bits, we can compare the absolute value directly", "+\t\tif (containerTypeBits < annotationTypeBits) {", "+\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\tscope.problemReporter().containerAnnotationTypeHasShorterRetention(culpritNode, repeatableAnnotationType, getRetentionName(annotationTypeBits), containerAnnotationType, getRetentionName(containerTypeBits));", "+\t\t}", "+\t\t", "+\t\tif ((repeatableAnnotationType.getAnnotationTagBits() & TagBits.AnnotationDocumented) != 0 && (containerAnnotationType.getAnnotationTagBits() & TagBits.AnnotationDocumented) == 0) {", "+\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\tscope.problemReporter().repeatableAnnotationTypeIsDocumented(culpritNode, repeatableAnnotationType, containerAnnotationType);", "+\t\t}", "+\t\t", "+\t\tif ((repeatableAnnotationType.getAnnotationTagBits() & TagBits.AnnotationInherited) != 0 && (containerAnnotationType.getAnnotationTagBits() & TagBits.AnnotationInherited) == 0) {", "+\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\tscope.problemReporter().repeatableAnnotationTypeIsInherited(culpritNode, repeatableAnnotationType, containerAnnotationType);", "+\t\t}"]}], "num": 5967}