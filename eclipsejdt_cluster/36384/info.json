{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bd006f67af0c4b4981b1cdde7f048ec4", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f14b46f13f72ac802aac0cbb0491115", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "82d58f9af854b98a92f7d694d40ac1e84e13013c", "commitAfterChange": "6d114aac1fbfd4c23041534efbb02c24c883ba25", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void abstractMethodMustBeImplemented(SourceTypeBinding type, MethodBinding abstractMethod)", "signatureAfterChange": " public void abstractMethodMustBeImplemented(SourceTypeBinding type, MethodBinding abstractMethod)", "diff": ["-\tthis.handle(", "-\t\t// Must implement the inherited abstract method %1", "-\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "-\t\tIProblem.AbstractMethodMustBeImplemented,", "-\t\tnew String[] { ", "-\t\t        new String(abstractMethod.selector),", "-\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "-\t\t        new String(abstractMethod.declaringClass.readableName()), ", "-\t\t        new String(type.readableName()), ", "-\t\t},", "-\t\tnew String[] { ", "-\t\t        new String(abstractMethod.selector),", "-\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "-\t\t        new String(abstractMethod.declaringClass.shortReadableName()), ", "-\t\t        new String(type.shortReadableName()), ", "-\t\t},", "-\t\ttype.sourceStart(),", "-\t\ttype.sourceEnd());", "+\tif (type.isEnum() && type.isLocalType()) {", "+\t\tFieldBinding field = type.scope.enclosingMethodScope().initializedField;", "+\t\tFieldDeclaration decl = field.sourceField();", "+\t\tthis.handle(", "+\t\t\t// Must implement the inherited abstract method %1", "+\t\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "+\t\t\tIProblem.EnumConstantMustImplementAbstractMethod,", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "+\t\t\t        new String(decl.name), ", "+\t\t\t},", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "+\t\t\t        new String(decl.name), ", "+\t\t\t},", "+\t\t\tdecl.sourceStart(),", "+\t\t\tdecl.sourceEnd());", "+\t} else {", "+\t\tthis.handle(", "+\t\t\t// Must implement the inherited abstract method %1", "+\t\t\t// 8.4.3 - Every non-abstract subclass of an abstract type, A, must provide a concrete implementation of all of A's methods.", "+\t\t\tIProblem.AbstractMethodMustBeImplemented,", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, false), ", "+\t\t\t        new String(abstractMethod.declaringClass.readableName()), ", "+\t\t\t        new String(type.readableName()), ", "+\t\t\t},", "+\t\t\tnew String[] { ", "+\t\t\t        new String(abstractMethod.selector),", "+\t\t\t        typesAsString(abstractMethod.isVarargs(), abstractMethod.parameters, true), ", "+\t\t\t        new String(abstractMethod.declaringClass.shortReadableName()), ", "+\t\t\t        new String(type.shortReadableName()), ", "+\t\t\t},", "+\t\t\ttype.sourceStart(),", "+\t\t\ttype.sourceEnd());", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76bbca1421bd793cf017dc4713cd4f6d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "b21cadb5eae53d9f84dce9f073b5350a267b6ad6", "commitAfterChange": "09b5bcfabb25c2c9040a9d902d7f8e5151952519", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 320, "signatureBeforeChange": " public void castArgumentToVarargsMethod(MethodBinding method, InvocationSite location)", "signatureAfterChange": " public void varargsArgumentNeedCast(MethodBinding method, TypeBinding argumentType, InvocationSite location)", "diff": ["-public void castArgumentToVarargsMethod(MethodBinding method, InvocationSite location) {", "-\tTypeBinding lastParam = method.parameters[method.parameters.length-1];", "-\tif (method.isConstructor()) {", "-\t\tthis.handle(", "-\t\t\tIProblem.CastArgumentToVarargsConstructor,", "-\t\t\tnew String[] {new String(method.declaringClass.readableName()), typesAsString(method.isVarargs(), method.parameters, false), new String(lastParam.readableName())},", "-\t\t\tnew String[] {new String(method.declaringClass.shortReadableName()), typesAsString(method.isVarargs(), method.parameters, true), new String(lastParam.shortReadableName())},", "-\t\t\tlocation.sourceStart(),", "-\t\t\tlocation.sourceEnd());", "-\t} else {", "-\t\tthis.handle(", "-\t\t\tIProblem.CastArgumentToVarargsMethod,", "-\t\t\tnew String[] {new String(method.declaringClass.readableName()), new String(method.selector), typesAsString(method.isVarargs(), method.parameters, false), new String(lastParam.readableName())},", "-\t\t\tnew String[] {new String(method.declaringClass.shortReadableName()), new String(method.selector), typesAsString(method.isVarargs(), method.parameters, true), new String(lastParam.shortReadableName())},", "-\t\t\tlocation.sourceStart(),", "-\t\t\tlocation.sourceEnd());", "-\t}", "-}", "+public void varargsArgumentNeedCast(MethodBinding method, TypeBinding argumentType, InvocationSite location) {", "+\tTypeBinding lastParam = method.parameters[method.parameters.length-1];", "+\tif (method.isConstructor()) {", "+\t\tthis.handle(", "+\t\t\tIProblem.ConstructorVarargsArgumentNeedCast,", "+\t\t\tnew String[] {new String(argumentType.readableName()), new String(lastParam.readableName()), new String(method.declaringClass.readableName()), typesAsString(method.isVarargs(), method.parameters, false), },", "+\t\t\tnew String[] {new String(argumentType.shortReadableName()), new String(lastParam.shortReadableName()), new String(method.declaringClass.shortReadableName()), typesAsString(method.isVarargs(), method.parameters, true), },", "+\t\t\tlocation.sourceStart(),", "+\t\t\tlocation.sourceEnd());", "+\t} else {", "+\t\tthis.handle(", "+\t\t\tIProblem.MethodVarargsArgumentNeedCast,", "+\t\t\tnew String[] { new String(argumentType.readableName()), new String(lastParam.readableName()), new String(method.selector), typesAsString(method.isVarargs(), method.parameters, false), new String(method.declaringClass.readableName()), },", "+\t\t\tnew String[] { new String(argumentType.shortReadableName()), new String(lastParam.shortReadableName()), new String(method.selector), typesAsString(method.isVarargs(), method.parameters, true), new String(method.declaringClass.shortReadableName()), },", "+\t\t\tlocation.sourceStart(),", "+\t\t\tlocation.sourceEnd());", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbd7c42d6d9f74a7ef989b530c00ce9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "eb727711bfbefbe06ad25a796b42d61ffab45eca", "commitAfterChange": "c4ce580cb0d1d41b788a7611bd30d4cf0eba4f86", "methodNumberBeforeChange": 257, "methodNumberAfterChange": 297, "signatureBeforeChange": " public void unsafeWildcardInvocation(ASTNode location, TypeBinding receiverType, MethodBinding method, TypeBinding[] arguments)", "signatureAfterChange": " public void wildcardInvocation(ASTNode location, TypeBinding receiverType, MethodBinding method, TypeBinding[] arguments)", "diff": ["-}", "-public void unsafeWildcardInvocation(ASTNode location, TypeBinding receiverType, MethodBinding method, TypeBinding[] arguments) {", "-\tTypeBinding offendingArgument = null;", "-\tTypeBinding offendingParameter = null;", "-\tfor (int i = 0, length = method.parameters.length; i < length; i++) {", "-\t\tTypeBinding parameter = method.parameters[i];", "-\t\tif (parameter.isWildcard() && (((WildcardBinding) parameter).kind != Wildcard.SUPER)) {", "-\t\t\toffendingParameter = parameter;", "-\t\t\toffendingArgument = arguments[i];", "-\t\t\tbreak;", "-\t\t}", "-\t}", "-\t", "-    if (method.isConstructor()) {", "-\t\tthis.handle(", "-\t\t\tIProblem.WildcardConstructorInvocation,", "-\t\t\tnew String[] {", "-\t\t\t\tnew String(receiverType.sourceName()),", "-\t\t\t\tparametersAsString(method.parameters, false),", "-\t\t\t\tnew String(receiverType.readableName()),", "-\t\t\t\tparametersAsString(arguments, false),", "-\t\t\t\tnew String(offendingArgument.readableName()),", "-\t\t\t\tnew String(offendingParameter.readableName()),", "-\t\t\t }, ", "-\t\t\tnew String[] {", "-\t\t\t\tnew String(receiverType.sourceName()),", "-\t\t\t\tparametersAsString(method.parameters, true),", "-\t\t\t\tnew String(receiverType.shortReadableName()),", "-\t\t\t\tparametersAsString(arguments, true),", "-\t\t\t\tnew String(offendingArgument.shortReadableName()),", "-\t\t\t\tnew String(offendingParameter.shortReadableName()),", "-\t\t\t }, ", "-\t\t\tlocation.sourceStart,", "-\t\t\tlocation.sourceEnd);    ", "-    } else {", "-\t\tthis.handle(", "-\t\t\tIProblem.WildcardMethodInvocation,", "-\t\t\tnew String[] {", "-\t\t\t\tnew String(method.selector),", "-\t\t\t\tparametersAsString(method.parameters, false),", "-\t\t\t\tnew String(receiverType.readableName()),", "-\t\t\t\tparametersAsString(arguments, false),", "-\t\t\t\tnew String(offendingArgument.readableName()),", "-\t\t\t\tnew String(offendingParameter.readableName()),", "-\t\t\t }, ", "-\t\t\tnew String[] {", "-\t\t\t\tnew String(method.selector),", "-\t\t\t\tparametersAsString(method.parameters, true),", "-\t\t\t\tnew String(receiverType.shortReadableName()),", "-\t\t\t\tparametersAsString(arguments, true),", "-\t\t\t\tnew String(offendingArgument.shortReadableName()),", "-\t\t\t\tnew String(offendingParameter.shortReadableName()),", "-\t\t\t }, ", "-\t\t\tlocation.sourceStart,", "-\t\t\tlocation.sourceEnd);    ", "-    }", "-}", "+public void wildcardInvocation(ASTNode location, TypeBinding receiverType, MethodBinding method, TypeBinding[] arguments) {", "+\tTypeBinding offendingArgument = null;", "+\tTypeBinding offendingParameter = null;", "+\tfor (int i = 0, length = method.parameters.length; i < length; i++) {", "+\t\tTypeBinding parameter = method.parameters[i];", "+\t\tif (parameter.isWildcard() && (((WildcardBinding) parameter).kind != Wildcard.SUPER)) {", "+\t\t\toffendingParameter = parameter;", "+\t\t\toffendingArgument = arguments[i];", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\t", "+    if (method.isConstructor()) {", "+\t\tthis.handle(", "+\t\t\tIProblem.WildcardConstructorInvocation,", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(receiverType.sourceName()),", "+\t\t\t\tparametersAsString(method.parameters, false),", "+\t\t\t\tnew String(receiverType.readableName()),", "+\t\t\t\tparametersAsString(arguments, false),", "+\t\t\t\tnew String(offendingArgument.readableName()),", "+\t\t\t\tnew String(offendingParameter.readableName()),", "+\t\t\t }, ", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(receiverType.sourceName()),", "+\t\t\t\tparametersAsString(method.parameters, true),", "+\t\t\t\tnew String(receiverType.shortReadableName()),", "+\t\t\t\tparametersAsString(arguments, true),", "+\t\t\t\tnew String(offendingArgument.shortReadableName()),", "+\t\t\t\tnew String(offendingParameter.shortReadableName()),", "+\t\t\t }, ", "+\t\t\tlocation.sourceStart,", "+\t\t\tlocation.sourceEnd);    ", "+    } else {", "+\t\tthis.handle(", "+\t\t\tIProblem.WildcardMethodInvocation,", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(method.selector),", "+\t\t\t\tparametersAsString(method.parameters, false),", "+\t\t\t\tnew String(receiverType.readableName()),", "+\t\t\t\tparametersAsString(arguments, false),", "+\t\t\t\tnew String(offendingArgument.readableName()),", "+\t\t\t\tnew String(offendingParameter.readableName()),", "+\t\t\t }, ", "+\t\t\tnew String[] {", "+\t\t\t\tnew String(method.selector),", "+\t\t\t\tparametersAsString(method.parameters, true),", "+\t\t\t\tnew String(receiverType.shortReadableName()),", "+\t\t\t\tparametersAsString(arguments, true),", "+\t\t\t\tnew String(offendingArgument.shortReadableName()),", "+\t\t\t\tnew String(offendingParameter.shortReadableName()),", "+\t\t\t }, ", "+\t\t\tlocation.sourceStart,", "+\t\t\tlocation.sourceEnd);    ", "+    }", "+}"]}], "num": 36384}