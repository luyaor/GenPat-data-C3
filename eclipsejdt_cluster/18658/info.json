{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9d6d10e585bc87dd6713f13c6555aef3", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1fd82efee4a205329158553dda79b746", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "5280e1e8db473b5a94d57033a6d3cab2e44e385d", "commitAfterChange": "2f280867bbcfaf415b943516836db7a4100ee4c3", "methodNumberBeforeChange": 87, "methodNumberAfterChange": 90, "signatureBeforeChange": "  protected void setPaths(ArrayList bootclasspaths, \t\tString sourcepathClasspathArg, \t\tArrayList sourcepathClasspaths, \t\tArrayList classpaths, \t\tArrayList extdirsClasspaths, \t\tArrayList endorsedDirClasspaths, \t\tString customEncoding) throws InvalidInputException", "signatureAfterChange": "  protected void setPaths(ArrayList bootclasspaths, \t\tString sourcepathClasspathArg, \t\tArrayList sourcepathClasspaths, \t\tArrayList classpaths, \t\tArrayList extdirsClasspaths, \t\tArrayList endorsedDirClasspaths, \t\tString customEncoding) throws InvalidInputException", "diff": ["-\tif (extdirsClasspaths == null) {", "-\t\textdirsClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);", "-\t\tString extdirsStr = System.getProperty(\"java.ext.dirs\"); //$NON-NLS-1$", "-\t\tif (extdirsStr == null) {", "-\t\t\tif (javaHome != null) {", "-\t\t\t\textdirsClasspaths.add(javaHome.getAbsolutePath() + \"/lib/ext\"); //$NON-NLS-1$", "-\t\t\t}", "-\t\t} else {", "-\t\t\tStringTokenizer tokenizer = new StringTokenizer(extdirsStr, File.pathSeparator);", "-\t\t\twhile (tokenizer.hasMoreTokens()) ", "-\t\t\t\textdirsClasspaths.add(tokenizer.nextToken());", "-\t\t}", "-\t}", "-\t", "-\t/*", "-\t * Feed extdirsClasspath with the entries found into the directories listed by", "-\t * extdirsNames.", "-\t */", "-\tif (extdirsClasspaths.size() != 0) {", "-\t\tFile[] directoriesToCheck = new File[extdirsClasspaths.size()];", "-\t\tfor (int i = 0; i < directoriesToCheck.length; i++) ", "-\t\t\tdirectoriesToCheck[i] = new File((String) extdirsClasspaths.get(i));", "-\t\textdirsClasspaths.clear();", "-\t\tFile[][] extdirsJars = getLibrariesFiles(directoriesToCheck);", "-\t\tif (extdirsJars != null) {", "-\t\t\tfor (int i = 0, max = extdirsJars.length; i < max; i++) {", "-\t\t\t\tFile[] current = extdirsJars[i];", "-\t\t\t\tif (current != null) {", "-\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\tFileSystem.Classpath classpath = ", "-\t\t\t\t\t\t\tFileSystem.getClasspath(", "-\t\t\t\t\t\t\t\t\tcurrent[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\tnull, null); ", "-\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\textdirsClasspaths.add(classpath);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t} else if (directoriesToCheck[i].isFile()) {", "-\t\t\t\t\tthis.logger.logIncorrectExtDirsEntry(directoriesToCheck[i].getAbsolutePath());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "+\textdirsClasspaths = handleExtdirs(extdirsClasspaths);", "-\t/*", "-\t * Feed endorsedDirClasspath according to:", "-\t * - -endorseddirs first if present;", "-\t * - else java.endorsed.dirs if defined;", "-\t * - else default extensions directory for the platform. (/lib/endorsed)", "-\t */", "-\tif (endorsedDirClasspaths == null) {", "-\t\tendorsedDirClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);", "-\t\tString endorsedDirsStr = System.getProperty(\"java.endorsed.dirs\"); //$NON-NLS-1$", "-\t\tif (endorsedDirsStr == null) {", "-\t\t\tif (javaHome != null) {", "-\t\t\t\tendorsedDirClasspaths.add(javaHome.getAbsolutePath() + \"/lib/endorsed\"); //$NON-NLS-1$", "-\t\t\t}", "-\t\t} else {", "-\t\t\tStringTokenizer tokenizer = new StringTokenizer(endorsedDirsStr, File.pathSeparator);", "-\t\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\t\tendorsedDirClasspaths.add(tokenizer.nextToken());", "-\t\t\t}", "-\t\t}", "-\t}", "-\t", "-\t/*", "-\t * Feed extdirsClasspath with the entries found into the directories listed by", "-\t * extdirsNames.", "-\t */", "-\tif (endorsedDirClasspaths.size() != 0) {", "-\t\tFile[] directoriesToCheck = new File[endorsedDirClasspaths.size()];", "-\t\tfor (int i = 0; i < directoriesToCheck.length; i++) ", "-\t\t\tdirectoriesToCheck[i] = new File((String) endorsedDirClasspaths.get(i));", "-\t\tendorsedDirClasspaths.clear();", "-\t\tFile[][] endorsedDirsJars = getLibrariesFiles(directoriesToCheck);", "-\t\tif (endorsedDirsJars != null) {", "-\t\t\tfor (int i = 0, max = endorsedDirsJars.length; i < max; i++) {", "-\t\t\t\tFile[] current = endorsedDirsJars[i];", "-\t\t\t\tif (current != null) {", "-\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\tFileSystem.Classpath classpath = ", "-\t\t\t\t\t\t\tFileSystem.getClasspath(", "-\t\t\t\t\t\t\t\t\tcurrent[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\tnull, null); ", "-\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\tendorsedDirClasspaths.add(classpath);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t} else if (directoriesToCheck[i].isFile()) {", "-\t\t\t\t\tthis.logger.logIncorrectEndorsedDirsEntry(directoriesToCheck[i].getAbsolutePath());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "+\tendorsedDirClasspaths = handleEndorseddirs(endorsedDirClasspaths);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b44bbd18004a8656808d0033f69b1162", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "8ff87d310a91c2a77c65ad68bb4b1fd94425fd85", "commitAfterChange": "dbf8a869161361178e399dd7e18a85b9a48bde74", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options)", "signatureAfterChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options)", "diff": ["-\t\tif (options == null) {", "-\t\t\toptions = JavaCore.getOptions();", "-\t\t}", "-\t\tASTConverter converter = new ASTConverter(options, false, null);", "-\t\tconverter.compilationUnitSource = source;", "-\t\tconverter.scanner.setSource(source);", "-\t\t", "-\t\tAST ast = new AST();", "-\t\tast.setBindingResolver(new BindingResolver());", "-\t\tconverter.setAST(ast);", "-\t\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "-\t\tCompilationUnit compilationUnit = ast.newCompilationUnit();", "-\t\tswitch(kind) {", "-\t\t\tcase K_STATEMENTS :", "-\t\t\t\tConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(source, offset, length, options, true);", "-\t\t\t\tRecordedParsingInformation recordedParsingInformation = codeSnippetParsingUtil.recordedParsingInformation;", "-\t\t\t\tint[][] comments = recordedParsingInformation.commentPositions;", "-\t\t\t\tif (comments != null) {", "-\t\t\t\t\tconverter.buildCommentsTable(compilationUnit, comments);", "-\t\t\t\t}", "-\t\t\t\tcompilationUnit.setLineEndTable(recordedParsingInformation.lineEnds);", "-\t\t\t\tif (constructorDeclaration != null) {", "-\t\t\t\t\tBlock block = ast.newBlock();", "-\t\t\t\t\tStatement[] statements = constructorDeclaration.statements;", "-\t\t\t\t\tif (statements != null) {", "-\t\t\t\t\t\tint statementsLength = statements.length;", "-\t\t\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "-\t\t\t\t\t\t\tblock.statements().add(converter.convert(statements[i]));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\trootNodeToCompilationUnit(ast, converter, compilationUnit, block, recordedParsingInformation);", "-\t\t\t\t\treturn block;", "-\t\t\t\t} else {", "-\t\t\t\t\tIProblem[] problems = recordedParsingInformation.problems;", "-\t\t\t\t\tif (problems != null) {", "-\t\t\t\t\t\tcompilationUnit.setProblems(problems);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn compilationUnit;", "-\t\t\t\t}", "-\t\t\tcase K_EXPRESSION :", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = codeSnippetParsingUtil.parseExpression(source, offset, length, options, true);", "-\t\t\t\trecordedParsingInformation = codeSnippetParsingUtil.recordedParsingInformation;", "-\t\t\t\tcomments = recordedParsingInformation.commentPositions;", "-\t\t\t\tif (comments != null) {", "-\t\t\t\t\tconverter.buildCommentsTable(compilationUnit, comments);", "-\t\t\t\t}", "-\t\t\t\tcompilationUnit.setLineEndTable(recordedParsingInformation.lineEnds);", "-\t\t\t\tif (expression != null) {", "-\t\t\t\t\tExpression expression2 = converter.convert(expression);", "-\t\t\t\t\trootNodeToCompilationUnit(ast, converter, compilationUnit, expression2, codeSnippetParsingUtil.recordedParsingInformation);", "-\t\t\t\t\treturn expression2;", "-\t\t\t\t} else {", "-\t\t\t\t\tIProblem[] problems = recordedParsingInformation.problems;", "-\t\t\t\t\tif (problems != null) {", "-\t\t\t\t\t\tcompilationUnit.setProblems(problems);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn compilationUnit;", "-\t\t\t\t}", "-\t\t\tcase K_CLASS_BODY_DECLARATIONS :", "-\t\t\t\tfinal org.eclipse.jdt.internal.compiler.ast.ASTNode[] nodes = codeSnippetParsingUtil.parseClassBodyDeclarations(source, offset, length, options, true);", "-\t\t\t\trecordedParsingInformation = codeSnippetParsingUtil.recordedParsingInformation;", "-\t\t\t\tcomments = recordedParsingInformation.commentPositions;", "-\t\t\t\tif (comments != null) {", "-\t\t\t\t\tconverter.buildCommentsTable(compilationUnit, comments);", "-\t\t\t\t}", "-\t\t\t\tcompilationUnit.setLineEndTable(recordedParsingInformation.lineEnds);", "-\t\t\t\tif (nodes != null) {", "-\t\t\t\t\tTypeDeclaration typeDeclaration = converter.convert(nodes);", "-\t\t\t\t\trootNodeToCompilationUnit(ast, converter, compilationUnit, typeDeclaration, codeSnippetParsingUtil.recordedParsingInformation);", "-\t\t\t\t\treturn typeDeclaration;", "-\t\t\t\t} else {", "-\t\t\t\t\tIProblem[] problems = recordedParsingInformation.problems;", "-\t\t\t\t\tif (problems != null) {", "-\t\t\t\t\t\tcompilationUnit.setProblems(problems);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn compilationUnit;", "-\t\t\t\t}", "-\t\t}", "-\t\tthrow new IllegalArgumentException();", "+\t\tASTParser c = ASTParser.internalNewParser2();", "+\t\tc.setKind(kind);", "+\t\tc.setSource(source);", "+\t\tc.setSourceRange(offset, length);", "+\t\tc.setCompilerOptions(options);", "+\t\treturn c.createAST(null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b58fe3dcb5d8f7b4d338e8c168f3db47", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "a667c05ed54e2e31a5fe871abdcae3c92be26c13", "commitAfterChange": "3ef2eccfdb5543a0ab32261d06183c857677e196", "methodNumberBeforeChange": 92, "methodNumberAfterChange": 94, "signatureBeforeChange": " protected void setPaths(ArrayList bootclasspaths, \t\tString sourcepathClasspathArg, \t\tArrayList sourcepathClasspaths, \t\tArrayList classpaths, \t\tArrayList extdirsClasspaths, \t\tArrayList endorsedDirClasspaths, \t\tString customEncoding) throws InvalidInputException", "signatureAfterChange": " protected void setPaths(ArrayList bootclasspaths, \t\tString sourcepathClasspathArg, \t\tArrayList sourcepathClasspaths, \t\tArrayList classpaths, \t\tArrayList extdirsClasspaths, \t\tArrayList endorsedDirClasspaths, \t\tString customEncoding) throws InvalidInputException", "diff": ["+\t", "- \tfinal File javaHome = getJavaHome();", "- \tfinal int bootclasspathsSize = bootclasspaths.size();", "-\tif (bootclasspathsSize != 0) {", "-\t\tString[] paths = new String[bootclasspathsSize];", "-\t\tbootclasspaths.toArray(paths);", "-\t\tbootclasspaths.clear();", "-\t\tfor (int i = 0; i < bootclasspathsSize; i++) {", "-\t\t\tprocessPathEntries(DEFAULT_SIZE_CLASSPATH, bootclasspaths, ", "-\t\t\t\tpaths[i], customEncoding, false, true);", "-\t\t}", "-\t} else {", "-\t\t/* no bootclasspath specified", "-\t\t * we can try to retrieve the default librairies of the VM used to run", "-\t\t * the batch compiler", "-\t\t */", "-\t\t String javaversion = System.getProperty(\"java.version\");//$NON-NLS-1$", "-\t\t if (javaversion != null && javaversion.equalsIgnoreCase(\"1.1.8\")) { //$NON-NLS-1$", "-\t\t\tthis.logger.logWrongJDK();", "-\t\t\tthis.proceed = false;", "-\t\t\treturn;", "-\t\t }", "+ \tbootclasspaths = handleBootclasspath(bootclasspaths, customEncoding);", "-\t \t/*", "-\t \t * Handle >= JDK 1.2.2 settings: retrieve rt.jar", "-\t \t */", "-\t \t if (javaHome != null) {", "-\t\t\tFile[] directoriesToCheck = null;", "-\t\t\tif (System.getProperty(\"os.name\").startsWith(\"Mac\")) {//$NON-NLS-1$//$NON-NLS-2$", "-\t\t\t\tdirectoriesToCheck = new File[] {", "-\t\t\t\t\tnew File(javaHome, \"../Classes\"), //$NON-NLS-1$", "-\t\t\t\t};", "-\t\t\t} else {", "-\t\t\t\tdirectoriesToCheck = new File[] { ", "-\t\t\t\t\tnew File(javaHome, \"lib\") //$NON-NLS-1$", "-\t\t\t\t};", "-\t\t\t}", "-\t\t\tFile[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);", "-\t\t\tif (systemLibrariesJars != null) {", "-\t\t\t\tfor (int i = 0, max = systemLibrariesJars.length; i < max; i++) {", "-\t\t\t\t\tFile[] current = systemLibrariesJars[i];", "-\t\t\t\t\tif (current != null) {", "-\t\t\t\t\t\tfor (int j = 0, max2 = current.length; j < max2; j++) {", "-\t\t\t\t\t\t\tFileSystem.Classpath classpath = ", "-\t\t\t\t\t\t\t\tFileSystem.getClasspath(current[j].getAbsolutePath(),", "-\t\t\t\t\t\t\t\t\tnull, false, null, null); ", "-\t\t\t\t\t\t\tif (classpath != null) {", "-\t\t\t\t\t\t\t\tbootclasspaths.add(classpath);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "- \t\t}", "-\t}", "-\tfinal int classpathsSize = classpaths.size();", "-\tif (classpaths.size() != 0) {", "-\t\tString[] paths = new String[classpathsSize];", "-\t\tclasspaths.toArray(paths);", "-\t\tclasspaths.clear();", "-\t\tfor (int i = 0; i < classpathsSize; i++) {", "-\t\t\tprocessPathEntries(DEFAULT_SIZE_CLASSPATH, classpaths, paths[i], ", "-\t\t\t\t\tcustomEncoding, false, true);", "-\t\t}\t\t\t", "-\t} else {", "-\t\t// no user classpath specified.", "-\t\tString classProp = System.getProperty(\"java.class.path\"); //$NON-NLS-1$", "-\t\tif ((classProp == null) || (classProp.length() == 0)) {", "-\t\t\tthis.logger.logNoClasspath();", "-\t\t\tclasspaths.add(FileSystem.getClasspath(System.getProperty(\"user.dir\"), customEncoding, null));//$NON-NLS-1$", "-\t\t} else {", "-\t\t\tStringTokenizer tokenizer = new StringTokenizer(classProp, File.pathSeparator);", "-\t\t\tString token;", "-\t\t\twhile (tokenizer.hasMoreTokens()) {", "-\t\t\t\ttoken = tokenizer.nextToken();", "-\t\t\t\tFileSystem.Classpath currentClasspath = FileSystem", "-\t\t\t\t\t\t.getClasspath(token, customEncoding, null);", "-\t\t\t\tif (currentClasspath != null) {", "-\t\t\t\t\tclasspaths.add(currentClasspath);", "-\t\t\t\t} else if (token.length() != 0) {", "-\t\t\t\t\tthis.logger.logIncorrectClasspath(token);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "+\tclasspaths = handleClasspath(classpaths, customEncoding);", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2c99604a89efc7fc2a87631c8a5e2ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java", "commitBeforeChange": "e6db618a9b62756ea5188d8fdad9bb0c157f5516", "commitAfterChange": "265fce71e12d88a397c49e9793a330fd01dcb78a", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "diff": ["-\t\treturn mapSource(mapper);", "-\t} else if (!this.checkAutomaticSourceMapping) {", "-\t\t/*", "-\t\t * We try to see if we can automatically attach a source", "-\t\t * source files located inside the same folder than its .class file", "-\t\t * See bug 36510.", "-\t\t */", "-\t\tPackageFragmentRoot root = getPackageFragmentRoot();", "-\t\tif (root.isArchive()) {", "-\t\t\t// root is a jar file or a zip file", "-\t\t\tString elementName = getElementName();", "-\t\t\tString sourceFileWithoutExtension = elementName.substring(0, elementName.lastIndexOf('.'));", "-\t\t\tJarPackageFragmentRoot jarPackageFragmentRoot = (JarPackageFragmentRoot) root;", "-\t\t\tZipFile jar = null;", "-\t\t\ttry {", "-\t\t\t\tjar = jarPackageFragmentRoot.getJar();", "-\t\t\t\tString[] pkgName = ((PackageFragment) getParent()).names;", "-\t\t\t\tchar[][] javaLikeExtensions = Util.getJavaLikeExtensions();", "-\t\t\t\tfor (int i = 0, length = javaLikeExtensions.length; i < length; i++) {", "-\t\t\t\t\tStringBuffer entryName = new StringBuffer();", "-\t\t\t\t\tfor (int j = 0, pkgNameLength = pkgName.length; j < pkgNameLength; j++) {", "-\t\t\t\t\t\tentryName.append(pkgName[j]);", "-\t\t\t\t\t\tentryName.append('/');", "-\t\t\t\t\t}", "-\t\t\t\t\tentryName.append(sourceFileWithoutExtension);", "-\t\t\t\t\tentryName.append('.');", "-\t\t\t\t\tentryName.append(javaLikeExtensions[i]);", "-\t\t\t\t\tZipEntry zipEntry = jar.getEntry(entryName.toString());", "-\t\t\t\t\tif (zipEntry != null) {", "-\t\t\t\t\t\t// found a source file", "-\t\t\t\t\t\tthis.checkAutomaticSourceMapping = true;", "-\t\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "-\t\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "-\t\t\t\t\t\tif (sourceMapper != null) {", "-\t\t\t\t\t\t\treturn mapSource(sourceMapper);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\tif (e instanceof JavaModelException) throw (JavaModelException)e;", "-\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t} finally {", "-\t\t\t\tJavaModelManager.getJavaModelManager().closeZipFile(jar);", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// Attempts to find the corresponding java file", "-\t\t\tString qualifiedName = getType().getFullyQualifiedName();", "-\t\t\tNameLookup lookup = ((JavaProject) getJavaProject()).newNameLookup(DefaultWorkingCopyOwner.PRIMARY);", "-\t\t\tICompilationUnit cu = lookup.findCompilationUnit(qualifiedName);", "-\t\t\tif (cu != null) {", "-\t\t\t\treturn cu.getBuffer();", "-\t\t\t} else\t{", "-\t\t\t\t// root is a class folder", "-\t\t\t\t", "-\t\t\t\tIContainer pkgFolder = (IContainer) getParent().getResource();", "-\t\t\t\tIResource[] files = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tfiles = pkgFolder.members();", "-\t\t\t\t} catch (CoreException e) {", "-\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\t}", "-\t\t\t\tIResource sourceFile = null;", "-\t\t\t\tString classFileName = getElementName();", "-\t\t\t\tString simpleName = classFileName.substring(0, classFileName.lastIndexOf('.'));", "-\t\t\t\tfor (int i = 0, length = files.length; i < length; i++) {", "-\t\t\t\t\tIResource resource = files[i];", "-\t\t\t\t\tif (resource.getType() == IResource.FILE ", "-\t\t\t\t\t\t\t&& Util.equalsIgnoreJavaLikeExtension(resource.getName(), simpleName)) {", "-\t\t\t\t\t\tsourceFile = resource;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (sourceFile != null) {", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t// found a source file", "-\t\t\t\t\t // we don't need to check again. The source will be attached.", "-\t\t\t\t\tthis.checkAutomaticSourceMapping = true;", "-\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "-\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "-\t\t\t\t\tif (sourceMapper != null) {", "-\t\t\t\t\t\treturn mapSource(sourceMapper);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t\treturn mapSource(mapper, info instanceof IBinaryType ? (IBinaryType) info : null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e481a65c3614de687d0fb0ad26a3e0b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic void analyseCode( \t\tClassScope classScope, \t\tInitializationFlowContext initializerFlowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo)", "diff": ["+ */", "+public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo) {", "+\tanalyseCode(classScope, initializerFlowContext, flowInfo, FlowInfo.REACHABLE);", "+}", "-\tpublic void analyseCode(", "-\t\tClassScope classScope,", "-\t\tInitializationFlowContext initializerFlowContext,", "-\t\tFlowInfo flowInfo) {", "-\t\tif (ignoreFurtherInvestigation)", "-\t\t\treturn;", "-", "-\t\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "-\t\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateConstructor(this);", "-\t\t\t", "-\t\t// check constructor recursion, once all constructor got resolved", "-\t\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "-\t\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "-\t\t\t", "-\t\ttry {", "-\t\t\tExceptionHandlingFlowContext constructorContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tinitializerFlowContext.parent,", "-\t\t\t\t\tthis,", "-\t\t\t\t\tbinding.thrownExceptions,", "-\t\t\t\t\tscope,", "-\t\t\t\t\tFlowInfo.DEAD_END);", "-\t\t\tinitializerFlowContext.checkInitializerExceptions(", "-\t\t\t\tscope,", "-\t\t\t\tconstructorContext,", "-\t\t\t\tflowInfo);", "-", "-\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "-\t\t\tif (binding.declaringClass.isAnonymousType()) {", "-\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "-\t\t\t\tif (computedExceptions != null){", "-\t\t\t\t\tint size;", "-\t\t\t\t\tif ((size = computedExceptions.size()) > 0){", "-\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "-\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "-\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// tag parameters as being set", "-\t\t\tif (this.arguments != null) {", "-\t\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "-\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// propagate to constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "-\t\t\t\t// set since they are supposed to be set inside other local constructor", "-\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {", "-\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\t\tFieldBinding field;", "-\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t}", "-\t\t\t// propagate to statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tboolean didAlreadyComplain = false;", "-\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {", "-\t\t\t\t\tStatement stat = statements[i];", "-\t\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, scope, didAlreadyComplain)) {", "-\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tdidAlreadyComplain = true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// check for missing returning path", "-\t\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-", "-", "-\t\t\t// check missing blank final field initializations", "-\t\t\tif ((constructorCall != null)", "-\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {", "-\t\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tif ((!(field = fields[i]).isStatic())", "-\t\t\t\t\t\t&& field.isFinal()", "-\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "-\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\t\tfield,", "-\t\t\t\t\t\t\tisDefaultConstructor ? (ASTNode) scope.referenceType() : this);", "-\t\t\t// check unreachable catch blocks", "-\t\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "-\t\t} catch (AbortMethod e) {", "-\t\t\tthis.ignoreFurtherInvestigation = true;", "-\t}"]}], "num": 18658}