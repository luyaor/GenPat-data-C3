{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "73c33394915c57feac3f967ce57afbf9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa7ff9b594770a969905502f22440761", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "4168404bef1be66fa92e39948727385e68af408c", "commitAfterChange": "641db1701cbce57a1e73a64de662de098370be6e", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method) \t\t\tthrows InferenceFailureException", "signatureAfterChange": " \tpublic BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method) \t\t\tthrows InferenceFailureException", "diff": ["-\t\t\tTypeBinding[] fs;", "-\t\t\tExpression[] arguments = this.invocationArguments;", "-\t\t\tif (arguments != null) {", "-\t\t\t\tint k = arguments.length;", "-\t\t\t\tint p = method.parameters.length;", "-\t\t\t\tif (k < (method.isVarargs() ? p-1 : p))", "-\t\t\t\t\treturn null; // insufficient arguments for parameters!", "-\t\t\t\tswitch (this.inferenceKind) {", "-\t\t\t\t\tcase CHECK_STRICT:", "-\t\t\t\t\tcase CHECK_LOOSE:", "-\t\t\t\t\t\tfs = method.parameters;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase CHECK_VARARG:", "-\t\t\t\t\t\tfs = varArgTypes(method.parameters, k);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tthrow new IllegalStateException(\"Unexpected checkKind \"+this.inferenceKind); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tfor (int i = 0; i < k; i++) {", "-\t\t\t\t\tTypeBinding fsi = fs[Math.min(i, p-1)];", "-\t\t\t\t\tTypeBinding substF = substitute(fsi);", "-\t\t\t\t\t// For all i (1 \u2264 i \u2264 k), if ei is not pertinent to applicability, the set contains \u27e8ei \u2192 \u03b8 Fi\u27e9.", "-\t\t\t\t\tExpression argument = arguments[i];", "-\t\t\t\t\tif (!argument.isPertinentToApplicability(fsi, method)) {", "-\t\t\t\t\t\tc.add(new ConstraintExpressionFormula(argument, substF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT));", "-\t\t\t\t\t}", "-\t\t\t\t\taddExceptionConstraint(c, argument, substF);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tif (!addConstraintsToC(this.invocationArguments, c, method))", "+\t\t\t\treturn null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b646928144de8e038f30e8ff231cc6c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "4168404bef1be66fa92e39948727385e68af408c", "commitAfterChange": "641db1701cbce57a1e73a64de662de098370be6e", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tprivate void addExceptionConstraint(Set<ConstraintFormula> c, Expression argument, TypeBinding substF)", "signatureAfterChange": "  \tprivate boolean addConstraintsToC(Expression[] exprs, Set<ConstraintFormula> c, MethodBinding method)", "diff": ["-\tprivate void addExceptionConstraint(Set<ConstraintFormula> c, Expression argument, TypeBinding substF) {", "-\t\tif (argument instanceof FunctionalExpression) {", "-\t\t\tc.add(new ConstraintExceptionFormula((FunctionalExpression) argument, substF));", "-\t\t} else if (argument instanceof ConditionalExpression) {", "-\t\t\tConditionalExpression ce = (ConditionalExpression) argument;", "-\t\t\taddExceptionConstraint(c, ce.valueIfTrue, substF);", "-\t\t\taddExceptionConstraint(c, ce.valueIfFalse, substF);", "+\tprivate boolean addConstraintsToC(Expression[] exprs, Set<ConstraintFormula> c, MethodBinding method) {", "+\t\tTypeBinding[] fs;", "+\t\tif (exprs != null) {", "+\t\t\tint k = exprs.length;", "+\t\t\tint p = method.parameters.length;", "+\t\t\tif (k < (method.isVarargs() ? p-1 : p))", "+\t\t\t\treturn false; // insufficient arguments for parameters!", "+\t\t\tswitch (this.inferenceKind) {", "+\t\t\t\tcase CHECK_STRICT:", "+\t\t\t\tcase CHECK_LOOSE:", "+\t\t\t\t\tfs = method.parameters;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase CHECK_VARARG:", "+\t\t\t\t\tfs = varArgTypes(method.parameters, k);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tthrow new IllegalStateException(\"Unexpected checkKind \"+this.inferenceKind); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < k; i++) {", "+\t\t\t\tTypeBinding fsi = fs[Math.min(i, p-1)];", "+\t\t\t\tTypeBinding substF = substitute(fsi);", "+\t\t\t\tif (!addConstraintsToC_OneExpr(exprs[i], c, fsi, substF, method))", "+\t\t\t\t\treturn false;", "+\t        }", "+\t\treturn true;", "+\t}"]}], "num": 12365}