{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ebb3425f3ea2fb52d7e47d7f2e1c407d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0625457e1f346f326503f0fdb2a0f90d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "0b724131f5f3cf2d018d63a77e76484f2fe8967f", "commitAfterChange": "7efd98740c0284fcb351af505635684db1a5006c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "signatureAfterChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "diff": ["-\t        \tif (equivalent == null || !equivalent.isParameterizedType())", "-\t        \t\treturn;", "+\t        \tif (equivalent == null) return;", "-\t        if (equivalent.isParameterizedType() && otherEquivalent.isParameterizedType()) {", "-\t        \tParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) equivalent;", "-\t        \tParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherEquivalent;", "-\t            for (int i = 0, length = parameterizedType.arguments.length; i < length; i++) {", "-\t                parameterizedType.arguments[i].collectSubstitutes(otherParameterizedType.arguments[i], substitutes);", "-\t            }", "-\t        } else if (equivalent.isParameterizedType() && otherEquivalent.isRawType()) {", "-\t        \tsubstitutes.clear(); // clear all variables to indicate raw generic method in the end", "+\t        TypeBinding[] elements;", "+\t        switch (equivalent.kind()) {", "+\t        \tcase Binding.GENERIC_TYPE :", "+\t        \t\telements = equivalent.typeVariables();", "+\t        \t\tbreak;", "+\t        \tcase Binding.PARAMETERIZED_TYPE :", "+\t        \t\telements = ((ParameterizedTypeBinding)equivalent).arguments;", "+\t        \t\tbreak;", "+\t        \tdefault :", "+\t        \t\treturn;", "+\t        }", "+\t        TypeBinding[] otherElements;", "+\t        switch (otherEquivalent.kind()) {", "+\t        \tcase Binding.GENERIC_TYPE :", "+\t        \t\totherElements = otherEquivalent.typeVariables();", "+\t        \t\tbreak;", "+\t        \tcase Binding.PARAMETERIZED_TYPE :", "+\t        \t\totherElements = ((ParameterizedTypeBinding)otherEquivalent).arguments;", "+\t        \t\tbreak;", "+\t        \tcase Binding.RAW_TYPE :", "+\t        \t\tsubstitutes.clear(); // clear all variables to indicate raw generic method in the end", "+\t        \t\treturn;", "+\t        \tdefault :", "+\t        \t\treturn;", "+\t        }", "+            for (int i = 0, length = elements.length; i < length; i++) {", "+                elements[i].collectSubstitutes(otherElements[i], substitutes);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c22b255eb807be72a6aaffba485034e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "dead6a3867ba962f651fba3cb95e7139a59158e3", "commitAfterChange": "2c262bb049c7c4afe17af25384f399520f404e78", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "signatureAfterChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "diff": ["+\t\t// only collect for method type parameters", "+\t\tif (!(this.declaringElement instanceof MethodBinding)) return;", "-\t        int length = variableSubstitutes.length;", "-\t        for (int i = 0; i < length; i++) {", "-\t        \tTypeBinding substitute = variableSubstitutes[i];", "-\t            if (substitute == otherType) return; // already there", "-\t            if (substitute == null) {", "-\t                variableSubstitutes[i] = otherType;", "-\t                return;", "-\t            }", "-\t        }", "-\t        // no free spot found, need to grow", "-\t        System.arraycopy(variableSubstitutes, 0, variableSubstitutes = new TypeBinding[2*length], 0, length);", "-\t        variableSubstitutes[length] = otherType;", "-\t        substitutes.put(this, variableSubstitutes);", "+\t\t    insertLoop: {", "+\t\t        int length = variableSubstitutes.length;", "+\t\t        for (int i = 0; i < length; i++) {", "+\t\t        \tTypeBinding substitute = variableSubstitutes[i];", "+\t\t            if (substitute == otherType) return; // already there", "+\t\t            if (substitute == null) {", "+\t\t                variableSubstitutes[i] = otherType;", "+\t\t                break insertLoop;", "+\t\t            }", "+\t\t        }", "+\t\t        // no free spot found, need to grow", "+\t\t        System.arraycopy(variableSubstitutes, 0, variableSubstitutes = new TypeBinding[2*length], 0, length);", "+\t\t        variableSubstitutes[length] = otherType;", "+\t\t        substitutes.put(this, variableSubstitutes);", "+\t\t    }", "+\t    // recurse in variable bounds (82187)", "+\t    if (this.superclass != null && this.firstBound == this.superclass) {", "+\t    \tthis.superclass.collectSubstitutes(otherType, substitutes);", "+\t    }", "+\t   \tfor (int i = 0, length = this.superInterfaces.length; i < length; i++) {", "+\t   \t\tthis.superInterfaces[i].collectSubstitutes(otherType, substitutes);", "+\t   \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5692e64dc91949a52f1bb75e78672a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["+\t\tInferenceContext inferenceContext = null;", "-\t\t\tInferenceContext inferenceContext = new InferenceContext(originalMethod);", "+\t\t\tinferenceContext = new InferenceContext(originalMethod);", "-\t\t// bounds check", "+\t\t/* bounds check: https://bugs.eclipse.org/bugs/show_bug.cgi?id=242159, Inferred types may contain self reference", "+\t\t   in formal bounds. If \"T extends I<T>\" is a original type variable and T was inferred to be I<T> due possibly", "+\t\t   to under constraints and resultant glb application per 15.12.2.8, using this.typeArguments to drive the bounds", "+\t\t   check against itself is doomed to fail. For, the variable T would after substitution be I<I<T>> and would fail", "+\t\t   bounds check against I<T>. Use the inferred types from the context directly - see that there is one round of", "+\t\t   extra substitution that has taken place to properly substitute a remaining unresolved variable which also appears", "+\t\t   in a formal bound  (So we really have a bounds mismatch between I<I<T>> and I<I<I<T>>>, in the absence of a fix.)", "+\t\t*/", "+\t\tSubstitution substitution = null;", "+\t\tif (inferenceContext != null) {", "+\t\t\tsubstitution = new LingeringTypeVariableEliminator(typeVariables, inferenceContext.substitutes, scope);", "+\t\t} else {", "+\t\t\tsubstitution = methodSubstitute;", "+\t\t}", "-\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i]; // retain for diagnostics", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t\tswitch (typeVariable.boundCheck(methodSubstitute, substitute)) {", "+\t\t\tswitch (typeVariable.boundCheck(substitution, substituteForChecks)) {"]}], "num": 44982}