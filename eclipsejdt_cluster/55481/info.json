{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6966c4fe54db7f62933c01f6e0d0e7c2", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "92395a20a8f44a100f4865366431b594", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public static void searchAllPossibleSubTypes( \tIType type, \tIJavaSearchScope scope, \tfinal Map binariesFromIndexMatches, \tfinal IPathRequestor pathRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)", "signatureAfterChange": "  public static void searchAllPossibleSubTypes( \tIType type, \tIJavaSearchScope scope, \tfinal Map binariesFromIndexMatches, \tfinal IPathRequestor pathRequestor, \tint waitingPolicy, \tIProgressMonitor progressMonitor)", "diff": ["-\tfinal Queue awaitings = new Queue();", "+\tfinal Queue queue = new Queue();", "-\t\t\t\tawaitings.add(typeName);", "+\t\t\t\tqueue.add(typeName);", "-\t", "+", "-\t", "-\t/* initialize entry result cache */", "-\tpattern.entryResults = new HashMap();", "-\t/* iterate all queued names */", "+", "-\tawaitings.add(type.getElementName().toCharArray());", "-\twhile (awaitings.start <= awaitings.end){", "-\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return;", "+\tqueue.add(type.getElementName().toCharArray());", "+\ttry {", "+\t\twhile (queue.start <= queue.end) {", "+\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) return;", "-\t\tchar[] currentTypeName = awaitings.retrieve();", "+\t\t\t// all subclasses of OBJECT are actually all types", "+\t\t\tchar[] currentTypeName = queue.retrieve();", "+\t\t\tif (CharOperation.equals(currentTypeName, IIndexConstants.OBJECT))", "+\t\t\t\tcurrentTypeName = null;", "-\t\t/* all subclasses of OBJECT are actually all types */", "-\t\tif (CharOperation.equals(currentTypeName, IIndexConstants.OBJECT)){", "-\t\t\tcurrentTypeName = null;", "-\t\t}\t\t\t", "-\t\t/* search all index references to a given supertype */", "-\t\tpattern.superSimpleName = currentTypeName;", "-\t\tindexManager.performConcurrentJob(", "-\t\t\tjob, ", "-\t\t\twaitingPolicy, ", "-\t\t\tnull); // don't pass a sub progress monitor as this is too costly for deep hierarchies", "-\t\tif (progressMonitor != null && ++ticks <= MAXTICKS) {", "-\t\t\tprogressMonitor.worked(1);", "+\t\t\t// search all index references to a given supertype", "+\t\t\tpattern.superSimpleName = currentTypeName;", "+\t\t\tindexManager.performConcurrentJob(job, waitingPolicy, null); // no sub progress monitor since its too costly for deep hierarchies", "+\t\t\tif (progressMonitor != null && ++ticks <= MAXTICKS)", "+\t\t\t\tprogressMonitor.worked(1);", "+", "+\t\t\t// in case, we search all subtypes, no need to search further", "+\t\t\tif (currentTypeName == null) break;", "-\t\t/* in case, we search all subtypes, no need to search further */", "-\t\tif (currentTypeName == null) break;", "+\t} finally {", "+\t\tjob.finished();", "-\t/* close all cached index inputs */", "-\tjob.closeAll();", "-\t/* flush entry result cache */", "-\tpattern.entryResults = null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d8ad0ff26269d2cc539568de2b8e616c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java", "commitBeforeChange": "14ba43da4ca84e6aa2e4b0e2b6c660335b90691e", "commitAfterChange": "b7f39314c9eefd05e7002c31c87dcdb0333c0655", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic final static boolean isArchiveFileName(String name)", "signatureAfterChange": " \tpublic final static boolean isPotentialZipArchive(String name)", "diff": ["-\tpublic final static boolean isArchiveFileName(String name) {", "-\t\tint nameLength = name == null ? 0 : name.length();", "-\t\tint suffixLength = SUFFIX_JAR.length;", "-\t\tif (nameLength < suffixLength) return false;", "-", "-\t\t// try to match as JAR file", "-\t\tfor (int i = 0; i < suffixLength; i++) {", "-\t\t\tchar c = name.charAt(nameLength - i - 1);", "-\t\t\tint suffixIndex = suffixLength - i - 1;", "-\t\t\tif (c != SUFFIX_jar[suffixIndex] && c != SUFFIX_JAR[suffixIndex]) {", "-", "-\t\t\t\t// try to match as ZIP file", "-\t\t\t\tsuffixLength = SUFFIX_ZIP.length;", "-\t\t\t\tif (nameLength < suffixLength) return false;", "-\t\t\t\tfor (int j = 0; j < suffixLength; j++) {", "-\t\t\t\t\tc = name.charAt(nameLength - j - 1);", "-\t\t\t\t\tsuffixIndex = suffixLength - j - 1;", "-\t\t\t\t\tif (c != SUFFIX_zip[suffixIndex] && c != SUFFIX_ZIP[suffixIndex]) return false;", "+\tpublic final static boolean isPotentialZipArchive(String name) {", "+\t\tint lastDot = name.lastIndexOf('.');", "+\t\tif (lastDot == -1)", "+\t\t\treturn false; // no file extension, it cannot be a zip archive name", "+\t\tif (name.lastIndexOf(File.separatorChar) > lastDot)", "+\t\t\treturn false; // dot was before the last file separator, it cannot be a zip archive name", "+\t\tint length = name.length();", "+\t\tint extensionLength = length - lastDot - 1;", "+\t\tif (extensionLength == EXTENSION_java.length()) {", "+\t\t\tfor (int i = extensionLength-1; i >=0; i--) {", "+\t\t\t\tif (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_java.charAt(i)) {", "+\t\t\t\t\tbreak; // not a \".java\" file, check \".class\" file case below", "-\t\t\t\treturn true;", "+\t\t\t\tif (i == 0) {", "+\t\t\t\t\treturn false; // it is a \".java\" file, it cannot be a zip archive name", "+\t\t\t\t}", "-\t\treturn true;\t\t", "-\t}\t", "+\t\tif (extensionLength == EXTENSION_class.length()) {", "+\t\t\tfor (int i = extensionLength-1; i >=0; i--) {", "+\t\t\t\tif (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_class.charAt(i)) {", "+\t\t\t\t\treturn true; // not a \".class\" file, so this is a potential archive name", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn false; // it is a \".class\" file, it cannot be a zip archive name", "+\t\t}", "+\t\treturn true; // it is neither a \".java\" file nor a \".class\" file, so this is a potential archive name", "+\t}"]}], "num": 55481}