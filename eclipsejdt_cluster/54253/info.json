{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1ca2982466773863f2688554fe2f2443", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42c5ea36534ee51bdd88751f7bf84882", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "702c62fec0923d7526ca23efea5c1bb4f5a2ef27", "commitAfterChange": "48a78bfcb529886e24e5f62b1bc56f7d3678e46a", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "  \tprivate LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk)", "signatureAfterChange": "  \tprivate LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk, boolean requireExceptionAnalysis)", "diff": ["-\tprivate LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk) {", "+\tprivate LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk, boolean requireExceptionAnalysis) {", "-\t\t\tif (copy != null)", "-\t\t\t\treturn copy;", "-\t\t\tif (anyTargetOk && this.copiesPerTargetType.values().size() > 0)", "-\t\t\t\treturn this.copiesPerTargetType.values().iterator().next();", "+\t\t\tif (copy == null) {", "+\t\t\t\tif (anyTargetOk && this.copiesPerTargetType.values().size() > 0)", "+\t\t\t\t\tcopy = this.copiesPerTargetType.values().iterator().next();", "+\t\t\t}", "-\t\t", "+\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "+\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\tcopy = copy();", "-\t\t\tif (copy == null)", "-\t\t\t\tthrow new CopyFailureException();", "-\t\t\t", "-\t\t\tcopy.setExpressionContext(this.expressionContext);", "-\t\t\tcopy.setExpectedType(targetType);", "-\t\t\tTypeBinding type = copy.resolveType(this.enclosingScope);", "-\t\t\tif (type == null || !type.isValidBinding())", "-\t\t\t\treturn null;", "-\t", "-\t\t\tif (this.copiesPerTargetType == null)", "-\t\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();", "-\t\t\tthis.copiesPerTargetType.put(targetType, copy);", "-\t\t\t", "+\t\t\tif (copy == null) {", "+\t\t\t\tcopy = copy();", "+\t\t\t\tif (copy == null)", "+\t\t\t\t\tthrow new CopyFailureException();", "+", "+\t\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\t\tcopy.setExpectedType(targetType);", "+\t\t\t\tTypeBinding type = copy.resolveType(this.enclosingScope);", "+\t\t\t\tif (type == null || !type.isValidBinding())", "+\t\t\t\t\treturn null;", "+", "+\t\t\t\tif (this.copiesPerTargetType == null)", "+\t\t\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();", "+\t\t\t\tthis.copiesPerTargetType.put(targetType, copy);", "+\t\t\t}", "+\t\t\tif (!requireExceptionAnalysis)", "+\t\t\t\treturn copy;", "+\t\t\tif (copy.thrownExceptions == null)", "+\t\t\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors())", "+\t\t\t\t\tcopy.analyzeExceptions();", "+\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79696ad8b63737dda857635b3288b471", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "e1a4dd76a1096e4a9ca316a8229a1b7d5fbaaa3a", "commitAfterChange": "0ff40cf9419ba675580163e104091de3b2c53d9a", "methodNumberBeforeChange": 118, "methodNumberAfterChange": 123, "signatureBeforeChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException", "signatureAfterChange": " \tpublic void resolveClasspath(PerProjectInfo perProjectInfo, boolean usePreviousSession) throws JavaModelException", "diff": ["-\tpublic void resolveClasspath(PerProjectInfo perProjectInfo) throws JavaModelException {", "+\tpublic void resolveClasspath(PerProjectInfo perProjectInfo, boolean usePreviousSession) throws JavaModelException {", "+\t\tif (CP_RESOLUTION_BP_LISTENERS != null)", "+\t\t\tbreakpoint(1, this);", "+\t\tboolean isClasspathBeingResolved = manager.isClasspathBeingResolved(this);", "-\t\t\tmanager.setClasspathBeingResolved(this, true);", "-\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "+\t\t\tif (!isClasspathBeingResolved) {", "+\t\t\t\tmanager.setClasspathBeingResolved(this, true);", "+\t\t\t}", "+\t\t\tExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();", "+", "-\t\t\t\t\t\t\tresolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);", "+\t\t\t\t\t\t\tresolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);", "-\t\t\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "+\t\t\t\t\t\tIClasspathContainer container = usePreviousSession ? manager.getPreviousSessionContainer(rawEntry.getPath(), this) : JavaCore.getClasspathContainer(rawEntry.getPath(), this);", "+\t\t\tif (CP_RESOLUTION_BP_LISTENERS != null)", "+\t\t\t\tbreakpoint(2, this);", "+", "-\t\t\tperProjectInfo.setResolvedClasspath(resolvedClasspath, rawReverseMap, rootPathToResolvedEntries, unresolvedEntryStatus, timeStamp);", "+\t\t\tperProjectInfo.setResolvedClasspath(resolvedClasspath, rawReverseMap, rootPathToResolvedEntries, usePreviousSession ? PerProjectInfo.NEED_RESOLUTION : unresolvedEntryStatus, timeStamp);", "-\t\t\tmanager.setClasspathBeingResolved(this, false);", "+\t\t\tif (!isClasspathBeingResolved) {", "+\t\t\t\tmanager.setClasspathBeingResolved(this, false);", "+\t\t\t}", "+\t\t\tif (CP_RESOLUTION_BP_LISTENERS != null)", "+\t\t\t\tbreakpoint(3, this);"]}], "num": 54253}