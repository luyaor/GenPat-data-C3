{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b8d7290e86aadd6bbe9bed8aa23cfb6e", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8d4bfda0ecde31fe8aec1c7a558d949", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "5bad0f0933acdc658d4e40a7d9becfd8568dd235", "commitAfterChange": "4316c760d5aabce67e5ab83fef96d7ef0cdbee57", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t// Structured to report as many errors as possible in bail out situations.", "+\t\t", "-", "-\t\tif (isConstructorReference()) {", "+\t\t", "+\t\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "+    \tif (isConstructorReference()) {", "-\t\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "+\t\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\t\tif (isMethodReference() && this.receiverType.isRawType())", "-\t\t\t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "+\t\t\t\tif (isMethodReference() && this.receiverType.isRawType()) {", "+\t\t\t\t\tif ((this.lhs.bits & ASTNode.IgnoreRawTypeCheck) == 0 && compilerOptions.getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "+\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+        this.method.binding = this.binding;", "-        boolean throwsTantrum = false;", "-        \tthrowsTantrum = true;", "-        if (this.binding.isAbstract()) {", "-        \tif (this.lhs instanceof SuperReference || this.lhs instanceof QualifiedSuperReference) {", "-        \t\tscope.problemReporter().cannotReferToAbstractMethod(this, this.binding);", "-        \t\treturn null;", "-        \t}", "-        }", "-        if (throwsTantrum)", "+        if (this.binding.isAbstract() && this.lhs.isSuper()) {", "+        \tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "+        }", "-        this.method.binding = this.binding;", "- ", "-        return this.resolvedType;", "+        if (this.binding.isStatic() && this.binding.declaringClass != this.receiverType) {", "+\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "+\t\t}", "+            \t", "+    \tif (checkInvocationArguments(scope, null, this.receiverType, this.binding, null, descriptorParameters, false, this)) {", "+    \t\tthis.bits |= ASTNode.Unchecked;", "+    \t}", "+", "+    \tif (isMethodUseDeprecated(this.binding, scope, true))", "+    \t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+", "+    \tif (this.descriptor.returnType.id != TypeIds.T_void) {", "+    \t\t// from 1.5 source level on, array#clone() returns the array type (but binding still shows Object)", "+    \t\tTypeBinding returnType = null;", "+    \t\tif (this.binding == scope.environment().arrayClone) {", "+    \t\t\treturnType = this.receiverType;", "+    \t\t} else {", "+    \t\t\tif ((this.bits & ASTNode.Unchecked) != 0 && this.resolvedTypeArguments == null) {", "+    \t\t\t\treturnType = this.binding.returnType;", "+    \t\t\t\tif (returnType != null) {", "+    \t\t\t\t\treturnType = scope.environment().convertToRawType(returnType.erasure(), true);", "+    \t\t\t\t}", "+    \t\t\t} else {", "+    \t\t\t\treturnType = this.binding.returnType;", "+    \t\t\t\tif (returnType != null) {", "+    \t\t\t\t\treturnType = returnType.capture(scope, this.sourceEnd);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope)) {", "+    \t\t\tscope.problemReporter().incompatibleReturnType(this, this.binding, this.descriptor.returnType);", "+    \t\t}", "+    \t}", "+    \tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+    \t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.resolvedTypeArguments, this.typeArguments);", "+    \t}", "+    \treturn (this.resolvedType.tagBits & TagBits.HasMissingType) == 0", "+    \t\t\t\t? this.resolvedType", "+    \t\t\t\t: null;\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbab4605c9e2e011b0fe96d6a5297950", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "5abbc9ddba0809fbf49d16dc724883e6fc17121c", "commitAfterChange": "dff8c6a289a7b5116b7d5b64b00c639d5d108195", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-    \tif (isConstructorReference()) {", "+    \tif (isConstructorReference())", "-\t\t}", "+\t\t", "-\t\t\tif (argHasError) {", "+\t\t\tif (argHasError)", "-\t\t\t}", "-\t\t\tscope.problemReporter().errorNoMethodFor(this.lhs, lhsType, selector, this.descriptor != null ? descriptorParameters : Binding.NO_TYPES);", "+\t\t\tscope.problemReporter().errorNoMethodFor(this.lhs, lhsType, selector, descriptorParameters);", "-\t\t\t\tif (isMethodReference() && this.receiverType.isRawType()) {", "-\t\t\t\t\tif ((this.lhs.bits & ASTNode.IgnoreRawTypeCheck) == 0 && compilerOptions.getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "-\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-        \tif (isStatic && (this.haveReceiver || this.receiverType instanceof ParameterizedTypeBinding)) {", "+        \tif (isStatic && (this.haveReceiver || this.receiverType.isParameterizedType())) {", "+        } else {", "+        \tif (this.lhs instanceof NameReference && !this.haveReceiver && isMethodReference() && this.receiverType.isRawType()) {", "+        \t\tif ((this.lhs.bits & ASTNode.IgnoreRawTypeCheck) == 0 && compilerOptions.getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "+        \t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "+        \t\t}", "+        \t}", "-        \tTypeBinding superType = descriptorParameters[0].findSuperTypeOriginatingFrom(this.receiverType);", "-        \tif (superType != null) {", "-        \t\tTypeBinding typeToSearch = this.receiverType.isRawType() ? superType : this.receiverType;", "+        \tfinal TypeBinding potentialReceiver = descriptorParameters[0];", "+        \tif (potentialReceiver.isCompatibleWith(this.receiverType, scope)) {", "+        \t\tTypeBinding typeToSearch = this.receiverType;", "+        \t\tif (this.receiverType.isRawType()) {", "+        \t\t\tTypeBinding superType = potentialReceiver.findSuperTypeOriginatingFrom(this.receiverType);", "+        \t\t\tif (superType != null)", "+        \t\t\t\ttypeToSearch = superType;", "+        \t\t}", "-        \tscope.problemReporter().danglingReference(this, this.receiverType, selector, descriptorParameters);", "+        \tchar [] visibleName = isConstructorReference() ? this.receiverType.sourceName() : selector;", "+        \tscope.problemReporter().danglingReference(this, this.receiverType, visibleName, descriptorParameters);", "+", "+        if (this.binding.isAbstract() && this.lhs.isSuper())", "+        \tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "+        if (this.binding.isStatic() && this.binding.declaringClass != this.receiverType)", "+\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "+    ", "+    \tif (isMethodUseDeprecated(this.binding, scope, true))", "+    \t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+", "+    \tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES)", "+    \t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.resolvedTypeArguments, this.typeArguments);", "+    \t", "+", "-        if (this.binding.isAbstract() && this.lhs.isSuper()) {", "-        \tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-        \treturn null;", "-        }", "-        ", "-        if (this.binding.isStatic() && this.binding.declaringClass != this.receiverType) {", "-\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "-\t\t}", "-            \t", "-    \tif (checkInvocationArguments(scope, null, this.receiverType, this.binding, null, descriptorParameters, false, this)) {", "+    \tif (checkInvocationArguments(scope, null, this.receiverType, this.binding, null, descriptorParameters, false, this))", "-    \t}", "-", "-    \tif (isMethodUseDeprecated(this.binding, scope, true))", "-    \t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-    \t\tif (this.binding == scope.environment().arrayClone) {", "+    \t\tif (this.binding == scope.environment().arrayClone || this.binding.isConstructor()) {", "-    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope)) {", "+    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope))", "-    \t\t}", "-    \tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "-    \t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.resolvedTypeArguments, this.typeArguments);", "-    \t}", "-    \treturn (this.resolvedType.tagBits & TagBits.HasMissingType) == 0", "-    \t\t\t\t? this.resolvedType", "-    \t\t\t\t: null;\t", "+", "+    \treturn this.resolvedType; // Phew !"]}], "num": 43141}