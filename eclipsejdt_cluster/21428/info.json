{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "63c67ba0d44653033edffdc74901807a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c367e74cdc322ae7ed0d0b0b289c5e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "55f4964943e2f63287728b29450cbefa492d313d", "commitAfterChange": "ffcfe0dac7f476f076089d3cdae600b5982efdfb", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t\tif (argLength != parameters.length)", "-\t\t\treturn null; // incompatible", "+\t\tint paramLength = parameters.length;", "+\t\tboolean varArgCase = method.isVararg();", "+\t\tif (argLength != paramLength)", "+\t\t\tif (!varArgCase || argLength < paramLength - 1)", "+\t\t\t\treturn null; // incompatible", "-\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod); // attempt to invoke generic method of raw type with type hints <String>foo()", "+\t\t\t\t\t// attempt to invoke generic method of raw type with type hints <String>foo()", "+\t\t\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod);", "-\t\t", "+", "-\t\t\tfor (int i = 0; i < argLength; i++)", "+\t\t\tint lastIndex = argLength;", "+\t\t\tif (varArgCase) {", "+\t\t\t\tlastIndex = paramLength - 1;", "+\t\t\t\tif (paramLength == argLength) { // accept both X and X[] but not X[][]", "+\t\t\t\t\tTypeBinding varArgType = parameters[lastIndex]; // is an ArrayBinding by definition", "+\t\t\t\t\tint varArgDimension = varArgType.dimensions();", "+\t\t\t\t\tTypeBinding lastArgument = arguments[lastIndex];", "+\t\t\t\t\tint lastArgDimensions = lastArgument.dimensions();", "+\t\t\t\t\tif (varArgDimension == lastArgDimensions || varArgDimension - 1 == lastArgDimensions) {", "+\t\t\t\t\t\tvarArgType = varArgType.leafComponentType();", "+\t\t\t\t\t\tlastArgument = lastArgument.leafComponentType();", "+\t\t\t\t\t\tif (varArgType != lastArgument && !lastArgument.isCompatibleWith(varArgType))", "+\t\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t\t} else { // dimensions are not compatible", "+\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType", "+\t\t\t\t\tTypeBinding varArgType = ((ArrayBinding) parameters[lastIndex]).elementsType();", "+\t\t\t\t\tfor (int i = lastIndex; i < argLength; i++)", "+\t\t\t\t\t\tif (varArgType != arguments[i] && !arguments[i].isCompatibleWith(varArgType))", "+\t\t\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t} else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();", "+\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\t\t}", "+\t\t\t\t// now compare standard arguments from 0 to lastIndex", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < lastIndex; i++)", "-\t\tif (genericTypeArguments != null) {", "+\t\tif (genericTypeArguments != null)", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c1ada7b953b595e782d2e597a846fb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "c65347571547f67c860a6ef249183861500993de", "commitAfterChange": "c37ad47cfe3a592e86ce37a47b02bf6402d7f1de", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " private int checkAndRecordImportBinding( \t\tBinding importBinding,  \t\tHashtableOfType typesBySimpleNames,  \t\tImportReference importReference, \t\tchar[][] compoundName)", "signatureAfterChange": " private int checkAndRecordImportBinding( \t\tBinding importBinding,  \t\tHashtableOfType typesBySimpleNames,  \t\tImportReference importReference, \t\tchar[][] compoundName)", "diff": ["+\tfinal char[] name = compoundName[compoundName.length - 1];", "-\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "+\t\tReferenceBinding existingType = typesBySimpleNames.get(name);", "+\t\t\tif (importReference.isStatic() && importBinding instanceof ReferenceBinding && compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\t// 7.5.3 says nothing about collision of single static imports and JDK8 tolerates them, though use is flagged.", "+\t\t\t\tfor (int j = 0; j < this.importPtr; j++) {", "+\t\t\t\t\tImportBinding resolved = this.tempImports[j];", "+\t\t\t\t\tif (resolved.isStatic() && resolved.resolvedImport instanceof ReferenceBinding && importBinding != resolved.resolvedImport) {", "+\t\t\t\t\t\tif (CharOperation.equals(name, resolved.compoundName[resolved.compoundName.length - 1])) {", "+\t\t\t\t\t\t\tReferenceBinding type = (ReferenceBinding) resolved.resolvedImport;", "+\t\t\t\t\t\t\tresolved.resolvedImport = new ProblemReferenceBinding(new char[][] { name }, type, ProblemReasons.Ambiguous);", "+\t\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], referenceBinding);", "+\t\ttypesBySimpleNames.put(name, referenceBinding);", "-\t\t\t\tif (CharOperation.equals(compoundName[compoundName.length - 1], resolved.compoundName[resolved.compoundName.length - 1])) {", "-\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\treturn -1;", "+\t\t\t\tif (CharOperation.equals(name, resolved.compoundName[resolved.compoundName.length - 1])) {", "+\t\t\t\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\t\t\t// 7.5.3 says nothing about collision of single static imports and JDK8 tolerates them, though use is flagged.", "+\t\t\t\t\t\tFieldBinding field = (FieldBinding) resolved.resolvedImport;", "+\t\t\t\t\t\tresolved.resolvedImport = new ProblemFieldBinding(field, field.declaringClass, name, ProblemReasons.Ambiguous);", "+\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "+\t\t\t\t\t\treturn -1;", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a55a58c7c9cc1c783ad1a214994f3190", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java", "commitBeforeChange": "37cdc05159ff5efd9f619984e4b82d8d4b642003", "commitAfterChange": "b467e55e644d7aa26f14573777b2b84d9309b910", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \r private boolean hasClasspathChanged()", "signatureAfterChange": "\r \r private boolean hasClasspathChanged()", "diff": ["-\tif (classpath.length == oldClasspathLocations.length) {\r", "-\t\tfor (int i = 0, length = classpath.length; i < length; i++) {\r", "+\tint newLength = classpath.length;\r", "+\tint oldLength = oldClasspathLocations.length;\r", "+\tint diff = newLength - oldLength;\r", "+\tif (diff == 0) {\r", "+\t\tfor (int i = 0; i < newLength; i++) {\r", "+\t} else if (diff == 1) {\r", "+\t\tClasspathMultiDirectory newSourceDirectory = null;\r", "+\t\tint n = 0, o = 0;\r", "+\t\tfor (; n < newLength && o < oldLength; n++, o++) {\r", "+\t\t\tif (classpath[n].equals(oldClasspathLocations[o])) continue;\r", "+\t\t\tif (diff == 1 && classpath[n] instanceof ClasspathMultiDirectory) { // added a new source folder\r", "+\t\t\t\tnewSourceDirectory = (ClasspathMultiDirectory) classpath[n];\r", "+\t\t\t\to--;\r", "+\t\t\t\tdiff = 0; // found new element\r", "+\t\t\t\tcontinue;\r", "+\t\t\t}\r", "+\t\t\tif (DEBUG)\r", "+\t\t\t\tSystem.out.println(classpath[n] + \" != \" + oldClasspathLocations[o]); //$NON-NLS-1$\r", "+\t\t\treturn true;\r", "+\t\t}\r", "+\r", "+\t\tif (diff == 1 && classpath[n] instanceof ClasspathMultiDirectory) // added a new source folder at the end\r", "+\t\t\tnewSourceDirectory = (ClasspathMultiDirectory) classpath[n];\r", "+\t\tif (newSourceDirectory != null) {\r", "+\t\t\tIContainer sourceFolder = workspaceRoot.getContainerForLocation(new Path(newSourceDirectory.sourcePath));\r", "+\t\t\tif (sourceFolder != null && sourceFolder.exists()) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tif (sourceFolder.members().length == 0) return false; // added a new empty source folder\r", "+\t\t\t\t} catch (CoreException ignore) {}\r", "+\t\t\t}\r", "+\t\t}\r"]}], "num": 21428}