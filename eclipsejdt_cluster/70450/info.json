{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9338905e5078c3ed8856ae1d997d400d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0fc722bdd02b36b23efc3b0b17991914", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "409d050617fcf352393ff243104bdcc98737726e", "commitAfterChange": "79aa5b474819808453695ac530baf1e6c5fdeb6b", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " private String extractJavadoc(IType declaringType, String contents) throws JavaModelException", "signatureAfterChange": " private String extractJavadoc(IType declaringType, String contents) throws JavaModelException", "diff": ["-\tString anchor = Signature.toString(this.getSignature().replace('/', '.'), methodName, null, true, false, Flags.isVarargs(this.getFlags()));", "+\tIBinaryMethod info = (IBinaryMethod) getElementInfo();", "+\tchar[] genericSignature = info.getGenericSignature();", "+\tString anchor = null;", "+\tif (genericSignature != null) {", "+\t\tCharOperation.replace(genericSignature, '/', '.');", "+\t\tanchor = Util.toAnchor(genericSignature, methodName, Flags.isVarargs(this.getFlags()));", "+\t\tif (anchor == null) throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.UNKNOWN_JAVADOC_FORMAT, this));", "+\t} else {", "+\t\tanchor = Signature.toString(this.getSignature().replace('/', '.'), methodName, null, true, false, Flags.isVarargs(this.getFlags()));", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48773e117e7cd684b6222cfa66b7104b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "40f76b3d0fb01a4a7fa1aad4b09c356c31458c94", "commitAfterChange": "323d52f789e646d704223fd3ac5d22c4e4efec25", "methodNumberBeforeChange": 433, "methodNumberAfterChange": 433, "signatureBeforeChange": " public void typeMismatchError(TypeBinding actualType, TypeBinding expectedType, ASTNode location, ASTNode expectingLocation)", "signatureAfterChange": " public void typeMismatchError(TypeBinding actualType, TypeBinding expectedType, ASTNode location, ASTNode expectingLocation)", "diff": ["+\tchar[] actualReadableName = actualType.readableName();", "+\tchar[] expectedReadableName = expectedType.readableName();", "-\t\tactualShortReadableName = actualType.readableName();", "-\t\texpectedShortReadableName = expectedType.readableName();", "+\t\tif (CharOperation.equals(actualReadableName, expectedReadableName)) {", "+\t\t\t// if full type names are equal, assume the incompatibility is due to mismatching null annotations:", "+\t\t\tactualReadableName = actualType.nullAnnotatedReadableName(this.options, false);", "+\t\t\texpectedReadableName = expectedType.nullAnnotatedReadableName(this.options, false);", "+\t\t\tactualShortReadableName = actualType.nullAnnotatedReadableName(this.options, true);", "+\t\t\texpectedShortReadableName = expectedType.nullAnnotatedReadableName(this.options, true);", "+\t\t} else {", "+\t\t\tactualShortReadableName = actualReadableName;", "+\t\t\texpectedShortReadableName = expectedReadableName;", "+\t\t}", "-\t\tnew String[] {new String(actualType.readableName()), new String(expectedType.readableName())},", "+\t\tnew String[] {new String(actualReadableName), new String(expectedReadableName)},"]}], "num": 70450}