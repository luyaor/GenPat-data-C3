{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1b3e7cf9c4be7e36d2aea0750a825aec", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0d59cb373582e09e4bd7f43b976fa729", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "079f1f525d3cbb0b2570dd4fe3bd959b7a33dc49", "commitAfterChange": "b21cadb5eae53d9f84dce9f073b5350a267b6ad6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException", "signatureAfterChange": " public void add(JavaProject project, int includeMask, HashSet visitedProject) throws JavaModelException", "diff": ["-public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException {", "+ */", "+public void add(JavaProject project, int includeMask, HashSet visitedProject) throws JavaModelException {", "+\tadd(project, null, includeMask, visitedProject, null);", "+}", "-\t\t\t\tIClasspathEntry rawEntry = null;", "-\t\t\t\tJavaModelManager.PerProjectInfo perProjectInfo = javaProject.getPerProjectInfo();", "-\t\t\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "-\t\t\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "-\t\t\t\t}", "-\t\t\t\tif (rawEntry == null) break;", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "-\t\t\t\t\tadd((JavaProject) model.getJavaProject(entry.getPath().lastSegment()), includeMask, visitedProjects);", "-\t\t\t\t\tadd(entry.getPath(), true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4baceb6827f7e2feacdd5ba32cc2035f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "50431e234c5ece34d7b8d3e0af32a86a5079d5cd", "commitAfterChange": "e87f626a0744f3e42bfbad630a4e9545c488a83d", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": " \tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project)", "signatureAfterChange": " \tvoid reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project)", "diff": ["-\tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project) {", "-\t\t\t", "-\t\tswitch (delta.getKind()) {", "-\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "-\t\t\t\ttry {", "-\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "-\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "-\t\t\t\t\t\tproject.saveClasspath(info.classpath, info.outputLocation);", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase IResourceDelta.CHANGED :", "-\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "-\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "-\t\t\t\t\tbreak;", "-\t\t\tcase IResourceDelta.ADDED :", "-\t\t\t\t// check if any actual difference", "-\t\t\t\tproject.flushClasspathProblemMarkers(false, true);", "-\t\t\t\tboolean wasSuccessful = false; // flag recording if .classpath file change got reflected", "-\t\t\t\ttry {", "-\t\t\t\t\t// force to (re)read the property file", "-\t\t\t\t\tIClasspathEntry[] fileEntries = project.readClasspathFile(true/*create markers*/, false/*don't log problems*/);", "-\t\t\t\t\tif (fileEntries == null)", "-\t\t\t\t\t\tbreak; // could not read, ignore ", "-\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "-\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "-\t\t\t\t\t\tif (project.isClasspathEqualsTo(info.classpath, info.outputLocation, fileEntries)) {", "-\t\t\t\t\t\t\twasSuccessful = true;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\tvoid reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project) {", "-\t\t\t\t\t// will force an update of the classpath/output location based on the file information", "-\t\t\t\t\t// extract out the output location", "-\t\t\t\t\tIPath outputLocation = null;", "-\t\t\t\t\tif (fileEntries != null && fileEntries.length > 0) {", "-\t\t\t\t\t\tIClasspathEntry entry = fileEntries[fileEntries.length - 1];", "-\t\t\t\t\t\tif (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {", "-\t\t\t\t\t\t\toutputLocation = entry.getPath();", "-\t\t\t\t\t\t\tIClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];", "-\t\t\t\t\t\t\tSystem.arraycopy(fileEntries, 0, copy, 0, copy.length);", "-\t\t\t\t\t\t\tfileEntries = copy;", "+\t\tboolean reloadClasspath = true;", "+\t\tif (delta != null) {", "+\t\t\treloadClasspath = false; // narrow down need to reload based on delta", "+\t\t\tswitch (delta.getKind()) {", "+\t\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tJavaModelManager.PerProjectInfo info = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(project.getProject());", "+\t\t\t\t\t\tif (info.classpath != null) { // if there is an in-memory classpath", "+\t\t\t\t\t\t\tproject.saveClasspath(info.classpath, info.outputLocation);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "+\t\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t// restore output location\t\t\t\t", "-\t\t\t\t\tif (outputLocation == null) {", "-\t\t\t\t\t\toutputLocation = SetClasspathOperation.ReuseOutputLocation;", "-\t\t\t\t\t\t// clean mode will also default to reusing current one", "-\t\t\t\t\t}", "-\t\t\t\t\tproject.setRawClasspath(", "-\t\t\t\t\t\tfileEntries, ", "-\t\t\t\t\t\toutputLocation, ", "-\t\t\t\t\t\tnull, // monitor", "-\t\t\t\t\t\ttrue, // canChangeResource", "-\t\t\t\t\t\tproject.getResolvedClasspath(true), // ignoreUnresolvedVariable", "-\t\t\t\t\t\ttrue, // needValidation", "-\t\t\t\t\t\tfalse); // no need to save", "-\t\t\t\t\t", "-\t\t\t\t\t// if reach that far, the classpath file change got absorbed", "-\t\t\t\t\twasSuccessful = true;", "-\t\t\t\t} catch (RuntimeException e) {", "-\t\t\t\t\t// setRawClasspath might fire a delta, and a listener may throw an exception", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not set classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t} catch (JavaModelException e) { // CP failed validation", "-\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\tif (e.getJavaModelStatus().getException() instanceof CoreException) {", "-\t\t\t\t\t\t\t// happens if the .classpath could not be written to disk", "-\t\t\t\t\t\t\tproject.createClasspathProblemMarker(new JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CLASSPATH_FILE_FORMAT,", "-\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.couldNotWriteClasspathFile\", project.getElementName(), e.getMessage()))); //$NON-NLS-1$", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tproject.createClasspathProblemMarker(new JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CLASSPATH_FILE_FORMAT,", "-\t\t\t\t\t\t\t\t\tUtil.bind(\"classpath.invalidClasspathInClasspathFile\", project.getElementName(), e.getMessage()))); //$NON-NLS-1$", "-\t\t\t\t\t\t}\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\t} finally {", "-\t\t\t\t\tif (!wasSuccessful) { ", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tproject.setRawClasspath0(JavaProject.INVALID_CLASSPATH);", "-\t\t\t\t\t\t\tproject.updatePackageFragmentRoots();", "-\t\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tcase IResourceDelta.CHANGED :", "+\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "+\t\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tcase IResourceDelta.ADDED :", "+\t\t\t\t\treloadClasspath = true;", "+\t\t\t}", "+\t\t}", "+\t\tif (reloadClasspath) {", "+\t\t\ttry {", "+\t\t\t\tproject.forceClasspathReload(null);", "+\t\t\t} catch (RuntimeException e) {", "+\t\t\t} catch (JavaModelException e) {\t", "+\t\t\t}"]}], "num": 2518}