{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "74d206a860d885576212a8af1283be90", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "173dfa29e41df6f7719eae95f8892d53", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "d32639fa2ab9bcc59e4aac9996a4cf8d63edf941", "commitAfterChange": "b317a1e7ce5a7a6cc55cd1f344eea57539a2bc94", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public String[] getParameterNames() throws JavaModelException", "signatureAfterChange": " public String[] getParameterNames() throws JavaModelException", "diff": ["+\t\tif (this.parameterNames == null) {", "+\t\t\t// try to see if we can retrieve the names from the attached javadoc", "+\t\t\tIBinaryMethod info = (IBinaryMethod) getElementInfo();", "+\t\t\tfinal int paramCount = Signature.getParameterCount(new String(info.getMethodDescriptor()));", "+\t\t\tif (paramCount != 0) {", "+\t\t\t\tString javadoc = this.getAttachedJavadoc(new NullProgressMonitor(), \"UTF-8\"); //$NON-NLS-1$", "+\t\t\t\tif (javadoc != null) {", "+\t\t\t\t\tfinal int indexOfOpenParen = javadoc.indexOf('(');", "+\t\t\t\t\tif (indexOfOpenParen != -1) {", "+\t\t\t\t\t\tfinal int indexOfClosingParen = javadoc.indexOf(')', indexOfOpenParen);", "+\t\t\t\t\t\tif (indexOfClosingParen != -1) {", "+\t\t\t\t\t\t\tfinal char[] paramsSource =", "+\t\t\t\t\t\t\t\tCharOperation.replace(", "+\t\t\t\t\t\t\t\t\tjavadoc.substring(indexOfOpenParen + 1, indexOfClosingParen).toCharArray(),", "+\t\t\t\t\t\t\t\t\t\"&nbsp;\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tnew char[] {' '});", "+\t\t\t\t\t\t\tfinal StringTokenizer tokenizer = new StringTokenizer(String.valueOf(paramsSource), \", \\n\\r\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tint index = 0;", "+\t\t\t\t\t\t\tfinal ArrayList paramNames = new ArrayList(paramCount);", "+\t\t\t\t\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\t\t\tfinal String token = tokenizer.nextToken();", "+\t\t\t\t\t\t\t\tif ((index & 1) != 0) {", "+\t\t\t\t\t\t\t\t\t// if odd then this is a parameter name", "+\t\t\t\t\t\t\t\t\tparamNames.add(token);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!paramNames.isEmpty()) {", "+\t\t\t\t\t\t\t\tthis.parameterNames = new String[paramNames.size()];", "+\t\t\t\t\t\t\t\tparamNames.toArray(this.parameterNames);", "+\t\t\t\t\t\t\t}", "+\t \t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "631c1eea69e890d9cdb4c41e7ca6eda8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "ac0d8e43201f2c72ac86f43d209462e745dd7be6", "commitAfterChange": "d651be7766f1aad04a5e2274e1cfb4a13affa340", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public String[] getParameterNames() throws JavaModelException", "signatureAfterChange": " public String[] getParameterNames() throws JavaModelException", "diff": ["-\tif (this.parameterNames == null) {", "+\tif (this.parameterNames != null) ", "+\t\treturn this.parameterNames;", "-\t\t// force source mapping if not already done", "-\t\tIType type = (IType) getParent();", "-\t\tSourceMapper mapper = getSourceMapper();", "-\t\tif (mapper != null) {", "-\t\t\tchar[][] paramNames = mapper.getMethodParameterNames(this);", "-\t\t\t", "-\t\t\t// map source and try to find parameter names", "-\t\t\tif(paramNames == null) {", "-\t\t\t\tchar[] source = mapper.findSource(type);", "-\t\t\t\tif (source != null){", "-\t\t\t\t\tmapper.mapSource(type, source);", "-\t\t\t\t}", "-\t\t\t\tparamNames = mapper.getMethodParameterNames(this);", "+\t// force source mapping if not already done", "+\tIType type = (IType) getParent();", "+\tSourceMapper mapper = getSourceMapper();", "+\tif (mapper != null) {", "+\t\tchar[][] paramNames = mapper.getMethodParameterNames(this);", "+\t\t", "+\t\t// map source and try to find parameter names", "+\t\tif(paramNames == null) {", "+\t\t\tchar[] source = mapper.findSource(type);", "+\t\t\tif (source != null){", "+\t\t\t\tmapper.mapSource(type, source);", "-\t\t\t", "-\t\t\t// if parameter names exist, convert parameter names to String array", "-\t\t\tif(paramNames != null) {", "-\t\t\t\tthis.parameterNames = new String[paramNames.length];", "-\t\t\t\tfor (int i = 0; i < paramNames.length; i++) {", "-\t\t\t\t\tthis.parameterNames[i] = new String(paramNames[i]);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tparamNames = mapper.getMethodParameterNames(this);", "-\t\t// if still no parameter names, produce fake ones", "-\t\tif (this.parameterNames == null) {", "-\t\t\tIBinaryMethod info = (IBinaryMethod) getElementInfo();", "-\t\t\tint paramCount = Signature.getParameterCount(new String(info.getMethodDescriptor()));", "-\t\t\tthis.parameterNames = new String[paramCount];", "-\t\t\tfor (int i = 0; i < paramCount; i++) {", "-\t\t\t\tthis.parameterNames[i] = \"arg\" + i; //$NON-NLS-1$", "+\t\t", "+\t\t// if parameter names exist, convert parameter names to String array", "+\t\tif(paramNames != null) {", "+\t\t\tthis.parameterNames = new String[paramNames.length];", "+\t\t\tfor (int i = 0; i < paramNames.length; i++) {", "+\t\t\t\tthis.parameterNames[i] = new String(paramNames[i]);", "+\t\t\t}", "+\t\t\treturn this.parameterNames;", "+\t\t}", "+\t}", "+\t", "+\t// try to see if we can retrieve the names from the attached javadoc", "+\tIBinaryMethod info = (IBinaryMethod) getElementInfo();", "+\tfinal int paramCount = Signature.getParameterCount(new String(info.getMethodDescriptor()));", "+\tif (paramCount != 0) {", "+\t\tString javadoc = this.getAttachedJavadoc(null, \"UTF-8\"); //$NON-NLS-1$", "+\t\tif (javadoc != null) {", "+\t\t\tfinal int indexOfOpenParen = javadoc.indexOf('(');", "+\t\t\tif (indexOfOpenParen != -1) {", "+\t\t\t\tfinal int indexOfClosingParen = javadoc.indexOf(')', indexOfOpenParen);", "+\t\t\t\tif (indexOfClosingParen != -1) {", "+\t\t\t\t\tfinal char[] paramsSource =", "+\t\t\t\t\t\tCharOperation.replace(", "+\t\t\t\t\t\t\tjavadoc.substring(indexOfOpenParen + 1, indexOfClosingParen).toCharArray(),", "+\t\t\t\t\t\t\t\"&nbsp;\".toCharArray(), //$NON-NLS-1$", "+\t\t\t\t\t\t\tnew char[] {' '});", "+\t\t\t\t\tfinal StringTokenizer tokenizer = new StringTokenizer(String.valueOf(paramsSource), \", \\n\\r\"); //$NON-NLS-1$", "+\t\t\t\t\tint index = 0;", "+\t\t\t\t\tfinal ArrayList paramNames = new ArrayList(paramCount);", "+\t\t\t\t\twhile (tokenizer.hasMoreTokens()) {", "+\t\t\t\t\t\tfinal String token = tokenizer.nextToken();", "+\t\t\t\t\t\tif ((index & 1) != 0) {", "+\t\t\t\t\t\t\t// if odd then this is a parameter name", "+\t\t\t\t\t\t\tparamNames.add(token);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!paramNames.isEmpty()) {", "+\t\t\t\t\t\tthis.parameterNames = new String[paramNames.size()];", "+\t\t\t\t\t\tparamNames.toArray(this.parameterNames);", "+\t\t\t\t\t\treturn this.parameterNames;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\treturn this.parameterNames;", "+", "+\t// if still no parameter names, produce fake ones", "+\treturn this.parameterNames = getRawParameterNames(paramCount);"]}], "num": 72460}