{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f9ba9f160a3bb6b39b0c95f1780145dd", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f0e576a906243f60c6e228d4fc38990", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "af652d9d40e3e30a14ccbd2056144782592afc53", "commitAfterChange": "3dca78ae937ad139f018c4ddaaa87c3fe26600ed", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic boolean tIsMoreSpecific(TypeBinding t, TypeBinding s)", "signatureAfterChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["-\tpublic boolean tIsMoreSpecific(TypeBinding t, TypeBinding s) {", "-\t\t/* 15.12.2.5 t is more specific than s iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "+\tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t) {", "+\t\t/* 15.12.2.5 s is more specific than t iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "-\t\tMethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);", "-\t\tif (tSam == null || !tSam.isValidBinding())", "-\t\t\treturn false;", "+\t\tMethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);", "+\t\tif (tSam == null || !tSam.isValidBinding())", "+\t\t\treturn false;", "-\t\tif (t.findSuperTypeOriginatingFrom(s) != null || s.findSuperTypeOriginatingFrom(t) != null)", "+\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\t\tif (tSam.parameters.length != sSam.parameters.length)", "+\t\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\t\tfor (int i = 0, length = tSam.parameters.length; i < length; i++) {", "-\t\t\t\tif (TypeBinding.notEquals(tSam.parameters[i], sSam.parameters[i]))", "+\t\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "+\t\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\tif (sSam.returnType.id == TypeIds.T_void)", "+\t\tif (tSam.returnType.id == TypeIds.T_void)", "-\t\tExpression [] returnExpressions = (Expression[]) this.resultExpressions.get(t); // should be same as for s", "+\t\tExpression [] returnExpressions = (Expression[]) this.resultExpressions.get(s); // should be same as for s", "-\t\tt = t.capture(this.enclosingScope, this.sourceEnd);", "-\t\ttSam = t.getSingleAbstractMethod(this.enclosingScope);", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tsSam = s.getSingleAbstractMethod(this.enclosingScope);", "-\t\t\tif (!resultExpression.tIsMoreSpecific(tSam.returnType, sSam.returnType))", "+\t\t\tif (!resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae97b5a323217b7a9817f9857594bc00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "a0e794820a3e45ac013c44e55b82e935802d5378", "commitAfterChange": "a06fd70a66cd192fe200df3baf9406d9e87b6313", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 32, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\t", "-\t\tif (sam == null || !sam.isValidBinding())", "+\t\tif (!(left instanceof ReferenceBinding))", "-\t\tif (sam.parameters.length != this.arguments.length)", "-\t\t\treturn false;", "-\t\t", "-\t\tif (!this.shapeAnalysisComplete) {", "+", "+\t\tshapeAnalysis: if (!this.shapeAnalysisComplete) {", "-\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\t\t\tif (!this.voidCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!this.valueCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "+// FIXME: we don't yet have the same, should we compute it here & now?", "+//\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "+//\t\t\t\t\t\t\tif (!this.voidCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t} else {", "+//\t\t\t\t\t\t\tif (!this.valueCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\treturn this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\tbreak shapeAnalysis;", "+\t\t\t\t\tif (this.arguments.length != 0) // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tbreak shapeAnalysis;", "+\t\tReferenceBinding groundTargetType = findGroundTargetType(this.enclosingScope, (ReferenceBinding) left, argumentsTypeElided());", "+\t\tif (groundTargetType == null)", "+\t\t\treturn false;", "+\t\t", "+\t\tMethodBinding sam = groundTargetType.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tif (sam == null || !sam.isValidBinding())", "+\t\t\treturn false;", "+\t\tif (sam.parameters.length != this.arguments.length)", "+\t\t\treturn false;", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c778fba35acfc23f22f5aa7368a07fb8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "af652d9d40e3e30a14ccbd2056144782592afc53", "commitAfterChange": "3dca78ae937ad139f018c4ddaaa87c3fe26600ed", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic boolean tIsMoreSpecific(TypeBinding t, TypeBinding s)", "signatureAfterChange": " \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["-\tpublic boolean tIsMoreSpecific(TypeBinding t, TypeBinding s) {", "+\tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t) {", "-\t\tMethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);", "-\t\tif (tSam == null || !tSam.isValidBinding())", "-\t\t\treturn false;", "+\t\tMethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);", "+\t\tif (tSam == null || !tSam.isValidBinding())", "+\t\t\treturn false;", "-\t\tif (t.findSuperTypeOriginatingFrom(s) != null || s.findSuperTypeOriginatingFrom(t) != null)", "+\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\tif (tSam.parameters.length != sSam.parameters.length)", "+\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\tfor (int i = 0, length = tSam.parameters.length; i < length; i++) {", "-\t\t\tif (TypeBinding.notEquals(tSam.parameters[i], sSam.parameters[i]))", "+\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "+\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\tif (sSam.returnType.id == TypeIds.T_void)", "+\t\tif (tSam.returnType.id == TypeIds.T_void)", "-\t\tExpression resultExpression = (Expression) this.resultExpressions.get(t); // should be same as for s", "+\t\tExpression resultExpression = (Expression) this.resultExpressions.get(s); // should be same as for s", "-\t\tt = t.capture(this.enclosingScope, this.sourceEnd);", "-\t\ttSam = t.getSingleAbstractMethod(this.enclosingScope);", "-\t\treturn resultExpression.tIsMoreSpecific(tSam.returnType, sSam.returnType);", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tsSam = s.getSingleAbstractMethod(this.enclosingScope);", "+\t\treturn resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType);"]}], "num": 57337}