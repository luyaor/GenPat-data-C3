{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "47dd17cf435ab4bd38e40023df733e9a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "313373deb58617b9edab7a8395d34dfd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\tif (receiverType == null) break checkParameterizedAllocation;", "+\t\t\t\t\tif (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;", "-\t\tif (receiverType == null) {", "+\t\tif (receiverType == null || !receiverType.isValidBinding()) {", "+\t\t", "+\t\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\t\tTypeReference typeReference = this.typeArguments[i];\t\t\t\t", "-\t\t\t\tTypeBinding argType = typeReference.resolveType(scope, true /* check bounds*/);", "-\t\t\t\tif (argType == null) {", "-\t\t\t\t\tif (typeReference instanceof Wildcard) {", "-\t\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn null; // error already reported", "+\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\targHasError = true;", "-\t\t\t\tthis.genericTypeArguments[i] = argType;", "+\t\t\t\tif (argHasError && typeReference instanceof Wildcard) {", "+\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t\t", "+\t\t\t\treturn null;", "+\t", "-\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "-\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "-\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "-\t\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "-\t\t\t\t}", "-\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this);", "-\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\t\t\t\tif (closestMatch != null) {", "-\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "-\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.binding = closestMatch;", "-\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "-\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "-\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tif (receiverType.isValidBinding()) {", "+\t\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "+\t\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "+\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this);", "+\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\treturn null;", "+\t\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "+\t\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\t\treturn null;", "+\t\t\t\t}\t\t\t\t\t", "-", "+\t\t\tif ((this.binding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "+\t\t\t}", "-\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance);", "+\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);", "-\t\t\tsuperType = new ProblemReferenceBinding(superType.sourceName(), superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\tsuperType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "+\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\treturn null;", "+\t\t\t}\t\t", "+\t\t}", "+\t\tif ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tscope.problemReporter().missingTypeInConstructor(this, inheritedBinding);", "-\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance);", "+\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aacab318a427d6b40bbf283fc3b248d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tconstant = Constant.NotAConstant;", "+\tthis.constant = Constant.NotAConstant;", "-\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\tthis.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\tthis.actualReceiverType = receiver.resolveType(scope); ", "-\tboolean receiverIsType = receiver instanceof NameReference && (((NameReference) receiver).bits & Binding.TYPE) != 0;", "+\tthis.actualReceiverType = this.receiver.resolveType(scope); ", "+\tboolean receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;", "-\tif (arguments != null) {", "+\tif (this.arguments != null) {", "-\t\tint length = arguments.length;", "+\t\tint length = this.arguments.length;", "-\t\t\tExpression argument = arguments[i];", "+\t\t\tExpression argument = this.arguments[i];", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\targument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "-\t\t\tif (actualReceiverType instanceof ReferenceBinding) {", "+\t\t\tif (this.actualReceiverType instanceof ReferenceBinding) {", "-\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? actualReceiverType : argumentTypes[i]; // replace args with errors with receiver", "+\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "-\t\t\t\t\treceiver.isImplicitThis()", "-\t\t\t\t\t\t? scope.getImplicitMethod(selector, pseudoArgs, this)", "-\t\t\t\t\t\t: scope.findMethod((ReferenceBinding) actualReceiverType, selector, pseudoArgs, this);", "-\t\t\t\tif (binding != null && !binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\t\t\t\tthis.receiver.isImplicitThis()", "+\t\t\t\t\t\t? scope.getImplicitMethod(this.selector, pseudoArgs, this)", "+\t\t\t\t\t\t: scope.findMethod((ReferenceBinding) this.actualReceiverType, this.selector, pseudoArgs, this);", "+\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif ((closestMatch.isPrivate() || closestMatch.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatch)) {", "+\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\tclosestMatch.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\t\treceiver.isImplicitThis()", "-\t\t\t? scope.getImplicitMethod(selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(this.actualReceiverType, selector, argumentTypes, this); ", "-\tif (!binding.isValidBinding()) {", "-\t\tif (binding.declaringClass == null) {", "+\t\tthis.receiver.isImplicitThis()", "+\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "+\t\t\t: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this); ", "+\tif (!this.binding.isValidBinding()) {", "+\t\tif (this.binding.declaringClass == null) {", "-\t\t\t\tbinding.declaringClass = (ReferenceBinding) this.actualReceiverType;", "+\t\t\t\tthis.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;", "-\t\tscope.problemReporter().invalidMethod(this, binding);", "-\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\tscope.problemReporter().invalidMethod(this, this.binding);", "+\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\tif ((closestMatch.isPrivate() || closestMatch.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatch)) {", "+\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();\t\t\t", "+\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\tclosestMatch.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "-\tif (!binding.isStatic()) {", "+\tif (!this.binding.isStatic()) {", "-\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\t\t\t\t\t&& (this.receiver.bits & IgnoreRawTypeCheck) == 0 ", "+\t\t\t\t\t&& (this.receiver.bits & ASTNode.IgnoreRawTypeCheck) == 0 ", "-\t\t\treceiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "+\t\t\tthis.receiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "-\t\tif (!(receiver.isImplicitThis() || receiver.isSuper() || receiverIsType)) {", "-\t\t\tscope.problemReporter().nonStaticAccessToStaticMethod(this, binding);", "+\t\tif (!(this.receiver.isImplicitThis() || this.receiver.isSuper() || receiverIsType)) {", "+\t\t\tscope.problemReporter().nonStaticAccessToStaticMethod(this, this.binding);", "-\t\tif (!receiver.isImplicitThis() && binding.declaringClass != actualReceiverType) {", "-\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, binding);", "+\t\tif (!this.receiver.isImplicitThis() && this.binding.declaringClass != this.actualReceiverType) {", "+\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "-\tcheckInvocationArguments(scope, this.receiver, actualReceiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "+\tcheckInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this);", "-\tif (binding.isAbstract()) {", "-\t\tif (receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "+\tif (this.binding.isAbstract()) {", "+\t\tif (this.receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\tif (isMethodUseDeprecated(binding, scope, true))", "-\t\tscope.problemReporter().deprecatedMethod(binding, this);", "+\tif (isMethodUseDeprecated(this.binding, scope, true))", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\tif (actualReceiverType.isArrayType() ", "+\tif (this.actualReceiverType.isArrayType() ", "-\t\t\t&& CharOperation.equals(this.binding.selector, CLONE)) {", "-\t\tthis.resolvedType = actualReceiverType;", "+\t\t\t&& CharOperation.equals(this.binding.selector, TypeConstants.CLONE)) {", "+\t\tthis.resolvedType = this.actualReceiverType;", "-\tif (receiver.isSuper() && compilerOptions.getSeverity(CompilerOptions.OverridingMethodWithoutSuperInvocation) != ProblemSeverities.Ignore) {", "+\tif (this.receiver.isSuper() && compilerOptions.getSeverity(CompilerOptions.OverridingMethodWithoutSuperInvocation) != ProblemSeverities.Ignore) {"]}], "num": 48481}