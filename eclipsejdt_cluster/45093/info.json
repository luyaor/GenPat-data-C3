{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "70c71e446b00cd03bc73f9fe8912427a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "184fbc5da70b1cfcfead71a57686d6f4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "30dfd49146d073c0ca77ec54f45987be483492de", "commitAfterChange": "b6791838b5fdf2dfb8325a3a5a7e1c11f48ab412", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// Answer the signature type of the field.", "-\t\t// constants are propaged when the field is final", "-\t\t// and initialized with a (compile time) constant ", "-\t\t//always ignore receiver cast, since may affect constant pool reference", "-\t\tboolean receiverCast = false;", "-\t\tif (this.receiver instanceof CastExpression) {", "-\t\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\treceiverCast = true;", "-\t\t}", "-\t\tthis.receiverType = receiver.resolveType(scope);", "-\t\tif (this.receiverType == null) {", "-\t\t\tconstant = NotAConstant;", "-\t\t\treturn null;", "-\t\t}", "-\t\tif (receiverCast) {", "-\t\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "-\t\t\tif (((CastExpression)this.receiver).expression.resolvedType == this.receiverType) { ", "-\t\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "-\t\t\t}", "-\t\t}\t\t", "-\t\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API", "-\t\tFieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);", "-\t\tif (!fieldBinding.isValidBinding()) {", "-\t\t\tconstant = NotAConstant;", "-\t\t\tscope.problemReporter().invalidField(this, this.receiverType);", "-\t\t\treturn null;", "-\t\t}", "-\t\tTypeBinding receiverErasure = this.receiverType.erasure();", "-\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeWithSameErasure(fieldBinding.declaringClass);", "-\t\t\tif (match == null) {", "-\t\t\t\tthis.receiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t}", "-\t\t}", "-\t\tthis.receiver.computeConversion(scope, this.receiverType, this.receiverType);", "-\t\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssigned) !=0)) {", "-\t\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "-\t\t}", "-\t\tboolean isImplicitThisRcv = receiver.isImplicitThis();", "-\t\tconstant = FieldReference.getConstantFor(fieldBinding, this, isImplicitThisRcv, scope);", "-\t\tif (!isImplicitThisRcv) {", "-\t\t\tconstant = NotAConstant;", "-\t\t}", "-\t\tif (fieldBinding.isStatic()) {", "-\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "-\t\t\tif (!(isImplicitThisRcv", "-\t\t\t\t\t|| (receiver instanceof NameReference ", "-\t\t\t\t\t\t&& (((NameReference) receiver).bits & Binding.TYPE) != 0))) {", "-\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, fieldBinding);", "-\t\t\t}", "-\t\t\tif (!isImplicitThisRcv && fieldBinding.declaringClass != receiverType) {", "-\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, fieldBinding);", "-\t\t\t}", "-\t\t}", "-\t\t// perform capture conversion if read access", "-\t\treturn this.resolvedType = ", "-\t\t\t(((this.bits & IsStrictlyAssigned) == 0) ", "-\t\t\t\t? fieldBinding.type.capture(scope, this.sourceEnd)", "-\t\t\t\t: fieldBinding.type);", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// Answer the signature type of the field.", "+\t// constants are propaged when the field is final", "+\t// and initialized with a (compile time) constant ", "+", "+\t//always ignore receiver cast, since may affect constant pool reference", "+\tboolean receiverCast = false;", "+\tif (this.receiver instanceof CastExpression) {", "+\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\treceiverCast = true;", "+\tthis.receiverType = receiver.resolveType(scope);", "+\tif (this.receiverType == null) {", "+\t\tconstant = Constant.NotAConstant;", "+\t\treturn null;", "+\tif (receiverCast) {", "+\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "+\t\tif (((CastExpression)this.receiver).expression.resolvedType == this.receiverType) { ", "+\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "+\t\t}", "+\t}\t\t", "+\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API", "+\tFieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);", "+\tif (!fieldBinding.isValidBinding()) {", "+\t\tconstant = Constant.NotAConstant;", "+\t\tscope.problemReporter().invalidField(this, this.receiverType);", "+\t\treturn null;", "+\t}", "+\tTypeBinding receiverErasure = this.receiverType.erasure();", "+\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeWithSameErasure(fieldBinding.declaringClass);", "+\t\tif (match == null) {", "+\t\t\tthis.receiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\tthis.receiver.computeConversion(scope, this.receiverType, this.receiverType);", "+\tif (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssigned) !=0)) {", "+\t\tscope.problemReporter().deprecatedField(fieldBinding, this);", "+\tboolean isImplicitThisRcv = receiver.isImplicitThis();", "+\tconstant = isImplicitThisRcv ? fieldBinding.constant() : Constant.NotAConstant;", "+\tif (!isImplicitThisRcv) {", "+\t\tconstant = Constant.NotAConstant;", "+\t}", "+\tif (fieldBinding.isStatic()) {", "+\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "+\t\tif (!(isImplicitThisRcv", "+\t\t\t\t|| (receiver instanceof NameReference ", "+\t\t\t\t\t&& (((NameReference) receiver).bits & Binding.TYPE) != 0))) {", "+\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, fieldBinding);", "+\t\tif (!isImplicitThisRcv && fieldBinding.declaringClass != receiverType) {", "+\t\t\tscope.problemReporter().indirectAccessToStaticField(this, fieldBinding);", "+\t\t}", "+\t// perform capture conversion if read access", "+\treturn this.resolvedType = ", "+\t\t(((this.bits & IsStrictlyAssigned) == 0) ", "+\t\t\t? fieldBinding.type.capture(scope, this.sourceEnd)", "+\t\t\t: fieldBinding.type);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "517c1aae00d0db5eaac05734cc1665a6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java", "commitBeforeChange": "30dfd49146d073c0ca77ec54f45987be483492de", "commitAfterChange": "b6791838b5fdf2dfb8325a3a5a7e1c11f48ab412", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tthis.constant = NotAConstant;", "+\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\t\tthis.constant = Constant.NotAConstant;", "-\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\tthis.constant = Constant.NotAConstant;", "-\t\tthis.constant = NotAConstant;", "+\t\tthis.constant = Constant.NotAConstant;", "-\tthis.constant = FieldReference.getConstantFor(this.binding, this, this.receiver.isImplicitThis(), scope);", "+\tthis.constant = this.receiver.isImplicitThis() ? this.binding.constant() : Constant.NotAConstant;", "-\t\tthis.constant = NotAConstant;", "+\t\tthis.constant = Constant.NotAConstant;"]}], "num": 45093}