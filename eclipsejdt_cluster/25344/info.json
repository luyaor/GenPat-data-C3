{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "79befd6642aa23c7f6000c69874b29d9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bbcc36c1ac33438c6dfbd61f738f802", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "618a6ff3d34de5a5e41db8b1f1893c42061e44cd", "commitAfterChange": "71dea98c1d878b28c8144aaff13d309d86912875", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tprivate static void checkContainingAnnotationTarget(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation)", "signatureAfterChange": " \tprivate static void checkContainerAnnotationTypeTarget(ASTNode culpritNode, Scope scope, ReferenceBinding containerType, ReferenceBinding repeatableAnnotationType)", "diff": ["-\tprivate static void checkContainingAnnotationTarget(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {", "-\t\tlong tagBits = repeatableAnnotation.getAnnotationTagBits();", "-\t\tif ((tagBits & TagBits.AnnotationTargetMASK) != 0) { ", "-\t\t\tlong containingTagBits = container.getAnnotationTagBits();", "-\t\t\tif ((containingTagBits & TagBits.AnnotationTargetMASK) == 0) {", "-\t\t\t\trepeatableAnnotation.tagAsHavingDefectiveContainerType();", "-\t\t\t\tscope.problemReporter().repeatableAnnotationHasTargets(markerNode, repeatableAnnotation, container);", "-\t\t\t} else {", "-\t\t\t\tfinal long targets = tagBits & TagBits.AnnotationTargetMASK;", "-\t\t\t\tfinal long containingTargets = containingTagBits & TagBits.AnnotationTargetMASK;", "-\t\t\t\t", "-\t\t\t\tif ((containingTargets & ~targets) != 0) {", "-\t\t\t\t\tclass MissingTargetBuilder {", "-\t\t\t\t\t\tStringBuffer targetBuffer = new StringBuffer();", "-\t\t\t\t\t\tvoid check(long targetMask, char[] targetName) {", "-\t\t\t\t\t\t\tif ((containingTargets & targetMask & ~targets) != 0) {", "-\t\t\t\t\t\t\t\tadd(targetName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tvoid checkAnnotationType(char[] targetName) {", "-\t\t\t\t\t\t\tif ((containingTargets & TagBits.AnnotationForAnnotationType) != 0 &&", "-\t\t\t\t\t\t\t\t\t((targets & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))) == 0) {", "-\t\t\t\t\t\t\t\tadd(targetName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tprivate void add(char[] targetName) {", "-\t\t\t\t\t\t\tif (this.targetBuffer.length() != 0) {", "-\t\t\t\t\t\t\t\tthis.targetBuffer.append(\", \"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.targetBuffer.append(targetName);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic String toString() {", "-\t\t\t\t\t\t\treturn this.targetBuffer.toString();", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpublic boolean hasError() {", "-\t\t\t\t\t\t\treturn this.targetBuffer.length() != 0;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tMissingTargetBuilder builder = new MissingTargetBuilder();", "+\tprivate static void checkContainerAnnotationTypeTarget(ASTNode culpritNode, Scope scope, ReferenceBinding containerType, ReferenceBinding repeatableAnnotationType) {", "+\t\tlong tagBits = repeatableAnnotationType.getAnnotationTagBits();", "+\t\tif ((tagBits & TagBits.AnnotationTargetMASK) == 0)", "+\t\t\ttagBits = TagBits.SE7AnnotationTargetMASK; // absence of @Target meta-annotation implies all SE7 targets not all targets.", "+\t\t", "+\t\tlong containerAnnotationTypeTypeTagBits = containerType.getAnnotationTagBits();", "+\t\tif ((containerAnnotationTypeTypeTagBits & TagBits.AnnotationTargetMASK) == 0)", "+\t\t\tcontainerAnnotationTypeTypeTagBits = TagBits.SE7AnnotationTargetMASK;", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForType, TypeConstants.TYPE);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForField, TypeConstants.UPPER_FIELD);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForMethod, TypeConstants.UPPER_METHOD);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForParameter, TypeConstants.UPPER_PARAMETER);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForConstructor, TypeConstants.UPPER_CONSTRUCTOR);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForLocalVariable, TypeConstants.UPPER_LOCAL_VARIABLE);", "-\t\t\t\t\tbuilder.checkAnnotationType(TypeConstants.UPPER_ANNOTATION_TYPE);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForPackage, TypeConstants.UPPER_PACKAGE);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForTypeParameter, TypeConstants.TYPE_PARAMETER_TARGET);", "-\t\t\t\t\tbuilder.check(TagBits.AnnotationForTypeUse, TypeConstants.TYPE_USE_TARGET);", "-\t\t\t\t\tif (builder.hasError()) {", "-\t\t\t\t\t\trepeatableAnnotation.tagAsHavingDefectiveContainerType();", "-\t\t\t\t\t\tscope.problemReporter().repeatableAnnotationTargetMismatch(markerNode, repeatableAnnotation, container, builder.toString());", "+\t\tfinal long targets = tagBits & TagBits.AnnotationTargetMASK;", "+\t\tfinal long containerAnnotationTypeTargets = containerAnnotationTypeTypeTagBits & TagBits.AnnotationTargetMASK;", "+", "+\t\tif ((containerAnnotationTypeTargets & ~targets) != 0) {", "+\t\t\tclass MissingTargetBuilder {", "+\t\t\t\tStringBuffer targetBuffer = new StringBuffer();", "+\t\t\t\tvoid check(long targetMask, char[] targetName) {", "+\t\t\t\t\tif ((containerAnnotationTypeTargets & targetMask & ~targets) != 0) {", "+\t\t\t\t\t\tadd(targetName);", "+\t\t\t\tvoid checkAnnotationType(char[] targetName) {", "+\t\t\t\t\tif ((containerAnnotationTypeTargets & TagBits.AnnotationForAnnotationType) != 0 &&", "+\t\t\t\t\t\t\t((targets & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))) == 0) {", "+\t\t\t\t\t\tadd(targetName);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tprivate void add(char[] targetName) {", "+\t\t\t\t\tif (this.targetBuffer.length() != 0) {", "+\t\t\t\t\t\tthis.targetBuffer.append(\", \"); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.targetBuffer.append(targetName);", "+\t\t\t\t}", "+\t\t\t\tpublic String toString() {", "+\t\t\t\t\treturn this.targetBuffer.toString();", "+\t\t\t\t}", "+\t\t\t\tpublic boolean hasError() {", "+\t\t\t\t\treturn this.targetBuffer.length() != 0;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tMissingTargetBuilder builder = new MissingTargetBuilder();", "+", "+\t\t\tbuilder.check(TagBits.AnnotationForType, TypeConstants.TYPE);", "+\t\t\tbuilder.check(TagBits.AnnotationForField, TypeConstants.UPPER_FIELD);", "+\t\t\tbuilder.check(TagBits.AnnotationForMethod, TypeConstants.UPPER_METHOD);", "+\t\t\tbuilder.check(TagBits.AnnotationForParameter, TypeConstants.UPPER_PARAMETER);", "+\t\t\tbuilder.check(TagBits.AnnotationForConstructor, TypeConstants.UPPER_CONSTRUCTOR);", "+\t\t\tbuilder.check(TagBits.AnnotationForLocalVariable, TypeConstants.UPPER_LOCAL_VARIABLE);", "+\t\t\tbuilder.checkAnnotationType(TypeConstants.UPPER_ANNOTATION_TYPE);", "+\t\t\tbuilder.check(TagBits.AnnotationForPackage, TypeConstants.UPPER_PACKAGE);", "+\t\t\tbuilder.check(TagBits.AnnotationForTypeParameter, TypeConstants.TYPE_PARAMETER_TARGET);", "+\t\t\tbuilder.check(TagBits.AnnotationForTypeUse, TypeConstants.TYPE_USE_TARGET);", "+\t\t\tif (builder.hasError()) {", "+\t\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\t\tscope.problemReporter().repeatableAnnotationTargetMismatch(culpritNode, repeatableAnnotationType, containerType, builder.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f5a3fff9c946517451877c502324871", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "ea035aff9493ec8381c8d6bd9548845ad9f81e22", "commitAfterChange": "3c8b95412c50bb73a8372fbf9db9df68231cc311", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "  \tpublic static void checkContainingAnnotation(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation)", "signatureAfterChange": "  \tpublic static void checkContainerAnnotationType(ASTNode culpritNode, BlockScope scope, ReferenceBinding containerAnnotationType, ReferenceBinding repeatableAnnotationType, boolean useSite)", "diff": ["-\tpublic static void checkContainingAnnotation(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {", "-\t\tMethodBinding[] annotationMethods = container.methods();", "+\tpublic static void checkContainerAnnotationType(ASTNode culpritNode, BlockScope scope, ReferenceBinding containerAnnotationType, ReferenceBinding repeatableAnnotationType, boolean useSite) {", "+\t\tMethodBinding[] annotationMethods = containerAnnotationType.methods();", "-\t\t\t\t\tif (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotation)) continue;", "+\t\t\t\t\tif (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotationType)) continue;", "-\t\t\t\tscope.problemReporter().containingAnnotationHasWrongValueType(markerNode, container, repeatableAnnotation, method.returnType);", "+\t\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\t\tscope.problemReporter().containingAnnotationHasWrongValueType(culpritNode, containerAnnotationType, repeatableAnnotationType, method.returnType);", "-\t\t\t\t// Not the value() - must have default (or else isn't suitable as container", "+\t\t\t\t// Not the value() - must have default (or else isn't suitable as container)", "-\t\t\t\t\tscope.problemReporter().containingAnnotationHasNonDefaultMembers(markerNode, container, method.selector);", "+\t\t\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\t\t\tscope.problemReporter().containingAnnotationHasNonDefaultMembers(culpritNode, containerAnnotationType, method.selector);", "-\t\t\tscope.problemReporter().containingAnnotationMustHaveValue(markerNode, container);", "+\t\t\trepeatableAnnotationType.tagAsHavingDefectiveContainerType();", "+\t\t\tscope.problemReporter().containingAnnotationMustHaveValue(culpritNode, containerAnnotationType);", "-\t\tcheckContainingAnnotationRetention(markerNode, scope, container, repeatableAnnotation);", "-\t\tif (markerNode instanceof Annotation)", "-\t\t\tcheckContainingAnnotationTarget((Annotation) markerNode, (BlockScope) scope, (TypeBinding) container, repeatableAnnotation);", "-\t\telse", "-\t\t\tcheckContainingAnnotationTarget(markerNode, scope, container, repeatableAnnotation);", "-\t\tcheckContaintAnnotationDocumented(markerNode, scope, container, repeatableAnnotation);", "-\t\tcheckContaintAnnotationInherited(markerNode, scope, container, repeatableAnnotation);", "-\t}", "+\t\tcheckContainingAnnotationRetention(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "+\t\t", "+\t\tif (useSite)", "+\t\t\tcheckContainingAnnotationTargetAtUse((Annotation) culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "+\t\telse ", "+\t\t\tcheckContainingAnnotationTarget(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "+\t\t", "+\t\tcheckContaintAnnotationDocumented(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);", "+\t\tcheckContaintAnnotationInherited(culpritNode, scope, containerAnnotationType, repeatableAnnotationType);"]}], "num": 25344}