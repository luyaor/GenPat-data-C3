{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a58c39d72ec4b3f7c4e3a4ef4055800a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "420465441c05c9aa091b6a8ee5968182", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/UserLibraryManager.java", "commitBeforeChange": "2fdac50d0a994a41e3b73d3202a0de983b014e1d", "commitAfterChange": "5291cd66203d5d42725b1c4b5cba50a5232bc244", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \t\tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event)", "signatureAfterChange": "  \tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event)", "diff": ["-\t\tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event) {", "-\t\t\tString key= event.getKey();", "-\t\t\tif (key.startsWith(CP_USERLIBRARY_PREFERENCES_PREFIX)) {", "-\t\t\t\ttry {", "-\t\t\t\t\trecreatePersistedUserLibraryEntry(key, (String) event.getNewValue(), false, true);", "-\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\tif (logProblems) {", "-\t\t\t\t\t\tUtil.log(e, \"Exception while rebinding user library '\"+ key.substring(CP_USERLIBRARY_PREFERENCES_PREFIX.length()) +\"'.\"); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event) {", "+\t\tString key = event.getKey();", "+\t\tif (key.startsWith(CP_USERLIBRARY_PREFERENCES_PREFIX)) {", "+\t\t\tString libName = key.substring(CP_USERLIBRARY_PREFERENCES_PREFIX.length());", "+\t\t\t\t// find affected projects", "+\t\t\t\tIPath containerPath = new Path(JavaCore.USER_LIBRARY_CONTAINER_ID).append(libName);", "+\t\t\t\tIJavaProject[] allJavaProjects = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProjects();", "+\t\t\t\tArrayList affectedProjects = new ArrayList();", "+\t\t\t\tfor (int i= 0; i < allJavaProjects.length; i++) {", "+\t\t\t\t\tIJavaProject javaProject = allJavaProjects[i];", "+\t\t\t\t\tIClasspathEntry[] entries= javaProject.getRawClasspath();", "+\t\t\t\t\tfor (int j= 0; j < entries.length; j++) {", "+\t\t\t\t\t\tIClasspathEntry entry = entries[j];", "+\t\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {", "+\t\t\t\t\t\t\tif (containerPath.equals(entry.getPath())) {", "+\t\t\t\t\t\t\t\taffectedProjects.add(javaProject);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}\t\t\t\t", "+\t\t\t\t", "+\t\t\t\t// decode user library", "+\t\t\t\tString encodedUserLibrary = (String) event.getNewValue();", "+\t\t\t\tUserLibrary userLibrary = encodedUserLibrary == null ? null : UserLibrary.createFromString(new StringReader(encodedUserLibrary));", "+\t\t\t\t", "+\t\t\t\t// update user libraries map", "+\t\t\t\tif (userLibrary != null) {", "+\t\t\t\t\tthis.userLibraries.put(libName, userLibrary);", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.userLibraries.remove(libName);", "+\t\t\t\t", "+\t\t\t\t// update affected projects", "+\t\t\t\tint length = affectedProjects.size();", "+\t\t\t\tif (length == 0)", "+\t\t\t\t\treturn;", "+\t\t\t\tIJavaProject[] projects = new IJavaProject[length];", "+\t\t\t\taffectedProjects.toArray(projects);", "+\t\t\t\tIClasspathContainer[] containers = new IClasspathContainer[length];", "+\t\t\t\tif (userLibrary != null) {", "+\t\t\t\t\tUserLibraryClasspathContainer container = new UserLibraryClasspathContainer(libName);", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tcontainers[i] = container;", "+\t\t\t\tJavaCore.setClasspathContainer(containerPath, projects, containers, null);", "+\t\t\t} catch (IOException e) {", "+\t\t\t\tUtil.log(e, \"Exception while decoding user library '\"+ libName +\"'.\"); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\tUtil.log(e, \"Exception while setting user library '\"+ libName +\"'.\"); //$NON-NLS-1$ //$NON-NLS-2$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "590844b355f60a4eccdb3c49a9638d6a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 67, "signatureBeforeChange": " \tprivate void computeExpectedTypes(ASTNode parent, Scope scope)", "signatureAfterChange": " \tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope)", "diff": ["-\tprivate void computeExpectedTypes(ASTNode parent, Scope scope){", "+\tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope){", "+\t\t\t\tBinaryExpression binaryExpression = (BinaryExpression) parent;", "+\t\t\t\tif(operator == OperatorIds.LESS) {", "+\t\t\t\t\tif(binaryExpression.left instanceof SingleNameReference){", "+\t\t\t\t\t\tSingleNameReference name = (SingleNameReference) binaryExpression.left;", "+\t\t\t\t\t\tBinding b = scope.getBinding(name.token, BindingIds.VARIABLE | BindingIds.TYPE, name, false);", "+\t\t\t\t\t\tif(b instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tTypeVariableBinding[] typeVariableBindings =((ReferenceBinding)b).typeVariables();", "+\t\t\t\t\t\t\tif(typeVariableBindings != null && typeVariableBindings.length > 0) {", "+\t\t\t\t\t\t\t\taddExpectedType(typeVariableBindings[0].firstBound);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t} else if(parent instanceof ParameterizedSingleTypeReference) {", "+\t\t\tParameterizedSingleTypeReference ref = (ParameterizedSingleTypeReference) parent;", "+\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "+\t\t\tint length = ref.typeArguments == null ? 0 : ref.typeArguments.length;", "+\t\t\tif(typeVariables != null && typeVariables.length >= length) {", "+\t\t\t\tint index = length - 1;", "+\t\t\t\twhile(index > -1 && ref.typeArguments[index] != node) index--;", "+\t\t\t\taddExpectedType(typeVariables[index].firstBound);", "+\t\t\t}", "+\t\t} else if(parent instanceof ParameterizedQualifiedTypeReference) {", "+\t\t\tParameterizedQualifiedTypeReference ref = (ParameterizedQualifiedTypeReference) parent;", "+\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "+\t\t\tTypeReference[][] arguments = ref.typeArguments;", "+\t\t\tif(typeVariables != null) {", "+\t\t\t\tint iLength = arguments == null ? 0 : arguments.length;", "+\t\t\t\tdone: for (int i = 0; i < iLength; i++) {", "+\t\t\t\t\tint jLength = arguments[i] == null ? 0 : arguments[i].length;", "+\t\t\t\t\tfor (int j = 0; j < jLength; j++) {", "+\t\t\t\t\t\tif(arguments[i][j] == node && typeVariables.length >= j) {", "+\t\t\t\t\t\t\taddExpectedType(typeVariables[j].firstBound);", "+\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93a6c21e0bfd369ec3ab93b54fac06b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LambdaExpression.java", "commitBeforeChange": "ca289ff4e9317024e3c3a344a3b266fd883ffd1d", "commitAfterChange": "aacce274176303cc524a6360232ca1201922c452", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \t@Override \tpublic String getTypeQualifiedName()", "signatureAfterChange": " \t \tpublic IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner workingCopyOwner)", "diff": ["+\t", "+\tpublic IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner workingCopyOwner) {", "+\t\tif (token.charAt(0) != JEM_LAMBDA_METHOD)", "+\t\t\treturn null;", "+\t\t", "+\t\t// ----", "+\t\tif (!memento.hasMoreTokens()) return this;", "+\t\tString selector = memento.nextToken();", "+\t\tif (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_COUNT) return this;", "+\t\tif (!memento.hasMoreTokens()) return this;", "+\t\tint length = Integer.parseInt(memento.nextToken());", "+\t\tString [] parameterTypes = new String[length];", "+\t\tString [] parameterNames = new String[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;", "+\t\t\tparameterTypes[i] = memento.nextToken();", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;", "+\t\t\tparameterNames[i] = memento.nextToken();", "+\t\t}", "+\t\tif (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;", "+\t\tString returnType = memento.nextToken();", "+\t\tif (!memento.hasMoreTokens() || memento.nextToken().charAt(0) != JEM_STRING) return this;", "+\t\tString key = memento.nextToken();", "+\t\tthis.lambdaMethod = LambdaMethod.make(this, selector, key, this.sourceStart, this.sourceEnd, this.arrowPosition, parameterTypes, parameterNames, returnType);", "+\t\tILocalVariable [] parameters = new ILocalVariable[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tparameters[i] = (ILocalVariable) this.lambdaMethod.getHandleFromMemento(memento, workingCopyOwner);", "+\t\t}", "+\t\tthis.lambdaMethod.elementInfo.arguments  = parameters;", "+\t\tthis.elementInfo.children = new IJavaElement[] { this.lambdaMethod };", "+\t\treturn this.lambdaMethod;", "-", "-\t@Override", "-\tpublic String getTypeQualifiedName() {", "-\t\treturn null;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2bde0fe4424fecccf4bea68c48b4ee0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method)", "signatureAfterChange": "  \tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException", "diff": ["-\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method) {", "+\tprivate boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException {", "+\t\t", "+\t\t// See https://bugs.openjdk.java.net/browse/JDK-8052325 for exclusion of poly expressions targeting proper types. CEF.reduce validates ", "+\t\t// that they are compatible in a loose invocation context against the target type. They contribute nothing further to solving the formulas.", "+\t\tif (substF.isProperType(true))", "+\t\t\treturn true;", "+\t\t", "+\t\t\tif (expri instanceof LambdaExpression) {", "+\t\t\t\tLambdaExpression lambda = (LambdaExpression) expri;", "+\t\t\t\tBlockScope skope = lambda.enclosingScope;", "+\t\t\t\tif (substF.isFunctionalInterface(skope)) { // could be an inference variable.", "+\t\t\t\t\tReferenceBinding t = (ReferenceBinding) substF;", "+\t\t\t\t\tParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(t);", "+\t\t\t\t\tif (withWildCards != null) {", "+\t\t\t\t\t\tt = ConstraintExpressionFormula.findGroundTargetType(this, skope, lambda, withWildCards);", "+\t\t\t\t\t}", "+\t\t\t\t\tMethodBinding functionType;", "+\t\t\t\t\tif (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.getResolvedCopyForInferenceTargeting(t)) != null) {", "+\t\t\t\t\t\tTypeBinding r = functionType.returnType;", "+\t\t\t\t\t\tExpression[] resultExpressions = lambda.resultExpressions();", "+\t\t\t\t\t\tfor (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {", "+\t\t\t\t\t\t\tExpression resultExpression = resultExpressions[i];", "+\t\t\t\t\t\t\tif (!addConstraintsToC_OneExpr(resultExpression, c, r.original(), r, method, true))", "+\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\tMethodBinding innerMethod = invocation.binding(null, false, null);", "+\t\t\tMethodBinding innerMethod = invocation.binding(substF, this.scope);", "+\t\t\tif (innerMethod == null)", "+\t\t\t\treturn true; \t\t  // -> proceed with no new C set elements.", "+\t\t\t", "+\t\t\tif (interleaved) {", "+\t\t\t\tMethodBinding shallowMethod = innerMethod.shallowOriginal();", "+\t\t\t\tSuspendedInferenceRecord prevInvocation = enterPolyInvocation(invocation, invocation.arguments());", "+\t\t\t\ttry {", "+\t\t\t\t\tExpression[] arguments = invocation.arguments();", "+\t\t\t\t\tTypeBinding[] argumentTypes = arguments == null ? Binding.NO_PARAMETERS : new TypeBinding[arguments.length];", "+\t\t\t\t\tfor (int i = 0; i < argumentTypes.length; i++)", "+\t\t\t\t\t\targumentTypes[i] = arguments[i].resolvedType;", "+\t\t\t\t\tif (innerMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tInferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) innerMethod);", "+\t\t\t\t\t\tthis.inferenceKind = innerCtx.inferenceKind;", "+\t\t\t\t\t}", "+\t\t\t\t\tinferInvocationApplicability(shallowMethod, argumentTypes, shallowMethod.isConstructor());", "+\t\t\t\t\tif (!ConstraintExpressionFormula.inferPolyInvocationType(this, invocation, substF, shallowMethod))", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t} finally {", "+\t\t\t\t\tresumeSuspendedInference(prevInvocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tint applicabilityKind = CHECK_LOOSE;  // FIXME, for <> resolving to a non-generic method, this need to be computed.", "-\t\t\t\tif (innerCtx != null) { // otherwise innerMethod does not participate in inference", "-\t\t\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), innerCtx.inferenceKind);", "+\t\t\t\tif (innerCtx != null) {", "+\t\t\t\t\tapplicabilityKind = innerCtx.inferenceKind;", "+\t\t\treturn addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), applicabilityKind, interleaved);", "-\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method)", "-\t\t\t\t && addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method);", "+\t\t\treturn addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method, interleaved)", "+\t\t\t\t\t&& addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method, interleaved);", "-\t}"]}], "num": 30431}