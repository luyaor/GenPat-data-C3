{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "72d61f953fdb95030b916483b3de8426", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09c732ea55e2ff58dc8c49f8a98d716a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 73, "signatureBeforeChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "signatureAfterChange": " public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException", "diff": ["- */", "-public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "-\t", "-\t// if factory is null, default factory must be used", "-\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "-", "-\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t", "-\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t// AND use the same buffer factory.", "-\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "-\t", "-\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(factory);", "-\tif (perFactoryWorkingCopies == null){", "-\t\tperFactoryWorkingCopies = new HashMap();", "-\t\tsharedWorkingCopies.put(factory, perFactoryWorkingCopies);", "-\t}", "-\tWorkingCopy workingCopy = (WorkingCopy)perFactoryWorkingCopies.get(this);", "-\tif (workingCopy != null) {", "-\t\tworkingCopy.useCount++;", "-", "-\t\tif (SHARED_WC_VERBOSE) {", "-\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "-\t\t}", "-", "-\t\treturn workingCopy;", "-\t} else {", "-\t\tCreateWorkingCopyOperation op = new CreateWorkingCopyOperation(this, perFactoryWorkingCopies, factory, problemRequestor);", "-\t\trunOperation(op, pm);", "-\t\treturn op.getResultElements()[0];", "-\t}", "-}", "+ */", "+public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {", "+\t", "+\tif (isWorkingCopy()) return this;", "+\t", "+\t// if factory is null, default factory must be used", "+\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "+", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t", "+\t// In order to be shared, working copies have to denote the same compilation unit ", "+\t// AND use the same buffer factory.", "+\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "+\tMap sharedWorkingCopies = manager.sharedWorkingCopies;", "+\t", "+\tCompilationUnitOwner workingCopyOwner = new DefaultCompilationUnitOwner(factory, problemRequestor);", "+\tMap perOwnerWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);", "+\tif (perOwnerWorkingCopies == null){", "+\t\tperOwnerWorkingCopies = new HashMap();", "+\t\tsharedWorkingCopies.put(workingCopyOwner, perOwnerWorkingCopies);", "+\t}", "+\tCompilationUnit workingCopy = (CompilationUnit)perOwnerWorkingCopies.get(this);", "+\tif (workingCopy != null) {", "+\t\tObject info = manager.getInfo(workingCopy);", "+\t\tif (info instanceof WorkingCopyElementInfo) {", "+\t\t\t((WorkingCopyElementInfo)info).incrementUseCount();", "+", "+\t\t\tif (SHARED_WC_VERBOSE) {", "+\t\t\t\tSystem.out.println(\"Incrementing use count of shared working copy \" + workingCopy.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t}", "+", "+\t\t\treturn workingCopy;", "+\t\t}", "+\t} ", "+\tworkingCopy = new CompilationUnit((IPackageFragment)getParent(), getElementName(), workingCopyOwner);", "+\tBecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, perOwnerWorkingCopies);", "+\trunOperation(op, pm);", "+\treturn workingCopy;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "103b6bac16f2dcf7aa08ad7988a8e0be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 46, "signatureBeforeChange": " public IJavaElement findSharedWorkingCopy(IBufferFactory factory)", "signatureAfterChange": " public IJavaElement findSharedWorkingCopy(IBufferFactory factory)", "diff": ["- */", "-public IJavaElement findSharedWorkingCopy(IBufferFactory factory) {", "-", "-\t// if factory is null, default factory must be used", "-\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "-", "-\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t// AND use the same buffer factory.", "-\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\tMap sharedWorkingCopies = JavaModelManager.getJavaModelManager().sharedWorkingCopies;", "-\t", "-\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(factory);", "-\tif (perFactoryWorkingCopies == null) return null;", "-\treturn (WorkingCopy)perFactoryWorkingCopies.get(this);", "-}", "+ */", "+public IJavaElement findSharedWorkingCopy(IBufferFactory factory) {", "+", "+\t// if factory is null, default factory must be used", "+\tif (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();", "+", "+\t// In order to be shared, working copies have to denote the same compilation unit ", "+\t// AND use the same buffer factory.", "+\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "+\tMap sharedWorkingCopies = JavaModelManager.getJavaModelManager().sharedWorkingCopies;", "+\t", "+\tCompilationUnitOwner workingCopyOwner = new DefaultCompilationUnitOwner(factory, null);", "+\tMap perFactoryWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);", "+\tif (perFactoryWorkingCopies == null) return null;", "+\treturn (CompilationUnit)perFactoryWorkingCopies.get(this);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ff6f61b2cefff782a09e2445dc56f07", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic  FileGenerationResult generateFileDuringReconcile( \t\t\tICompilationUnit parentCompilationUnit, String typeName, \t\t\tString contents, WorkingCopyOwner workingCopyOwner, \t\t\tIProblemRequestor problemRequestor, IProgressMonitor progressMonitor )  \t \tthrows CoreException", "signatureAfterChange": " \tpublic FileGenerationResult generateFileDuringReconcile(ICompilationUnit parentCompilationUnit, String typeName, \t\t\tString contents) throws CoreException", "diff": ["-\tpublic  FileGenerationResult generateFileDuringReconcile(", "-\t\t\tICompilationUnit parentCompilationUnit, String typeName,", "-\t\t\tString contents, WorkingCopyOwner workingCopyOwner,", "-\t\t\tIProblemRequestor problemRequestor, IProgressMonitor progressMonitor ) ", "-\t", "-\tthrows CoreException", "-\t{\t", "-\t\t", "+\tpublic FileGenerationResult generateFileDuringReconcile(ICompilationUnit parentCompilationUnit, String typeName,", "+\t\t\tString contents) throws CoreException", "+\t{", "-\t\t// We have disabled Reconcile-time type generated for a long time and", "-\t\t// everything else has changed ever since. Don't expect the following ", "-\t\t// code to work when we enable reconcile-time type generation again. ", "-\t\t// -theodora", "-\t\t// Work item", "-\t\t// 1) make sure generated source directory and classpath is setup properly", "-\t\t//    (i don't think it is today) -theodora", "+", "+\t\tIFile parentFile = (IFile) parentCompilationUnit.getResource();", "-\t\tICompilationUnit workingCopy = null;", "-\t\tFileGenerationResult result = null;", "-\t\tIFile parentFile = (IFile)parentCompilationUnit.getResource();", "-\t\ttry ", "-\t\t{", "-\t\t\t//", "-\t\t\t// get working copy (either from cache or create a new one)", "-\t\t\t//", "-\t\t\tworkingCopy = getCachedWorkingCopy( parentFile, typeName );", "-\t\t\t", "-\t\t\tif ( workingCopyOwner == null )", "-\t\t\t\tworkingCopyOwner = parentCompilationUnit.getOwner();", "-\t\t\t", "-\t\t\tif ( workingCopy == null )", "-\t\t\t{", "-\t\t\t\t// create a new working copy", "-\t\t\t\tworkingCopy = createNewWorkingCopy(  ", "-\t\t\t\t\t\tparentFile,  typeName, contents,  ", "-\t\t\t\t\t\tworkingCopyOwner, problemRequestor,  progressMonitor);", "-\t\t\t\t\t\t\t\t", "-\t\t\t\tworkingCopy.reconcile(AST.JLS3, true, workingCopyOwner,", "-\t\t\t\t\t\tprogressMonitor);", "-\t\t\t\t", "-\t\t\t\t// TODO:  pass in correct flag for source-patch changed.  This is probably not going to matter.  Per 103183, we will either ", "-\t\t\t\t// disable reconcile-time generation, or do it without any modifications, so we shouldn't have to worry about this.   ", "-\t\t\t\tresult = new FileGenerationResult((IFile)workingCopy.getResource(), true);", "-\t\t\t}", "+\t\tICompilationUnit workingCopy = getWorkingCopyForGeneratedFile(parentFile, typeName, _CUHELPER);", "+", "+\t\t// Update its contents and recursively reconcile", "+\t\tboolean modified = _CUHELPER.updateWorkingCopyContents(", "+\t\t\t\tcontents, workingCopy, parentCompilationUnit.getOwner(), RECURSIVE_RECONCILE);", "+\t\tif (AptPlugin.DEBUG_GFM) {", "+\t\t\tif (modified)", "+\t\t\t\tAptPlugin.trace(\"working copy modified during reconcile: \" + typeName); //$NON-NLS-1$", "-\t\t\t{", "+\t\t\t\tAptPlugin.trace(\"working copy unmodified during reconcile: \" + typeName); //$NON-NLS-1$", "+\t\t}", "-\t\t\t\t//", "-\t\t\t\t//  Update working copy's buffer with the contents of the type ", "-\t\t\t\t// ", "-\t\t\t\tboolean modified = updateWorkingCopy( contents, workingCopy, workingCopyOwner, progressMonitor );", "-\t\t\t\tresult = new FileGenerationResult((IFile)workingCopy.getResource(), modified);", "-\t\t\t}", "-\t\t\t", "-\t\t\treturn result;", "-\t\t} ", "-\t\tcatch (JavaModelException jme) ", "-\t\t{", "-\t\t\tAptPlugin.log(jme, \"Could not generate file for type: \" + typeName); //$NON-NLS-1$", "-\t\t} ", "-\t\treturn new FileGenerationResult((IFile)workingCopy.getResource(), true);", "+\t\tIFile generatedFile = (IFile) workingCopy.getResource();", "+\t\treturn new FileGenerationResult(generatedFile, modified);"]}], "num": 19545}