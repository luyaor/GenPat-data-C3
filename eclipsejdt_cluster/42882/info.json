{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c569243d10ac1c58fd0d0c2851a13f6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bef338afd1c171a545e3ae5e91a360b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "signatureAfterChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "diff": ["-\t\t// potentially-applicable method for the method reference when targeting T (15.13.1),", "-\t\tMethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope);", "-\t\tif (potentiallyApplicable == null)", "-\t\t\treturn FALSE;", "+", "+\t\t\tMethodBinding potentiallyApplicable = reference.getExactMethod(); ", "+\t\t\t} else if (n != k) {", "+\t\t\t\treturn FALSE;", "-\t\t\t\tTypeBinding rPrime = rAppl.capture(inferenceContext.scope, 14); // FIXME capture position??", "+\t\t\t\tTypeBinding rPrime = rAppl.capture(inferenceContext.scope, reference.sourceEnd);", "+\t\t\tMethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope); // // potentially-applicable method for the method reference when targeting T (15.13.1),", "+\t\t\tif (potentiallyApplicable == null)", "+\t\t\t\treturn FALSE;", "+\t\t\t", "-\t\t\t\t\t\t|| (original.isConstructor() && original.declaringClass.typeVariables() != Binding.NO_TYPE_VARIABLES)))", "+\t\t\t\t\t\t|| (original.isConstructor() && compileTimeDecl.declaringClass.isRawType())))", "-\t\t\tTypeBinding rPrime = compileTimeDecl.isConstructor() ? compileTimeDecl.declaringClass : compileTimeDecl.returnType;", "+\t\t\tTypeBinding rPrime = compileTimeDecl.isConstructor() ? compileTimeDecl.declaringClass : compileTimeDecl.returnType.capture(inferenceContext.scope, reference.sourceEnd());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3f18291e5bf45808f9b93c21b99537c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "ec64763fa4e57b4943311ee555e5ddce81854cf2", "commitAfterChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "signatureAfterChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "diff": ["-", "+\t\t// potentially-applicable method for the method reference when targeting T (15.13.1),", "+\t\tMethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope);", "+\t\tif (potentiallyApplicable == null)", "+\t\t\treturn FALSE;", "-\t\t\tMethodBinding potentiallyApplicable = reference.getExactMethod(); ", "-\t\t\t} else if (n != k) {", "-\t\t\t\treturn FALSE;", "-\t\t\tMethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope); // // potentially-applicable method for the method reference when targeting T (15.13.1),", "-\t\t\tif (potentiallyApplicable == null)", "-\t\t\t\treturn FALSE;", "-\t\t\t"]}], "num": 42882}