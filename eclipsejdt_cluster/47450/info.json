{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3ec58965397774c8e1f1cc2c0a39bec3", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "860bf174428c6504e582773ab9e72913", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "849bead878c9a40a476fb6736e2c949015040926", "commitAfterChange": "ffce987f3a5cbc5edb4057595c44a9095dbf9c81", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic TextEdit format(String string, ConstructorDeclaration constructorDeclaration)", "signatureAfterChange": " \t \tprivate void format(AnnotationTypeDeclaration annotationTypeDeclaration)", "diff": ["+\tprivate void format(AnnotationTypeDeclaration annotationTypeDeclaration) {", "+        /*", "+         * Print comments to get proper line number", "+         */", "+        this.scribe.printComment();", "+        final int line = this.scribe.line; ", "+        ", "+        this.scribe.printModifiers(annotationTypeDeclaration.annotations, this);", "+\t\t/*", "+\t\t * Type name", "+\t\t */", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameAT, this.preferences.insert_space_before_at_in_annotation_type_declaration);", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameinterface, this.preferences.insert_space_after_at_in_annotation_type_declaration); ", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, true); ", "+", "+\t\t/*", "+\t\t * Type body", "+\t\t */", "+\t\tString annotation_type_declaration_brace = this.preferences.brace_position_for_annotation_type_declaration;", "+", "+        formatLeftCurlyBrace(line, annotation_type_declaration_brace);", "+\t\tformatTypeOpeningBrace(annotation_type_declaration_brace, this.preferences.insert_space_before_opening_brace_in_annotation_type_declaration, annotationTypeDeclaration);", "+\t\t", "+\t\tif (this.preferences.indent_body_declarations_compare_to_type_header) {", "+\t\t\tthis.scribe.indent();", "+\t\t}", "+", "+\t\tformatTypeMembers(annotationTypeDeclaration);", "+", "+\t\tthis.scribe.printComment();", "+\t\t", "+\t\tif (this.preferences.indent_body_declarations_compare_to_type_header) {", "+\t\t\tthis.scribe.unIndent();", "+\t\t}", "+\t\t", "+\t\tif (this.preferences.insert_new_line_in_empty_type_declaration) {", "+\t\t\tthis.scribe.printNewLine();", "+\t\t}", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);", "+\t\tthis.scribe.printTrailingComment();", "+\t\tif (annotation_type_declaration_brace.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {", "+\t\t\tthis.scribe.unIndent();", "+\t\t}", "+\t\tif (hasComments()) {", "+\t\t\tthis.scribe.printNewLine();", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d3d8279a5b0c0a4e2592651dba348c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "82dc67de142f757f6098e678017a2b32f752c9b7", "commitAfterChange": "5249d37677c0ce4d66ab262efb5c3dd4aa089796", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": "  void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["-\tif (length > 1) {", "-\t\tint[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);", "-\t\tif (overriddenInheritedMethods != null) {", "-\t\t\t// detected some overridden methods that can be ignored when checking return types", "-\t\t\t// but cannot ignore an overridden inherited method completely when it comes to checking for bridge methods", "-\t\t\tint index = 0;", "-\t\t\tMethodBinding[] closestMethods = new MethodBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++)", "-\t\t\t\tif (overriddenInheritedMethods[i] == 0)", "-\t\t\t\t\tclosestMethods[index++] = methods[i];", "-\t\t\tif (index > 1 && !checkInheritedReturnTypes(closestMethods, index))", "-\t\t\t\treturn;", "-\t\t} else if (!checkInheritedReturnTypes(methods, length)) {", "-\t\t\treturn;", "-\t\t}", "-\t}", "+\t/*", "+\t1. find concrete method", "+\t2. if it doesn't exist then find first inherited abstract method whose return type is compatible with all others", "+\t   if no such method exists then report incompatible return type error", "+\t   otherwise report abstract method must be implemented", "+\t3. if concrete method exists, check to see if its return type is compatible with all others", "+\t   if it is then check concrete method against abstract methods", "+\t   if its not, then find most specific abstract method & report abstract method must be implemented since concrete method is insufficient", "+\t   if no most specific return type abstract method exists, then report incompatible return type with all inherited methods ", "+\t*/", "-\tMethodBinding concreteMethod = null;", "-\tif (!this.type.isInterface()) {  // ignore concrete methods for interfaces", "-\t\tfor (int i = length; --i >= 0;) {  // Remember that only one of the methods can be non-abstract", "-\t\t\tif (!methods[i].isAbstract()) {", "-\t\t\t\tconcreteMethod = methods[i];", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t}", "+\tMethodBinding concreteMethod = this.type.isInterface() || methods[0].isAbstract() ? null : methods[0];", "-\t\tif (!this.type.isAbstract()) {", "-\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\tif (mustImplementAbstractMethod(methods[i].declaringClass)) {", "-\t\t\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "-\t\t\t\t\tif (typeDeclaration != null) {", "-\t\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(methods[0]);", "-\t\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn;", "+\t\tMethodBinding bestAbstractMethod = length == 1 ? methods[0] : findBestInheritedAbstractMethod(methods, length);", "+\t\tif (bestAbstractMethod == null) {", "+\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "+\t\t} else if (mustImplementAbstractMethod(bestAbstractMethod.declaringClass)) {", "+\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "+\t\t\tMethodBinding superclassAbstractMethod = methods[0];", "+\t\t\tif (superclassAbstractMethod == bestAbstractMethod || superclassAbstractMethod.declaringClass.isInterface()) {", "+\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(bestAbstractMethod);", "+\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod);", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (typeDeclaration != null) {", "+\t\t\t\t\tMethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(bestAbstractMethod);", "+\t\t\t\t\tmissingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, superclassAbstractMethod);", "+\t\t\t\t} else {", "+\t\t\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, superclassAbstractMethod);", "+\tif (length < 2) return; // nothing else to check", "-\tif (length > 1) {", "-\t\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];", "-\t\tint index = 0;", "-\t\tfor (int i = length; --i >= 0;)", "-\t\t\tif (methods[i] != concreteMethod)", "-\t\t\t\tabstractMethods[index++] = methods[i];", "-\t\tcheckConcreteInheritedMethod(concreteMethod, abstractMethods);", "+\tint index = length;", "+\twhile (--index > 0 && checkInheritedReturnTypes(concreteMethod, methods[index])) {/*empty*/}", "+\tif (index > 0) {", "+\t\t// concreteMethod is not the best match", "+\t\tMethodBinding bestAbstractMethod = findBestInheritedAbstractMethod(methods, length);", "+\t\tif (bestAbstractMethod == null)", "+\t\t\tproblemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);", "+\t\telse // can only happen in >= 1.5 since return types must be equal prior to 1.5", "+\t\t\tproblemReporter().abstractMethodMustBeImplemented(this.type, bestAbstractMethod, concreteMethod);", "+\t\treturn;", "+", "+\tMethodBinding[] abstractMethods = new MethodBinding[length - 1];", "+\tindex = 0;", "+\tfor (int i = 0; i < length; i++)", "+\t\tif (methods[i].isAbstract())", "+\t\t\tabstractMethods[index++] = methods[i];", "+\tif (index < abstractMethods.length)", "+\t\tSystem.arraycopy(abstractMethods, 0, abstractMethods = new MethodBinding[index], 0, index);", "+\tcheckConcreteInheritedMethod(concreteMethod, abstractMethods);"]}], "num": 47450}