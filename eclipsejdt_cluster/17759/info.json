{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "95ebbd63432f53f78a5ae051bacb618d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "325e67a6b9a58c8632a892b3e3b30629", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 297, "methodNumberAfterChange": 298, "signatureBeforeChange": " public void recordPositionsFrom(int startPC, int sourcePos, boolean widen)", "signatureAfterChange": " public void recordPositionsFrom(int startPC, int sourcePos, boolean widen)", "diff": ["-\tint lineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, 0, lineSeparatorPositions.length-1);", "+\t\tint lineNumber;", "+\t\tint previousLineNumber = pcToSourceMap[pcToSourceMapSize - 1];", "+\t\tif (this.lineNumberStart == this.lineNumberEnd) {", "+\t\t\t// method on one line", "+\t\t\tlineNumber = this.lineNumberStart;", "+\t\t} else {", "+\t\t\t// Check next line number if this is the one we are looking for", "+\t\t\tint[] lineSeparatorPositions2 = this.lineSeparatorPositions;", "+\t\t\tint length = lineSeparatorPositions2.length;", "+\t\t\tif (previousLineNumber == 1) {", "+\t\t\t\tif (sourcePos < lineSeparatorPositions2[0]) {", "+\t\t\t\t\tlineNumber = 1;", "+\t\t\t\t\t/* the last recorded entry is on the same line. But it could be relevant to widen this entry.", "+\t\t\t\t\t   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement", "+\t\t\t\t\t*/\t", "+\t\t\t\t\tif (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\tint insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);", "+\t\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t\t// widen the existing entry", "+\t\t\t\t\t\t\t// we have to figure out if we need to move the last entry at another location to keep a sorted table", "+\t\t\t\t\t\t\t/* First we need to check if at the insertion position there is not an existing entry", "+\t\t\t\t\t\t\t * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.", "+\t\t\t\t\t\t\t * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion", "+\t\t\t\t\t\t\t * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.", "+\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\tif (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == lineNumber))) {", "+\t\t\t\t\t\t\t\tif ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 2] = startPC;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tlastEntryPC = position;", "+\t\t\t\t\treturn;", "+\t\t\t\t} else if (length == 1 || sourcePos < lineSeparatorPositions2[1]) {", "+\t\t\t\t\tlineNumber = 2;", "+\t\t\t\t\tif (startPC <= lastEntryPC) {", "+\t\t\t\t\t\t// we forgot to add an entry.", "+\t\t\t\t\t\t// search if an existing entry exists for startPC", "+\t\t\t\t\t\tint insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);", "+\t\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t\t// there is no existing entry starting with startPC.", "+\t\t\t\t\t\t\tint existingEntryIndex = indexOfSameLineEntrySincePC(startPC, lineNumber); // index for PC", "+\t\t\t\t\t\t\t/* the existingEntryIndex corresponds to an entry with the same line and a PC >= startPC.", "+\t\t\t\t\t\t\t\tin this case it is relevant to widen this entry instead of creating a new one.", "+\t\t\t\t\t\t\t\tline1: this(a,", "+\t\t\t\t\t\t\t\t  b,", "+\t\t\t\t\t\t\t\t  c);", "+\t\t\t\t\t\t\t\twith this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this", "+\t\t\t\t\t\t\t\taload0 bytecode. The first entry is the one for the argument a.", "+\t\t\t\t\t\t\t\tBut we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.", "+\t\t\t\t\t\t\t\tSo we widen the existing entry (if there is one) or we create a new entry with the startPC.", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tif (existingEntryIndex != -1) {", "+\t\t\t\t\t\t\t\t// widen existing entry", "+\t\t\t\t\t\t\t\tpcToSourceMap[existingEntryIndex] = startPC;", "+\t\t\t\t\t\t\t} else if (insertionIndex < 1 || pcToSourceMap[insertionIndex - 1] != lineNumber) {", "+\t\t\t\t\t\t\t\t// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.", "+\t\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);", "+\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\t\t\t\t\t\t\tpcToSourceMapSize += 2;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (position != lastEntryPC) { // no bytecode since last entry pc", "+\t\t\t\t\t\t\tif (lastEntryPC == startPC || lastEntryPC == pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "+\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (pcToSourceMap[pcToSourceMapSize - 1] < lineNumber && widen) {", "+\t\t\t\t\t\t\t// see if we can widen the existing entry", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = startPC;", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t}", "+\t\t\t\t\tlastEntryPC = position;", "+\t\t\t\t\treturn;", "+\t\t\t\t} else {", "+\t\t\t\t\t// since lineSeparatorPositions is zero-based, we pass this.lineNumberStart - 1 and this.lineNumberEnd - 1", "+\t\t\t\t\tlineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, this.lineNumberStart - 1, this.lineNumberEnd - 1);", "+\t\t\t\t}", "+\t\t\t} else if (previousLineNumber < length) {", "+\t\t\t\tif (lineSeparatorPositions2[previousLineNumber - 2] < sourcePos) {", "+\t\t\t\t\tif (sourcePos < lineSeparatorPositions2[previousLineNumber - 1]) {", "+\t\t\t\t\t\tlineNumber = previousLineNumber;", "+\t\t\t\t\t\t/* the last recorded entry is on the same line. But it could be relevant to widen this entry.", "+\t\t\t\t\t\t   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement", "+\t\t\t\t\t\t*/\t", "+\t\t\t\t\t\tif (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\t\tint insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);", "+\t\t\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t\t\t// widen the existing entry", "+\t\t\t\t\t\t\t\t// we have to figure out if we need to move the last entry at another location to keep a sorted table", "+\t\t\t\t\t\t\t\t/* First we need to check if at the insertion position there is not an existing entry", "+\t\t\t\t\t\t\t\t * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.", "+\t\t\t\t\t\t\t\t * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion", "+\t\t\t\t\t\t\t\t * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.", "+\t\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\t\tif (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == lineNumber))) {", "+\t\t\t\t\t\t\t\t\tif ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {", "+\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);", "+\t\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 2] = startPC;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlastEntryPC = position;", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t} else if (sourcePos < lineSeparatorPositions2[previousLineNumber]) {", "+\t\t\t\t\t\tlineNumber = previousLineNumber + 1;", "+\t\t\t\t\t\tif (startPC <= lastEntryPC) {", "+\t\t\t\t\t\t\t// we forgot to add an entry.", "+\t\t\t\t\t\t\t// search if an existing entry exists for startPC", "+\t\t\t\t\t\t\tint insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);", "+\t\t\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t\t\t// there is no existing entry starting with startPC.", "+\t\t\t\t\t\t\t\tint existingEntryIndex = indexOfSameLineEntrySincePC(startPC, lineNumber); // index for PC", "+\t\t\t\t\t\t\t\t/* the existingEntryIndex corresponds to an entry with the same line and a PC >= startPC.", "+\t\t\t\t\t\t\t\t\tin this case it is relevant to widen this entry instead of creating a new one.", "+\t\t\t\t\t\t\t\t\tline1: this(a,", "+\t\t\t\t\t\t\t\t\t  b,", "+\t\t\t\t\t\t\t\t\t  c);", "+\t\t\t\t\t\t\t\t\twith this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this", "+\t\t\t\t\t\t\t\t\taload0 bytecode. The first entry is the one for the argument a.", "+\t\t\t\t\t\t\t\t\tBut we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.", "+\t\t\t\t\t\t\t\t\tSo we widen the existing entry (if there is one) or we create a new entry with the startPC.", "+\t\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\t\tif (existingEntryIndex != -1) {", "+\t\t\t\t\t\t\t\t\t// widen existing entry", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[existingEntryIndex] = startPC;", "+\t\t\t\t\t\t\t\t} else if (insertionIndex < 1 || pcToSourceMap[insertionIndex - 1] != lineNumber) {", "+\t\t\t\t\t\t\t\t\t// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\t\t\t\t\t\t\t\tpcToSourceMapSize += 2;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (position != lastEntryPC) { // no bytecode since last entry pc", "+\t\t\t\t\t\t\t\tif (lastEntryPC == startPC || lastEntryPC == pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "+\t\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (pcToSourceMap[pcToSourceMapSize - 1] < lineNumber && widen) {", "+\t\t\t\t\t\t\t\t// see if we can widen the existing entry", "+\t\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = startPC;", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlastEntryPC = position;", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// since lineSeparatorPositions is zero-based, we pass this.lineNumberStart - 1 and this.lineNumberEnd - 1", "+\t\t\t\t\t\tlineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, this.lineNumberStart - 1, this.lineNumberEnd - 1);", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// since lineSeparatorPositions is zero-based, we pass this.lineNumberStart - 1 and this.lineNumberEnd - 1", "+\t\t\t\t\tlineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, this.lineNumberStart - 1, this.lineNumberEnd - 1);", "+\t\t\t\t}", "+\t\t\t} else if (lineSeparatorPositions2[length - 1] < sourcePos) {", "+\t\t\t\tlineNumber = length + 1;", "+\t\t\t\tif (startPC <= lastEntryPC) {", "+\t\t\t\t\t// we forgot to add an entry.", "+\t\t\t\t\t// search if an existing entry exists for startPC", "+\t\t\t\t\tint insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);", "+\t\t\t\t\tif (insertionIndex != -1) {", "+\t\t\t\t\t\t// there is no existing entry starting with startPC.", "+\t\t\t\t\t\tint existingEntryIndex = indexOfSameLineEntrySincePC(startPC, lineNumber); // index for PC", "+\t\t\t\t\t\t/* the existingEntryIndex corresponds to an entry with the same line and a PC >= startPC.", "+\t\t\t\t\t\t\tin this case it is relevant to widen this entry instead of creating a new one.", "+\t\t\t\t\t\t\tline1: this(a,", "+\t\t\t\t\t\t\t  b,", "+\t\t\t\t\t\t\t  c);", "+\t\t\t\t\t\t\twith this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this", "+\t\t\t\t\t\t\taload0 bytecode. The first entry is the one for the argument a.", "+\t\t\t\t\t\t\tBut we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.", "+\t\t\t\t\t\t\tSo we widen the existing entry (if there is one) or we create a new entry with the startPC.", "+\t\t\t\t\t\t*/", "+\t\t\t\t\t\tif (existingEntryIndex != -1) {", "+\t\t\t\t\t\t\t// widen existing entry", "+\t\t\t\t\t\t\tpcToSourceMap[existingEntryIndex] = startPC;", "+\t\t\t\t\t\t} else if (insertionIndex < 1 || pcToSourceMap[insertionIndex - 1] != lineNumber) {", "+\t\t\t\t\t\t\t// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.", "+\t\t\t\t\t\t\tSystem.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);", "+\t\t\t\t\t\t\tpcToSourceMap[insertionIndex++] = startPC;", "+\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\t\t\t\t\t\tpcToSourceMapSize += 2;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (position != lastEntryPC) { // no bytecode since last entry pc", "+\t\t\t\t\t\tif (lastEntryPC == startPC || lastEntryPC == pcToSourceMap[pcToSourceMapSize - 2]) {", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lastEntryPC;", "+\t\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (pcToSourceMap[pcToSourceMapSize - 1] < lineNumber && widen) {", "+\t\t\t\t\t\t// see if we can widen the existing entry", "+\t\t\t\t\t\tpcToSourceMap[pcToSourceMapSize - 1] = lineNumber;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.", "+\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = startPC;", "+\t\t\t\t\tpcToSourceMap[pcToSourceMapSize++] = lineNumber;", "+\t\t\t\t}", "+\t\t\t\tlastEntryPC = position;", "+\t\t\t\treturn;", "+\t\t\t} else {", "+\t\t\t\t// since lineSeparatorPositions is zero-based, we pass this.lineNumberStart - 1 and this.lineNumberEnd - 1", "+\t\t\t\tlineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, this.lineNumberStart - 1, this.lineNumberEnd - 1);", "+\t\t\t}", "+\t\t}", "-\t\tif (pcToSourceMap[pcToSourceMapSize - 1] != lineNumber) {", "+\t\tif (previousLineNumber != lineNumber) {", "-\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;\t\t\t\t\t\t", "+\t\t\t\t\t\t\tpcToSourceMap[insertionIndex] = lineNumber;", "+\t\tint lineNumber = 0;", "+\t\tif (this.lineNumberStart == this.lineNumberEnd) {", "+\t\t\t// method on one line", "+\t\t\tlineNumber = this.lineNumberStart;", "+\t\t} else {", "+\t\t\t// since lineSeparatorPositions is zero-based, we pass this.lineNumberStart - 1 and this.lineNumberEnd - 1", "+\t\t\tlineNumber = Util.getLineNumber(sourcePos, lineSeparatorPositions, this.lineNumberStart - 1, this.lineNumberEnd - 1);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f18357e1292437efd3728a2a343faef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java", "commitBeforeChange": "d9f5208ccd9842b7305a76e615fa0b04487a1a33", "commitAfterChange": "9ac3d3205dd69d72df25a75c1584224d5519622d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate String processElement(ICompilationUnit unit, int[] positionsToMap, char[] source)", "signatureAfterChange": " \tprivate String processElement(ICompilationUnit unit, char[] source)", "diff": ["-\tprivate String processElement(ICompilationUnit unit, int[] positionsToMap, char[] source) {", "+\tprivate String processElement(ICompilationUnit unit, char[] source) {", "-\t\tSortElementBuilder builder = new SortElementBuilder(source, positionsToMap, this.comparator, options);", "-\t\tSourceElementParser parser = new SourceElementParser(builder,", "-\t\t\tProblemFactory.getProblemFactory(Locale.getDefault()), options, true/*report local declarations*/, true/*optimize string literals*/);", "+\t\tASTParser parser = ASTParser.newParser(AST.JLS3);", "+\t\tparser.setCompilerOptions(options.getMap());", "+\t\tparser.setSource(source);", "+\t\tparser.setKind(ASTParser.K_COMPILATION_UNIT);", "+\t\tparser.setResolveBindings(false);", "+\t\torg.eclipse.jdt.core.dom.CompilationUnit domUnit = (org.eclipse.jdt.core.dom.CompilationUnit) parser.createAST(null);", "+\t\tfinal AST localAst = domUnit.getAST();", "+\t\tfinal ASTRewrite rewriter = ASTRewrite.create(localAst);", "+\t\tRangeMarker[] markers = null;", "-\t\tif (unit.exists()) {", "-\t\t\tPackageFragment packageFragment = (PackageFragment)unit.getAncestor(IJavaElement.PACKAGE_FRAGMENT);", "-\t\t\tchar[][] expectedPackageName = null;", "-\t\t\tif (packageFragment != null){", "-\t\t\t\texpectedPackageName = Util.toCharArrays(packageFragment.names);", "+\t\tfinal boolean needPositionsMapping = this.positions != null;", "+\t\tif (needPositionsMapping) {", "+\t\t\tmarkers = new RangeMarker[this.positions.length];", "+\t\t\tfor (int i= 0; i < this.positions.length; i++) {", "+\t\t\t\tmarkers[i]= new RangeMarker(this.positions[i], 0);", "-\t\t\tparser.parseCompilationUnit(", "-\t\t\t\tnew BasicCompilationUnit(", "-\t\t\t\t\tsource,", "-\t\t\t\t\texpectedPackageName,", "-\t\t\t\t\tunit.getElementName(),", "-\t\t\t\t\tunit),", "-\t\t\t\tfalse/*diet parse*/);", "-\t\t} else {", "-\t\t\tparser.parseCompilationUnit(", "-\t\t\t\tnew BasicCompilationUnit(", "-\t\t\t\t\tsource,", "-\t\t\t\t\tnull,", "-\t\t\t\t\t\"\",//$NON-NLS-1$", "-\t\t\t\t\tunit.getJavaProject()),//$NON-NLS-1$", "-\t\t\t\tfalse/*diet parse*/);", "-\t\treturn builder.getSource();", "+\t\tString generatedSource = new String(source);", "+\t\tDocument document = new Document(generatedSource);", "+\t\tdomUnit.accept(new ASTVisitor() {", "+\t\t\tpublic boolean visit(org.eclipse.jdt.core.dom.CompilationUnit compilationUnit) {", "+\t\t\t\tListRewrite listRewrite = rewriter.getListRewrite(compilationUnit, org.eclipse.jdt.core.dom.CompilationUnit.TYPES_PROPERTY);", "+\t\t\t\tList myCopy = new ArrayList();", "+\t\t\t\tList types = compilationUnit.types();", "+\t\t\t\tfinal int length = types.size();", "+\t\t\t\tmyCopy.addAll(types);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) types.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\tpublic boolean visit(AnnotationTypeDeclaration annotationTypeDeclaration) {", "+\t\t\t\tListRewrite listRewrite = rewriter.getListRewrite(annotationTypeDeclaration, AnnotationTypeDeclaration.BODY_DECLARATIONS_PROPERTY);", "+\t\t\t\tList myCopy = new ArrayList();", "+\t\t\t\tList bodyDeclarations = annotationTypeDeclaration.bodyDeclarations();", "+\t\t\t\tfinal int length = bodyDeclarations.size();", "+\t\t\t\tmyCopy.addAll(bodyDeclarations);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) bodyDeclarations.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+", "+\t\t\tpublic boolean visit(AnonymousClassDeclaration anonymousClassDeclaration) {", "+\t\t\t\tListRewrite listRewrite = rewriter.getListRewrite(anonymousClassDeclaration, AnonymousClassDeclaration.BODY_DECLARATIONS_PROPERTY);", "+\t\t\t\tList myCopy = new ArrayList();", "+\t\t\t\tList bodyDeclarations = anonymousClassDeclaration.bodyDeclarations();", "+\t\t\t\tfinal int length = bodyDeclarations.size();", "+\t\t\t\tmyCopy.addAll(bodyDeclarations);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) bodyDeclarations.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\t", "+\t\t\tpublic boolean visit(TypeDeclaration typeDeclaration) {", "+\t\t\t\tListRewrite listRewrite = rewriter.getListRewrite(typeDeclaration, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);", "+\t\t\t\tList myCopy = new ArrayList();", "+\t\t\t\tList bodyDeclarations = typeDeclaration.bodyDeclarations();", "+\t\t\t\tfinal int length = bodyDeclarations.size();", "+\t\t\t\tmyCopy.addAll(bodyDeclarations);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) bodyDeclarations.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+", "+\t\t\tpublic boolean visit(EnumDeclaration enumDeclaration) {", "+\t\t\t\tListRewrite listRewrite = rewriter.getListRewrite(enumDeclaration, EnumDeclaration.BODY_DECLARATIONS_PROPERTY);", "+\t\t\t\tList myCopy = new ArrayList();", "+\t\t\t\tList bodyDeclarations = enumDeclaration.bodyDeclarations();", "+\t\t\t\tint length = bodyDeclarations.size();", "+\t\t\t\tmyCopy.addAll(bodyDeclarations);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) bodyDeclarations.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tlistRewrite = rewriter.getListRewrite(enumDeclaration, EnumDeclaration.ENUM_CONSTANTS_PROPERTY);", "+\t\t\t\tmyCopy = new ArrayList();", "+\t\t\t\tList enumConstants = enumDeclaration.enumConstants();", "+\t\t\t\tlength = enumConstants.size();", "+\t\t\t\tmyCopy.addAll(enumConstants);", "+\t\t\t\tCollections.sort(myCopy, SortElementsOperation.this.comparator);", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tlistRewrite.replace((ASTNode) enumConstants.get(i), rewriter.createMoveTarget((ASTNode) myCopy.get(i)), null);", "+\t\t\t\t}", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t});\t\t\t", "+\t\tTextEdit edits = rewriter.rewriteAST(document, null);", "+\t\tif (needPositionsMapping) {", "+\t\t\tfor (int i = 0, max = markers.length; i < max; i++) {", "+\t\t\t\tinsert(edits, markers[i]);", "+\t\t\t}", "+\t\t}", "+\t\ttry {", "+\t\t\tedits.apply(document, TextEdit.UPDATE_REGIONS);", "+\t\t\tgeneratedSource = document.get();", "+\t\t\tif (needPositionsMapping) {", "+\t\t\t\tfor (int i= 0, max = markers.length; i < max; i++) {", "+\t\t\t\t\tthis.positions[i]= markers[i].getOffset();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} catch (BadLocationException e) {", "+\t\t\t// ignore", "+\t\t}", "+\t\treturn generatedSource;"]}], "num": 17759}