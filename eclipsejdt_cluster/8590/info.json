{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f3fb88c8aace69b22cca125558600012", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "01e80d722a0cccf06918b393dda3aa48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\t\tExceptionLabel exceptionLabel = new ExceptionLabel(codeStream, this.catchArguments[i].binding.type);", "+\t\t\tArgument argument = this.catchArguments[i];", "+\t\t\tExceptionLabel exceptionLabel = null;", "+\t\t\tif ((argument.binding.tagBits & TagBits.MultiCatchParameter) != 0) {", "+\t\t\t\tMultiCatchExceptionLabel multiCatchExceptionLabel = new MultiCatchExceptionLabel(codeStream, argument.binding.type);", "+\t\t\t\tmultiCatchExceptionLabel.initialize((UnionTypeReference) argument.type);", "+\t\t\t\texceptionLabel = multiCatchExceptionLabel;", "+\t\t\t} else {", "+\t\t\t\texceptionLabel = new ExceptionLabel(codeStream, argument.binding.type);", "+\t\t\t}", "+\t\tint resourceCount = this.resources.length;", "+\t\tif (resourceCount > 0) {", "+\t\t\t// Please see https://bugs.eclipse.org/bugs/show_bug.cgi?id=338402#c16", "+\t\t\tthis.resourceExceptionLabels = new ExceptionLabel[resourceCount + 1];", "+\t\t\tcodeStream.aconst_null();", "+\t\t\tcodeStream.store(this.primaryExceptionVariable, false /* value not required */);", "+\t\t\tcodeStream.addVariable(this.primaryExceptionVariable);", "+\t\t\tcodeStream.aconst_null();", "+\t\t\tcodeStream.store(this.caughtThrowableVariable, false /* value not required */);", "+\t\t\tcodeStream.addVariable(this.caughtThrowableVariable);", "+\t\t\tfor (int i = 0; i <= resourceCount; i++) {", "+\t\t\t\tthis.resourceExceptionLabels[i] = new ExceptionLabel(codeStream, this.scope.getJavaLangThrowable());", "+\t\t\t\tthis.resourceExceptionLabels[i].placeStart();", "+\t\t\t\tif (i < resourceCount) {", "+\t\t\t\t\tthis.resources[i].generateCode(this.scope, codeStream); // Initialize resources ...", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (resourceCount > 0) {", "+\t\t\tfor (int i = resourceCount; i >= 0; i--) {", "+\t\t\t\tBranchLabel exitLabel = new BranchLabel(codeStream);", "+\t\t\t\tthis.resourceExceptionLabels[i].placeEnd(); // outer handler if any is the one that should catch exceptions out of close()", "+\t\t\t\t", "+\t\t\t\tLocalVariableBinding localVariable = i > 0 ? this.resources[i-1].binding : null;", "+\t\t\t\tif ((this.bits & ASTNode.IsTryBlockExiting) == 0) {", "+\t\t\t\t\t// inline resource closure", "+\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\tint invokeCloseStartPc = codeStream.position; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=343785", "+\t\t\t\t\t\tcodeStream.load(localVariable);", "+\t\t\t\t    \tcodeStream.ifnull(exitLabel);", "+\t\t\t\t    \tcodeStream.load(localVariable);", "+\t\t\t\t    \tcodeStream.invokeAutoCloseableClose(localVariable.type);", "+\t\t\t\t    \tcodeStream.recordPositionsFrom(invokeCloseStartPc, this.tryBlock.sourceEnd);\t", "+\t\t\t\t    }", "+\t\t\t\t\tcodeStream.goto_(exitLabel); // skip over the catch block.", "+\t\t\t\t}", "+\t\t\t\tcodeStream.pushExceptionOnStack(this.scope.getJavaLangThrowable());", "+\t\t\t\tthis.resourceExceptionLabels[i].place();", "+\t\t\t\tif (i == resourceCount) { ", "+\t\t\t\t\t// inner most try's catch/finally can be a lot simpler. ", "+\t\t\t\t\tcodeStream.store(this.primaryExceptionVariable, false);", "+\t\t\t\t\t// fall through, invoke close() and re-throw.", "+\t\t\t\t} else {", "+\t\t\t\t\tBranchLabel elseLabel = new BranchLabel(codeStream), postElseLabel = new BranchLabel(codeStream);", "+\t\t\t\t\tcodeStream.store(this.caughtThrowableVariable, false);", "+\t\t\t\t\tcodeStream.load(this.primaryExceptionVariable);", "+\t\t\t\t\tcodeStream.ifnonnull(elseLabel);", "+\t\t\t\t\tcodeStream.load(this.caughtThrowableVariable);", "+\t\t\t\t\tcodeStream.store(this.primaryExceptionVariable, false);", "+\t\t\t\t\tcodeStream.goto_(postElseLabel);", "+\t\t\t\t\telseLabel.place();", "+\t\t\t\t\tcodeStream.load(this.primaryExceptionVariable);", "+\t\t\t\t\tcodeStream.load(this.caughtThrowableVariable);", "+\t\t\t\t\tcodeStream.if_acmpeq(postElseLabel);", "+\t\t\t\t\tcodeStream.load(this.primaryExceptionVariable);", "+\t\t\t\t\tcodeStream.load(this.caughtThrowableVariable);", "+\t\t\t\t\tcodeStream.invokeThrowableAddSuppressed();", "+\t\t\t\t\tpostElseLabel.place();", "+\t\t\t\t}", "+\t\t\t\tif (i > 0) {", "+\t\t\t\t\t// inline resource close here rather than bracketing the current catch block with a try region.", "+\t\t\t\t\tBranchLabel postCloseLabel = new BranchLabel(codeStream);", "+\t\t\t\t\tint invokeCloseStartPc = codeStream.position; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=343785\t\t\t", "+\t\t\t\t\tcodeStream.load(localVariable);", "+\t\t\t\t\tcodeStream.ifnull(postCloseLabel);", "+\t\t\t\t\tcodeStream.load(localVariable);", "+\t\t\t\t\tcodeStream.invokeAutoCloseableClose(localVariable.type);", "+\t\t\t\t\tcodeStream.recordPositionsFrom(invokeCloseStartPc, this.tryBlock.sourceEnd);", "+\t\t\t\t\tcodeStream.removeVariable(localVariable);", "+\t\t\t\t\tpostCloseLabel.place();", "+\t\t\t\t}", "+\t\t\t\tcodeStream.load(this.primaryExceptionVariable);", "+\t\t\t\tcodeStream.athrow();", "+\t\t\t\texitLabel.place();", "+\t\t\t}", "+\t\t\tcodeStream.removeVariable(this.primaryExceptionVariable);", "+\t\t\tcodeStream.removeVariable(this.caughtThrowableVariable);", "+\t\t}", "-\t\t\t\tif (exceptionLabels[i].count == 0) continue;", "+\t\t\t\tif (exceptionLabels[i].getCount() == 0) continue;", "-\t\tif (this.subRoutineStartLabel != null && this.anyExceptionLabel.count != 0) {", "+\t\tif (this.subRoutineStartLabel != null && this.anyExceptionLabel.getCount() != 0) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41eded65e4d8c560ea70069e66be440d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "25a0c02d6979e76d70832f78f8eb60bd371c0ad1", "commitAfterChange": "1b6413921860c74cfa469f859f6fc627d6400adf", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["+\t */", "-\t\tsuper.resolveType(blockScope);", "-\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "-\t\tthis.binding = this.scope.createAnonymousMethodBinding(this);", "-\t\tif (this.functionalInterfaceType.isValidBinding()) {", "-\t\t\tthis.binding.thrownExceptions = computeKosherThrowables();", "-\t\t\t// Resolve arguments, validate signature ...", "-\t\t\tif (this.arguments != null && this.singleAbstractMethod != null) {", "-\t\t\t\tint parameterCount = this.singleAbstractMethod.parameters != null ? this.singleAbstractMethod.parameters.length : 0;", "-\t\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+\t\t", "+\t\tsuper.resolveType(blockScope); // compute & capture interface function descriptor in singleAbstractMethod.", "+\t\t", "+\t\tfinal boolean argumentsTypeElided = argumentsTypeElided();", "+\t\tfinal boolean haveDescriptor = this.singleAbstractMethod != null;", "+\t\t", "+\t\tif (!haveDescriptor && argumentsTypeElided) ", "+\t\t\treturn null; // FUBAR, bail out...", "-\t\t\t\tif (parameterCount == lambdaArgumentCount) {", "-\t\t\t\t\tfor (int i = 0, length = this.arguments.length; i < length; i++) {", "-\t\t\t\t\t\tArgument argument = this.arguments[i];", "-\t\t\t\t\t\tif (argument.type != null) {", "-\t\t\t\t\t\t\targument.resolve(this.scope); // TODO: Check it!", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\targument.bind(this.scope, this.singleAbstractMethod.parameters[i], false);", "-\t\t\t\t\t\t}", "+\t\tthis.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);", "+\t\t", "+\t\tthis.binding = new MethodBinding(ClassFileConstants.AccPublic | ExtraCompilerModifiers.AccUnresolved,", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.selector : TypeConstants.ANONYMOUS_METHOD, ", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.returnType : null, ", "+\t\t\t\t\t\t\tBinding.NO_PARAMETERS, // for now. ", "+\t\t\t\t\t\t\thaveDescriptor ? this.singleAbstractMethod.thrownExceptions : Binding.NO_EXCEPTIONS, ", "+\t\t\t\t\t\t\tnull); // declaring class.", "+\t\tthis.binding.typeVariables = Binding.NO_TYPE_VARIABLES; // descriptor may have type variables, but they are useless in lambda and lambda cannot be generic.", "+\t\t", "+\t\tif (haveDescriptor) {", "+\t\t\tint descriptorParameterCount = this.singleAbstractMethod.parameters.length;", "+\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "+            if (descriptorParameterCount != lambdaArgumentCount) {", "+            \tthis.scope.problemReporter().lambdaSignatureMismatched(this);", "+            \tif (argumentsTypeElided) ", "+            \t\treturn null; // FUBAR, bail out ...", "+            }", "+\t\t}", "+\t\t", "+\t\tboolean buggyArguments = false;", "+\t\tint length = this.arguments == null ? 0 : this.arguments.length;", "+\t\tTypeBinding[] newParameters = new TypeBinding[length];", "+", "+\t\tAnnotationBinding [][] parameterAnnotations = null;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tArgument argument = this.arguments[i];", "+\t\t\tif (argument.isVarArgs()) {", "+\t\t\t\tif (i == length - 1) {", "+\t\t\t\t\tthis.binding.modifiers |= ClassFileConstants.AccVarargs;", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.scope.problemReporter().illegalVarargInLambda(argument);", "+\t\t\t\t\tbuggyArguments = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argument.annotations != null) {", "+\t\t\t\tthis.binding.tagBits |= TagBits.HasParameterAnnotations;", "+\t\t\t\tif (parameterAnnotations == null) {", "+\t\t\t\t\tparameterAnnotations = new AnnotationBinding[length][];", "+\t\t\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\t\t\tparameterAnnotations[j] = Binding.NO_ANNOTATIONS;", "-\t\t\t\t} /* TODO: else complain */", "+\t\t\t\t}", "+\t\t\t\tparameterAnnotations[i] = argument.binding.getAnnotations();", "+\t\t\t} else if (parameterAnnotations != null) {", "+\t\t\t\tparameterAnnotations[i] = Binding.NO_ANNOTATIONS;", "+\t\t\t}", "+\t\t\t", "+\t\t\tTypeBinding parameterType;", "+\t\t\tfinal TypeBinding expectedParameterType = this.singleAbstractMethod.parameters[i];", "+\t\t\tparameterType = argumentsTypeElided ? expectedParameterType : argument.type.resolveType(this.scope, true /* check bounds*/);", "+\t\t\tif (parameterType == null) {", "+\t\t\t\tbuggyArguments = true;", "+\t\t\t} else if (parameterType == TypeBinding.VOID) {", "+\t\t\t\tthis.scope.problemReporter().argumentTypeCannotBeVoid(this, argument);", "+\t\t\t\tbuggyArguments = true;", "+\t\t\t} else {", "+\t\t\t\tif (!parameterType.isValidBinding()) {", "+\t\t\t\t\tthis.binding.tagBits |= TagBits.HasUnresolvedArguments;", "+\t\t\t\t}", "+\t\t\t\tif ((parameterType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t\t\t}", "+\t\t\t\tif (haveDescriptor && parameterType != expectedParameterType) {", "+\t\t\t\t\tthis.scope.problemReporter().lambdaParameterTypeMismatched(argument, argument.type, expectedParameterType);", "+\t\t\t\t}", "+", "+\t\t\t\tTypeBinding leafType = parameterType.leafComponentType();", "+\t\t\t\tif (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)", "+\t\t\t\t\tthis.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+\t\t\t\tnewParameters[i] = parameterType;", "+\t\t\t\targument.bind(this.scope, parameterType, false);", "+\t\t// only assign parameters if no problems are found", "+\t\tif (!buggyArguments) {", "+\t\t\tthis.binding.parameters = newParameters;", "+\t\t\tif (parameterAnnotations != null)", "+\t\t\t\tthis.binding.setParameterAnnotations(parameterAnnotations);", "+\t\t}", "+\t", "+\t\tif (!argumentsTypeElided && this.binding.isVarargs()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=337795", "+\t\t\tif (!this.binding.parameters[this.binding.parameters.length - 1].isReifiable()) {", "+\t\t\t\tthis.scope.problemReporter().possibleHeapPollutionFromVararg(this.arguments[this.arguments.length - 1]);", "+\t\t\t}", "+\t\t}", "+", "+\t\tReferenceBinding [] exceptions = this.binding.thrownExceptions;", "+\t\tlength = exceptions.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tReferenceBinding exception = exceptions[i];", "+\t\t\tif ((exception.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t\t}", "+\t\t\tthis.binding.modifiers |= (exception.modifiers & ExtraCompilerModifiers.AccGenericSignature);", "+\t\t}", "+\t\t", "+\t\tTypeBinding returnType = this.binding.returnType;", "+\t\tif ((returnType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tthis.binding.tagBits |= TagBits.HasMissingType;", "+\t\t}", "+\t\tTypeBinding leafType = returnType.leafComponentType();", "+\t\tif (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)", "+\t\t\tthis.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;", "+", "+\t\tthis.binding.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;", "+\t\t", "-\t\t\tif (this.functionalInterfaceType.isValidBinding()) {", "-\t\t\t\texpression.setExpectedType(this.singleAbstractMethod.returnType); // chain expected type for any nested lambdas.", "-\t\t\t\t/* TypeBinding expressionType = */ expression.resolveType(this.scope);", "-\t\t\t\t// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);", "-\t\t\t}", "+\t\t\tnew ReturnStatement(expression, expression.sourceStart, expression.sourceEnd, true).resolve(this.scope); // :-) ;-)", "-\t\treturn this.functionalInterfaceType;", "+\t\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "acc077faa9c26955727645ea2cb9a353", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java", "commitBeforeChange": "99d47e4046e97803f75625986f5eb5ffc13cddfe", "commitAfterChange": "8282cb3c46786d73ca763e64384724ac9c0798d9", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "signatureAfterChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding otherType, Map substitutes, int constraint)", "diff": ["-\tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes) {", "+\tpublic void collectSubstitutes(Scope scope, TypeBinding otherType, Map substitutes, int constraint) {", "-\t\tif (this.bound == null)", "-\t\t\treturn;", "-\t\tif (otherType.isWildcard()) {", "-\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "-\t\t\tif (otherWildcard.bound != null) {", "-\t\t\t\tthis.bound.collectSubstitutes(otherWildcard.bound, substitutes);", "-\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "-\t\t\t\t\tthis.bound.collectSubstitutes(otherWildcard.otherBounds[i], substitutes);", "-\t        \t}", "-\t\t\t}", "-\t\t} else {", "-            this.bound.collectSubstitutes(otherType, substitutes);", "-            // check other bounds (lub scenario)", "-        \tfor (int i = 0, length = this.otherBounds == null ? 0 : this.otherBounds.length; i < length; i++) {", "-        \t\tthis.otherBounds[i].collectSubstitutes(otherType, substitutes);", "-        \t}", "-\t\t}\t    ", "+\t\tif ((this.tagBits & TagBits.HasTypeVariable) == 0) return;", "+\t\tif (otherType == NullBinding) return;", "+\t", "+\t\tswitch (constraint) {", "+\t\t\tcase CONSTRAINT_EXTENDS : // A << F", "+\t\t\t\tswitch (this.kind) {", "+\t\t\t\t\tcase Wildcard.UNBOUND: // F={?}", "+//\t\t\t\t\t\tif (otherType.isWildcard()) {", "+//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={?}  --> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t} else { // A=V << F={?} ---> 0", "+//\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.EXTENDS: // F={? extends U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? extends U} ---> V << U", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V << F={? extends U} ---> V << U", "+\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherType, substitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.SUPER: // F={? super U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} << F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} << F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} << F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V << F={? super U} ---> V >> U", "+\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherType, substitutes, CONSTRAINT_SUPER);\t\t\t\t\t\t\t", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase CONSTRAINT_EQUAL : // A == F", "+\t\t\t\tswitch (this.kind) {", "+\t\t\t\t\tcase Wildcard.UNBOUND: // F={?}", "+//\t\t\t\t\t\tif (otherType.isWildcard()) {", "+//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={?}  --> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t} else { // A=V == F={?} ---> 0", "+//\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.EXTENDS: // F={? extends U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? extends U} ---> V == U", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V == F={? extends U} ---> 0", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.SUPER: // F={? super U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} == F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} == F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_EQUAL);", "+\t\t\t\t\t\t        \t}\t", "+\t\t\t\t\t\t        \tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V == F={? super U} ---> 0", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase CONSTRAINT_SUPER : // A >> F", "+\t\t\t\tswitch (this.kind) {", "+\t\t\t\t\tcase Wildcard.UNBOUND: // F={?}", "+//\t\t\t\t\t\tif (otherType.isWildcard()) {", "+//\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+//\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+//\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={?}  --> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={?} ---> 0", "+//\t\t\t\t\t\t\t\t\tbreak;", "+//\t\t\t\t\t\t\t}", "+//\t\t\t\t\t\t} else { // A=V >> F={?} ---> 0", "+//\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.EXTENDS: // F={? extends U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? extends U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? extends U} ---> V >> U", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \t}\t\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? extends U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V == F={? extends U} ---> 0", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.SUPER: // F={? super U}", "+\t\t\t\t\t\tif (otherType.isWildcard()) {", "+\t\t\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherType;", "+\t\t\t\t\t\t\tswitch(otherWildcard.kind) {", "+\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND: // A={?} >> F={? super U}  --> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS: // A={? extends V} >> F={? super U} ---> 0", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase Wildcard.SUPER: // A={? super V} >> F={? super U} ---> V >> U", "+\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.bound, substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \tfor (int i = 0, length = otherWildcard.otherBounds == null ? 0 : otherWildcard.otherBounds.length; i < length; i++) {", "+\t\t\t\t\t\t\t\t\t\tthis.bound.collectSubstitutes(scope, otherWildcard.otherBounds[i], substitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t\t        \t}\t", "+\t\t\t\t\t\t        \tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else { // A=V >> F={? super U} ---> 0", "+\t\t\t\t\t\t}\t\t\t\t\t\t", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t}"]}], "num": 8590}