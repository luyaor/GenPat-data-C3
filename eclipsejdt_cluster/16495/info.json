{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5fd2091b07bea0197f35c9f01422f98a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1f0791808a8b2f859b350908d9a0b2d8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "3617e411ab09a4b93e5840b8e6d451f0c6a8a8c9", "commitAfterChange": "3f2dbb1c863e3e36f3c44754809ef2e96e6a175a", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public SyntheticAccessMethodBinding addSyntheticBridgeMethod(MethodBinding inheritedMethodToBridge, MethodBinding localTargetMethod)", "signatureAfterChange": " public SyntheticAccessMethodBinding addSyntheticBridgeMethod(MethodBinding inheritedMethodToBridge, MethodBinding localTargetMethod)", "diff": ["+\t} else {", "+\t\t// TODO (philippe) MethodBindings do not implement equals() so how do we prevent adding 2 'equal' inherited methods?", "+\t\t// check to see if there is another equivalent inheritedMethod already added", "+\t\tIterator synthMethods = synthetics[METHOD_EMUL].keySet().iterator();", "+\t\twhile (synthMethods.hasNext()) {", "+\t\t\tObject method = synthMethods.next();", "+\t\t\tif (method instanceof MethodBinding)", "+\t\t\t\tif (inheritedMethodToBridge.areParameterErasuresEqual((MethodBinding) method))", "+\t\t\t\t\treturn null;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "63692359b52dde61a2b0068743ccd1ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "72316be54b9086b28cc8ddca3e0761905b39515b", "commitAfterChange": "995fcf13bc3ad1e9b32a28fa575739b0c1b6aa41", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \tpublic IJavaElementDelta[] processResourceDelta(IResourceDelta changes)", "signatureAfterChange": "\r \tpublic IJavaElementDelta[] processResourceDelta(IResourceDelta changes)", "diff": ["-\t\t// get the workspace delta, and start processing there.\r", "-\t\tIResourceDelta[] deltas = changes.getAffectedChildren();\r", "-\t\tIJavaElementDelta[] translatedDeltas = new JavaElementDelta[deltas.length];\r", "-\t\tfor (int i = 0; i < deltas.length; i++) {\r", "-\t\t\tIResourceDelta delta = deltas[i];\r", "-\t\t\tJavaModel model =\r", "-\t\t\t\tJavaModelManager.getJavaModel(delta.getResource().getWorkspace());\r", "-\t\t\tif (model != null) {\r", "-\t\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "-\t\t\t\ttraverseDelta(delta, UNKNOWN_CLASSPATH); // traverse delta\r", "-\t\t\t\ttranslatedDeltas[i] = fCurrentDelta;\r", "+\t\ttry {\r", "+\t\t\t// get the workspace delta, and start processing there.\r", "+\t\t\tIResourceDelta[] deltas = changes.getAffectedChildren();\r", "+\t\t\tIJavaElementDelta[] translatedDeltas = new JavaElementDelta[deltas.length];\r", "+\t\t\tfor (int i = 0; i < deltas.length; i++) {\r", "+\t\t\t\tIResourceDelta delta = deltas[i];\r", "+\t\t\t\tJavaModel model =\r", "+\t\t\t\t\tJavaModelManager.getJavaModel(delta.getResource().getWorkspace());\r", "+\t\t\t\tif (model != null) {\r", "+\t\t\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "+\t\t\t\t\ttraverseDelta(delta, UNKNOWN_CLASSPATH); // traverse delta\r", "+\t\t\t\t\ttranslatedDeltas[i] = fCurrentDelta;\r", "+\t\t\t\t}\r", "+\t\t\t\r", "+\t\t\t// update package fragment roots of projects that were affected\r", "+\t\t\tEnumeration elements = this.projectsToUpdate.elements();\r", "+\t\t\twhile (elements.hasMoreElements()) {\r", "+\t\t\t\tJavaProject project = (JavaProject)elements.nextElement();\r", "+\t\t\t\tproject.updatePackageFragmentRoots();\r", "+\t\t\t}\r", "+\t\r", "+\t\t\treturn filterRealDeltas(translatedDeltas);\r", "+\t\t} finally {\r", "+\t\t\tthis.projectsToUpdate = new ObjectSet();\r", "-\r", "-\t\treturn filterRealDeltas(translatedDeltas);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88ad2c679641cd4748d2fa862319cde5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "fe41a5ed7a14de553c93fde5ff3064717032f87a", "commitAfterChange": "75a9b073354511bd41fc601022882d52caaa8ded", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \tpublic void fire()", "signatureAfterChange": "\r \tpublic void fire()", "diff": ["+\t\t\t\t\t\r", "+\t\t\t\t\t// Refresh internal scopes\r", "+\t\t\t\t\tIterator scopes = this.scopes.keySet().iterator();\r", "+\t\t\t\t\twhile (scopes.hasNext()) {\r", "+\t\t\t\t\t\tAbstractSearchScope scope = (AbstractSearchScope)scopes.next();\r", "+\t\t\t\t\t\tscope.processDelta(delta);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t\r"]}], "num": 16495}