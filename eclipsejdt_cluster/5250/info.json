{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c7e16a2598cc415201f09619ed5dcde6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46294686aa9732260c79206c652b1c58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "7e00ac35502a1ca240692e402a21abc4965fcca3", "commitAfterChange": "d3df82b4b651a728dac7ad34ce68970057ee30f8", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\t\t\t\t\tif (existingMethods != null)", "-\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "-\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "-\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\tif (existingMethods != null) {", "+\t\t\t\t\t\t// 30805 - non-visible (abstract) method still needs to be implemented even if similar method defined below (overridesPackageDefaultMethod) ", "+\t\t\t\t\t\tif (!(method.isDefault() && method.isAbstract() && (method.declaringClass.fPackage != type.fPackage))) { ", "+\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)", "+\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)", "+\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))", "+\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73d7d0637a5e0d583a1e0c6969624cad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "4f899ed65a6db0134a5169430983a39f00dbaf4c", "commitAfterChange": "302ba575da16bb6fb5610129dd618d637661239d", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)", "diff": ["-\t\t\t} else {", "+\t\t\t} else if (inheritedMethod.isPublic() || !type.isInterface()) {", "+\t\t\t\t// interface I { @Override Object clone(); } does not override Object#clone()", "-\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod))", "+\t\t\tif (!areReturnTypesCompatible(currentMethod, inheritedMethod)", "+\t\t\t\t\t&& (currentMethod.returnType.tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t}"]}], "num": 5250}