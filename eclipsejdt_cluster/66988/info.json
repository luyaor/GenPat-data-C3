{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8c9b0f48ad86728c86631664d2273006", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "536a26a8580d4a288f444580daeb7345", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/FormatterCommentParser.java", "commitBeforeChange": "e57e9e9b74a0efc06fcbf1fbb40dac7e7fed4c94", "commitAfterChange": "fed29f876dbd67e4d7770f5efdfd5f6894bd8a61", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected boolean parseHtmlTag(int previousPosition, int endTextPosition) throws InvalidInputException", "signatureAfterChange": " protected boolean parseHtmlTag(int previousPosition, int endTextPosition) throws InvalidInputException", "diff": ["+    int currentPosition = start;", "+    char firstChar = peekChar();", "+    boolean hasWhitespaces = firstChar == ' ' || ScannerHelper.isWhitespace(firstChar);", "+\t\t\t\tcurrentPosition = this.scanner.currentPosition;", "+\t\t\t\tcurrentPosition = this.scanner.currentPosition;", "-\t    if ((token = readTokenAndConsume()) != TerminalTokens.TokenNameGREATER) {", "-\t    \tif ((htmlIndex & JAVADOC_SPECIAL_TAGS_ID) == JAVADOC_SPECIAL_TAGS_ID) {", "-\t    \t\t// Special tags may have attributes, so consume tokens until the greater token is encountered", "-\t    \t\twhile (token != TerminalTokens.TokenNameGREATER) {", "-\t    \t\t\ttoken = readTokenAndConsume();", "-\t    \t\t\tif (token == TerminalTokens.TokenNameEOF) {", "-\t    \t\t\t\treturn false;", "-\t    \t\t\t}", "+\t    ", "+\t    // Looking for tag closing", "+\t    switch (token = readTokenAndConsume()) {", "+\t    \tcase TerminalTokens.TokenNameLESS:", "+\t    \tcase TerminalTokens.TokenNameLESS_EQUAL:", "+\t    \t\t// consider that the closing '>' is missing", "+\t    \t\treturn false;", "+\t    \tcase TerminalTokens.TokenNameGREATER:", "+\t    \t\t// simple tag without attributes", "+\t    \t\tbreak;", "+\t    \tcase TerminalTokens.TokenNameGREATER_EQUAL:", "+\t    \tcase TerminalTokens.TokenNameRIGHT_SHIFT:", "+\t    \tcase TerminalTokens.TokenNameRIGHT_SHIFT_EQUAL:", "+\t    \t\t// simple tag without attributes, but the closing '>' is followed by an '=' or '>'", "+\t    \t\tbreak;", "+\t    \tdefault:", "+\t    \t\tthis.index = currentPosition;", "+\t    \t\tloop: while (true) {", "+//\t    \t\t\tcurrentPosition = this.index;", "+\t\t\t\t    switch (readChar()) {", "+\t\t\t\t    \tcase '<':", "+\t\t\t\t    \t\tif (hasWhitespaces) {", "+\t\t\t\t    \t\t\t// not 100% sure this is a tag definition => give up", "+\t\t\t\t    \t\t\treturn false;", "+\t\t\t\t    \t\t}", "+\t\t\t\t    \t\t// opening tag => consider the current one as closed", "+\t\t\t\t    \t\tthis.index = currentPosition;", "+\t\t\t\t    \t\tthis.scanner.startPosition = currentPosition;", "+\t\t\t\t    \t\tthis.scanner.currentPosition = currentPosition;", "+\t\t\t\t    \t\tthis.scanner.currentCharacter = '<';", "+\t\t\t\t    \t\tbreak loop;", "+\t\t\t\t    \tcase '>':", "+\t\t\t\t    \t\t// simple tag without attributes", "+\t\t\t\t    \t\tthis.scanner.startPosition = this.index;", "+\t\t\t\t    \t\tthis.scanner.currentPosition = this.index;", "+\t\t\t\t    \t\tthis.scanner.currentCharacter = peekChar();", "+\t\t\t\t    \t\tbreak loop;", "+\t\t\t    \t\tdefault:", "+\t\t\t    \t\t\tbreak;", "+\t\t\t\t    }", "+\t\t\t\t    if (this.index >= this.javadocTextEnd) {", "+\t\t    \t\t\t// the end of the comment is reached => consider current tag as closed", "+\t\t\t    \t\tthis.index = currentPosition;", "+\t\t\t    \t\tthis.scanner.startPosition = currentPosition;", "+\t\t\t    \t\tthis.scanner.currentPosition = currentPosition;", "+\t\t\t    \t\tbreak;", "+\t\t\t\t    }", "-\t    \t} else {", "-\t\t    \t// invalid syntax", "-\t\t\t\treturn false;", "-\t    \t}", "-\t    }", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd60c0c1d73b7c2feb567d32224e4d80", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "330aeaad59d1633d10c0cd3a9ee9ac57073b385f", "commitAfterChange": "960ce528d76bd309a28ce655fc14cff77629ffa5", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["-\t */", "-", "-\t\t// In case of previous return tag, set it to not empty if parsing an inline tag", "-\t\tif (this.currentAstPtr != -2 && this.returnStatement != null) {", "-\t\t\tthis.currentAstPtr = -2;", "-\t\t\tJavadocReturnStatement javadocReturn = (JavadocReturnStatement) this.returnStatement;", "-\t\t\tjavadocReturn.empty = javadocReturn.empty && !this.inlineTagStarted;", "-\t\t}", "-", "+\t", "-\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+\t", "+\t\t// Try to get tag name other than java identifier", "+\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\tchar pc = peekChar();", "+\t\tboolean validTag = false;", "+\t\tswitch (token) {", "+\t\t\tcase TerminalTokens.TokenNameIdentifier:", "+\t\t\tcase TerminalTokens.TokenNamereturn:", "+\t\t\tcase TerminalTokens.TokenNamethrows:", "+\t\t\t\tvalidTag= true;", "+\t\t}", "+\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "+\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "+\t\t\tswitch (pc) {", "+\t\t\t\tcase '}':", "+\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "+\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\tcase '!':", "+\t\t\t\tcase '#':", "+\t\t\t\tcase '%':", "+\t\t\t\tcase '&':", "+\t\t\t\tcase '\\'':", "+\t\t\t\tcase '\"':", "+\t\t\t\tcase ':':", "+\t\t\t\t// case '-': allowed in tag names as this character is often used in doclets (bug 68087)", "+\t\t\t\tcase '<':", "+\t\t\t\tcase '>':", "+\t\t\t\t\treadChar();", "+\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\tvalidTag = false;", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;", "+\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\ttoken = readTokenAndConsume();", "+\t\t\t}", "+\t\t\tpc = peekChar();", "+\t\t}", "+\t\tif (!validTag) {", "+\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\treturn false;", "+\t\t}", "+\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\tchar[] tag = new char[length];", "+\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\tthis.index = this.tagSourceEnd+1;", "+\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;"]}], "num": 66988}