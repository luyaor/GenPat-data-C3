{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4998a2d5792ae7a05ae566bfe5699d90", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ccc83290466479606adbc29a9d165891", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " public int literalIndex(long key)", "signatureAfterChange": " public int literalIndex(long key)", "diff": ["-\t// Retrieve the index from the cache", "-\t// The long constant takes two indexes into the constant pool, but we only store", "-\t// the first index into the long table", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (longCache == null) {", "-\t\tlongCache = new LongCache(LONG_INITIAL_SIZE);", "-\t}", "-\tif ((index = longCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tthis.currentIndex+= 2; // long value need an extra place into thwe constant pool", "-\t\t// Write the long into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(LongTag);", "-\t\t// Then add the 8 bytes representing the long", "-\t\tif (currentOffset + 8 >= poolContent.length) {", "-\t\t\tresizePoolContents(8);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 56);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 48);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 40);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 32);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (key >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) key;", "-\t}", "-\treturn index;", "+    // Retrieve the index from the cache", "+    // The long constant takes two indexes into the constant pool, but we only store", "+    // the first index into the long table", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (longCache == null) {", "+        longCache = new LongCache(LONG_INITIAL_SIZE);", "+    }", "+    if ((index = longCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        if ((index = -index) > 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        this.currentIndex+= 2; // long value need an extra place into thwe constant pool", "+        // Write the long into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(LongTag);", "+        // Then add the 8 bytes representing the long", "+        if (currentOffset + 8 >= poolContent.length) {", "+            resizePoolContents(8);", "+        }", "+        poolContent[currentOffset++] = (byte) (key >>> 56);", "+        poolContent[currentOffset++] = (byte) (key >>> 48);", "+        poolContent[currentOffset++] = (byte) (key >>> 40);", "+        poolContent[currentOffset++] = (byte) (key >>> 32);", "+        poolContent[currentOffset++] = (byte) (key >>> 24);", "+        poolContent[currentOffset++] = (byte) (key >>> 16);", "+        poolContent[currentOffset++] = (byte) (key >>> 8);", "+        poolContent[currentOffset++] = (byte) key;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cec23661d67d5dfc3fdc706903ce828a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public int literalIndex(double key)", "signatureAfterChange": " public int literalIndex(double key)", "diff": ["-\t//Retrieve the index from the cache", "-\t// The double constant takes two indexes into the constant pool, but we only store", "-\t// the first index into the long table", "-\tint index;", "-\t// lazy initialization for base type caches", "-\t// If it is null, initialize it, otherwise use it", "-\tif (doubleCache == null) {", "-\t\t\tdoubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);", "-\t}", "-\tif ((index = doubleCache.putIfAbsent(key, this.currentIndex)) < 0) {", "-\t\tif ((index = -index)> 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tthis.currentIndex += 2; // a double needs an extra place into the constant pool", "-\t\t// Write the double into the constant pool", "-\t\t// First add the tag", "-\t\twriteU1(DoubleTag);", "-\t\t// Then add the 8 bytes representing the double", "-\t\tlong temp = java.lang.Double.doubleToLongBits(key);", "-\t\tint length = poolContent.length;", "-\t\tif (currentOffset + 8 >= length) {", "-\t\t\tresizePoolContents(8);", "-\t\t}", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 56);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 48);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 40);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 32);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 24);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 16);", "-\t\tpoolContent[currentOffset++] = (byte) (temp >>> 8);", "-\t\tpoolContent[currentOffset++] = (byte) temp;", "-\t}", "-\treturn index;", "+    //Retrieve the index from the cache", "+    // The double constant takes two indexes into the constant pool, but we only store", "+    // the first index into the long table", "+    int index;", "+    // lazy initialization for base type caches", "+    // If it is null, initialize it, otherwise use it", "+    if (doubleCache == null) {", "+            doubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);", "+    }", "+    if ((index = doubleCache.putIfAbsent(key, this.currentIndex)) < 0) {", "+        if ((index = -index)> 0xFFFF){", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        this.currentIndex += 2; // a double needs an extra place into the constant pool", "+        // Write the double into the constant pool", "+        // First add the tag", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(DoubleTag);", "+        // Then add the 8 bytes representing the double", "+        long temp = java.lang.Double.doubleToLongBits(key);", "+        length = poolContent.length;", "+        if (currentOffset + 8 >= length) {", "+            resizePoolContents(8);", "+        }", "+        poolContent[currentOffset++] = (byte) (temp >>> 56);", "+        poolContent[currentOffset++] = (byte) (temp >>> 48);", "+        poolContent[currentOffset++] = (byte) (temp >>> 40);", "+        poolContent[currentOffset++] = (byte) (temp >>> 32);", "+        poolContent[currentOffset++] = (byte) (temp >>> 24);", "+        poolContent[currentOffset++] = (byte) (temp >>> 16);", "+        poolContent[currentOffset++] = (byte) (temp >>> 8);", "+        poolContent[currentOffset++] = (byte) temp;", "+    }", "+    return index;"]}], "num": 36047}