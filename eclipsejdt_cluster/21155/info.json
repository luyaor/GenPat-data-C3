{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8ba3f37d3dd03f028bc5dfda6f885b71", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02edce0b4682c2df399d7bdfa07b2949", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "04b81cf15831bfe4330d81980faeafc08a8dde64", "commitAfterChange": "2648bf4db83bb49e8d037c44e11a0a6a32668be2", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\t\t", "+\t\t\t\t// all classpaths in the workspace are going to be resolved, ensure that containers are initialized in one batch", "+\t\t\t\tmanager.batchContainerInitializations = true; ", "+\t\t\t\t", "+\t\t\t\t// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413)", "+\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();", "+\t\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\t\t\t\tIClasspathEntry[] classpath = ((JavaProject) projects[i]).getResolvedClasspath();", "+\t\t\t\t\tif (classpath != null) {", "+\t\t\t\t\t\tfor (int j = 0, length2 = classpath.length; j < length2; j++) {", "+\t\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "+\t\t\t\t\t\t\tif (entry.getSourceAttachmentPath() != null)", "+\t\t\t\t\t\t\t\tUtil.setSourceAttachmentProperty(entry.getPath(), null);", "+\t\t\t\t\t\t\t// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// initialize delta state", "+\t\t\t\tmanager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment proprties", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0334c17814e54dfb4bdc225a8343092f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java", "commitBeforeChange": "7658885de020459a43d5c54a62e5511e4cf48903", "commitAfterChange": "effc87828d40c0b15d95e17b44487025194ac03b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t  \tprivate static Scanner getNameScanner(CompilerOptions compilerOptions)", "signatureAfterChange": " \t\tpublic char[][] getResults()", "diff": ["+\t\t}", "+\t\tpublic char[][] getResults(){", "+\t\t\tint count = prefixAndSuffixResultsCount + prefixResultsCount + suffixResultsCount + otherResultsCount;", "+\t\t\tchar[][] results = new char[count][];", "+\t\t\t", "+\t\t\tint index = 0;", "+\t\t\tSystem.arraycopy(prefixAndSuffixResults, 0, results, index, prefixAndSuffixResultsCount);", "+\t\t\tindex += prefixAndSuffixResultsCount;", "+\t\t\tSystem.arraycopy(prefixResults, 0, results, index, prefixResultsCount);", "+\t\t\tindex += prefixResultsCount;", "+\t\t\tSystem.arraycopy(suffixResults, 0, results, index, suffixResultsCount);", "+\t\t\tindex += suffixResultsCount;", "+\t\t\tSystem.arraycopy(otherResults, 0, results, index, otherResultsCount);", "+\t\t\t", "+\t\t\treturn results;", "+\t\t}", "-", "-\tprivate static Scanner getNameScanner(CompilerOptions compilerOptions) {", "-\t\treturn", "-\t\t\tnew Scanner(", "-\t\t\t\tfalse /*comment*/, ", "-\t\t\t\tfalse /*whitespace*/, ", "-\t\t\t\tfalse /*nls*/, ", "-\t\t\t\tcompilerOptions.sourceLevel >= CompilerOptions.JDK1_4 /*assert*/, ", "-\t\t\t\tcompilerOptions.complianceLevel >= CompilerOptions.JDK1_4 /*strict comment*/,", "-\t\t\t\tnull /*taskTags*/, ", "-\t\t\t\tnull/*taskPriorities*/);", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "06d93b82fb31c981a8df324564dae154", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBuilder.java", "commitBeforeChange": "f5262e0e66d7e25877ee8d8a091dd788b69869c5", "commitAfterChange": "47e88d0335bbb81b7bc00bc5460ee9a54afeb8fd", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r public void connect(IGenericType suppliedType, IGenericType superclass, IGenericType[] superinterfaces)", "signatureAfterChange": "\r public void connect(IGenericType suppliedType, IGenericType superclass, IGenericType[] superinterfaces)", "diff": ["+\tif (TypeHierarchy.DEBUG) {\r", "+\t\tSystem.out.println(\"Connecting: \" + ((JavaElement)typeHandle).toStringWithAncestors()); //$NON-NLS-1$\r", "+\t\tSystem.out.println(\"  to superclass: \" + (superHandle == null ? \"<None>\" : ((JavaElement)superHandle).toStringWithAncestors())); //$NON-NLS-1$ //$NON-NLS-2$\r", "+\t\tSystem.out.print(\"  and superinterfaces:\"); //$NON-NLS-1$\r", "+\t\tif (interfaceHandles == null) {\r", "+\t\t\tSystem.out.println(\" <None>\"); //$NON-NLS-1$\r", "+\t\t} else {\r", "+\t\t\tSystem.out.println();\r", "+\t\t\tfor (int i = 0, length = interfaceHandles.length; i < length; i++) {", "+\t\t\t\tSystem.out.println(\"    \" + ((JavaElement)interfaceHandles[i]).toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09095c4b61b907ca5e5e6ffa95eed0b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java", "commitBeforeChange": "6ec24b06cd0bcb5a744d15b20332350fd24ef6a3", "commitAfterChange": "02dcf6f68bd209d5530306427455d30bd6fad0d9", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \tpublic static int getPossibleComplianceLevels()", "signatureAfterChange": " \tpublic static int getPossibleComplianceLevels()", "diff": ["-\t\tif (possibleComplianceLevels == -1) {", "+\t\tif (possibleComplianceLevels == UNINITIALIZED) {", "-\t\t\t\t\tpossibleComplianceLevels = F_1_3;", "+\t\t\t\t\tpossibleComplianceLevels = RUN_JAVAC ? NONE : F_1_3;", "-\t\t\t\t\tpossibleComplianceLevels = F_1_4;", "+\t\t\t\t\tpossibleComplianceLevels = RUN_JAVAC ? NONE : F_1_4;", "-\t\t\tif (possibleComplianceLevels == -1) {", "-\t\t\t\tpossibleComplianceLevels = F_1_3;", "+\t\t\tif (possibleComplianceLevels == UNINITIALIZED) {", "-\t\t\t\tboolean canRun1_4 = !\"1.0\".equals(specVersion)", "-\t\t\t\t\t&& !CompilerOptions.VERSION_1_1.equals(specVersion)", "-\t\t\t\t\t&& !CompilerOptions.VERSION_1_2.equals(specVersion)", "-\t\t\t\t\t&& !CompilerOptions.VERSION_1_3.equals(specVersion);", "-\t\t\t\tif (canRun1_4) {", "-\t\t\t\t\tpossibleComplianceLevels |= F_1_4;", "-\t\t\t\t}", "-\t\t\t\tboolean canRun1_5 = canRun1_4 && !CompilerOptions.VERSION_1_4.equals(specVersion);", "-\t\t\t\tif (canRun1_5) {", "-\t\t\t\t\tpossibleComplianceLevels |= F_1_5;", "-\t\t\t\t}", "-\t\t\t\tboolean canRun1_6 = canRun1_5 && !CompilerOptions.VERSION_1_5.equals(specVersion);", "-\t\t\t\tif (canRun1_6) {", "-\t\t\t\t\tpossibleComplianceLevels |= F_1_6;", "-\t\t\t\t}", "-\t\t\t\tboolean canRun1_7 = canRun1_6 && !CompilerOptions.VERSION_1_6.equals(specVersion);", "-\t\t\t\tif (canRun1_7) {", "-\t\t\t\t\tpossibleComplianceLevels |= F_1_7;", "+\t\t\t\tif (!RUN_JAVAC) {", "+\t\t\t\t\tpossibleComplianceLevels = F_1_3;", "+\t\t\t\t\tboolean canRun1_4 = !\"1.0\".equals(specVersion)", "+\t\t\t\t\t\t&& !CompilerOptions.VERSION_1_1.equals(specVersion)", "+\t\t\t\t\t\t&& !CompilerOptions.VERSION_1_2.equals(specVersion)", "+\t\t\t\t\t\t&& !CompilerOptions.VERSION_1_3.equals(specVersion);", "+\t\t\t\t\tif (canRun1_4) {", "+\t\t\t\t\t\tpossibleComplianceLevels |= F_1_4;", "+\t\t\t\t\t}", "+\t\t\t\t\tboolean canRun1_5 = canRun1_4 && !CompilerOptions.VERSION_1_4.equals(specVersion);", "+\t\t\t\t\tif (canRun1_5) {", "+\t\t\t\t\t\tpossibleComplianceLevels |= F_1_5;", "+\t\t\t\t\t}", "+\t\t\t\t\tboolean canRun1_6 = canRun1_5 && !CompilerOptions.VERSION_1_5.equals(specVersion);", "+\t\t\t\t\tif (canRun1_6) {", "+\t\t\t\t\t\tpossibleComplianceLevels |= F_1_6;", "+\t\t\t\t\t}", "+\t\t\t\t\tboolean canRun1_7 = canRun1_6 && !CompilerOptions.VERSION_1_6.equals(specVersion);", "+\t\t\t\t\tif (canRun1_7) {", "+\t\t\t\t\t\tpossibleComplianceLevels |= F_1_7;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (\"1.0\".equals(specVersion)", "+\t\t\t\t\t\t\t|| CompilerOptions.VERSION_1_1.equals(specVersion)", "+\t\t\t\t\t\t\t|| CompilerOptions.VERSION_1_2.equals(specVersion)", "+\t\t\t\t\t\t\t|| CompilerOptions.VERSION_1_3.equals(specVersion)", "+\t\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(specVersion)) {", "+\t\t\t\t\tpossibleComplianceLevels = NONE;", "+\t\t\t\t} else {", "+\t\t\t\t\tpossibleComplianceLevels = F_1_5;", "+\t\t\t\t\tif (!CompilerOptions.VERSION_1_5.equals(specVersion)) {", "+\t\t\t\t\t\tpossibleComplianceLevels |= F_1_6;", "+\t\t\t\t\t\tif (!CompilerOptions.VERSION_1_6.equals(specVersion)) {", "+\t\t\t\t\t\t\tpossibleComplianceLevels |= F_1_7;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\tif (possibleComplianceLevels == NONE) {", "+\t\t\tSystem.out.println(\"Skipping all compliances (found none compatible with run.javac=enabled).\");", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "095b2db7c5c9b8055f379a99a0f361f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic TypeBinding substitute(TypeVariableBinding originalVariable)", "signatureAfterChange": " \t\tpublic TypeBinding substitute(TypeVariableBinding typeVariable)", "diff": ["+\t\t// With T mapping to I<T>, answer of I<?>, when given T, having eliminated the circularity/self reference.", "+\t\tpublic TypeBinding substitute(TypeVariableBinding typeVariable) {", "+\t\t\tif (typeVariable.rank >= this.variables.length || this.variables[typeVariable.rank] != typeVariable) {   // not kosher, don't touch.", "+\t\t\t\treturn typeVariable;", "+\t\t\t}", "+\t\t\tif (this.substitutes != null) {", "+\t\t\t\treturn Scope.substitute(new LingeringTypeVariableEliminator(this.variables, null, this.scope), this.substitutes[typeVariable.rank]); ", "+\t\t\t}", "+\t\t\tReferenceBinding genericType = (ReferenceBinding) (typeVariable.declaringElement instanceof ReferenceBinding ? typeVariable.declaringElement : null);", "+\t\t\treturn this.scope.environment().createWildcard(genericType, typeVariable.rank, null, null, Wildcard.UNBOUND);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0af26f9525fb0b6ae6f5ece13703299b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "86397dfc80023f615cc88c0705b2ada916e6efb2", "commitAfterChange": "24624a25f60573230ed7652730faedca15fd4d8b", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "signatureAfterChange": "  \tpublic NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries)", "diff": ["+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// cache whether each package and its including packages (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=119161)", "+\t\t// are actual packages", "+\t\tthis.isPackageCache = new HashtableOfArrayToObject();", "+\t\tfor (int i = 0, size = this.packageFragments.keyTable.length; i < size; i++) {", "+\t\t\tString[] pkgName = (String[]) this.packageFragments.keyTable[i];", "+\t\t\tif (pkgName == null) continue;", "+\t\t\tthis.isPackageCache.put(pkgName, pkgName);", "+\t\t\tint length = pkgName.length;", "+\t\t\tfor (int j = length-1; j > 0; j--) {", "+\t\t\t\tString[] subPkgName = new String[j];", "+\t\t\t\tSystem.arraycopy(pkgName, 0, subPkgName, 0, j);", "+\t\t\t\tthis.isPackageCache.put(subPkgName, subPkgName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15bf6fa025e1c5204cbd086f063066cd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "e9b8570c48a3adcf8ca596d7d5d3cb77e7107b24", "commitAfterChange": "d9f86abd22aa02e46b78f3fcafe4e36317129341", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames)", "signatureAfterChange": "\r protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames)", "diff": ["+\t\tif(SelectionEngine.DEBUG){\r", "+\t\t\tSystem.out.print(\"SELECTION - accept type(\"); //$NON-NLS-1$\r", "+\t\t\tSystem.out.print(type.toString());\r", "+\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$\r", "+\t\t}\r", "+\t\tif(SelectionEngine.DEBUG){\r", "+\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$\r", "+\t\t\tSystem.out.print(matches[0].toString());\r", "+\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$\r", "+\t\t}\r", "+\t\t\tif(SelectionEngine.DEBUG){\r", "+\t\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$\r", "+\t\t\t\tSystem.out.print(method.toString());\r", "+\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "17611c6cbee6907c4b1d5c7233db9c1a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "9a8c0b7f51c1a0b9d37b7d38acb4d0261e31390a", "commitAfterChange": "278bd24e5aaae65022c9b0e7c10b22e5ffa034b6", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " \t \tpublic TextEdit getRootEdit()", "signatureAfterChange": " \t \tpublic TextEdit getRootEdit()", "diff": ["-\t\tint length = this.textRegionEnd - this.textRegionStart + 1;", "-\t\tif (this.textRegionStart <= 0) {", "+\t\tint regionsLength = this.regions.length;", "+\t\tint textRegionStart;", "+\t\tint textRegionEnd;", "+\t\tif (regionsLength == 1) {", "+\t\t\tIRegion lastRegion = this.regions[0];", "+\t\t\ttextRegionStart = lastRegion.getOffset();", "+\t\t\ttextRegionEnd = textRegionStart + lastRegion.getLength();", "+\t\t} else {", "+\t\t\ttextRegionStart = this.regions[0].getOffset();", "+\t\t\tIRegion lastRegion = this.regions[regionsLength - 1];", "+\t\t\ttextRegionEnd = lastRegion.getOffset() + lastRegion.getLength();", "+\t\t}", "+\t\t", "+\t\tint length = textRegionEnd - textRegionStart + 1;", "+\t\tif (textRegionStart <= 0) {", "-\t\t\t\tedit = new MultiTextEdit(0, this.textRegionEnd + 1);", "+\t\t\t\tedit = new MultiTextEdit(0, textRegionEnd);", "-\t\t\tedit = new MultiTextEdit(this.textRegionStart, this.textRegionEnd - this.textRegionStart + 1);", "+\t\t\tedit = new MultiTextEdit(textRegionStart, length - 1);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1d8dbd5e4d40e6e5f1c99b6e8ecc670e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "4a42ce44b4dbdac7dfa261ef1a39fce0de95d7be", "commitAfterChange": "51fbd8e4f6294604d20aa6227743a8c8abfdc166", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r \r protected void findAffectedSourceFiles(IResourceDelta binaryDelta, int segmentCount)", "signatureAfterChange": "\r \r protected void findAffectedSourceFiles(IResourceDelta binaryDelta, int segmentCount)", "diff": ["-\t\t\t\t\tIPath packagePath = location.removeFirstSegments(segmentCount).makeRelative();\r", "-\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "-\t\t\t\t\t\tSystem.out.println(\"Add dependents of added/removed package \" + packagePath); //$NON-NLS-1$\r", "-\t\t\t\t\taddDependentsOf(packagePath, false);\r", "-\t\t\t\t\treturn;\r", "+\t\t\t\t\tIPath packagePath = location.removeFirstSegments(segmentCount).makeRelative().setDevice(null);\r", "+\t\t\t\t\tString packageName = packagePath.toString();\r", "+\t\t\t\t\tif (binaryDelta.getKind() == IResourceDelta.ADDED) {\r", "+\t\t\t\t\t\t// see if any known source file is from the same package... classpath already includes new package\r", "+\t\t\t\t\t\tif (!newState.isKnownPackage(packageName)) {\r", "+\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\t\t\t\t\t\tSystem.out.println(\"Add dependents of added package \" + packageName); //$NON-NLS-1$\r", "+\t\t\t\t\t\t\taddDependentsOf(packagePath, false);\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\t\t\t\t\tSystem.out.println(\"Skipped dependents of added package \" + packageName); //$NON-NLS-1$\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t// see if the package still exists on the classpath\r", "+\t\t\t\t\t\tif (!nameEnvironment.isPackage(packageName)) {\r", "+\t\t\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\t\t\t\t\t\tSystem.out.println(\"Add dependents of removed package \" + packageName); //$NON-NLS-1$\r", "+\t\t\t\t\t\t\taddDependentsOf(packagePath, false);\r", "+\t\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\t\t\t\t\tSystem.out.println(\"Skipped dependents of removed package \" + packageName); //$NON-NLS-1$\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// fall thru & traverse the sub-packages and .class files\r", "-\t\t\t\tIPath typePath = location.removeFirstSegments(segmentCount).removeFileExtension().makeRelative();\r", "+\t\t\t\tIPath typePath = location.removeFirstSegments(segmentCount).removeFileExtension().makeRelative().setDevice(null);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "20d7f739ff9367f2561670a81826f51c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "5166ddb130bcb062c1e82da491c829c5d95a6211", "commitAfterChange": "2894ba75386697d7bf484434d073fb6ffaf6cec9", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 11, "signatureBeforeChange": " private MethodBinding createMethod(IBinaryMethod method, long sourceLevel)", "signatureAfterChange": " private MethodBinding createMethod(IBinaryMethod method, long sourceLevel)", "diff": ["+\tAnnotationBinding[][] paramAnnotations = null; ", "+\t\t\tif (this.environment.storeAnnotations)", "+\t\t\t\tparamAnnotations = new AnnotationBinding[size][];", "-\t\t\t\tif (i >= startIndex)   // skip the synthetic arg if necessary", "+\t\t\t\tif (i >= startIndex) {   // skip the synthetic arg if necessary", "+\t\t\t\t\t// 'paramAnnotations' line up with 'parameters'", "+\t\t\t\t\t// int parameter to method.getParameterAnnotations() include the synthetic arg", "+\t\t\t\t\tif (paramAnnotations != null)", "+\t\t\t\t\t\tparamAnnotations[i - startIndex] = createAnnotations(method.getParameterAnnotations(i), this.environment);", "+\t\t\t\t}", "-\t\t\t\tparameters = new TypeBinding[types.size()];", "+\t\t\t\tint numParam = types.size();", "+\t\t\t\tparameters = new TypeBinding[numParam];", "+\t\t\t\tif (this.environment.storeAnnotations) {", "+\t\t\t\t\tparamAnnotations = new AnnotationBinding[numParam][];", "+\t\t\t\t\tfor (int i = 0; i < numParam; i++)", "+\t\t\t\t\t\tparamAnnotations[i] = createAnnotations(method.getParameterAnnotations(i), this.environment);", "+\t\t\t\t}", "+\tif (this.environment.storeAnnotations)", "+\t\tresult.setAnnotations(", "+\t\t\tcreateAnnotations(method.getAnnotations(), this.environment),", "+\t\t\tparamAnnotations,", "+\t\t\tisAnnotationType() ? convertMemberValue(method.getDefaultValue(), this.environment) : null);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "222f0b9c05905121bb897479c3d79203", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "3cfa0680932675f487a5ce02b3e0eda8b9c152d0", "commitAfterChange": "c5710053e25b56911ef4ca37886dd15d080aafc0", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 62, "signatureBeforeChange": " \tprivate static void updateVariableValues( \t\tString[] variableNames, \t\tIPath[] variablePaths, \t\tIProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tprivate static void updateVariableValues( \t\tString[] variableNames, \t\tIPath[] variablePaths, \t\tIProgressMonitor monitor) throws JavaModelException", "diff": ["+\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "+\t\t\tSystem.out.println(\"CPVariable SET  - setting variables: {\" + Util.toString(variableNames)  //$NON-NLS-1$", "+\t\t\t\t+ \"} with values: \" + Util.toString(variablePaths)); //$NON-NLS-1$", "+\t\t}", "+", "-\t", "+", "+\t\tfinal String[] dbgVariableNames = variableNames;", "+", "+\t\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"CPVariable SET  - updating affected project: [\"+project.getElementName()+\"] due to setting variables: \"+ Util.toString(dbgVariableNames)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "+\t\t\t\t\tSystem.out.println(\"CPVariable SET  - FAILED DUE TO EXCEPTION: \"+Util.toString(dbgVariableNames)); //$NON-NLS-1$", "+\t\t\t\t\te.printStackTrace();", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "28ec88c43a6df92eb708c65ba836142a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/Problem.java", "commitBeforeChange": "dade23c0ca1cb5b996dfae1d1cfc189d06d41a6f", "commitAfterChange": "b9f6281b56af6781d8bb8cc727077eb3dccaebba", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \t \tpublic Problem(String location, String message, IPath resourcePath)", "signatureAfterChange": " \t \tpublic Problem(String location, String message, IPath resourcePath, int start, int end, int categoryId)", "diff": ["-\tpublic Problem(String location, String message, IPath resourcePath){", "-\t\tthis(location, message, resourcePath, -1, -1);", "-\t}", "+\tpublic Problem(String location, String message, IPath resourcePath, int start, int end, int categoryId){", "+\t\tthis.categoryId = categoryId;", "+\t\tif (false && (start > 0 || end > 0) && categoryId <= 0) {", "+\t\t\tSystem.out.print(\"is categoryId properly set ? new Problem(\\\"\" + location + \"\\\", \\\"\" + message + \"\\\", \\\"\" + resourcePath + \"\\\"\");", "+\t\t\tSystem.out.print(\", \" + start + \", \" + end +  \", \" + categoryId);", "+\t\t\tSystem.out.println(\")\");", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3078e95a777dd9bb41106a3cc78ee3ae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterMassiveRegressionTests.java", "commitBeforeChange": "6b6471423b89c70a33d53654f3143292c15724dc", "commitAfterChange": "dbb5484f1c0506305bb2de3acc0db3501ec7c329", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 19, "signatureBeforeChange": " public void setUpSuite() throws Exception", "signatureAfterChange": " public void setUpSuite() throws Exception", "diff": ["-\t// skip standard model suite set up", "+", "+\t// Init directories", "+\tinitDirectories(this.inputDir, this.profiles);", "+", "+\t// Delete output dir before compute reference", "+\tif (CLEAN) {", "+\t\tSystem.out.print(\"Deleting all files from \"+OUTPUT_DIR+\"...\");", "+\t\tUtil.delete(OUTPUT_DIR);", "+\t\tSystem.out.println(\"done\");", "+\t}", "+\t// Init failure", "+\telse if (this.canCompare) {", "+\t\tinitFailures();", "+\t}", "+", "+\t// Dump the version", "+\tFile versionFile = new Path(OUTPUT_DIR.getPath()).append(\"version.txt\").toFile();", "+\tOUTPUT_DIR.mkdirs();", "+\tUtil.writeToFile(JDT_CORE_VERSION, versionFile.getAbsolutePath());", "+", "+\t// Init time measuring", "+\tTIME_MEASURES = new TimeMeasuring();", "+", "+\t// Print", "+\tprint();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "321c67bf256f798628196864beb2fa5b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 194, "methodNumberAfterChange": 204, "signatureBeforeChange": " private String parametersAsShortString(MethodBinding method)", "signatureAfterChange": " private String parameterBoundAsString(TypeVariableBinding typeVariable, boolean makeShort)", "diff": ["+private String parameterBoundAsString(TypeVariableBinding typeVariable, boolean makeShort) {", "+    StringBuffer nameBuffer = new StringBuffer(10);", "+    if (typeVariable.firstBound == typeVariable.superclass) {", "+        nameBuffer.append(makeShort ? typeVariable.superclass.shortReadableName() : typeVariable.superclass.readableName());", "+    }", "+    int length;", "+    if ((length = typeVariable.superInterfaces.length) > 0) {", "+\t    for (int i = 0; i < length; i++) {", "+\t        if (i > 0 || typeVariable.firstBound == typeVariable.superclass) nameBuffer.append(\" & \"); //$NON-NLS-1$", "+\t        nameBuffer.append(makeShort ? typeVariable.superInterfaces[i].shortReadableName() : typeVariable.superInterfaces[i].readableName());", "+\t    }", "+\treturn nameBuffer.toString();", "-private String parametersAsShortString(MethodBinding method) {", "-\tTypeBinding[] params = method.parameters;", "-\tStringBuffer buffer = new StringBuffer();", "-\t\tbuffer.append(new String(params[i].shortReadableName()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "346bb83cce9a1be7a10f4117cc5b437b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/NamingConventions.java", "commitBeforeChange": "64e9473f82af48ea4e5b2ff0272cf87fb1916f12", "commitAfterChange": "1612764cac82755ece5bb371b617dba233a98e7f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t\tpublic char[][] getResults()", "signatureAfterChange": " \t\tpublic char[][] getResults()", "diff": ["-\t\t\tint count = prefixAndSuffixResultsCount + prefixResultsCount + suffixResultsCount + otherResultsCount;", "+\t\t\tint count = ", "+\t\t\t\tfirstPrefixAndFirstSuffixResultsCount", "+\t\t\t\t+ firstPrefixAndSuffixResultsCount", "+\t\t\t\t+ prefixAndFirstSuffixResultsCount", "+\t\t\t\t+ prefixAndSuffixResultsCount", "+\t\t\t\t+ firstPrefixResultsCount", "+\t\t\t\t+ prefixResultsCount", "+\t\t\t\t+ firstSuffixResultsCount", "+\t\t\t\t+ suffixResultsCount", "+\t\t\t\t+ otherResultsCount;", "+\t\t\t\t", "+\t\t\tSystem.arraycopy(firstPrefixAndFirstSuffixResults, 0, results, index, firstPrefixAndFirstSuffixResultsCount);", "+\t\t\tindex += firstPrefixAndFirstSuffixResultsCount;", "+\t\t\tSystem.arraycopy(firstPrefixAndSuffixResults, 0, results, index, firstPrefixAndSuffixResultsCount);", "+\t\t\tindex += firstPrefixAndSuffixResultsCount;", "+\t\t\tSystem.arraycopy(prefixAndFirstSuffixResults, 0, results, index, prefixAndFirstSuffixResultsCount);", "+\t\t\tindex += prefixAndFirstSuffixResultsCount;\t\t", "+\t\t\tSystem.arraycopy(firstPrefixResults, 0, results, index, firstPrefixResultsCount);", "+\t\t\tindex += firstPrefixResultsCount;", "+\t\t\tSystem.arraycopy(firstSuffixResults, 0, results, index, firstSuffixResultsCount);", "+\t\t\tindex += firstSuffixResultsCount;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "389bec0c7de7fddb342054540408f201", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "990424c900c7463d4257bff26a1ccc6812106204", "commitAfterChange": "c8d00cbf2814182ef1ce07d7254dc4a8d85157bc", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void acceptLocalMethod(MethodBinding methodBinding)", "signatureAfterChange": " public void acceptLocalMethod(MethodBinding methodBinding)", "diff": ["-\tif(res != null && res.getElementType() == IJavaElement.METHOD) {", "-\t\tIMethod method = (IMethod) res;", "-\t\t", "-\t\tchar[] uniqueKey = methodBinding.computeUniqueKey();", "-\t\tif(method.isBinary()) {", "-\t\t\tres = new ResolvedBinaryMethod(", "-\t\t\t\t\t(JavaElement)res.getParent(),", "-\t\t\t\t\tmethod.getElementName(),", "-\t\t\t\t\tmethod.getParameterTypes(), ", "-\t\t\t\t\tnew String(uniqueKey));", "-\t\t} else {", "-\t\t\tres = new ResolvedSourceMethod(", "-\t\t\t\t\t(JavaElement)res.getParent(),", "-\t\t\t\t\tmethod.getElementName(),", "-\t\t\t\t\tmethod.getParameterTypes(), ", "-\t\t\t\t\tnew String(uniqueKey));", "-\t\t}", "-\t\taddElement(res);", "-\t\tif(SelectionEngine.DEBUG){", "-\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$", "-\t\t\tSystem.out.print(res.toString());", "-\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\tif(res != null) {", "+\t\tif(res.getElementType() == IJavaElement.METHOD) {", "+\t\t\tIMethod method = (IMethod) res;", "+\t\t\t", "+\t\t\tchar[] uniqueKey = methodBinding.computeUniqueKey();", "+\t\t\tif(method.isBinary()) {", "+\t\t\t\tres = new ResolvedBinaryMethod(", "+\t\t\t\t\t\t(JavaElement)res.getParent(),", "+\t\t\t\t\t\tmethod.getElementName(),", "+\t\t\t\t\t\tmethod.getParameterTypes(), ", "+\t\t\t\t\t\tnew String(uniqueKey));", "+\t\t\t} else {", "+\t\t\t\tres = new ResolvedSourceMethod(", "+\t\t\t\t\t\t(JavaElement)res.getParent(),", "+\t\t\t\t\t\tmethod.getElementName(),", "+\t\t\t\t\t\tmethod.getParameterTypes(), ", "+\t\t\t\t\t\tnew String(uniqueKey));", "+\t\t\t}", "+\t\t\taddElement(res);", "+\t\t\tif(SelectionEngine.DEBUG){", "+\t\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$", "+\t\t\t\tSystem.out.print(res.toString());", "+\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else if(methodBinding.selector == TypeConstants.INIT && res.getElementType() == IJavaElement.TYPE) {", "+\t\t\t// it's a default constructor", "+\t\t\tres = new ResolvedSourceType((JavaElement)res.getParent(), res.getElementName(), new String(methodBinding.declaringClass.computeUniqueKey()));", "+\t\t\taddElement(res);", "+\t\t\tif(SelectionEngine.DEBUG){", "+\t\t\t\tSystem.out.print(\"SELECTION - accept type(\"); //$NON-NLS-1$", "+\t\t\t\tSystem.out.print(res.toString());", "+\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45f163fe27629e51beb74d530514b5ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "7b9f5afc03b2a8eb9ffa3e6741b37f04d8f60a08", "commitAfterChange": "45eeabd31b9c2797f8358a82ef28ccf00894105c", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type)", "signatureAfterChange": " protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type, TypeBinding[] argumentTypes, boolean verifyMethod)", "diff": ["-protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type) {", "+protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type, TypeBinding[] argumentTypes, boolean verifyMethod) {", "-\t\t\treturn true;", "+\t\t\tif (!verifyMethod) return true;", "+\t\t\t// need to verify if the type implements the pattern method", "+\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "+\t\t\tfor (int j=0, length=methods.length; j<length; j++) {", "+\t\t\t\tMethodBinding method = methods[j];", "+\t\t\t\tTypeBinding[] parameters = method.parameters;", "+\t\t\t\tif (argumentTypes.length == parameters.length) {", "+\t\t\t\t\tboolean found = true;", "+\t\t\t\t\tfor (int k=0,l=parameters.length; k<l; k++) {", "+\t\t\t\t\t\tif (parameters[k].erasure() != argumentTypes[k].erasure()) {", "+\t\t\t\t\t\t\tfound = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (found) {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "-\t\t\tif (resolveLevelAsSuperInvocation(interfaces[i])) {", "+\t\t\tif (resolveLevelAsSuperInvocation(interfaces[i], argumentTypes, true)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "47e7c7ed68f47edc070cc39334caf3b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "a7da40a1a62439fc4b1ece4f5221022e1778c205", "commitAfterChange": "0ad2415ee4f1a2517a3e261113b08f2dfc4514f8", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 76, "signatureBeforeChange": " public void configure(String[] argv)", "signatureAfterChange": " public void configure(String[] argv)", "diff": ["-\tboolean didSpecifyDefaultEncoding = false;", "+\t", "+\tSet specifiedEncodings = null;", "-\t\t\t\tif (didSpecifyDefaultEncoding) {", "-\t\t\t\t\tthrow new IllegalArgumentException(", "-\t\t\t\t\t\tthis.bind(\"configure.duplicateDefaultEncoding\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tif (specifiedEncodings != null) {", "+\t\t\t\t\t// check already defined encoding", "+\t\t\t\t\tif (!specifiedEncodings.contains(currentArg)) {", "+\t\t\t\t\t\tif (specifiedEncodings.size() > 1) {", "+\t\t\t\t\t\t\tthis.logger.logWarning(", "+\t\t\t\t\t\t\t\t\tthis.bind(\"configure.differentencodings\", //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tcurrentArg,", "+\t\t\t\t\t\t\t\t\tgetAllEncodings(specifiedEncodings)));", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tthis.logger.logWarning(", "+\t\t\t\t\t\t\t\t\tthis.bind(\"configure.differentencoding\", //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tcurrentArg,", "+\t\t\t\t\t\t\t\t\tgetAllEncodings(specifiedEncodings)));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tspecifiedEncodings = new HashSet();", "+\t\t\t\tspecifiedEncodings.add(currentArg);", "-\t\t\t\tdidSpecifyDefaultEncoding = true;", "+\tif (specifiedEncodings != null && specifiedEncodings.size() > 1) {", "+\t\tthis.logger.logWarning(this.bind(\"configure.multipleencodings\", //$NON-NLS-1$", "+\t\t\t\t(String) this.options.get(CompilerOptions.OPTION_Encoding),", "+\t\t\t\tgetAllEncodings(specifiedEncodings)));", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4857b5df6483af2677f9d2b6b6799a2a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/EncodingTests.java", "commitBeforeChange": "d4b1799d68d9da7272b7b6470cdf87ffed026135", "commitAfterChange": "87e8af21b6459d4881cd0237a774f295946a026a", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic void test013() throws JavaModelException, CoreException", "signatureAfterChange": " \tpublic void test013() throws JavaModelException, CoreException", "diff": ["+\t// TODO (frederic) put back assertions when failure on linux platform will be fixed", "-//\t\tString independentSource = org.eclipse.jdt.core.tests.util.Util.convertToIndependantLineDelimiter(source);", "+\t\tString independentSource = org.eclipse.jdt.core.tests.util.Util.convertToIndependantLineDelimiter(source);", "-\t\tassertSourceEquals(\"Encoded UTF-8 source should have been decoded the same way!\", source, encodedContents);", "+//\t\tassertSourceEquals(\"Encoded UTF-8 source should have been decoded the same way!\", source, encodedContents);", "+\t\tSystem.out.println(\"Encoding tests013:\");", "+\t\tSystem.out.println(\"  - file encoding: \"+this.utf8File.getCharset());", "+\t\tSystem.out.println(\"  - project encoding: \"+this.encodingProject.getDefaultCharset());", "+\t\tSystem.out.println(\"  - workspace encoding: \"+getWorkspaceRoot().getDefaultCharset());", "+\t\tif (encodedContents.equals(independentSource)) {", "+\t\t\tSystem.out.println(\"  => SUCCESS: sources are identical\");", "+\t\t} else {", "+//\t\t\tSystem.out.println(\"  => FAIL: Encoded UTF-8 source should have been decoded the same way!\");", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a5f2cfa5506093bdc9018c9dcc0946b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/State.java", "commitBeforeChange": "4e88e1625bb1c2659a2ee4ba931e466f5126f9f4", "commitAfterChange": "075da32620f3ceb13a370a8be8550de2baf091f1", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": "\r \r static State read(DataInputStream in) throws IOException", "signatureAfterChange": "\r \r static State read(DataInputStream in) throws IOException", "diff": ["+\tif (JavaBuilder.DEBUG)\r", "+\t\tSystem.out.println(\"About to read state...\"); //$NON-NLS-1$\r", "-\tlength = in.readInt();\r", "-\tnewState.structuralBuildNumbers = new SimpleLookupTable(length);\r", "+\tnewState.structuralBuildNumbers = new SimpleLookupTable(length = in.readInt());\r", "+\tString[] internedLocations = new String[length = in.readInt()];\r", "+\tfor (int i = 0; i < length; i++)\r", "+\t\tinternedLocations[i] = in.readUTF();\r", "+\r", "+\tnewState.typeLocations = new SimpleLookupTable(length = in.readInt());\r", "+\tfor (int i = 0; i < length; i++)\r", "+\t\tnewState.typeLocations.put(in.readUTF(), internedLocations[in.readInt()]);\r", "+\r", "-\tlength = in.readInt();\r", "-\tchar[][][] internedQualifiedNames = new char[length][][];\r", "+\tchar[][][] internedQualifiedNames = new char[length = in.readInt()][][];\r", "-\tlength = in.readInt();\r", "-\tnewState.references = new SimpleLookupTable(length);\r", "+\tnewState.references = new SimpleLookupTable(length = in.readInt());\r", "-\t\tString location = in.readUTF();\r", "+\t\tString location = internedLocations[in.readInt()];\r", "+\tif (JavaBuilder.DEBUG)\r", "+\t\tSystem.out.println(\"Successfully read state for \" + newState.javaProjectName); //$NON-NLS-1$\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f309940f0b01a8d4d58b5885ee3946d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "9d0a10f56589d65d04aaea495d852ef502b02233", "commitAfterChange": "913c08568caa0adfd1165460a3e2394884803092", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type)", "signatureAfterChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "diff": ["-protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type) {", "+protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes) {", "-\tif (level != IMPOSSIBLE_MATCH) return level;", "+\tif (level != IMPOSSIBLE_MATCH) {", "+\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t}", "+\t\treturn level;", "+\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass());", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass(), argumentTypes);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (argumentTypes != null) {", "+\t\t\t\t// need to verify if method may be overridden", "+\t\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "+\t\t\t\tfor (int i=0, length=methods.length; i<length; i++) {", "+\t\t\t\t\tMethodBinding method = methods[i];", "+\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "+\t\t\t\t\tif (argumentTypes.length == parameters.length) {", "+\t\t\t\t\t\tboolean found = true;", "+\t\t\t\t\t\tfor (int j=0,l=parameters.length; j<l; j++) {", "+\t\t\t\t\t\t\tif (parameters[j].erasure() != argumentTypes[j].erasure()) {", "+\t\t\t\t\t\t\t\tfound = false;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (found) { // one method match in hierarchy", "+\t\t\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "+\t\t\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "+\t\t\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "+\t\t\t\t\t\t\t\t// store the fact that the method is overridden", "+\t\t\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i]);", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i], null);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d4a360a034650b11f277987a6516110", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java", "commitBeforeChange": "e3b61331087882f47093048d6298d97548b68615", "commitAfterChange": "9ae1dbe2eb10f60df8b987132110cee826808427", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public void checkMethodParse( \t\tchar[] source,  \t\tint cursorLocation,  \t\tString expectedCompletion,  \t\tString expectedParentCompletion, \t\tString expectedUnitToString,  \t\tString expectedCompletionIdentifier,  \t\tString expectedReplacedSource, \t\tString[] expectedLabels, \t\tString testName)", "signatureAfterChange": " public void checkMethodParse( \t\tchar[] source,  \t\tint cursorLocation,  \t\tString expectedCompletion,  \t\tString expectedParentCompletion, \t\tString expectedUnitToString,  \t\tString expectedCompletionIdentifier,  \t\tString expectedReplacedSource, \t\tString[] expectedLabels, \t\tString testName)", "diff": ["-\t\t\t\t\t\t\t\t: parser.assistNode.toString(0);", "+\t\t\t\t\t\t\t\t: parser.assistNode.toString();", "-\t\t\t\t\t\t\t\t: parser.assistNodeParent.toString(0);", "+\t\t\t\t\t\t\t\t: parser.assistNodeParent.toString();", "-\t//System.out.println(computedUnitToString);", "-\t//System.out.println(Util.displayString(computedUnitToString));", "-\t//System.out.println(expectedUnitToString);\t\t", "+\tif (!expectedCompletion.equals(computedCompletion)) {", "+\t\tSystem.out.println(Util.displayString(computedCompletion));", "+\t}", "+\t\tif (!expectedParentCompletion.equals(computedParentCompletion)) {", "+\t\t\tSystem.out.println(Util.displayString(computedParentCompletion));", "+\t\t}", "+\tif (!expectedUnitToString.equals(computedUnitToString)) {", "+\t\tSystem.out.println(Util.displayString(computedUnitToString));", "+\t}", "+\t\tif (!expectedCompletionIdentifier.equals(computedCompletionIdentifier)) {", "+\t\t\tSystem.out.println(Util.displayString(computedCompletionIdentifier));", "+\t\t}", "+\t\tif (!expectedReplacedSource.equals(computedReplacedSource)) {", "+\t\t\tSystem.out.println(Util.displayString(computedReplacedSource));", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d9a32e31cb2a7dc9aa913b267e54c65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "3cfa0680932675f487a5ce02b3e0eda8b9c152d0", "commitAfterChange": "c5710053e25b56911ef4ca37886dd15d080aafc0", "methodNumberBeforeChange": 50, "methodNumberAfterChange": 50, "signatureBeforeChange": " \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {", "+\tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {", "+\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "+\t\t\tSystem.out.println(\"CPContainer SET  - setting container: [\"+containerPath+\"] for projects: {\" //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t+ (Util.toString(affectedProjects, ", "+\t\t\t\t\t\tnew Util.Displayable(){ ", "+\t\t\t\t\t\t\tpublic String displayString(Object o) { return ((IJavaProject) o).getElementName(); }", "+\t\t\t\t\t\t}))", "+\t\t\t\t+ \"} with values: \" //$NON-NLS-1$", "+\t\t\t\t+ (Util.toString(respectiveContainers, ", "+\t\t\t\t\t\tnew Util.Displayable(){ ", "+\t\t\t\t\t\t\tpublic String displayString(Object o) { return ((IClasspathContainer) o).getDescription(); }", "+\t\t\t\t\t\t}))", "+\t\t\t\t\t);", "+\t\t}", "+", "+\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){", "+\t\t\t\t\t\t\tSystem.out.println(\"CPContainer SET  - updating affected project: [\"+affectedProject.getElementName()+\"] due to setting container: \" + containerPath); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\t\t\t}", "+", "-\t\t\t\tSystem.out.println(\"CPContainer INIT - FAILED DUE TO EXCEPTION: \"+containerPath); //$NON-NLS-1$", "+\t\t\t\tSystem.out.println(\"CPContainer SET  - FAILED DUE TO EXCEPTION: \"+containerPath); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5db7e63aa504a94a515d6e9fca552288", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "8308cfd802c8b60b3cfe136b716c3a270c031128", "commitAfterChange": "5f4b17a62cffd1579d0f5c93e6dae75091d296b0", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t\tint argLength = arguments.length;", "-\t\t\tfor (int i = 0; i < argLength; i++)", "-\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "+\t\t\t", "+\t\t\t// collect argument type mapping, handling varargs", "+\t\t\tif (originalMethod.isVarargs()) {", "+\t\t\t\tint paramLength = parameters.length;", "+\t\t\t\tint minArgLength = paramLength - 1;", "+\t\t\t\tint argLength = arguments.length;", "+\t\t\t\t// process mandatory arguments", "+\t\t\t\tfor (int i = 0; i < minArgLength; i++)", "+\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "+\t\t\t\t// process optional arguments", "+\t\t\t\tif (minArgLength < argLength) {", "+\t\t\t\t\tTypeBinding varargType = parameters[minArgLength]; // last arg type - as is ?", "+\t\t\t\t\tif (paramLength != argLength // argument is passed as is ?", "+\t\t\t\t\t\t\t||  (arguments[minArgLength] != NullBinding", "+\t\t\t\t\t\t\t\t\t&& (arguments[minArgLength].dimensions() != varargType.dimensions()))) { ", "+\t\t\t\t\t\tvarargType = ((ArrayBinding)varargType).elementsType(); // eliminate one array dimension", "+\t\t\t\t\t}", "+\t\t\t\t\tfor (int i = minArgLength; i < argLength; i++)", "+\t\t\t\t\t\tvarargType.collectSubstitutes(arguments[i], collectedSubstitutes);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tint paramLength = parameters.length;", "+\t\t\t\tfor (int i = 0; i < paramLength; i++)", "+\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f42e95bf90af9c263e6b1a26efd5d7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": "  protected void report(IResource resource, int sourceStart, int sourceEnd, IJavaElement element, int accuracy, SearchParticipant participant) throws CoreException", "signatureAfterChange": "  protected void report(SearchMatch match) throws CoreException", "diff": ["-protected void report(IResource resource, int sourceStart, int sourceEnd, IJavaElement element, int accuracy, SearchParticipant participant) throws CoreException {", "+protected void report(SearchMatch match) throws CoreException {", "-\tif (SearchEngine.VERBOSE)", "+\tif (SearchEngine.VERBOSE) {", "-\tString documentPath = element.getPath().toString();", "-\tSearchMatch match = new JavaSearchMatch(resource, element, documentPath, accuracy, participant, sourceStart, sourceEnd+1, -1);", "+\t\tSystem.out.println(\"Reporting match\"); //$NON-NLS-1$", "+\t\tSystem.out.println(\"\\tDocument path: \" + match.getDocumentPath()); //$NON-NLS-2$//$NON-NLS-1$", "+\t\tSystem.out.println(\"\\tPositions: [\" + match.getSourceStart() + \", \" + match.getSourceEnd() + \"]\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+\t\tSystem.out.println(\"\\tJava element: \" + match.getDescriptiveLocation()); //$NON-NLS-1$", "+\t\tSystem.out.println(match.getAccuracy() == IJavaSearchResultCollector.EXACT_MATCH", "+\t\t\t? \"\\tAccuracy: EXACT_MATCH\" //$NON-NLS-1$", "+\t\t\t: \"\\tAccuracy: POTENTIAL_MATCH\"); //$NON-NLS-1$", "+\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66d2d4a9a40f4c4b85e11afe16f59fdb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "017b3e7b4a0eb8977eddf3d61548e2949c330fd3", "commitAfterChange": "b8098db1e88dce762af01dca78879f57b1edfb90", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \tIBinding resolveName(Name name)", "signatureAfterChange": "\r \tIBinding resolveName(Name name)", "diff": ["-\t\tif (parent instanceof MethodDeclaration) {\r", "+\t\tif (parent instanceof MethodDeclaration && name.equals(((MethodDeclaration) parent).getName())) {\r", "-\t\tif (parent instanceof TypeDeclaration) {\r", "+\t\tif (parent instanceof TypeDeclaration && name.equals(((TypeDeclaration) parent).getName())) {\r", "-\t\tif (parent instanceof MethodInvocation\r", "-\t\t\t|| parent instanceof SuperMethodInvocation) {\r", "+\t\tif ((parent instanceof MethodInvocation && name.equals(((MethodInvocation) parent).getName()))\r", "+\t\t\t|| (parent instanceof SuperMethodInvocation && name.equals(((SuperMethodInvocation) parent).getName()))) {\r", "-\t\tif (parent instanceof FieldAccess\r", "-\t\t   || parent instanceof SuperFieldAccess) {\r", "+\t\tif ((parent instanceof FieldAccess && name.equals(((FieldAccess) parent).getName()))\r", "+\t\t   || (parent instanceof SuperFieldAccess && name.equals(((SuperFieldAccess) parent).getName()))) {\r", "-\t\tif (parent instanceof PackageDeclaration) {\r", "+\t\tif (parent instanceof PackageDeclaration && name.equals(((PackageDeclaration) parent).getName())) {\r", "-\t\tif (parent instanceof SimpleType) {\r", "+\t\tif (parent instanceof SimpleType && name.equals(((SimpleType) parent).getName())) {\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a2f4cc8922ef6a6cec5f7edd6dbdb61", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "1317e9ebe26807b45d83a46701194241e6f648d5", "commitAfterChange": "3649f3f6d703fd53c9c12b41cdc037f657d98134", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tpublic static IClasspathEntry[] getResolvedClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException", "signatureAfterChange": "\r \tpublic static IClasspathContainer getClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException", "diff": ["+\t */\r", "+\tpublic static IClasspathContainer getClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException {\r", "+\r", "+\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "+\t\tif (projectContainers == null){\r", "+\t\t\tprojectContainers = new HashMap(1);\r", "+\t\t\tJavaModelManager.Containers.put(project, projectContainers);\r", "+\t\t}\r", "+\t\tIClasspathContainer container = (IClasspathContainer)projectContainers.get(containerPath);\r", "+\r", "+\t\tif (container == JavaModelManager.ContainerInitializationInProgress) return null; // break cycle\r", "+\t\tif (container == null){\r", "+\t\t\tClasspathContainerInitializer initializer = JavaModelManager.getClasspathContainerInitializer(containerPath.segment(0));\r", "+\t\t\tif (initializer != null){\r", "+\t\t\t\tprojectContainers.put(containerPath, JavaModelManager.ContainerInitializationInProgress); // avoid initialization cycles\r", "+\t\t\t\tboolean ok = false;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tinitializer.initialize(containerPath.segment(0), containerPath.segment(1), project);\r", "+\t\t\t\t\tif (container != null){\r", "+\t\t\t\t\t\tIClasspathEntry[] entries = container.getClasspathEntries();\r", "+\t\t\t\t\t\t// validation - no nested classpath container\r", "+\t\t\t\t\t\tif (entries != null){\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){\r", "+\t\t\t\t\t\t\t\tIClasspathEntry entry = entries[i];\r", "+\t\t\t\t\t\t\t\tif (entry == null || entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER){\r", "+\t\t\t\t\t\t\t\t\tthrow new JavaModelException(\r", "+\t\t\t\t\t\t\t\t\t\tnew JavaModelStatus(\r", "+\t\t\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY,\r", "+\t\t\t\t\t\t\t\t\t\t\tcontainerPath.toString()));\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tok = true;\r", "+\t\t\t\t} catch(CoreException e){\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\tif (!ok) JavaModelManager.Containers.put(project, null); // flush cache\r", "+\t\t\t\t}\r", "+\t\t\t\tif (container != null){\r", "+\t\t\t\t\tprojectContainers.put(containerPath, container);\r", "+\t\t\t\t}\r", "+\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){\r", "+\t\t\t\t\tSystem.out.print(\"CPContainer INIT - after resolution: \" + containerPath + \" --> \"); //$NON-NLS-2$//$NON-NLS-1$\r", "+\t\t\t\t\tif (container != null){\r", "+\t\t\t\t\t\tSystem.out.print(\"container: \"+container.getDescription()+\" {\"); //$NON-NLS-2$//$NON-NLS-1$\r", "+\t\t\t\t\t\tIClasspathEntry[] entries = container.getClasspathEntries();\r", "+\t\t\t\t\t\tif (entries != null){\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){\r", "+\t\t\t\t\t\t\t\tif (i > 0) System.out.println(\", \");//$NON-NLS-1$\r", "+\t\t\t\t\t\t\t\tSystem.out.println(entries[i]);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tSystem.out.println(\"}\");//$NON-NLS-1$\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tSystem.out.println(\"{unbound}\");//$NON-NLS-1$\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\treturn container;\t\t\t\r", "+\t}\r", "-\t */\r", "-\tpublic static IClasspathEntry[] getResolvedClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException {\r", "-\r", "-\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "-\t\tif (projectContainers == null){\r", "-\t\t\tprojectContainers = new HashMap(1);\r", "-\t\t\tJavaModelManager.Containers.put(project, projectContainers);\r", "-\t\t}\r", "-\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "-\r", "-\t\tif (entries == JavaModelManager.ContainerInitializationInProgress) return null; // break cycle\r", "-\t\tif (entries == null){\r", "-\t\t\tClasspathContainerResolver resolver = JavaModelManager.getClasspathContainerResolver(containerPath);\r", "-\t\t\tif (resolver != null){\r", "-\t\t\t\tprojectContainers.put(containerPath, JavaModelManager.ContainerInitializationInProgress); // avoid initialization cycles\r", "-\t\t\t\tboolean ok = false;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tentries = resolver.resolve(containerPath, project);\r", "-\t\t\t\t\t\r", "-\t\t\t\t\t// validation - no nested classpath container\r", "-\t\t\t\t\tif (entries != null){\r", "-\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){\r", "-\t\t\t\t\t\t\tIClasspathEntry entry = entries[i];\r", "-\t\t\t\t\t\t\tif (entry == null || entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER){\r", "-\t\t\t\t\t\t\t\tthrow new JavaModelException(\r", "-\t\t\t\t\t\t\t\t\tnew JavaModelStatus(\r", "-\t\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY,\r", "-\t\t\t\t\t\t\t\t\t\tcontainerPath.toString()));\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tok = true;\r", "-\t\t\t\t} catch(CoreException e){\r", "-\t\t\t\t\tthrow new JavaModelException(e);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (!ok) JavaModelManager.Containers.put(project, null); // flush cache\r", "-\t\t\t\t}\r", "-\t\t\t\tif (entries != null){\r", "-\t\t\t\t\tprojectContainers.put(containerPath, entries);\r", "-\t\t\t\t}\r", "-\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE){\r", "-\t\t\t\t\tSystem.out.print(\"CPContainer INIT - after resolution: \" + containerPath + \" --> {\"); //$NON-NLS-2$//$NON-NLS-1$\r", "-\t\t\t\t\tif (entries != null){\r", "-\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){\r", "-\t\t\t\t\t\t\tif (i > 0) System.out.println(\", \");//$NON-NLS-1$\r", "-\t\t\t\t\t\t\tSystem.out.println(entries[i]);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\tSystem.out.println(\"}\");//$NON-NLS-1$\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn entries;\t\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6d3276674ec0884e3a29b357a35b180d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "9dbcebbcaf11825267cb12e7ee6eb7bd73431114", "commitAfterChange": "f7b0e495847f4cba5d393348688e14a6dd333c0e", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments)", "signatureAfterChange": "  \tprotected int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments)", "diff": ["-\t\tint lastIndex = argLength;", "+", "+\t\tLookupEnvironment env = environment();", "+\t\tif (env.options.sourceLevel < ClassFileConstants.JDK1_5) {", "+\t\t\tif (paramLength != argLength)", "+\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\tfor (int i = 0; i < argLength; i++) {", "+\t\t\t\tTypeBinding param = parameters[i];", "+\t\t\t\tTypeBinding arg = arguments[i];", "+\t\t\t\tif (arg != param && !arg.isCompatibleWith(param))", "+\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t}", "+\t\t\treturn COMPATIBLE;", "+\t\t}", "+", "+\t\tint lastIndex = argLength;", "-\t\t\t\tif (param != arg && !arg.isCompatibleWith(param)) {", "-\t\t\t\t\tif (isBoxingCompatibleWith(arg, param)) {", "-\t\t\t\t\t\tlevel = AUTOBOX_COMPATIBLE; // autoboxing support needed", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// expect X[], called with X", "+\t\t\t\tif (param != arg) {", "+\t\t\t\t\tlevel = parameterCompatibilityLevel(arg, param, env);", "+\t\t\t\t\tif (level == NOT_COMPATIBLE) {", "+\t\t\t\t\t\t// expect X[], is it called with X", "-\t\t\t\t\t\tif (!arg.isCompatibleWith(param) && !isBoxingCompatibleWith(arg, param))", "+\t\t\t\t\t\tif (parameterCompatibilityLevel(arg, param, env) == NOT_COMPATIBLE)", "-\t\t\t\t\t\tif (param != arg && !arg.isCompatibleWith(param) && !isBoxingCompatibleWith(arg, param))", "+\t\t\t\t\t\tif (param != arg && parameterCompatibilityLevel(arg, param, env) == NOT_COMPATIBLE)", "-\t\t\tif (arg != param && !arg.isCompatibleWith(param)) {", "-\t\t\t\tif (!isBoxingCompatibleWith(arg, param))", "+\t\t\tif (arg != param) {", "+\t\t\t\tint newLevel = parameterCompatibilityLevel(arg, param, env);", "+\t\t\t\tif (newLevel == NOT_COMPATIBLE)", "-\t\t\t\tlevel = AUTOBOX_COMPATIBLE; // autoboxing support needed", "+\t\t\t\tif (newLevel > level)", "+\t\t\t\t\tlevel = newLevel;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76dfa4e05b1600eb16bc2c1f325ab757", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java", "commitBeforeChange": "4a3b8d7f66c815bfc252f4ffc29a63c010eff917", "commitAfterChange": "2eb63d812179e5217306b90a651b95bfe7169c81", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void compile(ICompilationUnit[] sourceUnits)", "signatureAfterChange": " \tpublic void compile(ICompilationUnit[] sourceUnits)", "diff": ["-\t\tint i = 0;", "+\t\tProcessTaskManager processingTask = null;", "-\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "-\t\t\tfor (; i < this.totalUnits; i++) {", "-\t\t\t\tunit = unitsToProcess[i];", "-\t\t\t\treportProgress(Messages.bind(Messages.compilation_processing, new String(unit.getFileName())));", "-\t\t\t\ttry {", "+", "+\t\t\tif (this.useSingleThread) {", "+\t\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "+\t\t\t\tfor (int i = 0; i < this.totalUnits; i++) {", "+\t\t\t\t\tunit = unitsToProcess[i];", "+\t\t\t\t\treportProgress(Messages.bind(Messages.compilation_processing, new String(unit.getFileName())));", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tif (options.verbose)", "+\t\t\t\t\t\t\tthis.out.println(", "+\t\t\t\t\t\t\t\tMessages.bind(Messages.compilation_process,", "+\t\t\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\t\t\t\tString.valueOf(this.totalUnits),", "+\t\t\t\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())", "+\t\t\t\t\t\t\t\t}));", "+\t\t\t\t\t\tprocess(unit, i);", "+\t\t\t\t\t} finally {", "+\t\t\t\t\t\t// cleanup compilation unit result", "+\t\t\t\t\t\tunit.cleanUp();", "+\t\t\t\t\t}", "+\t\t\t\t\tunitsToProcess[i] = null; // release reference to processed unit declaration", "+\t\t\t\t\t", "+\t\t\t\t\treportWorked(1, i);", "+\t\t\t\t\tthis.stats.lineCount += unit.compilationResult.lineSeparatorPositions.length;", "+\t\t\t\t\tlong acceptStart = System.currentTimeMillis();", "+\t\t\t\t\trequestor.acceptResult(unit.compilationResult.tagAsAccepted());", "+\t\t\t\t\tthis.stats.generateTime += System.currentTimeMillis() - acceptStart; // record accept time as part of generation", "-\t\t\t\t\t\t\tMessages.bind(Messages.compilation_process,", "+\t\t\t\t\t\t\tMessages.bind(Messages.compilation_done,", "-\t\t\t\t\t\t\t\tnew String(unitsToProcess[i].getFileName())", "+\t\t\t\t\t\t\t\tnew String(unit.getFileName())", "-\t\t\t\t\tprocess(unit, i);", "-\t\t\t\t} finally {", "-\t\t\t\t\t// cleanup compilation unit result", "-\t\t\t\t\tunit.cleanUp();", "-\t\t\t\tunitsToProcess[i] = null; // release reference to processed unit declaration", "-\t\t\t\t", "-\t\t\t\treportWorked(1, i);", "-\t\t\t\tthis.stats.lineCount += unit.compilationResult.lineSeparatorPositions.length;", "-\t\t\t\tlong acceptStart = System.currentTimeMillis();", "-\t\t\t\trequestor.acceptResult(unit.compilationResult.tagAsAccepted());", "-\t\t\t\tthis.stats.generateTime += System.currentTimeMillis() - acceptStart; // record accept time as part of generation", "-\t\t\t\tif (options.verbose)", "-\t\t\t\t\tthis.out.println(", "-\t\t\t\t\t\tMessages.bind(Messages.compilation_done,", "-\t\t\t\t\t\tnew String[] {", "-\t\t\t\t\t\t\tString.valueOf(i + 1),", "-\t\t\t\t\t\t\tString.valueOf(this.totalUnits),", "-\t\t\t\t\t\t\tnew String(unit.getFileName())", "-\t\t\t\t\t\t}));", "+\t\t\t} else {", "+\t\t\t\tprocessingTask = new ProcessTaskManager(this);", "+\t\t\t\tint acceptedCount = 0;", "+\t\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "+\t\t\t\t// the processTask can continue to process units until its fixed sized cache is full then it must wait", "+\t\t\t\t// for this this thread to accept the units as they appear (it only waits if no units are available)", "+\t\t\t\twhile (true) {", "+\t\t\t\t\tunit = processingTask.removeNextUnit(); // waits if no units are in the processed queue", "+\t\t\t\t\tif (unit == null) break;", "+\t\t\t\t\treportWorked(1, acceptedCount++);", "+\t\t\t\t\tthis.stats.lineCount += unit.compilationResult.lineSeparatorPositions.length;", "+\t\t\t\t\trequestor.acceptResult(unit.compilationResult.tagAsAccepted());", "+\t\t\t\t\tif (options.verbose)", "+\t\t\t\t\t\tthis.out.println(", "+\t\t\t\t\t\t\tMessages.bind(Messages.compilation_done,", "+\t\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\t\tString.valueOf(acceptedCount),", "+\t\t\t\t\t\t\t\tString.valueOf(this.totalUnits),", "+\t\t\t\t\t\t\t\tnew String(unit.getFileName())", "+\t\t\t\t\t\t\t}));", "+\t\t\t\t}", "+\t\t\tif (processingTask != null) {", "+\t\t\t\tprocessingTask.shutdown();", "+\t\t\t\tprocessingTask = null;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "826bd0591eced3e5b30214bbb4602db3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "502ac8abc8910137c8c48c0b99f02c92a8a1a0bb", "commitAfterChange": "88902aca029742fa432be78ddccc5cc15b507f75", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r \tpublic static IPath canonicalizedPath(IPath externalPath)", "signatureAfterChange": "\r \tpublic static IPath canonicalizedPath(IPath externalPath)", "diff": ["+\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\tSystem.out.println(\"JAVA MODEL - Canonicalizing \" + externalPath.toString());\r", "+\t\t}\r", "+\r", "+\t\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\t\tSystem.out.println(\"JAVA MODEL - Canonical path is original path (member of workspace)\");\r", "+\t\t\t}\r", "+\t\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\t\tSystem.out.println(\"JAVA MODEL - Canonical path is original path (IOException)\");\r", "+\t\t\t}\r", "+\t\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\t\tSystem.out.println(\"JAVA MODEL - Canonical path is original path (canonical path is empty)\");\r", "+\t\t\t}\r", "+\t\t\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\t\t\tSystem.out.println(\"JAVA MODEL - Canonical path is original path (canonical path is \" + canonicalPath.toString() + \")\");\r", "+\t\t\t\t}\r", "-\t\t\treturn result.setDevice(null);\r", "-\t\t} else {\r", "-\t\t\treturn result;\r", "+\t\t\tresult = result.setDevice(null);\r", "+\t\t} \r", "+\t\tif (JavaModelManager.VERBOSE) {\r", "+\t\t\tSystem.out.println(\"JAVA MODEL - Canonical path is \" + result.toString());\r", "+\t\treturn result;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9468d08add33a8393ae553ae610b18fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "6214978e7f95991a58a94c92ca3aaa2f1fb276e7", "commitAfterChange": "e51ee3261ac6e39dfe94f9022da64a162a2b4dbc", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " public MethodBinding getHighestOverridenMethod()", "signatureAfterChange": " public MethodBinding getHighestOverridenMethod(LookupEnvironment environment)", "diff": ["-public MethodBinding getHighestOverridenMethod() {", "+public MethodBinding getHighestOverridenMethod(LookupEnvironment environment) {", "+    MethodVerifier verifier = environment.methodVerifier();", "-\t\tMethodBinding superMethod = currentType.getExactMethod(this.selector, this.parameters, null);", "-\t\tif (superMethod != null) {", "-\t\t\tbestMethod = superMethod;", "+\t\tMethodBinding[] superMethods = currentType.getMethods(this.selector);", "+\t\tfor (int i = 0, length = superMethods.length; i < length; i++) {", "+\t\t\tif (verifier.doesMethodOverride(this, superMethods[i])) {", "+\t\t\t\tbestMethod = superMethods[i];", "+\t\t\t\tbreak;", "+\t\t\t}", "-\t\tMethodBinding superMethod = currentType.getExactMethod(this.selector, this.parameters, null);", "-\t\tif (superMethod != null) {", "-\t\t\tbestMethod = superMethod;", "-\t\t}\t\t", "+\t\tMethodBinding[] superMethods = currentType.getMethods(this.selector);", "+\t\tfor (int j = 0, length = superMethods.length; j < length; j++) {", "+\t\t\tMethodBinding superMethod = superMethods[j];", "+\t\t\tif (verifier.doesMethodOverride(this, superMethod)) {", "+\t\t\t\tTypeBinding bestReturnType = bestMethod.returnType;", "+\t\t\t\tif (bestReturnType == superMethod.returnType", "+\t\t\t\t\t\t|| bestMethod.returnType.findSuperTypeOriginatingFrom(superMethod.returnType) != null) {", "+\t\t\t\t\tbestMethod = superMethod;", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e1fe992c65b0c4f1a31bbe1900411cb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e87f51d941d6cbe203d8b543bd1f01e26d5c134d", "commitAfterChange": "1ffd151549eccf4f346b9688b80b9066e8dc6a10", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "\r \tpublic void report(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r \tpublic void report(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "diff": ["+\t\t\tif (SearchEngine.VERBOSE) {\r", "+\t\t\t\tIResource res = this.getCurrentResource();\r", "+\t\t\t\tSystem.out.println(\"Reporting match\"); //$NON-NLS-1$\r", "+\t\t\t\tSystem.out.println(\"\\tResource: \" + (res == null ? \" <unknown> \" : res.getFullPath().toString())); //$NON-NLS-1$\r", "+\t\t\t\tSystem.out.println(\"\\tPositions: [\" + sourceStart + \", \" + sourceEnd + \"]\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\r", "+\t\t\t\tSystem.out.println(\"\\tJava element: \" + ((JavaElement)element).toStringWithAncestors()); //$NON-NLS-1$\r", "+\t\t\t\tif (accuracy == IJavaSearchResultCollector.EXACT_MATCH) {\r", "+\t\t\t\t\tSystem.out.println(\"\\tAccuracy: EXACT_MATCH\"); //$NON-NLS-1$\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tSystem.out.println(\"\\tAccuracy: POTENTIAL_MATCH\"); //$NON-NLS-1$\r", "+\t\t\t\t}\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab0170c5aff6323e9a8a257a0fdd831b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  protected void addAffectedSourceFiles()", "signatureAfterChange": "  protected void addAffectedSourceFiles()", "diff": ["-\tnext : for (int i = 0, l = keyTable.length; i < l; i++) {", "-\t\tString sourceLocation = (String) keyTable[i];", "-\t\tif (sourceLocation != null && !locations.contains(sourceLocation)) {", "-\t\t\tif (compiledAllAtOnce && previousLocations != null && previousLocations.contains(sourceLocation))", "-\t\t\t\tcontinue next; // can skip previously compiled locations since already saw hierarchy related problems", "-", "-\t\t\tReferenceCollection refs = (ReferenceCollection) valueTable[i];", "-\t\t\tif (refs.includes(qualifiedNames, simpleNames)) {", "-\t\t\t\t// check that the file still exists... the file or its package may have been deleted", "-\t\t\t\tIResource affectedFile = resourceForLocation(sourceLocation);", "-\t\t\t\tif (affectedFile != null && affectedFile.exists()) {", "-\t\t\t\t\tif (JavaBuilder.DEBUG)", "-\t\t\t\t\t\tSystem.out.println(\"  adding affected source file \" + sourceLocation); //$NON-NLS-1$", "-\t\t\t\t\tlocations.add(sourceLocation);", "-\t\t\t\t\ttypeNames.add(extractTypeNameFrom(sourceLocation));", "+\tnext : for (int i = 0, l = valueTable.length; i < l; i++) {", "+\t\tReferenceCollection refs = (ReferenceCollection) valueTable[i];", "+\t\tif (refs != null && refs.includes(qualifiedNames, simpleNames)) {", "+\t\t\tString typeLocator = (String) keyTable[i];", "+\t\t\tIFile file = javaBuilder.currentProject.getFile(typeLocator);", "+\t\t\tif (file.exists()) {", "+\t\t\t\tClasspathMultiDirectory md = sourceLocations[0];", "+\t\t\t\tif (sourceLocations.length > 1) {", "+\t\t\t\t\tIPath sourceFileFullPath = file.getFullPath();", "+\t\t\t\t\tfor (int j = 0, m = sourceLocations.length; j < m; j++) {", "+\t\t\t\t\t\tif (sourceLocations[j].sourceFolder.getFullPath().isPrefixOf(sourceFileFullPath)) {", "+\t\t\t\t\t\t\tmd = sourceLocations[j];", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\tSourceFile sourceFile = new SourceFile(file, md, encoding);", "+\t\t\t\tif (sourceFiles.contains(sourceFile)) continue next;", "+\t\t\t\tif (compiledAllAtOnce && previousSourceFiles != null && previousSourceFiles.contains(sourceFile))", "+\t\t\t\t\tcontinue next; // can skip previously compiled files since already saw hierarchy related problems", "+", "+\t\t\t\tif (JavaBuilder.DEBUG)", "+\t\t\t\t\tSystem.out.println(\"  adding affected source file \" + typeLocator); //$NON-NLS-1$", "+\t\t\t\tsourceFiles.add(sourceFile);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac99193536c43ef6f9eb831a2bf5466a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaSearchTests.java", "commitBeforeChange": "9170036b60b531a506b4ffe0efeda8e18d918bef", "commitAfterChange": "f8aee71b6b129d09f997301cd8500148a6feb325", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprotected void assertSearchResults(String message, String expected, JavaSearchResultCollector collector)", "signatureAfterChange": " \tprotected void assertSearchResults(String message, String expected, JavaSearchResultCollector collector)", "diff": ["+\t\t\tif (this.workingCopies != null) {", "+\t\t\t\tint length = this.workingCopies.length;", "+\t\t\t\tString[] sources = new String[length*2];", "+\t\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\t\tsources[i*2] = this.workingCopies[i].getPath().toString();", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tsources[i*2+1] = this.workingCopies[i].getSource();", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// ignore", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tSystem.out.println(\"--------------------------------------------------------------------------------\");", "+\t\t\t\tfor (int i=0; i<length; i+=2) {", "+\t\t\t\t\tSystem.out.println(sources[i]);", "+\t\t\t\t\tSystem.out.println(sources[i+1]);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad3a44a22fa13fdd293086020c82fb3c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/EncodingTests.java", "commitBeforeChange": "83c47ad58d0e74e38827d2d1f073a35312f6f8d5", "commitAfterChange": "1d0bf2fd1ae02cf0a5ebd8dc2dd268afda57373a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic void _test006() throws JavaModelException, CoreException", "signatureAfterChange": " \tpublic void test006() throws JavaModelException, CoreException", "diff": ["-\tpublic void _test006() throws JavaModelException, CoreException {", "+\t// TODO (frederic) put back assertions when failure on linux platform will be fixed", "+\tpublic void test006() throws JavaModelException, CoreException {", "-\t\tString encodedContents = new String (Util.getResourceContentsAsCharArray(this.utf8File, null));", "-\t\tassertEquals(\"Project encoding should be the same than workspace encoding!\", this.encodingProject.getDefaultCharset(), getWorkspaceRoot().getDefaultCharset());", "-\t\tassertTrue(\"Encoded UTF-8 source should have been decoded the same way!\", encodedContents.equals(source));", "-", "+\t\tString encodedContents = new String (Util.getResourceContentsAsCharArray(this.utf8File));", "+\t\tSystem.out.println(\"Encoding tests006:\");", "+\t\tSystem.out.println(\"  - file encoding: \"+this.utf8File.getCharset());", "+\t\tSystem.out.println(\"  - project encoding: \"+this.encodingProject.getDefaultCharset());", "+\t\tSystem.out.println(\"  - workspace encoding: \"+getWorkspaceRoot().getDefaultCharset());", "+\t\tif (encodedContents.equals(source)) {", "+\t\t\tSystem.out.println(\"  => SUCCESS: sources are identical\");", "+\t\t} else {", "+\t\t\tSystem.out.println(\"  => FAIL: Encoded UTF-8 source should have been decoded the same way!\");", "+\t\t}", "+//\t\tassertTrue(\"Encoded UTF-8 source should have been decoded the same way!\", encodedContents.equals(source));", "+\t\t\t", "-\t\tassertEquals(\"Wrong size of encoded string\", encodedBytes.length, sourceBytes.length);", "+\t\tif (encodedBytes.length == sourceBytes.length) {", "+\t\t\tSystem.out.println(\"  => SUCCESS: bytes arrays have same size\");", "+\t\t} else {", "+\t\t\tSystem.out.println(\"  => FAIL: Wrong size of encoded string\");", "+\t\t}", "+//\t\tassertEquals(\"Wrong size of encoded string\", encodedBytes.length, sourceBytes.length);", "-\t\t\tassertTrue(\"Wrong size of encoded character at \" + i, sourceBytes[i] == encodedBytes[i]);", "+\t\t\tif (sourceBytes[i] != encodedBytes[i]) {", "+\t\t\t\tSystem.out.println(\"  => FAIL: Wrong size of encoded character at \" + i);", "+\t\t\t\tbreak;", "+\t\t\t}", "+//\t\t\tassertTrue(\"Wrong size of encoded character at \" + i, sourceBytes[i] == encodedBytes[i]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae59eb24e0e7be2bdecaa6bd364dac0a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "38b7a9cf48e2b7b43c2a92fc5bd92474a255d139", "commitAfterChange": "119fb61720952839453ade6e48fab76b7b943cab", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 45, "signatureBeforeChange": "\r \t\r \tprivate void computeBuilderRoots(boolean exportedOnly, IResourceDelta delta, Vector visitedProjects, Vector accumulatedRoots)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \t\t\t\r \tprivate void computeExpandedClasspath(\r \t\tboolean restrainToExportedEntries, \r \t\tboolean ignoreUnresolvedVariable,\r \t\tboolean generateMarkerOnError,\r \t\tVector visitedProjects, \r \t\tVector accumulatedEntries) throws JavaModelException", "diff": ["-\t\r", "-\tprivate void computeBuilderRoots(boolean exportedOnly, IResourceDelta delta, Vector visitedProjects, Vector accumulatedRoots)\r", "-\t\t// avoid project cycles\r", "-\t\tif (visitedProjects.contains(this)){\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\t\tvisitedProjects.add(this);\r", "-\r", "-\t\tclasspath = getResolvedClasspath(true);\r", "-\t\t\tif (!exportedOnly || entry.isExported()){\r", "-\t\t\t\tcomputeBuilderRoots(entry, delta, visitedProjects, accumulatedRoots);\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r", "+\t\t\t\r", "+\tprivate void computeExpandedClasspath(\r", "+\t\tboolean restrainToExportedEntries, \r", "+\t\tboolean ignoreUnresolvedVariable,\r", "+\t\tboolean generateMarkerOnError,\r", "+\t\tVector visitedProjects, \r", "+\t\tVector accumulatedEntries) throws JavaModelException {\r", "+\t\t\r", "+\t\tif (visitedProjects.contains(this)) return; // break cycles if any\r", "+\t\tvisitedProjects.add(this);\r", "+\t\t\r", "+\t\tIClasspathEntry[] immediateClasspath = getResolvedClasspath(ignoreUnresolvedVariable, false);\r", "+\t\tfor (int i = 0, length = immediateClasspath.length; i < length; i++){\r", "+\t\t\tIClasspathEntry entry = immediateClasspath[i];\r", "+\r", "+\t\t\tif (!restrainToExportedEntries || entry.isExported()){\r", "+\t\t\t\taccumulatedEntries.add(entry);\r", "+\t\t\t\tif (entry.getEntryKind() == ClasspathEntry.CPE_PROJECT) {\r", "+\t\t\t\t\t\tIProject projRsc = (IProject) getWorkspace().getRoot().findMember(entry.getPath());\r", "+\t\t\t\t\t\tif (projRsc != null && projRsc.isOpen()) {\t\t\t\t\r", "+\t\t\t\t\t\t\tJavaProject project = (JavaProject) JavaCore.create(projRsc);\r", "+\t\t\t\t\t\t\t// recurse in project to get all its indirect exports (only consider exported entries from there on)\r", "+\t\t\t\t\t\t\tproject.computeExpandedClasspath(\r", "+\t\t\t\t\t\t\t\ttrue, \r", "+\t\t\t\t\t\t\t\tignoreUnresolvedVariable, \r", "+\t\t\t\t\t\t\t\tgenerateMarkerOnError,\r", "+\t\t\t\t\t\t\t\tvisitedProjects, \r", "+\t\t\t\t\t\t\t\taccumulatedEntries);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t}\t\t\t\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8c4005725d5694be3d696d54b4f3a4d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "4a9b6fe7716b388465a0e3822e83603fcd673790", "commitAfterChange": "8d96b52b3ee6d748bf52fa2774ac5cb71b98586d", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " public ReferenceBinding setFocusType(char[][] compoundName)", "signatureAfterChange": " public ReferenceBinding setFocusType(char[][] compoundName)", "diff": ["+\t\tif (this.focusType == null) {", "+\t\t\tint length = compoundName.length;", "+\t\t\tchar[] typeName = compoundName[length-1];", "+\t\t\tint firstDollar = CharOperation.indexOf('$', typeName);", "+\t\t\tif (firstDollar != -1) {", "+\t\t\t\tcompoundName[length-1] = CharOperation.subarray(typeName, 0, firstDollar);", "+\t\t\t\tthis.focusType = this.lookupEnvironment.askForType(compoundName);", "+\t\t\t\tif (this.focusType != null) {", "+\t\t\t\t\tchar[][] memberTypeNames = CharOperation.splitOn('$', typeName, firstDollar+1, typeName.length);", "+\t\t\t\t\tfor (int i = 0; i < memberTypeNames.length; i++) {", "+\t\t\t\t\t\tthis.focusType = this.focusType.getMemberType(memberTypeNames[i]);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bb50ae07f3819d0719acd44e311ce8d8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java", "commitBeforeChange": "272d89e2710b1b25c157dda1019ac9d84fa9215b", "commitAfterChange": "2089a9f5184bf5fb7d1ec0ff5a609f7c5f00e85f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": " private void sortUnit(ICompilationUnit unit, String expectedResult) throws CoreException", "signatureAfterChange": "  private void sortUnit(ICompilationUnit unit, String expectedResult, boolean testPositions) throws CoreException", "diff": ["-\tdebug(unit, \"BEFORE\");", "-\tCompilationUnitSorter.sort(new ICompilationUnit[] { unit }, null, new DefaultJavaElementComparator(1,2,3,4,5,6,7,8,9), new NullProgressMonitor());", "-\tString sortedSource = unit.getBuffer().getContents();", "-\tassertEquals(\"Different output\", sortedSource, expectedResult);", "-\tCompilationUnitSorter.sort(new ICompilationUnit[] { unit }, null, new DefaultJavaElementComparator(1,2,3,4,5,6,7,8,9), new NullProgressMonitor());", "-\tString sortedSource2 = unit.getBuffer().getContents();", "-\tdebug(unit, \"AFTER\");", "-\tassertEquals(\"Different output\", sortedSource, sortedSource2);", "+", "+private void sortUnit(ICompilationUnit unit, String expectedResult, boolean testPositions) throws CoreException {", "+\tdebug(unit, \"BEFORE\");", "+\tif (testPositions) {", "+\t\tchar[] initialSource = unit.getSource().toCharArray();", "+\t\tint[] positions = new int[initialSource.length];", "+\t\tfor (int i = 0; i < initialSource.length; i++) {", "+\t\t\tpositions[i] = i;", "+\t\t}", "+\t\tCompilationUnitSorter.sort(new ICompilationUnit[] { unit }, new int[][] { positions }, new DefaultJavaElementComparator(1,2,3,4,5,6,7,8,9), new NullProgressMonitor());", "+\t\tString sortedSource = unit.getBuffer().getContents();", "+\t\tassertEquals(\"Different output\", sortedSource, expectedResult);", "+\t\tfor (int i = 0, max = positions.length; i < max; i++) {", "+\t\t\tassertEquals(\"wrong mapped positions at \" + i + \" <-> \" + positions[i], initialSource[i], expectedResult.charAt(positions[i]));", "+\t\t}", "+\t} else {", "+\t\tCompilationUnitSorter.sort(new ICompilationUnit[] { unit }, null, new DefaultJavaElementComparator(1,2,3,4,5,6,7,8,9), new NullProgressMonitor());", "+\t\tString sortedSource = unit.getBuffer().getContents();", "+\t\tif (expectedResult == null || expectedResult.length() == 0) {", "+\t\t\tSystem.out.println(sortedSource);", "+\t\t} else {", "+\t\t\tassertEquals(\"Different output\", sortedSource, expectedResult);", "+\t\t}", "+\t}", "+\tdebug(unit, \"AFTER\");", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d73efc15a13955dcceba2d0f11a12a29", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/AbstractImageBuilder.java", "commitBeforeChange": "96cbe57b16442df110d3b0ecde11c12b456820b8", "commitAfterChange": "16a26bc49f78acb9a7d0c10a9d6bedce29952111", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r protected void compile(String[] filenames, String[] initialTypeNames)", "signatureAfterChange": "\r protected void compile(String[] filenames, String[] initialTypeNames)", "diff": ["-\t\t\t\tSystem.out.println(\"About to compile \" + filename);//$NON-NLS-1$\r", "-\t\t\ttoCompile[i] = new SourceFile(filename);\r", "+\t\t\t\tSystem.out.println(\"About to compile \" + filename); //$NON-NLS-1$\r", "+\t\t\tString typeName = initialTypeNames[i];\r", "+\t\t\tint lastIndex = typeName.lastIndexOf('/');\r", "+\t\t\tlastIndex = (lastIndex > 0 ? lastIndex : typeName.length()) - 1;\r", "+\t\t\ttoCompile[i] = new SourceFile(filename, CharOperation.splitOn('/', typeName.toCharArray(), 0, lastIndex));\r", "-\t\t\t\t\ttoCompile[index] = new SourceFile(filename);\r", "-\t\t\t\t\tinitialNamesInLoop[index++] = initialTypeNames[i];\r", "+\t\t\t\t\tString typeName = initialTypeNames[i];\r", "+\t\t\t\t\tinitialNamesInLoop[index++] = typeName;\r", "+\t\t\t\t\tint lastIndex = typeName.lastIndexOf('/');\r", "+\t\t\t\t\tlastIndex = (lastIndex > 0 ? lastIndex : typeName.length()) - 1;\r", "+\t\t\t\t\ttoCompile[index] = new SourceFile(filename, CharOperation.splitOn('/', typeName.toCharArray(), 0, lastIndex));\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "daa9c7fd6a5c28f32af2d28c6e6a0c0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "98ad487e103c268099d7117573693243c8d3b8fc", "commitAfterChange": "721a9dcda02493639666143934bddb089e848d18", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 62, "signatureBeforeChange": "  protected void report(SearchMatch match) throws CoreException", "signatureAfterChange": "  protected void report(SearchMatch match) throws CoreException", "diff": ["+\t\t}", "+\t\tif (match instanceof TypeReferenceMatch) {", "+\t\t\ttry {", "+\t\t\t\tTypeReferenceMatch typeRefMatch = (TypeReferenceMatch) match;", "+\t\t\t\tJavaElement local = (JavaElement) typeRefMatch.getLocalElement();", "+\t\t\t\tif (local != null) {", "+\t\t\t\t\tSystem.out.println(\"\\tLocal element: \"+ local.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tIJavaElement[] others = typeRefMatch.getOtherElements();", "+\t\t\t\tint length = others==null ? 0 : others.length;", "+\t\t\t\tif (length > 0) {", "+\t\t\t\t\tSystem.out.println(\"\\tOther elements:\"); //$NON-NLS-1$", "+\t\t\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\t\t\tJavaElement other = (JavaElement) others[i];", "+\t\t\t\t\t\tSystem.out.println(\"\\t\\t- \"+ other.toStringWithAncestors()); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (Exception e) {", "+\t\t\t\t// it's just for debug purposes... ignore all exceptions in this area", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc219a41637dec30879e9032d4a3831e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MementoTests.java", "commitBeforeChange": "2f9db6d5da33c7aae5495cb19cb4e15019a503c5", "commitAfterChange": "d272b4067753c3b8224afb90d2ae4fc124cff69f", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void assertMemento(String expected, IJavaElement element)", "signatureAfterChange": " protected void assertMemento(String expected, IJavaElement element)", "diff": ["-\t \tSystem.out.println(Util.displayString(actual, 2));", "+\t\tString escapedExternalJCL = getEscapedExternalJCLPath();", "+\t\tint start = actual.indexOf(escapedExternalJCL);", "+\t\tif (start != -1) {", "+\t\t\tString firstPart = actual.substring(0, start);", "+\t\t \tSystem.out.print(Util.displayString(firstPart, 2));", "+\t\t \tSystem.out.print(\" + getEscapedExternalJCLPath() + \");", "+\t\t \tString secondPart = actual.substring(start+escapedExternalJCL.length());", "+\t\t \tSystem.out.print(Util.displayString(secondPart, 0));", "+\t\t} else {", "+\t\t\tSystem.out.print(Util.displayString(actual, 2));", "+\t\t}", "+\t \tSystem.out.println(\",\");", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "df2f78c7390a4ec808ffa8efdf109c5a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugsTests.java", "commitBeforeChange": "15e3a9fc2ecd5761f01e0bac254435a2b7c9efda", "commitAfterChange": "7d045aff59e674d12c8b86d331be1a0001ff1185", "methodNumberBeforeChange": 613, "methodNumberAfterChange": 613, "signatureBeforeChange": " public void testBug286379c() throws CoreException", "signatureAfterChange": " public void testBug286379c() throws CoreException", "diff": ["-", "+\t// print statement to debug random failures of this test", "+\tSystem.out.println(\"Forbidden reference at the start of the test is \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t", "+\t\t// print statement to debug random failures of this test", "+\t\tSystem.out.println(\"Forbidden reference before first exit \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tsimulateRestart();\t\t", "+\t\tsimulateRestart();", "+\t\t// print statement to debug random failures of this test", "+\t\tSystem.out.println(\"Forbidden reference after first restart \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "+\t\t// print statement to debug random failures of this test", "+\t\tSystem.out.println(\"Forbidden reference before second exit \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));", "-\t\tsimulateRestart();\t\t", "+\t\tsimulateRestart();\t", "+\t\t// print statement to debug random failures of this test", "+\t\tSystem.out.println(\"Forbidden reference after second restart \" + JavaCore.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e60b037cf1bf08320bf2de449e0fc38a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElement.java", "commitBeforeChange": "6660c11fbd338cdace0b80e024a9e47f8c34c2d5", "commitAfterChange": "64151d299c94cd994364e344797612fa2bd1a461", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \tprotected IJavaElement getSourceElementAt(int position) throws JavaModelException", "signatureAfterChange": " \tprotected IJavaElement getSourceElementAt(int position) throws JavaModelException", "diff": ["-\t\t\tint i;", "-\t\t\tfor (i = 0; i < children.length; i++) {", "+\t\t\tfor (int i = children.length-1; i >= 0; i--) {", "-\t\t\t\t\tif (position < range.getOffset() + range.getLength() && position >= range.getOffset()) {", "-\t\t\t\t\t\tif (child instanceof IParent) {", "+\t\t\t\t\tint start = range.getOffset();", "+\t\t\t\t\tint end = start + range.getLength();", "+\t\t\t\t\tif (start <= position && position <= end) {", "+\t\t\t\t\t\tif (child instanceof IField) {", "+\t\t\t\t\t\t\t// check muti-declaration case (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=39943)", "+\t\t\t\t\t\t\tint declarationStart = start;", "+\t\t\t\t\t\t\tSourceRefElement candidate = null;", "+\t\t\t\t\t\t\tdo {", "+\t\t\t\t\t\t\t\t// check name range", "+\t\t\t\t\t\t\t\trange = ((IField)child).getNameRange();", "+\t\t\t\t\t\t\t\tif (position <= range.getOffset() + range.getLength()) {", "+\t\t\t\t\t\t\t\t\tcandidate = child;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\treturn candidate == null ? child.getSourceElementAt(position) : candidate.getSourceElementAt(position);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tchild = --i>=0 ? (SourceRefElement) children[i] : null;", "+\t\t\t\t\t\t\t} while (child != null && child.getSourceRange().getOffset() == declarationStart);", "+\t\t\t\t\t\t\t// position in field's type: use first field", "+\t\t\t\t\t\t\treturn candidate.getSourceElementAt(position);", "+\t\t\t\t\t\t} else if (child instanceof IParent) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9570aa1de373c22aa208eaa9e4b2f6c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java", "commitBeforeChange": "ff4953718f4a4fa66bb0922d1821b22a0e2fdd84", "commitAfterChange": "b48f366c7cd622655a48ea734bdcd0016d20ec8b", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " public void checkComment()", "signatureAfterChange": " public void checkComment()", "diff": ["+", "+\t\t// Search for pattern locator matches in javadoc comment parameters @param tags", "+\t\tJavadocSingleNameReference[] paramReferences = this.javadoc.paramReferences;", "+\t\tint length = paramReferences == null ? 0 : paramReferences.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tthis.patternLocator.match(paramReferences[i], this.nodeSet);", "+\t\t}", "+", "+\t\t// Search for pattern locator matches in javadoc comment type parameters @param tags", "+\t\tJavadocSingleTypeReference[] paramTypeParameters = this.javadoc.paramTypeParameters;", "+\t\tlength = paramTypeParameters == null ? 0 : paramTypeParameters.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tthis.patternLocator.match(paramTypeParameters[i], this.nodeSet);", "+\t\t}", "+", "-\t\tint throwsTagsLength = thrownExceptions == null ? 0 : thrownExceptions.length;", "-\t\tfor (int i = 0; i < throwsTagsLength; i++) {", "-\t\t\tTypeReference typeRef = thrownExceptions[i];", "-\t\t\tthis.patternLocator.match(typeRef, this.nodeSet);", "+\t\tlength = thrownExceptions == null ? 0 : thrownExceptions.length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tthis.patternLocator.match(thrownExceptions[i], this.nodeSet);", "-\t\tint seeTagsLength = references == null ? 0 : references.length;", "-\t\tfor (int i = 0; i < seeTagsLength; i++) {", "+\t\tlength = references == null ? 0 : references.length;", "+\t\tfor (int i = 0; i < length; i++) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ec3170c94866b72d5ac0587830ed206b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3e3563fc2739979022c8ed5ef771769e6ddb9cf7", "commitAfterChange": "ac01f488e9b6b2b17a11c53e0a49f85c3d9e7aeb", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " protected void reportDeclaration(MethodBinding methodBinding, MatchLocator locator, SimpleSet knownMethods) throws CoreException", "signatureAfterChange": " protected void reportDeclaration(MethodBinding methodBinding, MatchLocator locator, SimpleSet knownMethods) throws CoreException", "diff": ["+\tboolean isBinary = type.isBinary();", "+\tIMethod method = null;", "-\tString[] parameterTypes = new String[parameterLength];", "-\tfor (int i = 0; i  < parameterLength; i++) {", "-\t\tchar[] typeName = parameters[i].shortReadableName();", "-\t\tif (parameters[i].isMemberType()) {", "-\t\t\ttypeName = CharOperation.subarray(typeName, CharOperation.indexOf('.', typeName)+1, typeName.length);", "+\tif (isBinary) {", "+\t\tchar[][] parameterTypes = new char[parameterLength][];", "+\t\tfor (int i = 0; i<parameterLength; i++) {", "+\t\t\tchar[] typeName = parameters[i].qualifiedSourceName();", "+\t\t\tfor (int j=0, dim=parameters[i].dimensions(); j<dim; j++) {", "+\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t}", "+\t\t\tparameterTypes[i] = typeName;", "-\t\tparameterTypes[i] = Signature.createTypeSignature(typeName, false);", "+\t\tmethod = locator.createBinaryMethodHandle(type, methodBinding.selector, parameterTypes, locator);", "+\t} else {", "+\t\tString[] parameterTypes = new String[parameterLength];", "+\t\tfor (int i = 0; i  < parameterLength; i++) {", "+\t\t\tchar[] typeName = parameters[i].shortReadableName();", "+\t\t\tif (parameters[i].isMemberType()) {", "+\t\t\t\ttypeName = CharOperation.subarray(typeName, CharOperation.indexOf('.', typeName)+1, typeName.length);", "+\t\t\t}", "+\t\t\tparameterTypes[i] = Signature.createTypeSignature(typeName, false);", "+\t\t}", "+\t\tmethod = type.getMethod(new String(bindingSelector), parameterTypes);", "-\tIMethod method = type.getMethod(new String(bindingSelector), parameterTypes);", "-\tif (knownMethods.includes(method)) return;", "+\tif (method == null || knownMethods.includes(method)) return;", "-\tboolean isBinary = type.isBinary();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5d708809c8962e9ea026993ea7fd902", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "c9cd00a8dc1b877b2c5187fd0281ae7de37ff02a", "commitAfterChange": "4b3b23614cfca32dd53fa7e699914bb6d6883a79", "methodNumberBeforeChange": 49, "methodNumberAfterChange": 49, "signatureBeforeChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "signatureAfterChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed)", "diff": ["-", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)", "-\t\t\t\t\t&& lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "-", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))", "-\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t\tif(method.declaringClass == scope.getJavaLangObject())", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (method.declaringClass.isInterface())", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tif (!superCall && method", "-\t\t\t\t\t\t\t.declaringClass", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tif (method.declaringClass.isInterface())", "-\t\t\t\t\t\tif(otherMethod", "-\t\t\t\t\t\t\t.declaringClass", "-\t\t\t\t\t\t\t.implementsInterface(method.declaringClass,true))", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t", "-\t\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "-\t\t\t\t\t", "-\t\t\t\t\tif(!superCall) {", "-\t\t\t\t\t\tif(canBePrefixed) {", "-\t\t\t\t\t\t\tprefixRequired = true;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcontinue next;", "+\t\t\t\t", "+\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)) {", "+\t\t\t\t\tif (receiverType == otherReceiverType) {", "+\t\t\t\t\t\tif (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "+\t\t\t\t\t\t\tif (!superCall || !otherMethod.declaringClass.isInterface()) {", "+\t\t\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {", "+\t\t\t\t\t\t\tif(receiverType.isAnonymousType()) continue next;", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif(!superCall) {", "+\t\t\t\t\t\t\t\tif(!canBePrefixed) continue next;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tprefixRequired = true;", "+\t\t\t\t\t\t\t}", "+\t\t\t", "+\t\t\tReferenceBinding superTypeWithSameErasure = (ReferenceBinding)receiverType.findSuperTypeWithSameErasure(method.declaringClass);", "+\t\t\tif (method.declaringClass != superTypeWithSameErasure) {", "+\t\t\t\tMethodBinding[] otherMethods = superTypeWithSameErasure.getMethods(method.selector);", "+\t\t\t\tfor (int i = 0; i < otherMethods.length; i++) {", "+\t\t\t\t\tif(otherMethods[i].original() == method.original()) {", "+\t\t\t\t\t\tmethod = otherMethods[i];", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc725338b37a9040dd99f9676f9da208", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "1798df591429fc6a5448f8a074f2d563846bcebb", "commitAfterChange": "e8a92b10517fc0e6b59559ac009096fb50176b96", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " public void configure(String[] argv)", "signatureAfterChange": " public void configure(String[] argv)", "diff": ["-\tthis.annotationPath = null;", "+\tthis.annotationPaths = null;", "+\tthis.annotationsFromClasspath = false;", "-\t\t\t\tthis.annotationPath = currentArg;", "+\t\t\t\tif (currentArg.isEmpty() || currentArg.charAt(0) == '-')", "+\t\t\t\t\tthrow new IllegalArgumentException(this.bind(\"configure.missingAnnotationPath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\tif (ANNOTATION_SOURCE_CLASSPATH.equals(currentArg)) {", "+\t\t\t\t\tthis.annotationsFromClasspath = true;", "+\t\t\t\t} else {", "+\t\t\t\t\tif (this.annotationPaths == null)", "+\t\t\t\t\t\tthis.annotationPaths = new ArrayList<String>();", "+\t\t\t\t\tStringTokenizer tokens = new StringTokenizer(currentArg, File.pathSeparator);", "+\t\t\t\t\twhile (tokens.hasMoreTokens())", "+\t\t\t\t\t\tthis.annotationPaths.add(tokens.nextToken());", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fccd9d80889ff927c0c66de8b25160e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e87f51d941d6cbe203d8b543bd1f01e26d5c134d", "commitAfterChange": "1ffd151549eccf4f346b9688b80b9066e8dc6a10", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "diff": ["+\t\tif (SearchEngine.VERBOSE) {\r", "+\t\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$\r", "+\t\t\tfor (int i = 0, length = filePaths.length; i < length; i++) {\r", "+\t\t\t\tString path = filePaths[i];\r", "+\t\t\t\tSystem.out.println(\"\\t\" + path);\r", "+\t\t\t}\r", "+\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$\r", "+\t\t\tif (workingCopies != null) {\r", "+\t\t\t\t System.out.println(\" and working copies [\"); //$NON-NLS-1$\r", "+\t\t\t\tfor (int i = 0, length = workingCopies.length; i < length; i++) {\r", "+\t\t\t\t\tIWorkingCopy wc = workingCopies[i];\r", "+\t\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement)wc).toStringWithAncestors()); //$NON-NLS-1$\r", "+\t\t\t\t}\r", "+\t\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\t\r"]}], "num": 21155}