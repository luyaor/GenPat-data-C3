{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0d3d0fe70951cf73fcd3f765c122adf6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f57806ec5296ab34dc96e0e6a0dee41", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "83dc88df7a1508be17b764df4120ac8a34178f58", "commitAfterChange": "f428b70bc80bfdae47260a00a8636113b21b698c", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " public boolean isTypeArgumentIntersecting(TypeBinding otherArgument)", "signatureAfterChange": " public boolean isTypeArgumentIntersecting(TypeBinding otherArgument)", "diff": ["+\tcase Binding.INTERSECTION_TYPE:", "+\t\tcase Binding.INTERSECTION_TYPE:", "-\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\tupperBound1 = wildcard.bound;", "-\t\t\t\tbreak;", "-\t\t\tcase Wildcard.SUPER:", "-\t\t\t\tlowerBound1 = wildcard.bound;", "-\t\t\t\tbreak;", "-\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t}", "-", "-\t\t\tTypeBinding lowerBound2 = null;", "-\t\t\tTypeBinding upperBound2 = null;", "-\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "-\t\t\tswitch (otherWildcard.boundKind) {", "-\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\tupperBound2 = otherWildcard.bound;", "-\t\t\t\tbreak;", "-\t\t\tcase Wildcard.SUPER:", "-\t\t\t\tlowerBound2 = otherWildcard.bound;", "-\t\t\t\tbreak;", "-\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t}", "-\t\t\tif (lowerBound1 != null) {", "-\t\t\t\tif (lowerBound2 != null) {", "-\t\t\t\t\treturn true; // Object could always be a candidate", "-", "-\t\t\t\t} else if (upperBound2 != null) {", "-\t\t\t\t\treturn lowerBound1.isCompatibleWith(upperBound2);", "-\t\t\t\t} else {", "-\t\t\t\t\treturn true;", "+\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\tupperBound1 = wildcard.bound;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\tlowerBound1 = wildcard.bound;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t} else if (upperBound1 != null) {", "-\t\t\t\tif (upperBound1.isTypeVariable())", "-\t\t\t\t\treturn true;", "-\t\t\t\tif (lowerBound2 != null) {", "-\t\t\t\t\treturn lowerBound2.isCompatibleWith(upperBound1);", "-", "-\t\t\t\t} else if (upperBound2 != null) {", "-\t\t\t\t\tif (upperBound1.isInterface()) {", "-\t\t\t\t\t\tif (upperBound2.isInterface())", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\tif (upperBound2.isArrayType()", "-\t\t\t\t\t\t\t\t|| ((upperBound2 instanceof ReferenceBinding) && ((ReferenceBinding) upperBound2)", "-\t\t\t\t\t\t\t\t\t\t.isFinal())) {", "-\t\t\t\t\t\t\treturn upperBound2", "-\t\t\t\t\t\t\t\t\t.isCompatibleWith(upperBound1);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn true;", "+\t", "+\t\t\t\tTypeBinding lowerBound2 = null;", "+\t\t\t\tTypeBinding upperBound2 = null;", "+\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "+\t\t\t\tswitch (otherWildcard.boundKind) {", "+\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\tupperBound2 = otherWildcard.bound;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\tlowerBound2 = otherWildcard.bound;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t}", "+\t\t\t\tif (lowerBound1 != null) {", "+\t\t\t\t\tif (lowerBound2 != null) {", "+\t\t\t\t\t\treturn true; // Object could always be a candidate", "+\t", "+\t\t\t\t\t} else if (upperBound2 != null) {", "+\t\t\t\t\t\treturn lowerBound1.isCompatibleWith(upperBound2);", "-\t\t\t\t\t\tif (upperBound2.isInterface()) {", "-\t\t\t\t\t\t\tif (upperBound1.isArrayType()", "-\t\t\t\t\t\t\t\t\t|| ((upperBound1 instanceof ReferenceBinding) && ((ReferenceBinding) upperBound1)", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t} else if (upperBound1 != null) {", "+\t\t\t\t\tif (upperBound1.isTypeVariable())", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\tif (lowerBound2 != null) {", "+\t\t\t\t\t\treturn lowerBound2.isCompatibleWith(upperBound1);", "+\t", "+\t\t\t\t\t} else if (upperBound2 != null) {", "+\t\t\t\t\t\tif (upperBound1.isInterface()) {", "+\t\t\t\t\t\t\tif (upperBound2.isInterface())", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\tif (upperBound2.isArrayType()", "+\t\t\t\t\t\t\t\t\t|| ((upperBound2 instanceof ReferenceBinding) && ((ReferenceBinding) upperBound2)", "+\t\t\t\t\t\t\t\treturn upperBound2", "+\t\t\t\t\t\t\t\t\t\t.isCompatibleWith(upperBound1);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (upperBound2.isInterface()) {", "+\t\t\t\t\t\t\t\tif (upperBound1.isArrayType()", "+\t\t\t\t\t\t\t\t\t\t|| ((upperBound1 instanceof ReferenceBinding) && ((ReferenceBinding) upperBound1)", "+\t\t\t\t\t\t\t\t\t\t\t\t.isFinal())) {", "+\t\t\t\t\t\t\t\t\treturn upperBound1", "+\t\t\t\t\t\t\t\t\t\t\t.isCompatibleWith(upperBound2);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\treturn upperBound1", "-\t\t\t\t\t\t\t\t\t.isCompatibleWith(upperBound2);", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\treturn true;", "-\t\t\t\t\treturn true;", "-\t\t\t} else {", "-\t\t\t\treturn true;", "-\t\t\t}", "-", "-\t\t\t// WILDCARD & OTHER TYPE", "-\t\tdefault:", "-\t\t\twildcard = (WildcardBinding) this;", "-\t\t\tswitch (wildcard.boundKind) {", "-\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\treturn otherArgument.isCompatibleWith(wildcard.bound);", "-\t\t\tcase Wildcard.SUPER:", "-\t\t\t\treturn wildcard.bound.isCompatibleWith(otherArgument);", "-\t\t\tcase Wildcard.UNBOUND:", "+\t", "+\t\t\t\t// WILDCARD & OTHER TYPE", "-\t\t\t\treturn true;", "-\t\t\t}", "+\t\t\t\twildcard = (WildcardBinding) this;", "+\t\t\t\tswitch (wildcard.boundKind) {", "+\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\treturn otherArgument.isCompatibleWith(wildcard.bound);", "+\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\treturn wildcard.bound.isCompatibleWith(otherArgument);", "+\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\tdefault:", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\tcase Binding.INTERSECTION_TYPE:"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9132d3314afd1a91ed0ada310ad336c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "8c76b4014ea5428c07ebba6a1cc324074d6e35bd", "commitAfterChange": "ff2a27470c07ef3625cccb4ee1e5803e3112da43", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " private int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, int depth, MatchLocator locator)", "signatureAfterChange": " private int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, int depth, MatchLocator locator)", "diff": ["-\t\t\t// If we get a binding for pattern arg, then verify if it is compatible with match type argument binding", "-\t\t\tif (patternBinding != null) {", "-\t\t\t\tTypeBinding argumentBinding = argumentsBinding[i];", "-\t\t\t\tswitch (patternWildcard) {", "-\t\t\t\t\tcase Signature.C_STAR : // UNBOUND pattern", "-\t\t\t\t\t\t// unbound always match => skip to next argument", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tcase Signature.C_EXTENDS : // EXTENDS pattern", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t\t\t// valid when arg extends a subclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (argumentBinding.isCompatibleWith(patternBinding)) {", "-\t\t\t\t\t\t\t// valid when arg is a subclass of pattern ", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase Signature.C_SUPER : // SUPER pattern", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg super a superclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (patternBinding.isCompatibleWith(argumentBinding)) {", "-\t\t\t\t\t\t\t// valid only when arg is a superclass of pattern", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg extends a superclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg super a subclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (argumentBinding == patternBinding)", "-\t\t\t\t\t\t\t// valid only when arg is equals to pattern", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\t\t// If have no binding for pattern arg, then we won't be able to refine accuracy", "+\t\t\tif (patternBinding == null) return accuracy;", "-\t\t\t\t// Refine the accuracy to impossible", "-\t\t\t\treturn -1;", "+\t\t\t// Verify tha pattern binding is compatible with match type argument binding", "+\t\t\tTypeBinding argumentBinding = argumentsBinding[i];", "+\t\t\tswitch (patternWildcard) {", "+\t\t\t\tcase Signature.C_STAR : // UNBOUND pattern", "+\t\t\t\t\t// unbound always match => skip to next argument", "+\t\t\t\t\tcontinue;", "+\t\t\t\tcase Signature.C_EXTENDS : // EXTENDS pattern", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "+\t\t\t\t\t\t\t\t\t// valid when arg extends a subclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (argumentBinding.isCompatibleWith(patternBinding)) {", "+\t\t\t\t\t\t// valid when arg is a subclass of pattern ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Signature.C_SUPER : // SUPER pattern", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "+\t\t\t\t\t\t\t\t\t// valid only when arg super a superclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (patternBinding.isCompatibleWith(argumentBinding)) {", "+\t\t\t\t\t\t// valid only when arg is a superclass of pattern", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "+\t\t\t\t\t\t\t\t\t// valid only when arg extends a superclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "+\t\t\t\t\t\t\t\t\t// valid only when arg super a subclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (argumentBinding == patternBinding)", "+\t\t\t\t\t\t// valid only when arg is equals to pattern", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tbreak;", "+\t\t\t", "+\t\t\t// Refine the accuracy to impossible", "+\t\t\treturn -1;"]}], "num": 40848}