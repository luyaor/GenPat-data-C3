{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ca754e5792ec50cd2d24b0cb21f9358b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8afc9655472b305a5b6bccc6ba388cd5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "24cf489e4c973e29dff7eade9d41897f72a37db0", "commitAfterChange": "f924ed86fe1dbe148077a9cade20b11e404ba89b", "methodNumberBeforeChange": 169, "methodNumberAfterChange": 181, "signatureBeforeChange": "  \tprivate void findTypesAndPackages(char[] token, Scope scope, boolean proposeBaseTypes, boolean proposeVoidType, ObjectVector typesFound)", "signatureAfterChange": "  \tprivate void findTypesAndPackages(char[] token, Scope scope, boolean proposeBaseTypes, boolean proposeVoidType, ObjectVector typesFound)", "diff": ["-", "+\t\t", "+\t\tboolean allowingLongComputationProposals = isAllowingLongComputationProposals();", "+\t\t", "+\t\t", "+\t\tboolean proposeConstructor =", "+\t\t\tallowingLongComputationProposals &&", "+\t\t\tthis.assistNodeIsConstructor &&", "+\t\t\t(!isIgnored(CompletionProposal.CONSTRUCTOR_INVOCATION, CompletionProposal.TYPE_REF) ||", "+\t\t\t\t\t!isIgnored(CompletionProposal.ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION, CompletionProposal.TYPE_REF));", "+\t\t", "-\t\tif (proposeType && scope.enclosingSourceType() != null) {", "+\t\tif ((proposeType || proposeConstructor) && scope.enclosingSourceType() != null) {", "-\t\tif (proposeType && this.unitScope != null) {", "+\t\tif ((proposeType || proposeConstructor) && this.unitScope != null) {", "-\t\t\t\t\t\t&& !(this.options.camelCaseMatch && CharOperation.camelCaseMatch(token, sourceType.sourceName))) continue;", "+\t\t\t\t\t\t&& !(this.options.camelCaseMatch && CharOperation.camelCaseMatch(token, sourceType.sourceName))) continue next;", "-", "-\t\t\t\tthis.knownTypes.put(CharOperation.concat(sourceType.qualifiedPackageName(), sourceType.sourceName(), '.'), this);", "+\t\t\t\t", "+\t\t\t\ttypesFound.add(sourceType);", "+\t\t\t\t", "+\t\t\t\t", "-\t\t\t\tif(proposeType) {", "+\t\t\t\tif(proposeType &&", "+\t\t\t\t\t\t(!this.assistNodeIsConstructor ||", "+\t\t\t\t\t\t\t\t!allowingLongComputationProposals ||", "+\t\t\t\t\t\t\t\thasStaticMemberTypes(sourceType, null, this.unitScope) ||", "+\t\t\t\t\t\t\t\thasMemberTypesInEnclosingScope(sourceType, scope))) {", "+\t\t\t\t", "+\t\t\t\tif (proposeConstructor) {", "+\t\t\t\t\tfindConstructorsOrAnonymousTypes(", "+\t\t\t\t\t\t\tsourceType,", "+\t\t\t\t\t\t\tscope,", "+\t\t\t\t\t\t\tFakeInvocationSite,", "+\t\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\t\trelevance);", "+\t\t\t\t}", "-\t\tif(proposeType) {", "+\t\tif (proposeConstructor && !isEmptyPrefix) {", "+\t\t\t", "+\t\t\tcheckCancel();", "+\t\t\t", "+\t\t\tfindTypesFromImports(token, scope, proposeType, typesFound);", "+\t\t} else if(proposeType) {", "+\t\t", "+\t\tif (proposeConstructor) {", "+\t\t\t", "+\t\t\tcheckCancel();", "+\t\t\t", "+\t\t\tfindTypesFromExpectedTypes(token, scope, typesFound, proposeType, proposeConstructor);", "+\t\t}", "-\t\t\tif(proposeType && this.expectedTypesPtr > -1) {", "-\t\t\t\tnext : for (int i = 0; i <= this.expectedTypesPtr; i++) {", "-\t\t\t\t\t", "-\t\t\t\t\tcheckCancel();", "-\t\t\t\t\t", "-\t\t\t\t\tif(this.expectedTypes[i] instanceof ReferenceBinding) {", "-\t\t\t\t\t\tReferenceBinding refBinding = (ReferenceBinding)this.expectedTypes[i];", "-", "-\t\t\t\t\t\tif(refBinding.isTypeVariable() && this.assistNodeIsConstructor) {", "-\t\t\t\t\t\t\t// don't propose type variable if the completion is a constructor ('new |')", "-\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.options.checkDeprecation &&", "-\t\t\t\t\t\t\t\trefBinding.isViewedAsDeprecated() &&", "-\t\t\t\t\t\t\t\t!scope.isDefinedInSameUnit(refBinding))", "-\t\t\t\t\t\t\tcontinue next;", "-", "-\t\t\t\t\t\tint accessibility = IAccessRule.K_ACCESSIBLE;", "-\t\t\t\t\t\tif(refBinding.hasRestrictedAccess()) {", "-\t\t\t\t\t\t\tAccessRestriction accessRestriction = this.lookupEnvironment.getAccessRestriction(refBinding);", "-\t\t\t\t\t\t\tif(accessRestriction != null) {", "-\t\t\t\t\t\t\t\tswitch (accessRestriction.getProblemId()) {", "-\t\t\t\t\t\t\t\t\tcase IProblem.ForbiddenReference:", "-\t\t\t\t\t\t\t\t\t\tif (this.options.checkForbiddenReference) {", "-\t\t\t\t\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\taccessibility = IAccessRule.K_NON_ACCESSIBLE;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase IProblem.DiscouragedReference:", "-\t\t\t\t\t\t\t\t\t\tif (this.options.checkDiscouragedReference) {", "-\t\t\t\t\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\taccessibility = IAccessRule.K_DISCOURAGED;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tfor (int j = 0; j < typesFound.size(); j++) {", "-\t\t\t\t\t\t\tReferenceBinding typeFound = (ReferenceBinding)typesFound.elementAt(j);", "-\t\t\t\t\t\t\tif (typeFound == refBinding) {", "-\t\t\t\t\t\t\t\tcontinue next;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tboolean inSameUnit = this.unitScope.isDefinedInSameUnit(refBinding);", "-", "-\t\t\t\t\t\t// top level types of the current unit are already proposed.", "-\t\t\t\t\t\tif(!inSameUnit || (inSameUnit && refBinding.isMemberType())) {", "-\t\t\t\t\t\t\tchar[] packageName = refBinding.qualifiedPackageName();", "-\t\t\t\t\t\t\tchar[] typeName = refBinding.sourceName();", "-\t\t\t\t\t\t\tchar[] completionName = typeName;", "-", "-\t\t\t\t\t\t\tboolean isQualified = false;", "-\t\t\t\t\t\t\tif (!this.insideQualifiedReference && !refBinding.isMemberType()) {", "-\t\t\t\t\t\t\t\tif (mustQualifyType(packageName, typeName, null, refBinding.modifiers)) {", "-\t\t\t\t\t\t\t\t\tif (packageName == null || packageName.length == 0)", "-\t\t\t\t\t\t\t\t\t\tif (this.unitScope != null && this.unitScope.fPackage.compoundName != CharOperation.NO_CHAR_CHAR)", "-\t\t\t\t\t\t\t\t\t\t\tcontinue next; // ignore types from the default package from outside it", "-\t\t\t\t\t\t\t\t\tcompletionName = CharOperation.concat(packageName, typeName, '.');", "-\t\t\t\t\t\t\t\t\tisQualified = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\tif(this.assistNodeIsClass) {", "-\t\t\t\t\t\t\t\tif(!refBinding.isClass()) continue next;", "-\t\t\t\t\t\t\t} else if(this.assistNodeIsInterface) {", "-\t\t\t\t\t\t\t\tif(!refBinding.isInterface() && !refBinding.isAnnotationType()) continue next;", "-\t\t\t\t\t\t\t} else if (this.assistNodeIsAnnotation) {", "-\t\t\t\t\t\t\t\tif(!refBinding.isAnnotationType()) continue next;", "-\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\tint relevance = computeBaseRelevance();", "-\t\t\t\t\t\t\trelevance += computeRelevanceForResolution();", "-\t\t\t\t\t\t\trelevance += computeRelevanceForInterestingProposal();", "-\t\t\t\t\t\t\trelevance += computeRelevanceForCaseMatching(token, typeName);", "-\t\t\t\t\t\t\trelevance += computeRelevanceForExpectingType(refBinding);", "-\t\t\t\t\t\t\trelevance += computeRelevanceForQualification(isQualified);", "-\t\t\t\t\t\t\trelevance += computeRelevanceForRestrictions(accessibility);", "-", "-\t\t\t\t\t\t\tif(refBinding.isClass()) {", "-\t\t\t\t\t\t\t\trelevance += computeRelevanceForClass();", "-\t\t\t\t\t\t\t\trelevance += computeRelevanceForException(typeName);", "-\t\t\t\t\t\t\t} else if(refBinding.isEnum()) {", "-\t\t\t\t\t\t\t\trelevance += computeRelevanceForEnum();", "-\t\t\t\t\t\t\t} else if(refBinding.isInterface()) {", "-\t\t\t\t\t\t\t\trelevance += computeRelevanceForInterface();", "-\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\tthis.noProposal = false;", "-\t\t\t\t\t\t\tif(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {", "-\t\t\t\t\t\t\t\tInternalCompletionProposal proposal =  createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);", "-\t\t\t\t\t\t\t\tproposal.setDeclarationSignature(packageName);", "-\t\t\t\t\t\t\t\tproposal.setSignature(getSignature(refBinding));", "-\t\t\t\t\t\t\t\tproposal.setPackageName(packageName);", "-\t\t\t\t\t\t\t\tproposal.setTypeName(typeName);", "-\t\t\t\t\t\t\t\tproposal.setCompletion(completionName);", "-\t\t\t\t\t\t\t\tproposal.setFlags(refBinding.modifiers);", "-\t\t\t\t\t\t\t\tproposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);", "-\t\t\t\t\t\t\t\tproposal.setTokenRange(this.tokenStart - this.offset, this.tokenEnd - this.offset);", "-\t\t\t\t\t\t\t\tproposal.setRelevance(relevance);", "-\t\t\t\t\t\t\t\tproposal.setAccessibility(accessibility);", "-\t\t\t\t\t\t\t\tthis.requestor.accept(proposal);", "-\t\t\t\t\t\t\t\tif(DEBUG) {", "-\t\t\t\t\t\t\t\t\tthis.printDebug(proposal);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\tif (!proposeConstructor) {", "+\t\t\t\tfindTypesFromExpectedTypes(token, scope, typesFound, proposeType, proposeConstructor);", "-\t\t\tif(proposeType) {", "+\t\t\t", "+\t\t\tif (proposeConstructor) {", "-\t\t\t\t\tthis.knownTypes.put(fullyQualifiedTypeName, this);", "+\t\t\t\t\tthis.knownTypes.put(fullyQualifiedTypeName, KNOWN_TYPE_WITH_KNOWN_CONSTRUCTORS);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tcheckCancel();", "+\t\t\t\t", "+\t\t\t\tthis.foundConstructorsCount = 0;", "+\t\t\t\tthis.nameEnvironment.findConstructorDeclarations(", "+\t\t\t\t\t\ttoken,", "+\t\t\t\t\t\tthis.options.camelCaseMatch,", "+\t\t\t\t\t\tthis,", "+\t\t\t\t\t\tthis.monitor);", "+\t\t\t\tacceptConstructors(scope);", "+\t\t\t} else if (proposeType) {", "+\t\t\t\tint l = typesFound.size();", "+\t\t\t\tfor (int i = 0; i < l; i++) {", "+\t\t\t\t\tReferenceBinding typeFound = (ReferenceBinding) typesFound.elementAt(i);", "+\t\t\t\t\tchar[] fullyQualifiedTypeName =", "+\t\t\t\t\t\tCharOperation.concat(", "+\t\t\t\t\t\t\t\ttypeFound.qualifiedPackageName(),", "+\t\t\t\t\t\t\t\ttypeFound.qualifiedSourceName(),", "+\t\t\t\t\t\t\t\t'.');", "+\t\t\t\t\tthis.knownTypes.put(fullyQualifiedTypeName, KNOWN_TYPE_WITH_KNOWN_CONSTRUCTORS);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c748de62b33b2d3ced88d483166ea150", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "0c9d35cff2dc84f5482dc68d6d37735087c6900a", "commitAfterChange": "ec83f4485fd98b95e4e8e2158e7e66ce8f1734fe", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType)", "signatureAfterChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType)", "diff": ["-   ", "-   // range check", "-   boolean isInRange = ", "-            scanner.initialPosition <= typeDeclaration.declarationSourceStart", "-            && scanner.eofPosition >= typeDeclaration.declarationSourceEnd;", "-   ", "-   FieldDeclaration[] fields = typeDeclaration.fields;", "-   AbstractMethodDeclaration[] methods = typeDeclaration.methods;", "-   TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;", "-   int fieldCounter = fields == null ? 0 : fields.length;", "-   int methodCounter = methods == null ? 0 : methods.length;", "-   int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;", "-   int fieldIndex = 0;", "-   int methodIndex = 0;", "-   int memberTypeIndex = 0;", "- ", "-   if (notifyTypePresence){", "-      char[][] interfaceNames = null;", "-      int superInterfacesLength = 0;", "-      TypeReference[] superInterfaces = typeDeclaration.superInterfaces;", "-      if (superInterfaces != null) {", "-         superInterfacesLength = superInterfaces.length;", "-         interfaceNames = new char[superInterfacesLength][];", "-      } else {", "-         if ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "-            // see PR 3442", "-            QualifiedAllocationExpression alloc = typeDeclaration.allocation;", "-            if (alloc != null && alloc.type != null) {", "-               superInterfaces = new TypeReference[] { alloc.type};", "-               superInterfacesLength = 1;", "-               interfaceNames = new char[1][];", "-            }", "-         }", "-      }", "-      if (superInterfaces != null) {", "-         for (int i = 0; i < superInterfacesLength; i++) {", "-            interfaceNames[i] = ", "-               CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); ", "-         }", "-      }", "-      int kind = typeDeclaration.kind();", "-      switch (kind) {", "-         case IGenericType.CLASS_DECL :", "-         case IGenericType.ANNOTATION_TYPE_DECL :", "-            TypeReference superclass = typeDeclaration.superclass;", "-            if (superclass == null) {", "- \t\t\t\tif (isInRange) {", "- \t\t\t\t\tint flags =  typeDeclaration.modifiers;", "- \t\t\t\t\tboolean isEnumInit = typeDeclaration.allocation != null && typeDeclaration.allocation.enumConstant != null;", "- \t\t\t\t\tif (isEnumInit)", "- \t\t\t\t\t\tflags |= AccEnum;", "- \t\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "- \t\t\t\t\ttypeInfo.kind = kind;", "- \t\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "- \t\t\t\t\ttypeInfo.modifiers = flags;", "- \t\t\t\t\ttypeInfo.name = typeDeclaration.name;", "- \t\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "- \t\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "- \t\t\t\t\ttypeInfo.superclass = isEnumInit ? declaringType.name : null;", "- \t\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "- \t\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "-\t\t\t\t\ttypeInfo.annotationPositions = collectAnnotationPositions(typeDeclaration.annotations);", "-\t\t\t\t\trequestor.enterClass(typeInfo);", "-               }", "-            } else {", "-               if (isInRange) {", "-\t\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "- \t\t\t\t\ttypeInfo.kind = kind;", "- \t\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "- \t\t\t\t\ttypeInfo.modifiers = typeDeclaration.modifiers;", "- \t\t\t\t\ttypeInfo.name = typeDeclaration.name;", "- \t\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "- \t\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "- \t\t\t\t\ttypeInfo.superclass = CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');", "- \t\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "- \t\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "-\t\t\t\t\ttypeInfo.annotationPositions = collectAnnotationPositions(typeDeclaration.annotations);", "-\t\t\t\t\trequestor.enterClass(typeInfo);", "-               }", "-            }", "-            if (nestedTypeIndex == typeNames.length) {", "-               // need a resize", "-               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-            }", "-            typeNames[nestedTypeIndex] = typeDeclaration.name;", "-            superTypeNames[nestedTypeIndex++] = superclass == null ? TypeConstants.CharArray_JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');", "-            break;", "- ", "-         case IGenericType.INTERFACE_DECL :", "-            if (isInRange){", "-               int currentModifiers = typeDeclaration.modifiers;", "-               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "-\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "-\t\t\t\ttypeInfo.kind = kind;", "-\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "-\t\t\t\ttypeInfo.modifiers = deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag;", "-\t\t\t\ttypeInfo.name = typeDeclaration.name;", "-\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "-\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "-\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "-\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "-\t\t\t\ttypeInfo.annotationPositions = collectAnnotationPositions(typeDeclaration.annotations);", "-\t\t\t\trequestor.enterInterface(typeInfo);", "-            }", "-            if (nestedTypeIndex == typeNames.length) {", "-               // need a resize", "-               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-            }", "-            typeNames[nestedTypeIndex] = typeDeclaration.name;", "-            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_OBJECT;", "-            break;", "- ", "-         case IGenericType.ENUM_DECL :", "- ", "-            if (isInRange){", "-               int currentModifiers = typeDeclaration.modifiers;", "-               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "-\t\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "-\t\t\t\ttypeInfo.kind = kind;", "-\t\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "-\t\t\t\ttypeInfo.modifiers = deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag;", "-\t\t\t\ttypeInfo.name = typeDeclaration.name;", "-\t\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "-\t\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "-\t\t\t\ttypeInfo.superinterfaces = interfaceNames;", "-\t\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "-\t\t\t\ttypeInfo.annotationPositions = collectAnnotationPositions(typeDeclaration.annotations);", "-\t\t\t\trequestor.enterEnum(typeInfo);", "-            }", "-            if (nestedTypeIndex == typeNames.length) {", "-               // need a resize", "-               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-            }", "-            typeNames[nestedTypeIndex] = typeDeclaration.name;", "-            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_ENUM;", "-            break;", "- ", "-//         case IGenericType.ANNOTATION_TYPE :", "-            // TODO need support", "-//            break;", "-      }      ", "-   }", "-   while ((fieldIndex < fieldCounter)", "-      || (memberTypeIndex < memberTypeCounter)", "-      || (methodIndex < methodCounter)) {", "-      FieldDeclaration nextFieldDeclaration = null;", "-      AbstractMethodDeclaration nextMethodDeclaration = null;", "-      TypeDeclaration nextMemberDeclaration = null;", "- ", "-      int position = Integer.MAX_VALUE;", "-      int nextDeclarationType = -1;", "-      if (fieldIndex < fieldCounter) {", "-         nextFieldDeclaration = fields[fieldIndex];", "-         if (nextFieldDeclaration.declarationSourceStart < position) {", "-            position = nextFieldDeclaration.declarationSourceStart;", "-            nextDeclarationType = 0; // FIELD", "-         }", "-      }", "-      if (methodIndex < methodCounter) {", "-         nextMethodDeclaration = methods[methodIndex];", "-         if (nextMethodDeclaration.declarationSourceStart < position) {", "-            position = nextMethodDeclaration.declarationSourceStart;", "-            nextDeclarationType = 1; // METHOD", "-         }", "-      }", "-      if (memberTypeIndex < memberTypeCounter) {", "-         nextMemberDeclaration = memberTypes[memberTypeIndex];", "-         if (nextMemberDeclaration.declarationSourceStart < position) {", "-            position = nextMemberDeclaration.declarationSourceStart;", "-            nextDeclarationType = 2; // MEMBER", "-         }", "-      }", "-      switch (nextDeclarationType) {", "-         case 0 :", "-            fieldIndex++;", "-            notifySourceElementRequestor(nextFieldDeclaration, typeDeclaration);", "-            break;", "-         case 1 :", "-            methodIndex++;", "-            notifySourceElementRequestor(nextMethodDeclaration);", "-            break;", "-         case 2 :", "-            memberTypeIndex++;", "-            notifySourceElementRequestor(nextMemberDeclaration, true, null);", "-      }", "-   }", "-   if (notifyTypePresence){", "-      if (isInRange){", "-         switch (typeDeclaration.kind()) {", "-            case IGenericType.CLASS_DECL :", "-            case IGenericType.ANNOTATION_TYPE_DECL :", "-               requestor.exitClass(typeDeclaration.declarationSourceEnd);", "-               break;", "-            case IGenericType.INTERFACE_DECL :", "-               requestor.exitInterface(typeDeclaration.declarationSourceEnd);", "-               break;", "-            case IGenericType.ENUM_DECL :", "-               requestor.exitEnum(typeDeclaration.declarationSourceEnd);", "-               break;", "-/*            case IGenericType.ANNOTATION_TYPE :", "-               // TODO need support", "-               //requestor.exitAnnotationType(typeDeclaration.declarationSourceEnd);", "-               break;*/", "-         }         ", "-      }", "-      nestedTypeIndex--;", "-   }", "+\t", "+\t// range check", "+\tboolean isInRange = ", "+\t\tscanner.initialPosition <= typeDeclaration.declarationSourceStart", "+\t\t&& scanner.eofPosition >= typeDeclaration.declarationSourceEnd;", "+\t", "+\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+\tTypeDeclaration[] memberTypes = typeDeclaration.memberTypes;", "+\tint fieldCounter = fields == null ? 0 : fields.length;", "+\tint methodCounter = methods == null ? 0 : methods.length;", "+\tint memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;", "+\tint fieldIndex = 0;", "+\tint methodIndex = 0;", "+\tint memberTypeIndex = 0;", "+\t", "+\tif (notifyTypePresence){", "+\t\tchar[][] interfaceNames = null;", "+\t\tint superInterfacesLength = 0;", "+\t\tTypeReference[] superInterfaces = typeDeclaration.superInterfaces;", "+\t\tif (superInterfaces != null) {", "+\t\t\tsuperInterfacesLength = superInterfaces.length;", "+\t\t\tinterfaceNames = new char[superInterfacesLength][];", "+\t\t} else {", "+\t\t\tif ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "+\t\t\t\t// see PR 3442", "+\t\t\t\tQualifiedAllocationExpression alloc = typeDeclaration.allocation;", "+\t\t\t\tif (alloc != null && alloc.type != null) {", "+\t\t\t\t\tsuperInterfaces = new TypeReference[] { alloc.type};", "+\t\t\t\t\tsuperInterfacesLength = 1;", "+\t\t\t\t\tinterfaceNames = new char[1][];", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (superInterfaces != null) {", "+\t\t\tfor (int i = 0; i < superInterfacesLength; i++) {", "+\t\t\t\tinterfaceNames[i] = ", "+\t\t\t\t\tCharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); ", "+\t\t\t}", "+\t\t}", "+\t\tint kind = typeDeclaration.kind();", "+\t\tchar[] implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;", "+\t\tif (isInRange) {", "+\t\t\tint currentModifiers = typeDeclaration.modifiers;", "+\t\t\tboolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "+\t\t\tboolean isEnumInit = typeDeclaration.allocation != null && typeDeclaration.allocation.enumConstant != null;", "+\t\t\tchar[] superclassName;", "+\t\t\tif (isEnumInit) {", "+\t\t\t\tcurrentModifiers |= AccEnum;", "+\t\t\t\tsuperclassName = declaringType.name;", "+\t\t\t} else {", "+\t\t\t\tTypeReference superclass = typeDeclaration.superclass;", "+\t\t\t\tsuperclassName = superclass != null ? CharOperation.concatWith(superclass.getParameterizedTypeName(), '.') : null;", "+\t\t\t}", "+\t\t\tISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();", "+\t\t\ttypeInfo.kind = kind;", "+\t\t\ttypeInfo.declarationStart = typeDeclaration.declarationSourceStart;", "+\t\t\ttypeInfo.modifiers = deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag;", "+\t\t\ttypeInfo.name = typeDeclaration.name;", "+\t\t\ttypeInfo.nameSourceStart = typeDeclaration.sourceStart;", "+\t\t\ttypeInfo.nameSourceEnd = sourceEnd(typeDeclaration);", "+\t\t\ttypeInfo.superclass = superclassName;", "+\t\t\ttypeInfo.superinterfaces = interfaceNames;", "+\t\t\ttypeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);", "+\t\t\ttypeInfo.annotationPositions = collectAnnotationPositions(typeDeclaration.annotations);", "+\t\t\trequestor.enterType(typeInfo);", "+\t\t\tswitch (kind) {", "+\t\t\t\tcase IGenericType.CLASS_DECL :", "+\t\t\t\t\tif (superclassName != null)", "+\t\t\t\t\t\timplicitSuperclassName = superclassName;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IGenericType.INTERFACE_DECL :", "+\t\t\t\t\timplicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IGenericType.ENUM_DECL :", "+\t\t\t\t\timplicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ENUM;", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase IGenericType.ANNOTATION_TYPE_DECL :", "+\t\t\t\t\timplicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ANNOTATION_ANNOTATION;", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (this.nestedTypeIndex == this.typeNames.length) {", "+\t\t\t// need a resize", "+\t\t\tSystem.arraycopy(this.typeNames, 0, (this.typeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);", "+\t\t\tSystem.arraycopy(this.superTypeNames, 0, (this.superTypeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);", "+\t\t}", "+\t\tthis.typeNames[this.nestedTypeIndex] = typeDeclaration.name;", "+\t\tthis.superTypeNames[this.nestedTypeIndex++] = implicitSuperclassName;", "+\t}", "+\twhile ((fieldIndex < fieldCounter)", "+\t\t\t|| (memberTypeIndex < memberTypeCounter)", "+\t\t\t|| (methodIndex < methodCounter)) {", "+\t\tFieldDeclaration nextFieldDeclaration = null;", "+\t\tAbstractMethodDeclaration nextMethodDeclaration = null;", "+\t\tTypeDeclaration nextMemberDeclaration = null;", "+\t\t", "+\t\tint position = Integer.MAX_VALUE;", "+\t\tint nextDeclarationType = -1;", "+\t\tif (fieldIndex < fieldCounter) {", "+\t\t\tnextFieldDeclaration = fields[fieldIndex];", "+\t\t\tif (nextFieldDeclaration.declarationSourceStart < position) {", "+\t\t\t\tposition = nextFieldDeclaration.declarationSourceStart;", "+\t\t\t\tnextDeclarationType = 0; // FIELD", "+\t\t\t}", "+\t\t}", "+\t\tif (methodIndex < methodCounter) {", "+\t\t\tnextMethodDeclaration = methods[methodIndex];", "+\t\t\tif (nextMethodDeclaration.declarationSourceStart < position) {", "+\t\t\t\tposition = nextMethodDeclaration.declarationSourceStart;", "+\t\t\t\tnextDeclarationType = 1; // METHOD", "+\t\t\t}", "+\t\t}", "+\t\tif (memberTypeIndex < memberTypeCounter) {", "+\t\t\tnextMemberDeclaration = memberTypes[memberTypeIndex];", "+\t\t\tif (nextMemberDeclaration.declarationSourceStart < position) {", "+\t\t\t\tposition = nextMemberDeclaration.declarationSourceStart;", "+\t\t\t\tnextDeclarationType = 2; // MEMBER", "+\t\t\t}", "+\t\t}", "+\t\tswitch (nextDeclarationType) {", "+\t\t\tcase 0 :", "+\t\t\t\tfieldIndex++;", "+\t\t\t\tnotifySourceElementRequestor(nextFieldDeclaration, typeDeclaration);", "+\t\t\t\tbreak;", "+\t\t\tcase 1 :", "+\t\t\t\tmethodIndex++;", "+\t\t\t\tnotifySourceElementRequestor(nextMethodDeclaration);", "+\t\t\t\tbreak;", "+\t\t\tcase 2 :", "+\t\t\t\tmemberTypeIndex++;", "+\t\t\t\tnotifySourceElementRequestor(nextMemberDeclaration, true, null);", "+\t\t}", "+\t}", "+\tif (notifyTypePresence){", "+\t\tif (isInRange){", "+\t\t\trequestor.exitType(typeDeclaration.declarationSourceEnd);", "+\t\t}", "+\t\tnestedTypeIndex--;", "+\t}"]}], "num": 2386}