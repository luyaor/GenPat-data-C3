{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ce9c657980fc9deb72553525a050bd12", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0625457e1f346f326503f0fdb2a0f90d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "0b724131f5f3cf2d018d63a77e76484f2fe8967f", "commitAfterChange": "7efd98740c0284fcb351af505635684db1a5006c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "signatureAfterChange": " \tpublic void collectSubstitutes(TypeBinding otherType, Map substitutes)", "diff": ["-\t        \tif (equivalent == null || !equivalent.isParameterizedType())", "-\t        \t\treturn;", "+\t        \tif (equivalent == null) return;", "-\t        if (equivalent.isParameterizedType() && otherEquivalent.isParameterizedType()) {", "-\t        \tParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) equivalent;", "-\t        \tParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherEquivalent;", "-\t            for (int i = 0, length = parameterizedType.arguments.length; i < length; i++) {", "-\t                parameterizedType.arguments[i].collectSubstitutes(otherParameterizedType.arguments[i], substitutes);", "-\t            }", "-\t        } else if (equivalent.isParameterizedType() && otherEquivalent.isRawType()) {", "-\t        \tsubstitutes.clear(); // clear all variables to indicate raw generic method in the end", "+\t        TypeBinding[] elements;", "+\t        switch (equivalent.kind()) {", "+\t        \tcase Binding.GENERIC_TYPE :", "+\t        \t\telements = equivalent.typeVariables();", "+\t        \t\tbreak;", "+\t        \tcase Binding.PARAMETERIZED_TYPE :", "+\t        \t\telements = ((ParameterizedTypeBinding)equivalent).arguments;", "+\t        \t\tbreak;", "+\t        \tdefault :", "+\t        \t\treturn;", "+\t        }", "+\t        TypeBinding[] otherElements;", "+\t        switch (otherEquivalent.kind()) {", "+\t        \tcase Binding.GENERIC_TYPE :", "+\t        \t\totherElements = otherEquivalent.typeVariables();", "+\t        \t\tbreak;", "+\t        \tcase Binding.PARAMETERIZED_TYPE :", "+\t        \t\totherElements = ((ParameterizedTypeBinding)otherEquivalent).arguments;", "+\t        \t\tbreak;", "+\t        \tcase Binding.RAW_TYPE :", "+\t        \t\tsubstitutes.clear(); // clear all variables to indicate raw generic method in the end", "+\t        \t\treturn;", "+\t        \tdefault :", "+\t        \t\treturn;", "+\t        }", "+            for (int i = 0, length = elements.length; i < length; i++) {", "+                elements[i].collectSubstitutes(otherElements[i], substitutes);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "092b80f8c80499335d8701668c33a6fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "9e52c15d15d394b53153c5ea38c3a83d68121d6a", "commitAfterChange": "9951b7a54ba18cc36a88513505c20a6b6559265f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \tpublic String rootID()", "signatureAfterChange": "\r \tpublic String rootID()", "diff": ["-\t\tbuffer.append(JavaProject.kindToString(this.entryKind));\r", "-\t\tbuffer.append(']');\r", "-\t\tbuffer.append(this.path);\r", "-\t\treturn buffer.toString();\r", "+\t\tswitch(this.entryKind){\r", "+\t\t\tcase IClasspathEntry.CPE_LIBRARY :\r", "+\t\t\t\treturn \"[LIB]\"+this.path;  //$NON-NLS-1$\r", "+\t\t\tcase IClasspathEntry.CPE_PROJECT :\r", "+\t\t\t\treturn \"[PRJ]\"+this.path;  //$NON-NLS-1$\r", "+\t\t\tcase IClasspathEntry.CPE_SOURCE :\r", "+\t\t\t\treturn \"[SRC]\"+this.path;  //$NON-NLS-1$\r", "+\t\t\tcase IClasspathEntry.CPE_VARIABLE :\r", "+\t\t\t\treturn \"[VAR]\"+this.path;  //$NON-NLS-1$\r", "+\t\t}\r", "+\t\treturn \"\";  //$NON-NLS-1$\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39021bfbe705c332900bee6d68fc0d6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "  \tpublic static boolean resolvePolyExpressionArguments(BlockScope scope, MethodBinding methodBinding, Expression [] arguments, TypeBinding[] argumentTypes)", "signatureAfterChange": " \tpublic static boolean resolvePolyExpressionArguments(Invocation invocation, BlockScope scope, MethodBinding methodBinding, TypeBinding[] argumentTypes)", "diff": ["-\tpublic static boolean resolvePolyExpressionArguments(BlockScope scope, MethodBinding methodBinding, Expression [] arguments, TypeBinding[] argumentTypes) {", "-\t\tboolean polyExpressionsHaveErrors = false;", "+\t */", "+\tpublic static boolean resolvePolyExpressionArguments(Invocation invocation, BlockScope scope, MethodBinding methodBinding, TypeBinding[] argumentTypes) {", "+\t\tint problemReason = 0;", "+\t\t\tproblemReason = methodBinding.problemId();", "+\t\tboolean hasUpdatedInner = false;", "+\t\t\tExpression [] arguments = invocation.arguments();", "-\t\t\t\tif (argumentTypes[i] instanceof PolyTypeBinding) {", "-\t\t\t\t\tExpression argument = arguments[i];", "-\t\t\t\t\tTypeBinding parameterType = i < parametersLength ? parameters[i] : variableArity ? parameters[parametersLength - 1] : null;", "-\t\t\t\t\targument.setExpressionContext(parameterType != null ? ExpressionContext.INVOCATION_CONTEXT: ExpressionContext.ASSIGNMENT_CONTEXT); // force the errors to surface.", "-\t\t\t\t\tif (variableArity && i >= parametersLength - 1)", "-\t\t\t\t\t\targument.tagAsEllipsisArgument();", "-\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\tTypeBinding argumentType = argument.resolveType(scope);", "-\t\t\t\t\tif (argumentType == null || !argumentType.isValidBinding())", "-\t\t\t\t\t\tpolyExpressionsHaveErrors = true;", "-\t\t\t\t\tif (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())", "-\t\t\t\t\t\tpolyExpressionsHaveErrors = true;", "+\t\t\t\tExpression argument = arguments[i];", "+\t\t\t\tTypeBinding parameterType = i < parametersLength ? parameters[i] : variableArity ? parameters[parametersLength - 1] : null;", "+\t\t\t\tTypeBinding updatedArgumentType = null;", "+", "+\t\t\t\tif (variableArity && i >= parametersLength - 1)", "+\t\t\t\t\targument.tagAsEllipsisArgument();", "+\t\t\t\tupdatedArgumentType = updateExpression(scope, argument, argumentTypes[i], parameterType, invocation.hasInferenceFinished());", "+\t\t\t\tif (updatedArgumentType == POLY_ERROR) //$IDENTITY-COMPARISON$", "+\t\t\t\t\tcontinue; // don't update if inner poly has errors", "+\t\t\t\tif (problemReason != ProblemReasons.Ambiguous \t// preserve this error", "+\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "+\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding)", "+\t\t\t\t\t\t&& TypeBinding.notEquals(updatedArgumentType, argumentTypes[i]))", "+\t\t\t\t{", "+\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "+\t\t\t\t\t// in order to give better information into a second round of method lookup:", "+\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "+\t\t\t\t\thasUpdatedInner = true;", "-\t\treturn polyExpressionsHaveErrors;", "+\t\treturn hasUpdatedInner;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ccb8a4bb768e79cc7924297fdbec8a5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "8d1d658761d5e634e1f9986cdb54c46ecd8cbc2e", "commitAfterChange": "f4d9deb41a71301595419326392826169e31b674", "methodNumberBeforeChange": 61, "methodNumberAfterChange": 61, "signatureBeforeChange": "  \tprotected boolean isAcceptableMethod(MethodBinding one, MethodBinding two)", "signatureAfterChange": "  \tprotected boolean isAcceptableMethod(MethodBinding one, MethodBinding two)", "diff": ["-\t\t\tfor (int i = 0; i < oneParamsLength; i++) {", "+\t\t\tnext : for (int i = 0; i < oneParamsLength; i++) {", "-\t\t\t\tif (oneParam == twoParam) {", "-\t\t\t\t\tif (twoParam.leafComponentType().isRawType()) {", "-\t\t\t\t\t\t// must detect & reject this case", "-\t\t\t\t\t\t// when Y<U> extends X<U>", "-\t\t\t\t\t\t// void foo(Y y) {}", "-\t\t\t\t\t\t// <T extends X<Object>> void foo(T t) {}", "-\t\t\t\t\t\t// foo(T) will show up as foo(Y#RAW) and not foo(X#RAW)", "-\t\t\t\t\t\t// Y#RAW is not more specific than a rawified X<T>", "-\t\t\t\t\t\tTypeBinding originalOneParam = one.original().parameters[i].leafComponentType();", "-\t\t\t\t\t\tif ((originalOneParam.isTypeVariable() ? ((TypeVariableBinding) originalOneParam).upperBound()", "-\t\t\t\t\t\t\t\t: originalOneParam).isRawType())", "-\t\t\t\t\t\t\tif (twoParam.leafComponentType().erasure() != two.original().parameters[i]", "-\t\t\t\t\t\t\t\t\t.leafComponentType().erasure())", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (oneParam.isCompatibleWith(twoParam)) {", "-\t\t\t\t\tif (oneParam.leafComponentType().isRawType()) {", "-\t\t\t\t\t\tif (oneParam.needsUncheckedConversion(twoParam))", "-\t\t\t\t\t\t\tif (oneParam.leafComponentType().erasure() != twoParam.leafComponentType().erasure())", "-\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\tif (oneParam == twoParam || oneParam.isCompatibleWith(twoParam)) {", "+\t\t\t\t\tif (two.declaringClass.isRawType()) continue next;", "+", "+\t\t\t\t\tTypeBinding originalOneParam = one.original().parameters[i].leafComponentType();", "+\t\t\t\t\tswitch (originalOneParam.kind()) {", "+\t\t\t\t\t   \tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t   \t\tif (!((TypeVariableBinding) originalOneParam).upperBound().isRawType()) break;", "+\t\t\t\t\t   \t\t//$FALL-THROUGH$", "+\t\t\t\t\t   \tcase Binding.RAW_TYPE:", "+\t\t\t\t\t   \t\t// originalOneParam is RAW so it cannot be more specific than a wildcard or parameterized type", "+\t\t\t\t\t\t\tTypeBinding originalTwoParam = two.original().parameters[i].leafComponentType();", "+\t\t\t\t\t\t\tswitch (originalTwoParam.kind()) {", "+\t\t\t\t\t\t\t   \tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\t\t\t   \t\tif (((TypeVariableBinding) originalTwoParam).hasOnlyRawBounds())", "+\t\t\t\t\t\t\t\t   \t\tcontinue next;", "+\t\t\t\t\t\t\t\t   \treturn false;", "+\t\t\t\t\t\t\t   \tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\t\t\t   \tcase Binding.INTERSECTION_TYPE:", "+\t\t\t\t\t\t\t   \tcase Binding.PARAMETERIZED_TYPE :", "+\t\t\t\t\t\t\t   \t\treturn false;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn true; // special case to choose between 2 varargs methods when the last arg is", "-\t\t\t\t\t\t\t\t\t\t\t// Object[]", "+\t\t\t\t\t\t\treturn true; // special case to choose between 2 varargs methods when the last arg is Object[]", "-\t\t\t\t// special case when autoboxing makes (int, int...) better than (Object...) but not (int...) or", "-\t\t\t\t// (Integer, int...)", "+\t\t\t\t// special case when autoboxing makes (int, int...) better than (Object...) but not (int...) or (Integer, int...)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5074d67bf77f94d55b9147d053a9431c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "3ec169b44d3736817b7c4ce9bf1791fcda57b692", "commitAfterChange": "4a83e27deea774790864c829cd5109d435b50edd", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 28, "signatureBeforeChange": " public boolean isProvablyDistinctFrom(TypeBinding otherType)", "signatureAfterChange": " public boolean isProvablyDistinctFrom(TypeBinding otherType)", "diff": ["-\tif (this.isTypeVariable()) return false;", "-\tif (this.isWildcard()) return false;", "-\tif (otherType.isTypeVariable()) return false;", "-\tif (otherType.isWildcard()) return false;", "-\tif (this.isParameterizedType()) {", "-\t\tParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) this;", "-\t\tif (parameterizedType.type.isProvablyDistinctFrom(otherType.erasure())) return true;", "-\t\tif (otherType.isGenericType()) return false;", "-\t\tif (otherType.isRawType()) return false;", "-\t\tif (otherType.isParameterizedType()) {", "-\t\t\tTypeBinding[] arguments = parameterizedType.arguments;", "-\t\t\tif (arguments == null) return false;", "-\t\t\tParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherType;", "-\t\t\tTypeBinding[] otherArguments = otherParameterizedType. arguments;", "-\t\t\tif (otherArguments == null) return false;", "-\t\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "-\t\t\t\tif (arguments[i].isProvablyDistinctFrom(otherArguments[i])) return true;", "-\t\t\t}", "+\tswitch (otherType.bindingType()) {", "+\t\tcase Binding.TYPE_PARAMETER :", "+\t\tcase Binding.WILDCARD_TYPE :", "-\t\t}", "-\t} else if (this.isRawType()) {", "-\t\treturn this.erasure().isProvablyDistinctFrom(otherType.erasure());", "-\t} else if (this.isGenericType()) {", "-\t\treturn this != otherType.erasure();", "+\t}", "+\tswitch(bindingType()) {", "+\t\t", "+\t\tcase Binding.TYPE_PARAMETER :", "+\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\treturn false;", "+\t\t\t", "+\t\tcase Binding.PARAMETERIZED_TYPE :", "+\t\t\tParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) this;", "+\t\t\tif (parameterizedType.type.isProvablyDistinctFrom(otherType.erasure())) return true;", "+\t\t\tswitch (otherType.bindingType()) {", "+\t\t\t\tcase Binding.GENERIC_TYPE :", "+\t\t\t\tcase Binding.RAW_TYPE :", "+\t\t\t\t\treturn false;", "+\t\t\t\tcase Binding.PARAMETERIZED_TYPE :", "+\t\t\t\t\tTypeBinding[] arguments = parameterizedType.arguments;", "+\t\t\t\t\tif (arguments == null) return false;", "+\t\t\t\t\tParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherType;", "+\t\t\t\t\tTypeBinding[] otherArguments = otherParameterizedType. arguments;", "+\t\t\t\t\tif (otherArguments == null) return false;", "+\t\t\t\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "+\t\t\t\t\t\tif (arguments[i].isProvablyDistinctFrom(otherArguments[i])) return true;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn false;", "+\t\t\t\t\t", "+\t\t\t}", "+\t\t\tbreak;", "+", "+\t\tcase Binding.RAW_TYPE :", "+\t\t\treturn this.erasure().isProvablyDistinctFrom(otherType.erasure());", "+\t\t\t", "+\t\tcase Binding.GENERIC_TYPE :", "+\t\t\treturn this != otherType.erasure();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "866a96d7113fec092ce0b82e46c3f687", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "d1adb49c37ffedded033367d49226373a027a74a", "commitAfterChange": "bb78eb5668b505d8cc58cdf0f1742d5d5430764d", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " public boolean isTypeArgumentIntersecting(TypeBinding otherArgument)", "signatureAfterChange": " public boolean isTypeArgumentIntersecting(TypeBinding otherArgument)", "diff": ["-\tif (this.isTypeVariable() || otherArgument.isTypeVariable())", "-\t\treturn true;", "-\tif (this.isWildcard()) {", "-\t\tif (!otherArgument.isWildcard()) {", "-\t\t\tWildcardBinding wildcard = (WildcardBinding) this;", "-\t\t\tswitch(wildcard.boundKind) {", "-\t\t\t\tcase Wildcard.EXTENDS :", "-\t\t\t\t\treturn otherArgument.isCompatibleWith(wildcard.bound);", "-\t\t\t\tcase Wildcard. SUPER :", "-\t\t\t\t\treturn wildcard.bound.isCompatibleWith(otherArgument);", "-\t\t\t\tcase Wildcard.UNBOUND :", "-\t\t\t\tdefault:", "-\t\t\t\t\treturn true;", "-\t\t\t}", "-\t\t}", "-\t} else if (otherArgument.isWildcard()) {", "-\t\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "-\t\tswitch(otherWildcard.boundKind) {", "-\t\t\tcase Wildcard.EXTENDS :", "-\t\t\t\treturn this.isCompatibleWith(otherWildcard.bound);", "-\t\t\tcase Wildcard. SUPER :", "-\t\t\t\treturn otherWildcard.bound.isCompatibleWith(this);", "-\t\t\tcase Wildcard.UNBOUND :", "-\t\t\tdefault:", "-\t\t\t\treturn true;", "-\t\t}", "-\t}", "-\tTypeBinding lowerBound1 = null;", "-\tTypeBinding upperBound1 = null;", "-\tWildcardBinding wildcard = (WildcardBinding) this;", "-\tswitch(wildcard.boundKind) {", "-\t\tcase Wildcard.EXTENDS :", "-\t\t\tupperBound1 = wildcard.bound;", "-\t\t\tbreak;", "-\t\tcase Wildcard. SUPER :", "-\t\t\tlowerBound1 = wildcard.bound;", "-\t\t\tbreak;", "-\t\tcase Wildcard.UNBOUND :", "-\t}", "-", "-\tTypeBinding lowerBound2 = null;", "-\tTypeBinding upperBound2 = null;", "-\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "-\tswitch(otherWildcard.boundKind) {", "-\t\tcase Wildcard.EXTENDS :", "-\t\t\tupperBound2 = otherWildcard.bound;", "-\t\t\tbreak;", "-\t\tcase Wildcard. SUPER :", "-\t\t\tlowerBound2 = otherWildcard.bound;", "-\t\t\tbreak;", "-\t\tcase Wildcard.UNBOUND :", "-\t}", "-\tif (lowerBound1 != null) {", "-\t\tif (lowerBound2 != null) {", "-\t\t\treturn true; // Object could always be a candidate", "+\tswitch (kind()) {", "+\t\t", "+\t\t// TYPE_PARAM & ANY TYPE", "+\t\tcase Binding.TYPE_PARAMETER :   ", "+\t\t\treturn true;", "-\t\t} else if (upperBound2 != null) {", "-\t\t\treturn lowerBound1.isCompatibleWith(upperBound2);", "-\t\t} else {", "-\t\t\treturn true;", "-\t\t}", "-\t} else if (upperBound1 != null) {", "-\t\tif (lowerBound2 != null) {", "-\t\t\treturn lowerBound2.isCompatibleWith(upperBound1);", "-", "-\t\t} else if (upperBound2 != null) {", "-\t\t\tif (upperBound1.isInterface()) {", "-\t\t\t\tif (upperBound2.isInterface())", "+\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\tswitch (otherArgument.kind()) {", "+\t\t\t\t", "+\t\t\t\t// WILDCARD & TYPE_PARAM", "+\t\t\t\tcase Binding.TYPE_PARAMETER :", "-\t\t\t\tif (upperBound2.isArrayType() || ((upperBound2 instanceof ReferenceBinding) && ((ReferenceBinding)upperBound2).isFinal())) {", "-\t\t\t\t\treturn upperBound2.isCompatibleWith(upperBound1);", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t} else if (upperBound2.isInterface()) {", "-\t\t\t\tif (upperBound1.isArrayType() || ((upperBound1 instanceof ReferenceBinding) && ((ReferenceBinding)upperBound1).isFinal())) {", "-\t\t\t\t\treturn upperBound1.isCompatibleWith(upperBound2);", "-\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t// WILDCARD & WILDCARD", "+\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\tTypeBinding lowerBound1 = null;", "+\t\t\t\t\tTypeBinding upperBound1 = null;", "+\t\t\t\t\tWildcardBinding wildcard = (WildcardBinding) this;", "+\t\t\t\t\tswitch(wildcard.boundKind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\t\t\tupperBound1 = wildcard.bound;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Wildcard. SUPER :", "+\t\t\t\t\t\t\tlowerBound1 = wildcard.bound;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Wildcard.UNBOUND :", "+\t\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t\tTypeBinding lowerBound2 = null;", "+\t\t\t\t\tTypeBinding upperBound2 = null;", "+\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "+\t\t\t\t\tswitch(otherWildcard.boundKind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\t\t\tupperBound2 = otherWildcard.bound;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Wildcard. SUPER :", "+\t\t\t\t\t\t\tlowerBound2 = otherWildcard.bound;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Wildcard.UNBOUND :", "+\t\t\t\t\t}", "+\t\t\t\t\tif (lowerBound1 != null) {", "+\t\t\t\t\t\tif (lowerBound2 != null) {", "+\t\t\t\t\t\t\treturn true; // Object could always be a candidate", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t} else if (upperBound2 != null) {", "+\t\t\t\t\t\t\treturn lowerBound1.isCompatibleWith(upperBound2);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (upperBound1 != null) {", "+\t\t\t\t\t\tif (lowerBound2 != null) {", "+\t\t\t\t\t\t\treturn lowerBound2.isCompatibleWith(upperBound1);", "+\t\t\t\t", "+\t\t\t\t\t\t} else if (upperBound2 != null) {", "+\t\t\t\t\t\t\tif (upperBound1.isInterface()) {", "+\t\t\t\t\t\t\t\tif (upperBound2.isInterface())", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\tif (upperBound2.isArrayType() || ((upperBound2 instanceof ReferenceBinding) && ((ReferenceBinding)upperBound2).isFinal())) {", "+\t\t\t\t\t\t\t\t\treturn upperBound2.isCompatibleWith(upperBound1);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t} else if (upperBound2.isInterface()) {", "+\t\t\t\t\t\t\t\tif (upperBound1.isArrayType() || ((upperBound1 instanceof ReferenceBinding) && ((ReferenceBinding)upperBound1).isFinal())) {", "+\t\t\t\t\t\t\t\t\treturn upperBound1.isCompatibleWith(upperBound2);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t// WILDCARD & OTHER TYPE", "+\t\t\t\tdefault :", "+\t\t\t\t\t wildcard = (WildcardBinding) this;", "+\t\t\t\t\tswitch(wildcard.boundKind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\t\t\treturn otherArgument.isCompatibleWith(wildcard.bound);", "+\t\t\t\t\t\tcase Wildcard. SUPER :", "+\t\t\t\t\t\t\treturn wildcard.bound.isCompatibleWith(otherArgument);", "+\t\t\t\t\t\tcase Wildcard.UNBOUND :", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "-\t\t\treturn true;", "-\t\t} else {", "-\t\t\treturn true;", "-\t\t}", "-\t} else {", "-\t\treturn true;", "+\t\t\t", "+\t\tdefault:", "+\t\t\tswitch (otherArgument.kind()) {", "+", "+\t\t\t\t// OTHER TYPE & TYPE_PARAM", "+\t\t\t\tcase Binding.TYPE_PARAMETER :", "+\t\t\t\t\treturn true;", "+", "+\t\t\t\t// OTHER TYPE & WILDCARD", "+\t\t\t\tcase Binding.WILDCARD_TYPE :", "+\t\t\t\t\tWildcardBinding otherWildcard = (WildcardBinding) otherArgument;", "+\t\t\t\t\tswitch(otherWildcard.boundKind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS :", "+\t\t\t\t\t\t\treturn this.isCompatibleWith(otherWildcard.bound);", "+\t\t\t\t\t\tcase Wildcard. SUPER :", "+\t\t\t\t\t\t\treturn otherWildcard.bound.isCompatibleWith(this);", "+\t\t\t\t\t\tcase Wildcard.UNBOUND :", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}\t\t\t\t\t", "+", "+\t\t\t\t// OTHER TYPE & OTHER TYPE", "+\t\t\t\tdefault :", "+\t\t\t\t\treturn false;", "+\t\t\t}"]}], "num": 48857}