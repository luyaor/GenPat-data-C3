{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f3eefc2571dd1b707245112a0951a8db", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "072ec975ee1437b59579081e7f3ce583", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "fc2bbd994a305724f9f5d9645163d8f7329cd965", "commitAfterChange": "340d76460697d1d853431b9a4e8d18df2a5632b9", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tFlowInfo conditionFlowInfo;", "-\t\t\tif (this.receiver.resolvedType != null ", "-\t\t\t\t\t&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert", "-\t\t\t\t\t&& argument.resolvedType != null", "-\t\t\t\t\t&& argument.resolvedType.id == TypeIds.T_boolean) {", "-\t\t\t\tConstant cst = argument.optimizedBooleanConstant();", "-\t\t\t\tboolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\t\t\tboolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-\t\t\t\tflowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;", "-\t\t\t\tconditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());", "-\t\t\t\tif (!wasInsideAssert) {", "-\t\t\t\t\tflowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;", "-\t\t\t\t}", "-\t\t\t\tUnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();", "-\t\t\t\tFlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();", "-\t\t\t\tif (isOptimizedTrueAssertion) {", "-\t\t\t\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "-\t\t\t\tif (!isOptimizedFalseAssertion) {", "-\t\t\t\t\t// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.", "-\t\t\t\t\t// if the code does reach ahead, it means the assert didn't cause an exit, and so", "-\t\t\t\t\t// the expression inside it shouldn't change the prior flowinfo", "-\t\t\t\t\t// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)", "-\t\t\t\t\t", "-\t\t\t\t\t// keep the merge from the initial code for the definite assignment", "-\t\t\t\t\t// analysis, tweak the null part to influence nulls downstream", "-\t\t\t\t\tflowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "-\t\t\t\t\t\taddInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tflowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\t\t\tswitch (detectAssertionUtility(i)) {", "+\t\t\t\tcase TRUE_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FALSE_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, false);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase NONNULL_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, false);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase NULL_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, true);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tflowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "891e8c424ea4e89ca1cb53efd4bed4ba", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "071f59f477be631666f24420ca0aab156c270c65", "commitAfterChange": "986a6d11b1b7e4db82dd5d830210e01550f74aa3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tFlowInfo conditionFlowInfo;", "-\t\t\tif (this.receiver.resolvedType != null ", "-\t\t\t\t\t&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert", "-\t\t\t\t\t&& argument.resolvedType != null", "-\t\t\t\t\t&& argument.resolvedType.id == TypeIds.T_boolean) {", "-\t\t\t\tConstant cst = argument.optimizedBooleanConstant();", "-\t\t\t\tboolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\t\t\tboolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-\t\t\t\tflowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;", "-\t\t\t\tconditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());", "-\t\t\t\tif (!wasInsideAssert) {", "-\t\t\t\t\tflowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;", "-\t\t\t\t}", "-\t\t\t\tUnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();", "-\t\t\t\tFlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();", "-\t\t\t\tif (isOptimizedTrueAssertion) {", "-\t\t\t\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "-\t\t\t\tif (!isOptimizedFalseAssertion) {", "-\t\t\t\t\t// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.", "-\t\t\t\t\t// if the code does reach ahead, it means the assert didn't cause an exit, and so", "-\t\t\t\t\t// the expression inside it shouldn't change the prior flowinfo", "-\t\t\t\t\t// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)", "-\t\t\t\t\t", "-\t\t\t\t\t// keep the merge from the initial code for the definite assignment", "-\t\t\t\t\t// analysis, tweak the null part to influence nulls downstream", "-\t\t\t\t\tflowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "-\t\t\t\t\t\taddInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tflowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\t\t\tswitch (detectAssertionUtility(i)) {", "+\t\t\t\tcase TRUE_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, true);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase FALSE_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseBooleanAssertion(currentScope, argument, flowContext, flowInfo, wasInsideAssert, false);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase NONNULL_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, false);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase NULL_ASSERTION:", "+\t\t\t\t\tflowInfo = analyseNullAssertion(currentScope, argument, flowContext, flowInfo, true);", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tflowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();"]}], "num": 41531}