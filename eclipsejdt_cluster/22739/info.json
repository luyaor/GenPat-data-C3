{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bc5858b375db2c4192601ea60c045be1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e2539d5a154362c5f8836eacb26e521", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "4997f1f5c27828dc6733e1f0cda3081f9d59b298", "commitAfterChange": "c454077fd72f14a026b898d3b50aaf59d2a0517c", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": " \tprivate BoundSet resolve(InferenceVariable[] toResolve) throws InferenceFailureException", "signatureAfterChange": " \tprivate BoundSet resolve(InferenceVariable[] toResolve) throws InferenceFailureException", "diff": ["+\t\t\t\t\tfinal BoundSet kurrentBoundSet = tmpBoundSet;", "+\t\t\t\t\t\t\t/* If we have an instantiation, lower it to the instantiation. We don't want downstream abstractions to be confused about multiple versions of bounds without", "+\t\t\t\t\t\t\t   and with instantiations propagated by incorporation. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=430686. There is no value whatsoever in continuing", "+\t\t\t\t\t\t\t   to speak in two tongues. Also fixes https://bugs.eclipse.org/bugs/show_bug.cgi?id=425031.", "+\t\t\t\t\t\t\t*/", "+\t\t\t\t\t\t\tif (typeVariable instanceof InferenceVariable) {", "+\t\t\t\t\t\t\t\tInferenceVariable inferenceVariable = (InferenceVariable) typeVariable;", "+\t\t\t\t\t\t\t\tTypeBinding instantiation = kurrentBoundSet.getInstantiation(inferenceVariable, null);", "+\t\t\t\t\t\t\t\tif (instantiation != null)", "+\t\t\t\t\t\t\t\t\treturn instantiation;", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tlowerBounds = Scope.substitute(theta, lowerBounds);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4eb541da3de61637975eb45998a7d032", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "644c4d9043a8634631a6c37637807f9484dbb1d4", "commitAfterChange": "fff3d1bb7cd12822df70202db7e6a801aeeb63a2", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": " \tpublic BoundSet solve(boolean inferringApplicability) throws InferenceFailureException", "signatureAfterChange": " \tpublic BoundSet solve(boolean inferringApplicability) throws InferenceFailureException", "diff": ["+", "-\t\treturn resolve(this.inferenceVariables);", "+\t\tBoundSet solution = resolve(this.inferenceVariables);", "+\t\t", "+\t\t/* If inferring applicability make a final pass over the initial constraints preserved as final constraints to make sure they hold true at a macroscopic level.", "+\t\t   See https://bugs.eclipse.org/bugs/show_bug.cgi?id=426537#c55 onwards.", "+\t\t*/", "+\t\tif (inferringApplicability && solution != null && this.finalConstraints != null) {", "+\t\t\tfor (ConstraintExpressionFormula constraint: this.finalConstraints) {", "+\t\t\t\tif (constraint.left.isPolyExpression())", "+\t\t\t\t\tcontinue; // avoid redundant re-inference, inner poly's own constraints get validated in its own context & poly invocation type inference proved compatibility against target. ", "+\t\t\t\tconstraint.applySubstitution(solution, this.inferenceVariables);", "+\t\t\t\tif (!this.currentBounds.reduceOneConstraint(this, constraint)) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn solution;"]}], "num": 22739}