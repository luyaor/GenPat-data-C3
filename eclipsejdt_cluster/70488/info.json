{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6b21f660a671a2fe782b57cb1fcacdc1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23bb42998f8d2d932bd57362196ad54b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java", "commitBeforeChange": "ae317766273ccd74fe0e1bfd1f3ccc3925356a13", "commitAfterChange": "3fc8f68d913a6f6e40f71f3d7dea34c1f2893e07", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static char[] createDeclarationIndexKey( \t\t\tchar[] typeName, \t\t\tchar[] declaringQualification, \t\t\tchar[] methodName, \t\t\tint argCount, \t\t\tchar[] signature, \t\t\tchar[][] parameterTypes, \t\t\tchar[][] parameterNames, \t\t\tchar[] returnType, \t\t\tint modifiers, \t\t\tchar[] packageName, \t\t\tint typeModifiers, \t\t\tint extraFlags)", "signatureAfterChange": " \tpublic static char[] createDeclarationIndexKey( \t\t\tchar[] typeName, \t\t\tchar[] declaringQualification, \t\t\tchar[] methodName, \t\t\tint argCount, \t\t\tchar[] signature, \t\t\tchar[][] parameterTypes, \t\t\tchar[][] parameterNames, \t\t\tchar[] returnType, \t\t\tint modifiers, \t\t\tchar[] packageName, \t\t\tint typeModifiers, \t\t\tint extraFlags)", "diff": ["-\t\tcountChars = argCount < 10 ? COUNTS[argCount]: (\"/\" + String.valueOf(argCount)).toCharArray(); //$NON-NLS-1$", "+\t\tcountChars = argCount < 10 ? new char[] {COUNTS[argCount][1]}:  String.valueOf(argCount).toCharArray(); ", "-\t\t\t", "-\t\tchar[] returnTypeChars = returnType == null ? CharOperation.NO_CHAR : getTypeErasure(returnType);", "-\t\t", "-\t\t", "-\t\tint typeNameLength = typeName == null ? 0 : typeName.length;", "-\t\tint qualifierLength = declaringQualification == null ? 0 : declaringQualification.length;", "-\t\tint methodNameLength = methodName == null ? 0 : methodName.length;", "-\t\tint packageNameLength = packageName == null ? 0 : packageName.length;", "-\t\tint countCharsLength = countChars.length;", "-\t\tint parameterTypesLength = signature == null ? (parameterTypesChars == null ? 0 : parameterTypesChars.length): signature.length;", "-\t\tint parameterNamesLength = parameterNamesChars == null ? 0 : parameterNamesChars.length;", "-\t\tint returnTypeLength = returnTypeChars.length;", "-\t\t", "-\t\tint resultLength = methodNameLength + countCharsLength + qualifierLength + typeNameLength + 2 /* type modifiers */", "-\t\t\t\t+ packageNameLength + parameterTypesLength + parameterNamesLength + returnTypeLength + 2 /* modifiers*/ + 9; // SEPARATOR = 9", "-\t\tchar[] result = new char[resultLength];", "-\t\t", "-\t\tint pos = 0;", "-\t\tif (methodNameLength > 0) {", "-\t\t\tSystem.arraycopy(methodName, 0, result, pos, methodNameLength);", "-\t\t\tpos += methodNameLength;", "-\t\t}", "-\t\tif (countCharsLength > 0) {", "-\t\t\tSystem.arraycopy(countChars, 0, result, pos, countCharsLength);", "-\t\t\tpos += countCharsLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tif (qualifierLength > 0) {", "-\t\t\tSystem.arraycopy(declaringQualification, 0, result, pos, qualifierLength);", "-\t\t\tpos += qualifierLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-", "-\t\tif (typeNameLength > 0) {", "-\t\t\tSystem.arraycopy(typeName, 0, result, pos, typeNameLength);", "-\t\t\tpos += typeNameLength;", "-\t\t}", "-", "-\t\t", "+\t\tchar[] returnTypeChars = returnType == null ? CharOperation.NO_CHAR : getTypeErasure(returnType);\t\t", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tresult[pos++] = (char) typeModifiersWithExtraFlags;", "-\t\tresult[pos++] = (char) (typeModifiersWithExtraFlags>>16);", "+\t\tint entryIndex = 0;", "+\t\tint numEntries = 10;", "+\t\tchar [][] tmp = new char[numEntries][];", "-\t\tresult[pos++] = SEPARATOR;", "-\t\tif (packageNameLength > 0) {", "-\t\t\tSystem.arraycopy(packageName, 0, result, pos, packageNameLength);", "-\t\t\tpos += packageNameLength;", "-\t\t}", "+\t\ttmp[entryIndex++] = methodName != null ? methodName : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = countChars;", "+\t\ttmp[entryIndex++] = declaringQualification != null ? declaringQualification : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = typeName != null ? typeName : CharOperation.NO_CHAR;", "+\t\ttmp[entryIndex++] = new char[] {(char) typeModifiersWithExtraFlags, (char) (typeModifiersWithExtraFlags>>16)};", "+\t\ttmp[entryIndex++] = packageName != null ? packageName : CharOperation.NO_CHAR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tresult[pos++] = SEPARATOR;", "+\t\t\ttmp[entryIndex++] = CharOperation.NO_CHAR;", "+\t\t\ttmp[entryIndex++] = CharOperation.NO_CHAR;", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tif (parameterTypesLength > 0) {", "-\t\t\t\tif (signature == null) {", "-\t\t\t\t\tSystem.arraycopy(parameterTypesChars, 0, result, pos, parameterTypesLength);", "-\t\t\t\t} else {", "-\t\t\t\t\tSystem.arraycopy(CharOperation.replaceOnCopy(signature, SEPARATOR, '\\\\'), 0, result, pos, parameterTypesLength);", "-\t\t\t\t}", "-\t\t\t\tpos += parameterTypesLength;", "-\t\t\t}", "-\t\t\t", "-\t\t\tresult[pos++] = SEPARATOR;", "-\t\t\tif (parameterNamesLength > 0) {", "-\t\t\t\tSystem.arraycopy(parameterNamesChars, 0, result, pos, parameterNamesLength);", "-\t\t\t\tpos += parameterNamesLength;", "-\t\t\t}", "-\t\t\t", "-\t\t\tresult[pos++] = SEPARATOR;", "+\t\t\ttmp[entryIndex++] = signature != null ? CharOperation.replaceOnCopy(signature, SEPARATOR, '\\\\') : parameterTypesChars != null ? parameterTypesChars  : CharOperation.NO_CHAR;", "+\t\t\ttmp[entryIndex++] = parameterNamesChars != null ? parameterNamesChars : CharOperation.NO_CHAR;", "-\t\tresult[pos++] = (char) modifiers;", "-\t\tresult[pos++] = (char) (modifiers>>16);", "-\t\tresult[pos++] = SEPARATOR;", "-", "-\t\tif (returnTypeLength > 0) {", "-\t\t\tSystem.arraycopy(returnTypeChars, 0, result, pos, returnTypeLength);", "-\t\t\tpos += returnTypeLength;", "-\t\t}", "-\t\tresult[pos++] = SEPARATOR;", "-\t\treturn result;", "+\t\ttmp[entryIndex++] = new char[] {(char) modifiers, (char) (modifiers>>16)};", "+\t\ttmp[entryIndex] = returnTypeChars;", "+\t\treturn CharOperation.concatWithAll(tmp, '/');"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbfdaf397c7dab5715c8e17c48e046cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/AndPattern.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " protected void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor, char[] queryKey, char[] category) throws IOException", "signatureAfterChange": " public void findIndexMatches(Index index, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException", "diff": ["- */", "-protected void findIndexMatches(IndexInput input, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor, char[] queryKey, char[] category) throws IOException {", "-", "+public void findIndexMatches(Index index, IndexQueryRequestor requestor, SearchParticipant participant, IJavaSearchScope scope, IProgressMonitor progressMonitor) throws IOException {", "-\t", "-\t/* narrow down a set of entries using prefix criteria */", "-\tlong[] possibleRefs = null;", "-\tint maxRefs = -1;", "+", "-\tdo {", "-\t\tqueryKey = encodeIndexKey();", "-\t\tchar[] pattern = CharOperation.concat(category, queryKey);", "-\t\tEntryResult[] entries = input.queryEntries(pattern, SearchPattern.R_PREFIX_MATCH);", "-\t\tif (entries == null) break;", "+\tSimpleSet intersectedNames = null;", "+\ttry {", "+\t\tindex.startQuery();", "+\t\tdo {", "+\t\t\tSearchPattern pattern = currentPattern();", "+\t\t\tEntryResult[] entries = pattern.queryIn(index);", "+\t\t\tif (entries == null) return;", "-\t\tint numFiles = input.getNumFiles();", "-\t\tlong[] references = null;", "-\t\tint referencesLength = -1;", "-\t\tfor (int i = 0, max = entries.length; i < max; i++) {", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "+\t\t\tSearchPattern decodedResult = pattern.getBlankPattern();", "+\t\t\tSimpleSet newIntersectedNames = new SimpleSet();", "+\t\t\tfor (int i = 0, l = entries.length; i < l; i++) {", "+\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "-\t\t\t/* retrieve and decode entry */\t", "-\t\t\tEntryResult entry = entries[i];", "-\t\t\tchar[] word = entry.getWord();", "-\t\t\tchar[] indexKey = CharOperation.subarray(word, category.length, word.length);", "-\t\t\tSearchPattern decodedPattern = getBlankPattern();", "-\t\t\tdecodedPattern.decodeIndexKey(indexKey);", "-\t\t\tif (matchesDecodedPattern(decodedPattern)) {", "-\t\t\t\t/* accumulate references in an array of bits : 1 if the reference is present, 0 otherwise */", "-\t\t\t\tint[] fileReferences = entry.getFileReferences();", "-\t\t\t\tfor (int j = 0, refLength = fileReferences.length; j < refLength; j++) {", "-\t\t\t\t\tint fileReference = fileReferences[j];", "-\t\t\t\t\tint vectorIndex = fileReference / 64; // a long has 64 bits", "-\t\t\t\t\tif (references == null) {", "-\t\t\t\t\t\treferencesLength = (numFiles / 64) + 1;", "-\t\t\t\t\t\treferences = new long[referencesLength];", "-\t\t\t\t\t}", "-\t\t\t\t\tlong mask = 1L << (fileReference % 64);", "-\t\t\t\t\treferences[vectorIndex] |= mask;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t/* only select entries which actually match the entire search pattern */", "-\t\tif (references == null) return;", "-\t\tif (possibleRefs == null) {", "-\t\t\t/* first query : these are the possible references */", "-\t\t\tpossibleRefs = references;", "-\t\t\tmaxRefs = numFiles;", "-\t\t} else {", "-\t\t\t/* eliminate possible references that don't match the current references */", "-\t\t\tint possibleLength = possibleRefs.length;", "-\t\t\tfor (int i = 0, length = references.length; i < length; i++) {", "-\t\t\t\tif (i < possibleLength)", "-\t\t\t\t\tpossibleRefs[i] &= references[i];", "-\t\t\t\telse", "-\t\t\t\t\tpossibleRefs[i] = 0;", "-\t\t\t}", "-\t\t\t// check to see that there are still possible references after the merge", "-\t\t\twhile (--possibleLength >= 0 && possibleRefs[possibleLength] == 0);", "-\t\t\tif (possibleLength == -1) return;", "-\t\t}", "-\t} while (this.hasNextQuery());", "-", "-\t/* report possible references that remain */", "-\tif (possibleRefs != null) {", "-\t\tint[] refs = new int[maxRefs];", "-\t\tint refsLength = 0;", "-\t\tfor (int reference = 1; reference <= maxRefs; reference++) {", "-\t\t\tint vectorIndex = reference / 64; // a long has 64 bits", "-\t\t\tif ((possibleRefs[vectorIndex] & (1L << (reference % 64))) != 0)", "-\t\t\t\trefs[refsLength++] = reference;", "-\t\t}", "-\t\tSystem.arraycopy(refs, 0, refs = new int[refsLength], 0, refsLength);", "-\t\tfor (int i = 0; i < refsLength; i++) { // TODO (jerome) merge with previous loop", "-\t\t\tint reference = refs[i];", "-\t\t\tif (reference != -1) { // if the reference has not been eliminated", "-\t\t\t\tIndexedFile file = input.getIndexedFile(reference);", "-\t\t\t\tif (file != null) {", "-\t\t\t\t\tString documentPath = IndexedFile.convertPath(file.getPath());", "-\t\t\t\t\tif (scope.encloses(documentPath)) {", "-\t\t\t\t\t\tif (!requestor.acceptIndexMatch(documentPath, null, participant)) // AndPatterns cannot provide the decoded pattern ", "-\t\t\t\t\t\t\tthrow new OperationCanceledException();", "+\t\t\t\tEntryResult entry = entries[i];", "+\t\t\t\tdecodedResult.decodeIndexKey(entry.getWord());", "+\t\t\t\tif (pattern.matchesDecodedKey(decodedResult)) {", "+\t\t\t\t\tString[] names = entry.getDocumentNames(index);", "+\t\t\t\t\tif (intersectedNames != null) {", "+\t\t\t\t\t\tfor (int j = 0, n = names.length; j < n; j++)", "+\t\t\t\t\t\t\tif (intersectedNames.includes(names[j]))", "+\t\t\t\t\t\t\t\tnewIntersectedNames.add(names[j]);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int j = 0, n = names.length; j < n; j++)", "+\t\t\t\t\t\t\tnewIntersectedNames.add(names[j]);", "-\t\t}", "+", "+\t\t\tif (newIntersectedNames.elementSize == 0) return;", "+\t\t\tintersectedNames = newIntersectedNames;", "+\t\t} while (this.hasNextQuery());", "+\t} finally {", "+\t\tindex.stopQuery();", "+\tif (intersectedNames == null) return;", "+", "+\tObject[] names = intersectedNames.values;", "+\tfor (int i = 0, l = names.length; i < l; i++)", "+\t\tif (names[i] != null)", "+\t\t\tacceptMatch((String) names[i], null, requestor, participant, scope); // AndPatterns cannot provide the decoded result"]}], "num": 70488}