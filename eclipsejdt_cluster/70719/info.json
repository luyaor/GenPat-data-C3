{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8f5deed21bd97cc09735f56511d445ff", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c7a75f784730a40df50ed6ccea3469b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " void checkInheritedMethods(MethodBinding[] methods, int length)", "diff": ["+// 8.4.8.4", "-\tint count = length;", "-\tint[] skip = new int[count];", "-\tnextMethod : for (int i = 0, l = length - 1; i < l; i++) {", "-\t\tif (skip[i] == -1) continue nextMethod;", "-\t\tMethodBinding method = methods[i];", "-\t\tMethodBinding[] duplicates = null;", "-\t\tfor (int j = i + 1; j <= l; j++) {", "-\t\t\tMethodBinding method2 = methods[j];", "-\t\t\tif (method.declaringClass == method2.declaringClass && areMethodsCompatible(method, method2)) {", "-\t\t\t\tskip[j] = -1;", "-\t\t\t\tif (duplicates == null)", "-\t\t\t\t\tduplicates = new MethodBinding[length];", "-\t\t\t\tduplicates[j] = method2;", "+\tboolean continueInvestigation = true;", "+\tMethodBinding concreteMethod = null;", "+\tfor (int i = 0; i < length; i++) {", "+\t\tif (!methods[i].isAbstract()) {", "+\t\t\tif (concreteMethod != null) {", "+\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);", "+\t\t\t\tcontinueInvestigation = false;", "-\t\t}", "-\t\tif (duplicates != null) {", "-\t\t\t// found an inherited ParameterizedType that defines duplicate methods", "-\t\t\t// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates", "-\t\t\t// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error", "-\t\t\tint concreteCount = method.isAbstract() ? 0 : 1;", "-\t\t\tMethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method", "-\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\tif (!duplicates[m].isAbstract()) {", "-\t\t\t\t\t\tmethodToKeep = duplicates[m];", "-\t\t\t\t\t\tconcreteCount++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (concreteCount != 1) {", "-\t\t\t\tfor (int m = 0, s = duplicates.length; m < s; m++) {", "-\t\t\t\t\tif (duplicates[m] != null) {", "-\t\t\t\t\t\tproblemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tif (methodToKeep == duplicates[m])", "-\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tmethods[m] = null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tconcreteMethod = methods[i];", "-\tif (count < length) {", "-\t\tif (count == 1) return; // no need to continue since only 1 inherited method is left", "-\t\tMethodBinding[] newMethods = new MethodBinding[count];", "-\t\tfor (int i = length; --i >= 0;)", "-\t\t\tif (methods[i] != null)", "-\t\t\t\tnewMethods[--count] = methods[i];", "-\t\tmethods = newMethods;", "-\t\tlength = newMethods.length;", "+\tif (continueInvestigation) {", "+\t\tsuper.checkInheritedMethods(methods, length);", "-", "-\tsuper.checkInheritedMethods(methods, length);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5ed19a34a9f7bd4dd34da5d00076099", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java", "commitBeforeChange": "13b3d93ad06f327dd1b71c8b4a9dd41c3f6dfa1e", "commitAfterChange": "21b9b0f5640cfb80f180c2faa0f4171ca50a57f3", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 53, "signatureBeforeChange": "  public void testDenseCycleDetection() throws CoreException", "signatureAfterChange": " public void testDenseCycleDetection() throws CoreException", "diff": ["-", "+\tdenseCycleDetection(5);", "+\tdenseCycleDetection(10);", "+\tdenseCycleDetection(20);", "+\t//denseCycleDetection(100);", "+}", "-\tint max = 10;", "-\tIJavaProject[] projects = new IJavaProject[max];", "-\tint[] allProjectsInCycle = new int[max];", "-\t\tfor (int i = 0; i < max; i++){", "-\t\tfor (int i = 0; i < max; i++){", "-\t\t\tIClasspathEntry[] extraEntries = new IClasspathEntry[max-1];", "-\t\t\tfor (int j = 0; j < max; j++){", "-\t\tSystem.out.println(\"Dense cycle check (\"+max+\" participants) : \"+ (System.currentTimeMillis()-start)+\" ms\");", "-\t\tfor (int i = 0; i < max; i++){", "-\t\t\tfor (int i = 0; i < max; i++){"]}], "num": 70719}