{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e3747c53afca39d07c34e0c0575f26f6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a02f2f4f3ab85ea33c5c7d9d81e9a98", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/FilerImpl.java", "commitBeforeChange": "9b9b413c1fc3e1733988a3ceecffb87b92306bbd", "commitAfterChange": "afdd923f425377ac0a0c68fd300457070eaabf3e", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "signatureAfterChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "diff": ["+    \t", "+    \t// If we're reconciling, we do not want to actually create the text file", "+    \tif (_env.getPhase() == Phase.RECONCILE) {", "+    \t\treturn new NoOpPrintWriter();", "+    \t}", "+    \t", "-        return charsetName == null ? new RefreshingPrintWriter( path, _env.getProject() ) : ", "-        \tnew RefreshingPrintWriter( path, _env.getProject(), charsetName );", "+    \tIFile file = _env.getProject().getFile(path);", "+    \tOutputStream binaryOut = new BinaryFileOutputStream(file);", "+ ", "+    \tif (charsetName == null) {", "+    \t\treturn new PrintWriter(binaryOut);", "+    \t}", "+    \telse {", "+    \t\tOutputStreamWriter outWriter = new OutputStreamWriter(binaryOut, charsetName);", "+    \t\treturn new PrintWriter(outWriter);", "+    \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2b0244adb7502a3214966196496babca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "763e42ee77f843bf78751f85365c5a74eb47696c", "commitAfterChange": "525a282931680472e1c4e0ea3a9d163e6052ec36", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": "\r \tpublic IPackageFragmentRoot[] getPackageFragmentRoots(IClasspathEntry entry)", "signatureAfterChange": "\r \tpublic IPackageFragmentRoot[] getPackageFragmentRoots(IClasspathEntry entry)", "diff": ["-\t\tif (entry.getContentKind() == IPackageFragmentRoot.K_BINARY) {\r", "-\t\t\tString ext= path.getFileExtension();\r", "+\t\tString ext= path.getFileExtension();\r", "+\t\tif (ext != null && entry.getContentKind() == IPackageFragmentRoot.K_BINARY) {\r", "-\t\t\tif (ext != null && (ext.equalsIgnoreCase(\"zip\") || ext.equalsIgnoreCase(\"jar\"))) { //$NON-NLS-1$ //$NON-NLS-2$\r", "+\t\t\tif (ext.equalsIgnoreCase(\"zip\") || ext.equalsIgnoreCase(\"jar\")) { //$NON-NLS-1$ //$NON-NLS-2$\r", "-\t\t}\r", "+\t\t} \r", "-\t\t\tif (path.segmentCount() != 1)\r", "-\t\t\t\treturn new IPackageFragmentRoot[] {}; // invalid path for a project\r", "-\t\t\tString project= path.segment(0);\r", "-\t\t\tIJavaProject javaProject= getJavaModel().getJavaProject(project);\r", "-\t\t\tVector sourceRoots= new Vector();\r", "-\t\t\tIPackageFragmentRoot[] roots= null;\r", "-\t\t\ttry {\r", "-\t\t\t\troots= javaProject.getPackageFragmentRoots();\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\treturn new IPackageFragmentRoot[]{};\r", "-\t\t\t}\r", "-\t\t\tfor (int i= 0; i < roots.length; i++) {\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tif (roots[i].getKind() == IPackageFragmentRoot.K_SOURCE) {\r", "-\t\t\t\t\t\tsourceRoots.addElement(roots[i]);\r", "+\t\t\tif (path.segmentCount() != 1) {\r", "+\t\t\t\tif (entry.getContentKind() == IPackageFragmentRoot.K_BINARY) {\r", "+\t\t\t\t\t// binary folder in another project\r", "+\t\t\t\t\tIResource resource= workspaceRoot.getFolder(path);\r", "+\t\t\t\t\tif (resource == null) {\r", "+\t\t\t\t\t\t return new IPackageFragmentRoot[]{};\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tIPackageFragmentRoot root= new PackageFragmentRoot(resource, this);\r", "+\t\t\t\t\t\treturn new IPackageFragmentRoot[] {root};\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t// do nothing if the root does not exist\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\t// invalid path for a project\r", "+\t\t\t\t\treturn new IPackageFragmentRoot[] {}; \r", "-\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tString project= path.segment(0);\r", "+\t\t\t\tIJavaProject javaProject= getJavaModel().getJavaProject(project);\r", "+\t\t\t\tVector sourceRoots= new Vector();\r", "+\t\t\t\tIPackageFragmentRoot[] roots= null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\troots= javaProject.getPackageFragmentRoots();\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\treturn new IPackageFragmentRoot[]{};\r", "+\t\t\t\t}\r", "+\t\t\t\tfor (int i= 0; i < roots.length; i++) {\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tif (roots[i].getKind() == IPackageFragmentRoot.K_SOURCE) {\r", "+\t\t\t\t\t\t\tsourceRoots.addElement(roots[i]);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t// do nothing if the root does not exist\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "-\t\t\tsourceRoots.copyInto(copy);\r", "-\t\t\treturn copy;\r", "+\t\t\t\tsourceRoots.copyInto(copy);\r", "+\t\t\t\treturn copy;\r", "+\t\t\t}\r"]}], "num": 71477}