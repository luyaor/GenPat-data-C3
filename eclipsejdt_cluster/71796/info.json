{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "285de56e2b7919e1d2a73069bcd223bb", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2aa5af6e219586bc36b02b8442784fda", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "e5fda1d929f48b1ed961a5e3c698240a2263aa5e", "commitAfterChange": "492742130581f98e928eea7bd4ac7e448a4c7517", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tif (length <= 1) {", "-\t\treturn true; // no need to continue since only 1 inherited method is left", "-\t}", "-\t// get rid of overriden methods coming from interfaces - if any", "-\tMethodBinding methodsToCheck[] = new MethodBinding[length];\t// must not nullify methods slots in place", "-\tint count = length;", "-\tfor (int i = 0; i < length; i++) {", "-\t\tmethodsToCheck[i] = methods[i];", "-\t}", "-\tfor (int i = 0; i < length; i++) {", "-\t\tMethodBinding existingMethod;", "-\t\tif ((existingMethod = methodsToCheck[i]) != null) {", "-\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\tMethodBinding inheritedMethod;", "-\t\t\t\tif (i != j && (inheritedMethod = methodsToCheck[j]) != null &&", "-\t\t\t\t\t\texistingMethod.declaringClass.implementsInterface(inheritedMethod.declaringClass, true)) {", "-\t\t\t\t\tMethodBinding substitute = computeSubstituteMethod(inheritedMethod, existingMethod);", "-\t\t\t\t\tif (substitute != null && ", "-\t\t\t\t\t\t\tdoesSubstituteMethodOverride(existingMethod, substitute) &&", "-\t\t\t\t\t\t\t(existingMethod.returnType.isCompatibleWith(substitute.returnType) ||", "-\t\t\t\t\t\t\t\t\tisReturnTypeSubstituable(substitute, existingMethod))) {", "-\t\t\t\t\t\tcount--;", "-\t\t\t\t\t\tmethodsToCheck[j] = null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tif (count < length) {", "-\t\tif (count == 1) { ", "-\t\t\treturn true; // no need to continue since only 1 inherited method is left", "-\t\t}", "-\t\tfor (int i = 0, j = 0; j < count; i++) {", "-\t\t\tif (methodsToCheck[i] != null) {", "-\t\t\t\tmethodsToCheck[j++] = methodsToCheck[i];", "-\t\t\t}", "-\t\t}", "-\t\tmethods = methodsToCheck;", "-\t\tlength = count;", "-\t} // else keep methods unchanged for further checks", "-\t\tfor (int j = i; j <= l; j++) {", "+\t\tnextMethod : for (int j = i; j <= l; j++) {", "-\t\t\t\t\t\t\treturn false; // do not complain since the super interface already got blamed", "+\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the super interface already got blamed"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4559517ff211237ccd19b544da7f879", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "5f24b77df8c988e32ccc28fe3aeb291db1631306", "commitAfterChange": "af85fd47bc376f76c0f4a41c13693956408c1a01", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public void finalizeProblems()", "signatureAfterChange": "  public void finalizeProblems()", "diff": ["-\tif (this.suppressWarningsCount == 0) {", "-\t\tif (this.compilationResult.hasErrors()) {", "-\t\t\t// we need to check if we should discard unused locals warnings (336648)", "-\t\t\tint removed = 0;", "-\t\t\tCategorizedProblem[] problems = this.compilationResult.problems;", "-\t\t\tint problemCount = this.compilationResult.problemCount;", "-\t\t\tfor (int i = 0; i < problemCount; i++) {", "-\t\t\t\tCategorizedProblem currentProblem = problems[i];", "-\t\t\t\tif (currentProblem.getID() == IProblem.LocalVariableIsNeverUsed", "-\t\t\t\t\t\t&& currentProblem.isWarning()) {", "-\t\t\t\t\tproblems[i] = null;", "-\t\t\t\t\tremoved++;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// compact remaining problems", "-\t\t\tif (removed > 0) {", "-\t\t\t\tfor (int i = 0, index = 0; i < problemCount; i++) {", "-\t\t\t\t\tCategorizedProblem problem;", "-\t\t\t\t\tif ((problem = problems[i]) != null) {", "-\t\t\t\t\t\tif (i > index) {", "-\t\t\t\t\t\t\tproblems[index++] = problem;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tindex++;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tthis.compilationResult.problemCount -= removed;", "-\t\t\t}", "-\t\t}", "-\t\treturn;", "-\t}", "+\tif (this.suppressWarningsCount == 0) return;", "-\tint remainingErrors = 0;", "-\t\tboolean isError = problem.isError();", "-\t\tif (isError) {", "+\t\tif (problem.isError()) {", "-\t\t\t\tremainingErrors++;", "-\t\t\t\tremainingErrors++;", "-\t\t\tif (start < startSuppress) {", "+\t\t\tif (start < startSuppress) continue nextSuppress;", "+\t\t\tif (end > endSuppress) continue nextSuppress;", "+\t\t\tif (!this.suppressWarningIrritants[iSuppress].isSet(irritant))", "-\t\t\t}", "-\t\t\tif (end > endSuppress) {", "-\t\t\t\tcontinue nextSuppress;", "-\t\t\t}", "-\t\t\tif (!this.suppressWarningIrritants[iSuppress].isSet(irritant)) {", "-\t\t\t\tcontinue nextSuppress;", "-\t\t\t}", "-\t\t\tif (isError) {", "-\t\t\t\tthis.compilationResult.numberOfErrors--;", "-\t\t\t}", "-\t\t}", "-\t\tif (isError) {", "-\t\t\tremainingErrors++;", "-\t\t}", "-\t}", "-\t// we need to check if we should discard unused locals warnings that were not already filtered out (336648)", "-\tif (remainingErrors > 0) {", "-\t\tfor (int i = 0; i < problemCount; i++) {", "-\t\t\tCategorizedProblem problem;", "-\t\t\tif ((problem = problems[i]) != null", "-\t\t\t\t\t&& problem.getID() == IProblem.LocalVariableIsNeverUsed", "-\t\t\t\t\t&& problem.isWarning()) {", "-\t\t\t\tproblems[i] = null;", "-\t\t\t\tremoved++;", "-\t\t\t}"]}], "num": 71796}