{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "56f63d766d21af99f61da80f3bd111ed", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "29d20965290ecc84128883d46cb0e8d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "135399ac7f48d47679e738d0a583e6c95ff87fd6", "commitAfterChange": "092d49846655da2c4e511a256ba551dc4e15c674", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "signatureAfterChange": "\r \tprivate void locateMatches() throws JavaModelException", "diff": ["- */\r", "-private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "-\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "-\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "-\tIBinaryType info;\r", "-\tif (classFile.isOpen()) {\r", "-\t\t// reuse the info from the java model cache\r", "-\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "-\t} else {\r", "-\t\t// create a temporary info\r", "-\t\ttry {\r", "-\t\t\tIJavaElement pkg = classFile.getParent();\r", "-\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "-\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t// class file in a jar\r", "-\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "-\t\t\t\tString classFilePath = \r", "-\t\t\t\t\t(pkgPath.length() > 0) ?\r", "-\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "-\t\t\t\t\t\tclassFile.getElementName();\r", "-\t\t\t\tZipFile zipFile = null;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "-\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "-\t\t\t\t\t\tzipFile,\r", "-\t\t\t\t\t\tclassFilePath);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (zipFile != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tzipFile.close();\r", "-\t\t\t\t\t\t} catch (IOException e) {\r", "-\t\t\t\t\t\t\t// ignore \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// class file in a directory\r", "-\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "-\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "-\t\t\t}\r", "-\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "-\t\t\te.printStackTrace();\r", "-\t\t\treturn;\r", "-\t\t} catch (java.io.IOException e) {\r", "-\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "-\t\t}\r", "-\t\t\r", "-\t}\r", "-\r", "-\t// check class definition\r", "-\tif (this.pattern.matchesBinary(info, null)) {\r", "-\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t}\r", "-\r", "-\tboolean compilationAborted = false;\r", "-\tif (this.pattern.needsResolve) {\r", "-\t\t// resolve\r", "-\t\tBinaryTypeBinding binding = null;\r", "-\t\ttry {\r", "-\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "-\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "-\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "-\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "-\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "-\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "-\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// check methods\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tMethodBinding[] methods = binding.methods();\r", "-\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "-\t\t\t\t\tMethodBinding method = methods[i];\r", "-\t\t\t\t\tif (this.pattern.matches(method)) {\r", "-\t\t\t\t\t\tIMethod methodHandle = \r", "-\t\t\t\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "-\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "-\t\t\t\t\t\t\t);\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\r", "-\t\t\t// check fields\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tFieldBinding[] fields = binding.fields();\r", "-\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "-\t\t\t\t\tFieldBinding field = fields[i];\r", "-\t\t\t\t\tif (this.pattern.matches(field)) {\r", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t} catch (AbortCompilation e) {\r", "-\t\t\tbinding = null;\r", "-\t\t// no need to check binary info if resolve was successful\r", "-\t\tcompilationAborted = binding == null;\r", "-\t\tif (!compilationAborted) return;\r", "-\t// if compilation was aborted it is a problem with the class path: \r", "-\t// report as a potential match if binary info matches the pattern\r", "-\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\r", "-\t// check methods\r", "-\tIBinaryMethod[] methods = info.getMethods();\r", "-\tint length = methods == null ? 0 : methods.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryMethod method = methods[i];\r", "-\t\tif (this.pattern.matchesBinary(method, info)) {\r", "-\t\t\tIMethod methodHandle = \r", "-\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "-\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "-\t\t\t\t);\r", "-\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "-\t// check fields\r", "-\tIBinaryField[] fields = info.getFields();\r", "-\tlength = fields == null ? 0 : fields.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryField field = fields[i];\r", "-\t\tif (this.pattern.matchesBinary(field, info)) {\r", "-\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "-\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "-}\r", "+\t */\r", "+\tprivate void locateMatches() throws JavaModelException {\r", "+\t\t// binding resolution\r", "+\t\tthis.lookupEnvironment.completeTypeBindings();\r", "+\r", "+\t\t// potential match resolution\r", "+\t\tfor (this.potentialMatchesIndex = 0;\r", "+\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "+\t\t\tthis.potentialMatchesIndex++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tPotentialMatch potentialMatch =\r", "+\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "+\t\t\t\tpotentialMatch.locateMatches();\r", "+\t\t\t\tpotentialMatch.reset();\r", "+\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\t\tthrow new JavaModelException(\r", "+\t\t\t\t\te,\r", "+\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t\t} catch (CoreException e) {\r", "+\t\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\t\tthrow (JavaModelException) e;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "430b10ec36f2d6c58b1cc73c5abe0080", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "commitAfterChange": "7e5cc03e445550d3cbc10c611218c79332074276", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "signatureAfterChange": "\r \tprivate void locateMatches() throws JavaModelException", "diff": ["- */\r", "-private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "-\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "-\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "-\tIBinaryType info;\r", "-\tif (classFile.isOpen()) {\r", "-\t\t// reuse the info from the java model cache\r", "-\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "-\t} else {\r", "-\t\t// create a temporary info\r", "-\t\ttry {\r", "-\t\t\tIJavaElement pkg = classFile.getParent();\r", "-\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "-\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t// class file in a jar\r", "-\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "-\t\t\t\tString classFilePath = \r", "-\t\t\t\t\t(pkgPath.length() > 0) ?\r", "-\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "-\t\t\t\t\t\tclassFile.getElementName();\r", "-\t\t\t\tZipFile zipFile = null;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "-\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "-\t\t\t\t\t\tzipFile,\r", "-\t\t\t\t\t\tclassFilePath);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (zipFile != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tzipFile.close();\r", "-\t\t\t\t\t\t} catch (IOException e) {\r", "-\t\t\t\t\t\t\t// ignore \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// class file in a directory\r", "-\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "-\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "-\t\t\t}\r", "-\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "-\t\t\te.printStackTrace();\r", "-\t\t\treturn;\r", "-\t\t} catch (java.io.IOException e) {\r", "-\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "-\t\t}\r", "-\t\t\r", "-\t}\r", "-\r", "-\t// check class definition\r", "-\tif (this.pattern.matchesBinary(info, null)) {\r", "-\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t}\r", "-\r", "-\tboolean compilationAborted = false;\r", "-\tif (this.pattern.needsResolve) {\r", "-\t\t// resolve\r", "-\t\tBinaryTypeBinding binding = null;\r", "-\t\ttry {\r", "-\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "-\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "-\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "-\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "-\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "-\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "-\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// check methods\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tMethodBinding[] methods = binding.methods();\r", "-\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "-\t\t\t\t\tMethodBinding method = methods[i];\r", "-\t\t\t\t\tif (this.pattern.matches(method)) {\r", "-\t\t\t\t\t\tIMethod methodHandle = \r", "-\t\t\t\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "-\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "-\t\t\t\t\t\t\t);\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\r", "-\t\t\t// check fields\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tFieldBinding[] fields = binding.fields();\r", "-\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "-\t\t\t\t\tFieldBinding field = fields[i];\r", "-\t\t\t\t\tif (this.pattern.matches(field)) {\r", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t} catch (AbortCompilation e) {\r", "-\t\t\tbinding = null;\r", "-\t\t// no need to check binary info if resolve was successful\r", "-\t\tcompilationAborted = binding == null;\r", "-\t\tif (!compilationAborted) return;\r", "-\t// if compilation was aborted it is a problem with the class path: \r", "-\t// report as a potential match if binary info matches the pattern\r", "-\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\r", "-\t// check methods\r", "-\tIBinaryMethod[] methods = info.getMethods();\r", "-\tint length = methods == null ? 0 : methods.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryMethod method = methods[i];\r", "-\t\tif (this.pattern.matchesBinary(method, info)) {\r", "-\t\t\tIMethod methodHandle = \r", "-\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "-\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "-\t\t\t\t);\r", "-\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "-\t// check fields\r", "-\tIBinaryField[] fields = info.getFields();\r", "-\tlength = fields == null ? 0 : fields.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryField field = fields[i];\r", "-\t\tif (this.pattern.matchesBinary(field, info)) {\r", "-\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "-\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "-}\r", "+\t */\r", "+\tprivate void locateMatches() throws JavaModelException {\r", "+\t\t// binding resolution\r", "+\t\tthis.lookupEnvironment.completeTypeBindings();\r", "+\r", "+\t\t// potential match resolution\r", "+\t\tfor (this.potentialMatchesIndex = 0;\r", "+\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "+\t\t\tthis.potentialMatchesIndex++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tPotentialMatch potentialMatch =\r", "+\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "+\t\t\t\tpotentialMatch.locateMatches();\r", "+\t\t\t\tpotentialMatch.reset();\r", "+\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\t\tthrow new JavaModelException(\r", "+\t\t\t\t\te,\r", "+\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t\t} catch (CoreException e) {\r", "+\t\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\t\tthrow (JavaModelException) e;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcc787cfb279473b650238287ab3df0e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "commitAfterChange": "44855522f87e615f1ca0bfcda268b074e4443dfe", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "signatureAfterChange": "\r \tprivate void locateMatches() throws JavaModelException", "diff": ["- */\r", "-private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "-\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "-\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "-\tIBinaryType info;\r", "-\tif (classFile.isOpen()) {\r", "-\t\t// reuse the info from the java model cache\r", "-\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "-\t} else {\r", "-\t\t// create a temporary info\r", "-\t\ttry {\r", "-\t\t\tIJavaElement pkg = classFile.getParent();\r", "-\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "-\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t// class file in a jar\r", "-\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "-\t\t\t\tString classFilePath = \r", "-\t\t\t\t\t(pkgPath.length() > 0) ?\r", "-\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "-\t\t\t\t\t\tclassFile.getElementName();\r", "-\t\t\t\tZipFile zipFile = null;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "-\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "-\t\t\t\t\t\tzipFile,\r", "-\t\t\t\t\t\tclassFilePath);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (zipFile != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tzipFile.close();\r", "-\t\t\t\t\t\t} catch (IOException e) {\r", "-\t\t\t\t\t\t\t// ignore \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// class file in a directory\r", "-\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "-\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "-\t\t\t}\r", "-\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "-\t\t\te.printStackTrace();\r", "-\t\t\treturn;\r", "-\t\t} catch (java.io.IOException e) {\r", "-\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "-\t\t}\r", "-\t\t\r", "-\t}\r", "-\r", "-\t// check class definition\r", "-\tif (this.pattern.matchesBinary(info, null)) {\r", "-\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t}\r", "-\r", "-\tboolean compilationAborted = false;\r", "-\tif (this.pattern.needsResolve) {\r", "-\t\t// resolve\r", "-\t\tBinaryTypeBinding binding = null;\r", "-\t\ttry {\r", "-\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "-\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "-\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "-\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "-\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "-\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "-\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// check methods\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tMethodBinding[] methods = binding.methods();\r", "-\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "-\t\t\t\t\tMethodBinding method = methods[i];\r", "-\t\t\t\t\tif (this.pattern.matches(method)) {\r", "-\t\t\t\t\t\tIMethod methodHandle = \r", "-\t\t\t\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "-\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "-\t\t\t\t\t\t\t);\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\r", "-\t\t\t// check fields\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tFieldBinding[] fields = binding.fields();\r", "-\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "-\t\t\t\t\tFieldBinding field = fields[i];\r", "-\t\t\t\t\tif (this.pattern.matches(field)) {\r", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t} catch (AbortCompilation e) {\r", "-\t\t\tbinding = null;\r", "-\t\t// no need to check binary info if resolve was successful\r", "-\t\tcompilationAborted = binding == null;\r", "-\t\tif (!compilationAborted) return;\r", "-\t// if compilation was aborted it is a problem with the class path: \r", "-\t// report as a potential match if binary info matches the pattern\r", "-\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\r", "-\t// check methods\r", "-\tIBinaryMethod[] methods = info.getMethods();\r", "-\tint length = methods == null ? 0 : methods.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryMethod method = methods[i];\r", "-\t\tif (this.pattern.matchesBinary(method, info)) {\r", "-\t\t\tIMethod methodHandle = \r", "-\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "-\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "-\t\t\t\t);\r", "-\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "-\t// check fields\r", "-\tIBinaryField[] fields = info.getFields();\r", "-\tlength = fields == null ? 0 : fields.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryField field = fields[i];\r", "-\t\tif (this.pattern.matchesBinary(field, info)) {\r", "-\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "-\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "-}\r", "+\t */\r", "+\tprivate void locateMatches() throws JavaModelException {\r", "+\t\t// binding resolution\r", "+\t\tthis.lookupEnvironment.completeTypeBindings();\r", "+\r", "+\t\t// potential match resolution\r", "+\t\tfor (this.potentialMatchesIndex = 0;\r", "+\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "+\t\t\tthis.potentialMatchesIndex++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tPotentialMatch potentialMatch =\r", "+\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "+\t\t\t\tpotentialMatch.locateMatches();\r", "+\t\t\t\tpotentialMatch.reset();\r", "+\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\t\tthrow new JavaModelException(\r", "+\t\t\t\t\te,\r", "+\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t\t} catch (CoreException e) {\r", "+\t\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\t\tthrow (JavaModelException) e;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e431641a2e6ced7d0e35d04f86a65a3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "40383c2427f4645edcb9e28f2e15a8a778f0a951", "commitAfterChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "signatureAfterChange": "\r \tprivate void locateMatches() throws JavaModelException", "diff": ["- */\r", "-private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "-\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "-\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "-\tIBinaryType info;\r", "-\tif (classFile.isOpen()) {\r", "-\t\t// reuse the info from the java model cache\r", "-\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "-\t} else {\r", "-\t\t// create a temporary info\r", "-\t\ttry {\r", "-\t\t\tIJavaElement pkg = classFile.getParent();\r", "-\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "-\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t// class file in a jar\r", "-\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "-\t\t\t\tString classFilePath = \r", "-\t\t\t\t\t(pkgPath.length() > 0) ?\r", "-\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "-\t\t\t\t\t\tclassFile.getElementName();\r", "-\t\t\t\tZipFile zipFile = null;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "-\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "-\t\t\t\t\t\tzipFile,\r", "-\t\t\t\t\t\tclassFilePath);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (zipFile != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tzipFile.close();\r", "-\t\t\t\t\t\t} catch (IOException e) {\r", "-\t\t\t\t\t\t\t// ignore \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// class file in a directory\r", "-\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "-\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "-\t\t\t}\r", "-\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "-\t\t\te.printStackTrace();\r", "-\t\t\treturn;\r", "-\t\t} catch (java.io.IOException e) {\r", "-\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "-\t\t}\r", "-\t\t\r", "-\t}\r", "-\r", "-\t// check class definition\r", "-\tif (this.pattern.matchesBinary(info, null)) {\r", "-\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t}\r", "-\r", "-\tboolean compilationAborted = false;\r", "-\tif (this.pattern.needsResolve) {\r", "-\t\t// resolve\r", "-\t\tBinaryTypeBinding binding = null;\r", "-\t\ttry {\r", "-\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "-\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "-\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "-\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "-\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "-\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "-\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// check methods\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tMethodBinding[] methods = binding.methods();\r", "-\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "-\t\t\t\t\tMethodBinding method = methods[i];\r", "-\t\t\t\t\tif (this.pattern.matches(method)) {\r", "-\t\t\t\t\t\tIMethod methodHandle = \r", "-\t\t\t\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "-\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "-\t\t\t\t\t\t\t);\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(methodHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\r", "-\t\t\t// check fields\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tFieldBinding[] fields = binding.fields();\r", "-\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "-\t\t\t\t\tFieldBinding field = fields[i];\r", "-\t\t\t\t\tif (this.pattern.matches(field)) {\r", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(fieldHandle, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t\t} catch (AbortCompilation e) {\r", "-\t\t\tbinding = null;\r", "-\t\t// no need to check binary info if resolve was successful\r", "-\t\tcompilationAborted = binding == null;\r", "-\t\tif (!compilationAborted) return;\r", "-\t// if compilation was aborted it is a problem with the class path: \r", "-\t// report as a potential match if binary info matches the pattern\r", "-\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t\r", "-\t// check methods\r", "-\tIBinaryMethod[] methods = info.getMethods();\r", "-\tint length = methods == null ? 0 : methods.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryMethod method = methods[i];\r", "-\t\tif (this.pattern.matchesBinary(method, info)) {\r", "-\t\t\tIMethod methodHandle = \r", "-\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "-\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "-\t\t\t\t);\r", "-\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "-\t// check fields\r", "-\tIBinaryField[] fields = info.getFields();\r", "-\tlength = fields == null ? 0 : fields.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryField field = fields[i];\r", "-\t\tif (this.pattern.matchesBinary(field, info)) {\r", "-\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "-\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "-}\r", "+\t */\r", "+\tprivate void locateMatches() throws JavaModelException {\r", "+\t\t// binding resolution\r", "+\t\tthis.lookupEnvironment.completeTypeBindings();\r", "+\r", "+\t\t// potential match resolution\r", "+\t\tfor (this.potentialMatchesIndex = 0;\r", "+\t\t\tthis.potentialMatchesIndex < this.potentialMatchesLength;\r", "+\t\t\tthis.potentialMatchesIndex++) {\r", "+\t\t\ttry {\r", "+\t\t\t\tPotentialMatch potentialMatch =\r", "+\t\t\t\t\tthis.potentialMatches[this.potentialMatchesIndex];\r", "+\t\t\t\tpotentialMatch.locateMatches();\r", "+\t\t\t\tpotentialMatch.reset();\r", "+\t\t\t} catch (AbortCompilation e) {\r", "+\t\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\t\tthrow new JavaModelException(\r", "+\t\t\t\t\te,\r", "+\t\t\t\t\tIJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t\t} catch (CoreException e) {\r", "+\t\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\t\tthrow (JavaModelException) e;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f86cfd37df57fae14b5c52893d468a01", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "305e4f0c27f7df148c6acf3c313dda144407f8c1", "commitAfterChange": "c72a639799e1f7a209f8477bea888d0d19067c25", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 32, "signatureBeforeChange": "\r private void locateMatchesInClassFile() throws CoreException, JavaModelException", "signatureAfterChange": "\r private void locateMatches() throws JavaModelException", "diff": ["- */\r", "-private void locateMatchesInClassFile() throws CoreException, JavaModelException {\r", "-\torg.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.currentOpenable;\r", "-\tBinaryType binaryType = (BinaryType)classFile.getType();\r", "-\tIBinaryType info;\r", "-\tif (classFile.isOpen()) {\r", "-\t\t// reuse the info from the java model cache\r", "-\t\tinfo = (IBinaryType)binaryType.getRawInfo();\r", "-\t} else {\r", "-\t\t// create a temporary info\r", "-\t\ttry {\r", "-\t\t\tIJavaElement pkg = classFile.getParent();\r", "-\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();\r", "-\t\t\tif (root.isArchive()) {\r", "-\t\t\t\t// class file in a jar\r", "-\t\t\t\tString pkgPath = pkg.getElementName().replace('.', '/');\r", "-\t\t\t\tString classFilePath = \r", "-\t\t\t\t\t(pkgPath.length() > 0) ?\r", "-\t\t\t\t\t\tpkgPath + \"/\"/*nonNLS*/ + classFile.getElementName() :\r", "-\t\t\t\t\t\tclassFile.getElementName();\r", "-\t\t\t\tZipFile zipFile = null;\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tzipFile = ((JarPackageFragmentRoot)root).getJar();\r", "-\t\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(\r", "-\t\t\t\t\t\tzipFile,\r", "-\t\t\t\t\t\tclassFilePath);\r", "-\t\t\t\t} finally {\r", "-\t\t\t\t\tif (zipFile != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tzipFile.close();\r", "-\t\t\t\t\t\t} catch (IOException e) {\r", "-\t\t\t\t\t\t\t// ignore \r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t} else {\r", "-\t\t\t\t// class file in a directory\r", "-\t\t\t\tString osPath = this.currentResource.getFullPath().toOSString();\r", "-\t\t\t\tinfo = org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.read(osPath);\r", "-\t\t\t}\r", "-\t\t} catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException e) {\r", "-\t\t\te.printStackTrace();\r", "-\t\t\treturn;\r", "-\t\t} catch (java.io.IOException e) {\r", "-\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.IO_EXCEPTION);\r", "-\t\t}\r", "-\t\t\r", "-\t}\r", "-\r", "-\t// check class definition\r", "-\tif (this.pattern.matchesBinary(info, null)) {\r", "-\t\tthis.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);\r", "-\t}\r", "-\r", "-\tboolean compilationAborted = false;\r", "-\tif (this.pattern.needsResolve) {\r", "-\t\t// resolve\r", "-\t\tBinaryTypeBinding binding = null;\r", "-\t\ttry {\r", "-\t\t\tbinding = this.lookupEnvironment.cacheBinaryType(info);\r", "-\t\t\tif (binding == null) { // it was already cached as a result of a previous query\r", "-\t\t\t\tchar[][] compoundName = CharOperation.splitOn('.', binaryType.getFullyQualifiedName().toCharArray());\r", "-\t\t\t\tReferenceBinding referenceBinding = this.lookupEnvironment.getCachedType(compoundName);\r", "-\t\t\t\tif (referenceBinding != null && (referenceBinding instanceof BinaryTypeBinding)) {\r", "-\t\t\t\t\t// if the binding could be found and if it comes from a source type,\r", "-\t\t\t\t\tbinding = (BinaryTypeBinding)referenceBinding;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\t// check methods\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tMethodBinding[] methods = binding.methods();\r", "-\t\t\t\tfor (int i = 0; i < methods.length; i++) {\r", "-\t\t\t\t\tMethodBinding method = methods[i];\r", "-\t\t\t\t\tint level = this.pattern.matchLevel(method);\r", "-\t\t\t\t\tif (level != SearchPattern.IMPOSSIBLE_MATCH) {\r", "-\t\t\t\t\t\tIMethod methodHandle = \r", "-\t\t\t\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\t\t\t\tnew String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),\r", "-\t\t\t\t\t\t\t\tSignature.getParameterTypes(new String(method.signature()).replace('/', '.'))\r", "-\t\t\t\t\t\t\t);\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(\r", "-\t\t\t\t\t\t\tmethodHandle, \r", "-\t\t\t\t\t\t\tinfo, \r", "-\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH ? \r", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH : \r", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\r", "-\t\t\t// check fields\r", "-\t\t\tif (binding != null) {\r", "-\t\t\t\tFieldBinding[] fields = binding.fields();\r", "-\t\t\t\tfor (int i = 0; i < fields.length; i++) {\r", "-\t\t\t\t\tFieldBinding field = fields[i];\r", "-\t\t\t\t\tint level = this.pattern.matchLevel(field);\r", "-\t\t\t\t\tif (level != SearchPattern.IMPOSSIBLE_MATCH) {\r", "-\t\t\t\t\t\tIField fieldHandle = binaryType.getField(new String(field.name));\r", "-\t\t\t\t\t\tthis.reportBinaryMatch(\r", "-\t\t\t\t\t\t\tfieldHandle, \r", "-\t\t\t\t\t\t\tinfo, \r", "-\t\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH ? \r", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH : \r", "-\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t} catch (AbortCompilation e) {\r", "-\t\t\tbinding = null;\r", "-\t\t}\r", "-\r", "-\t\t// no need to check binary info if resolve was successful\r", "-\t\tcompilationAborted = binding == null;\r", "-\t\tif (!compilationAborted) return;\r", "-\t}\r", "-\r", "-\t// if compilation was aborted it is a problem with the class path: \r", "-\t// report as a potential match if binary info matches the pattern\r", "-\tint accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;\r", "-\t// check methods\r", "-\tIBinaryMethod[] methods = info.getMethods();\r", "-\tint length = methods == null ? 0 : methods.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryMethod method = methods[i];\r", "-\t\tif (this.pattern.matchesBinary(method, info)) {\r", "-\t\t\tIMethod methodHandle = \r", "-\t\t\t\tbinaryType.getMethod(\r", "-\t\t\t\t\tnew String(method.isConstructor() ? info.getName() : method.getSelector()),\r", "-\t\t\t\t\tSignature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))\r", "-\t\t\t\t);\r", "-\t\t\tthis.reportBinaryMatch(methodHandle, info, accuracy);\r", "-\t\t}\r", "-\t// check fields\r", "-\tIBinaryField[] fields = info.getFields();\r", "-\tlength = fields == null ? 0 : fields.length;\r", "-\tfor (int i = 0; i < length; i++) {\r", "-\t\tIBinaryField field = fields[i];\r", "-\t\tif (this.pattern.matchesBinary(field, info)) {\r", "-\t\t\tIField fieldHandle = binaryType.getField(new String(field.getName()));\r", "-\t\t\tthis.reportBinaryMatch(fieldHandle, info, accuracy);\r", "-\t\t}\r", "-\t}\r", "-}\r", "+ */\r", "+private void locateMatches() throws JavaModelException {\r", "+\t// binding resolution\r", "+\tthis.lookupEnvironment.completeTypeBindings();\r", "+\r", "+\t// potential match resolution\r", "+\tfor (this.potentialMatchesIndex = 0; this.potentialMatchesIndex < this.potentialMatchesLength; this.potentialMatchesIndex++) {\r", "+\t\ttry {\r", "+\t\t\tPotentialMatch potentialMatch = this.potentialMatches[this.potentialMatchesIndex];\r", "+\t\t\tpotentialMatch.locateMatches();\r", "+\t\t\tpotentialMatch.reset();\r", "+\t\t} catch (AbortCompilation e) {\r", "+\t\t\t// problem with class path: it could not find base classes\r", "+\t\t\tthrow new JavaModelException(e, IJavaModelStatusConstants.BUILDER_INITIALIZATION_ERROR);\r", "+\t\t} catch (CoreException e) {\r", "+\t\t\tif (e instanceof JavaModelException) {\r", "+\t\t\t\tthrow (JavaModelException)e;\r", "+\t\t\t} else {\r", "+\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t\t}\r", "+\t\t}\r", "+\t}\r", "+}\r"]}], "num": 29199}