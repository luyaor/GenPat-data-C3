{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "24d4766bd6d0b62eb687b4001eaa18c2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46b2951351041bd029d4f64331ac24a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java", "commitBeforeChange": "06e44af1d1177a8820136cde1fbe3146b9563e7f", "commitAfterChange": "c0452100f2ed18d65cf0dd0efb6f9fc0ffa98156", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 35, "signatureBeforeChange": "  \tprotected void setUp() throws Exception", "signatureAfterChange": "  \tprotected void setUp() throws Exception", "diff": ["+\t\tif (RUN_JAVAC) {", "+\t\t\tif (!getClass().getName().equals(CURRENT_CLASS_NAME)) {", "+\t\t\t\tif (javacFullLog == null) {", "+\t\t\t\t\t// One time initialization of javac related concerns", "+\t\t\t\t\t// compute command lines and extract javac version", "+\t\t\t\t\tString jdkRootDirectory = System.getProperty(\"jdk.root\");", "+\t\t\t\t\tif (jdkRootDirectory == null)", "+\t\t\t\t\t  jdkRootDirPath = (new Path(Util.getJREDirectory())).removeLastSegments(1);", "+\t\t\t\t\telse ", "+\t\t\t\t\t\tjdkRootDirPath = new Path(jdkRootDirectory);", "+\t\t", "+\t\t\t\t\tStringBuffer cmdLineHeader = new StringBuffer(jdkRootDirPath.", "+\t\t\t\t\t\t\tappend(\"bin\").append(JAVA_NAME).toString()); // PREMATURE replace JAVA_NAME and JAVAC_NAME with locals? depends on potential reuse", "+\t\t\t\t\tjavaCommandLineHeader = cmdLineHeader.toString();", "+\t\t\t\t\tcmdLineHeader = new StringBuffer(jdkRootDirPath.", "+\t\t\t\t\t\t\tappend(\"bin\").append(JAVAC_NAME).toString());", "+\t\t\t\t\tcmdLineHeader.append(\" -classpath . \");", "+\t\t\t\t\t  // start with the current directory which contains the source files", "+\t\t\t\t\tProcess compileProcess = Runtime.getRuntime().exec(", "+\t\t\t\t\t\tcmdLineHeader.toString() + \" -version\", null, null);", "+\t        Logger versionLogger = new Logger(compileProcess.getErrorStream(), \"\"); // WORK            ", "+\t        versionLogger.start();", "+\t        compileProcess.waitFor();", "+\t\t\t\t\tversionLogger.join(); // make sure we get the whole output", "+\t\t\t\t\tString version = versionLogger.buffer.toString();", "+\t\t\t\t\tint eol = version.indexOf('\\n');", "+\t\t\t\t\tversion = version.substring(0, eol);", "+\t\t\t\t\tcmdLineHeader.append(\" -d \");", "+\t\t\t\t\tcmdLineHeader.append(JAVAC_OUTPUT_DIR.indexOf(\" \") != -1 ? \"\\\"\" + JAVAC_OUTPUT_DIR + \"\\\"\" : JAVAC_OUTPUT_DIR);", "+\t\t\t\t\tcmdLineHeader.append(\" -source 1.5 -deprecation -Xlint:unchecked \"); // enable recommended warnings", "+\t\t\t\t\t// REVIEW consider enabling all warnings instead? Philippe does not see", "+\t\t\t\t\t//        this as ez to use (too many changes in logs)", "+\t\t\t\t\tjavacCommandLineHeader = cmdLineHeader.toString();", "+", "+\t\t\t\t\t// open output log", "+\t\t\t\t\tString javacFullLogFileName = ", "+\t\t\t\t\t\t\tUtil.getOutputDirectory() +\tFile.separatorChar + ", "+\t\t\t\t\t\t\tversion.replace(' ', '_') + \"_\" + ", "+\t\t\t\t\t    (new SimpleDateFormat(\"yyyyMMdd_HHmmss\")).format(new Date()) +", "+\t\t\t\t\t    \".txt\";", "+\t\t\t\t\tjavacFullLog = ", "+\t\t\t\t\t  \tnew PrintWriter(new FileOutputStream(javacFullLogFileName));", "+\t\t\t\t\tjavacFullLog.println(version); // so that the contents is self sufficient", "+\t\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\t\tSystem.out.println(\"* Sun Javac compiler output archived into file:\");", "+\t\t\t\t\tSystem.out.println(\"* \" + javacFullLogFileName);", "+\t\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\t}", "+\t\t\t\t// per class initialization", "+\t\t\t\tCURRENT_CLASS_NAME = getClass().getName();", "+\t\t\t\tdualPrintln(\"***************************************************************************\");", "+\t\t\t\tSystem.out.print(\"* Comparison with Sun Javac compiler for class \");", "+\t\t\t\tdualPrintln(CURRENT_CLASS_NAME.substring(CURRENT_CLASS_NAME.lastIndexOf('.')+1) + ", "+\t\t\t\t\t\t\" (\" + TESTS_COUNTERS.get(CURRENT_CLASS_NAME) + \" tests)\");", "+\t\t\t\tSystem.out.println(\"***************************************************************************\");", "+\t\t\t\tDIFF_COUNTERS[0] = 0;", "+\t\t\t\tDIFF_COUNTERS[1] = 0;", "+\t\t\t\tDIFF_COUNTERS[2] = 0;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c7f2517c199beb00295976f67b956aee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "900c13d17fd147c187a2b319111ff0c850c4ae89", "commitAfterChange": "f02cc00df615ce0df96d2675e50465c713b4b942", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count)", "diff": ["-\t\t\t\t// insert a new line only if it has not been already done before", "-\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476", "-\t\t\t\tif (this.lastNumberOfNewLines == 0) {", "+\t\t\t\t// Insert a new line only if it has not been already done before", "+\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)", "+\t\t\t\t// or when there's no direct member alignment", "+\t\t\t\t// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)", "+\t\t\t\tif (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\"Preserve empty lines:\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(this.currentAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\tif (this.memberAlignment != null) {", "+\t\t\t\t\t\t\tSystem.out.println(\" - member alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tSystem.out.print(this.memberAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+", "-\t\t\t\t\tthis.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;", "-\t\t\t\t\tthis.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;", "-\t\t\t\t\t// Create new line keeping the existing indentation", "+", "+\t\t\t\t\t// Create new line", "+\t\t\t\t\t", "+\t\t\t\t\t// Look for current indentation", "-\t\t\t\t\tAlignment rootAlignment = this.currentAlignment;", "-\t\t\t\t\twhile (rootAlignment.enclosing != null) {", "-\t\t\t\t\t\trootAlignment = rootAlignment.enclosing;", "+\t\t\t\t\t", "+\t\t\t\t\t// Determine whether the alignment indentation can be used or not", "+\t\t\t\t\t// So far, the best algorithm is to use it when", "+\t\t\t\t\t// 1. this is not the opening brace of a local declaration assignment", "+\t\t\t\t\t// 2. this is not the first opening brace", "+\t\t\t\t\t//     or this is an array initializer alignment ", "+\t\t\t\t\t//     or this is an binary expression alignment", "+\t\t\t\t\t// 3. the indentation level is below the alignment break indentation", "+\t\t\t\t\tint currentTokenStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\tint nextToken = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tnextToken = this.scanner.getNextToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t// skip", "-\t\t\t\t\tLocation location = rootAlignment.location;", "-\t\t\t\t\tif (currentColumn > location.inputColumn) {", "-\t\t\t\t\t\tint savedIndentation = this.indentationLevel;", "-\t\t\t\t\t\tthis.indentationLevel += currentColumn - location.inputColumn;", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\tthis.indentationLevel = savedIndentation;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\tboolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || !this.currentAlignment.name.equals(\"localDeclarationAssignmentAlignment\")); //$NON-NLS-1$", "+\t\t\t\t\tif (canUseAlignmentIndentation &&", "+\t\t\t\t\t\t\t(!this.formatBrace ||", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"array_initializer\") || //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"binaryExpressionAlignment\")) && //$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel) {", "+\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t", "+\t\t\t\t\t// Use the current indentation if over the computed indentation", "+\t\t\t\t\tif (this.indentationLevel < currentColumn) {", "+\t\t\t\t\t\tthis.indentationLevel = currentColumn;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\" - format brace = \"+this.formatBrace); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current column = \"+currentColumn); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current position = \"+this.scanner.currentPosition); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(\" - current line = \"); //$NON-NLS-1$", "+\t\t\t\t\t\tint linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);", "+\t\t\t\t\t\tif (linePtr < 0) {", "+\t\t\t\t\t\t\tlinePtr = -linePtr - 1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tint i = getLineEnd(linePtr)+1;", "+\t\t\t\t\t\twhile (this.scanner.source[i] != '\\r') {", "+\t\t\t\t\t\t\tSystem.out.print(this.scanner.source[i++]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Set the flag to indicate that a specific indentation is currently in used", "+\t\t\t\t\tthis.preserveLineBreakIndentation = true;", "+\t\t\t\t\t", "+\t\t\t\t\t// Print the computed indentation in the buffer", "+\t\t\t\t\tprintIndentationIfNecessary(buffer);"]}], "num": 2663}