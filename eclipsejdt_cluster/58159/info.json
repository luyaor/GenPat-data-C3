{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5cf9cf83848e9d53ef388ea76a823f27", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30a28430bf304d3d5ae7631682dc9840", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "  private void internalGenerateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-", "-\tprivate void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "-\t\t", "-\t\tclassFile.generateMethodInfoHeader(binding);", "-\t\tint methodAttributeOffset = classFile.contentsOffset;", "-\t\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "-\t\tif ((!binding.isNative()) && (!binding.isAbstract())) {", "-\t\t\t", "-\t\t\tTypeDeclaration declaringType = classScope.referenceContext;", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;", "-\t\t\tclassFile.generateCodeAttributeHeader();", "-\t\t\tCodeStream codeStream = classFile.codeStream;", "-\t\t\tcodeStream.reset(this, classFile);", "-", "-\t\t\t// initialize local positions - including initializer scope.", "-\t\t\tReferenceBinding declaringClass = binding.declaringClass;", "-", "-\t\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "-\t\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "-", "-\t\t\tif (declaringClass.isNestedType()){", "-\t\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "-\t\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "-\t\t\t\tscope.computeLocalVariablePositions(// consider synthetic arguments if any", "-\t\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "-\t\t\t\t\tcodeStream);", "-\t\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "-\t\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "-\t\t\t} else {", "-\t\t\t\tscope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "-\t\t\t}", "-\t\t\t\t", "-\t\t\tif (arguments != null) {", "-\t\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {", "-\t\t\t\t\t// arguments initialization for local variable debug attributes", "-\t\t\t\t\tLocalVariableBinding argBinding;", "-\t\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = arguments[i].binding);", "-\t\t\t\t\targBinding.recordInitializationStartPC(0);", "-\t\t\t\t\tTypeBinding argType;", "-\t\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\targSlotSize += 2;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\targSlotSize++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\tMethodScope initializerScope = declaringType.initializerScope;", "-\t\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "-", "-\t\t\tboolean needFieldInitializations = constructorCall == null || constructorCall.accessMode != ExplicitConstructorCall.This;", "-", "-\t\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "-\t\t\tboolean preInitSyntheticFields = scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "-", "-\t\t\tif (needFieldInitializations && preInitSyntheticFields){", "-\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t}\t\t\t", "-\t\t\t// generate constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\tconstructorCall.generateCode(scope, codeStream);", "-\t\t\t}", "-\t\t\t// generate field initialization - only if not invoking another constructor call of the same class", "-\t\t\tif (needFieldInitializations) {", "-\t\t\t\tif (!preInitSyntheticFields){", "-\t\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(scope, codeStream, declaringClass);", "-\t\t\t\t}", "-\t\t\t\t// generate user field initialization", "-\t\t\t\tif (declaringType.fields != null) {", "-\t\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "-\t\t\t\t\t\tFieldDeclaration fieldDecl;", "-\t\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// generate statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++) {", "-\t\t\t\t\tstatements[i].generateCode(scope, codeStream);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (this.needFreeReturn) {", "-\t\t\t\tcodeStream.return_();", "-\t\t\t}", "-\t\t\t// local variable attributes", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "-\t\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "-\t\t\tattributeNumber++;", "-\t\t}", "-\t\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "-", "-\t\t// if a problem got reported during code gen, then trigger problem method creation", "-\t\tif (ignoreFurtherInvestigation) {", "-\t\t\tthrow new AbortMethod(scope.referenceCompilationUnit().compilationResult, null);", "-\t\t}", "-\t}", "+", "+private void internalGenerateCode(ClassScope classScope, ClassFile classFile) {", "+\tclassFile.generateMethodInfoHeader(this.binding);", "+\tint methodAttributeOffset = classFile.contentsOffset;", "+\tint attributeNumber = classFile.generateMethodInfoAttribute(this.binding);", "+\tif ((!this.binding.isNative()) && (!this.binding.isAbstract())) {", "+\t\tTypeDeclaration declaringType = classScope.referenceContext;", "+\t\tint codeAttributeOffset = classFile.contentsOffset;", "+\t\tclassFile.generateCodeAttributeHeader();", "+\t\tCodeStream codeStream = classFile.codeStream;", "+\t\tcodeStream.reset(this, classFile);", "+\t\t// initialize local positions - including initializer scope.", "+\t\tReferenceBinding declaringClass = this.binding.declaringClass;", "+\t\tint enumOffset = declaringClass.isEnum() ? 2 : 0; // String name, int ordinal", "+\t\tint argSlotSize = 1 + enumOffset; // this==aload0", "+\t\tif (declaringClass.isNestedType()){", "+\t\t\tNestedTypeBinding nestedType = (NestedTypeBinding) declaringClass;", "+\t\t\tthis.scope.extraSyntheticArguments = nestedType.syntheticOuterLocalVariables();", "+\t\t\tthis.scope.computeLocalVariablePositions(// consider synthetic arguments if any", "+\t\t\t\tnestedType.enclosingInstancesSlotSize + 1 + enumOffset,", "+\t\t\t\tcodeStream);", "+\t\t\targSlotSize += nestedType.enclosingInstancesSlotSize;", "+\t\t\targSlotSize += nestedType.outerLocalVariablesSlotSize;", "+\t\t} else {", "+\t\t\tthis.scope.computeLocalVariablePositions(1 + enumOffset,  codeStream);", "+\t\t\t", "+\t\tif (this.arguments != null) {", "+\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t// arguments initialization for local variable debug attributes", "+\t\t\t\tLocalVariableBinding argBinding;", "+\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = this.arguments[i].binding);", "+\t\t\t\targBinding.recordInitializationStartPC(0);", "+\t\t\t\tTypeBinding argType;", "+\t\t\t\tif ((argType = argBinding.type) == TypeBinding.LONG || (argType == TypeBinding.DOUBLE)) {", "+\t\t\t\t\targSlotSize += 2;", "+\t\t\t\t} else {", "+\t\t\t\t\targSlotSize++;", "+\t\t", "+\t\tMethodScope initializerScope = declaringType.initializerScope;", "+\t\tinitializerScope.computeLocalVariablePositions(argSlotSize, codeStream); // offset by the argument size (since not linked to method scope)", "+", "+\t\tboolean needFieldInitializations = this.constructorCall == null || this.constructorCall.accessMode != ExplicitConstructorCall.This;", "+", "+\t\t// post 1.4 target level, synthetic initializations occur prior to explicit constructor call", "+\t\tboolean preInitSyntheticFields = this.scope.compilerOptions().targetJDK >= ClassFileConstants.JDK1_4;", "+", "+\t\tif (needFieldInitializations && preInitSyntheticFields){", "+\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t}\t\t\t", "+\t\t// generate constructor call", "+\t\tif (this.constructorCall != null) {", "+\t\t\tthis.constructorCall.generateCode(this.scope, codeStream);", "+\t\t}", "+\t\t// generate field initialization - only if not invoking another constructor call of the same class", "+\t\tif (needFieldInitializations) {", "+\t\t\tif (!preInitSyntheticFields){", "+\t\t\t\tgenerateSyntheticFieldInitializationsIfNecessary(this.scope, codeStream, declaringClass);", "+\t\t\t}", "+\t\t\t// generate user field initialization", "+\t\t\tif (declaringType.fields != null) {", "+\t\t\t\tfor (int i = 0, max = declaringType.fields.length; i < max; i++) {", "+\t\t\t\t\tFieldDeclaration fieldDecl;", "+\t\t\t\t\tif (!(fieldDecl = declaringType.fields[i]).isStatic()) {", "+\t\t\t\t\t\tfieldDecl.generateCode(initializerScope, codeStream);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// generate statements", "+\t\tif (this.statements != null) {", "+\t\t\tfor (int i = 0, max = this.statements.length; i < max; i++) {", "+\t\t\t\tthis.statements[i].generateCode(this.scope, codeStream);", "+\t\t\t}", "+\t\t}", "+\t\tif (this.needFreeReturn) {", "+\t\t\tcodeStream.return_();", "+\t\t}", "+\t\t// local variable attributes", "+\t\tcodeStream.exitUserScope(this.scope);", "+\t\tcodeStream.recordPositionsFrom(0, this.bodyEnd);", "+\t\tclassFile.completeCodeAttribute(codeAttributeOffset);", "+\t\tattributeNumber++;", "+\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);", "+", "+\t// if a problem got reported during code gen, then trigger problem method creation", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tthrow new AbortMethod(this.scope.referenceCompilationUnit().compilationResult, null);", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "68e2a7ec468ff2dcc7b7ee0fd5a56983", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\treceiverType = receiver.resolveType(scope);", "-\tif (receiverType == null){", "-\t\tconstant = NotAConstant;", "+\tthis.receiverType = this.receiver.resolveType(scope);", "+\tif (this.receiverType == null){", "+\t\tthis.constant = NotAConstant;", "-\tthis.codegenBinding = this.binding = scope.getField(receiverType, token, this);", "-\tFieldBinding firstAttempt = binding;", "+\tthis.codegenBinding = this.binding = scope.getField(this.receiverType, this.token, this);", "+\tFieldBinding firstAttempt = this.binding;", "-\tif (!binding.isValidBinding()) {", "-\t\tif (binding instanceof ProblemFieldBinding", "-\t\t\t&& ((ProblemFieldBinding) binding).problemId() == NotVisible) {", "+\tif (!this.binding.isValidBinding()) {", "+\t\tif (this.binding instanceof ProblemFieldBinding", "+\t\t\t&& ((ProblemFieldBinding) this.binding).problemId() == NotVisible) {", "-\t\t\t\t\tdelegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "-\t\t\t\t\tif (delegateThis == null){  // if not found then internal error, field should have been found", "-\t\t\t\t\t\tconstant = NotAConstant;", "-\t\t\t\t\t\tscope.problemReporter().invalidField(this, receiverType);", "+\t\t\t\t\tthis.delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "+\t\t\t\t\tif (this.delegateThis == null){  // if not found then internal error, field should have been found", "+\t\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\t\tscope.problemReporter().invalidField(this, this.receiverType);", "-\t\t\t\t\tconstant = NotAConstant;", "-\t\t\t\t\tscope.problemReporter().invalidField(this, receiverType);", "+\t\t\t\t\tthis.constant = NotAConstant;", "+\t\t\t\t\tscope.problemReporter().invalidField(this, this.receiverType);", "-\t\t\tthis.codegenBinding = this.binding = localScope.getFieldForCodeSnippet(delegateThis.type, token, this);", "+\t\t\tthis.codegenBinding = this.binding = localScope.getFieldForCodeSnippet(this.delegateThis.type, this.token, this);", "-\tif (!binding.isValidBinding()) {", "-\t\tconstant = NotAConstant;", "+\tif (!this.binding.isValidBinding()) {", "+\t\tthis.constant = NotAConstant;", "-\t\tscope.problemReporter().invalidField(this, receiverType);", "+\t\tscope.problemReporter().invalidField(this, this.receiverType);", "-\tif (isFieldUseDeprecated(binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0)) {", "-\t\tscope.problemReporter().deprecatedField(binding, this);", "+\tif (isFieldUseDeprecated(this.binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0)) {", "+\t\tscope.problemReporter().deprecatedField(this.binding, this);", "-\tconstant = FieldReference.getConstantFor(binding, this, receiver.isImplicitThis(), scope);", "-\tif (!receiver.isThis()) {", "-\t\tconstant = NotAConstant;", "+\tthis.constant = FieldReference.getConstantFor(this.binding, this, this.receiver.isImplicitThis(), scope);", "+\tif (!this.receiver.isThis()) {", "+\t\tthis.constant = NotAConstant;", "-\treturn this.resolvedType = binding.type;", "+\treturn this.resolvedType = this.binding.type;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae312c3eca84b8cb3e8303be2be1127b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "signatureAfterChange": " public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream, CompoundAssignment postIncrement, boolean valueRequired)", "diff": ["-\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\tif (lastFieldBinding.isStatic()){", "-\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\tif (this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\tif (this.lastFieldBinding.isStatic()){", "+\t\t\tcodeStream.getstatic(this.lastFieldBinding);", "-\t\t\tcodeStream.getfield(lastFieldBinding);", "+\t\t\tcodeStream.getfield(this.lastFieldBinding);", "-\t\t\tif (lastFieldBinding.isStatic()) {", "-\t\t\t\tif ((lastFieldBinding.type == LongBinding) || (lastFieldBinding.type == DoubleBinding)) {", "+\t\t\tif (this.lastFieldBinding.isStatic()) {", "+\t\t\t\tif ((this.lastFieldBinding.type == LongBinding) || (this.lastFieldBinding.type == DoubleBinding)) {", "-\t\t\t\tif ((lastFieldBinding.type == LongBinding) || (lastFieldBinding.type == DoubleBinding)) {", "+\t\t\t\tif ((this.lastFieldBinding.type == LongBinding) || (this.lastFieldBinding.type == DoubleBinding)) {", "-\t\tcodeStream.generateConstant(postIncrement.expression.constant, implicitConversion);", "-\t\tcodeStream.sendOperator(postIncrement.operator, lastFieldBinding.type.id);", "+\t\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "+\t\tcodeStream.sendOperator(postIncrement.operator, this.lastFieldBinding.type.id);", "-\t\tfieldStore(codeStream, lastFieldBinding, null, false);", "+\t\tfieldStore(codeStream, this.lastFieldBinding, null, false);", "-\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(lastFieldBinding);", "+\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(this.lastFieldBinding);", "-\t\t\tif ((lastFieldBinding.type == LongBinding) || (lastFieldBinding.type == DoubleBinding)) {", "+\t\t\tif ((this.lastFieldBinding.type == LongBinding) || (this.lastFieldBinding.type == DoubleBinding)) {", "-\t\t((CodeSnippetCodeStream) codeStream).generateEmulationForField(lastFieldBinding);", "-\t\tif ((lastFieldBinding.type == LongBinding) || (lastFieldBinding.type == DoubleBinding)) {", "+\t\t((CodeSnippetCodeStream) codeStream).generateEmulationForField(this.lastFieldBinding);", "+\t\tif ((this.lastFieldBinding.type == LongBinding) || (this.lastFieldBinding.type == DoubleBinding)) {", "-\t\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tif (this.lastFieldBinding.isStatic()) {", "-\t\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tif (this.lastFieldBinding.isStatic()) {", "-\t\tcodeStream.generateConstant(postIncrement.expression.constant, implicitConversion);", "-\t\tcodeStream.sendOperator(postIncrement.operator, lastFieldBinding.type.id);", "+\t\tcodeStream.generateConstant(postIncrement.expression.constant, this.implicitConversion);", "+\t\tcodeStream.sendOperator(postIncrement.operator, this.lastFieldBinding.type.id);", "-\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedWriteAccessForField(lastFieldBinding);", "+\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedWriteAccessForField(this.lastFieldBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc3e6fc6db2a0363160e72d7b93417f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java", "commitBeforeChange": "bdce8da9f757d6b76794f509f77a703bf05199f8", "commitAfterChange": "2a151eb41be773ba8e53248cc8da5c85a5bc6fca", "methodNumberBeforeChange": 69, "methodNumberAfterChange": 69, "signatureBeforeChange": " public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t\tif(focusType != null) {", "+\t\tif(this.focusType != null) {", "-\t\t\thashtable.put(focusType, index);", "-\t\t\thashtable2.put(index, focusType);", "+\t\t\thashtable.put(this.focusType, index);", "+\t\t\thashtable2.put(index, this.focusType);", "-\t\tObject[] types = classToSuperclass.keySet().toArray();", "+\t\tObject[] types = this.classToSuperclass.keySet().toArray();", "-\t\t\tObject superClass = classToSuperclass.get(t);", "+\t\t\tObject superClass = this.classToSuperclass.get(t);", "-\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "+\t\ttypes = this.typeToSuperInterfaces.keySet().toArray();", "-\t\t\tObject[] sp = (Object[])typeToSuperInterfaces.get(t);", "+\t\t\tObject[] sp = (Object[])this.typeToSuperInterfaces.get(t);", "-\t\tif(computeSubtypes) {", "+\t\tif(this.computeSubtypes) {", "-\t\tif(project != null) {", "-\t\t\toutput.write(project.getHandleIdentifier().getBytes());", "+\t\tif(this.project != null) {", "+\t\t\toutput.write(this.project.getHandleIdentifier().getBytes());", "-\t\tfor (int i = 0; i < missingTypes.size(); i++) {", "+\t\tfor (int i = 0; i < this.missingTypes.size(); i++) {", "-\t\t\toutput.write(((String)missingTypes.get(i)).getBytes());", "+\t\t\toutput.write(((String)this.missingTypes.get(i)).getBytes());", "-\t\t\toutput.write(flagsToBytes((Integer)typeFlags.get(t)));", "+\t\t\toutput.write(flagsToBytes((Integer)this.typeFlags.get(t)));", "-\t\t\tif(focusType != null && focusType.equals(t)) {", "+\t\t\tif(this.focusType != null && this.focusType.equals(t)) {", "-\t\t\tif(interfaces.contains(t)) {", "+\t\t\tif(this.interfaces.contains(t)) {", "-\t\t\tif(rootClasses.contains(t)) {", "+\t\t\tif(this.rootClasses.contains(t)) {", "-\t\ttypes = classToSuperclass.keySet().toArray();", "+\t\ttypes = this.classToSuperclass.keySet().toArray();", "-\t\t\tIJavaElement value = (IJavaElement)classToSuperclass.get(key);", "+\t\t\tIJavaElement value = (IJavaElement)this.classToSuperclass.get(key);", "-\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "+\t\ttypes = this.typeToSuperInterfaces.keySet().toArray();", "-\t\t\tIJavaElement[] values = (IJavaElement[])typeToSuperInterfaces.get(key);", "+\t\t\tIJavaElement[] values = (IJavaElement[])this.typeToSuperInterfaces.get(key);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e36c068a7077feb5b687a2ed133353d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " public void generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateReadSequence(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\tint otherBindingsCount = this.otherCodegenBindings == null ? 0 : otherCodegenBindings.length;", "+\tint otherBindingsCount = this.otherCodegenBindings == null ? 0 : this.otherCodegenBindings.length;", "-\tswitch (bits & RestrictiveFlagMASK) {", "+\tswitch (this.bits & RestrictiveFlagMASK) {", "-\t\t\tlastFieldBinding = (FieldBinding) this.codegenBinding;", "+\t\t\tthis.lastFieldBinding = (FieldBinding) this.codegenBinding;", "-\t\t\tif (lastFieldBinding.constant != NotAConstant) {", "+\t\t\tif (this.lastFieldBinding.constant != NotAConstant) {", "-\t\t\t\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\t\tif (!lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "-\t\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);", "+\t\t\t\tif (this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\t\tif (!this.lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\tif ((this.bits & DepthMASK) != 0) {", "+\t\t\t\t\t\t\tReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((this.bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\t\tif (!lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\tif ((bits & DepthMASK) != 0) {", "+\t\t\t\t\tif (!this.lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\tif ((this.bits & DepthMASK) != 0) {", "-\t\t\tlastFieldBinding = null;", "+\t\t\tthis.lastFieldBinding = null;", "-\t\t\t\tif ((bits & DepthMASK) != 0) {", "+\t\t\t\tif ((this.bits & DepthMASK) != 0) {", "-\t\t\tif (lastFieldBinding != null) {", "+\t\t\tif (this.lastFieldBinding != null) {", "-\t\t\t\t\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\t\t\tif (lastFieldBinding.constant != NotAConstant) {", "+\t\t\t\t\tif (this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\t\t\tif (this.lastFieldBinding.constant != NotAConstant) {", "-\t\t\t\t\t\t\tcodeStream.generateConstant(lastFieldBinding.constant, 0);", "-\t\t\t\t\t\t} else if (lastFieldBinding.isStatic()) {", "-\t\t\t\t\t\t\tcodeStream.getstatic(lastFieldBinding);", "+\t\t\t\t\t\t\tcodeStream.generateConstant(this.lastFieldBinding.constant, 0);", "+\t\t\t\t\t\t} else if (this.lastFieldBinding.isStatic()) {", "+\t\t\t\t\t\t\tcodeStream.getstatic(this.lastFieldBinding);", "-\t\t\t\t\t\t\tcodeStream.getfield(lastFieldBinding);", "+\t\t\t\t\t\t\tcodeStream.getfield(this.lastFieldBinding);", "-\t\t\t\t\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(lastFieldBinding);", "+\t\t\t\t\t\t((CodeSnippetCodeStream) codeStream).generateEmulatedReadAccessForField(this.lastFieldBinding);", "-\t\t\tif (lastFieldBinding != null && !lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\t\t\tif (lastFieldBinding.isStatic()) {", "+\t\t\tif (this.lastFieldBinding != null && !this.lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "+\t\t\t\tif (this.lastFieldBinding.isStatic()) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "edd793799fe58e99805f1cac68111ab3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprivate void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": " private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+ */", "+private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {", "+\tif ((this.binding.isPrivate()/* || (this.binding.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType*/) && !this.binding.isUsed()) {", "+\t\tif (!this.scope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "+\t\t\tthis.scope.problemReporter().unusedPrivateType(this);", "+\t\t}", "+\t}", "+\tInitializationFlowContext initializerContext = new InitializationFlowContext(null, this, this.initializerScope);", "+\tInitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, this.staticInitializerScope);", "+\tFlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "+\tFlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "+\tif (this.fields != null) {", "+\t\tfor (int i = 0, count = this.fields.length; i < count; i++) {", "+\t\t\tFieldDeclaration field = this.fields[i];", "+\t\t\tif (field.isStatic()) {", "+\t\t\t\tif ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "+\t\t\t\t", "+\t\t\t\t/*if (field.isField()){", "+\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "+\t\t\t\t} else {*/", "+\t\t\t\tstaticInitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "+\t\t\t\t/*}*/", "+\t\t\t\tstaticFieldInfo =", "+\t\t\t\t\tfield.analyseCode(", "+\t\t\t\t\t\tthis.staticInitializerScope,", "+\t\t\t\t\t\tstaticInitializerContext,", "+\t\t\t\t\t\tstaticFieldInfo);", "+\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+\t\t\t\t// branch, since the previous initializer already got the blame.", "+\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "+\t\t\t\t\tthis.staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "+\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t} else {", "+\t\t\t\tif ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "+\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "+\t\t\t\t", "+\t\t\t\t/*if (field.isField()){", "+\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "+\t\t\t\t} else {*/", "+\t\t\t\t\tinitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "+\t\t\t\t/*}*/", "+\t\t\t\tnonStaticFieldInfo =", "+\t\t\t\t\tfield.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo);", "+\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "+\t\t\t\t// branch, since the previous initializer already got the blame.", "+\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "+\t\t\t\t\tthis.initializerScope.problemReporter().initializerMustCompleteNormally(field);", "+\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t} ", "+\t\t}", "+\t}", "+\tif (this.memberTypes != null) {", "+\t\tfor (int i = 0, count = this.memberTypes.length; i < count; i++) {", "+\t\t\tif (flowContext != null){ // local type", "+\t\t\t\tthis.memberTypes[i].analyseCode(this.scope, flowContext, nonStaticFieldInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "+\t\t\t} else {", "+\t\t\t\tthis.memberTypes[i].analyseCode(this.scope);", "+\t\t\t}", "+\t\t}", "+\t}", "+\tif (this.methods != null) {", "+\t\tUnconditionalFlowInfo outerInfo = flowInfo.unconditionalFieldLessCopy();", "+\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "+\t\tfor (int i = 0, count = this.methods.length; i < count; i++) {", "+\t\t\tAbstractMethodDeclaration method = this.methods[i];", "+\t\t\tif (method.ignoreFurtherInvestigation)", "+\t\t\t\tcontinue;", "+\t\t\tif (method.isInitializationMethod()) {", "+\t\t\t\tif (method.isStatic()) { // <clinit>", "+\t\t\t\t\tmethod.analyseCode(", "+\t\t\t\t\t\tthis.scope, ", "+\t\t\t\t\t\tstaticInitializerContext,  ", "+\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo).setReachMode(flowInfo.reachMode()));  // reset reach mode in case initializers did abrupt completely", "+\t\t\t\t} else { // constructor", "+\t\t\t\t\tmethod.analyseCode(this.scope, initializerContext, constructorInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t */", "-\tprivate void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {", "-", "-\t\tif ((this.binding.isPrivate()/* || (this.binding.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType*/) && !this.binding.isUsed()) {", "-\t\t\tif (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateType(this);", "+\t\t\t} else { // regular method", "+\t\t\t\tmethod.analyseCode(this.scope, null, flowInfo.copy());", "-", "-\t\tInitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);", "-\t\tInitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);", "-\t\tFlowInfo nonStaticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\tFlowInfo staticFieldInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\tif (fields != null) {", "-\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\tFieldDeclaration field = fields[i];", "-\t\t\t\tif (field.isStatic()) {", "-\t\t\t\t\tif ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "-\t\t\t\t\t", "-\t\t\t\t\t/*if (field.isField()){", "-\t\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\tstaticInitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tstaticFieldInfo =", "-\t\t\t\t\t\tfield.analyseCode(", "-\t\t\t\t\t\t\tstaticInitializerScope,", "-\t\t\t\t\t\t\tstaticInitializerContext,", "-\t\t\t\t\t\t\tstaticFieldInfo);", "-\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\tstaticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)", "-\t\t\t\t\t\tfield.bits &= ~ASTNode.IsReachable;", "-\t\t\t\t\t", "-\t\t\t\t\t/*if (field.isField()){", "-\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-\t\t\t\t\t} else {*/", "-\t\t\t\t\t\tinitializerContext.handledExceptions = Binding.ANY_EXCEPTION; // tolerate them all, and record them", "-\t\t\t\t\t/*}*/", "-\t\t\t\t\tnonStaticFieldInfo =", "-\t\t\t\t\t\tfield.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);", "-\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-\t\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "-\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-\t\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t\t} ", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (memberTypes != null) {", "-\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-\t\t\t\tif (flowContext != null){ // local type", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t} else {", "-\t\t\t\t\tmemberTypes[i].analyseCode(scope);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (methods != null) {", "-\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.unconditionalFieldLessCopy();", "-\t\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-\t\t\t\tif (method.ignoreFurtherInvestigation)", "-\t\t\t\t\tcontinue;", "-\t\t\t\tif (method.isInitializationMethod()) {", "-\t\t\t\t\tif (method.isStatic()) { // <clinit>", "-\t\t\t\t\t\tmethod.analyseCode(", "-\t\t\t\t\t\t\tscope, ", "-\t\t\t\t\t\t\tstaticInitializerContext,  ", "-\t\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo).setReachMode(flowInfo.reachMode()));  // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t\t} else { // constructor", "-\t\t\t\t\t\tmethod.analyseCode(scope, initializerContext, constructorInfo.copy().setReachMode(flowInfo.reachMode())); // reset reach mode in case initializers did abrupt completely", "-\t\t\t\t\t}", "-\t\t\t\t} else { // regular method", "-\t\t\t\t\tmethod.analyseCode(scope, null, flowInfo.copy());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t// enable enum support ?", "-\t\tif (this.binding.isEnum() && !this.binding.isAnonymousType()) {", "-\t\t\tthis.enumValuesSyntheticfield = this.binding.addSyntheticFieldForEnumValues();", "-\t\t}", "+\t// enable enum support ?", "+\tif (this.binding.isEnum() && !this.binding.isAnonymousType()) {", "+\t\tthis.enumValuesSyntheticfield = this.binding.addSyntheticFieldForEnumValues();", "+}"]}], "num": 58159}