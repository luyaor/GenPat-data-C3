{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "36f46984645762accb593d0a1f84dbfa", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3271a140c0843cf655846509b36f045", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t\tinferenceContext = new InferenceContext(originalMethod);", "-\t\t\tmethodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);", "-\t\t\tif (methodSubstitute == null)", "-\t\t\t\treturn null;", "-\t\t\t", "-\t\t\t// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method", "-\t\t\t// 15.12.2.8 - inferring unresolved type arguments", "-\t\t\tif (inferenceContext.hasUnresolvedTypeArgument()) {", "-\t\t\t\tif (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7", "-\t\t\t\t\tint length = inferenceContext.substitutes.length;", "-\t\t\t\t\tSystem.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);", "-\t\t\t\t}", "-\t\t\t\tif (methodSubstitute.returnType != TypeBinding.VOID) {", "-\t\t\t\t\tTypeBinding expectedType = invocationSite.expectedType();", "-\t\t\t\t\tif (expectedType != null) {", "-\t\t\t\t\t\t// record it was explicit from context, as opposed to assumed by default (see below)", "-\t\t\t\t\t\tinferenceContext.hasExplicitExpectedType = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\texpectedType = scope.getJavaLangObject(); // assume Object by default", "+", "+// ==== 1.8: The main driver for inference of generic methods: ====", "+\t\t\tInferenceContext18 infCtx18 = null;", "+\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)", "+\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\t\tif (infCtx18 != null) {", "+\t\t\t\tint checkKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "+\t\t\t\t// 18.5.1 (Applicability):", "+\t\t\t\tboolean isDiamond = originalMethod.isConstructor()", "+\t\t\t\t\t\t&& invocationSite instanceof Expression", "+\t\t\t\t\t\t&& ((Expression)invocationSite).isPolyExpression(originalMethod);", "+\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "+\t\t\t\ttry {", "+\t\t\t\t\tBoundSet provisionalResult = infCtx18.solve();", "+\t\t\t\t\tif (provisionalResult == null && originalMethod.isVarargs()) {", "+\t\t\t\t\t\t// check for variable arity applicability", "+\t\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope); // start over", "+\t\t\t\t\t\tcheckKind = InferenceContext18.CHECK_VARARG;", "+\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "+\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "-\t\t\t\t\tinferenceContext.expectedType = expectedType;", "+\t\t\t\t\tBoundSet result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()", "+\t\t\t\t\tif (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {", "+\t\t\t\t\t\t// 18.5.2 (Invocation type):", "+\t\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "+\t\t\t\t\t\tboolean hasReturnProblem = false;", "+\t\t\t\t\t\tboolean invocationTypeInferred = false;", "+\t\t\t\t\t\tif (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {", "+\t\t\t\t\t\t\tresult = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod, checkKind);", "+\t\t\t\t\t\t\tinvocationTypeInferred = true;", "+\t\t\t\t\t\t\thasReturnProblem |= result == null;", "+\t\t\t\t\t\t\tif (hasReturnProblem)", "+\t\t\t\t\t\t\t\tresult = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// we're not yet ready for invocation type inference", "+\t\t\t\t\t\t\tresult = provisionalResult;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tTypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);", "+\t\t\t\t\t\tif (solutions != null) {", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tmethodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif (InferenceContext18.SIMULATE_BUG_JDK_8026527 && expectedType != null && methodSubstitute.returnType instanceof ReferenceBinding)", "+\t\t\t\t\t\t\t\thasReturnProblem &= !methodSubstitute.returnType.erasure().isCompatibleWith(expectedType);", "+\t\t\t\t\t\t\tif (hasReturnProblem) {", "+\t\t\t\t\t\t\t\tProblemMethodBinding problemMethod = new ProblemMethodBinding(methodSubstitute, methodSubstitute.selector, parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);", "+\t\t\t\t\t\t\t\tproblemMethod.returnType = invocationSite.invocationTargetType();", "+\t\t\t\t\t\t\t\tproblemMethod.inferenceContext = infCtx18;", "+\t\t\t\t\t\t\t\treturn problemMethod;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (invocationSite instanceof Invocation) {", "+\t\t\t\t\t\t\t\tInvocation invocation = (Invocation)invocationSite;", "+\t\t\t\t\t\t\t\tinvocation.setInferenceKind(checkKind);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (invocationTypeInferred) {", "+\t\t\t\t\t\t\t\tif (invocationSite instanceof PolyExpression)", "+\t\t\t\t\t\t\t\t\t((PolyExpression) invocationSite).markInferenceFinished();\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tinfCtx18.rebindInnerPolies(result, arguments);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak computeSubstitutes;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn null;", "+\t\t\t\t} catch (InferenceFailureException e) {", "+\t\t\t\t\t// FIXME stop-gap measure", "+\t\t\t\t\tscope.problemReporter().genericInferenceError(e.getMessage(), invocationSite);", "+\t\t\t\t\treturn null;", "-\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);", "+\t\t\t} else {", "+// ==== 1.8 ====", "+\t\t\t\tinferenceContext = new InferenceContext(originalMethod);", "+\t\t\t\tmethodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);", "+\t\t\t\t", "+\t\t\t\t// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method", "+\t\t\t\t// 15.12.2.8 - inferring unresolved type arguments", "+\t\t\t\tif (inferenceContext.hasUnresolvedTypeArgument()) {", "+\t\t\t\t\tif (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7", "+\t\t\t\t\t\tint length = inferenceContext.substitutes.length;", "+\t\t\t\t\t\tSystem.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (methodSubstitute.returnType != TypeBinding.VOID) {", "+\t\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "+\t\t\t\t\t\tif (expectedType != null) {", "+\t\t\t\t\t\t\t// record it was explicit from context, as opposed to assumed by default (see below)", "+\t\t\t\t\t\t\tinferenceContext.hasExplicitExpectedType = true;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\texpectedType = scope.getJavaLangObject(); // assume Object by default", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tinferenceContext.expectedType = expectedType;", "+\t\t\t\t\t}", "+\t\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);", "+\t\t\t\t\tif (methodSubstitute == null)", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e63528e402b9845839ca2e66b02c09a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "09f42f58bcdf2fa84ccd2b8b65f28ab3036222ca", "commitAfterChange": "57e8dd41219d846363c918d62edb5007994c5c79", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, \t\t\tInvocationSite invocationSite, int inferenceLevel)", "diff": ["-\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "+\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,", "+\t\t\tInvocationSite invocationSite, int inferenceLevel)", "+\t{", "-\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)", "-\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\tif ((inferenceLevel & Scope.APPLICABILITY) != 0)", "+\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope);", "+\t\t\t\telse if (invocationSite instanceof Invocation && originalMethod instanceof ParameterizedGenericMethodBinding)", "+\t\t\t\t\tinfCtx18 = ((Invocation) invocationSite).getInferenceContext((ParameterizedGenericMethodBinding) originalMethod);", "+\t\t\t}", "-\t\t\t\tint checkKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "-\t\t\t\t// 18.5.1 (Applicability):", "-\t\t\t\tboolean isDiamond = originalMethod.isConstructor()", "-\t\t\t\t\t\t&& invocationSite instanceof Expression", "-\t\t\t\t\t\t&& ((Expression)invocationSite).isPolyExpression(originalMethod);", "-\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "-\t\t\t\t\tBoundSet provisionalResult = infCtx18.solve();", "-\t\t\t\t\tif (provisionalResult == null && originalMethod.isVarargs()) {", "-\t\t\t\t\t\t// check for variable arity applicability", "-\t\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope); // start over", "-\t\t\t\t\t\tcheckKind = InferenceContext18.CHECK_VARARG;", "-\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond, checkKind);", "-\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "-\t\t\t\t\t}", "-\t\t\t\t\tBoundSet result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()", "-\t\t\t\t\tif (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {", "-\t\t\t\t\t\t// 18.5.2 (Invocation type):", "-\t\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "-\t\t\t\t\t\tboolean hasReturnProblem = false;", "-\t\t\t\t\t\tboolean invocationTypeInferred = false;", "-\t\t\t\t\t\tif (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT) {", "-\t\t\t\t\t\t\tresult = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod, checkKind);", "-\t\t\t\t\t\t\tinvocationTypeInferred = true;", "-\t\t\t\t\t\t\thasReturnProblem |= result == null;", "-\t\t\t\t\t\t\tif (hasReturnProblem)", "-\t\t\t\t\t\t\t\tresult = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// we're not yet ready for invocation type inference", "-\t\t\t\t\t\t\tresult = provisionalResult;", "+\t\t\t\t\tBoundSet provisionalResult = null;", "+\t\t\t\t\tBoundSet result = null;", "+\t\t\t\t\tif ((inferenceLevel & Scope.APPLICABILITY) != 0) {", "+", "+\t\t\t\t\t\t// ---- 18.5.1 (Applicability): ----", "+\t\t\t\t\t\tboolean isDiamond = originalMethod.isConstructor()", "+\t\t\t\t\t\t\t\t&& invocationSite instanceof Expression", "+\t\t\t\t\t\t\t\t&& ((Expression)invocationSite).isPolyExpression(originalMethod);", "+\t\t\t\t\t\tif (arguments.length == parameters.length) {", "+\t\t\t\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.", "+\t\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);", "+\t\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "+\t\t\t\t\t\tif (provisionalResult == null && originalMethod.isVarargs()) {", "+\t\t\t\t\t\t\t// check for variable-arity applicability", "+\t\t\t\t\t\t\tinfCtx18 = invocationSite.freshInferenceContext(scope); // start over", "+\t\t\t\t\t\t\tinfCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;", "+\t\t\t\t\t\t\tinfCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);", "+\t\t\t\t\t\t\tprovisionalResult = infCtx18.solve();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {", "+\t\t\t\t\t\t\tinfCtx18.storedSolution = provisionalResult;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tprovisionalResult = infCtx18.storedSolution;", "+\t\t\t\t\t}", "+\t\t\t\t\tresult = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()", "+", "+\t\t\t\t\tTypeBinding expectedType = invocationSite.invocationTargetType();", "+\t\t\t\t\tboolean hasReturnProblem = false;", "+\t\t\t\t\tboolean invocationTypeInferred = false;", "+\t\t\t\t\tif ((inferenceLevel & Scope.INVOCATION_TYPE) != 0 // requested?", "+\t\t\t\t\t\t\t&& (expectedType != null || invocationSite.getExpressionContext() == ExpressionContext.VANILLA_CONTEXT)) { // possible?", "+", "+\t\t\t\t\t\t// ---- 18.5.2 (Invocation type): ----", "+\t\t\t\t\t\tresult = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);", "+\t\t\t\t\t\tinvocationTypeInferred = true;", "+\t\t\t\t\t\thasReturnProblem |= result == null;", "+\t\t\t\t\t\tif (hasReturnProblem)", "+\t\t\t\t\t\t\tresult = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// we're not yet ready for invocation type inference", "+\t\t\t\t\t\tresult = provisionalResult;", "+\t\t\t\t\t}", "+", "+\t\t\t\t\tif (result != null) {", "+\t\t\t\t\t\t// assemble the solution etc:", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (InferenceContext18.SIMULATE_BUG_JDK_8026527 && expectedType != null && methodSubstitute.returnType instanceof ReferenceBinding)", "-\t\t\t\t\t\t\t\thasReturnProblem &= !methodSubstitute.returnType.erasure().isCompatibleWith(expectedType);", "-\t\t\t\t\t\t\tif (hasReturnProblem) {", "-\t\t\t\t\t\t\t\tProblemMethodBinding problemMethod = new ProblemMethodBinding(methodSubstitute, methodSubstitute.selector, parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);", "-\t\t\t\t\t\t\t\tproblemMethod.returnType = invocationSite.invocationTargetType();", "-\t\t\t\t\t\t\t\tproblemMethod.inferenceContext = infCtx18;", "-\t\t\t\t\t\t\t\treturn problemMethod;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (invocationSite instanceof Invocation) {", "-\t\t\t\t\t\t\t\tInvocation invocation = (Invocation)invocationSite;", "-\t\t\t\t\t\t\t\tinvocation.setInferenceKind(checkKind);", "+\t\t\t\t\t\t\tif (hasReturnProblem) { // illegally working from the provisional result?", "+\t\t\t\t\t\t\t\tMethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);", "+\t\t\t\t\t\t\t\tif (problemMethod instanceof ProblemMethodBinding)", "+\t\t\t\t\t\t\t\t\treturn problemMethod;", "-\t\t\t\t\t\t\t\tif (invocationSite instanceof PolyExpression)", "-\t\t\t\t\t\t\t\t\t((PolyExpression) invocationSite).markInferenceFinished();\t\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\t\tinfCtx18.rebindInnerPolies(result, arguments);", "+\t\t\t\t\t\t\t\tinfCtx18.rebindInnerPolies(result, methodSubstitute.parameters);", "+\t\t\t\t\t\t\t\treturn methodSubstitute.boundCheck18(scope, arguments);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (invocationSite instanceof Invocation)", "+\t\t\t\t\t\t\t\t\t((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later", "+\t\t\t\t\t\t\t\treturn methodSubstitute;", "-\t\t\t\t\t\t\tbreak computeSubstitutes;"]}], "num": 49299}