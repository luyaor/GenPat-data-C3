{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "17f3b87a2c2e851c4e7ce416bcd2dc1e", "detectedBy": ["DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2eef786d16e3f53f4aefce427ad7693a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/IncrementalImageBuilder.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r \tpublic void applySourceDelta(Hashtable deltas)", "signatureAfterChange": "\r public void applySourceDelta(Hashtable deltas)", "diff": ["-\t */\r", "-\tpublic void applySourceDelta(Hashtable deltas) {\r", "-\t\tfNotifier = new BuildNotifier(fDC, false);\r", "-\t\tfNotifier.begin();\r", "-\t\tfNotifier.subTask(\"Preparing for build\");\r", "-\t\tfSourceDeltas = deltas;\r", "-\t\tfNewState = fOldState.copy(fNewProject, fImageContext);\r", "-\r", "-\t\t// options might have changed since last builder run, thus refresh them\r", "-\t\tfCompilerOptions =\r", "-\t\t\tJavaModelManager.convertConfigurableOptions(JavaCore.getOptions());\r", "-\t\tfNewState.setCompilerOptions(fCompilerOptions);\r", "-\r", "-\t\ttry {\r", "-\t\t\t/* find out what has changed at the package level */\r", "-\t\t\tfNotifier.subTask(\"Analyzing packages\");\r", "-\t\t\tcomputeAllPackages();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* update the package map */\r", "-\t\t\tupdatePackageMap();\r", "-\t\t\tfNewState.canonicalizeBuildContext();\r", "-\t\t\tfNotifier.updateProgressDelta(0.05f);\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* Update the source element table and namespace table for the removed and changed packages.\r", "-\t\t\t * The tables are simply deleted.  They will be rebuilt lazily for changed packages. */\r", "-\t\t\tfor (Enumeration e = fRemovedPackageHandles.elements(); e.hasMoreElements();) {\r", "-\t\t\t\tIPackage pkgHandle = (IPackage) e.nextElement();\r", "-\t\t\t\tfNewState.getSourceElementTable().removePackage(pkgHandle);\r", "-\t\t\t}\r", "-\t\t\trecomputeSourceEntriesForChangedPackages();\r", "-\t\t\tcheckCancel();\r", "-\t\t\tfWorkQueue = new WorkQueue();\r", "-\r", "-\t\t\t/* rebuild the namespaces and issue indictments for changes */\r", "-\t\t\tcomputeNamespaceChanges();\r", "-\t\t\t// 1G220B5 - force compilation of all their dependents as well - only one level deeper\r", "-\t\t\tfor (Enumeration e = fWorkQueue.getElementsToCompile().elements();\r", "-\t\t\t\te.hasMoreElements();\r", "-\t\t\t\t) {\r", "-\t\t\t\tmarkDependentsAsNeedingCompile(e.nextElement());\r", "-\t\t\t}\r", "-\r", "-\t\t\t/* find out what has changed at the package element level */\r", "-\t\t\tfNotifier.subTask(\"Analyzing sources\");\r", "-\t\t\tcomputeAllClasses();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* All dependents of changed zips will need compiling */\r", "-\t\t\tmarkDependentsOfChangedZips();\r", "-\r", "-\t\t\t/* remove old classes and get affected JCUs */\r", "-\t\t\tremoveOldClasses();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* flag changed classes and get compilation units to compile */\r", "-\t\t\tupdateChangedClasses();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* adding new classes might hide (equivalent to delete) old classes */\r", "-\t\t\taddNewClasses();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\tfloat amountPerIteration = 0.60f;\r", "-\t\t\t// Approximation of n + (n/4) + (n/16) + ... = 0.85\r", "-\r", "-\t\t\t/* keep compiling until there is nothing left to compile */\r", "-\t\t\tVector vToCompile = fWorkQueue.getElementsToCompile();\r", "-\t\t\twhile (vToCompile.size() != 0) {\r", "-\t\t\t\tfNotifier.setProgressPerCompilationUnit(amountPerIteration / vToCompile.size());\r", "-\t\t\t\tcompile(vToCompile);\r", "-\t\t\t\tvToCompile = fWorkQueue.getElementsToCompile();\r", "-\t\t\t\tamountPerIteration *= 0.25f;\r", "-\t\t\t}\r", "-\r", "-\t\t\t//\t\tnot using PrincipalStructureByPackageTable\r", "-\t\t\t//\t\tpropagatePrincipalStructureByPackageTable();\r", "-\r", "-\t\t\t// Force all in build context\r", "-\t\t\t/*\r", "-\t\t\tDon't force -- we're not doing lazy builds.\r", "-\t\t\t\r", "-\t\t\tif (fAddedPackageHandles.size() > 0 || fChangedPackageHandles.size() > 0) {\r", "-\t\t\tfor (int i = 0; i < fAddedPackageHandles.size(); ++i) {\r", "-\t\t\tIPackage pkg = (IPackage) fAddedPackageHandles.elementAt(i);\r", "-\t\t\tmaybeForce(pkg);\r", "-\t\t\t}\r", "-\t\t\tfor (int i = 0; i < fChangedPackageHandles.size(); ++i) {\r", "-\t\t\tIPackage pkg = (IPackage) fChangedPackageHandles.elementAt(i);\r", "-\t\t\tmaybeForce(pkg);\r", "-\t\t\t}\r", "-\t\t\t}\t\t\r", "-\t\t\t*/\r", "-\t\t\t/* Update resources in binary output */\r", "-\t\t\tIResourceDelta projectDelta = (IResourceDelta) deltas.get(fNewProject);\r", "-\t\t\tif (projectDelta != null) {\r", "-\t\t\t\tProjectResourceCopier copier =\r", "-\t\t\t\t\tnew ProjectResourceCopier(fNewState.getJavaProject(), fDC, fNotifier, 0.10f);\r", "-\t\t\t\tcopier.updateAffectedResources(projectDelta);\r", "-\t\t\t}\r", "-\r", "-\t\t\t/* Removals and recompilations can leave unused namespace nodes in the \r", "-\t\t\t * dependency graph.  Clean them up. */\r", "-\t\t\tcleanupUnusedNamespaceNodes();\r", "-\t\t\tcheckCancel();\r", "-\r", "-\t\t\t/* Copy resource to binary output */\r", "-\t\t\t//copyResources(projectDelta, 0.05f);\r", "-\r", "-\t\t\tfNotifier.done();\r", "-\t\t} finally {\r", "-\t\t\tcleanUp();\r", "-\t\t}\r", "-\t}\r", "+ */\r", "+public void applySourceDelta(Hashtable deltas) {\r", "+\tfNotifier = new BuildNotifier(fDC, false);\r", "+\tfNotifier.begin();\r", "+\tfNotifier.subTask(Util.bind(\"build.preparingBuild\"/*nonNLS*/));\r", "+\tfSourceDeltas = deltas;\r", "+\tfNewState = fOldState.copy(fNewProject, fImageContext);\r", "+\r", "+\t// options might have changed since last builder run, thus refresh them\r", "+\tfCompilerOptions = JavaModelManager.convertConfigurableOptions(JavaCore.getOptions());\r", "+\tfNewState.setCompilerOptions(fCompilerOptions);\r", "+\t\r", "+\ttry {\r", "+\t\t/* find out what has changed at the package level */\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzingPackage\"/*nonNLS*/));\r", "+\t\tcomputeAllPackages();\r", "+\t\tcheckCancel();\r", "+\r", "+\t\t/* update the package map */\r", "+\t\tupdatePackageMap();\r", "+\t\tfNewState.canonicalizeBuildContext();\r", "+\t\tfNotifier.updateProgressDelta(0.05f);\r", "+\t\tcheckCancel();\r", "+\r", "+\t\t/* Update the source element table and namespace table for the removed and changed packages.\r", "+\t\t * The tables are simply deleted.  They will be rebuilt lazily for changed packages. */\r", "+\t\tfor (Enumeration e = fRemovedPackageHandles.elements(); e.hasMoreElements();) {\r", "+\t\t\tIPackage pkgHandle = (IPackage) e.nextElement();\r", "+\t\t\tfNewState.getSourceElementTable().removePackage(pkgHandle);\r", "+\t\t}\r", "+\t\trecomputeSourceEntriesForChangedPackages();\r", "+\t\tcheckCancel();\r", "+\t\tfWorkQueue = new WorkQueue();\r", "+\r", "+\t\t/* rebuild the namespaces and issue indictments for changes */\r", "+\t\tcomputeNamespaceChanges();\r", "+\t\t// 1G220B5 - force compilation of all their dependents as well - only one level deeper\r", "+\t\tfor (Enumeration e = fWorkQueue.getElementsToCompile().elements(); e.hasMoreElements();) {\r", "+\t\t\tmarkDependentsAsNeedingCompile(e.nextElement());\r", "+\t\t}\r", "+\t\t\r", "+\t\t/* find out what has changed at the package element level */\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzingSources\"/*nonNLS*/));\r", "+\t\tcomputeAllClasses();\r", "+\t\tcheckCancel();\r", "+\r", "+\t\t/* All dependents of changed zips will need compiling */\r", "+\t\tmarkDependentsOfChangedZips();\r", "+\r", "+\t\t/* remove old classes and get affected JCUs */\r", "+\t\tremoveOldClasses();\r", "+\t\tcheckCancel();\r", "+\r", "+\t\t/* flag changed classes and get compilation units to compile */\r", "+\t\tupdateChangedClasses();\r", "+\t\tcheckCancel();\r", "+\r", "+\t\t/* adding new classes might hide (equivalent to delete) old classes */\r", "+\t\taddNewClasses();\r", "+\t\tcheckCancel();\r", "+\t\t\r", "+\t\tfloat amountPerIteration = 0.60f; // Approximation of n + (n/4) + (n/16) + ... = 0.85\r", "+\r", "+\t\t/* keep compiling until there is nothing left to compile */\r", "+\t\tVector vToCompile = fWorkQueue.getElementsToCompile();\r", "+\t\twhile (vToCompile.size() != 0) {\r", "+\t\t\tfNotifier.setProgressPerCompilationUnit(amountPerIteration / vToCompile.size());\r", "+\t\t\tcompile(vToCompile);\r", "+\t\t\tvToCompile = fWorkQueue.getElementsToCompile();\r", "+\t\t\tamountPerIteration *= 0.25f;\r", "+\t\t//\t\tnot using PrincipalStructureByPackageTable\r", "+\t\t//\t\tpropagatePrincipalStructureByPackageTable();\r", "+\r", "+\t\t// Force all in build context\r", "+\t\t/*\r", "+\t\tDon't force -- we're not doing lazy builds.\r", "+\t\t\r", "+\t\tif (fAddedPackageHandles.size() > 0 || fChangedPackageHandles.size() > 0) {\r", "+\t\tfor (int i = 0; i < fAddedPackageHandles.size(); ++i) {\r", "+\t\tIPackage pkg = (IPackage) fAddedPackageHandles.elementAt(i);\r", "+\t\tmaybeForce(pkg);\r", "+\t\t}\r", "+\t\tfor (int i = 0; i < fChangedPackageHandles.size(); ++i) {\r", "+\t\tIPackage pkg = (IPackage) fChangedPackageHandles.elementAt(i);\r", "+\t\tmaybeForce(pkg);\r", "+\t\t}\r", "+\t\t}\t\t\r", "+\t\t*/\r", "+\t\t/* Update resources in binary output */\r", "+\t\tIResourceDelta projectDelta = (IResourceDelta) deltas.get(fNewProject);\r", "+\t\tif (projectDelta != null) {\r", "+\t\t\tProjectResourceCopier copier = new ProjectResourceCopier(fNewState.getJavaProject(), fDC, fNotifier, 0.10f);\r", "+\t\t\tcopier.updateAffectedResources(projectDelta);\r", "+\t\t}\r", "+\t\t\r", "+\t\t/* Removals and recompilations can leave unused namespace nodes in the \r", "+\t\t * dependency graph.  Clean them up. */\r", "+\t\tcleanupUnusedNamespaceNodes();\r", "+\t\tcheckCancel();\r", "+\t\t\r", "+\t\t/* Copy resource to binary output */\r", "+\t\t//copyResources(projectDelta, 0.05f);\r", "+\t\t\r", "+\t\tfNotifier.done();\r", "+\t} finally {\r", "+\t\tcleanUp();\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cba0e05bd7f2939eb263e63f0b3f50f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/IncrementalImageBuilder.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tprotected void computeNamespaceChanges()", "signatureAfterChange": "\r protected void computeNamespaceChanges()", "diff": ["+ */\r", "+protected void computeNamespaceChanges() {\r", "-\t */\r", "-\tprotected void computeNamespaceChanges() {\r", "-\r", "-\t\tfor (Enumeration e = fSourceDeltas.elements(); e.hasMoreElements();) {\r", "-\t\t\tIResourceDelta delta = (IResourceDelta) e.nextElement();\r", "-\t\t\tJavaModelManager.getJavaModelManager().closeAffectedElements(delta);\r", "-\t\t}\r", "-\r", "-\t\t// Should really only process packages in image context here,\r", "-\t\t// but in general other packages may depend on namespaces being added, \r", "-\t\t// not just those being removed and changed.  So for now, process everything.\r", "-\r", "-\t\t// The computations here must be based on the computed namespaces rather than\r", "-\t\t// directly off of the namespace contributions of affected source elements\r", "-\t\t// since the namespace computation may remove items due to conflicts.\r", "-\r", "-\t\tint numPackages =\r", "-\t\t\tfAddedPackageHandles.size()\r", "-\t\t\t\t+ fRemovedPackageHandles.size()\r", "-\t\t\t\t+ fChangedPackageHandles.size();\r", "-\t\tif (numPackages == 0) {\r", "-\t\t\tfNotifier.updateProgressDelta(0.10f);\r", "-\t\t\treturn;\r", "-\t\t}\r", "-\t\tfloat progressDelta = 0.10f / numPackages;\r", "-\r", "-\t\t// Process changes in the set of package prefixes\r", "-\t\tif (fAddedPackageHandles.size() > 0 || fRemovedPackageHandles.size() > 0) {\r", "-\t\t\tcomputePackagePrefixChanges();\r", "-\t\t}\r", "-\r", "-\t\t// Process added packages\r", "-\t\tfor (Enumeration addedPkgs = fAddedPackageHandles.elements();\r", "-\t\t\taddedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) addedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\r", "-\t\t\t// Mark all dependents of missing namespace as needing compile.\r", "-\t\t\tmarkDependentsAsNeedingCompile(pkg);\r", "-\r", "-\t\t\t// If any types currently exist with the same name as this package,\r", "-\t\t\t// they must be recompiled\r", "-\t\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "-\r", "-\t\t// Process removed packages\r", "-\t\tfor (Enumeration removedPkgs = fRemovedPackageHandles.elements();\r", "-\t\t\tremovedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) removedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\r", "-\t\t\t// Mark all dependents of namespace as needing compile.\r", "-\t\t\tmarkDependentsAsNeedingCompile(pkg);\r", "-\r", "-\t\t\t// If any types currently exist with the same name as this package,\r", "-\t\t\t// they must be recompiled\r", "-\t\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "-\r", "-\t\t// Process changed packages\r", "-\t\tfor (Enumeration changedPkgs = fChangedPackageHandles.elements();\r", "-\t\t\tchangedPkgs.hasMoreElements();\r", "-\t\t\t) {\r", "-\t\t\tIPackage pkg = (IPackage) changedPkgs.nextElement();\r", "-\t\t\tfNotifier.subTask(\"Analyzing \" + PackageImpl.readableName(pkg));\r", "-\t\t\tcomputeNamespaceChanges(pkg);\r", "-\t\t\tfNotifier.updateProgressDelta(progressDelta);\r", "-\t\t\tfNotifier.checkCancel();\r", "-\t\t}\r", "+\tfor (Enumeration e = fSourceDeltas.elements(); e.hasMoreElements();) {\r", "+\t\tIResourceDelta delta = (IResourceDelta) e.nextElement();\r", "+\t\tJavaModelManager.getJavaModelManager().closeAffectedElements(delta);\r", "+\t// Should really only process packages in image context here,\r", "+\t// but in general other packages may depend on namespaces being added, \r", "+\t// not just those being removed and changed.  So for now, process everything.\r", "+\r", "+\t// The computations here must be based on the computed namespaces rather than\r", "+\t// directly off of the namespace contributions of affected source elements\r", "+\t// since the namespace computation may remove items due to conflicts.\r", "+\r", "+\tint numPackages = fAddedPackageHandles.size() + fRemovedPackageHandles.size() + fChangedPackageHandles.size();\r", "+\tif (numPackages == 0) {\r", "+\t\tfNotifier.updateProgressDelta(0.10f);\r", "+\t\treturn;\r", "+\t}\r", "+\tfloat progressDelta = 0.10f / numPackages;\r", "+\r", "+\t// Process changes in the set of package prefixes\r", "+\tif (fAddedPackageHandles.size() > 0 || fRemovedPackageHandles.size() > 0) {\r", "+\t\tcomputePackagePrefixChanges();\r", "+\t// Process added packages\r", "+\tfor (Enumeration addedPkgs = fAddedPackageHandles.elements(); addedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) addedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\r", "+\t\t// Mark all dependents of missing namespace as needing compile.\r", "+\t\tmarkDependentsAsNeedingCompile(pkg);\r", "+\r", "+\t\t// If any types currently exist with the same name as this package,\r", "+\t\t// they must be recompiled\r", "+\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+\r", "+\t// Process removed packages\r", "+\tfor (Enumeration removedPkgs = fRemovedPackageHandles.elements(); removedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) removedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\r", "+\t\t// Mark all dependents of namespace as needing compile.\r", "+\t\tmarkDependentsAsNeedingCompile(pkg);\r", "+\r", "+\t\t// If any types currently exist with the same name as this package,\r", "+\t\t// they must be recompiled\r", "+\t\tmarkOverlappingTypesAsNeedingCompile(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+\r", "+\t// Process changed packages\r", "+\tfor (Enumeration changedPkgs = fChangedPackageHandles.elements(); changedPkgs.hasMoreElements();) {\r", "+\t\tIPackage pkg = (IPackage) changedPkgs.nextElement();\r", "+\t\tfNotifier.subTask(Util.bind(\"build.analyzing\"/*nonNLS*/, PackageImpl.readableName(pkg)));\r", "+\t\tcomputeNamespaceChanges(pkg);\r", "+\t\tfNotifier.updateProgressDelta(progressDelta);\r", "+\t\tfNotifier.checkCancel();\r", "+\t}\r", "+}\r"]}], "num": 61136}