{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "85dfad31800d45fab3cde00644398fea", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3459c2843420a7269bc7bec6d9dbf5ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchSet.java", "commitBeforeChange": "abab907ca988de55db9659fc1161de10230e8bdf", "commitAfterChange": "5a0382cf8f4f31c0856d2c7bec7b6965767832d9", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r public void reportMatching(CompilationUnitDeclaration unit) throws CoreException", "signatureAfterChange": "\r public void reportMatching(CompilationUnitDeclaration unit) throws CoreException", "diff": ["-\t\t\tint level = this.locator.pattern.matchLevel(node, true);\r", "-\t\t\tif (level == SearchPattern.ACCURATE_MATCH || level == SearchPattern.INACCURATE_MATCH) {\r", "-\t\t\t\tthis.matchingNodes.put(node, new Integer(level));\r", "+\t\t\tint level;\r", "+\t\t\tif (node instanceof ImportReference) {\r", "+\t\t\t\t// special case for import refs: they don't know their binding\r", "+\t\t\t\tImportReference importRef = (ImportReference)node;\r", "+\t\t\t\tBinding binding;\r", "+\t\t\t\tif (importRef.onDemand) {\r", "+\t\t\t\t\tbinding = unit.scope.getTypeOrPackage(CharOperation.subarray(importRef.tokens, 0, importRef.tokens.length));\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tbinding = unit.scope.getTypeOrPackage(importRef.tokens);\r", "+\t\t\t\t}\r", "+\t\t\t\tlevel = this.locator.pattern.matchLevel(binding);\r", "+\r", "+\t\t\t\tif (level == SearchPattern.ACCURATE_MATCH || level == SearchPattern.INACCURATE_MATCH) {\r", "+\t\t\t\t\t// create defining import handle\r", "+\t\t\t\t\tIJavaElement importHandle = this.locator.createImportHandle(importRef);\r", "+\t\t\t\t\tthis.locator.pattern.matchReportImportRef(\r", "+\t\t\t\t\t\timportRef, \r", "+\t\t\t\t\t\tbinding, \r", "+\t\t\t\t\t\timportHandle, \r", "+\t\t\t\t\t\tlevel == SearchPattern.ACCURATE_MATCH ?\r", "+\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH :\r", "+\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH,\r", "+\t\t\t\t\t\tthis.locator);\r", "+\t\t\t\t}\r", "+\t\t\t} else {\r", "+\t\t\t\tlevel = this.locator.pattern.matchLevel(node, true);\r", "+\t\t\t\tif (level == SearchPattern.ACCURATE_MATCH || level == SearchPattern.INACCURATE_MATCH) {\r", "+\t\t\t\t\tthis.matchingNodes.put(node, new Integer(level));\r", "+\t\t\t\t}\r", "-\tImportReference[] imports = unit.imports;\r", "-\tif (imports != null) {\r", "-\t\tfor (int i = 0; i < imports.length; i++) {\r", "-\t\t\tImportReference importRef = imports[i];\r", "-\t\t\tif ((level = (Integer)this.matchingNodes.remove(importRef)) != null) {\r", "-\t\t\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0) {\r", "-\t\t\t\t\tthis.locator.reportImport(\r", "-\t\t\t\t\t\timportRef, \r", "-\t\t\t\t\t\tlevel.intValue() == SearchPattern.ACCURATE_MATCH ?\r", "-\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH :\r", "-\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);\r", "+\tif (!this.cuHasBeenResolved) {\r", "+\t\tImportReference[] imports = unit.imports;\r", "+\t\tif (imports != null) {\r", "+\t\t\tfor (int i = 0; i < imports.length; i++) {\r", "+\t\t\t\tImportReference importRef = imports[i];\r", "+\t\t\t\tif ((level = (Integer)this.matchingNodes.remove(importRef)) != null) {\r", "+\t\t\t\t\tif ((this.matchContainer & SearchPattern.COMPILATION_UNIT) != 0) {\r", "+\t\t\t\t\t\tthis.locator.reportImport(\r", "+\t\t\t\t\t\t\timportRef, \r", "+\t\t\t\t\t\t\tlevel.intValue() == SearchPattern.ACCURATE_MATCH ?\r", "+\t\t\t\t\t\t\t\tIJavaSearchResultCollector.EXACT_MATCH :\r", "+\t\t\t\t\t\t\t\tIJavaSearchResultCollector.POTENTIAL_MATCH);\r", "+\t\t\t\t\t}\r", "-\t}\r", "+\t} // else import declarations have already been processed above\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1092409be720427d08fe25fe9d0daf5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java", "commitBeforeChange": "146dc3b7afcca724ac2ba30b2cbb382c047a5a77", "commitAfterChange": "916862391ff792c972ae46f3240db598c93015ba", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "diff": ["-\t\tboolean hasTypeVarArgs = false;", "+\t\tboolean hasArgsTypeVar = false;", "-\t\t\t\t} else if (!hasTypeVarArgs) {", "-\t\t\t\t\thasTypeVarArgs = argumentTypes[i].isTypeVariable();", "+\t\t\t\t} else if (!hasArgsTypeVar) {", "+\t\t\t\t\thasArgsTypeVar = argumentTypes[i].isTypeVariable();", "-\t\tthis.binding = (this.receiver != null && this.receiver.isThis())", "-\t\t\t? scope.getImplicitMethod(this.selector, argumentTypes, this)", "-\t\t\t: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);", "+\t\tthis.binding = scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);", "+\t\tif (!this.binding.isValidBinding()) {", "+\t\t\t// Try method in enclosing types", "+\t\t\tTypeBinding enclosingTypeBinding = this.actualReceiverType;", "+\t\t\tMethodBinding methodBinding = this.binding;", "+\t\t\twhile (!methodBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {", "+\t\t\t\tenclosingTypeBinding = enclosingTypeBinding.enclosingType();", "+\t\t\t\tmethodBinding = scope.getMethod(enclosingTypeBinding, this.selector, argumentTypes, this);", "+\t\t\t}", "+\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\tthis.binding = methodBinding;", "+\t\t\t} else {", "+\t\t\t\t// Try to search a constructor instead", "+\t\t\t\tenclosingTypeBinding = this.actualReceiverType;", "+\t\t\t\tMethodBinding contructorBinding = this.binding;", "+\t\t\t\twhile (!contructorBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {", "+\t\t\t\t\tenclosingTypeBinding = enclosingTypeBinding.enclosingType();", "+\t\t\t\t\tif (CharOperation.equals(this.selector, enclosingTypeBinding.shortReadableName())) {", "+\t\t\t\t\t\tcontructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, argumentTypes, this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (contructorBinding.isValidBinding()) {", "+\t\t\t\t\tthis.binding = contructorBinding;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t} else if (hasTypeVarArgs) {", "+\t\t} else if (hasArgsTypeVar) {", "+\t\t} else if (binding.isVarargs()) {", "+\t\t\tint length = argumentTypes.length;", "+\t\t\tif (!(binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {", "+\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\tscope.problemReporter().javadocInvalidMethod(this, problem, scope.getDeclarationModifiers());", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d0bc583f7796f960a0e430da63ad580f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java", "commitBeforeChange": "146dc3b7afcca724ac2ba30b2cbb382c047a5a77", "commitAfterChange": "916862391ff792c972ae46f3240db598c93015ba", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": "  \tprivate TypeBinding internalResolveType(Scope scope)", "diff": ["+\t\t\tReferenceBinding enclosingTypeBinding = allocationType;", "+\t\t\tMethodBinding contructorBinding = this.binding;", "+\t\t\twhile (!contructorBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {", "+\t\t\t\tenclosingTypeBinding = enclosingTypeBinding.enclosingType();", "+\t\t\t\tcontructorBinding = scope.getConstructor(enclosingTypeBinding, argumentTypes, this);", "+\t\t\t}", "+\t\t\tif (contructorBinding.isValidBinding()) {", "+\t\t\t\tthis.binding = contructorBinding;", "+\t\t\t}", "+\t\t}", "+\t\tif (!this.binding.isValidBinding()) {", "+\t\t\t// First try to search a method instead", "+\t\t} else if (binding.isVarargs()) {", "+\t\t\tint length = argumentTypes.length;", "+\t\t\tif (!(binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {", "+\t\t\t\tMethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\tscope.problemReporter().javadocInvalidConstructor(this, problem, scope.getDeclarationModifiers());", "+\t\t\t}"]}], "num": 46927}