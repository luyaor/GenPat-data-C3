{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3955e9188db41d9a1bdd5be917b1b11c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "047710b3cb3715e96d243e370728b50a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java", "commitBeforeChange": "e998ae10322cb7f60a31fc6c5e4772816c1fbc92", "commitAfterChange": "f3aae3085ef4d874b17441c47725356fd2afe319", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r public IClasspathEntry getRawClasspathEntry() throws JavaModelException", "signatureAfterChange": "\r public IClasspathEntry getRawClasspathEntry() throws JavaModelException", "diff": ["+\t\t\tcase IClasspathEntry.CPE_CONTAINER:\r", "+\t\t\t\tIClasspathContainer container = JavaCore.getClasspathContainer(entry.getPath(), this.getJavaProject());\r", "+\t\t\t\tif (container != null){\r", "+\t\t\t\t\tIClasspathEntry[] containerEntries = container.getClasspathEntries();\r", "+\t\t\t\t\tfor (int j = 0; j < containerEntries.length; j++){\r", "+\t\t\t\t\t\tIClasspathEntry containerEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);\r", "+\t\t\t\t\t\tif (containerEntry != null && path.equals(containerEntry.getPath())) {\r", "+\t\t\t\t\t\t\treturn entry; // answer original entry\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04aa633352967d12ab3f6eea5f139b59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/FormatterCommentParser.java", "commitBeforeChange": "0a52fc66fb4db2fd9981d577d974e91228093601", "commitAfterChange": "76d395ddd90431ef7cb4486078cb51e978a5ad63", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " protected boolean parseHtmlTag(int previousPosition, int endTextPosition) throws InvalidInputException", "signatureAfterChange": " protected boolean parseHtmlTag(int previousPosition, int endTextPosition) throws InvalidInputException", "diff": ["+\t\t\t\tif (htmlPtr >= 0) {", "+\t\t    \t\tint lastHtmlTagIndex = getHtmlTagIndex(this.htmlTags[htmlPtr]);", "+\t\t\t\t\tif ((lastHtmlTagIndex & JAVADOC_TAGS_ID_MASK) == JAVADOC_IMMUTABLE_TAGS_ID) {", "+\t\t\t\t\t\t// Do not accept tags inside immutable tags except the <pre> tag", "+\t\t\t\t\t\tif ((htmlIndex & JAVADOC_TAGS_ID_MASK) == JAVADOC_CODE_TAGS_ID) {", "+\t\t\t\t\t\t\tFormatJavadocBlock previousBlock = (FormatJavadocBlock) this.astStack[this.astPtr];", "+\t\t\t\t\t\t\tFormatJavadocNode parentNode = previousBlock;", "+\t\t\t\t\t\t\tFormatJavadocNode lastNode = parentNode;", "+\t\t\t\t\t\t\twhile (lastNode.getLastNode() != null) {", "+\t\t\t\t\t\t\t\tparentNode = lastNode;", "+\t\t\t\t\t\t\t\tlastNode = lastNode.getLastNode();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (lastNode.isText()) {", "+\t\t\t\t\t\t\t\tFormatJavadocText text = (FormatJavadocText) lastNode;", "+\t\t\t\t\t\t\t\tif (text.separatorsPtr == -1) {", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t    \t\t\treturn false;", "+\t\t\t\t\t}", "+\t    \t\t}", "+", "+\t    // Push texts"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ead50abf47cd73c1d552ea6aeb17092", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "a746953c3c39228e621101bf14cd960b61f268e5", "commitAfterChange": "8d9e4d82b7907a3f11b58a9fee1e77dc3999b852", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " static int updateMatchRule(int matchRule)", "signatureAfterChange": " private static boolean validateCamelCasePattern(String stringPattern)", "diff": ["-static int updateMatchRule(int matchRule) {", "-\tif ((matchRule & R_CAMELCASE_MATCH) != 0) {", "-\t\tmatchRule &= ~R_CAMELCASE_MATCH;", "-\t\tmatchRule |= R_CAMEL_CASE_MATCH;", "-\t\tif ((matchRule & (R_PREFIX_MATCH | R_CASE_SENSITIVE)) == 0) {", "-\t\t\tmatchRule |= R_PREFIX_MATCH;", "-\t\t}", "+private static boolean validateCamelCasePattern(String stringPattern) {", "+\tif (stringPattern == null) return true;", "+\t// verify sting pattern validity", "+\tint length = stringPattern.length();", "+\tboolean validCamelCase = true;", "+\tboolean lowerCamelCase = false;", "+\tint uppercase = 0;", "+\tfor (int i=0; i<length && validCamelCase; i++) {", "+\t\tchar ch = stringPattern.charAt(i);", "+\t\tvalidCamelCase = i==0 ? ScannerHelper.isJavaIdentifierStart(ch) : ScannerHelper.isJavaIdentifierPart(ch);", "+\t\t// at least one uppercase character is need in CamelCase pattern", "+\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=136313)", "+\t\tif (ScannerHelper.isUpperCase(ch)) uppercase++;", "+\t\tif (i==0) lowerCamelCase = uppercase == 0;", "-\treturn matchRule;", "+\tif (validCamelCase) {", "+\t\tvalidCamelCase = lowerCamelCase ? uppercase > 0 : uppercase > 1 ;", "+\t}", "+\treturn validCamelCase;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1103182e2577c630539130084b6923ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "fa4cf904b1d5690e02fc0246dbc8bc14a58e5d04", "commitAfterChange": "4ddddb5424dafb4b8650d4349863e03fece6ac06", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 66, "signatureBeforeChange": "  \tprivate char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, int accessFlags)", "signatureAfterChange": "  \tprivate char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, IMethodParametersAttribute parametersAttribute, int accessFlags)", "diff": ["-\tprivate char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, int accessFlags) {", "+\tprivate char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, IMethodParametersAttribute parametersAttribute, int accessFlags) {", "-\t\tif (codeAttribute != null) {", "-\t\t\tILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();", "-\t\t\tif (localVariableAttribute != null) {", "-\t\t\t\tILocalVariableTableEntry[] entries = localVariableAttribute.getLocalVariableTable();", "-\t\t\t\tfinal int startingIndex = (accessFlags & IModifierConstants.ACC_STATIC) != 0 ? 0 : 1;", "-\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "-\t\t\t\t\tILocalVariableTableEntry searchedEntry = getEntryFor(getLocalIndex(startingIndex, i, methodDescriptor), entries);", "-\t\t\t\t\tif (searchedEntry != null) {", "-\t\t\t\t\t\tparameterNames[i] = searchedEntry.getName();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tparameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\tif (parametersAttribute != null) {", "+\t\t\tint parameterCount = parametersAttribute.getMethodParameterLength();", "+\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\tif (i < parameterCount && parametersAttribute.getParameterName(i) != null) {", "+\t\t\t\t\tparameterNames[i] = parametersAttribute.getParameterName(i);", "+\t\t\t\t} else {", "+\t\t} else if (codeAttribute != null) {", "+\t\t\t\tILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();", "+\t\t\t\tif (localVariableAttribute != null) {", "+\t\t\t\t\tILocalVariableTableEntry[] entries = localVariableAttribute.getLocalVariableTable();", "+\t\t\t\t\tfinal int startingIndex = (accessFlags & IModifierConstants.ACC_STATIC) != 0 ? 0 : 1;", "+\t\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\t\t\tILocalVariableTableEntry searchedEntry = getEntryFor(getLocalIndex(startingIndex, i, methodDescriptor), entries);", "+\t\t\t\t\t\tif (searchedEntry != null) {", "+\t\t\t\t\t\t\tparameterNames[i] = searchedEntry.getName();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tparameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\t\t\tparameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33620c39a827cab65da1682150403aca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "f0ba284185943d1b8df039a8beb736a55eeed994", "commitAfterChange": "e51594c408ebb686b1be624626fdc1156c116aa5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] annotations, Binding recipient)", "signatureAfterChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] annotations, Binding recipient)", "diff": ["-\t\t\tannotation.recipient = recipient;", "-\t\t\tannotationTypes[i] = annotation.resolveType(scope);", "-", "-\t\t\t// null if receiver is a package binding", "-\t\t\tif (instances != null)", "-\t\t\t\tinstances[i] = annotation.getCompilerAnnotation();", "+\t\t\tfinal Binding annotationRecipient = annotation.recipient;", "+\t\t\tif (annotationRecipient != null && recipient != null) {", "+\t\t\t\t// only local and field can share annnotations", "+\t\t\t\tswitch (recipient.kind()) {", "+\t\t\t\t\tcase Binding.FIELD :", "+\t\t\t\t\t\tFieldBinding field = (FieldBinding) recipient;", "+\t\t\t\t\t\tfield.tagBits = ((FieldBinding) annotationRecipient).tagBits;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Binding.LOCAL :", "+\t\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) recipient;", "+\t\t\t\t\t\tlocal.tagBits = ((LocalVariableBinding) annotationRecipient).tagBits;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tif (instances != null) {", "+\t\t\t\t\t// need to fill the instances array", "+\t\t\t\t\tinstances[0] = annotation.getCompilerAnnotation();", "+\t\t\t\t\tfor (int j = 1; j < length; j++) {", "+\t\t\t\t\t\tAnnotation annot = annotations[j];", "+\t\t\t\t\t\tinstances[j] = annot.getCompilerAnnotation();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t} else {", "+\t\t\t\tannotation.recipient = recipient;", "+\t\t\t\tannotationTypes[i] = annotation.resolveType(scope);", "+\t\t\t\t// null if receiver is a package binding", "+\t\t\t\tif (instances != null) {", "+\t\t\t\t\tinstances[i] = annotation.getCompilerAnnotation();", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3a4cd501354c551e926c0b3ccc789720", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 122, "methodNumberAfterChange": 122, "signatureBeforeChange": " \tpublic static String typeSignature(TypeReference type)", "signatureAfterChange": " \tpublic static String typeSignature(TypeReference type)", "diff": ["-\t\tchar[][] compoundName = type.getParameterizedTypeName();", "-\t\tchar[] typeName =CharOperation.concatWith(compoundName, '.');", "-\t\tString signature = Signature.createTypeSignature(typeName, false/*don't resolve*/);", "+\t\tString signature = null;", "+\t\tif ((type.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsUnionType) != 0) {", "+\t\t\t// special treatment for union type reference", "+\t\t\tUnionTypeReference unionTypeReference = (UnionTypeReference) type;", "+\t\t\tTypeReference[] typeReferences = unionTypeReference.typeReferences;", "+\t\t\tint length = typeReferences.length;", "+\t\t\tString[] typeSignatures = new String[length];", "+\t\t\tfor(int i = 0; i < length; i++) {", "+\t\t\t\tchar[][] compoundName = typeReferences[i].getParameterizedTypeName();", "+\t\t\t\tchar[] typeName = CharOperation.concatWith(compoundName, '.');", "+\t\t\t\ttypeSignatures[i] = Signature.createTypeSignature(typeName, false/*don't resolve*/);", "+\t\t\t}", "+\t\t\tsignature = Signature.createIntersectionTypeSignature(typeSignatures);", "+\t\t} else {", "+\t\t\tchar[][] compoundName = type.getParameterizedTypeName();", "+\t\t\tchar[] typeName =CharOperation.concatWith(compoundName, '.');", "+\t\t\tsignature = Signature.createTypeSignature(typeName, false/*don't resolve*/);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "41301076b8f47c6ec3a018ac83211fed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "808ee1989aa546fef406f77c37a96f979df5219f", "commitAfterChange": "2528937997399f978f8c04c6800f46f957dbd27f", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 23, "signatureBeforeChange": " public static int validateMatchRule(String stringPattern, int matchRule)", "signatureAfterChange": " public static int validateMatchRule(String stringPattern, int matchRule)", "diff": ["-\t\tif ((matchRule & R_PATTERN_MATCH) != 0 || (matchRule & R_PREFIX_MATCH) != 0 || (matchRule & R_CAMELCASE_MATCH) != 0) {", "+\t\tif ((matchRule & R_PATTERN_MATCH) != 0 || (matchRule & R_PREFIX_MATCH) != 0 || ", "+\t\t\t(matchRule & R_CAMEL_CASE_MATCH) != 0 || (matchRule & R_CAMELCASE_MATCH) != 0) {", "-\t\t// reset pattern match bit if any", "+\t\t// reset pattern match flag if any", "-\t\t// remove Camel Case and Prefix match bits if any", "+\t\t// remove Camel Case and Prefix match flags if any", "+\t\tmatchRule &= ~R_CAMEL_CASE_MATCH;", "-\tif ((matchRule & R_CAMELCASE_MATCH) != 0) {", "+\tif ((matchRule & R_CAMEL_CASE_MATCH) != 0) {", "+\t\tmatchRule &= ~R_CAMELCASE_MATCH; // in case of some user specify both constants", "-\t\t// Verify bits compatibility", "+\t\t// Verify flags compatibility", "+\t\tif (!validCamelCase) {", "+\t\t\tmatchRule &= ~R_CAMEL_CASE_MATCH;", "+\t\t\tmatchRule |= R_PREFIX_MATCH;", "+\t\t}", "+\t}", "+", "+\t// Verify deprecated Camel Case match rule for backward compatibility", "+\telse if ((matchRule & R_CAMELCASE_MATCH) != 0) {", "+\t\t// Verify sting pattern validity", "+\t\tint length = stringPattern.length();", "+\t\tboolean validCamelCase = true;", "+\t\tboolean uppercase = false;", "+\t\tfor (int i=0; i<length && validCamelCase; i++) {", "+\t\t\tchar ch = stringPattern.charAt(i);", "+\t\t\tvalidCamelCase = i==0 ? ScannerHelper.isJavaIdentifierStart(ch) : ScannerHelper.isJavaIdentifierPart(ch);", "+\t\t\t// at least one uppercase character is need in CamelCase pattern", "+\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=136313)", "+\t\t\tif (!uppercase) uppercase = ScannerHelper.isUpperCase(ch);", "+\t\t}", "+\t\tvalidCamelCase = validCamelCase && uppercase;", "+\t\t// Verify flags compatibility"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ef4838be1a1640604c4853f4abfe602", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "241d64f631bbf77014d4fbfc8f74f781b65e5c36", "commitAfterChange": "42e53b3c82f631cac5341438af4d88461f281652", "methodNumberBeforeChange": 80, "methodNumberAfterChange": 81, "signatureBeforeChange": " \tpublic void _testBug51617() throws JavaModelException", "signatureAfterChange": " \tpublic void testBug51617() throws JavaModelException", "diff": ["-\tpublic void _testBug51617() throws JavaModelException {", "+\tpublic void testBug51617() throws JavaModelException {", "+\t\tString [] unbound = { \"e\" };", "-\t\t\tassertNotNull(\"We should have a failure!\", this.failures);", "-\t\t\tassertEquals(\"We should have exactly one failure!\", 1, this.failures.size());", "-\t\t\t// TODO positions cannot be inlined (they will be different if compiled on Linux and run on Windows)", "-\t\t\tString expected = \"Test.java: Reference at <126> in '\\n * @exception e' should be bound!\";", "-\t\t\tString failure = (String) this.failures.remove(0);", "-\t\t\tassertEquals(\"We should have an unbound exception here!\", expected, failure);", "+\t\t\tint size = unbound.length;", "+\t\t\tfor (int i=0, f=0; i<size; i++) {", "+\t\t\t\tassertTrue(\"Invalid number of failures!\", this.failures.size()>f);", "+\t\t\t\tString failure = (String) this.failures.get(f);", "+\t\t\t\tString expected = \"Reference '\"+unbound[i]+\"' should be bound!\";", "+\t\t\t\tif (expected.equals(failure.substring(failure.indexOf(' ')+1))) {", "+\t\t\t\t\tthis.failures.remove(f);", "+\t\t\t\t} else {", "+\t\t\t\t\tf++;\t// skip offending failure", "+\t\t\t\t\ti--;\t// stay on expected string", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tthis.stopOnFailure = true;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5183d137eacc60bf5ac8c6fa3b2bd453", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java", "commitBeforeChange": "40b99e5148bf82c3e66b88907e69f5d1e18e6f74", "commitAfterChange": "85d2c2c8ac37bb6f0260d6630185def87956883b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected void generateClasspathChangeDeltas()", "signatureAfterChange": " \tprotected void generateClasspathChangeDeltas()", "diff": ["-\t\t\t\t\t\tnewSourcePath,", "-\t\t\t\t\t\tnull/*not a source root path*/);", "-\t\t\t\tint sourceAttachmentRootFlags = ", "-\t\t\t\t\tthis.getSourceAttachmentDeltaFlag(", "-\t\t\t\t\t\toldResolvedPath[i].getSourceAttachmentRootPath(),", "-\t\t\t\t\t\tnewResolvedPath[index].getSourceAttachmentRootPath(),", "-\t\t\t\t\t\tnewSourcePath/*in case both root paths are null*/);", "+\t\t\t\t\t\tnewSourcePath);", "+\t\t\t\tIPath oldRootPath = oldResolvedPath[i].getSourceAttachmentRootPath();", "+\t\t\t\tIPath newRootPath = newResolvedPath[index].getSourceAttachmentRootPath();", "+\t\t\t\tint sourceAttachmentRootFlags = getSourceAttachmentDeltaFlag(oldRootPath, newRootPath);", "-\t\t\t\t\taddClasspathDeltas(", "-\t\t\t\t\t\tproject.computePackageFragmentRoots(oldResolvedPath[i]),", "-\t\t\t\t\t\tflags,", "-\t\t\t\t\t\tdelta);", "+\t\t\t\t\taddClasspathDeltas(project.computePackageFragmentRoots(oldResolvedPath[i]), flags, delta);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (oldRootPath == null && newRootPath == null) {", "+\t\t\t\t\t\t// if source path is specified and no root path, it needs to be recomputed dynamically", "+\t\t\t\t\t\t// force detach source on jar package fragment roots (source will be lazily computed when needed)", "+\t\t\t\t\t\tIPackageFragmentRoot[] computedRoots = project.computePackageFragmentRoots(oldResolvedPath[i]);", "+\t\t\t\t\t\tfor (int j = 0; j < computedRoots.length; j++) {", "+\t\t\t\t\t\t\tIPackageFragmentRoot root = computedRoots[j];", "+\t\t\t\t\t\t\t// force detach source on jar package fragment roots (source will be lazily computed when needed)", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\troot.close();", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t\t// ignore", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t((PackageFragmentRoot) root).setSourceAttachmentProperty(null);// loose info - will be recomputed", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t} else {", "+\t\t\tthis.identicalRoots = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "56b386472c15f8d024374b8d5c802872", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CopyPackageFragmentRootOperation.java", "commitBeforeChange": "2137214feeed8e469f6a48ad072ff21bc1eece7e", "commitAfterChange": "41b3af5fb5d6223f4e0dcfced815a29a07861ec5", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprotected void updateDestProjectClasspath( \t\tIClasspathEntry rootEntry, \t\tIWorkspaceRoot workspaceRoot) \t\tthrows JavaModelException", "signatureAfterChange": " \tprotected void updateDestProjectClasspath( \t\tIClasspathEntry rootEntry, \t\tIWorkspaceRoot workspaceRoot) \t\tthrows JavaModelException", "diff": ["+\t\t", "+\t\tIClasspathEntry[] newClasspath;", "+\t\t", "+\t\t// case of existing entry and REPLACE was specified", "+\t\tif ((this.updateModelFlags & IPackageFragmentRoot.REPLACE) != 0) {", "+\t\t\t// find existing entry", "+\t\t\tIPath rootPath = rootEntry.getPath();", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tif (rootPath.equals(classpath[i].getPath())) {", "+\t\t\t\t\tnewClasspath = new IClasspathEntry[length];", "+\t\t\t\t\tSystem.arraycopy(classpath, 0, newClasspath, 0, length);", "+\t\t\t\t\tnewClasspath[i] = copy(rootEntry);", "+\t\t\t\t\tjProject.setRawClasspath(newClasspath, fMonitor);", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t} ", "+\t\t", "+\t\t// other cases", "-\t\tIClasspathEntry[] newClasspath = new IClasspathEntry[length+1];", "+\t\tnewClasspath = new IClasspathEntry[length+1];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "601a66007b85435862b500e82e286a9a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java", "commitBeforeChange": "80e40b4c60040fa0aa8e1c95f16e2597f3f0acf0", "commitAfterChange": "f9277e3d6f326ff6a770d54a63a8fe0127208bbc", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic AnnotationBinding[] getAnnotations()", "signatureAfterChange": "  \tpublic AnnotationBinding[] getAnnotations()", "diff": ["-\t\tif (this.declaringScope == null)", "+\t\tif (this.declaringScope == null) {", "+\t\t\tif ((this.tagBits & TagBits.AnnotationResolved) != 0) {", "+\t\t\t\t// annotation are already resolved", "+\t\t\t\tif (this.declaration == null) {", "+\t\t\t\t\treturn Binding.NO_ANNOTATIONS;", "+\t\t\t\t}", "+\t\t\t\tAnnotation[] annotations = this.declaration.annotations;", "+\t\t\t\tif (annotations != null) {", "+\t\t\t\t\tint length = annotations.length;", "+\t\t\t\t\tAnnotationBinding[] annotationBindings = new AnnotationBinding[length];", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tAnnotationBinding compilerAnnotation = annotations[i].getCompilerAnnotation();", "+\t\t\t\t\t\tif (compilerAnnotation == null) {", "+\t\t\t\t\t\t\treturn Binding.NO_ANNOTATIONS;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tannotationBindings[i] = compilerAnnotation;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn annotationBindings;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "620353baf2e6b9520f71e6b343b37b73", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/Tests.java", "commitBeforeChange": "939badb3c6fe1d2f02856fa68cfae3c871f99594", "commitAfterChange": "1d813f81d1ab9bf28fbd197f33e8c5356ab9bb9d", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprotected void expectingOnlySpecificProblemsFor(IPath root, Problem[] expectedProblems)", "signatureAfterChange": " \tprotected void expectingOnlySpecificProblemsFor(IPath root, Problem[] expectedProblems)", "diff": ["-\t\tfor (int i = 0; i < expectedProblems.length; i++)", "-\t\t\tassertEquals(\"unexpected problem\", expectedProblems[i].toString(), rootProblems[i].toString()); //$NON-NLS-1$", "+\t", "+\t\tfor (int i = 0; i < expectedProblems.length; i++) {", "+\t\t\tProblem expectedProblem = expectedProblems[i];", "+\t\t\tboolean found = false;", "+\t\t\tfor (int j = 0; j < rootProblems.length; j++) {", "+\t\t\t\tif(expectedProblem.equals(rootProblems[j])) {", "+\t\t\t\t\tfound = true;", "+\t\t\t\t\trootProblems[j] = null;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tassertTrue(\"problem not found: \" + expectedProblem.toString(), found); //$NON-NLS-1$", "+\t\t}", "+\t\tfor (int i = 0; i < rootProblems.length; i++) {", "+\t\t\tif(rootProblems[i] != null) {", "+\t\t\t\tassertTrue(\"unexpected problem: \" + rootProblems[i].toString(), false); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "645f4aeb922f3c1dbf23da0517d974b3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "b2caa750738c585e3970cd6cbdee229067bea596", "commitAfterChange": "8d1eb8a1ba1f8d42e85f057c2e74fe0db8cb690d", "methodNumberBeforeChange": 53, "methodNumberAfterChange": 54, "signatureBeforeChange": " \t \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.BinaryExpression expression)", "signatureAfterChange": " \t \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.BinaryExpression expression)", "diff": ["-\t\tif (expression.left instanceof org.eclipse.jdt.internal.compiler.ast.BinaryExpression && ((expression.left.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0)) {", "+\t\tif (expression.left instanceof org.eclipse.jdt.internal.compiler.ast.BinaryExpression", "+\t\t\t\t&& ((expression.left.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0)) {", "-\t\t\t\tif ((((leftOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorMASK) >> org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorSHIFT) != expressionOperatorID && ((leftOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0))", "-\t\t\t\t || ((rightOperand instanceof org.eclipse.jdt.internal.compiler.ast.BinaryExpression && ((rightOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorMASK) >> org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorSHIFT) != expressionOperatorID) && ((rightOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0))) {", "+\t\t\t\tif ((((leftOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorMASK) >> org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorSHIFT) != expressionOperatorID", "+\t\t\t\t\t\t\t&& ((leftOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0))", "+\t\t\t\t\t || ((rightOperand instanceof org.eclipse.jdt.internal.compiler.ast.BinaryExpression", "+\t\t\t\t \t\t\t&& ((rightOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorMASK) >> org.eclipse.jdt.internal.compiler.ast.ASTNode.OperatorSHIFT) != expressionOperatorID)", "+\t\t\t\t\t\t\t&& ((rightOperand.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0))) {", "-\t\t}\t\t", "+\t\t} else if (expression.left instanceof StringLiteralConcetanation", "+\t\t\t\t&& ((expression.left.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.ParenthesizedMASK) == 0)) {", "+\t\t\tStringLiteralConcetanation literal = (StringLiteralConcetanation) expression.left;", "+\t\t\tfinal org.eclipse.jdt.internal.compiler.ast.StringLiteral[] stringLiterals = literal.literals;", "+\t\t\tinfixExpression.setLeftOperand(convert(stringLiterals[0]));", "+\t\t\tinfixExpression.setRightOperand(convert(stringLiterals[1]));", "+\t\t\tfor (int i = 2; i < literal.counter; i++) {", "+\t\t\t\tinfixExpression.extendedOperands().add(convert(stringLiterals[i]));", "+\t\t\t}", "+\t\t\tinfixExpression.extendedOperands().add(convert(expression.right));", "+\t\t\tint startPosition = literal.sourceStart;", "+\t\t\tinfixExpression.setSourceRange(startPosition, expression.sourceEnd - startPosition + 1);", "+\t\t\treturn infixExpression;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6862d8c3fee3a2b2e2bf90e1ebe54cd5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java", "commitBeforeChange": "c16162b1194f3110eda140f5ccdd35c2ba36455d", "commitAfterChange": "8d1ff9b80d2587df4aa2d0a1ee1f5a75472a5feb", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \tprotected void generateClasspathChangeDeltas(\r \t\tIClasspathEntry[] oldResolvedPath,\r \t\tIClasspathEntry[] newResolvedPath,\r \t\tJavaModelManager manager,\r \t\tJavaProject project)", "signatureAfterChange": "\r \tprotected void generateClasspathChangeDeltas(\r \t\tIClasspathEntry[] oldResolvedPath,\r \t\tIClasspathEntry[] newResolvedPath,\r \t\tJavaModelManager manager,\r \t\tJavaProject project)", "diff": ["+\t\t\t\t\r", "+\t\t\t\t// Request indexing of the library\r", "+\t\t\t\tif (changeKind == IClasspathEntry.CPE_LIBRARY) {\r", "+\t\t\t\t\tIndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();\r", "+\t\t\t\t\tif (indexManager != null) {\r", "+\t\t\t\t\t\tboolean pathHasChanged = true;\r", "+\t\t\t\t\t\tIPath newPath = newResolvedPath[i].getPath();\r", "+\t\t\t\t\t\tfor (int j = 0; j < oldResolvedPath.length; j++) {\r", "+\t\t\t\t\t\t\tIClasspathEntry oldEntry = oldResolvedPath[j];\r", "+\t\t\t\t\t\t\tif (oldEntry.getPath().equals(newPath)) {\r", "+\t\t\t\t\t\t\t\tpathHasChanged = false;\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (pathHasChanged) {\r", "+\t\t\t\t\t\t\tindexManager.indexLibrary(newPath, project.getProject());\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "978dee30cda92af8773008dc80bb7017", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyResolver.java", "commitBeforeChange": "e92ab0eafbe7472576da485243db5aa49da5df74", "commitAfterChange": "a4e58088a1010e10b50ef0d8683567f65215eac1", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 26, "signatureBeforeChange": "  \tpublic void consumeLocalVar(char[] varName, int occurrenceCount)", "signatureAfterChange": "  \tpublic void consumeLocalVar(char[] varName, int occurrenceCount)", "diff": ["-\t\t\tthis.scope = this.methodBinding.sourceMethod().scope;", "+\t\t\tAbstractMethodDeclaration sourceMethod = this.methodBinding.sourceMethod();", "+\t\t\tif (sourceMethod != null) {", "+\t\t\t\tthis.scope = sourceMethod.scope;", "+\t\t\t} else {", "+\t\t\t\tchar[][] parameterNames = this.methodBinding.parameterNames;", "+\t\t\t\tfor (int i = 0; i < parameterNames.length; i++) {", "+\t\t\t\t\tif (CharOperation.equals(parameterNames[i], varName)) {", "+\t\t\t\t\t\t// we don't have a compiler binding for this argument, but we can craft one:", "+\t\t\t\t\t\tthis.compilerBinding = new SyntheticLocalVariableBinding(varName, this.methodBinding.parameters[i], this.methodBinding);", "+\t\t\t\t\t\tthis.methodBinding = null;", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-\t \tfor (int i = 0; i < this.scope.localIndex; i++) {", "-\t\t\tLocalVariableBinding local = this.scope.locals[i];", "-\t\t\tif (CharOperation.equals(local.name, varName)", "-\t\t\t\t\t&& occurrenceCount-- == 0) {", "-\t\t\t\tthis.methodBinding = null;", "-\t\t\t\tthis.compilerBinding = local;", "-\t\t\t\treturn;", "+\t\tif (this.scope != null) {", "+\t\t \tfor (int i = 0; i < this.scope.localIndex; i++) {", "+\t\t\t\tLocalVariableBinding local = this.scope.locals[i];", "+\t\t\t\tif (CharOperation.equals(local.name, varName)", "+\t\t\t\t\t\t&& occurrenceCount-- == 0) {", "+\t\t\t\t\tthis.methodBinding = null;", "+\t\t\t\t\tthis.compilerBinding = local;", "+\t\t\t\t\treturn;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab139e0761affcdc7402f54d89c5bfac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "db331d5badcb0b35069c87387ccad89f9c226a52", "commitAfterChange": "30b862416cba759ca39b029e0f535018291e11dc", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " private static boolean canSeeFocus(IJavaElement focus, JavaProject javaProject)", "signatureAfterChange": " private static boolean canSeeFocus(IJavaElement focus, JavaProject javaProject, char[][] focusQualifiedName)", "diff": ["-private static boolean canSeeFocus(IJavaElement focus, JavaProject javaProject) {", "+private static boolean canSeeFocus(IJavaElement focus, JavaProject javaProject, char[][] focusQualifiedName) {", "-\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT && entry.getPath().equals(focusPath))", "+\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT && entry.getPath().equals(focusPath)) {", "+\t\t\t\tif (focusQualifiedName != null) { // builder state is usable, hence use it to try to reduce project which can see the focus...", "+\t\t\t\t\tState projectState = (State) JavaModelManager.getJavaModelManager().getLastBuiltState(javaProject.getProject(), null);", "+\t\t\t\t\tif (projectState != null) {", "+\t\t\t\t\t\tObject[] values = projectState.getReferences().valueTable;", "+\t\t\t\t\t\tint vLength = values.length;", "+\t\t\t\t\t\tfor (int j=0; j<vLength; j++)  {", "+\t\t\t\t\t\t\tif (values[j] == null) continue;", "+\t\t\t\t\t\t\tReferenceCollection references = (ReferenceCollection) values[j];", "+\t\t\t\t\t\t\tif (references.includes(focusQualifiedName)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad588ac9059368d431b514c06c5a1abe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "b2caa750738c585e3970cd6cbdee229067bea596", "commitAfterChange": "8d1eb8a1ba1f8d42e85f057c2e74fe0db8cb690d", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 43, "signatureBeforeChange": " \t \tpublic org.eclipse.jdt.core.dom.NullLiteral convert(org.eclipse.jdt.internal.compiler.ast.NullLiteral expression)", "signatureAfterChange": "  \tpublic InfixExpression convert(StringLiteralConcetanation expression)", "diff": ["-\t", "+", "+\tpublic InfixExpression convert(StringLiteralConcetanation expression) {", "+\t\texpression.computeConstant();", "+\t\tInfixExpression infixExpression = this.ast.newInfixExpression();", "+\t\tinfixExpression.setOperator(InfixExpression.Operator.PLUS);", "+\t\torg.eclipse.jdt.internal.compiler.ast.StringLiteral[] stringLiterals = expression.literals;", "+\t\tinfixExpression.setLeftOperand(convert(stringLiterals[0]));", "+\t\tinfixExpression.setRightOperand(convert(stringLiterals[1]));", "+\t\tfor (int i = 2; i < expression.counter; i++) {", "+\t\t\tinfixExpression.extendedOperands().add(convert(stringLiterals[i]));", "+\t\t}", "+\t\tif (this.resolveBindings) {", "+\t\t\tthis.recordNodes(infixExpression, expression);", "+\t\t}", "+\t\tinfixExpression.setSourceRange(expression.sourceStart, expression.sourceEnd - expression.sourceStart + 1);", "+\t\treturn infixExpression;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b2f5a34912f2a5bd769bcdaf06b4acae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java", "commitBeforeChange": "8cdf54f95656ee372ecbeae181ede3d9dd6c34a8", "commitAfterChange": "ef10fc23511bb08998ebf4a7dfdc62536faa0a9b", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected void generateClasspathChangeDeltas( \t\tIClasspathEntry[] oldResolvedPath, \t\tIClasspathEntry[] newResolvedPath, \t\tJavaModelManager manager, \t\tfinal JavaProject project)", "signatureAfterChange": " \tprotected void generateClasspathChangeDeltas( \t\tIClasspathEntry[] oldResolvedPath, \t\tIClasspathEntry[] newResolvedPath, \t\tJavaModelManager manager, \t\tfinal JavaProject project)", "diff": ["+\t\tMap allRemovedRoots = manager.deltaProcessor.removedRoots;", "+\t\tMap removedRoots = null;", "+\t\tif (allRemovedRoots != null) {", "+\t\t\tremovedRoots = new HashMap();", "+\t\t\tIPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) allRemovedRoots.get(project);", "+\t\t\tfor (int i = 0; i < roots.length; i++) {", "+\t\t\t\tIPackageFragmentRoot root = roots[i];", "+\t\t\t\tremovedRoots.put(root.getPath(), root);", "+\t\t\t}", "+\t\t}", "-\t\t\t\tIPackageFragmentRoot[] pkgFragmentRoots =", "-\t\t\t\t\tproject.getPackageFragmentRoots(oldResolvedPath[i]);", "+\t\t\t\tIPackageFragmentRoot[] pkgFragmentRoots = null;", "+\t\t\t\tif (removedRoots != null) {", "+\t\t\t\t\tpkgFragmentRoots = new IPackageFragmentRoot[] {(IPackageFragmentRoot) removedRoots.get(oldResolvedPath[i].getPath())};", "+\t\t\t\t}", "+\t\t\t\tif (pkgFragmentRoots == null) {", "+\t\t\t\t\tpkgFragmentRoots = project.getPackageFragmentRoots(oldResolvedPath[i]);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "be94d133e6505e78da3cdc81cfbda901", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9f614fc97667efed681d3433770b756cc7555814", "commitAfterChange": "e5350265da2408990b972b2cb2f8a82c97230de1", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "signatureAfterChange": " protected void updateMatch(ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, boolean patternHasTypeParameters, int depth, MatchLocator locator)", "diff": ["-\tboolean isRaw = parameterizedBinding.isRawType()|| (parameterizedBinding.arguments==null && parameterizedBinding.type.isGenericType());", "+\tTypeBinding[] argumentsBindings = parameterizedBinding.arguments;", "+\tboolean isRaw = parameterizedBinding.isRawType()|| (argumentsBindings==null && parameterizedBinding.type.isGenericType());", "-\t\tchar[][] patternArguments =  patternTypeArguments[depth];", "-\t\tupdateMatch(parameterizedBinding.arguments, locator, patternArguments, patternHasTypeParameters);", "+\t\t// verify if this is a reference to the generic type itself", "+\t\tif (!isRaw && patternHasTypeParameters && argumentsBindings != null) {", "+\t\t\tboolean needUpdate = false;", "+\t\t\tTypeVariableBinding[] typeVariables = parameterizedBinding.type.typeVariables();", "+\t\t\tfor (int i=0, l=argumentsBindings.length; i<l; i++) {", "+\t\t\t\tif (argumentsBindings[i] != typeVariables[i]) {", "+\t\t\t\t\tneedUpdate = true;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (needUpdate) {", "+\t\t\t\tchar[][] patternArguments =  patternTypeArguments[depth];", "+\t\t\t\tupdateMatch(argumentsBindings, locator, patternArguments, patternHasTypeParameters);\t", "+\t\t\t}", "+\t\t} else {", "+\t\t\tchar[][] patternArguments =  patternTypeArguments[depth];", "+\t\t\tupdateMatch(argumentsBindings, locator, patternArguments, patternHasTypeParameters);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1c1360a58e0925d24f9685d448e34c7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyResolver.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": "  \tpublic void consumeMethod(char[] selector, char[] signature)", "signatureAfterChange": "  \tpublic void consumeMethod(char[] selector, char[] signature)", "diff": ["+\t\t\t\t} else if ((method.tagBits & TagBits.AnnotationPolymorphicSignature) != 0) {", "+\t\t\t\t\tthis.typeBinding = null;", "+\t\t\t\t\tchar[][] typeParameters = Signature.getParameterTypes(signature);", "+\t\t\t\t\tint length = typeParameters.length;", "+\t\t\t\t\tTypeBinding[] parameterTypes = new TypeBinding[length];", "+\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\tparameterTypes[j] = getType(typeParameters[j]);", "+\t\t\t\t\t}", "+\t\t\t\t\tPolymorphicMethodBinding polymorphicMethod = this.environment.createPolymorphicMethod(method, parameterTypes);", "+\t\t\t\t\tthis.methodBinding = polymorphicMethod;", "+\t\t\t\t\tthis.methodBinding = this.environment.updatePolymorphicMethodReturnType(", "+\t\t\t\t\t\t\tpolymorphicMethod,", "+\t\t\t\t\t\t\tgetType(Signature.getReturnType(signature)));", "+\t\t\t\t\tthis.compilerBinding = this.methodBinding;", "+\t\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d49bc56cab9f075c910368a1382f20e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "d3e68ebc2f073155fc0135042d457eeda516d425", "commitAfterChange": "e2b82109649a9a909e8c958b4e10c6fc85813cdf", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tprotected boolean parseReference() throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference() throws InvalidInputException", "diff": ["-\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidReference(this.scanner.getCurrentTokenStartPosition(), getTokenEndPosition());", "+\t\t\t\t\t\t\tif (this.reportProblems) {", "+\t\t\t\t\t\t\t\tboolean isUrlRef = false;", "+\t\t\t\t\t\t\t\tif (this.tagValue == TAG_SEE_VALUE) {", "+\t\t\t\t\t\t\t\t\tint length=currentError.length, i=1 /* first char is \" */;", "+\t\t\t\t\t\t\t\t\twhile (i<length && ScannerHelper.isLetter(currentError[i])) {", "+\t\t\t\t\t\t\t\t\t\ti++;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (i<(length-2) && currentError[i] == ':' && currentError[i+1] == '/' && currentError[i+2] == '/') {", "+\t\t\t\t\t\t\t\t\t\tisUrlRef = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (isUrlRef) {", "+\t\t\t\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=207765", "+\t\t\t\t\t\t\t\t\t// handle invalid URL references in javadoc with dedicated message", "+\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidSeeUrlReference(this.scanner.getCurrentTokenStartPosition(), getTokenEndPosition());", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidReference(this.scanner.getCurrentTokenStartPosition(), getTokenEndPosition());", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d90e426022f6853d4101a667f6e72786", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/LocalVariable.java", "commitBeforeChange": "6a618f5105b380b0a9a5dc6bfffb855693be7fab", "commitAfterChange": "93613529f4763965d02155d2aaa1cabf71be7897", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " \tpublic String getKey(boolean forceOpen) throws JavaModelException", "signatureAfterChange": " \tpublic String getKey(boolean forceOpen) throws JavaModelException", "diff": ["-\t\t\tStringBuilder buf = new StringBuilder(((IMethod)this.parent).getKey());", "+\t\t\tStringBuilder buf = new StringBuilder();", "+\t\t\tif (this.parent instanceof BinaryMethod)", "+\t\t\t\tbuf.append(((BinaryMethod) this.parent).getKey(forceOpen));", "+\t\t\telse", "+\t\t\t\tbuf.append(((IMethod)this.parent).getKey());", "+\t\t\tif (this.isParameter) {", "+\t\t\t\tILocalVariable[] parameters = ((IMethod) this.parent).getParameters();", "+\t\t\t\tfor (int i = 0; i < parameters.length; i++) {", "+\t\t\t\t\tif (this.equals(parameters[i])) {", "+\t\t\t\t\t\tbuf.append(\"#0#\").append(i); // always first occurrence, followed by parameter rank //$NON-NLS-1$", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddcb2babf7cebc467fec99ced4e10f83", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/HierarchyResolver.java", "commitBeforeChange": "f5c8fa183f49a587ca0e6e41a5167044809abbaf", "commitAfterChange": "f2539f967d6224481505d94554439a7a56cc2d0a", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r private void rememberWithMemberTypes(TypeDeclaration typeDeclaration, HierarchyType enclosingType, ICompilationUnit unit)", "signatureAfterChange": "\r private void rememberWithMemberTypes(TypeDeclaration typeDeclaration, HierarchyType enclosingType, ICompilationUnit unit)", "diff": ["+\t// simple super class name\r", "+\tchar[] superclassName = null;\r", "+\tTypeReference superclass = typeDeclaration.superclass;\r", "+\tif (superclass != null) {\r", "+\t\tchar[][] typeName = superclass.getTypeName();\r", "+\t\tsuperclassName = typeName == null ? null : typeName[typeName.length-1];\r", "+\t}\r", "+\t\r", "+\t// simple super interface names\r", "+\tchar[][] superInterfaceNames = null;\r", "+\tTypeReference[] superInterfaces = typeDeclaration.superInterfaces;\r", "+\tif (superInterfaces != null) {\r", "+\t\tint length = superInterfaces.length;\r", "+\t\tsuperInterfaceNames = new char[length][];\r", "+\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\tTypeReference superInterface = superInterfaces[i];\r", "+\t\t\tchar[][] typeName = superInterface.getTypeName();\r", "+\t\t\tsuperInterfaceNames[i] = typeName[typeName.length-1];\r", "+\t\t}\r", "+\t}\r", "+\r", "+\t\tsuperclassName,\r", "+\t\tsuperInterfaceNames,\r"]}], "num": 61086}