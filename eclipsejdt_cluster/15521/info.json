{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "af5f48c73e1b41f773a1b3f8a6667c6b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7cf1acd09d4fb11df3c2908057141744", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "8d86c45b7dbc1d8316194b358e7234e4491fa695", "commitAfterChange": "0305482ace5c5443f44c914a225574b12096815b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "signatureAfterChange": " \t \tpublic void inferFromExpectedType(TypeBinding expectedType, Scope scope)", "diff": ["-        if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "-            return;", "-        Map substitutes = new HashMap(1);", "-        int length = this.typeArguments.length;", "-        TypeVariableBinding[] originalVariables = this.original().typeVariables;", "-        boolean hasUnboundParameters = false;", "-        for (int i = 0; i < length; i++) {", "-            if (this.typeArguments[i] == originalVariables[i]) {", "-                hasUnboundParameters = true;", "+\t    if ((this.returnType.tagBits & TagBits.HasTypeVariable) == 0) ", "+\t        return;", "+\t    Map substitutes = new HashMap(1);", "+\t    int length = this.typeArguments.length;", "+\t    TypeVariableBinding[] originalVariables = this.original().typeVariables;", "+\t    boolean hasUnboundParameters = false;", "+\t    for (int i = 0; i < length; i++) {", "+\t        if (this.typeArguments[i] == originalVariables[i]) {", "+\t            hasUnboundParameters = true;", "-            } else {", "+\t        } else {", "-            }", "-        }", "-        if (!hasUnboundParameters)", "-            return;", "-        returnType.collectSubstitutes(expectedType, substitutes);", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "-\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\tif (mostSpecificSubstitute == null) {", "-\t\t\t    return; // TODO (philippe) should report no way to infer type", "-\t\t\t}", "-\t\t\tif (mostSpecificSubstitute != VoidBinding) ", "+\t        }", "+\t    }", "+\t    if (!hasUnboundParameters)", "+\t        return;", "+\t    returnType.collectSubstitutes(expectedType, substitutes);", "+\t    if (substitutes.isEmpty()) {", "+\t    \t// raw generic method inferred", "+\t    \tthis.isRaw = true;", "+\t    \tfor (int i = 0; i < length; i++) {", "+\t    \t\tthis.typeArguments[i] = originalVariables[i].erasure();", "+\t    \t}", "+\t    } else {", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) substitutes.get(originalVariables[i]);", "+\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "+\t\t\t\tif (mostSpecificSubstitute == null) {", "+\t\t\t\t    return; // TODO (philippe) should report no way to infer type", "+\t\t\t\t}", "+\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "+\t\t\t\t\t// 15.12.2.8 - any remaining variable is assumed to be Object", "+\t\t\t\t\tmostSpecificSubstitute = scope.getJavaLangObject();", "+\t\t\t\t}\t\t\t\t", "-\t\t}", "+\t\t\t}", "+\t    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b4710da8ceea932d2571b17441d75150", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "0eda4899fe49711eb207c4c5710f5520d9ea2e2d", "commitAfterChange": "4a8da6910e1c14334403dae0988de171cbd44126", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "signatureAfterChange": "  void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[] abstractMethods)", "diff": ["+", "+\t// A subclass inheriting this method and putting it up as the implementation to meet its own", "+\t// obligations should qualify as a use.", "+\tif (concreteMethod.isOrEnclosedByPrivateType())", "+\t\tconcreteMethod.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\tfor (int i = abstractMethods.length; --i >= 0;) {", "+\t\tif (abstractMethods[i].isOrEnclosedByPrivateType())", "+\t\t\tabstractMethods[i].original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t}"]}], "num": 15521}