{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fb5d51a54b4ce74d943e44bdd67581b6", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bcde16db42a44805736be1ce507b5f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "30b5f4681e6bde6cf7c8af9cdfc4f18b157d7133", "commitAfterChange": "a85a8093ef474608272936c6b1e8237aad65c54a", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "signatureAfterChange": " \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "diff": ["-\t\tif (!partialMatch) {", "-\t\t\tint firstDot = name.indexOf('.');", "-\t\t\tString topLevelTypeName = firstDot == -1 ? name : name.substring(0, firstDot);", "-\t\t\t", "-\t\t\t// look in unitsToLookInside first", "-\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "-\t\t\tif (typeMap != null) {", "-\t\t\t\tObject object = typeMap.get(topLevelTypeName);", "-\t\t\t\tif (object instanceof IType) {", "-\t\t\t\t\tIType type = getMemberType((IType) object, name, firstDot);", "-\t\t\t\t\tif (acceptType(type, acceptFlags)) {", "-\t\t\t\t\t\trequestor.acceptType(type);", "-\t\t\t\t\t\treturn; // don't continue with compilation unit", "-\t\t\t\t\t}", "-\t\t\t\t} else if (object instanceof IType[]) {", "-\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "-\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++) {", "-\t\t\t\t\t\tif (requestor.isCanceled())", "-\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t\tIType type = getMemberType(topLevelTypes[i], name, firstDot);", "+\t\tlong start = -1;", "+\t\tif (VERBOSE)", "+\t\t\tstart = System.currentTimeMillis();", "+\t\ttry {", "+\t\t\tif (!partialMatch) {", "+\t\t\t\tint firstDot = name.indexOf('.');", "+\t\t\t\tString topLevelTypeName = firstDot == -1 ? name : name.substring(0, firstDot);", "+\t\t\t\t", "+\t\t\t\t// look in unitsToLookInside first", "+\t\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "+\t\t\t\tif (typeMap != null) {", "+\t\t\t\t\tObject object = typeMap.get(topLevelTypeName);", "+\t\t\t\t\tif (object instanceof IType) {", "+\t\t\t\t\t\tIType type = getMemberType((IType) object, name, firstDot);", "-\t\t\t\t\t\t\treturn; // return the first one", "+\t\t\t\t\t\t\treturn; // don't continue with compilation unit", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (object instanceof IType[]) {", "+\t\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "+\t\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++) {", "+\t\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\tIType type = getMemberType(topLevelTypes[i], name, firstDot);", "+\t\t\t\t\t\t\tif (acceptType(type, acceptFlags)) {", "+\t\t\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t\t\t\treturn; // return the first one", "+\t\t\t\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// look in compilation units", "-\t\t\ttry {", "-\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "-\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "-\t\t\t\t\tif (requestor.isCanceled())", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "-\t\t\t\t\tString cuName = cu.getElementName();", "-\t\t\t\t\tint lastDot = cuName.lastIndexOf('.');", "-\t\t\t\t\tif (!topLevelTypeName.equals(cuName.substring(0, lastDot))) ", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tIType type = cu.getType(topLevelTypeName);", "-\t\t\t\t\ttype = getMemberType(type, name, firstDot);", "-\t\t\t\t\tif (acceptType(type, acceptFlags)) { // accept type checks for existence", "-\t\t\t\t\t\trequestor.acceptType(type);", "-\t\t\t\t\t\tbreak;  // since an exact match was requested, no other matching type can exist", "+\t\t\t\t", "+\t\t\t\t// look in compilation units", "+\t\t\t\ttry {", "+\t\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "+\t\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "+\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "+\t\t\t\t\t\tString cuName = cu.getElementName();", "+\t\t\t\t\t\tint lastDot = cuName.lastIndexOf('.');", "+\t\t\t\t\t\tif (!topLevelTypeName.equals(cuName.substring(0, lastDot))) ", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tIType type = cu.getType(topLevelTypeName);", "+\t\t\t\t\t\ttype = getMemberType(type, name, firstDot);", "+\t\t\t\t\t\tif (acceptType(type, acceptFlags)) { // accept type checks for existence", "+\t\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t\t\tbreak;  // since an exact match was requested, no other matching type can exist", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// package doesn't exist -> ignore", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tString prefix = name.toLowerCase();", "+\t\t\t\tint firstDot = prefix.indexOf('.');", "+\t\t\t\t", "+\t\t\t\t// look in unitsToLookInside first", "+\t\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "+\t\t\t\tif (typeMap != null) {", "+\t\t\t\t\tIterator iterator = typeMap.values().iterator();", "+\t\t\t\t\twhile (iterator.hasNext()) {", "+\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tObject object = iterator.next();", "+\t\t\t\t\t\tif (object instanceof IType) {", "+\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, (IType) object, requestor, acceptFlags);", "+\t\t\t\t\t\t} else if (object instanceof IType[]) {", "+\t\t\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "+\t\t\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++)", "+\t\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, topLevelTypes[i], requestor, acceptFlags);", "+\t\t\t\t\t\t}", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// package doesn't exist -> ignore", "-\t\t\t}", "-\t\t} else {", "-\t\t\tString prefix = name.toLowerCase();", "-\t\t\tint firstDot = prefix.indexOf('.');", "-\t\t\t", "-\t\t\t// look in unitsToLookInside first", "-\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "-\t\t\tif (typeMap != null) {", "-\t\t\t\tIterator iterator = typeMap.values().iterator();", "-\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\tif (requestor.isCanceled())", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\tObject object = iterator.next();", "-\t\t\t\t\tif (object instanceof IType) {", "-\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, (IType) object, requestor, acceptFlags);", "-\t\t\t\t\t} else if (object instanceof IType[]) {", "-\t\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "-\t\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++)", "-\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, topLevelTypes[i], requestor, acceptFlags);", "+\t\t\t\t", "+\t\t\t\t// look in compilation units", "+\t\t\t\ttry {", "+\t\t\t\t\tString cuPrefix = firstDot == -1 ? prefix : prefix.substring(0, firstDot);", "+\t\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "+\t\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "+\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "+\t\t\t\t\t\tif (!cu.getElementName().toLowerCase().startsWith(cuPrefix))", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tIType[] types = cu.getTypes();", "+\t\t\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++)", "+\t\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, types[j], requestor, acceptFlags);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// cu doesn't exist -> ignore", "+\t\t\t\t\t\t}", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// package doesn't exist -> ignore", "-\t\t\t", "-\t\t\t// look in compilation units", "-\t\t\ttry {", "-\t\t\t\tString cuPrefix = firstDot == -1 ? prefix : prefix.substring(0, firstDot);", "-\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "-\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "-\t\t\t\t\tif (requestor.isCanceled())", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "-\t\t\t\t\tif (!cu.getElementName().toLowerCase().startsWith(cuPrefix))", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tIType[] types = cu.getTypes();", "-\t\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++)", "-\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, types[j], requestor, acceptFlags);", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t// cu doesn't exist -> ignore", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// package doesn't exist -> ignore", "-\t\t\t}", "+\t\t} finally {", "+\t\t\tif (VERBOSE)", "+\t\t\t\tthis.timeSpentInSeekTypesInSourcePackage += System.currentTimeMillis()-start;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a27fe6441f1b2e95f831fd779c80b56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "447c4a3138b0e8356dbfa24777955b13411dcda3", "commitAfterChange": "97f850634c52d79fc9e9ec223b5adcbcdf586443", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected void seekTypesInBinaryPackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "signatureAfterChange": " \tprotected void seekTypesInBinaryPackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "diff": ["-\t\tIClassFile[] classFiles= null;", "+\t\tlong start = -1;", "+\t\tif (VERBOSE)", "+\t\t\tstart = System.currentTimeMillis();", "-\t\t\tclassFiles= pkg.getClassFiles();", "-\t\t} catch (JavaModelException npe) {", "-\t\t\treturn; // the package is not present", "-\t\t}", "-\t\tint length= classFiles.length;", "-", "-\t\tString unqualifiedName= name;", "-\t\tint index= name.lastIndexOf('$');", "-\t\tif (index != -1) {", "-\t\t\t//the type name of the inner type", "-\t\t\tunqualifiedName= Util.localTypeName(name, index, name.length());", "-\t\t\t// unqualifiedName is empty if the name ends with a '$' sign.", "-\t\t\t// See http://dev.eclipse.org/bugs/show_bug.cgi?id=14642", "-\t\t}", "-\t\tString matchName= partialMatch ? name.toLowerCase() : name;", "-\t\tfor (int i= 0; i < length; i++) {", "-\t\t\tif (requestor.isCanceled())", "-\t\t\t\treturn;", "-\t\t\tIClassFile classFile= classFiles[i];", "-\t\t\tString elementName = classFile.getElementName();", "-\t\t\tif (partialMatch) elementName = elementName.toLowerCase();", "-", "-\t\t\t/**", "-\t\t\t * Must use startWith because matchName will never have the ", "-\t\t\t * extension \".class\" and the elementName always will.", "-\t\t\t */", "-\t\t\tif (elementName.startsWith(matchName)) {", "-\t\t\t\tIType type= null;", "-\t\t\t\ttry {", "-\t\t\t\t\ttype= classFile.getType();", "-\t\t\t\t} catch (JavaModelException npe) {", "-\t\t\t\t\tcontinue; // the classFile is not present", "-\t\t\t\t}", "-\t\t\t\tif (!partialMatch || (type.getElementName().length() > 0 && !Character.isDigit(type.getElementName().charAt(0)))) { //not an anonymous type", "-\t\t\t\t\tif (nameMatches(unqualifiedName, type, partialMatch) && acceptType(type, acceptFlags, false/*not a source type*/))", "-\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\tIClassFile[] classFiles= null;", "+\t\t\ttry {", "+\t\t\t\tclassFiles= pkg.getClassFiles();", "+\t\t\t} catch (JavaModelException npe) {", "+\t\t\t\treturn; // the package is not present", "+\t\t\t}", "+\t\t\tint length= classFiles.length;", "+\t", "+\t\t\tString unqualifiedName= name;", "+\t\t\tint index= name.lastIndexOf('$');", "+\t\t\tif (index != -1) {", "+\t\t\t\t//the type name of the inner type", "+\t\t\t\tunqualifiedName= Util.localTypeName(name, index, name.length());", "+\t\t\t\t// unqualifiedName is empty if the name ends with a '$' sign.", "+\t\t\t\t// See http://dev.eclipse.org/bugs/show_bug.cgi?id=14642", "+\t\t\t}", "+\t\t\tString matchName= partialMatch ? name.toLowerCase() : name;", "+\t\t\tfor (int i= 0; i < length; i++) {", "+\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\treturn;", "+\t\t\t\tIClassFile classFile= classFiles[i];", "+\t\t\t\tString elementName = classFile.getElementName();", "+\t\t\t\tif (partialMatch) elementName = elementName.toLowerCase();", "+\t", "+\t\t\t\t/**", "+\t\t\t\t * Must use startWith because matchName will never have the ", "+\t\t\t\t * extension \".class\" and the elementName always will.", "+\t\t\t\t */", "+\t\t\t\tif (elementName.startsWith(matchName)) {", "+\t\t\t\t\tIType type= null;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttype= classFile.getType();", "+\t\t\t\t\t} catch (JavaModelException npe) {", "+\t\t\t\t\t\tcontinue; // the classFile is not present", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!partialMatch || (type.getElementName().length() > 0 && !Character.isDigit(type.getElementName().charAt(0)))) { //not an anonymous type", "+\t\t\t\t\t\tif (nameMatches(unqualifiedName, type, partialMatch) && acceptType(type, acceptFlags, false/*not a source type*/))", "+\t\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t}", "+\t\t} finally {", "+\t\t\tif (VERBOSE)", "+\t\t\t\tthis.timeSpentInSeekTypesInBinaryPackage += System.currentTimeMillis()-start;"]}], "num": 34222}