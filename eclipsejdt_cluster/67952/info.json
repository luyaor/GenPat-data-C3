{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "622c86476893141b303c719476ea6a5b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0790767fc377ba5f1beacf40ca644ba8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocFieldReference.java", "commitBeforeChange": "2ce6255dd4ec5ed8642a03ac881dd120c66b8a90", "commitAfterChange": "44812880b1f64f568edbe98bb8d70e4f3eb124f9", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": " \tprotected TypeBinding internalResolveType(Scope scope)", "diff": ["-\t\t\t\tMethodBinding[] methodBindings = refBinding.getMethods(this.token);", "-\t\t\t\tif (methodBindings == null) {", "-\t\t\t\t\tscope.problemReporter().javadocInvalidField(this, fieldBinding, this.receiverType, scope.getDeclarationModifiers());", "+\t\t\t\tMethodBinding possibleMethod = this.receiver.isThis()", "+\t\t\t\t\t? scope.getImplicitMethod(this.token, Binding.NO_TYPES, this)", "+\t\t\t\t\t: scope.getMethod(refBinding, this.token, Binding.NO_TYPES, this);", "+\t\t\t\tif (possibleMethod.isValidBinding()) {", "+\t\t\t\t\tthis.methodBinding = possibleMethod;", "-\t\t\t\t\tswitch (methodBindings.length) {", "-\t\t\t\t\t\tcase 0:", "-\t\t\t\t\t\t\t// no method was found: report problem", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidField(this, fieldBinding, this.receiverType, scope.getDeclarationModifiers());", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase 1:", "-\t\t\t\t\t\t\t// one method binding was found: store binding in specific field", "-\t\t\t\t\t\t\tthis.methodBinding = methodBindings[0];", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t// several method binding were found: store first binding in specific field and report ambiguous error", "-\t\t\t\t\t\t\tthis.methodBinding = methodBindings[0];", "-\t\t\t\t\t\t\tscope.problemReporter().javadocAmbiguousMethodReference(this.sourceStart, this.sourceEnd, fieldBinding, scope.getDeclarationModifiers());", "-\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\tProblemMethodBinding problemMethodBinding = (ProblemMethodBinding) possibleMethod;", "+\t\t\t\t\tif (problemMethodBinding.closestMatch == null) {", "+\t\t\t\t\t\tscope.problemReporter().javadocInvalidField(this, fieldBinding, this.receiverType, scope.getDeclarationModifiers());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.methodBinding = problemMethodBinding.closestMatch;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88bddf48cb5da585c003a61a3b159ad9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "14ba43da4ca84e6aa2e4b0e2b6c660335b90691e", "commitAfterChange": "b7f39314c9eefd05e7002c31c87dcdb0333c0655", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tpublic IPackageFragmentRoot getPackageFragmentRoot(IPath path)", "signatureAfterChange": " \tpublic IPackageFragmentRoot getPackageFragmentRoot(IPath path)", "diff": ["-\t\tswitch (segmentCount) {", "-\t\t\tcase 0:", "-\t\t\t\treturn null;", "-\t\t\tcase 1:", "-\t\t\t\tif (path.equals(getPath())) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=75814", "-\t\t\t\t\t// default root", "-\t\t\t\t\treturn getPackageFragmentRoot(this.project);", "-\t\t\t\t}", "-\t\t\tdefault:", "-\t\t\t\t// a path ending with .jar/.zip is still ambiguous and could still resolve to a source/lib folder ", "-\t\t\t\t// thus will try to guess based on existing resource", "-\t\t\t\tif (org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(path.lastSegment())) {", "-\t\t\t\t\tIResource resource = this.project.getWorkspace().getRoot().findMember(path); ", "-\t\t\t\t\tif (resource != null && resource.getType() == IResource.FOLDER){", "-\t\t\t\t\t\treturn getPackageFragmentRoot(resource);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn getPackageFragmentRoot0(path);", "-\t\t\t\t} else if (segmentCount == 1) {", "-\t\t\t\t\t// lib being another project", "-\t\t\t\t\treturn getPackageFragmentRoot(this.project.getWorkspace().getRoot().getProject(path.lastSegment()));", "-\t\t\t\t} else {", "-\t\t\t\t\t// lib being a folder", "-\t\t\t\t\treturn getPackageFragmentRoot(this.project.getWorkspace().getRoot().getFolder(path));", "-\t\t\t\t}", "+\t\tif (segmentCount == 0) {", "+\t\t\treturn null;", "+\t\tif (path.getDevice() != null || JavaModel.getExternalTarget(path, true/*check existence*/) != null) {", "+\t\t\t// external path", "+\t\t\treturn getPackageFragmentRoot0(path);", "+\t\t}", "+\t\tIWorkspaceRoot workspaceRoot = this.project.getWorkspace().getRoot();", "+\t\tif (segmentCount == 1) {", "+\t\t\tString projectName = path.segment(0);", "+\t\t\tif (getElementName().equals(projectName)) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=75814", "+\t\t\t\t// default root", "+\t\t\t\treturn getPackageFragmentRoot(this.project);", "+\t\t\t} else {", "+\t\t\t\t// lib being another project", "+\t\t\t\treturn getPackageFragmentRoot(workspaceRoot.getProject(projectName));", "+\t\t\t}", "+\t\t}", "+\t\tIResource resource = workspaceRoot.findMember(path); ", "+\t\tif (resource == null) {", "+\t\t\t// resource doesn't exist in workspace", "+\t\t\tif (path.getFileExtension() != null) {", "+\t\t\t\t// assume it is a file", "+\t\t\t\tresource = workspaceRoot.getFile(path);", "+\t\t\t} else {", "+\t\t\t\t// assume it is a folder", "+\t\t\t\tresource = workspaceRoot.getFolder(path);", "+\t\t\t}", "+\t\t}", "+\t\treturn getPackageFragmentRoot(resource);"]}], "num": 67952}