{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "28ebea25a0696b57ad299c7ab2597f27", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1c95106b675f68441674618aa7589d3d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "4e6bb96b0e120539a45cc4860f508bf12e097d37", "commitAfterChange": "ffd0667b5086352f304c15ea4ad31de38892668e", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": "  \t\t\tprivate int getLineBreaksBetween(Token token1, Token token2)", "signatureAfterChange": "  \tint getLineBreaksToPreserve(Token token1, Token token2, boolean isBetweenImports)", "diff": ["-\t\t\tprivate int getLineBreaksBetween(Token token1, Token token2) {", "-\t\t\t\tif (token1 != null) {", "-\t\t\t\t\tList<Token> structure1 = token1.getInternalStructure();", "-\t\t\t\t\tif (structure1 != null && !structure1.isEmpty())", "-\t\t\t\t\t\ttoken1 = structure1.get(structure1.size() - 1);", "-\t\t\t\t}", "-\t\t\t\tList<Token> structure2 = token2.getInternalStructure();", "-\t\t\t\tif (structure2 != null && !structure2.isEmpty())", "-\t\t\t\t\ttoken2 = structure2.get(0);", "-\t\t\t\tint lineBreaks = WrapPreparator.this.tm.countLineBreaksBetween(token1, token2);", "-\t\t\t\tif (token1 == null)", "-\t\t\t\t\tlineBreaks++;", "-\t\t\t\treturn lineBreaks;", "-\t\t\t}", "+\tint getLineBreaksToPreserve(Token token1, Token token2, boolean isBetweenImports) {", "+\t\tif (token1 != null) {", "+\t\t\tList<Token> structure = token1.getInternalStructure();", "+\t\t\tif (structure != null && !structure.isEmpty())", "+\t\t\t\ttoken1 = structure.get(structure.size() - 1);", "+\t\t}", "+\t\tif (token2 != null) {", "+\t\t\tList<Token> structure = token2.getInternalStructure();", "+\t\t\tif (structure != null && !structure.isEmpty())", "+\t\t\t\ttoken2 = structure.get(0);", "+\t\t}", "+\t\tint lineBreaks = WrapPreparator.this.tm.countLineBreaksBetween(token1, token2);", "+\t\tif (isBetweenImports)", "+\t\t\treturn lineBreaks > 1 ? (this.options.blank_lines_between_import_groups + 1) : 0;", "+", "+\t\tint toPreserve = this.options.number_of_empty_lines_to_preserve;", "+\t\tif (token1 != null && token2 != null)", "+\t\t\ttoPreserve++; // n empty lines = n+1 line breaks, except for file start and end", "+\t\tif (token1 != null && token1.tokenType == Token.TokenNameEMPTY_LINE)", "+\t\t\ttoPreserve--;", "+\t\treturn Math.min(lineBreaks, toPreserve);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c21e25020466a98fd250af53dfa92681", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "4e6bb96b0e120539a45cc4860f508bf12e097d37", "commitAfterChange": "ffd0667b5086352f304c15ea4ad31de38892668e", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": "  \tprivate void preserveExistingLineBreaks()", "signatureAfterChange": "  \tprivate void preserveExistingLineBreaks()", "diff": ["-\t\t\t\tint lineBreaks = getLineBreaksBetween(getPrevious(), token);", "-\t\t\t\tif (index > WrapPreparator.this.importsStart && index < WrapPreparator.this.importsEnd) {", "-\t\t\t\t\tlineBreaks = lineBreaks > 1 ? (this.options2.blank_lines_between_import_groups + 1) : 0;", "-\t\t\t\t} else {", "-\t\t\t\t\tlineBreaks = Math.min(lineBreaks, this.options2.number_of_empty_lines_to_preserve + 1);", "-\t\t\t\t}", "+\t\t\t\tboolean isBetweenImports = index > WrapPreparator.this.importsStart && index < WrapPreparator.this.importsEnd;", "+\t\t\t\tint lineBreaks = getLineBreaksToPreserve(getPrevious(), token, isBetweenImports);", "-\t\t\t\tif (!this.options2.join_wrapped_lines && token.isWrappable() && lineBreaks == 1) {", "-\t\t\t\t\ttoken.breakBefore();", "+\t\t\t\tif (lineBreaks == 1) {", "+\t\t\t\t\tif ((!this.options2.join_wrapped_lines && token.isWrappable()) || index == 0)", "+\t\t\t\t\t\ttoken.breakBefore();", "-\t\t\t\t\tif (index == 0)", "-\t\t\t\t\t\tlineBreaks--;", "-\t\t\tprivate int getLineBreaksBetween(Token token1, Token token2) {", "-\t\t\t\tif (token1 != null) {", "-\t\t\t\t\tList<Token> structure1 = token1.getInternalStructure();", "-\t\t\t\t\tif (structure1 != null && !structure1.isEmpty())", "-\t\t\t\t\t\ttoken1 = structure1.get(structure1.size() - 1);", "-\t\t\t\t}", "-\t\t\t\tList<Token> structure2 = token2.getInternalStructure();", "-\t\t\t\tif (structure2 != null && !structure2.isEmpty())", "-\t\t\t\t\ttoken2 = structure2.get(0);", "-\t\t\t\tint lineBreaks = WrapPreparator.this.tm.countLineBreaksBetween(token1, token2);", "-\t\t\t\tif (token1 == null)", "-\t\t\t\t\tlineBreaks++;", "-\t\t\t\treturn lineBreaks;", "-\t\t\t}", "-\t\tint endingBreaks = this.tm.countLineBreaksBetween(last, null);", "-\t\tendingBreaks = Math.min(endingBreaks, this.options.number_of_empty_lines_to_preserve);", "+\t\tint endingBreaks = getLineBreaksToPreserve(last, null, false);"]}], "num": 4430}