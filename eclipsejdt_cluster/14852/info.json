{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3c0de739c626aa76b5959415f7af4d79", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00b253c7ba34413c69d0a3c347d86670", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary( \t\t\tBlockScope currentScope, \t\t\tFieldBinding fieldBinding, \t\t\tTypeBinding lastReceiverType, \t\t\tint index, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBinding fieldBinding, TypeBinding lastReceiverType, \tint index, FlowInfo flowInfo)", "diff": ["-\t */", "-\tpublic void manageSyntheticAccessIfNecessary(", "-\t\t\tBlockScope currentScope,", "-\t\t\tFieldBinding fieldBinding,", "-\t\t\tTypeBinding lastReceiverType,", "-\t\t\tint index,", "-\t\t\tFlowInfo flowInfo) {", "-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "-\t\t// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)", "-\t\tif (fieldBinding.constant() != Constant.NotAConstant)", "+ */", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBinding fieldBinding, TypeBinding lastReceiverType, \tint index, FlowInfo flowInfo) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "+\t// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)", "+\tif (fieldBinding.constant() != Constant.NotAConstant)", "+\t\treturn;", "+", "+\t// if field from parameterized type got found, use the original field at codegen time", "+\tFieldBinding originalField = fieldBinding.original();", "+\tif (originalField != fieldBinding) {", "+\t\tsetCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index, originalField);", "+\t}", "+\t", "+\tif (fieldBinding.isPrivate()) { // private access", "+\t    FieldBinding someCodegenBinding = getCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index);", "+\t\tif (someCodegenBinding.declaringClass != currentScope.enclosingSourceType()) {", "+\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t            ((SourceTypeBinding) someCodegenBinding.declaringClass).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-", "-\t\t// if field from parameterized type got found, use the original field at codegen time", "-\t\tFieldBinding originalField = fieldBinding.original();", "-\t\tif (originalField != fieldBinding) {", "-\t\t\tsetCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index, originalField);", "+\t} else if (fieldBinding.isProtected()){", "+\t    int depth = (index == 0 || (index < 0 && this.otherDepths == null))", "+\t    \t\t? (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT ", "+\t    \t\t : this.otherDepths[index < 0 ? this.otherDepths.length-1 : index-1];", "-\t\tif (fieldBinding.isPrivate()) { // private access", "+\t\t// implicit protected access ", "+\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage())) {", "-\t\t\tif (someCodegenBinding.declaringClass != currentScope.enclosingSourceType()) {", "-\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "-\t\t\t            ((SourceTypeBinding) someCodegenBinding.declaringClass).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t} else if (fieldBinding.isProtected()){", "-\t\t    int depth = (index == 0 || (index < 0 && this.otherDepths == null))", "-\t\t    \t\t? (bits & DepthMASK) >> DepthSHIFT ", "-\t\t    \t\t : otherDepths[index < 0 ? otherDepths.length-1 : index-1];", "-\t\t\t", "-\t\t\t// implicit protected access ", "-\t\t\tif (depth > 0 && (fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage())) {", "-\t\t\t    FieldBinding someCodegenBinding = getCodegenBinding(index < 0 ? (this.otherBindings == null ? 0 : this.otherBindings.length) : index);", "-\t\t\t    setSyntheticAccessor(fieldBinding, index, ", "-\t\t\t            ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth)).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "-\t\t\t\treturn;", "-\t\t\t}", "+\t\t    setSyntheticAccessor(fieldBinding, index, ", "+\t\t            ((SourceTypeBinding) currentScope.enclosingSourceType().enclosingTypeAt(depth)).addSyntheticMethod(someCodegenBinding, index >= 0 /*read-access?*/));", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(someCodegenBinding, this, index >= 0 /*read-access?*/);", "+\t\t\treturn;", "-\t\t// if the binding declaring class is not visible, need special action", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t// and not from Object or implicit static field access.\t", "-\t\tif (fieldBinding.declaringClass != lastReceiverType", "-\t\t\t\t&& !lastReceiverType.isArrayType()", "-\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "-\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "-\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(index <= 1 &&  indexOfFirstFieldBinding == 1 && fieldBinding.isStatic()))", "-\t\t\t\t\t&& fieldBinding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+\t}", "+\t// if the binding declaring class is not visible, need special action", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t// and not from Object or implicit static field access.\t", "+\tif (fieldBinding.declaringClass != lastReceiverType", "+\t\t\t&& !lastReceiverType.isArrayType()", "+\t\t\t&& fieldBinding.declaringClass != null // array.length", "+\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "+\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(index <= 1 &&  this.indexOfFirstFieldBinding == 1 && fieldBinding.isStatic()))", "+\t\t\t\t&& fieldBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields", "-\t\t\t}", "-\t\t}\t\t\t", "-\t}", "+\t\t}", "+\t}\t\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd3326428f84de14e26c968bf346e59e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8b0f83ab2fc2f0377aa0a160aaebc6cf11976024", "commitAfterChange": "841d4b99f7f88577aa004d23df8444d60d488b4b", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "diff": ["-\t */", "-\tpublic void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {", "- \t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;", "-\t\tNestedTypeBinding nestedType = (NestedTypeBinding) binding;", "-\t\t", "-\t\tMethodScope methodScope = currentScope.methodScope();", "-\t\tif (!methodScope.isStatic && !methodScope.isConstructorCall){", "-\t\t\tnestedType.addSyntheticArgumentAndField(nestedType.enclosingType());\t", "-\t\t}", "-\t\t// add superclass enclosing instance arg for anonymous types (if necessary)", "-\t\tif (nestedType.isAnonymousType()) {", "-\t\t\tReferenceBinding superclassBinding = (ReferenceBinding)nestedType.superclass.erasure();", "-\t\t\tif (superclassBinding.enclosingType() != null && !superclassBinding.isStatic()) {", "-\t\t\t\tif (!superclassBinding.isLocalType()", "-\t\t\t\t\t\t|| ((NestedTypeBinding)superclassBinding).getSyntheticField(superclassBinding.enclosingType(), true) != null){", "+ */", "+public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;", "+\tNestedTypeBinding nestedType = (NestedTypeBinding) this.binding;", "+\t", "+\tMethodScope methodScope = currentScope.methodScope();", "+\tif (!methodScope.isStatic && !methodScope.isConstructorCall){", "+\t\tnestedType.addSyntheticArgumentAndField(nestedType.enclosingType());\t", "+\t}", "+\t// add superclass enclosing instance arg for anonymous types (if necessary)", "+\tif (nestedType.isAnonymousType()) {", "+\t\tReferenceBinding superclassBinding = (ReferenceBinding)nestedType.superclass.erasure();", "+\t\tif (superclassBinding.enclosingType() != null && !superclassBinding.isStatic()) {", "+\t\t\tif (!superclassBinding.isLocalType()", "+\t\t\t\t\t|| ((NestedTypeBinding)superclassBinding).getSyntheticField(superclassBinding.enclosingType(), true) != null){", "-\t\t\t\t\tnestedType.addSyntheticArgument(superclassBinding.enclosingType());\t", "-\t\t\t\t}", "+\t\t\t\tnestedType.addSyntheticArgument(superclassBinding.enclosingType());\t", "-\t\t\t// From 1.5 on, provide access to enclosing instance synthetic constructor argument when declared inside constructor call", "-\t\t\t// only for direct anonymous type", "-\t\t\t//public class X {", "-\t\t\t//\tvoid foo() {}", "-\t\t\t//\tclass M {", "-\t\t\t//\t\tM(Object o) {}", "-\t\t\t//\t\tM() { this(new Object() { void baz() { foo(); }}); } // access to #foo() indirects through constructor synthetic arg: val$this$0", "-\t\t\t//\t}", "-\t\t\t//}", "-\t\t\tif (!methodScope.isStatic && methodScope.isConstructorCall && currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_5) {", "-\t\t\t\tReferenceBinding enclosing = nestedType.enclosingType();", "-\t\t\t\tif (enclosing.isNestedType()) {", "-\t\t\t\t\tNestedTypeBinding nestedEnclosing = (NestedTypeBinding)enclosing;", "+\t\t}", "+\t\t// From 1.5 on, provide access to enclosing instance synthetic constructor argument when declared inside constructor call", "+\t\t// only for direct anonymous type", "+\t\t//public class X {", "+\t\t//\tvoid foo() {}", "+\t\t//\tclass M {", "+\t\t//\t\tM(Object o) {}", "+\t\t//\t\tM() { this(new Object() { void baz() { foo(); }}); } // access to #foo() indirects through constructor synthetic arg: val$this$0", "+\t\t//\t}", "+\t\t//}", "+\t\tif (!methodScope.isStatic && methodScope.isConstructorCall && currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\tReferenceBinding enclosing = nestedType.enclosingType();", "+\t\t\tif (enclosing.isNestedType()) {", "+\t\t\t\tNestedTypeBinding nestedEnclosing = (NestedTypeBinding)enclosing;", "-\t\t\t\t\t\tSyntheticArgumentBinding syntheticEnclosingInstanceArgument = nestedEnclosing.getSyntheticArgument(nestedEnclosing.enclosingType(), true);", "-\t\t\t\t\t\tif (syntheticEnclosingInstanceArgument != null) {", "-\t\t\t\t\t\t\tnestedType.addSyntheticArgumentAndField(syntheticEnclosingInstanceArgument);\t", "-\t\t\t\t\t\t}", "+\t\t\t\t\tSyntheticArgumentBinding syntheticEnclosingInstanceArgument = nestedEnclosing.getSyntheticArgument(nestedEnclosing.enclosingType(), true);", "+\t\t\t\t\tif (syntheticEnclosingInstanceArgument != null) {", "+\t\t\t\t\t\tnestedType.addSyntheticArgumentAndField(syntheticEnclosingInstanceArgument);\t", "+\t\t\t\t}", "-\t\t\t}", "+}"]}], "num": 14852}