{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a597b53c56485a509195e25887e418f7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "120c4e94c606914b73352a387a976f21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/VariableElementImpl.java", "commitBeforeChange": "bbb750998e75511ba75783c9f2d763f2e32279d9", "commitAfterChange": "02bf4272774dd4f6faf4897c054614bdc809ab9e", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \t@Override \tpublic Element getEnclosingElement()", "signatureAfterChange": "  \t@Override \tpublic Element getEnclosingElement()", "diff": ["-\t\telse if (_binding instanceof LocalVariableBinding){", "-\t\t\t//TODO: return enclosing method binding", "-\t\t\tthrow new UnsupportedOperationException(\"NYI: VariableElementImpl.getEnclosingElement()\"); //$NON-NLS-1$", "+\t\telse if (_binding instanceof AptSourceLocalVariableBinding){", "+\t\t\treturn _env.getFactory().newElement(((AptSourceLocalVariableBinding) _binding).methodBinding);", "+\t\t} else if (_binding instanceof AptBinaryLocalVariableBinding) {", "+\t\t\treturn _env.getFactory().newElement(((AptBinaryLocalVariableBinding) _binding).methodBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "266a2bf17ef95de5cb9fc311dc62ac16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e6099120ee9021152f84e60105066d4964c2db21", "commitAfterChange": "82631a98caad8b28e9cefb217339d51e64ef47f9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "diff": ["-\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "-\t\tif (this.handleFactory == null) {\r", "-\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t}\r", "-\t\t\r", "-\t\t// initialize locator with working copies\r", "-\t\tthis.workingCopies = workingCopies;\r", "-\t\t\r", "-\t\t// substitute compilation units with working copies\r", "-\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "-\t\tint wcLength;\r", "-\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "-\t\t\tString[] newPaths = new String[wcLength];\r", "-\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "-\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t\tString path = res.getFullPath().toString();\r", "-\t\t\t\t\twcPaths.put(path, workingCopy);\r", "-\t\t\t\t\tnewPaths[i] = path;\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t// continue with next working copy\r", "-\t\t\t\t}\r", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\t\ttry {\r", "+\t\t\t// optimize access to zip files during search operation\r", "+\t\t\tmanager.cacheZipFiles();\r", "+\t\t\t\t\r", "+\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "+\t\t\tif (this.handleFactory == null) {\r", "+\t\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t\tint filePathsLength = filePaths.length;\r", "-\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "-\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\t\t}\r", "-\t\t\r", "-\t\tint length = filePaths.length;\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\r", "-\t\t// sort file paths projects\r", "-\t\tUtil.sort(filePaths); \r", "-\t\t\r", "-\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "-\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "-\t\t\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\t// skip duplicate paths\r", "-\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t// initialize locator with working copies\r", "+\t\t\tthis.workingCopies = workingCopies;\r", "-\t\t\tOpenable openable;\r", "-\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "-\t\t\tif (workingCopy != null) {\r", "-\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t} else {\r", "-\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "-\t\t\t\tif (openable == null)\r", "-\t\t\t\t\tcontinue; // match is outside classpath\r", "-\t\t\t}\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\tJavaProject javaProject = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tif (workingCopy != null) {\r", "-\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\t\t\t\tthrow e;\r", "-\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t// substitute compilation units with working copies\r", "+\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\t\t\tint wcLength;\r", "+\t\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\t\t\tString[] newPaths = new String[wcLength];\r", "+\t\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "+\t\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t\tString path = res.getFullPath().toString();\r", "+\t\t\t\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\t\t\t\tnewPaths[i] = path;\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t// continue with next working copy\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tthis.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "+\t\t\t\tint filePathsLength = filePaths.length;\r", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "+\t\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\r", "-\t\t\t// add matching openable\r", "-\t\t\tthis.addMatchingOpenable(resource, openable);\r", "-\r", "+\t\t\t\r", "+\t\t\tint length = filePaths.length;\r", "-\t\t\t\tprogressMonitor.worked(1);\r", "+\t\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\t\t\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\ttry {\r", "-\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\tthrow e;\r", "+\t\r", "+\t\t\t// sort file paths projects\r", "+\t\t\tUtil.sort(filePaths); \r", "+\t\t\t\r", "+\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "+\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "+\t\t\t\r", "+\t\t\tJavaProject previousJavaProject = null;\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "+\t\t\t\t\tthrow new OperationCanceledException();\r", "+\t\t\t\t}\r", "+\t\t\t\tString pathString = filePaths[i];\r", "+\t\t\t\t\r", "+\t\t\t\t// skip duplicate paths\r", "+\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t\t\r", "+\t\t\t\tOpenable openable;\r", "+\t\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "+\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "+\t\t\t\t\tif (openable == null)\r", "+\t\t\t\t\t\tcontinue; // match is outside classpath\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// create new parser and lookup environment if this is a new project\r", "+\t\t\t\tIResource resource = null;\r", "+\t\t\t\tJavaProject javaProject = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "+\t\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "+\t\t\t\t\t\tresource = javaProject.getProject();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t\t\t// locate matches in previous project\r", "+\t\t\t\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t\t\t\t}\r", "+\t\r", "+\t\t\t\t\t\t// create parser for this project\r", "+\t\t\t\t\t\tthis.createParser(javaProject);\r", "+\t\t\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t// file doesn't exist -> skip it\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// add matching openable\r", "+\t\t\t\tthis.addMatchingOpenable(resource, openable);\r", "+\t\r", "+\t\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\t\tprogressMonitor.worked(1);\r", "-\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\t} \r", "-\t\t\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.done();\r", "-\t\t}\r", "-\r", "+\t\t\t\r", "+\t\t\t// last project\r", "+\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t} \r", "+\t\t\t\r", "+\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\tprogressMonitor.done();\r", "+\t\t\t}\r", "+\t\t} finally {\r", "+\t\t\tif (this.nameEnvironment != null) {\r", "+\t\t\t\tthis.nameEnvironment.cleanup();\r", "+\t\t\t}\r", "+\t\t\tthis.parsedUnits = null;\r", "+\t\t\tmanager.flushZipFiles();\r", "+\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2ba485fb92d0f8fcc112208dfdd8b819", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "b04602938404af4f8569a399fb36a5018768a262", "commitAfterChange": "6a230a9d6ae1a4a6adbf38879cb9ee685eccffe9", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r \tpublic void reportReference(\r \t\tAstNode reference,\r \t\tTypeDeclaration typeDeclaration,\r \t\tFieldDeclaration fieldDeclaration,\r \t\tchar[][] definingTypeNames,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r public void reportReference(\r \tAstNode reference,\r \tTypeDeclaration typeDeclaration,\r \tFieldDeclaration fieldDeclaration, \r \tchar[][] definingTypeNames, \r \tint accuracy) throws CoreException", "diff": ["+ */\r", "+public void reportReference(\r", "+\tAstNode reference,\r", "+\tTypeDeclaration typeDeclaration,\r", "+\tFieldDeclaration fieldDeclaration, \r", "+\tchar[][] definingTypeNames, \r", "+\tint accuracy) throws CoreException {\r", "+\tif (fieldDeclaration.isField()) {\r", "+\t\t// create defining field handle\r", "+\t\tIField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);\r", "+\t\r", "+\t\tif (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {\r", "+\t\t\tthis.pattern.matchReportReference((AstNode)reference, field, accuracy, this);\r", "+\t\t} else if (reference instanceof MessageSend) { // message ref are starting at the selector start\r", "+\t\t\tthis.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);\r", "+\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, field, accuracy);\r", "+\t\t}\r", "+\t} else { // initializer\r", "+\t\t// create defining initializer\r", "+\t\tIInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);\r", "+\t\t\r", "+\t\t// accept reference\r", "+\t\tif (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {\r", "+\t\t\tthis.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);\r", "+\t\t} else if (reference instanceof MessageSend) { // message ref are starting at the selector start\r", "+\t\t\tthis.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);\r", "+\t\t} else {\r", "+\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);\r", "+}\r", "-\t */\r", "-\tpublic void reportReference(\r", "-\t\tAstNode reference,\r", "-\t\tTypeDeclaration typeDeclaration,\r", "-\t\tFieldDeclaration fieldDeclaration,\r", "-\t\tchar[][] definingTypeNames,\r", "-\t\tint accuracy)\r", "-\t\tthrows CoreException {\r", "-\t\tif (fieldDeclaration.isField()) {\r", "-\t\t\t// create defining field handle\r", "-\t\t\tIField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);\r", "-\r", "-\t\t\t// accept reference\r", "-\t\t\tif (reference instanceof QualifiedNameReference\r", "-\t\t\t\t|| reference instanceof QualifiedTypeReference) {\r", "-\t\t\t\tthis.pattern.matchReportReference((AstNode) reference, field, accuracy, this);\r", "-\t\t\t} else {\r", "-\t\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, field, accuracy);\r", "-\t\t\t}\r", "-\t\t} else { // initializer\r", "-\t\t\t// create defining initializer\r", "-\t\t\tIInitializer initializer =\r", "-\t\t\t\tthis.createInitializerHandle(\r", "-\t\t\t\t\ttypeDeclaration,\r", "-\t\t\t\t\tfieldDeclaration,\r", "-\t\t\t\t\tdefiningTypeNames);\r", "-\r", "-\t\t\t// accept reference\r", "-\t\t\tif (reference instanceof QualifiedNameReference\r", "-\t\t\t\t|| reference instanceof QualifiedTypeReference) {\r", "-\t\t\t\tthis.pattern.matchReportReference(\r", "-\t\t\t\t\t(AstNode) reference,\r", "-\t\t\t\t\tinitializer,\r", "-\t\t\t\t\taccuracy,\r", "-\t\t\t\t\tthis);\r", "-\t\t\t} else {\r", "-\t\t\t\tthis.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);\r", "-\t\t\t}\r", "-\t\t}\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37addd71324179ce0d1b12500ed52cf3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "055cf2299e246e07310e3c00069174f749475bd4", "commitAfterChange": "ee49c8f1081c02bdb311590036980191aff6a2f1", "methodNumberBeforeChange": 47, "methodNumberAfterChange": 47, "signatureBeforeChange": "  \tprivate void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs)", "signatureAfterChange": "  \tprivate void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs)", "diff": ["+\t\t\t\t\t\t\tif (!innerBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\tif (invocation instanceof MessageSend)", "+\t\t\t\t\t\t\t\t\tinnerCtx.scope.problemReporter().invalidMethod((MessageSend) invocation, innerBinding);", "+\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\tinnerCtx.scope.problemReporter().invalidConstructor(expression, innerBinding);", "+\t\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3cfc992e4a640c697863724df172946b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "f72b9294e29a54b769c09b51ef7c0dfbd4791089", "commitAfterChange": "bf20c4733b5ba628131f77425b6d1ad646dfd787", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient)", "signatureAfterChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient)", "diff": ["-\t\t\t\t\t\tlocal.tagBits = ((LocalVariableBinding) annotationRecipient).tagBits;", "+\t\t\t\t\t\tlong otherLocalTagBits = ((LocalVariableBinding) annotationRecipient).tagBits;", "+\t\t\t\t\t\tlocal.tagBits = otherLocalTagBits;", "+\t\t\t\t\t\t/*", "+\t\t\t\t\t\t * Annotations are shared between two locals, but we still need to record", "+\t\t\t\t\t\t * the suppress annotation range for the second local", "+\t\t\t\t\t\t */", "+\t\t\t\t\t\tif ((otherLocalTagBits & TagBits.AnnotationSuppressWarnings) != 0) {", "+\t\t\t\t\t\t\tLocalDeclaration localDeclaration = local.declaration;", "+\t\t\t\t\t\t\tannotation.recordSuppressWarnings(scope, localDeclaration.declarationSourceStart, localDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "63bf36f7540948a93f99119ff0a50c0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "5ffa6d87d82bcd877c2c1c819145a0122be38cd2", "commitAfterChange": "712c3e08152ef0500611b85e95a98a332827c891", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \t   \tpublic void resolve()", "signatureAfterChange": " \t   \tpublic void resolve()", "diff": ["+\t\t\t// check extends/implements for annotation type", "+\t\t\tif (getKind() == IGenericType.ANNOTATION_TYPE) {", "+\t\t\t\tif (this.superclass != null) {", "+\t\t\t\t\tthis.scope.problemReporter().annotationTypeDeclarationCannotHaveSuperclass(this);", "+\t\t\t\t}", "+\t\t\t\tif (this.superInterfaces != null) {", "+\t\t\t\t\tthis.scope.problemReporter().annotationTypeDeclarationCannotHaveSuperinterfaces(this);", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "69f6b57fc279a35f98f775fa3c746ef2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "055cf2299e246e07310e3c00069174f749475bd4", "commitAfterChange": "ee49c8f1081c02bdb311590036980191aff6a2f1", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": " \tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes)", "signatureAfterChange": " \tpublic void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes)", "diff": ["-\t\t\t\tif (solutions == null) ", "-\t\t\t\t\tcontinue; // play safe, but shouldn't happen in a resolved context", "+\t\t\t\tif (solutions == null) {", "+\t\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\t\tInferenceContext18 innerCtx = innerMessage.getInferenceContext((ParameterizedGenericMethodBinding) binding);", "+\t\t\t\t\t\tif (innerCtx != null && !binding.isValidBinding()) {", "+\t\t\t\t\t\t\tif (innerMessage instanceof MessageSend)", "+\t\t\t\t\t\t\t\tinnerCtx.scope.problemReporter().invalidMethod((MessageSend) innerMessage, binding);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\tinnerCtx.scope.problemReporter().invalidConstructor(inner, binding);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue; // inner inference not requested -> not a problem", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6a8e90466a1d2ad68b45b6120117595b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/HierarchyScope.java", "commitBeforeChange": "a41e619c58860e4fb0ad103984917e455aa47d4f", "commitAfterChange": "6166acc1a72eef4415ab90fa4d71205848f659db", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprivate void buildResourceVector()", "signatureAfterChange": " \tprivate void buildResourceVector()", "diff": ["-\t\tthis.types = this.hierarchy.getAllTypes();", "-\t\tfor (int i = 0; i < this.types.length; i++) {", "-\t\t\tIType type = this.types[i];", "-\t\t\tIResource resource = ((JavaElement) type).resource();", "+\t\tIType[] types = null;", "+\t\tif (this.subTypes != null) {", "+\t\t\ttypes = this.hierarchy.getAllSubtypes(this.focusType);", "+\t\t} else {", "+\t\t\ttypes = this.hierarchy.getAllTypes();", "+\t\t}", "+\t\tfor (int i = 0; i < types.length; i++) {", "+\t\t\tIType type = types[i];", "+\t\t\tif (this.subTypes != null) {", "+\t\t\t\t// remember subtypes for later use in encloses()", "+\t\t\t\tthis.subTypes.add(type);", "+\t\t\t}", "+\t\t\tIResource resource = ((JavaElement)type).resource();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "837b3222fa429cc64d78e5425f2bc237", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "7d431a6663c03691d383a66bc16841bb87e3308d", "commitAfterChange": "97e97b88721b4de5a807118c9ff5efc5e22e05aa", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["-\t\tif ((sourceType.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0", "+\t\tlong annotationTagBits = sourceType.getAnnotationTagBits();", "+\t\tif ((annotationTagBits & TagBits.AnnotationDeprecated) == 0", "+\t\tif ((annotationTagBits & TagBits.AnnotationFunctionalInterface) != 0) {", "+\t\t\tif(!this.binding.isFunctionalInterface(this.scope)) {", "+\t\t\t\tthis.scope.problemReporter().notAFunctionalInterface(this);", "+\t\t\t}", "+\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84b5ecad786570bee085f9ffe2eafc7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "ee8ad1e40e9b16f34ac6204dee3c91af5b27ff77", "commitAfterChange": "a6e44391963b63fa0c27651827313192cc7a80a0", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["+\t\tif (this.primary != null) {", "+\t\t\tthis.primary.resolveType(blockScope);", "+\t\t} else if (this.name != null) {", "+\t\t\tthis.name.resolveType(blockScope);", "+\t\t} else if (this.type != null) {", "+\t\t\tthis.type.resolveType(blockScope);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8633344ee2083da707a08bfe6d328176", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java", "commitBeforeChange": "963ad4c5e113eba29c599e5fefea6c28cb728772", "commitAfterChange": "cf4d63b8cb3eb4d0964e155767da7aeaa9651363", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic void checkcast(TypeReference typeReference, TypeBinding typeBinding)", "signatureAfterChange": " \t \tpublic void checkcast(TypeReference typeReference, TypeBinding typeBinding, int currentPosition)", "diff": ["-\tpublic void checkcast(TypeReference typeReference, TypeBinding typeBinding) {", "+\tpublic void checkcast(TypeReference typeReference, TypeBinding typeBinding, int currentPosition) {", "-\t\t\t\t\tif ((typeReference.bits & ASTNode.HasTypeAnnotations) != 0)", "-\t\t\t\t\t\taddAnnotationContext(typeReference, this.position, i, AnnotationTargetTypeConstants.CAST);", "-\t\t\t\t\tsuper.checkcast(typeReference, typeReference.resolvedType);", "+\t\t\t\t\tif ((typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\tif (!typeReference.resolvedType.isBaseType()) {", "+\t\t\t\t\t\t\taddAnnotationContext(typeReference, this.position, i, AnnotationTargetTypeConstants.CAST);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// for base type record it against the start position of the expression", "+\t\t\t\t\t\t\taddAnnotationContext(typeReference, currentPosition, i, AnnotationTargetTypeConstants.CAST);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!typeReference.resolvedType.isBaseType()) {", "+\t\t\t\t\t\tsuper.checkcast(typeReference, typeReference.resolvedType, currentPosition);", "+\t\t\t\t\t}", "-\t\t\tsuper.checkcast(null, typeBinding);", "+\t\t\tsuper.checkcast(null, typeBinding, currentPosition);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9bd0d223e9ecc77e2b078c698a0fdb4d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "56e0fc7aba6871cd475a06affdeeb59f64adf83b", "commitAfterChange": "4907c471cc7f66f0a0c55c535efacf1a6186f3ab", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "\r \tpublic boolean performConcurrentJob(\r \t\tIJob searchJob,\r \t\tint waitingPolicy,\r \t\tIProgressMonitor progress)", "signatureAfterChange": "\r \tpublic boolean performConcurrentJob(\r \t\tIJob searchJob,\r \t\tint waitingPolicy,\r \t\tIProgressMonitor progress)", "diff": ["+\t\t\t\t\tint currentPriority = this.thread.getPriority();;\r", "+\t\t\t\t\t\t\tif (this.thread != null) {\r", "+\t\t\t\t\t\t\t\tthis.thread.setPriority(Thread.currentThread().getPriority());\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tif (this.thread != null) {\r", "+\t\t\t\t\t\t\t\tthis.thread.setPriority(currentPriority);\r", "+\t\t\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c9674093069103e0ee33f73211fb5c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "484bb49f20ab3dfdc1bd0aad8e6eff3ac06b3aff", "commitAfterChange": "cfd501694f5288c5b2d25d4e0376aabc070087d8", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["+\t\t\t\tif (methodDecl == null) {", "+\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special", "+\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tthis.scope.problemReporter().duplicateMethodInType(this, methodDecl, method.areParametersEqual(method2));", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\tif (isEnumSpecialMethod) {", "+\t\t\t\t\tif (isEnumSpecialMethod)", "-\t\t\t\t\t} else {", "+\t\t\t\t\telse", "-\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd670978f4773cb90a25056976caf251", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "64298556651d81e68f8405c1642b36744d7373dd", "commitAfterChange": "b92bafecd030777e0d6056677f8286cf640a489f", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic void complete(IType type, char[] snippet, int position, char[][] localVariableTypeNames, char[][] localVariableNames, int[] localVariableModifiers, boolean isStatic)", "signatureAfterChange": " \t \tpublic void complete(IType type, char[] snippet, int position, char[][] localVariableTypeNames, char[][] localVariableNames, int[] localVariableModifiers, boolean isStatic)", "diff": ["-", "+\t\tif(this.requestor != null){", "+\t\t\tthis.requestor.beginReporting();", "+\t\t}", "+\t\t", "-\t\t\t\t\tthis.requestor.acceptError(this.problem);", "+\t\t\t\t\tthis.requestor.completionFailure(this.problem);", "+\t\t\t\t\tif(DEBUG) {", "+\t\t\t\t\t\tthis.printDebug(this.problem);", "+\t\t\t\t\t}", "+\t\t}", "+\t\t", "+\t\tif(this.requestor != null){", "+\t\t\tthis.requestor.endReporting();"]}], "num": 23664}