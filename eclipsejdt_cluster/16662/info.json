{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "21ea07132c07de8d5472a35db59148f2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f3bdad57d750f99d0ccfffa97be497a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java", "commitBeforeChange": "1ca61ba390ea54fcabd09223853d7a3d6816c249", "commitAfterChange": "5663a1e0521003a6152962cf3fce8cc9ca6a4647", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " public abstract TypeReference copyDims(int dim, Annotation[][] annotationsOnDimensions);", "signatureAfterChange": "  protected Annotation[][] getMergedAnnotationsOnDimensions(int additionalDimensions, Annotation[][] additionalAnnotations)", "diff": ["-public abstract TypeReference copyDims(int dim);", "-public abstract TypeReference copyDims(int dim, Annotation[][] annotationsOnDimensions);", "+", "+protected Annotation[][] getMergedAnnotationsOnDimensions(int additionalDimensions, Annotation[][] additionalAnnotations) {", "+\t/* Note, we actually concatenate the additional annotations after base annotations, in bindings, they should appear before base annotations.", "+\t   Given @English int @Nullable [] x @NonNull []; the type x is a @NonNull arrays of of @Nullable arrays of @English Strings, not the other", "+\t   way about. Changing this in the compiler AST representation will cause too many ripples, so we leave it as is. On the bindings, the type", "+\t   will reflect rotated (i.e will reflect correctly). See AnnotatableTypeSystem.flattenedAnnotations", "+\t*/", "+\tAnnotation[][] annotationsOnDimensions = this.getAnnotationsOnDimensions(true);", "+\tint dimensions = this.dimensions();", "+\t", "+\tif (annotationsOnDimensions == null && additionalAnnotations == null)", "+\t\treturn null;", "+", "+\tfinal int totalDimensions = dimensions + additionalDimensions;", "+\tAnnotation [][] mergedAnnotations = new Annotation[totalDimensions][];", "+\tif (annotationsOnDimensions != null) {", "+\t\tfor (int i = 0; i < dimensions; i++) {", "+\t\t\tmergedAnnotations[i] = annotationsOnDimensions[i];", "+\t\t} ", "+\t}", "+\tif (additionalAnnotations != null) {", "+\t\tfor (int i = dimensions, j = 0; i < totalDimensions; i++, j++) {", "+\t\t\tmergedAnnotations[i] = additionalAnnotations[j];", "+\t\t}", "+\t}", "+\treturn mergedAnnotations;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37d5267caadb17f5d178a263622dda9e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java", "commitBeforeChange": "8c8cd78ee7d91af397b355193b993289ef7f4454", "commitAfterChange": "dab69163a24dbd341ec146b21a1806a7799bbbc6", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 16, "signatureBeforeChange": " private void generateMethodInfos(IType type, IBinaryType typeInfo, HashMap newElements, ArrayList childrenHandles, ArrayList typeParameterHandles)", "signatureAfterChange": " private void generateMethodInfos(IType type, IBinaryType typeInfo, HashMap newElements, ArrayList childrenHandles, ArrayList typeParameterHandles)", "diff": ["-\t\t}catch (IllegalArgumentException e) {", "+\t\t} catch (IllegalArgumentException e) {", "-\t\t// ensure that 2 binary methods with the same signature but with different return types have different occurence counts.", "+\t\t// ensure that 2 binary methods with the same signature but with different return types have different occurrence counts.", "+\t\tint max = pNames.length;", "+\t\tchar[][] argumentNames = methodInfo.getArgumentNames();", "+\t\tif (argumentNames == null || argumentNames.length < max) {", "+\t\t\targumentNames = new char[max][];", "+\t\t\tfor (int j = 0; j < max; j++) {", "+\t\t\t\targumentNames[j] = (\"arg\" + j).toCharArray(); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+\t\tfor (int j = 0; j < max; j++) {", "+\t\t\tIBinaryAnnotation[] parameterAnnotations = methodInfo.getParameterAnnotations(j);", "+\t\t\tif (parameterAnnotations != null) {", "+\t\t\t\tLocalVariable localVariable = new LocalVariable(", "+\t\t\t\t\t\tmethod,", "+\t\t\t\t\t\tnew String(argumentNames[j]),", "+\t\t\t\t\t\t0,", "+\t\t\t\t\t\t-1,", "+\t\t\t\t\t\t0,", "+\t\t\t\t\t\t-1,", "+\t\t\t\t\t\tmethod.parameterTypes[j],", "+\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t-1,", "+\t\t\t\t\t\ttrue);", "+\t\t\t\tgenerateAnnotationsInfos(localVariable, argumentNames[j], parameterAnnotations, methodInfo.getTagBits(), newElements);", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b450a00e5cd591e69beba28a0df6901d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "05ffc45e7b8ab76e8a7e8ec987e52f6f3663e0c3", "commitAfterChange": "7c124cb865f103cbfba1919be3ee5fe920ce2ecf", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public String[] getParameterNames() throws JavaModelException", "signatureAfterChange": " public String[] getParameterNames() throws JavaModelException", "diff": ["- \t\tString javadocContents = null;", "- \t\tIType declaringType = this.getDeclaringType();", "+\t\tString javadocContents = null;", "+\t\tIType declaringType = this.getDeclaringType();", "- \t\tsynchronized (projectInfo.javadocCache) {", "- \t\t\tjavadocContents = (String) projectInfo.javadocCache.get(declaringType);", "- \t\t\tif (javadocContents == null) {", "- \t\t\t\tprojectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);", "- \t\t\t}", "- \t\t}", "- \t\tif (javadocContents == null) {", "- \t\t\tlong timeOut = 50; // default value", "- \t\t\ttry {", "- \t\t\t\tString option = this.getJavaProject().getOption(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, true);", "- \t\t\t\tif (option != null) {", "- \t\t\t\t\ttimeOut = Long.parseLong(option);", "- \t\t\t\t}", "- \t\t\t} catch(NumberFormatException e) {", "- \t\t\t\t// ignore", "- \t\t\t}", "- \t\t\tif (timeOut == 0) {", "- \t\t\t\t// don't try to fetch the values", "- \t\t\t\treturn this.parameterNames = getRawParameterNames(paramCount);", "- \t\t\t}", "- \t\t\tfinal class ParametersNameCollector {", "- \t\t\t\tString javadoc;", "- \t\t\t\tpublic void setJavadoc(String s) {", "- \t\t\t\t\tthis.javadoc = s;", "- \t\t\t\t}", "- \t\t\t\tpublic String getJavadoc() {", "- \t\t\t\t\treturn this.javadoc;", "- \t\t\t\t}", "- \t \t\t}", "- \t\t\t/*", "- \t\t\t * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents", "- \t\t\t */", "-\t \t\tfinal ParametersNameCollector nameCollector = new ParametersNameCollector();", "+\t\tsynchronized (projectInfo.javadocCache) {", "+\t\t\tjavadocContents = (String) projectInfo.javadocCache.get(declaringType);", "+\t\t\tif (javadocContents == null) {", "+\t\t\t\tprojectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);", "+\t\t\t}", "+\t\t}", "+\t\tif (javadocContents == null) {", "+\t\t\tlong timeOut = 50; // default value", "+\t\t\ttry {", "+\t\t\t\tString option = this.getJavaProject().getOption(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, true);", "+\t\t\t\tif (option != null) {", "+\t\t\t\t\ttimeOut = Long.parseLong(option);", "+\t\t\t\t}", "+\t\t\t} catch(NumberFormatException e) {", "+\t\t\t\t// ignore", "+\t\t\t}", "+\t\t\tif (timeOut == 0) {", "+\t\t\t\t// don't try to fetch the values", "+\t\t\t\treturn this.parameterNames = getRawParameterNames(paramCount);", "+\t\t\t}", "+\t\t\tfinal class ParametersNameCollector {", "+\t\t\t\tString javadoc;", "+\t\t\t\tpublic void setJavadoc(String s) {", "+\t\t\t\t\tthis.javadoc = s;", "+\t\t\t\t}", "+\t\t\t\tpublic String getJavadoc() {", "+\t\t\t\t\treturn this.javadoc;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents", "+\t\t\t */", "+\t\t\tfinal ParametersNameCollector nameCollector = new ParametersNameCollector();", "-\t\t\t        } catch (JavaModelException e) {", "-\t \t\t        \t// ignore", "-\t \t\t        }", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// ignore", "+\t\t\t\t\t}", "- \t\t} else if (javadocContents != BinaryType.EMPTY_JAVADOC){", "- \t\t\t// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type", "- \t\t\ttry {", "- \t\t\t\tjavadocContents = extractJavadoc(declaringType, javadocContents);", "- \t\t\t} catch(JavaModelException e) {", "- \t\t\t\t// ignore", "- \t\t\t}", "- \t\t} else {", "- \t\t\t// we don't want to set the parameter names", "- \t\t\treturn getRawParameterNames(paramCount);", "- \t\t}", "+\t\t} else if (javadocContents != BinaryType.EMPTY_JAVADOC){", "+\t\t\t// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type", "+\t\t\ttry {", "+\t\t\t\tjavadocContents = extractJavadoc(declaringType, javadocContents);", "+\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t// ignore", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// let's see if we can retrieve them from the debug infos", "+\t\t\tchar[][] argumentNames = info.getArgumentNames();", "+\t\t\tif (argumentNames != null && argumentNames.length == paramCount) {", "+\t\t\t\tString[] names = new String[paramCount];", "+\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\t\tnames[i] = new String(argumentNames[i]);", "+\t\t\t\t}", "+\t\t\t\treturn this.parameterNames = names;", "+\t\t\t}", "+\t\t\treturn getRawParameterNames(paramCount);", "+\t\t}", "+\t\t// let's see if we can retrieve them from the debug infos", "+\t\tchar[][] argumentNames = info.getArgumentNames();", "+\t\tif (argumentNames != null && argumentNames.length == paramCount) {", "+\t\t\tString[] names = new String[paramCount];", "+\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\tnames[i] = new String(argumentNames[i]);", "+\t\t\t}", "+\t\t\treturn this.parameterNames = names;", "+\t\t}"]}], "num": 16662}