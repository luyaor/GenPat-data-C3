{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6e78213ab8fa0ee1e9b2839632952c3", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14fb38476c06d43b6ad5772c818f3645", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "ba623d582045575b43eee2b86be165ff58225746", "commitAfterChange": "5f25db2c9c02bf799108bff292447ab679c3c3b7", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods)", "diff": ["-void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod) {", "+void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {", "-\tif (inheritedMethod != originalInherited) {", "-\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "-\t\tif (toCheck.length > 1) {", "-\t\t\t// must check to see if a bridge method will collide with another current method (see 77861)", "-\t\t\tfor (int i = 0, length = toCheck.length; i < length; i++) {", "-\t\t\t\tif (currentMethod != toCheck[i] && toCheck[i].areParameterErasuresEqual(originalInherited)) {", "-\t\t\t\t\tproblemReporter(toCheck[i]).methodNameClash(toCheck[i], originalInherited); // bridge method will collide", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tthis.type.addSyntheticBridgeMethod(originalInherited, currentMethod);", "+", "+\tif (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod) != null) {", "+\t\tfor (int i = 0, l = otherInheritedMethods.length; i < l; i++) {", "+\t\t\tif (otherInheritedMethods[i] != null) {", "+\t\t\t\tMethodBinding otherOriginal = otherInheritedMethods[i].original();", "+\t\t\t\tif (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))", "+\t\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// there is an ordering issue with the comparison in checkMethods", "+\t\t// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)", "+\t\t// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method", "+\t\t//\t\tclass X implements Comparable<X> {", "+\t\t//\t\t\tpublic int compareTo(Object o) { return 0; }", "+\t\t//\t\t\tpublic int compareTo(X o) { return 1; }", "+\t\t//\t\t}", "+\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "+\t\tfor (int i = 0, l = toCheck.length; i < l; i++)", "+\t\t\tif (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))", "+\t\t\t\treturn;", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "187eb5906e1620050b00b0821fcd7d96", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "1b79e24e174cbe645091d191260c98e48405b675", "commitAfterChange": "3d0cee6e94784a6b3bd48a07f7ded01c1ecae704", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void seekPackageFragments(String name, boolean partialMatch, IJavaElementRequestor requestor)", "signatureAfterChange": " \tpublic void seekPackageFragments(String name, boolean partialMatch, IJavaElementRequestor requestor)", "diff": ["-\t\tint count= this.packageFragmentRoots.length;", "-\t\tString matchName= partialMatch ? name.toLowerCase() : name;", "-\t\tString[] splittedName = partialMatch ? null : Util.splitOn('.', matchName, 0, matchName.length());", "-\t\tfor (int i= 0; i < count; i++) {", "-\t\t\tif (requestor.isCanceled())", "-\t\t\t\treturn;", "-\t\t\tIPackageFragmentRoot root= this.packageFragmentRoots[i];", "-\t\t\tIJavaElement[] list= null;", "-\t\t\ttry {", "-\t\t\t\tlist= root.getChildren();", "-\t\t\t} catch (JavaModelException npe) {", "-\t\t\t\tcontinue; // this root package fragment is not present", "-\t\t\t}", "-\t\t\tint elementCount= list.length;", "-\t\t\tfor (int j= 0; j < elementCount; j++) {", "+\t\tif (partialMatch) {", "+\t\t\tint count= this.packageFragmentRoots.length;", "+\t\t\tString matchName= name.toLowerCase();", "+\t\t\tfor (int i= 0; i < count; i++) {", "-\t\t\t\tIPackageFragment packageFragment= (IPackageFragment) list[j];", "-\t\t\t\tif (partialMatch) {", "+\t\t\t\tIPackageFragmentRoot root= this.packageFragmentRoots[i];", "+\t\t\t\tIJavaElement[] list= null;", "+\t\t\t\ttry {", "+\t\t\t\t\tlist= root.getChildren();", "+\t\t\t\t} catch (JavaModelException npe) {", "+\t\t\t\t\tcontinue; // this root package fragment is not present", "+\t\t\t\t}", "+\t\t\t\tint elementCount= list.length;", "+\t\t\t\tfor (int j= 0; j < elementCount; j++) {", "+\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\tIPackageFragment packageFragment= (IPackageFragment) list[j];", "-\t\t\t\t} else {", "-\t\t\t\t\tif (Util.equalArraysOrNull(((PackageFragment)packageFragment).names, splittedName))", "-\t\t\t\t\t\trequestor.acceptPackageFragment(packageFragment);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tString[] splittedName = Util.splitOn('.', name, 0, name.length());", "+\t\t\tIPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) this.packageFragments.get(splittedName);", "+\t\t\tif (roots != null) {", "+\t\t\t\tfor (int i = 0, length = roots.length; i < length; i++) {", "+\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot) roots[i];", "+\t\t\t\t\trequestor.acceptPackageFragment(root.getPackageFragment(splittedName));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30b882766b41fcd367d81eca77908383", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java", "commitBeforeChange": "7fcda725e57776ddb850f6e0923a37be77d4220a", "commitAfterChange": "a6e6bfb150ee78b02c696c163d3f66a811019e6b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t \tHashtableOfArrayToObject getAllPackageFragments(JavaProject project)", "signatureAfterChange": " \t \tHashtableOfArrayToObject getAllPackageFragments(JavaProject project)", "diff": ["-\t\t\tIPackageFragment[] frags = this.getPackageFragmentsInRoots(roots, project);", "-\t\t\tfor (int i= 0; i < frags.length; i++) {", "-\t\t\t\tPackageFragment fragment= (PackageFragment) frags[i];", "-\t\t\t\tString[] pkgName = fragment.names;", "-\t\t\t\tIPackageFragment[] entry= (IPackageFragment[]) cache.get(pkgName);", "-\t\t\t\tif (entry == null) {", "-\t\t\t\t\tentry= new IPackageFragment[1];", "-\t\t\t\t\tentry[0]= fragment;", "-\t\t\t\t\tcache.put(pkgName, entry);", "-\t\t\t\t} else {", "-\t\t\t\t\tIPackageFragment[] copy= new IPackageFragment[entry.length + 1];", "-\t\t\t\t\tSystem.arraycopy(entry, 0, copy, 0, entry.length);", "-\t\t\t\t\tcopy[entry.length]= fragment;", "-\t\t\t\t\tcache.put(pkgName, copy);", "+\t\t\tfor (int i = 0, length = roots.length; i < length; i++) {", "+\t\t\t\tIPackageFragmentRoot root = roots[i];", "+\t\t\t\tIJavaElement[] frags = null;", "+\t\t\t\ttry {", "+\t\t\t\t\tfrags = root.getChildren();", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t// root doesn't exist: ignore", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tfor (int j = 0, length2 = frags.length; j < length2; j++) {", "+\t\t\t\t\tPackageFragment fragment= (PackageFragment) frags[j];", "+\t\t\t\t\tString[] pkgName = fragment.names;", "+\t\t\t\t\tIPackageFragmentRoot[] entry= (IPackageFragmentRoot[]) cache.get(pkgName);", "+\t\t\t\t\tif (entry == null) {", "+\t\t\t\t\t\tentry= new IPackageFragmentRoot[] {root};", "+\t\t\t\t\t\tcache.put(pkgName, entry);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tIPackageFragmentRoot[] copy= new IPackageFragmentRoot[entry.length + 1];", "+\t\t\t\t\t\tSystem.arraycopy(entry, 0, copy, 0, entry.length);", "+\t\t\t\t\t\tcopy[entry.length]= root;", "+\t\t\t\t\t\tcache.put(pkgName, copy);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "505cc05ba61838a82fec674bd56fae38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "13012d4d345052a766efaa509c91e36e4e9c4bd7", "commitAfterChange": "0e6d159b6b5bd2cefe41360d930f2e2ea9602f91", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType,  \t\tchar[][][] missingTypeNames, TypeAnnotationWalker walker)", "signatureAfterChange": " TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType,  \t\tchar[][][] missingTypeNames, TypeAnnotationWalker walker)", "diff": ["-\t// null annotations on dimensions?", "+\t// annotations on dimensions?", "-\tint depth = binding.depth();", "-\twhile (depth > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) { // we are dropping annotations on enclosing types.", "-\t\twalker = walker.toNextNestedType();", "-\t\tdepth--;", "+\tif (isParameterized) {", "+\t\tif (dimension != 0)", "+\t\t\tthrow new IllegalStateException();", "+\t\treturn binding;", "-\tAnnotationBinding [][] annotations = new AnnotationBinding[depth + 1][];", "-\tannotations[depth] = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);", "-\tif (annotations[depth] != null && annotations[depth] != Binding.NO_ANNOTATIONS)", "-\t\tbinding = createAnnotatedType(binding, annotations);", "+\tif (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {", "+\t\tfinal int depth = binding.depth();", "+\t\tAnnotationBinding [][] annotations = null;", "+\t\tfor (int i = 0; i <= depth; i++) {", "+\t\t\tAnnotationBinding[] annots = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);", "+\t\t\tif (annots != null && annots.length > 0) {", "+\t\t\t\tif (annotations == null)", "+\t\t\t\t\tannotations = new AnnotationBinding[depth + 1][];", "+\t\t\t\tannotations[i] = annots;", "+\t\t\t}", "+\t\t\twalker = walker.toNextNestedType();", "+\t\t}", "+\t\tif (annotations != null)", "+\t\t\tbinding = createAnnotatedType(binding, annotations);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60ab27f04d74db1d5c7bf9a7d00a68c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "ed03b97e41cec71a1f276a24a6c89d537dde57f2", "commitAfterChange": "3617e411ab09a4b93e5840b8e6d451f0c6a8a8c9", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 20, "signatureBeforeChange": " public void storeDependencyInfo()", "signatureAfterChange": " public void storeDependencyInfo()", "diff": ["-\t// add the type hierarchy of each referenced type", "+\t// add the type hierarchy of each referenced supertype", "-\tfor (int i = 0; i < referencedTypes.size; i++) { // grows as more types are added", "-\t\tReferenceBinding type = (ReferenceBinding) referencedTypes.elementAt(i);", "+\tfor (int i = 0; i < referencedSuperTypes.size; i++) { // grows as more types are added", "+\t\tReferenceBinding type = (ReferenceBinding) referencedSuperTypes.elementAt(i);", "+\t\tif (!referencedTypes.containsIdentical(type))", "+\t\t\treferencedTypes.add(type);", "+", "+\t\t\tReferenceBinding enclosing = type.enclosingType();", "+\t\t\tif (enclosing != null)", "+\t\t\t\trecordSuperTypeReference(enclosing);", "+\t\t}", "+\t\tReferenceBinding superclass = type.superclass();", "+\t\tif (superclass != null)", "+\t\t\trecordSuperTypeReference(superclass);", "+\t\tReferenceBinding[] interfaces = type.superInterfaces();", "+\t\tif (interfaces != null)", "+\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++)", "+\t\t\t\trecordSuperTypeReference(interfaces[j]);", "+\t}", "+", "+\tfor (int i = 0, l = referencedTypes.size; i < l; i++) {", "+\t\tReferenceBinding type = (ReferenceBinding) referencedTypes.elementAt(i);", "+\t\tif (!type.isLocalType())", "-\t\t\tReferenceBinding enclosing = type.enclosingType();", "-\t\t\tif (enclosing != null && !referencedTypes.containsIdentical(enclosing))", "-\t\t\t\treferencedTypes.add(enclosing); // to record its supertypes", "-\t\t}", "-\t\tReferenceBinding superclass = type.superclass();", "-\t\tif (superclass != null && !referencedTypes.containsIdentical(superclass))", "-\t\t\t\treferencedTypes.add(superclass); // to record its supertypes", "-\t\tReferenceBinding[] interfaces = type.superInterfaces();", "-\t\tif (interfaces != null && interfaces.length > 0)", "-\t\t\tfor (int j = 0, length = interfaces.length; j < length; j++)", "-\t\t\t\tif (!referencedTypes.containsIdentical(interfaces[j]))", "-\t\t\t\t\treferencedTypes.add(interfaces[j]); // to record its supertypes"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c5856fad4cc1aa2df69fa616f4ea8f26", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java", "commitBeforeChange": "2452619bb5034f0a0ba9b6e9747cd6db77b2eb53", "commitAfterChange": "8d4f2ebabb0e50507cab6ea5f17acab787cfb10b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic static Test suiteForComplianceLevel(String complianceLevel, Class setupClass, ArrayList testClasses)", "signatureAfterChange": " \tprivate static Test buildComplianceSetupTestSuite(List testClasses, Class setupClass, String complianceLevel)", "diff": ["-\tpublic static Test suiteForComplianceLevel(String complianceLevel, Class setupClass, ArrayList testClasses) {", "-\t\tTestSuite suite;", "-\t\tif (testClasses.size() == 1) {", "-\t\t\tsuite = new TestSuite((Class)testClasses.get(0), complianceLevel);", "-\t\t} else {", "-\t\t\tsuite = new TestSuite(complianceLevel);", "-\t\t\tfor (int i = 0, length = testClasses.size(); i < length; i++) {", "-\t\t\t\tClass testClass = (Class)testClasses.get(i);", "-\t\t\t\tTestSuite innerSuite = new TestSuite(testClass);", "-\t\t\t\tsuite.addTest(innerSuite);", "-\t\t\t}", "-\t\t}", "+\t */", "+\tprivate static Test buildComplianceSetupTestSuite(List testClasses, Class setupClass, String complianceLevel) {", "+\t\tTestSuite complianceSuite = new TestSuite(complianceLevel);", "+\t\tfor (int i=0, m=testClasses.size(); i<m ; i++) {", "+\t\t\tClass testClass = (Class)testClasses.get(i);", "+\t\t\tTestSuite suite = new TestSuite(testClass.getName());", "+\t\t\tList tests = buildTestsList(testClass);", "+\t\t\tfor (int index=0, size=tests.size(); index<size; index++) {", "+\t\t\t\tsuite.addTest((Test)tests.get(index));", "+\t\t\t}", "+\t\t\tcomplianceSuite.addTest(suite);", "+\t\t}", "+\t", "-\t\t\tTest setUp = (Test)constructor.newInstance(new Object[]{suite, complianceLevel});", "+\t\t\tTest setUp = (Test)constructor.newInstance(new Object[]{complianceSuite, complianceLevel});", "-", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d35a90eab31262b7f0f2026bb58c646b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingOpenable.java", "commitBeforeChange": "e6099120ee9021152f84e60105066d4964c2db21", "commitAfterChange": "82631a98caad8b28e9cefb217339d51e64ef47f9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r public void buildTypeBindings()", "signatureAfterChange": "\r public void buildTypeBindings()", "diff": ["-\tif (openable instanceof CompilationUnit) {\r", "-\t\tthis.buildTypeBindings(this.getSource());\r", "-\t} else if (openable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "-\t\tchar[] source = this.locator.findSource((org.eclipse.jdt.internal.core.ClassFile)openable); \r", "-\t\tif (source != null) {\r", "-\t\t\tthis.buildTypeBindings(source);\r", "+\tchar[] source = this.getSource();\r", "+\tif (source == null) return;\r", "+\tthis.buildTypeBindings(source);\r", "-\t\t\t// try to use the main type's class file as the openable\r", "-\t\t\tTypeDeclaration[] types = this.parsedUnit.types;\r", "-\t\t\tif (types != null && types.length > 0) {\r", "-\t\t\t\tString simpleTypeName = new String(types[0].name);\r", "-\t\t\t\tIPackageFragment parent = (IPackageFragment)openable.getParent();\r", "-\t\t\t\torg.eclipse.jdt.core.IClassFile mainTypeClassFile = \r", "-\t\t\t\t\tparent.getClassFile(simpleTypeName + \".class\"); //$NON-NLS-1$\r", "-\t\t\t\tif (mainTypeClassFile.exists()) {\r", "-\t\t\t\t\tthis.openable = (Openable)mainTypeClassFile;\r", "-\t\t\t\t} \r", "-\t\t\t}\r", "+\tif (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {\r", "+\t\t// try to use the main type's class file as the openable\r", "+\t\tTypeDeclaration[] types = this.parsedUnit.types;\r", "+\t\tif (types != null) {\r", "+\t\t\tString classFileName = openable.getElementName();\r", "+\t\t\tfor (int i = 0, length = types.length; i < length; i++) {\r", "+\t\t\t\tTypeDeclaration typeDeclaration = types[i];\r", "+\t\t\t\tString simpleTypeName = new String(typeDeclaration.name);\r", "+\t\t\t\tif (classFileName.startsWith(simpleTypeName)) {\r", "+\t\t\t\t\tIPackageFragment parent = (IPackageFragment)openable.getParent();\r", "+\t\t\t\t\tthis.openable = (Openable)parent.getClassFile(simpleTypeName + \".class\"); //$NON-NLS-1$\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t} \r"]}], "num": 5856}