{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "90b47b72a4a03db4af0d020b157e385e", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13981ef5a4b0026912c18a896ce345de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "1740233a8dca1d707aa9811c9f07a7ace8f5d808", "commitAfterChange": "36542264af3396595138a00ba7efc11cead3cfc1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+\t// substitute compilation units with working copies\r", "+\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\tint wcLength;\r", "+\tIWorkingCopy[] workingCopies = this.getWokingCopies();\r", "+\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\tString[] newPaths = new String[wcLength];\r", "+\t\tfor (int i = 0; i < wcLength; i++) {\r", "+\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "+\t\t\tString path = workingCopy.getOriginalElement().getPath().toString();\r", "+\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\tnewPaths[i] = path;\r", "+\t\t}\r", "+\t\tint potentialSubtypesLength = allPotentialSubTypes.length;\r", "+\t\tSystem.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[potentialSubtypesLength+wcLength], 0, potentialSubtypesLength);\r", "+\t\tSystem.arraycopy(newPaths, 0, allPotentialSubTypes, potentialSubtypesLength, wcLength);\r", "+\t}\r", "+\t\t\t\r", "-\t\t\tOpenable handle = \r", "-\t\t\t\tresourcePath.equals(focusPath) ? \r", "-\t\t\t\t\tfocusCU :\r", "-\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "-\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\tOpenable handle;\r", "+\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);\r", "+\t\t\tif (workingCopy != null) {\r", "+\t\t\t\thandle = (Openable)workingCopy;\r", "+\t\t\t} else {\r", "+\t\t\t\thandle = \r", "+\t\t\t\t\tresourcePath.equals(focusPath) ? \r", "+\t\t\t\t\t\tfocusCU :\r", "+\t\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "+\t\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2fb0370383671d91da0e41ba75dea5d0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7dce3ced6f2c34a63721a3fda038e2fad50139b7", "commitAfterChange": "4a258c24dea43b906f3daa4041c94e7315633dfe", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException", "signatureAfterChange": " public void locateMatches(SearchDocument[] searchDocuments) throws JavaModelException", "diff": ["-public void locateMatches(String[] filePaths, IWorkspace workspace, org.eclipse.jdt.core.ICompilationUnit[] copies) throws JavaModelException {", "+public void locateMatches(SearchDocument[] searchDocuments) throws JavaModelException {", "-\t\tSystem.out.println(\"Locating matches in files [\"); //$NON-NLS-1$", "-\t\tfor (int i = 0, length = filePaths.length; i < length; i++)", "-\t\t\tSystem.out.println(\"\\t\" + filePaths[i]); //$NON-NLS-1$", "+\t\tSystem.out.println(\"Locating matches in documents [\"); //$NON-NLS-1$", "+\t\tfor (int i = 0, length = searchDocuments.length; i < length; i++)", "+\t\t\tSystem.out.println(\"\\t\" + searchDocuments[i]); //$NON-NLS-1$", "-\t\tif (copies != null) {", "-\t\t\t System.out.println(\"and working copies [\"); //$NON-NLS-1$", "-\t\t\tfor (int i = 0, length = copies.length; i < length; i++)", "-\t\t\t\tSystem.out.println(\"\\t\" + ((JavaElement) copies[i]).toStringWithAncestors()); //$NON-NLS-1$", "-\t\t\tSystem.out.println(\"]\"); //$NON-NLS-1$", "-\t\t}", "-\t\t// substitute compilation units with working copies", "-\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies", "-\t\tif ((this.workingCopies = copies) != null) {", "-\t\t\tint wcLength = this.workingCopies.length;", "-\t\t\tif (wcLength > 0) {", "-\t\t\t\tString[] newPaths = new String[wcLength];", "-\t\t\t\tfor (int i = 0; i < wcLength; i++) {", "-\t\t\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = this.workingCopies[i];", "-\t\t\t\t\tString path = workingCopy.getPath().toString();", "-\t\t\t\t\twcPaths.put(path, workingCopy);", "-\t\t\t\t\tnewPaths[i] = path;", "-\t\t\t\t}", "-\t\t\t\tint filePathsLength = filePaths.length;", "-\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength + wcLength], 0, filePathsLength);", "-\t\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);", "-\t\t\t}", "-\t\t}", "-", "-\t\t\tthis.progressMonitor.beginTask(\"\", filePaths.length * (this.pattern.mustResolve ? 10 : 5)); //$NON-NLS-1$", "+\t\t\tthis.progressMonitor.beginTask(\"\", searchDocuments.length * (this.pattern.mustResolve ? 10 : 5)); //$NON-NLS-1$", "-\t\tUtil.sort(filePaths); ", "-\t\tfor (int i = 0, l = filePaths.length; i < l; i++) {", "+\t\tUtil.sort(searchDocuments, new Util.Comparer() {", "+\t\t\tpublic int compare(Object a, Object b) {", "+\t\t\t\treturn ((SearchDocument)a).getPath().compareTo(((SearchDocument)b).getPath());", "+\t\t\t}", "+\t\t}); ", "+\t\tfor (int i = 0, l = searchDocuments.length; i < l; i++) {", "-\t\t\tString pathString = filePaths[i];", "-\t\t\tif (i > 0 && pathString.equals(filePaths[i - 1])) continue;", "+\t\t\tSearchDocument searchDocument = searchDocuments[i];", "+\t\t\tString pathString = searchDocument.getPath();", "+\t\t\tif (i > 0 && pathString.equals(searchDocuments[i - 1].getPath())) continue;", "-\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = (org.eclipse.jdt.core.ICompilationUnit) wcPaths.get(pathString);", "-\t\t\tif (workingCopy != null) {", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit workingCopy = null;", "+\t\t\tif (searchDocument instanceof JavaSearchParticipant.WorkingCopyDocument) {", "+\t\t\t\tworkingCopy = ((JavaSearchParticipant.WorkingCopyDocument)searchDocument).workingCopy;", "-\t\t\tmatchSet.add(new PossibleMatch(this, resource, openable));", "+\t\t\tmatchSet.add(new PossibleMatch(this, resource, openable, searchDocument));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ba91014b819002fafeab1e117f205f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "7c0534e311ca23dad63801edecab8ecfaf54c055", "commitAfterChange": "f0126485e71d6e9762ea26c839590b2bf7e1a885", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+\tIType focusType = this.getType();\r", "+\t\t\r", "+\tint length = allPotentialSubTypes.length;\r", "+\r", "+\t// inject the compilation unit of the focus type (so that types in\r", "+\t// this cu have special visibility permission (this is also usefull\r", "+\t// when the cu is a working copy)\r", "+\tOpenable focusCU = (Openable)focusType.getCompilationUnit();\r", "+\tString focusPath = null;\r", "+\tif (focusCU != null) {\r", "+\t\ttry {\r", "+\t\t\tIResource underlyingResource;\r", "+\t\t\tif (focusCU instanceof WorkingCopy) {\r", "+\t\t\t\tunderlyingResource = ((WorkingCopy)focusCU).getOriginalElement().getUnderlyingResource();\r", "+\t\t\t} else {\r", "+\t\t\t\tunderlyingResource = focusCU.getUnderlyingResource();\r", "+\t\t\t}\r", "+\t\t\tfocusPath = underlyingResource.getFullPath().toString();\r", "+\t\t} catch (JavaModelException e) {\r", "+\t\t\t// type does not exist\r", "+\t\t\treturn;\r", "+\t\t}\r", "+\t\tif (length > 0) {\r", "+\t\t\tSystem.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[length+1], 0, length);\r", "+\t\t\tallPotentialSubTypes[length] = focusPath;\t\r", "+\t\t} else {\r", "+\t\t\tallPotentialSubTypes = new String[] {focusPath};\r", "+\t\t}\r", "+\t\tlength++;\r", "+\t}\r", "+\t\r", "-\tIType focusType = this.getType();\r", "-\r", "-\tfor (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {\r", "+\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tOpenable handle = factory.createOpenable(resourcePath);\r", "-\t\t\tif (handle == null) continue; // match is outside classpath\r", "-\t\t\t// working copies take precedence over compilation units\r", "-\t\t\tObject workingCopy = this.handleToWorkingCopy.get(handle);\r", "-\t\t\tif (workingCopy != null) {\r", "-\t\t\t\thandle = (Openable)workingCopy;\r", "-\t\t\t}\r", "+\t\t\t// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)\r", "+\t\t\tif (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;\r", "+\t\t\t\r", "+\t\t\tOpenable handle = \r", "+\t\t\t\tresourcePath.equals(focusPath) ? \r", "+\t\t\t\t\tfocusCU :\r", "+\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "+\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\t\t// build current project\r", "+\t\r", "+\t// build last project\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eff4cf609a8783c246d047b7a2cd2385", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "2faa7dcefcba49716eb602b07f666c741c012441", "commitAfterChange": "0c050a9e41e2d9f51004e54259260763cb09b54a", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace, IWorkingCopy[] workingCopies)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(String[] filePaths, IWorkspace workspace, IWorkingCopy[] workingCopies)\r \t\tthrows JavaModelException", "diff": ["-\t\t// sort file paths projects\r", "-\t\tUtil.sort(filePaths); \r", "-\t\t\r", "-\t\tHashSet wcPaths = new HashSet(); // a set of Strings\r", "-\t\tif (workingCopies != null) {\r", "-\t\t\tfor (int i = 0, length = workingCopies.length; i < length; i++) {\r", "+\t\t\r", "+\t\t// substitute compilation units with working copies\r", "+\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\t\tint wcLength;\r", "+\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\t\tString[] newPaths = new String[wcLength];\r", "+\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "-\t\t\t\t\twcPaths.add(res.getFullPath().toString());\r", "+\t\t\t\t\tString path = res.getFullPath().toString();\r", "+\t\t\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\t\t\tnewPaths[i] = path;\r", "+\t\t\tint filePathsLength = filePaths.length;\r", "+\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "+\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "+\t\t\r", "+\t\t// sort file paths projects\r", "+\t\tUtil.sort(filePaths); \r", "-\t\tthis.initializeMatchingOpenables(workingCopies);\r", "+\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\t\t// skip paths that are hidden by a working copy\r", "-\t\t\tif (wcPaths.contains(pathString)) continue;\r", "+\t\t\t// skip duplicate paths\r", "+\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "-\t\t\tOpenable openable = this.handleFactory.createOpenable(pathString);\r", "-\t\t\tif (openable == null)\r", "-\t\t\t\tcontinue; // match is outside classpath\r", "+\t\t\tOpenable openable;\r", "+\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "+\t\t\tif (workingCopy != null) {\r", "+\t\t\t\topenable = (Openable)workingCopy;\r", "+\t\t\t} else {\r", "+\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "+\t\t\t\tif (openable == null)\r", "+\t\t\t\t\tcontinue; // match is outside classpath\r", "+\t\t\t}\r", "-\t\t\t\tresource = openable.getUnderlyingResource();\r", "+\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "+\t\t\t\t}\r", "-\t\t\t\t\t\tthis.initializeMatchingOpenables(workingCopies);\r", "+\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\t\tthis.initializeMatchingOpenables(workingCopies);\r", "-\t\t}\r", "+\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t} \r"]}], "num": 56937}