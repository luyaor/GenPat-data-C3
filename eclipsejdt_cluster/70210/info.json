{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ff2cd77f426e391b34a4f764d924e98c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "375b537e0f71b1d1f4427a9508d4ce54", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence)", "signatureAfterChange": " public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence)", "diff": ["-\t", "-\t// range check", "-\tboolean isInRange = ", "-\t\t\t\tscanner.initialPosition <= typeDeclaration.declarationSourceStart", "-\t\t\t\t&& scanner.eofPosition >= typeDeclaration.declarationSourceEnd;", "-\t", "-\tFieldDeclaration[] fields = typeDeclaration.fields;", "-\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "-\tTypeDeclaration[] memberTypes = typeDeclaration.memberTypes;", "-\tint fieldCounter = fields == null ? 0 : fields.length;", "-\tint methodCounter = methods == null ? 0 : methods.length;", "-\tint memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;", "-\tint fieldIndex = 0;", "-\tint methodIndex = 0;", "-\tint memberTypeIndex = 0;", "-\tboolean isInterface = typeDeclaration.isInterface();", "-", "-\tif (notifyTypePresence){", "-\t\tchar[][] interfaceNames = null;", "-\t\tint superInterfacesLength = 0;", "-\t\tTypeReference[] superInterfaces = typeDeclaration.superInterfaces;", "-\t\tif (superInterfaces != null) {", "-\t\t\tsuperInterfacesLength = superInterfaces.length;", "-\t\t\tinterfaceNames = new char[superInterfacesLength][];", "-\t\t} else {", "-\t\t\tif ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "-\t\t\t\t// see PR 3442", "-\t\t\t\tQualifiedAllocationExpression alloc = typeDeclaration.allocation;", "-\t\t\t\tif (alloc != null && alloc.type != null) {", "-\t\t\t\t\tsuperInterfaces = new TypeReference[] { typeDeclaration.allocation.type};", "-\t\t\t\t\tsuperInterfacesLength = 1;", "-\t\t\t\t\tinterfaceNames = new char[1][];", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (superInterfaces != null) {", "-\t\t\tfor (int i = 0; i < superInterfacesLength; i++) {", "-\t\t\t\tinterfaceNames[i] = ", "-\t\t\t\t\tCharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); ", "-\t\t\t}", "-\t\t}", "-\t\tif (isInterface) {", "-\t\t\tif (isInRange){", "-\t\t\t\tint currentModifiers = typeDeclaration.modifiers;", "-\t\t\t\tboolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "-\t\t\t\trequestor.enterInterface(", "-\t\t\t\t\ttypeDeclaration.declarationSourceStart, ", "-\t\t\t\t\tdeprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "-\t\t\t\t\ttypeDeclaration.name, ", "-\t\t\t\t\ttypeDeclaration.sourceStart, ", "-\t\t\t\t\tsourceEnd(typeDeclaration), ", "-\t\t\t\t\tinterfaceNames);", "-\t\t\t}", "-\t\t\tnotifySourceElementRequestor(typeDeclaration.typeParameters);\t\t\t", "-\t\t\tif (nestedTypeIndex == typeNames.length) {", "-\t\t\t\t// need a resize", "-\t\t\t\tSystem.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-\t\t\t\tSystem.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-\t\t\t}", "-\t\t\ttypeNames[nestedTypeIndex] = typeDeclaration.name;", "-\t\t\tsuperTypeNames[nestedTypeIndex++] = JAVA_LANG_OBJECT;", "-\t\t} else {", "-\t\t\tTypeReference superclass = typeDeclaration.superclass;", "-\t\t\tif (superclass == null) {", "-\t\t\t\tif (isInRange){", "-\t\t\t\t\trequestor.enterClass(", "-\t\t\t\t\t\ttypeDeclaration.declarationSourceStart, ", "-\t\t\t\t\t\ttypeDeclaration.modifiers, ", "-\t\t\t\t\t\ttypeDeclaration.name, ", "-\t\t\t\t\t\ttypeDeclaration.sourceStart, ", "-\t\t\t\t\t\tsourceEnd(typeDeclaration), ", "-\t\t\t\t\t\tnull, ", "-\t\t\t\t\t\tinterfaceNames);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (isInRange){", "-\t\t\t\t\trequestor.enterClass(", "-\t\t\t\t\t\ttypeDeclaration.declarationSourceStart, ", "-\t\t\t\t\t\ttypeDeclaration.modifiers, ", "-\t\t\t\t\t\ttypeDeclaration.name, ", "-\t\t\t\t\t\ttypeDeclaration.sourceStart, ", "-\t\t\t\t\t\tsourceEnd(typeDeclaration), ", "-\t\t\t\t\t\tCharOperation.concatWith(superclass.getParameterizedTypeName(), '.'), ", "-\t\t\t\t\t\tinterfaceNames);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tnotifySourceElementRequestor(typeDeclaration.typeParameters);\t\t\t", "-\t\t\tif (nestedTypeIndex == typeNames.length) {", "-\t\t\t\t// need a resize", "-\t\t\t\tSystem.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-\t\t\t\tSystem.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "-\t\t\t}", "-\t\t\ttypeNames[nestedTypeIndex] = typeDeclaration.name;", "-\t\t\tsuperTypeNames[nestedTypeIndex++] = superclass == null ? JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');", "-\t\t}", "-\t}", "-\twhile ((fieldIndex < fieldCounter)", "-\t\t|| (memberTypeIndex < memberTypeCounter)", "-\t\t|| (methodIndex < methodCounter)) {", "-\t\tFieldDeclaration nextFieldDeclaration = null;", "-\t\tAbstractMethodDeclaration nextMethodDeclaration = null;", "-\t\tTypeDeclaration nextMemberDeclaration = null;", "-", "-\t\tint position = Integer.MAX_VALUE;", "-\t\tint nextDeclarationType = -1;", "-\t\tif (fieldIndex < fieldCounter) {", "-\t\t\tnextFieldDeclaration = fields[fieldIndex];", "-\t\t\tif (nextFieldDeclaration.declarationSourceStart < position) {", "-\t\t\t\tposition = nextFieldDeclaration.declarationSourceStart;", "-\t\t\t\tnextDeclarationType = 0; // FIELD", "-\t\t\t}", "-\t\t}", "-\t\tif (methodIndex < methodCounter) {", "-\t\t\tnextMethodDeclaration = methods[methodIndex];", "-\t\t\tif (nextMethodDeclaration.declarationSourceStart < position) {", "-\t\t\t\tposition = nextMethodDeclaration.declarationSourceStart;", "-\t\t\t\tnextDeclarationType = 1; // METHOD", "-\t\t\t}", "-\t\t}", "-\t\tif (memberTypeIndex < memberTypeCounter) {", "-\t\t\tnextMemberDeclaration = memberTypes[memberTypeIndex];", "-\t\t\tif (nextMemberDeclaration.declarationSourceStart < position) {", "-\t\t\t\tposition = nextMemberDeclaration.declarationSourceStart;", "-\t\t\t\tnextDeclarationType = 2; // MEMBER", "-\t\t\t}", "-\t\t}", "-\t\tswitch (nextDeclarationType) {", "-\t\t\tcase 0 :", "-\t\t\t\tfieldIndex++;", "-\t\t\t\tnotifySourceElementRequestor(nextFieldDeclaration);", "-\t\t\t\tbreak;", "-\t\t\tcase 1 :", "-\t\t\t\tmethodIndex++;", "-\t\t\t\tnotifySourceElementRequestor(nextMethodDeclaration);", "-\t\t\t\tbreak;", "-\t\t\tcase 2 :", "-\t\t\t\tmemberTypeIndex++;", "-\t\t\t\tnotifySourceElementRequestor(nextMemberDeclaration, true);", "-\t\t}", "-\t}", "-\tif (notifyTypePresence){", "-\t\tif (isInRange){", "-\t\t\tif (isInterface) {", "-\t\t\t\trequestor.exitInterface(typeDeclaration.declarationSourceEnd);", "-\t\t\t} else {", "-\t\t\t\trequestor.exitClass(typeDeclaration.declarationSourceEnd);", "-\t\t\t}", "-\t\t}", "-\t\tnestedTypeIndex--;", "-\t}", "+   ", "+   // range check", "+   boolean isInRange = ", "+            scanner.initialPosition <= typeDeclaration.declarationSourceStart", "+            && scanner.eofPosition >= typeDeclaration.declarationSourceEnd;", "+   ", "+   FieldDeclaration[] fields = typeDeclaration.fields;", "+   AbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+   TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;", "+   int fieldCounter = fields == null ? 0 : fields.length;", "+   int methodCounter = methods == null ? 0 : methods.length;", "+   int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;", "+   int fieldIndex = 0;", "+   int methodIndex = 0;", "+   int memberTypeIndex = 0;", "+ ", "+   if (notifyTypePresence){", "+      char[][] interfaceNames = null;", "+      int superInterfacesLength = 0;", "+      TypeReference[] superInterfaces = typeDeclaration.superInterfaces;", "+      if (superInterfaces != null) {", "+         superInterfacesLength = superInterfaces.length;", "+         interfaceNames = new char[superInterfacesLength][];", "+      } else {", "+         if ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "+            // see PR 3442", "+            QualifiedAllocationExpression alloc = typeDeclaration.allocation;", "+            if (alloc != null && alloc.type != null) {", "+               superInterfaces = new TypeReference[] { alloc.type};", "+               superInterfacesLength = 1;", "+               interfaceNames = new char[1][];", "+            }", "+         }", "+      }", "+      if (superInterfaces != null) {", "+         for (int i = 0; i < superInterfacesLength; i++) {", "+            interfaceNames[i] = ", "+               CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); ", "+         }", "+      }", "+      switch (typeDeclaration.getKind()) {", "+         case IGenericType.CLASS :", "+         case IGenericType.ANNOTATION_TYPE :", "+            TypeReference superclass = typeDeclaration.superclass;", "+            if (superclass == null) {", "+               if (isInRange){", "+                  requestor.enterClass(", "+                     typeDeclaration.declarationSourceStart, ", "+                     typeDeclaration.modifiers, ", "+                     typeDeclaration.name, ", "+                     typeDeclaration.sourceStart, ", "+                     sourceEnd(typeDeclaration), ", "+                     null, ", "+                     interfaceNames);", "+               }", "+            } else {", "+               if (isInRange){", "+                  requestor.enterClass(", "+                     typeDeclaration.declarationSourceStart, ", "+                     typeDeclaration.modifiers, ", "+                     typeDeclaration.name, ", "+                     typeDeclaration.sourceStart, ", "+                     sourceEnd(typeDeclaration), ", "+                     CharOperation.concatWith(superclass.getParameterizedTypeName(), '.'), ", "+                     interfaceNames);", "+               }", "+            }", "+            notifySourceElementRequestor(typeDeclaration.typeParameters);         ", "+            if (nestedTypeIndex == typeNames.length) {", "+               // need a resize", "+               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+            }", "+            typeNames[nestedTypeIndex] = typeDeclaration.name;", "+            superTypeNames[nestedTypeIndex++] = superclass == null ? TypeConstants.CharArray_JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');", "+            break;", "+ ", "+         case IGenericType.INTERFACE :", "+            if (isInRange){", "+               int currentModifiers = typeDeclaration.modifiers;", "+               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "+               requestor.enterInterface(", "+                  typeDeclaration.declarationSourceStart, ", "+                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "+                  typeDeclaration.name, ", "+                  typeDeclaration.sourceStart, ", "+                  sourceEnd(typeDeclaration), ", "+                  interfaceNames);", "+            }", "+            notifySourceElementRequestor(typeDeclaration.typeParameters);         ", "+            if (nestedTypeIndex == typeNames.length) {", "+               // need a resize", "+               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+            }", "+            typeNames[nestedTypeIndex] = typeDeclaration.name;", "+            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_OBJECT;", "+            break;", "+ ", "+         case IGenericType.ENUM :", "+ ", "+            if (isInRange){", "+               int currentModifiers = typeDeclaration.modifiers;", "+               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below", "+               requestor.enterEnum(", "+                  typeDeclaration.declarationSourceStart, ", "+                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "+                  typeDeclaration.name, ", "+                  typeDeclaration.sourceStart, ", "+                  sourceEnd(typeDeclaration), ", "+                  interfaceNames);", "+            }", "+            notifySourceElementRequestor(typeDeclaration.typeParameters);         ", "+            if (nestedTypeIndex == typeNames.length) {", "+               // need a resize", "+               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);", "+            }", "+            typeNames[nestedTypeIndex] = typeDeclaration.name;", "+            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_ENUM;", "+            break;", "+ ", "+//         case IGenericType.ANNOTATION_TYPE :", "+            // TODO need support", "+//            break;", "+      }      ", "+   }", "+   while ((fieldIndex < fieldCounter)", "+      || (memberTypeIndex < memberTypeCounter)", "+      || (methodIndex < methodCounter)) {", "+      FieldDeclaration nextFieldDeclaration = null;", "+      AbstractMethodDeclaration nextMethodDeclaration = null;", "+      TypeDeclaration nextMemberDeclaration = null;", "+ ", "+      int position = Integer.MAX_VALUE;", "+      int nextDeclarationType = -1;", "+      if (fieldIndex < fieldCounter) {", "+         nextFieldDeclaration = fields[fieldIndex];", "+         if (nextFieldDeclaration.declarationSourceStart < position) {", "+            position = nextFieldDeclaration.declarationSourceStart;", "+            nextDeclarationType = 0; // FIELD", "+         }", "+      }", "+      if (methodIndex < methodCounter) {", "+         nextMethodDeclaration = methods[methodIndex];", "+         if (nextMethodDeclaration.declarationSourceStart < position) {", "+            position = nextMethodDeclaration.declarationSourceStart;", "+            nextDeclarationType = 1; // METHOD", "+         }", "+      }", "+      if (memberTypeIndex < memberTypeCounter) {", "+         nextMemberDeclaration = memberTypes[memberTypeIndex];", "+         if (nextMemberDeclaration.declarationSourceStart < position) {", "+            position = nextMemberDeclaration.declarationSourceStart;", "+            nextDeclarationType = 2; // MEMBER", "+         }", "+      }", "+      switch (nextDeclarationType) {", "+         case 0 :", "+            fieldIndex++;", "+            notifySourceElementRequestor(nextFieldDeclaration);", "+            break;", "+         case 1 :", "+            methodIndex++;", "+            notifySourceElementRequestor(nextMethodDeclaration);", "+            break;", "+         case 2 :", "+            memberTypeIndex++;", "+            notifySourceElementRequestor(nextMemberDeclaration, true);", "+      }", "+   }", "+   if (notifyTypePresence){", "+      if (isInRange){", "+         switch (typeDeclaration.getKind()) {", "+            case IGenericType.CLASS :", "+            case IGenericType.ANNOTATION_TYPE :", "+               requestor.exitClass(typeDeclaration.declarationSourceEnd);", "+               break;", "+            case IGenericType.INTERFACE :", "+               requestor.exitInterface(typeDeclaration.declarationSourceEnd);", "+               break;", "+            case IGenericType.ENUM :", "+               requestor.exitEnum(typeDeclaration.declarationSourceEnd);", "+               break;", "+/*            case IGenericType.ANNOTATION_TYPE :", "+               // TODO need support", "+               //requestor.exitAnnotationType(typeDeclaration.declarationSourceEnd);", "+               break;*/", "+         }         ", "+      }", "+      nestedTypeIndex--;", "+   }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51ef6ce986df154edca5a2b53e6b11c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "d4b8f1437bd894de59822a00977399b8af50c7a1", "commitAfterChange": "00e190bf5f96c54b05d4853702eef90ea6dc4747", "methodNumberBeforeChange": 241, "methodNumberAfterChange": 241, "signatureBeforeChange": " protected void reportSyntaxError(int act, int currentKind, int stateStackTop)", "signatureAfterChange": " protected void reportSyntaxError(int act, int currentKind, int stateStackTop)", "diff": ["-\t\tif ((length == 2)", "-\t\t\t&& (tokenName.equals(\";\")) //$NON-NLS-1$", "-\t\t\t&& (expectings[0] == \"++\") //$NON-NLS-1$", "-\t\t\t&& (expectings[1] == \"--\") //$NON-NLS-1$", "+\t\tif ((length == 14)", "+\t\t\t&& (expectings[0] == \"=\") //$NON-NLS-1$", "+\t\t\t&& (expectings[1] == \"*=\") //$NON-NLS-1$", "-\t\t\t// the ; is not the expected token ==> it ends a statement when an expression is not ended", "-\t\t\tproblemReporter().invalidExpressionAsStatement(expressionStack[expressionPtr]);", "+\t\t\t\tswitch(currentKind) {", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameSEMICOLON:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNamePLUS:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameMINUS:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameDIVIDE:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameREMAINDER:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameMULTIPLY:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameLEFT_SHIFT:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameRIGHT_SHIFT:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameLESS:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameGREATER:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameLESS_EQUAL:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameGREATER_EQUAL:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameEQUAL_EQUAL:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameNOT_EQUAL:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameXOR:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameAND:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameOR:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameOR_OR:", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameAND_AND:", "+\t\t\t\t\t\t// the ; is not the expected token ==> it ends a statement when an expression is not ended", "+\t\t\t\t\t\tproblemReporter().invalidExpressionAsStatement(expressionStack[expressionPtr]);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase ITerminalSymbols.TokenNameRBRACE :", "+\t\t\t\t\t\tproblemReporter().missingSemiColon(expressionStack[expressionPtr]);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tchar[] tokenSource;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\ttokenSource = this.scanner.getCurrentTokenSource();", "+\t\t\t\t\t\t} catch (Exception e) {", "+\t\t\t\t\t\t\ttokenSource = new char[] {};", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tproblemReporter().parseError(", "+\t\t\t\t\t\t\tthis.scanner.startPosition, ", "+\t\t\t\t\t\t\tthis.scanner.currentPosition - 1, ", "+\t\t\t\t\t\t\ttokenSource, ", "+\t\t\t\t\t\t\ttokenName, ", "+\t\t\t\t\t\t\texpectings); ", "+\t\t\t\t\t\tthis.checkAndReportBracketAnomalies(problemReporter());", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66e93182e87ed01fe10933d3caae3262", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "13d2f617e2307a81f1ff967feb328a472a058ad0", "commitAfterChange": "ba73d03b72a57aed50025829bc3cf0ad3ce1483c", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprotected Object parseQualifiedName(boolean reset) throws InvalidInputException", "signatureAfterChange": " \tprotected Object parseQualifiedName(boolean reset) throws InvalidInputException", "diff": ["-\t\t\t\tcase TerminalTokens.TokenNamevoid :", "-\t\t\t\tcase TerminalTokens.TokenNameboolean :", "-\t\t\t\tcase TerminalTokens.TokenNamebyte :", "-\t\t\t\tcase TerminalTokens.TokenNamechar :", "-\t\t\t\tcase TerminalTokens.TokenNamedouble :", "-\t\t\t\tcase TerminalTokens.TokenNamefloat :", "-\t\t\t\tcase TerminalTokens.TokenNameint :", "-\t\t\t\tcase TerminalTokens.TokenNamelong :", "-\t\t\t\tcase TerminalTokens.TokenNameshort :", "-\t\t\t\t\tif (iToken > 0) {", "-\t\t\t\t\t\tthrow new InvalidInputException();", "+\t\t\t\tcase TerminalTokens.TokenNameabstract:", "+\t\t\t\tcase TerminalTokens.TokenNameassert:", "+\t\t\t\tcase TerminalTokens.TokenNameboolean:", "+\t\t\t\tcase TerminalTokens.TokenNamebreak:", "+\t\t\t\tcase TerminalTokens.TokenNamebyte:", "+\t\t\t\tcase TerminalTokens.TokenNamecase:", "+\t\t\t\tcase TerminalTokens.TokenNamecatch:", "+\t\t\t\tcase TerminalTokens.TokenNamechar:", "+\t\t\t\tcase TerminalTokens.TokenNameclass:", "+\t\t\t\tcase TerminalTokens.TokenNamecontinue:", "+\t\t\t\tcase TerminalTokens.TokenNamedefault:", "+\t\t\t\tcase TerminalTokens.TokenNamedo:", "+\t\t\t\tcase TerminalTokens.TokenNamedouble:", "+\t\t\t\tcase TerminalTokens.TokenNameelse:", "+\t\t\t\tcase TerminalTokens.TokenNameextends:", "+\t\t\t\tcase TerminalTokens.TokenNamefalse:", "+\t\t\t\tcase TerminalTokens.TokenNamefinal:", "+\t\t\t\tcase TerminalTokens.TokenNamefinally:", "+\t\t\t\tcase TerminalTokens.TokenNamefloat:", "+\t\t\t\tcase TerminalTokens.TokenNamefor:", "+\t\t\t\tcase TerminalTokens.TokenNameif:", "+\t\t\t\tcase TerminalTokens.TokenNameimplements:", "+\t\t\t\tcase TerminalTokens.TokenNameimport:", "+\t\t\t\tcase TerminalTokens.TokenNameinstanceof:", "+\t\t\t\tcase TerminalTokens.TokenNameint:", "+\t\t\t\tcase TerminalTokens.TokenNameinterface:", "+\t\t\t\tcase TerminalTokens.TokenNamelong:", "+\t\t\t\tcase TerminalTokens.TokenNamenative:", "+\t\t\t\tcase TerminalTokens.TokenNamenew:", "+\t\t\t\tcase TerminalTokens.TokenNamenull:", "+\t\t\t\tcase TerminalTokens.TokenNamepackage:", "+\t\t\t\tcase TerminalTokens.TokenNameprivate:", "+\t\t\t\tcase TerminalTokens.TokenNameprotected:", "+\t\t\t\tcase TerminalTokens.TokenNamepublic:", "+\t\t\t\tcase TerminalTokens.TokenNameshort:", "+\t\t\t\tcase TerminalTokens.TokenNamestatic:", "+\t\t\t\tcase TerminalTokens.TokenNamestrictfp:", "+\t\t\t\tcase TerminalTokens.TokenNamesuper:", "+\t\t\t\tcase TerminalTokens.TokenNameswitch:", "+\t\t\t\tcase TerminalTokens.TokenNamesynchronized:", "+\t\t\t\tcase TerminalTokens.TokenNamethis:", "+\t\t\t\tcase TerminalTokens.TokenNamethrow:", "+\t\t\t\tcase TerminalTokens.TokenNametransient:", "+\t\t\t\tcase TerminalTokens.TokenNametrue:", "+\t\t\t\tcase TerminalTokens.TokenNametry:", "+\t\t\t\tcase TerminalTokens.TokenNamevoid:", "+\t\t\t\tcase TerminalTokens.TokenNamevolatile:", "+\t\t\t\tcase TerminalTokens.TokenNamewhile:", "+\t\t\t\t\tif (iToken == 0) {", "+\t\t\t\t\t\tpushIdentifier(true, true);", "+\t\t\t\t\t\tprimitiveToken = token;", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\tpushIdentifier(true, false);", "-\t\t\t\t\tprimitiveToken = token;", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tbreak nextToken;", "-", "+\t\t\t\t\t// Fall through default case to verify that we do not leave on a dot", "+\t\t\t\t\t//$FALL-THROUGH$"]}], "num": 70210}