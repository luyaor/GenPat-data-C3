{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6c80ecdbc80affcc9f4fd2d750aee336", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "163097d6a97953aa82b6f1b6a4102946", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " public void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t */", "-\tpublic void generateCode(BlockScope currentScope, CodeStream codeStream) {", "-\t\tif ((bits & IsReachable) == 0) {", "-\t\t\treturn;", "-\t\t}", "-\t\tint pc = codeStream.position;", "-\t\t// generate the expression", "-\t\tif ((this.expression != null) && (this.expression.constant == Constant.NotAConstant)) {", "-\t\t\tthis.expression.generateCode(currentScope, codeStream, needValue()); // no value needed if non-returning subroutine", "-\t\t\tgenerateStoreSaveValueIfNecessary(codeStream);", "-\t\t}", "-\t\t", "-\t\t// generation of code responsible for invoking the finally blocks in sequence", "-\t\tif (subroutines != null) {", "-\t\t\tfor (int i = 0, max = subroutines.length; i < max; i++) {", "-\t\t\t\tSubRoutineStatement sub = subroutines[i];", "-\t\t\t\tsub.generateSubRoutineInvocation(currentScope, codeStream);", "-\t\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t\t\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t\t\t\t\t\tSubRoutineStatement.reenterAnyExceptionHandlers(subroutines, i, codeStream);", "-\t\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t\tsub.exitAnyExceptionHandler();", "-\t\t\t}", "-\t\t}", "-\t\tif (saveValueVariable != null) codeStream.load(saveValueVariable);", "-\t\t", "-\t\tif ((this.expression != null) && (this.expression.constant != Constant.NotAConstant)) {", "-\t\t\tcodeStream.generateConstant(this.expression.constant, this.expression.implicitConversion);", "-\t\t\tgenerateStoreSaveValueIfNecessary(codeStream);\t\t", "-\t\t}", "-\t\t// output the suitable return bytecode or wrap the value inside a descriptor for doits", "-\t\tthis.generateReturnBytecode(codeStream);", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "-\t\tSubRoutineStatement.reenterAnyExceptionHandlers(subroutines, -1, codeStream);", "-\t}", "+ */", "+public void generateCode(BlockScope currentScope, CodeStream codeStream) {", "+\tif ((this.bits & ASTNode.IsReachable) == 0) {", "+\t\treturn;", "+\t}", "+\tint pc = codeStream.position;", "+\tboolean alreadyGeneratedExpression = false;", "+\t// generate the expression", "+\tif ((this.expression != null) && (this.expression.constant == Constant.NotAConstant) && !(this.expression instanceof NullLiteral)) {", "+\t\talreadyGeneratedExpression = true;", "+\t\tthis.expression.generateCode(currentScope, codeStream, needValue()); // no value needed if non-returning subroutine", "+\t\tgenerateStoreSaveValueIfNecessary(codeStream);", "+\t}", "+\t", "+\t// generation of code responsible for invoking the finally blocks in sequence", "+\tif (this.subroutines != null) {", "+\t\tObject reusableJSRTarget = this.expression == null ? (Object)TypeBinding.VOID : this.expression.reusableJSRTarget();", "+\t\tfor (int i = 0, max = this.subroutines.length; i < max; i++) {", "+\t\t\tSubRoutineStatement sub = this.subroutines[i];", "+\t\t\tboolean didEscape = sub.generateSubRoutineInvocation(currentScope, codeStream, reusableJSRTarget);", "+\t\t\tif (didEscape) {", "+\t\t\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\t\t\tSubRoutineStatement.reenterAllExceptionHandlers(this.subroutines, i, codeStream);", "+\t\t\t\t\treturn;", "+\t\t}", "+\t}", "+\tif (this.saveValueVariable != null) {", "+\t\tcodeStream.load(this.saveValueVariable);", "+\t}", "+\tif (this.expression != null && !alreadyGeneratedExpression) {", "+\t\tthis.expression.generateCode(currentScope, codeStream, true);", "+\t\tgenerateStoreSaveValueIfNecessary(codeStream);\t", "+\t}", "+\t// output the suitable return bytecode or wrap the value inside a descriptor for doits", "+\tthis.generateReturnBytecode(codeStream);", "+\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\tSubRoutineStatement.reenterAllExceptionHandlers(this.subroutines, -1, codeStream);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4b68db557d8711f52815fa720fe7523c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a12b1847e48d96ac5e805a907f4cf72bcc8b1f19", "commitAfterChange": "1f22eae4a2779bf8c236df5ff222307e09db45c0", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 67, "signatureBeforeChange": " \tprivate char[][] findMethodParameterNames(MethodBinding method, char[][] parameterTypeNames)", "signatureAfterChange": " \tprivate char[][] findMethodParameterNames(MethodBinding method, char[][] parameterTypeNames)", "diff": ["-\t\tReferenceBinding bindingType = method.declaringClass;", "+\t\tTypeBinding erasure =  method.declaringClass.erasure();", "+\t\tif(!(erasure instanceof ReferenceBinding)) return null;", "-\t\tif (bindingType instanceof SourceTypeBinding){", "-\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) bindingType;", "+\t\tif (erasure instanceof SourceTypeBinding){", "+\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) erasure;", "+\t\t\t", "+\t\t\tReferenceBinding bindingType = (ReferenceBinding)erasure;", "+\t\t\t", "-\t\t\t\tSourceMethod[] sourceMethods = ((SourceTypeElementInfo) sourceType).getMethodHandles();", "-\t\t\t\tint len = sourceMethods.length;", "-\t\t\t\tfor(int i = 0; i < len ; i++){", "-\t\t\t\t\tSourceMethod sourceMethod = sourceMethods[i];", "-\t\t\t\t\tString[] argTypeSignatures = sourceMethod.getParameterTypes();", "-", "-\t\t\t\t\tif(argTypeSignatures != null &&", "-\t\t\t\t\t\tCharOperation.equals(method.selector,sourceMethod.getElementName().toCharArray()) &&", "-\t\t\t\t\t\tequalSignatures(parameterTypeNames, argTypeSignatures)){", "+\t\t\t\tIType typeHandle = ((SourceTypeElementInfo) sourceType).getHandle();", "+\t\t\t\t", "+\t\t\t\tString[] parameterTypeSignatures = new String[length];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tparameterTypeSignatures[i] = Signature.createTypeSignature(parameterTypeNames[i], false);", "+\t\t\t\t}", "+\t\t\t\tIMethod searchedMethod = typeHandle.getMethod(String.valueOf(method.selector), parameterTypeSignatures);", "+\t\t\t\tIMethod[] foundMethods = typeHandle.findMethods(searchedMethod);", "+\t\t\t\t", "+\t\t\t\tif(foundMethods != null) {", "+\t\t\t\t\tint len = foundMethods.length;", "+\t\t\t\t\tif(len == 1) {", "+\t\t\t\t\t\t\tSourceMethod sourceMethod = (SourceMethod) foundMethods[0];", "-\t\t\t\t\t\t\tbreak;", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a184dd7721d159d62110c8e2d270450c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CreateMethodOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " protected String[] convertDOMMethodTypesToSignatures()", "signatureAfterChange": " protected String[] convertASTMethodTypesToSignatures()", "diff": ["-// TODO - JDOM - remove once model ported off of JDOM", "-protected String[] convertDOMMethodTypesToSignatures() {", "-\tif (fParameterTypes == null) {", "-\t\tif (isDOMNodeNull()) {", "-\t\t\tString[] domParameterTypes = ((IDOMMethod)fDOMNode).getParameterTypes();", "-\t\t\tif (domParameterTypes != null) {", "-\t\t\t\tfParameterTypes = new String[domParameterTypes.length];", "-\t\t\t\t// convert the DOM types to signatures", "-\t\t\t\tint i;", "-\t\t\t\tfor (i = 0; i < fParameterTypes.length; i++) {", "-\t\t\t\t\tfParameterTypes[i] = Signature.createTypeSignature(domParameterTypes[i].toCharArray(), false);", "-\t\t\t\t}", "+protected String[] convertASTMethodTypesToSignatures() {", "+\tif (this.parameterTypes == null) {", "+\t\tif (this.createdNode != null) {", "+\t\t\tList parameters = ((MethodDeclaration) this.createdNode).parameters();", "+\t\t\tint size = parameters.size();", "+\t\t\tthis.parameterTypes = new String[size];", "+\t\t\tIterator iterator = parameters.iterator();", "+\t\t\t// convert the AST types to signatures", "+\t\t\tfor (int i = 0; i < size; i++) {", "+\t\t\t\tSingleVariableDeclaration parameter = (SingleVariableDeclaration) iterator.next();", "+\t\t\t\tthis.parameterTypes[i] = Util.getSignature(parameter.getType());", "-\treturn fParameterTypes;", "+\treturn this.parameterTypes;"]}], "num": 68915}