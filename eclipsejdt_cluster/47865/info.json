{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4c8f0ff3d46dbad85057c95676db3e33", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5a885773531d40914f0a9114af5a300f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 140, "methodNumberAfterChange": 21, "signatureBeforeChange": " public void initializeMaxLocals(MethodBinding methodBinding)", "signatureAfterChange": "  public void initializeMaxLocals(MethodBinding methodBinding)", "diff": ["-}", "-public void initializeMaxLocals(MethodBinding methodBinding) {", "-    super.initializeMaxLocals(methodBinding);", "-    StackMapFrame frame = new StackMapFrame();", "-    frame.pc = -1;", "-", "-    if (this.maxLocals != 0) {", "-        int resolvedPosition = 0;", "-        // take into account enum constructor synthetic name+ordinal", "-        final boolean isConstructor = methodBinding.isConstructor();", "-        if (isConstructor) {", "-            frame.putLocal(resolvedPosition, new VerificationTypeInfo(VerificationTypeInfo.ITEM_UNINITIALIZED_THIS, methodBinding.declaringClass));", "-            resolvedPosition++;", "-        } else if (!methodBinding.isStatic()) {", "-            frame.putLocal(resolvedPosition, new VerificationTypeInfo(VerificationTypeInfo.ITEM_OBJECT, methodBinding.declaringClass));", "-            resolvedPosition++;", "-        }", "-", "-        if (isConstructor) {", "-            if (methodBinding.declaringClass.isEnum()) {", "-                frame.putLocal(resolvedPosition, new VerificationTypeInfo(TypeIds.T_JavaLangString, ConstantPool.JavaLangStringConstantPoolName));", "-                resolvedPosition++;", "-                frame.putLocal(resolvedPosition, new VerificationTypeInfo(TypeBinding.INT));", "-                resolvedPosition++;", "-            }", "-", "-            // take into account the synthetic parameters", "-            if (methodBinding.declaringClass.isNestedType()) {", "-                ReferenceBinding enclosingInstanceTypes[];", "-                if ((enclosingInstanceTypes = methodBinding.declaringClass.syntheticEnclosingInstanceTypes()) != null) {", "-                    for (int i = 0, max = enclosingInstanceTypes.length; i < max; i++) {", "-                         // an enclosingInstanceType can only be a reference binding. It cannot be", "-                        // LongBinding or DoubleBinding", "-                        frame.putLocal(resolvedPosition, new VerificationTypeInfo(enclosingInstanceTypes[i]));", "-                        resolvedPosition++;", "-                    }", "-                }", "-", "-                TypeBinding[] arguments;", "-                if ((arguments = methodBinding.parameters) != null) {", "-                    for (int i = 0, max = arguments.length; i < max; i++) {", "-                        final TypeBinding typeBinding = arguments[i];", "-                        frame.putLocal(resolvedPosition, new VerificationTypeInfo(typeBinding));", "-                        switch(typeBinding.id) {", "-                            case TypeIds.T_double :", "-                            case TypeIds.T_long :", "-                                resolvedPosition += 2;", "-                                break;", "-                            default:", "-                                resolvedPosition++;", "-                        }", "-                    }", "-                }", "-", "-                SyntheticArgumentBinding syntheticArguments[];", "-                if ((syntheticArguments = methodBinding.declaringClass.syntheticOuterLocalVariables()) != null) {", "-                    for (int i = 0, max = syntheticArguments.length; i < max; i++) {", "-                        final TypeBinding typeBinding = syntheticArguments[i].type;", "-                        frame.putLocal(resolvedPosition, new VerificationTypeInfo(typeBinding));", "-                        switch(typeBinding.id) {", "-                            case TypeIds.T_double :", "-                            case TypeIds.T_long :", "-                                resolvedPosition+=2;", "-                                break;", "-                            default:", "-                                resolvedPosition++;", "-                        }", "-                    }", "-                }", "-            } else {", "-                TypeBinding[] arguments;", "-                if ((arguments = methodBinding.parameters) != null) {", "-                    for (int i = 0, max = arguments.length; i < max; i++) {", "-                        final TypeBinding typeBinding = arguments[i];", "-                        frame.putLocal(resolvedPosition, new VerificationTypeInfo(typeBinding));", "-                        switch(typeBinding.id) {", "-                            case TypeIds.T_double :", "-                            case TypeIds.T_long :", "-                                resolvedPosition += 2;", "-                                break;", "-                            default:", "-                                resolvedPosition++;", "-                        }", "-                    }", "-                }", "-            }", "-        } else {", "-            TypeBinding[] arguments;", "-            if ((arguments = methodBinding.parameters) != null) {", "-                for (int i = 0, max = arguments.length; i < max; i++) {", "-                    final TypeBinding typeBinding = arguments[i];", "-                    frame.putLocal(resolvedPosition, new VerificationTypeInfo(typeBinding));", "-                    switch(typeBinding.id) {", "-                        case TypeIds.T_double :", "-                        case TypeIds.T_long :", "-                            resolvedPosition += 2;", "-                            break;", "-                        default:", "-                            resolvedPosition++;", "-                    }", "-                }", "-            }", "-        }", "-    }", "-    try {", "-        this.frames = new ArrayList();", "-        this.frames.add(frame.clone());", "-    } catch (CloneNotSupportedException e) {", "-        e.printStackTrace();", "-    }", "-    this.currentFrame = frame;", "-    this.framePositions = new HashSet();", "-    this.variablesModificationsPositions = new ArrayList();", "-}", "+", "+public void initializeMaxLocals(MethodBinding methodBinding) {", "+\tsuper.initializeMaxLocals(methodBinding);", "+\tif (this.framePositions == null) {", "+\t\tthis.framePositions = new HashMap();", "+\t} else {", "+\t\tthis.framePositions.clear();", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76ccda7d0221d1faecc60d1e335346c0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 9, "signatureBeforeChange": " public void addDefinitelyAssignedVariables(Scope scope, int initStateIndex)", "signatureAfterChange": " public void addDefinitelyAssignedVariables(Scope scope, int initStateIndex)", "diff": ["-    // Required to fix 1PR0XVS: LFRE:WINNT - Compiler: variable table for method appears incorrect", "-    loop: for (int i = 0; i < visibleLocalsCount; i++) {", "-        LocalVariableBinding localBinding = visibleLocals[i];", "-        if (localBinding != null) {", "-            // Check if the local is definitely assigned", "-            boolean isDefinitelyAssigned = isDefinitelyAssigned(scope, initStateIndex, localBinding);", "-            if (!isDefinitelyAssigned) {", "-                if (this.stateIndexes != null) {", "-                    for (int j = 0, max = this.stateIndexesCounter; j < max; j++) {", "-                        if (isDefinitelyAssigned(scope, this.stateIndexes[j], localBinding)) {", "-                            currentFrame.putLocal(localBinding.resolvedPosition, new VerificationTypeInfo(localBinding.type));", "-                            if ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {", "-                                /* There are two cases:", "-                                 * 1) there is no initialization interval opened ==> add an opened interval", "-                                 * 2) there is already some initialization intervals but the last one is closed ==> add an opened interval", "-                                 * An opened interval means that the value at localBinding.initializationPCs[localBinding.initializationCount - 1][1]", "-                                 * is equals to -1.", "-                                 * initializationPCs is a collection of pairs of int:", "-                                 * \tfirst value is the startPC and second value is the endPC. -1 one for the last value means that the interval", "-                                 * \tis not closed yet.", "-                                 */", "-                                localBinding.recordInitializationStartPC(position);", "-                            }", "-                            continue loop;", "-                        }", "-                    }", "-                }", "-            } else {", "-                currentFrame.putLocal(localBinding.resolvedPosition, new VerificationTypeInfo(localBinding.type));", "-                if ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {", "-                    /* There are two cases:", "-                     * 1) there is no initialization interval opened ==> add an opened interval", "-                     * 2) there is already some initialization intervals but the last one is closed ==> add an opened interval", "-                     * An opened interval means that the value at localBinding.initializationPCs[localBinding.initializationCount - 1][1]", "-                     * is equals to -1.", "-                     * initializationPCs is a collection of pairs of int:", "-                     * \tfirst value is the startPC and second value is the endPC. -1 one for the last value means that the interval", "-                     * \tis not closed yet.", "-                     */", "-                    localBinding.recordInitializationStartPC(position);", "-                }", "-            }", "-        }", "-    }", "-    Integer newValue = new Integer(this.position);", "-    if (this.variablesModificationsPositions.size() == 0 || !this.variablesModificationsPositions.get(this.variablesModificationsPositions.size() - 1).equals(newValue)) {", "-        this.variablesModificationsPositions.add(newValue);", "-    }", "-    storeStackMapFrame();", "+\t// Required to fix 1PR0XVS: LFRE:WINNT - Compiler: variable table for method appears incorrect", "+\tloop: for (int i = 0; i < visibleLocalsCount; i++) {", "+\t\tLocalVariableBinding localBinding = visibleLocals[i];", "+\t\tif (localBinding != null) {", "+\t\t\t// Check if the local is definitely assigned", "+\t\t\tboolean isDefinitelyAssigned = isDefinitelyAssigned(scope, initStateIndex, localBinding);", "+\t\t\tif (!isDefinitelyAssigned) {", "+\t\t\t\tif (this.stateIndexes != null) {", "+\t\t\t\t\tfor (int j = 0, max = this.stateIndexesCounter; j < max; j++) {", "+\t\t\t\t\t\tif (isDefinitelyAssigned(scope, this.stateIndexes[j], localBinding)) {", "+\t\t\t\t\t\t\tif ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {", "+\t\t\t\t\t\t\t\t/* There are two cases:", "+\t\t\t\t\t\t\t\t * 1) there is no initialization interval opened ==> add an opened interval", "+\t\t\t\t\t\t\t\t * 2) there is already some initialization intervals but the last one is closed ==> add an opened interval", "+\t\t\t\t\t\t\t\t * An opened interval means that the value at localBinding.initializationPCs[localBinding.initializationCount - 1][1]", "+\t\t\t\t\t\t\t\t * is equals to -1.", "+\t\t\t\t\t\t\t\t * initializationPCs is a collection of pairs of int:", "+\t\t\t\t\t\t\t\t * \tfirst value is the startPC and second value is the endPC. -1 one for the last value means that the interval", "+\t\t\t\t\t\t\t\t * \tis not closed yet.", "+\t\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\t\tlocalBinding.recordInitializationStartPC(position);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue loop;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {", "+\t\t\t\t\t/* There are two cases:", "+\t\t\t\t\t * 1) there is no initialization interval opened ==> add an opened interval", "+\t\t\t\t\t * 2) there is already some initialization intervals but the last one is closed ==> add an opened interval", "+\t\t\t\t\t * An opened interval means that the value at localBinding.initializationPCs[localBinding.initializationCount - 1][1]", "+\t\t\t\t\t * is equals to -1.", "+\t\t\t\t\t * initializationPCs is a collection of pairs of int:", "+\t\t\t\t\t * \tfirst value is the startPC and second value is the endPC. -1 one for the last value means that the interval", "+\t\t\t\t\t * \tis not closed yet.", "+\t\t\t\t\t */", "+\t\t\t\t\tlocalBinding.recordInitializationStartPC(position);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}], "num": 47865}