{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "70cedd5e359e34ff84682478bc9904aa", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b82ea031bbd31a3a12b7308470a5956", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "c1cf01c530411de2efbd387e25a51a976ee057a9", "commitAfterChange": "d4fb0fb51b1c723a05d230645f038ab08aa3a386", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "signatureAfterChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "diff": ["-\t\t\tInferenceContext18.missingImplementation(\"NYI: inexact method reference\"); //$NON-NLS-1$", "-\t\t\t// FIXME: Otherwise, a search for a compile-time declaration is performed, as defined in 15.28.1 .....", "+\t\t\t// Otherwise, a search for a compile-time declaration is performed, as defined in 15.28.1....", "+\t\t\treference.resolveTypeExpecting(reference.enclosingScope, t);", "+\t\t\tMethodBinding compileTimeDecl = reference.binding;", "+\t\t\tif (compileTimeDecl == null || !compileTimeDecl.isValidBinding())", "+\t\t\t\treturn FALSE;", "+\t\t\tTypeBinding r = functionType.isConstructor() ? functionType.declaringClass : functionType.returnType;", "+\t\t\tif (r.id == TypeIds.T_void)", "+\t\t\t\treturn TRUE;", "+\t\t\t// ignore parameterization of resolve result and do a fresh start:", "+\t\t\tMethodBinding original = compileTimeDecl.original();", "+\t\t\tif (reference.typeArguments == null", "+\t\t\t\t\t&& ((original.typeVariables() != Binding.NO_TYPE_VARIABLES && r.mentionsAny(original.typeVariables(), -1))", "+\t\t\t\t\t\t|| (original.isConstructor() && original.declaringClass.typeVariables() != Binding.NO_TYPE_VARIABLES && r.mentionsAny(original.declaringClass.typeVariables(), -1)))) ", "+\t\t\t{", "+\t\t\t\tInvocationRecord prevInvocation = inferenceContext.enterPolyInvocation(reference, null/*no invocation arguments available*/);", "+", "+\t\t\t\t// Invocation Applicability Inference: 18.5.1 & Invocation Type Inference: 18.5.2", "+\t\t\t\ttry {", "+\t\t\t\t\tinferInvocationApplicability(inferenceContext, original, functionType.parameters, original.isConstructor()/*mimic a diamond?*/, inferenceContext.inferenceKind);", "+\t\t\t\t\tif (!inferPolyInvocationType(inferenceContext, reference, r, original))", "+\t\t\t\t\t\treturn FALSE;", "+\t\t\t\t\treturn null; // already incorporated", "+\t\t\t\t} catch (InferenceFailureException e) {", "+\t\t\t\t\treturn FALSE;", "+\t\t\t\t} finally {", "+\t\t\t\t\tinferenceContext.leavePolyInvocation(prevInvocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tTypeBinding rPrime = compileTimeDecl.isConstructor() ? compileTimeDecl.declaringClass : compileTimeDecl.returnType;", "+\t\t\tif (rPrime.id == TypeIds.T_void)", "+\t\t\t\treturn FALSE;", "+\t\t\treturn new ConstraintTypeFormula(rPrime, r, COMPATIBLE, this.isSoft);", "-\t\treturn FALSE;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "983d27a5c18a8afd7277c563ffa04d8b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "c74124c71dc16aadffc9c127481cf29440dd03c8", "commitAfterChange": "2d053de9651cebac3cf0a82f4012b7196ccb5c83", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "signatureAfterChange": "  \tprivate Object reduceReferenceExpressionCompatibility(ReferenceExpression reference, InferenceContext18 inferenceContext)", "diff": ["-\t\t\t\t\t\t|| (original.isConstructor() && original.declaringClass.typeVariables() != Binding.NO_TYPE_VARIABLES && r.mentionsAny(original.declaringClass.typeVariables(), -1)))) ", "+\t\t\t\t\t\t|| (original.isConstructor() && original.declaringClass.typeVariables() != Binding.NO_TYPE_VARIABLES)))", "+\t\t\t\t\t\t\t// not checking r.mentionsAny for constructors, because A::new resolves to the raw type", "+\t\t\t\t\t\t\t// whereas in fact the type of all expressions of this shape depends on their type variable (if any)", "-\t\t\t\t\treturn null; // already incorporated", "+\t\t\t\t\tif (!original.isConstructor() ", "+\t\t\t\t\t\t\t|| reference.receiverType.isRawType()  // note: rawtypes may/may not have typeArguments() depending on initialization state", "+\t\t\t\t\t\t\t|| reference.receiverType.typeArguments() == null)", "+\t\t\t\t\t\treturn null; // already incorporated", "+\t\t\t\t\t// for Foo<Bar>::new we need to (illegally) add one more constraint below to get to the Bar"]}], "num": 25666}