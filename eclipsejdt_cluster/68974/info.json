{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0f6cbdbd1f406694532394c0224dafd6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3991e001d41b499dda7ca9225959cfaf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "557b942f819d62ffe9419db1ce92c3e011ea65a9", "commitAfterChange": "566dfe9d75afc609e513171bfa949df8ee32e8da", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic final void areTypesCastCompatible( \t\tBlockScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType)", "signatureAfterChange": "  \tpublic final void areTypesCastCompatible( \t\tBlockScope scope, \t\tTypeBinding castType, \t\tTypeBinding expressionType)", "diff": ["-\t\t// see specifications p.68", "+\t\t// see specifications 5.5", "-\t\t", "+", "+\t\t// identity conversion cannot be performed upfront, due to side-effects", "+\t\t// like constant propagation", "+\t\t\t\t", "-\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType)", "+\t\t\t\tif (expressionType.isCompatibleWith(castType)", "-\t\tif (expressionType == NullBinding) ", "+\t\tif (expressionType == NullBinding) {", "+\t\t\t//\tif (castType.isArrayType()){ // 26903 - need checkcast when casting null to array type", "+\t\t\t//\t\tneedRuntimeCheckcast = true;", "+\t\t\t//\t}", "-", "+\t\t}", "+\t\t\tif (castType == expressionType) return; // identity conversion", "+", "-\t\t\t} else if (", "-\t\t\t\tcastType.isClass()) { // ----- (castType.isClass) expressionType.isClass ------", "-\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType)){ // no runtime error", "+\t\t\t} else if (castType.isClass()) { // ----- (castType.isClass) expressionType.isClass ------", "+\t\t\t\tif (expressionType.isCompatibleWith(castType)){ // no runtime error", "-\t\t\t\tif (Scope.areTypesCompatible(castType, expressionType)) {", "+\t\t\t\tif (castType.isCompatibleWith(expressionType)) {", "-\t\t\t\t\tif (Scope.areTypesCompatible(expressionType, castType)) ", "+\t\t\t\t\tif (expressionType.isCompatibleWith(castType)) ", "-\t\t\t\tif (!Scope.areTypesCompatible(castType, expressionType)) {", "+\t\t\t\tif (!castType.isCompatibleWith(expressionType)) {", "-\t\t\tif (castType != expressionType", "-\t\t\t\t\t&& (Scope.compareTypes(castType, expressionType) == NotRelated)) {", "+\t\t\tif (castType == expressionType) return; // identity conversion", "+\t\t\tif (Scope.compareTypes(castType, expressionType) == NotRelated) {", "-\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad4774de477738c441e95d71dbc38bf5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java", "commitBeforeChange": "ad30422de59b5093c5225e2a4599516c056303dc", "commitAfterChange": "c1c045ff9c256acaa6d98530fa4640b4cd80b7c6", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb)", "signatureAfterChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "diff": ["-\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb) {", "+\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType) {", "-\t\t\tTypeBinding leafComponentType = expectedTb.leafComponentType();", "+\t\t\tTypeBinding leafComponentType = expectedType.leafComponentType();", "-\t\tif (expectedTb.isArrayType()) {", "-\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedTb;", "-\t\t\tif (expressions == null)", "-\t\t\t\treturn binding;", "-\t\t\tTypeBinding expectedElementsTb = binding.elementsType();", "-\t\t\tif (expectedElementsTb.isBaseType()) {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "-\t\t\t\t\tExpression expression = expressions[i];", "-\t\t\t\t\tTypeBinding expressionTb =", "-\t\t\t\t\t\t(expression instanceof ArrayInitializer)", "-\t\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, expectedElementsTb)", "-\t\t\t\t\t\t\t: expression.resolveType(scope);", "-\t\t\t\t\tif (expressionTb == null)", "-\t\t\t\t\t\treturn null;", "-\t", "-\t\t\t\t\t// Compile-time conversion required?", "-\t\t\t\t\tif (expectedElementsTb != expressionTb) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(expectedElementsTb, expressionTb);", "-\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionTb, expectedElementsTb)", "-\t\t\t\t\t\t|| BaseTypeBinding.isWidening(expectedElementsTb.id, expressionTb.id)", "-\t\t\t\t\t\t|| scope.isBoxingCompatibleWith(expressionTb, expectedElementsTb)) {", "-\t\t\t\t\t\t\texpression.computeConversion(scope, expectedElementsTb, expressionTb);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tscope.problemReporter().typeMismatchError(expressionTb, expectedElementsTb, expression);", "-\t\t\t\t\t\treturn null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++)", "-\t\t\t\t\tif (expressions[i].resolveTypeExpecting(scope, expectedElementsTb) == null)", "-\t\t\t\t\t\treturn null;", "+\t\tif (expectedType.isArrayType()) {", "+\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedType;", "+\t\t\tif (this.expressions == null)", "+\t\t\t\treturn this.binding;", "+\t\t\tTypeBinding elementType = this.binding.elementsType();", "+\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "+\t\t\t\tExpression expression = expressions[i];", "+\t\t\t\tTypeBinding exprType = expression instanceof ArrayInitializer", "+\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, elementType)", "+\t\t\t\t\t\t: expression.resolveType(scope);", "+\t\t\t\tif (exprType == null)", "+\t\t\t\t\treturn null;", "+", "+\t\t\t\t// Compile-time conversion required?", "+\t\t\t\tif (elementType != exprType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, exprType);", "+", "+\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(exprType, elementType)", "+\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, exprType.id)))", "+\t\t\t\t\t\t|| exprType.isCompatibleWith(elementType)) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else if (scope.isBoxingCompatibleWith(exprType, elementType) ", "+\t\t\t\t\t\t\t\t\t|| (exprType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t\t\t&& !elementType.isBaseType()", "+\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(exprType, scope.environment().computeBoxingType(elementType)))) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else {", "+\t\t\t\t\tscope.problemReporter().typeMismatchError(exprType, elementType, expression);", "+\t\t\t\t\treturn null;", "+\t\t\t\t} \t\t\t\t", "-\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedTb, this);", "+\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedType, this);"]}], "num": 68974}