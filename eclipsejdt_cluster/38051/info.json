{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "da22c483ede4896f8fe893f0ce4c6a2c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a90825b2a6c66946b575c2a174a95867", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "c609c337bf309009b4e02e584ece29cf9833f54e", "commitAfterChange": "b4f87915b858b8e38e418046984ece5dc8db6148", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": " \tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project)", "signatureAfterChange": " \tprivate void reconcileClasspathFileUpdate(IResourceDelta delta, JavaProject project)", "diff": ["-\t\tboolean reloadClasspath = true;", "-\t\tif (delta != null) {", "-\t\t\treloadClasspath = false; // narrow down need to reload based on delta", "-\t\t\tswitch (delta.getKind()) {", "-\t\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tJavaModelManager.PerProjectInfo info = project.getPerProjectInfo();", "-\t\t\t\t\t\tif (info.rawClasspath != null) { // if there is an in-memory classpath", "-\t\t\t\t\t\t\tproject.saveClasspath(info.rawClasspath, info.outputLocation);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\tif (project.getProject().isAccessible()) {", "-\t\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "-\t\t\t\t\t\t}", "+\t\tswitch (delta.getKind()) {", "+\t\t\tcase IResourceDelta.REMOVED : // recreate one based on in-memory classpath", "+\t\t\t\ttry {", "+\t\t\t\t\tJavaModelManager.PerProjectInfo info = project.getPerProjectInfo();", "+\t\t\t\t\tif (info.rawClasspath != null) { // if there is an in-memory classpath", "+\t\t\t\t\t\tproject.saveClasspath(info.rawClasspath, info.outputLocation);", "+\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\tif (project.getProject().isAccessible()) {", "+\t\t\t\t\t\tUtil.log(e, \"Could not save classpath for \"+ project.getPath()); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase IResourceDelta.CHANGED :", "+\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "+\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) {// and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "-\t\t\t\tcase IResourceDelta.CHANGED :", "-\t\t\t\t\tif ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change", "-\t\t\t\t\t\t\t&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "-\t\t\t\t\t\tbreak;", "-\t\t\t\tcase IResourceDelta.ADDED :", "-\t\t\t\t\treloadClasspath = true;", "-\t\t\t}", "-\t\t}", "-\t\tif (reloadClasspath) {", "-\t\t\ttry {", "-\t\t\t\tproject.forceClasspathReload(null);", "-\t\t\t} catch (RuntimeException e) {", "-\t\t\t} catch (JavaModelException e) {\t", "-\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// fall through", "+\t\t\tcase IResourceDelta.ADDED :", "+\t\t\t\ttry {", "+\t\t\t\t\tproject.forceClasspathReload(null);", "+\t\t\t\t} catch (RuntimeException e) { \t\t// ignore", "+\t\t\t\t} catch (JavaModelException e) {\t// ignore", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9be4142a40d7fcc4ed3bd2ed4245f24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java", "commitBeforeChange": "1dc6df2cba1e3f21897002448cbe5ca7ad21d269", "commitAfterChange": "973af06dbc6df022ac42e8e0a0c238581d8558f6", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope scope)", "signatureAfterChange": " \t \tpublic void resolve(BlockScope scope)", "diff": ["-\t\tboolean shouldInsertInScope = true;", "-\t\t\t\tshouldInsertInScope = false;", "-\t\tif (shouldInsertInScope) {", "-\t\t\tif ((modifiers & ClassFileConstants.AccFinal)!= 0 && this.initialization == null) {", "-\t\t\t\tmodifiers |= ExtraCompilerModifiers.AccBlankFinal;", "-\t\t\t}", "-\t\t\tthis.binding = new LocalVariableBinding(this, variableType, modifiers, false);", "-\t\t\tscope.addLocalVariable(binding);", "-\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\t// allow to recursivelly target the binding....", "-\t\t\t// the correct constant is harmed if correctly computed at the end of this method", "+\t\tif ((modifiers & ClassFileConstants.AccFinal)!= 0 && this.initialization == null) {", "+\t\t\tmodifiers |= ExtraCompilerModifiers.AccBlankFinal;", "+\t\tthis.binding = new LocalVariableBinding(this, variableType, modifiers, false);", "+\t\tscope.addLocalVariable(binding);", "+\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t// allow to recursivelly target the binding....", "+\t\t// the correct constant is harmed if correctly computed at the end of this method", "-\t\t\tif (binding != null) {", "-\t\t\t\t// check for assignment with no effect", "-\t\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "-\t\t\t\t\tscope.problemReporter().assignmentHasNoEffect(this, this.name);", "-\t\t\t\t}", "-\t\t\t\t// change the constant in the binding when it is final", "-\t\t\t\t// (the optimization of the constant propagation will be done later on)", "-\t\t\t\t// cast from constant actual type to variable type", "-\t\t\t\tbinding.setConstant(", "-\t\t\t\t\tbinding.isFinal()", "-\t\t\t\t\t\t? initialization.constant.castTo((variableType.id << 4) + initialization.constant.typeID())", "-\t\t\t\t\t\t: Constant.NotAConstant);", "+\t\t\t// check for assignment with no effect", "+\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "+\t\t\t\tscope.problemReporter().assignmentHasNoEffect(this, this.name);", "+\t\t\t// change the constant in the binding when it is final", "+\t\t\t// (the optimization of the constant propagation will be done later on)", "+\t\t\t// cast from constant actual type to variable type", "+\t\t\tbinding.setConstant(", "+\t\t\t\tbinding.isFinal()", "+\t\t\t\t\t? initialization.constant.castTo((variableType.id << 4) + initialization.constant.typeID())", "+\t\t\t\t\t: Constant.NotAConstant);", "-\t\tif (this.binding != null)", "-\t\t\tresolveAnnotations(scope, this.annotations, this.binding);", "+\t\tresolveAnnotations(scope, this.annotations, this.binding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd660c9b163874c60739d62290e7785a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe2.java", "commitBeforeChange": "74d059b3fbdc00070c70bee76509a44ccad7fb4d", "commitAfterChange": "31d2b0bac7c9b032f1ad8765fd4577eaff8d79fd", "methodNumberBeforeChange": 44, "methodNumberAfterChange": 44, "signatureBeforeChange": " \tpublic void printModifiers(List modifiers, ASTVisitor visitor)", "signatureAfterChange": " \tpublic void printModifiers(List modifiers, ASTVisitor visitor)", "diff": ["-\t\t\tboolean hasModifiers = false;", "-\t\t\t\t\t\thasModifiers = true;", "-\t\t\t\t\t\thasModifiers = true;", "-\t\t\t\t\t\tif (hasModifiers) {", "-\t\t\t\t\t\t\tthis.space();", "-\t\t\t\t\t\t}"]}], "num": 38051}