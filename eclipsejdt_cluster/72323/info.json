{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "47b945112ff0964bf17c6050e571b5c9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3882ebbfbb1edefd8da0d5666753a20d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PackageReferenceLocator.java", "commitBeforeChange": "4a7fb72faa1d4eb35981dd799c06dbffe9837a2f", "commitAfterChange": "af607e2e1ad6576e50200e327ea9acd540ed1ad7", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException", "signatureAfterChange": " protected void matchReportReference(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, MatchLocator locator) throws CoreException", "diff": ["+\tmatchReportReference(reference, element, null, null, elementBinding, accuracy, locator);", "+}", "-\tmatch = locator.newPackageReferenceMatch(element, accuracy, sourceStart, sourceEnd-sourceStart+1, reference);", "-\tlocator.report(match);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9bff70803e3f2d83949acb6924f527b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count, int emptyLinesRules)", "diff": ["-\tprivate String getPreserveEmptyLines(int count) {", "+\tprivate String getPreserveEmptyLines(int count, int emptyLinesRules) {", "-\t\t\t// preserve line breaks in wrapping if specified", "-\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=198074", "-\t\t\tif (this.currentAlignment != null && !this.formatter.preferences.join_wrapped_lines) {", "-\t\t\t\t// Insert a new line only if it has not been already done before", "-\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)", "-\t\t\t\t// or when there's no direct member alignment", "-\t\t\t\t// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)", "-\t\t\t\tif (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {", "-\t\t\t\t\t", "-\t\t\t\t\t// Debug", "-\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "-\t\t\t\t\t\tSystem.out.println(\"Preserve empty lines:\"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current alignment: \"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.print(this.currentAlignment.toString(new StringBuffer(), 1));", "-\t\t\t\t\t\tif (this.memberAlignment != null) {", "-\t\t\t\t\t\t\tSystem.out.println(\" - member alignment: \"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tSystem.out.print(this.memberAlignment.toString(new StringBuffer(), 1));", "-\t\t\t\t\t\t}", "+\t\t\tint currentIndentationLevel = this.indentationLevel;", "+\t\t\tint useAlignmentBreakIndentation = useAlignmentBreakIndentation(emptyLinesRules);", "+\t\t\tswitch (useAlignmentBreakIndentation) {", "+\t\t\t\tcase PRESERVE_EMPTY_LINES_DO_NOT_USE_ANY_INDENTATION:", "+\t\t\t\t\treturn Util.EMPTY_STRING;", "+\t\t\t\tdefault:", "+\t\t\t\t\t// Return the new indented line", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer(getNewLine());", "+\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\tif (useAlignmentBreakIndentation == PRESERVE_EMPTY_LINES_USE_TEMPORARY_INDENTATION) {", "+\t\t\t\t\t\tthis.indentationLevel = currentIndentationLevel;", "-", "-\t\t\t\t\t// Reset indentation level to the location output", "-\t\t\t\t\tthis.indentationLevel = this.currentAlignment.location.outputIndentationLevel;", "-", "-\t\t\t\t\t// Create new line", "-\t\t\t\t\tthis.tempBuffer.setLength(0);", "-\t\t\t\t\tthis.tempBuffer.append(getNewLine());", "-\t\t\t\t\t", "-\t\t\t\t\t// Look for current indentation", "-\t\t\t\t\tint currentIndentation = getCurrentIndentation(this.scanner.currentPosition);", "-\t\t\t\t\t", "-\t\t\t\t\t// Determine whether the alignment indentation can be used or not", "-\t\t\t\t\t// So far, the best algorithm is to use it when", "-\t\t\t\t\t// 1. this is not the opening brace of a local declaration assignment", "-\t\t\t\t\t// 2. this is not the first opening brace", "-\t\t\t\t\t//     or this is an array initializer alignment ", "-\t\t\t\t\t//     or this is an binary expression alignment", "-\t\t\t\t\t// 3. the indentation level is below the alignment break indentation", "-\t\t\t\t\tint currentTokenStartPosition = this.scanner.currentPosition;", "-\t\t\t\t\tint nextToken = -1;", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tnextToken = this.scanner.getNextToken();", "-\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t// skip", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "-\t\t\t\t\tboolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || this.currentAlignment.kind != Alignment.LOCAL_DECLARATION_ASSIGNMENT);", "-\t\t\t\t\tif (canUseAlignmentIndentation &&", "-\t\t\t\t\t\t\t(!this.formatBrace ||", "-\t\t\t\t\t\t\t\t\tthis.currentAlignment.kind == Alignment.ARRAY_INITIALIZER ||", "-\t\t\t\t\t\t\t\t\tthis.currentAlignment.kind == Alignment.BINARY_EXPRESSION) &&", "-\t\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel) {", "-\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Use the current indentation if over the computed indentation", "-\t\t\t\t\tif (this.indentationLevel < currentIndentation) {", "-\t\t\t\t\t\tthis.indentationLevel = currentIndentation;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Debug", "-\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "-\t\t\t\t\t\tSystem.out.println(\" - format brace = \"+this.formatBrace); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current column = \"+(currentIndentation+1)); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current position = \"+this.scanner.currentPosition); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.print(\" - current line = \"); //$NON-NLS-1$", "-\t\t\t\t\t\tint linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);", "-\t\t\t\t\t\tif (linePtr < 0) {", "-\t\t\t\t\t\t\tlinePtr = -linePtr - 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint i = getLineEnd(linePtr)+1;", "-\t\t\t\t\t\tchar[] source = this.scanner.source;", "-\t\t\t\t\t\tint sourceLength = source.length;", "-\t\t\t\t\t\twhile (i < sourceLength && source[i] != '\\r') {", "-\t\t\t\t\t\t\tSystem.out.print(source[i++]);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tSystem.out.println();", "-\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println();", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Set the flag to indicate that a specific indentation is currently in used", "-\t\t\t\t\tthis.preserveLineBreakIndentation = true;", "-\t\t\t\t\t", "-\t\t\t\t\t// Print the computed indentation in the buffer", "-\t\t\t\t\tprintIndentationIfNecessary(this.tempBuffer);", "-\t\t\t\t\treturn this.tempBuffer.toString();", "-\t\t\t\t}", "+\t\t\t\t\treturn buffer.toString();", "-\t\t\treturn Util.EMPTY_STRING;", "+\t\t\tuseAlignmentBreakIndentation(emptyLinesRules);", "+\t\t\tuseAlignmentBreakIndentation(emptyLinesRules);", "+\t}"]}], "num": 72323}