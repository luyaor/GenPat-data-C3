{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "62e4953bdee2659512d5223eab468d8c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1e0a79ed5769aff31a53d8bef10bf84b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "572021b99f292f39a76e81c2ea834ac6a839b00b", "commitAfterChange": "727d8ca46d64642ad4f629f81ba37e76e7ae8c85", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "signatureAfterChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "diff": ["-    \tint initialStart = start==-1 ? 0 : start;", "-\t\tint bottom = initialStart, top = sortedEdits.length - 1;", "+    \tint bottom = start==-1?0:start, top = sortedEdits.length - 1;", "+        int linesOutside= -1;", "-    \t\tif (editStart > regionStart) {  // the edit starts after the region's start => no possible overlap of region's start", "+    \t\tif (regionStart < editStart) {  // the edit starts after the region's start => no possible overlap of region's start", "-    \t\t\tif (editStart > regionEnd) { // the edit starts after the region's end => no possible overlap of region's end", "+    \t\t\tif (regionEnd < editStart) { // the edit starts after the region's end => no possible overlap of region's end", "-    \t\t\tif (editEnd < regionStart) { // the edit ends before the region's start => no possible overlap of region's start", "+    \t\t\tif (regionStart >= editEnd) { // the edit ends before the region's start => no possible overlap of region's start", "-\t\t\t\t\tint linesOutside = 0;", "-\t\t\t\t\tStringBuffer spacesOutside = new StringBuffer();", "+\t\t\t\t\tlinesOutside = 0;", "-\t\t\t\t\twhile (this.scanner.currentPosition < regionStart && !this.scanner.atEnd()) {", "-\t\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "-\t\t\t\t\t\tswitch (ch) {", "-\t\t\t\t\t\t\tcase '\\n':", "-\t\t\t\t\t\t\t\tlinesOutside++;", "-\t\t\t\t\t\t\t\tspacesOutside.setLength(0);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase '\\r':", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tspacesOutside.append(ch);", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t\twhile (!this.scanner.atEnd()) {", "+\t\t\t\t\t\tboolean before = this.scanner.currentPosition < regionStart;", "+\t                    char ch = (char) this.scanner.getNextChar();", "+                    \tif (ch == '\\n' ) {", "+                    \t\tif (before) linesOutside++;", "+                    \t}", "+                    }", "-\t\t\t\t\tint editLength = edit.length;", "-\t\t\t\t\t\t// If the edit was a replacement but become an insertion due to the length reduction", "-\t\t\t\t\t\t// and if the edit finishes just before the region starts and if there's no line to replace", "-\t\t\t\t\t\t// then there's no replacement to do...", "-\t\t\t\t\t\tif (editLength > 0 && edit.length == 0 && editEnd == regionStart && linesReplaced == 0 && linesOutside== 0) {", "-\t\t\t\t\t\t\tedit.valid = false;", "-\t\t\t\t\t\t} else {", "-", "-\t\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "-\t\t\t\t\t\t\tif (linesReplaced > 0) {", "-\t\t\t\t\t\t\t\tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "-\t\t\t\t\t\t\t\tif (linesCount > 0) {", "-\t\t\t\t\t\t\t\t\tint idx = 0;", "-\t\t\t\t\t\t\t\t\tloop: while (idx < length) {", "-\t\t\t\t\t\t\t\t\t\tchar ch = edit.replacement.charAt(idx);", "-\t\t\t\t\t\t\t\t\t\tswitch (ch) {", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\n':", "-\t\t\t\t\t\t\t\t\t\t\t\tlinesCount--;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (linesCount == 0) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tidx++;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\r':", "-\t\t\t\t\t\t\t\t\t\t\tcase ' ':", "-\t\t\t\t\t\t\t\t\t\t\tcase '\\t':", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tidx++;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t// Compare spaces outside the region and the beginning", "-\t\t\t\t\t\t\t\t\t// of the replacement string to remove the common part", "-\t\t\t\t\t\t\t\t\tint spacesOutsideLength = spacesOutside.length();", "-\t\t\t\t\t\t\t\t\tint replacementStart = idx;", "-\t\t\t\t\t\t\t\t\tfor (int o=0, r=0; o < spacesOutsideLength && r<(length-idx); o++) {", "-\t\t\t\t\t\t\t\t\t\tchar rch = edit.replacement.charAt(idx + r);", "-\t\t\t\t\t\t\t\t\t\tchar och = spacesOutside.charAt(o);", "-\t\t\t\t\t\t\t\t\t\tif (rch == och) {", "-\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "-\t\t\t\t\t\t\t\t\t\t\tr++;", "-\t\t\t\t\t\t\t\t\t\t} else if (rch == '\\t' && (this.tabLength > 0 && och == ' ')) {", "-\t\t\t\t\t\t\t\t\t\t\tif ((o+1)%this.tabLength == 0) {", "-\t\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "-\t\t\t\t\t\t\t\t\t\t\t\tr++;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t// Update the replacement string", "-\t\t\t\t\t\t\t\t\tif (replacementStart >= length) {", "-\t\t\t\t\t\t\t\t\t\tedit.valid = false;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tedit.replacement = edit.replacement.substring(replacementStart);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "+\t\t\t\t\t\tif (linesReplaced > 0) {", "+\t\t\t\t\t    \tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "+\t\t\t\t\t    \tif (linesCount > 0) {", "+\t\t\t\t\t    \t\tint idx=0;", "+\t\t\t\t\t    \t\tloop: while (idx < length) {", "+\t\t\t\t\t    \t\t\tchar ch = edit.replacement.charAt(idx);", "+\t\t\t\t\t    \t\t\tswitch (ch) {", "+\t\t\t\t\t    \t\t\t\tcase '\\n':", "+\t\t\t\t\t\t    \t\t\t\tlinesCount--;", "+\t\t\t\t\t\t    \t\t\t\tif (linesCount == 0) {", "+\t\t\t\t\t\t    \t\t\t\t\tidx++;", "+\t\t\t\t\t\t    \t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t    \t\t\t\t}", "+\t\t\t\t\t\t    \t\t\t\tbreak;", "+\t\t\t\t\t    \t\t\t\tcase '\\r':", "+\t\t\t\t\t    \t\t\t\tcase ' ':", "+\t\t\t\t\t    \t\t\t\tcase '\\t':", "+\t\t\t\t\t    \t\t\t\t\tbreak;", "+\t\t\t\t\t    \t\t\t\tdefault:", "+\t\t\t\t\t    \t\t\t\t\tbreak loop;", "+\t\t\t\t\t    \t\t\t}", "+\t\t\t\t\t    \t\t\tidx++;", "+\t\t\t\t\t    \t\t}", "+\t\t\t\t\t    \t\tif (idx >= length) {", "+\t\t\t\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "+\t\t\t\t\t    \t\t} else {", "+\t\t\t\t\t    \t\t\tedit.replacement = edit.replacement.substring(idx);", "+\t\t\t\t\t    \t\t}", "+\t\t\t\t\t    \t}", "-    \tint validIndex = (overlapIndex != -1) ? overlapIndex : bottom;", "-    \t\t\tif (editEnd <= regionEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "+    \t\t\tif (regionEnd >= editEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "-\t\t\t\t\tint linesOutside = 0;", "+\t\t\t\t\tlinesOutside = 0;", "-", "-\t\t\t    \t// Set invalid all edits outside the region", "-\t\t\t    \tfor (int e=initialStart; e<validIndex; e++) {", "-\t\t\t    \t\tsortedEdits[e].valid = false;", "-\t\t\t    \t}", "-\t\t\t    \t", "-\t\t\t    \t// Return the index of next edit to look at", "-\t\t\t\t\treturn i + 1;", "+\t\t\t\t\treturn i;", "-", "-    \t// Set invalid all edits outside the region", "-    \tfor (int e=initialStart; e<validIndex; e++) {", "-    \t\tsortedEdits[e].valid = false;", "-    \t}", "-    \t", "-    \t// Return the index of next edit to look at", "-    \treturn topEnd+1;", "+    \treturn overlapIndex;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d3c1ae547e3df95c0a74943382e40dc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "96c7afd29f6893c16cf00a3ac29701c1a81f919d", "commitAfterChange": "dd45817f66a0a68c9747e1c73f77cc12766ad25c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "signatureAfterChange": "     private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd)", "diff": ["-    \tint bottom = start==-1?0:start, top = sortedEdits.length - 1;", "+    \tint initialStart = start==-1 ? 0 : start;", "+\t\tint bottom = initialStart, top = sortedEdits.length - 1;", "-        int linesOutside= -1;", "-    \t\tif (regionStart < editStart) {  // the edit starts after the region's start => no possible overlap of region's start", "+    \t\tif (editStart > regionStart) {  // the edit starts after the region's start => no possible overlap of region's start", "-    \t\t\tif (regionEnd < editStart) { // the edit starts after the region's end => no possible overlap of region's end", "+    \t\t\tif (editStart > regionEnd) { // the edit starts after the region's end => no possible overlap of region's end", "-    \t\t\tif (regionStart >= editEnd) { // the edit ends before the region's start => no possible overlap of region's start", "+    \t\t\tif (editEnd < regionStart) { // the edit ends before the region's start => no possible overlap of region's start", "-\t\t\t\t\tlinesOutside = 0;", "+\t\t\t\t\tint linesOutside = 0;", "+\t\t\t\t\tStringBuffer spacesOutside = new StringBuffer();", "-\t\t\t\t\twhile (!this.scanner.atEnd()) {", "-\t\t\t\t\t\tboolean before = this.scanner.currentPosition < regionStart;", "-\t                    char ch = (char) this.scanner.getNextChar();", "-                    \tif (ch == '\\n' ) {", "-                    \t\tif (before) linesOutside++;", "-                    \t}", "-                    }", "+\t\t\t\t\twhile (this.scanner.currentPosition < regionStart && !this.scanner.atEnd()) {", "+\t\t\t\t\t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\tlinesOutside++;", "+\t\t\t\t\t\t\t\tspacesOutside.setLength(0);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tspacesOutside.append(ch);", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tint editLength = edit.length;", "-\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "-\t\t\t\t\t\tif (linesReplaced > 0) {", "-\t\t\t\t\t    \tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "-\t\t\t\t\t    \tif (linesCount > 0) {", "-\t\t\t\t\t    \t\tint idx=0;", "-\t\t\t\t\t    \t\tloop: while (idx < length) {", "-\t\t\t\t\t    \t\t\tchar ch = edit.replacement.charAt(idx);", "-\t\t\t\t\t    \t\t\tswitch (ch) {", "-\t\t\t\t\t    \t\t\t\tcase '\\n':", "-\t\t\t\t\t\t    \t\t\t\tlinesCount--;", "-\t\t\t\t\t\t    \t\t\t\tif (linesCount == 0) {", "-\t\t\t\t\t\t    \t\t\t\t\tidx++;", "-\t\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t    \t\t\t\t}", "-\t\t\t\t\t\t    \t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tcase '\\r':", "-\t\t\t\t\t    \t\t\t\tcase ' ':", "-\t\t\t\t\t    \t\t\t\tcase '\\t':", "-\t\t\t\t\t    \t\t\t\t\tbreak;", "-\t\t\t\t\t    \t\t\t\tdefault:", "-\t\t\t\t\t    \t\t\t\t\tbreak loop;", "-\t\t\t\t\t    \t\t\t}", "-\t\t\t\t\t    \t\t\tidx++;", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t\tif (idx >= length) {", "-\t\t\t\t\t    \t\t\tedit.replacement = \"\"; //$NON-NLS-1$", "-\t\t\t\t\t    \t\t} else {", "-\t\t\t\t\t    \t\t\tedit.replacement = edit.replacement.substring(idx);", "-\t\t\t\t\t    \t\t}", "-\t\t\t\t\t    \t}", "+\t\t\t\t\t\t// If the edit was a replacement but become an insertion due to the length reduction", "+\t\t\t\t\t\t// and if the edit finishes just before the region starts and if there's no line to replace", "+\t\t\t\t\t\t// then there's no replacement to do...", "+\t\t\t\t\t\tif (editLength > 0 && edit.length == 0 && editEnd == regionStart && linesReplaced == 0 && linesOutside== 0) {", "+\t\t\t\t\t\t\tedit.valid = false;", "+\t\t\t\t\t\t} else {", "+", "+\t\t\t\t\t\t\t// As the edit starts outside the region, remove first lines from edit string if any", "+\t\t\t\t\t\t\tif (linesReplaced > 0) {", "+\t\t\t\t\t\t\t\tint linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;", "+\t\t\t\t\t\t\t\tif (linesCount > 0) {", "+\t\t\t\t\t\t\t\t\tint idx = 0;", "+\t\t\t\t\t\t\t\t\tloop: while (idx < length) {", "+\t\t\t\t\t\t\t\t\t\tchar ch = edit.replacement.charAt(idx);", "+\t\t\t\t\t\t\t\t\t\tswitch (ch) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\n':", "+\t\t\t\t\t\t\t\t\t\t\t\tlinesCount--;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (linesCount == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\r':", "+\t\t\t\t\t\t\t\t\t\t\tcase ' ':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\t':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tidx++;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Compare spaces outside the region and the beginning", "+\t\t\t\t\t\t\t\t\t// of the replacement string to remove the common part", "+\t\t\t\t\t\t\t\t\tint spacesOutsideLength = spacesOutside.length();", "+\t\t\t\t\t\t\t\t\tint replacementStart = idx;", "+\t\t\t\t\t\t\t\t\tfor (int o=0, r=0; o < spacesOutsideLength && r<(length-idx); o++) {", "+\t\t\t\t\t\t\t\t\t\tchar rch = edit.replacement.charAt(idx + r);", "+\t\t\t\t\t\t\t\t\t\tchar och = spacesOutside.charAt(o);", "+\t\t\t\t\t\t\t\t\t\tif (rch == och) {", "+\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t} else if (rch == '\\t' && (this.tabLength > 0 && och == ' ')) {", "+\t\t\t\t\t\t\t\t\t\t\tif ((o+1)%this.tabLength == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\treplacementStart++;", "+\t\t\t\t\t\t\t\t\t\t\t\tr++;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// Update the replacement string", "+\t\t\t\t\t\t\t\t\tif (replacementStart >= length) {", "+\t\t\t\t\t\t\t\t\t\tedit.valid = false;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tedit.replacement = edit.replacement.substring(replacementStart);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+    \tint validIndex = (overlapIndex != -1) ? overlapIndex : bottom;", "-    \t\t\tif (regionEnd >= editEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "+    \t\t\tif (editEnd <= regionEnd) {\t// the edit ends before the region's end => no possible overlap of region's end", "-\t\t\t\t\tlinesOutside = 0;", "+\t\t\t\t\tint linesOutside = 0;", "-\t\t\t\t\treturn i;", "+", "+\t\t\t    \t// Set invalid all edits outside the region", "+\t\t\t    \tfor (int e=initialStart; e<validIndex; e++) {", "+\t\t\t    \t\tsortedEdits[e].valid = false;", "+\t\t\t    \t}", "+\t\t\t    \t", "+\t\t\t    \t// Return the index of next edit to look at", "+\t\t\t\t\treturn i + 1;", "-    \treturn overlapIndex;", "+", "+    \t// Set invalid all edits outside the region", "+    \tfor (int e=initialStart; e<validIndex; e++) {", "+    \t\tsortedEdits[e].valid = false;", "+    \t}", "+    \t", "+    \t// Return the index of next edit to look at", "+    \treturn topEnd+1;"]}], "num": 29651}