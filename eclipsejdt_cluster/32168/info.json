{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "41e602f647d31c98a157793ae0f3a2a9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "003402de599b66ac58a755b3d305b1e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "f700051affab74804180d3a8bb296f6cabd751a0", "commitAfterChange": "745840be480d4e43f22d0c4f40c198cdee6926a4", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "signatureAfterChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "diff": ["+\t\t\t\t\t\t// not per JLS: if the new constraint relates types where at least one has a null annotations,", "+\t\t\t\t\t\t// record all null tagBits as hints for the final inference solution.", "+\t\t\t\t\t\tlong nullHints = (newConstraint.left.tagBits | newConstraint.right.tagBits) & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\tboundI.nullHints |= nullHints;", "+\t\t\t\t\t\tboundJ.nullHints |= nullHints;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "295d20a9a65d5d88e2f0d2516b6b4793", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "e0ebad67303a47fa3ab9d8532c92ffc60ae916e2", "commitAfterChange": "6940f5238f5f044dc7dc7f5472f64a2c5617a365", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic static TypeBinding[] greaterLowerBound(TypeBinding[] types, Scope scope, LookupEnvironment environment)", "signatureAfterChange": " \tpublic static TypeBinding[] greaterLowerBound(TypeBinding[] types, Scope scope, LookupEnvironment environment)", "diff": ["+\t\t\t\t\t\t// Skip the following check if inference variables or CaptureBinding18 are involved,", "+\t\t\t\t\t\t// hopefully during inference a contradictory glb will simply not produce a solution", "+\t\t\t\t\t\t// (should essentially be detected beforehand in CaptureBinding18.setUpperBounds()): ", "+\t\t\t\t\t\tif (!narrowType.isProperType(false) || !wideType.isProperType(false))", "+\t\t\t\t\t\t\tcontinue;"]}], "num": 32168}