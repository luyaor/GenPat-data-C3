{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba2ced2e8f415fc547fe19de9bcf0a62", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ba9e496daaaff5b0c2260ecfdd2a6fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "da50a11f1737dbee3925e1da64ad7f9cbaff2e84", "commitAfterChange": "99342a278896e2f8caf142911ce817f7cc97d106", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public void resolve(BlockScope scope)", "signatureAfterChange": "\r \r public void bind(MethodScope scope, TypeBinding typeBinding, boolean used)", "diff": ["-public void resolve(BlockScope scope) {\r", "-\t// an argument may be final ==> cannot be assigned\r", "-\tsuper.resolve(scope);\r", "-\tbinding.isArgument = true;\r", "-\tbinding.used = true;\r", "+public void bind(MethodScope scope, TypeBinding typeBinding, boolean used) {\r", "+\tif (this.type != null) this.type.binding = typeBinding; // record the resolved type into the type reference\r", "+\tint modifierFlag = this.modifiers;\r", "+\tif ((this.binding = scope.duplicateName(this.name)) != null) {\r", "+\t\t//the name already exist....may carry on with the first binding ....\r", "+\t\tscope.problemReporter().redefineArgument(this);\r", "+\t} else {\r", "+\t\tscope.addLocalVariable(this.binding = new LocalVariableBinding(this.name, typeBinding, modifierFlag, true)); //true stand for argument instead of just local\r", "+\t\tif (isTypeUseDeprecated(typeBinding, scope))\r", "+\t\t\tscope.problemReporter().deprecatedType(typeBinding, this.type);\r", "+\t\tthis.binding.declaration = this;\r", "+\t\tthis.binding.used = used;\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e0e79917eaad71c3e6e8ef9b8c57c5e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java", "commitBeforeChange": "da50a11f1737dbee3925e1da64ad7f9cbaff2e84", "commitAfterChange": "99342a278896e2f8caf142911ce817f7cc97d106", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "\r public void bindArguments()", "signatureAfterChange": "\r public void bindArguments()", "diff": ["-\t\t\tArgument argument = arguments[i];\r", "-\t\t\tif (argument.type != null) argument.type.binding = binding.parameters[i]; // record the resolved type into the type reference\r", "-\t\t\tint modifierFlag = argument.modifiers;\r", "-\t\t\tif ((argument.binding = scope.duplicateName(argument.name)) != null) {\r", "-\t\t\t\t//the name already exist....may carry on with the first binding ....\r", "-\t\t\t\tscope.problemReporter().redefineArgument(argument);\r", "-\t\t\t} else {\r", "-\t\t\t\tscope.addLocalVariable(argument.binding = new LocalVariableBinding(argument.name, binding.parameters[i], modifierFlag, true)); //true stand for argument instead of just local\r", "-\t\t\t\tif (isTypeUseDeprecated(binding.parameters[i], scope))\r", "-\t\t\t\t\tscope.problemReporter().deprecatedType(binding.parameters[i], argument.type);\r", "-\t\t\t\targument.binding.declaration = argument;\r", "-\t\t\t\targument.binding.used = binding.isAbstract() | binding.isNative(); // by default arguments in abstract/native methods are considered to be used (no complaint is expected)\r", "-\t\t\t}\r", "+\t\t\targuments[i].bind(scope, binding.parameters[i], binding.isAbstract() | binding.isNative());// by default arguments in abstract/native methods are considered to be used (no complaint is expected)\r"]}], "num": 17601}