{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e02c2865ccc220421ed8f63e0be6ba19", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0abdccf84d1a7c63171fc861cd97047a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "ddff16f6a6b8fee88d497b4653d14d58ccda81b4", "commitAfterChange": "128a99659b73df0d65c1b7965233f291b8bbcedc", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\tpublic boolean isCompatibleWith(TypeBinding left, Scope someScope) {", "+\tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope) {", "-\t\t\tLambdaExpression copy = copy();", "+\t\t\tfinal LambdaExpression copy = copy();", "-\t\t\tfinal TypeBinding returnType = sam.returnType;", "-\t\t\tif (this.body instanceof Block) {", "-\t\t\t\tASTVisitor visitor = new ASTVisitor() {", "-\t\t\t\t\tpublic boolean visit(ReturnStatement returnStatement, BlockScope blockScope) {", "-\t\t\t\t\t\tExpression expression = returnStatement.expression;", "-\t\t\t\t\t\tif (expression != null && !expression.isAssignmentCompatible(returnType, blockScope))", "-\t\t\t\t\t\t\tthrow new IncongruentLambdaException();", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "-\t\t\t\t};", "-\t\t\t\tcopy.body.traverse(visitor, copy.scope);", "-\t\t\t} else {", "-\t\t\t\tExpression expression = (Expression) copy.body;", "-\t\t\t\tif (!expression.isAssignmentCompatible(returnType, copy.scope))", "-\t\t\t\t\tthrow new IncongruentLambdaException();", "+\t\t\tif (this.returnExpressionsTally > 0) {", "+\t\t\t\tfinal TypeBinding returnType = sam.returnType;", "+\t\t\t\tif (this.resultExpressions == null)", "+\t\t\t\t\tthis.resultExpressions = new SimpleLookupTable(); // gather for more specific analysis later.", "+\t\t\t\tif (this.body instanceof Block) {", "+\t\t\t\t\tASTVisitor visitor = new ASTVisitor() {", "+\t\t\t\t\t\tExpression [] returnExpressions = new Expression[LambdaExpression.this.returnExpressionsTally];", "+\t\t\t\t\t\tint returnExpressionsCount = 0;", "+\t\t\t\t\t\tpublic boolean visit(ReturnStatement returnStatement, BlockScope blockScope) {", "+\t\t\t\t\t\t\tExpression expression = returnStatement.expression;", "+\t\t\t\t\t\t\tif (expression != null && !expression.isAssignmentCompatible(returnType, blockScope))", "+\t\t\t\t\t\t\t\tthrow new IncongruentLambdaException();", "+\t\t\t\t\t\t\tthis.returnExpressions[this.returnExpressionsCount++] = expression;", "+\t\t\t\t\t\t\treturn false; // should not analyze any lambda returns.m", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tpublic void endVisit(Block block, BlockScope blockScope) {", "+\t\t\t\t\t\t\tif (block == copy.body)", "+\t\t\t\t\t\t\t\tLambdaExpression.this.resultExpressions.put(left, this.returnExpressions);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t};", "+\t\t\t\t\tcopy.body.traverse(visitor, copy.scope);", "+\t\t\t\t} else if (this.body instanceof Expression){", "+\t\t\t\t\tExpression expression = (Expression) copy.body;", "+\t\t\t\t\tif (!expression.isAssignmentCompatible(returnType, copy.scope))", "+\t\t\t\t\t\tthrow new IncongruentLambdaException();", "+\t\t\t\t\tthis.resultExpressions.put(left, new Expression [] { expression });", "+\t\t\t\t}", "-\t\t\t "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f71bab59cc376428d3ed46f89e95f70", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "ac56f2b73d9b33e4b9a6e4d4cb10ee0f16401ca0", "commitAfterChange": "075f0337e26b45d6db80c1a335ec63cbf2bb29bc", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  \tpublic void recordStringLiteral(StringLiteral literal)", "signatureAfterChange": "  \tpublic void recordStringLiteral(StringLiteral literal, boolean fromRecovery)", "diff": ["-\tpublic void recordStringLiteral(StringLiteral literal) {", "+\tpublic void recordStringLiteral(StringLiteral literal, boolean fromRecovery) {", "+\t\tif (this.stringLiteralsStart != null) {", "+\t\t\tif (this.stringLiteralsStart.contains(literal.sourceStart)) return;", "+\t\t\tthis.stringLiteralsStart.add(literal.sourceStart);", "+\t\t} else if (fromRecovery) {", "+\t\t\tthis.stringLiteralsStart = new HashSetOfInt(stringLiteralsPtr + STRING_LITERALS_INCREMENT);", "+\t\t\tfor (int i = 0; i < this.stringLiteralsPtr; i++) {", "+\t\t\t\tthis.stringLiteralsStart.add(this.stringLiterals[i].sourceStart);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (this.stringLiteralsStart.contains(literal.sourceStart)) return;", "+\t\t\tthis.stringLiteralsStart.add(literal.sourceStart);", "+\t\t}", "+\t\t"]}], "num": 2592}