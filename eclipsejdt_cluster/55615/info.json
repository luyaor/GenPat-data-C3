{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c729b360f246f7e8cce01fa95b36ee35", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "094cff8e57bd1aa666e4238f091428d5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-\t\t// for code gen, harm the restrictiveFlag \t", "-\t\tif (this.actualReceiverType != null) {", "-\t\t\tthis.binding = scope.getField(this.actualReceiverType, token, this);", "-\t\t} else {", "-\t\t\tthis.actualReceiverType = scope.enclosingSourceType();", "-\t\t\tthis.binding = scope.getBinding(token, bits & RestrictiveFlagMASK, this, true /*resolve*/);", "-\t\t}", "-\t\tthis.codegenBinding = this.binding;", "-\t\tif (this.binding.isValidBinding()) {", "-\t\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\t\tcase Binding.VARIABLE : // =========only variable============", "-\t\t\t\tcase Binding.VARIABLE | Binding.TYPE : //====both variable and type============", "-\t\t\t\t\tif (binding instanceof VariableBinding) {", "-\t\t\t\t\t\tVariableBinding variable = (VariableBinding) binding;", "-\t\t\t\t\t\tif (binding instanceof LocalVariableBinding) {", "-\t\t\t\t\t\t\tbits &= ~RestrictiveFlagMASK;  // clear bits", "-\t\t\t\t\t\t\tbits |= Binding.LOCAL;", "-\t\t\t\t\t\t\tif (!variable.isFinal() && (bits & DepthMASK) != 0) {", "-\t\t\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tTypeBinding fieldType = variable.type;", "-\t\t\t\t\t\t\tif ((this.bits & IsStrictlyAssigned) == 0) {", "-\t\t\t\t\t\t\t\tconstant = variable.constant();", "-\t\t\t\t\t\t\t\tif (fieldType != null) ", "-\t\t\t\t\t\t\t\t\tfieldType = fieldType.capture(scope, this.sourceEnd); // perform capture conversion if read access", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\treturn this.resolvedType = fieldType;", "+public TypeBinding resolveType(BlockScope scope) {", "+\t// for code gen, harm the restrictiveFlag \t", "+", "+\tif (this.actualReceiverType != null) {", "+\t\tthis.binding = scope.getField(this.actualReceiverType, this.token, this);", "+\t} else {", "+\t\tthis.actualReceiverType = scope.enclosingSourceType();", "+\t\tthis.binding = scope.getBinding(this.token, this.bits & ASTNode.RestrictiveFlagMASK, this, true /*resolve*/);", "+\t}", "+\tthis.codegenBinding = this.binding;", "+\tif (this.binding.isValidBinding()) {", "+\t\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\t\tcase Binding.VARIABLE : // =========only variable============", "+\t\t\tcase Binding.VARIABLE | Binding.TYPE : //====both variable and type============", "+\t\t\t\tif (this.binding instanceof VariableBinding) {", "+\t\t\t\t\tVariableBinding variable = (VariableBinding) this.binding;", "+\t\t\t\t\tTypeBinding variableType;", "+\t\t\t\t\tif (this.binding instanceof LocalVariableBinding) {", "+\t\t\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK;  // clear bits", "+\t\t\t\t\t\tthis.bits |= Binding.LOCAL;", "+\t\t\t\t\t\tif (!variable.isFinal() && (this.bits & ASTNode.DepthMASK) != 0) {", "+\t\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);", "+\t\t\t\t\t\tvariableType = variable.type;", "+\t\t\t\t\t\tthis.constant = (this.bits & ASTNode.IsStrictlyAssigned) == 0 ? variable.constant() : Constant.NotAConstant;", "+\t\t\t\t\t} else {", "-\t\t\t\t\t\t// perform capture conversion if read access", "-\t\t\t\t\t\tTypeBinding fieldType = checkFieldAccess(scope);", "-\t\t\t\t\t\treturn this.resolvedType = ", "-\t\t\t\t\t\t\t(((this.bits & IsStrictlyAssigned) == 0) ", "-\t\t\t\t\t\t\t\t? fieldType.capture(scope, this.sourceEnd)", "-\t\t\t\t\t\t\t\t: fieldType);", "+\t\t\t\t\t\tvariableType = checkFieldAccess(scope);", "-\t", "-\t\t\t\t\t// thus it was a type", "-\t\t\t\t\tbits &= ~RestrictiveFlagMASK;  // clear bits", "-\t\t\t\t\tbits |= Binding.TYPE;", "-\t\t\t\tcase Binding.TYPE : //========only type==============", "-\t\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\t\t//deprecated test", "-\t\t\t\t\tTypeBinding type = (TypeBinding)binding;", "-\t\t\t\t\tif (isTypeUseDeprecated(type, scope))", "-\t\t\t\t\t\tscope.problemReporter().deprecatedType(type, this);", "-\t\t\t\t\ttype = scope.environment().convertToRawType(type, false /*do not force conversion of enclosing types*/);", "-\t\t\t\t\treturn this.resolvedType = type;", "-\t\t\t}", "-\t\t}", "-\t", "-\t\t// error scenarii", "-\t\treturn this.resolvedType = this.reportError(scope);", "-\t}", "+\t\t\t\t\t// perform capture conversion if read access", "+\t\t\t\t\tif (variableType != null) {", "+\t\t\t\t\t\tthis.resolvedType = variableType = (((this.bits & ASTNode.IsStrictlyAssigned) == 0) ", "+\t\t\t\t\t\t\t\t? variableType.capture(scope, this.sourceEnd)", "+\t\t\t\t\t\t\t\t: variableType);", "+\t\t\t\t\t\tif ((variableType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\t\tif ((this.bits & Binding.LOCAL) == 0) {", "+\t\t\t\t\t\t\t\t// only complain if field reference (for local, its type got flagged already)", "+\t\t\t\t\t\t\t\tscope.problemReporter().invalidType(this, variableType);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\treturn variableType;", "+\t\t\t\t}", "+\t\t\t\t// thus it was a type", "+\t\t\t\tthis.bits &= ~ASTNode.RestrictiveFlagMASK;  // clear bits", "+\t\t\t\tthis.bits |= Binding.TYPE;", "+\t\t\tcase Binding.TYPE : //========only type==============", "+\t\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\t\t//deprecated test", "+\t\t\t\tTypeBinding type = (TypeBinding)this.binding;", "+\t\t\t\tif (isTypeUseDeprecated(type, scope))", "+\t\t\t\t\tscope.problemReporter().deprecatedType(type, this);", "+\t\t\t\ttype = scope.environment().convertToRawType(type, false /*do not force conversion of enclosing types*/);", "+\t\t\t\treturn this.resolvedType = type;", "+\t\t}", "+\t}", "+\t// error scenarii", "+\treturn this.resolvedType = this.reportError(scope);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aadbe5b4b06175ece5d12997310a148c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetTypeDeclaration.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void generateCode(ClassFile enclosingClassFile)", "signatureAfterChange": " public void generateCode(ClassFile enclosingClassFile)", "diff": ["-\tif (hasBeenGenerated) return;", "-\thasBeenGenerated = true;", "+\tif (this.hasBeenGenerated) return;", "+\tthis.hasBeenGenerated = true;", "-\tif (ignoreFurtherInvestigation) {", "-\t\tif (binding == null)", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tif (this.binding == null)", "-\t\tCodeSnippetClassFile.createProblemType(this, scope.referenceCompilationUnit().compilationResult);", "+\t\tCodeSnippetClassFile.createProblemType(this, this.scope.referenceCompilationUnit().compilationResult);", "-\t\tClassFile classFile = new CodeSnippetClassFile(binding, enclosingClassFile, false);", "+\t\tClassFile classFile = new CodeSnippetClassFile(this.binding, enclosingClassFile, false);", "-\t\tif (binding.isMemberType())", "-\t\t\tclassFile.recordEnclosingTypeAttributes(binding);", "-\t\tif (binding.isLocalType()) {", "-\t\t\tenclosingClassFile.recordNestedLocalAttribute(binding);", "-\t\t\tclassFile.recordNestedLocalAttribute(binding);", "+\t\tif (this.binding.isMemberType())", "+\t\t\tclassFile.recordEnclosingTypeAttributes(this.binding);", "+\t\tif (this.binding.isLocalType()) {", "+\t\t\tenclosingClassFile.recordNestedLocalAttribute(this.binding);", "+\t\t\tclassFile.recordNestedLocalAttribute(this.binding);", "-\t\tif (memberTypes != null) {", "-\t\t\tfor (int i = 0, max = memberTypes.length; i < max; i++) {", "+\t\tif (this.memberTypes != null) {", "+\t\t\tfor (int i = 0, max = this.memberTypes.length; i < max; i++) {", "-\t\t\t\tclassFile.recordNestedMemberAttribute(memberTypes[i].binding);", "-\t\t\t\tmemberTypes[i].generateCode(scope, classFile);", "+\t\t\t\tclassFile.recordNestedMemberAttribute(this.memberTypes[i].binding);", "+\t\t\t\tthis.memberTypes[i].generateCode(this.scope, classFile);", "-\t\tif (methods != null) {", "-\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\tmethods[i].generateCode(scope, classFile);", "+\t\tif (this.methods != null) {", "+\t\t\tfor (int i = 0, max = this.methods.length; i < max; i++) {", "+\t\t\t\tthis.methods[i].generateCode(this.scope, classFile);", "-\t\tif (ignoreFurtherInvestigation){ // trigger problem type generation for code gen errors", "-\t\t\tthrow new AbortType(scope.referenceCompilationUnit().compilationResult);", "+\t\tif (this.ignoreFurtherInvestigation){ // trigger problem type generation for code gen errors", "+\t\t\tthrow new AbortType(this.scope.referenceCompilationUnit().compilationResult);", "-\t\tscope.referenceCompilationUnit().compilationResult.record(binding.constantPoolName(), classFile);", "+\t\tthis.scope.referenceCompilationUnit().compilationResult.record(this.binding.constantPoolName(), classFile);", "-\t\tif (binding == null)", "+\t\tif (this.binding == null)", "-\t\tCodeSnippetClassFile.createProblemType(this, scope.referenceCompilationUnit().compilationResult);", "+\t\tCodeSnippetClassFile.createProblemType(this, this.scope.referenceCompilationUnit().compilationResult);"]}], "num": 55615}