{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c4ae6a2ca82f455424bb9d51009e3d14", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed68550382f43f59f4eca0087b2ce0b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java", "commitBeforeChange": "34ee213dde08a7453eec3b2a2a0e314e1d2814a6", "commitAfterChange": "7350d2407528c733101203f94e4081cd258cb05c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tConstant inlinedValue;", "-\t\tif (initialization != null) {", "-\t\t\t// initialize to constant value?", "-\t\t\tif ((inlinedValue = initialization.constant) != Constant.NotAConstant) {", "-\t\t\t\t// forget initializing unused or final locals set to constant value (final ones are inlined)", "-\t\t\t\tif (binding.resolvedPosition != -1) { // may need to preserve variable", "-\t\t\t\t\tint initPC = codeStream.position;", "-\t\t\t\t\tcodeStream.generateConstant(inlinedValue, initialization.implicitConversion);", "-\t\t\t\t\tcodeStream.recordPositionsFrom(initPC, initialization.sourceStart);", "-\t\t\t\t\tcodeStream.store(binding, false);", "-\t\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t\t//\t\t\t\tcodeStream.lastInitStateIndexWhenRemovingInits = -2; // reinitialize remove index ", "-\t\t\t\t\t//\t\t\t\tcodeStream.lastInitStateIndexWhenAddingInits = -2; // reinitialize add index\t\t", "-\t\t\t\t}", "-\t\t\t} else { // initializing to non-constant value", "-\t\t\t\tinitialization.generateCode(currentScope, codeStream, true);", "+\t\tgenerateInit: {", "+\t\t\tif (this.initialization == null) ", "+\t\t\t\tbreak generateInit;", "+\t\t\t// forget initializing unused or final locals set to constant value (final ones are inlined)", "+\t\t\tif (binding.resolvedPosition < 0) {", "+\t\t\t\tif (initialization.constant != Constant.NotAConstant) ", "+\t\t\t\t\tbreak generateInit;", "-\t\t\t\tif (binding.resolvedPosition != -1) {", "-\t\t\t\t\t// 26903, need extra cast to store null in array local var\t", "-\t\t\t\t\tif (binding.type.isArrayType() ", "-\t\t\t\t\t\t&& (initialization.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "-\t\t\t\t\t\t\t|| ((initialization instanceof CastExpression)\t// arrayLoc = (type[])null", "-\t\t\t\t\t\t\t\t&& (((CastExpression)initialization).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "-\t\t\t\t\t\tcodeStream.checkcast(binding.type); ", "-\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\tcodeStream.store(binding, false);", "-\t\t\t\t\tif (binding.initializationCount == 0) {", "-\t\t\t\t\t\t/* Variable may have been initialized during the code initializing it", "-\t\t\t\t\t\t\te.g. int i = (i = 1);", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t\t\t//\t\t\t\t\tcodeStream.lastInitStateIndexWhenRemovingInits = -2; // reinitialize remove index ", "-\t\t\t\t\t\t//\t\t\t\t\tcodeStream.lastInitStateIndexWhenAddingInits = -2; // reinitialize add index ", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((binding.type == TypeBinding.LONG) || (binding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\tcodeStream.pop2();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tinitialization.generateCode(currentScope, codeStream, false);", "+\t\t\t\tbreak generateInit;", "+\t\t\t}\t\t\t", "+\t\t\tinitialization.generateCode(currentScope, codeStream, true);", "+\t\t\t// 26903, need extra cast to store null in array local var\t", "+\t\t\tif (binding.type.isArrayType() ", "+\t\t\t\t&& (initialization.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "+\t\t\t\t\t|| ((initialization instanceof CastExpression)\t// arrayLoc = (type[])null", "+\t\t\t\t\t\t&& (((CastExpression)initialization).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "+\t\t\t\tcodeStream.checkcast(binding.type); ", "+\t\t\t}\t\t\t\t\t", "+\t\t\tcodeStream.store(binding, false);", "+\t\t\tif ((this.bits & ASTNode.FirstAssignmentToLocal) != 0) {", "+\t\t\t\t/* Variable may have been initialized during the code initializing it", "+\t\t\t\t\te.g. int i = (i = 1);", "+\t\t\t\t*/", "+\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f65c2a92374bf4f46e5f8c3a0502c16a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java", "commitBeforeChange": "731fe0d2952c3083dab81ac412f56109dd816295", "commitAfterChange": "b7ee6a874c851c7037f430220f1f330c599f0f24", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic static char[] getInputStreamAsCharArray(InputStream stream, int length, String encoding) \t\tthrows IOException", "signatureAfterChange": " \tpublic static char[] getInputStreamAsCharArray(InputStream stream, int length, String encoding) \t\tthrows IOException", "diff": ["+\t\tint totalRead = 0;", "-\t\t\tint contentsLength = 0;", "-\t\t\tint amountRead = -1;", "-\t\t\tdo {", "-\t\t\t\tint amountRequested = Math.max(stream.available(), DEFAULT_READING_SIZE);  // read at least 8K", "-", "-\t\t\t\t// resize contents if needed", "-\t\t\t\tif (contentsLength + amountRequested > contents.length) {", "-\t\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\t\tcontents,", "-\t\t\t\t\t\t0,", "-\t\t\t\t\t\tcontents = new char[contentsLength + amountRequested],", "-\t\t\t\t\t\t0,", "-\t\t\t\t\t\tcontentsLength);", "-\t\t\t\t}", "-", "-\t\t\t\t// read as many chars as possible", "-\t\t\t\tamountRead = reader.read(contents, contentsLength, amountRequested);", "-", "-\t\t\t\tif (amountRead > 0) {", "-\t\t\t\t\t// remember length of contents", "-\t\t\t\t\tcontentsLength += amountRead;", "-\t\t\t\t}", "-\t\t\t} while (amountRead != -1);", "-", "-\t\t\t// Do not keep first character for UTF-8 BOM encoding", "-\t\t\tint start = 0;", "-\t\t\tif (contentsLength > 0 && UTF_8.equals(encoding)) {", "-\t\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "-\t\t\t\t\tcontentsLength--;", "-\t\t\t\t\tstart = 1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// resize contents if necessary", "-\t\t\tif (contentsLength < contents.length) {", "-\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\tcontents,", "-\t\t\t\t\tstart,", "-\t\t\t\t\tcontents = new char[contentsLength],", "-\t\t\t\t\t0,", "-\t\t\t\t\tcontentsLength);", "-\t\t\t}", "-\t\t\tcontents = new char[length];", "-\t\t\tint len = 0;", "-\t\t\tint readSize = 0;", "-\t\t\twhile ((readSize != -1) && (len != length)) {", "-\t\t\t\t// See PR 1FMS89U", "-\t\t\t\t// We record first the read size. In this case len is the actual read size.", "-\t\t\t\tlen += readSize;", "-\t\t\t\treadSize = reader.read(contents, len, length - len);", "-\t\t\t}", "-\t\t\t// Do not keep first character for UTF-8 BOM encoding", "-\t\t\tint start = 0;", "-\t\t\tif (length > 0 && UTF_8.equals(encoding)) {", "-\t\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "-\t\t\t\t\tlen--;", "-\t\t\t\t\tstart = 1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// See PR 1FMS89U", "-\t\t\t// Now we need to resize in case the default encoding used more than one byte for each", "-\t\t\t// character", "-\t\t\tif (len != length)", "-\t\t\t\tSystem.arraycopy(contents, start, (contents = new char[len]), 0, len);", "+\t\t\t// length is a good guess when the encoding produces less or the same amount of characters than the file length", "+\t\t\tcontents = new char[length]; // best guess", "+\t\twhile (true) {", "+\t\t\tint amountRequested;", "+\t\t\tif (totalRead < length) {", "+\t\t\t\t// until known length is met, reuse same array sized eagerly", "+\t\t\t\tamountRequested = length - totalRead;", "+\t\t\t} else {", "+\t\t\t\t// reading beyond known length", "+\t\t\t\tint current = reader.read(); ", "+\t\t\t\tif (current < 0) break;", "+\t\t\t\t", "+\t\t\t\tamountRequested = Math.max(stream.available(), DEFAULT_READING_SIZE);  // read at least 8K", "+\t\t\t\t", "+\t\t\t\t// resize contents if needed", "+\t\t\t\tif (totalRead + 1 + amountRequested > contents.length)", "+\t\t\t\t\tSystem.arraycopy(contents, \t0, \tcontents = new char[totalRead + 1 + amountRequested], 0, totalRead);", "+\t\t\t\t", "+\t\t\t\t// add current character", "+\t\t\t\tcontents[totalRead++] = (char) current; // coming from totalRead==length", "+\t\t\t}", "+\t\t\t// read as many chars as possible", "+\t\t\tint amountRead = reader.read(contents, totalRead, amountRequested);", "+\t\t\tif (amountRead < 0) break;", "+\t\t\ttotalRead += amountRead;", "+\t\t}", "+", "+\t\t// Do not keep first character for UTF-8 BOM encoding", "+\t\tint start = 0;", "+\t\tif (totalRead > 0 && UTF_8.equals(encoding)) {", "+\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "+\t\t\t\ttotalRead--;", "+\t\t\t\tstart = 1;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// resize contents if necessary", "+\t\tif (totalRead < contents.length)", "+\t\t\tSystem.arraycopy(contents, start, contents = new char[totalRead], \t0, \ttotalRead);", "+"]}], "num": 48438}