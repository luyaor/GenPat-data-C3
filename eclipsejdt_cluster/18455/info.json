{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fb1c4925e3d40d469287a040d7de8894", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2eb640df1b61047abe235ab7ff28856b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9fa4ee2d52d7a35a0c57f8c4b875f0f155754f75", "commitAfterChange": "330462fa1b1e3cc7e6b257e0a0f3470535bf4f54", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tboolean mustResolve,", "-\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0) return level;", "+\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0 || depth>=patternTypeArguments.length || patternTypeArguments[depth] == null) return level;", "+\t", "+\t// if pattern is erasure match (see bug 79790), commute impossible to erasure", "+\tint impossible = this.isErasureMatch ? ERASURE_MATCH : IMPOSSIBLE_MATCH;", "-\t\t\tif (mustResolve)", "+\t\t\tif (this.mustResolve)", "+\t\t\t\tboolean patternTypeArgHasAnyChars = CharOperation.contains(new char[] {'*', '?'}, patternTypeArgument);", "-\t\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "+\t\t\t\t\t\t\t// Invalid if type argument is not exact", "+\t\t\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\t\t// Look for bound name in hierarchy", "+\t\t\t\t\t// Look if bound name match pattern type argument", "+\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t}", "+", "+\t\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "+\t\t\t\t\t\t", "+\t\t\t\t\t// Look for bound name in type argument superclasses", "+\t\t\t\t\tboundBinding = boundBinding.superclass();", "-\t\t\t\t\t\tif (CharOperation.match(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\t\tCharOperation.match(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\treturn impossible;", "+", "+\t\t\t\t// If pattern is not exact then match fails", "+\t\t\t\tif (patternTypeArgHasAnyChars) return impossible;", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\treturn impossible;", "-\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, mustResolve, enclosingType) == IMPOSSIBLE_MATCH) {", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "+\t\t\tint enclosingLevel = resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, enclosingType);", "+\t\t\tif (enclosingLevel == impossible) return impossible;", "+\t\t\tif (enclosingLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fabf4c559b9ba3e03b085ca4f5f59d22", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "321d0d2c500c247f0447784febbb6a14ba5499be", "commitAfterChange": "0a78a38e693907f3c7add6d8e6f4ecfad096e0fb", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 38, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\tboolean isRawType = type.isRawType();", "-\t} else if (isRawType) {", "+\t} else if (type.isRawType()) {", "-\t} else if (!type.isParameterizedType()) {", "-\t\t// Standard types (ie. neither generic nor parameterized nor raw types)", "-\t\t// cannot match pattern with type parameters or arguments", "-\t\treturn (patternTypeArguments[depth]==null || patternTypeArguments[depth].length==0) ? level : IMPOSSIBLE_MATCH;", "-\t\tParameterizedTypeBinding paramTypeBinding = (ParameterizedTypeBinding) type;", "+\t\tTypeBinding leafType = type.leafComponentType();", "+\t\tif (!leafType.isParameterizedType()) {", "+\t\t\t// Standard types (ie. neither generic nor parameterized nor raw types)", "+\t\t\t// cannot match pattern with type parameters or arguments", "+\t\t\treturn (patternTypeArguments[depth]==null || patternTypeArguments[depth].length==0) ? level : IMPOSSIBLE_MATCH;", "+\t\t}", "+\t\tParameterizedTypeBinding paramTypeBinding = (ParameterizedTypeBinding) leafType;", "-\t\t\t\t// Get reference binding", "-\t\t\t\tReferenceBinding refBinding = null;", "-\t\t\t\tif (argTypeBinding.isArrayType()) {", "-\t\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "-\t\t\t\t\tif (!leafBinding.isBaseType()) {", "-\t\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (!argTypeBinding.isBaseType()) {", "-\t\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "-\t\t\t\t}", "-\t\t\t\tif (refBinding != null) {", "-\t\t\t\t\trefBinding = refBinding.superclass();", "-\t\t\t\t\twhile (refBinding != null) {", "-\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\tTypeBinding leafTypeBinding = argTypeBinding.leafComponentType();", "+\t\t\t\tif (leafTypeBinding.isBaseType()) return impossible;", "+\t\t\t\tReferenceBinding refBinding = ((ReferenceBinding) leafTypeBinding).superclass();", "+\t\t\t\twhile (refBinding != null) {", "+\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t} else if (refBinding.isLocalType() || refBinding.isMemberType()) {", "+\t\t\t\t\t\t// for local or member type, verify also source name (bug 81084)", "+\t\t\t\t\t\tif (CharOperation.match(patternTypeArgument, refBinding.sourceName(), this.isCaseSensitive))", "-\t\t\t\t\t\t} else if (refBinding.isLocalType() || refBinding.isMemberType()) {", "-\t\t\t\t\t\t\t// for local or member type, verify also source name (bug 81084)", "-\t\t\t\t\t\t\tif (CharOperation.match(patternTypeArgument, refBinding.sourceName(), this.isCaseSensitive))", "-\t\t\t\t\t\t\t\tcontinue nextTypeArgument;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\trefBinding = refBinding.superclass();", "+\t\t\t\t\trefBinding = refBinding.superclass();"]}], "num": 18455}