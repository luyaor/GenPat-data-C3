{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4465ddea4659617396bb02bb3b456986", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "66a7d620555847d2c086b6ed486b0aed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java", "commitBeforeChange": "83b88f3849bc3529944cb5ada76e610acc101ab1", "commitAfterChange": "7eed8178809b3804cdae88d40ff2d9114bc0d206", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\t\tTypeBinding collectionElementType = ((ArrayBinding) collectionType).elementsType();", "+\t\t\t\tthis.collectionElementType = ((ArrayBinding) collectionType).elementsType();", "-\t\t\t\tthis.arrayElementTypeID = collectionElementType.id;", "-\t\t\t\tint compileTimeTypeID = this.arrayElementTypeID;", "+\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = parameterizedType.arguments[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = parameterizedType.arguments[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tTypeBinding collectionElementType = iterableType.typeVariables()[0]; ", "-\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\t\tthis.collectionElementType = iterableType.typeVariables()[0]; ", "+\t\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tint compileTimeTypeID = collectionElementType.id;", "+\t\t\t\t\t\t\t// no conversion needed as only for reference types", "+\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\tif (!collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = UNBOXING;", "+\t\t\t\t\t\t\t\t\tif (elementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (collectionElementType.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tint boxedID = scope.environment().computeBoxingType(collectionElementType).id;", "+\t\t\t\t\t\t\t\t\tthis.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion", "+\t\t\t\t\t\t\t\t\tcompileTimeTypeID = boxedID;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tTypeBinding collectionElementType = scope.getJavaLangObject(); ", "-\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)) {", "+\t\t\t\t\t\tthis.collectionElementType = scope.getJavaLangObject();", "+\t\t\t\t\t\tif (!collectionElementType.isCompatibleWith(elementType)", "+\t\t\t\t\t\t\t\t&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {", "-\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t    "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd7cdfca03e82dfc3d0c7a1c0bdac87c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "0f7f9d63e5fbc5d41771bd4e2e39b628130add76", "commitAfterChange": "ed4cdf5cf5dec0284dce12a661248f2f9a27a709", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "signatureAfterChange": "  \tprivate void printLineComment(int commentStart, int commentEnd)", "diff": ["-\t\tthis.indentationLevel = getNextIndentationLevel(firstColumn);", "+\t\tthis.indentationLevel = (this.column / this.tabLength) * this.tabLength;", "+\t\tStringBuffer tokensBuffer = new StringBuffer();", "+\t\tboolean bufferHasTokens = false;", "-\t\t\t\tString msg = iie.getMessage();", "-\t\t\t\tif (msg == Scanner.INVALID_CHARACTER_CONSTANT) {", "-\t\t\t\t\tbuffer.append('\\'');", "-\t\t\t\t} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {", "-\t\t\t\t\tbuffer.append('\"');", "-\t\t\t\t} else {", "-\t\t\t\t\t// skip failure", "-\t\t\t\t}", "-\t\t\t\t// Need to retrieve correct position", "+\t    \t\tif (previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE) {", "+\t    \t\t\ttokensBuffer.append(' ');", "+\t    \t\t}", "-\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\tthis.column++;", "+\t    \t\tchar ch = (char) this.scanner.getNextChar();", "+\t\t\t\tpreviousToken = TerminalTokens.TokenNameWHITESPACE;", "+\t\t\t\twhile (!ScannerHelper.isWhitespace(ch)) {", "+\t\t\t\t\ttokensBuffer.append(ch);", "+\t\t\t\t\tif (this.scanner.atEnd()) {", "+\t\t\t\t\t\tpreviousToken = TerminalTokens.TokenNameEOF;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tch = (char) this.scanner.getNextChar();", "+\t\t\t\t}", "+\t\t\t\t\tif (tokensBuffer.length() > 0) {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t\t}", "-    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;", "-\t\t\tthis.column += tokenLength;", "-    \t\tif (previousToken == -1 || insertSpace) this.column++;", "-    \t\tint col = column; ", "-\t\t\tif (!firstWord && col > maxColumn) {", "+    \t\tboolean insertSpace = previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE;", "+    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "+    \t\tif (insertSpace) lastColumn++;", "+\t\t\tif (!firstWord && lastColumn > maxColumn) {", "-\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t    \tthis.column = 1;", "-\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\tbuffer.append(LINE_COMMENT_PREFIX);", "-\t\t    \tthis.column = firstColumn + LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\tif ((firstColumn+tokensBuffer.length()+tokenLength) > maxColumn) {", "+\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "+\t\t\t\t\t// So add the buffered tokens now", "+\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\tbufferHasTokens = true;", "+\t\t\t\t}", "+\t\t\t\tif (bufferHasTokens) {", "+\t\t\t    \tbuffer.append(this.lineSeparator);", "+\t\t\t    \tthis.column = 1;", "+\t\t\t    \tprintIndentationIfNecessary(buffer);", "+\t    \t\t\tbuffer.append(LINE_COMMENT_PREFIX);", "+\t\t    \t\tthis.column += LINE_COMMENT_PREFIX_LENGTH;", "+\t\t\t\t}", "+\t\t    \tif (tokensBuffer.length() > 0) {", "+\t\t    \t\tif (ScannerHelper.isWhitespace(tokensBuffer.charAt(0))) {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer.substring(1));", "+\t\t\t\t\t\tthis.column += tokensBuffer.length() - 1;", "+\t\t    \t\t} else {", "+\t\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t    \t\t}", "+\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t\t\tif (insertSpace)  {", "+\t\t    \t\t\tbuffer.append(' ');", "+\t\t    \t\t\tthis.column++;", "+\t\t\t\t\t}", "+\t\t    \t}", "+\t\t\t\tbufferHasTokens = true;", "+\t\t\t\tfirstColumn = this.indentationLevel + LINE_COMMENT_PREFIX_LENGTH;", "-\t\t\t\tif (previousToken == -1 || insertSpace)  {", "-\t    \t\t\tbuffer.append(' ');", "+\t\t\t\tif (insertSpace)  {", "+\t    \t\t\ttokensBuffer.append(' ');", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t}", "+", "+\t\t// Add remaining buffered tokens", "+\t\tif (tokensBuffer.length() > 0) {", "+\t\t\tbuffer.append(tokensBuffer);", "+\t\t\tthis.column += tokensBuffer.length();"]}], "num": 35512}