{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "224fb5707519d4d90cc0c158d621550d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e505521d5c4d94bd9e6ec13522ffb24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "23d1f03b5721ce2de9c0b6bda12e344c2ac468ba", "commitAfterChange": "966ae4bbaf97367f3fc38a9b2c2261f477021842", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "-\t\t\tchar[][] typeParameterNames = null;", "-\t\t\tchar[][][] typeParameterBounds = null;", "-\t\t\tif (typeParameters != null) {", "-\t\t\t\tint typeParametersLength = typeParameters.length;", "-\t\t\t\ttypeParameterNames = new char[typeParametersLength][];", "-\t\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "-\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "-\t\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "-\t\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "-\t\t\t\t\tif (bounds != null) {", "-\t\t\t\t\t\tint boundLength = bounds.length;", "-\t\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "-\t\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "-\t\t\t\t\t\t\tboundNames[j] = ", "-\t\t\t\t\t\t\t\tCharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); ", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}\t\t\t", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "+\t\t\tnotifySourceElementRequestor(methodDeclaration.typeParameters());\t\t\t", "-\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "-\t\tchar[][] typeParameterNames = null;", "-\t\tchar[][][] typeParameterBounds = null;", "-\t\tif (typeParameters != null) {", "-\t\t\tint typeParametersLength = typeParameters.length;", "-\t\t\ttypeParameterNames = new char[typeParametersLength][];", "-\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "-\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "-\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "-\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "-\t\t\t\tif (bounds != null) {", "-\t\t\t\t\tint boundLength = bounds.length;", "-\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "-\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "-\t\t\t\t\t\tboundNames[j] = ", "-\t\t\t\t\t\t\tCharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); ", "-\t\t\t\t\t}", "-\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "-\t\t\t\tthrownExceptionTypes,", "-\t\t\t\ttypeParameterNames,", "-\t\t\t\ttypeParameterBounds);", "+\t\t\t\tthrownExceptionTypes);", "+\t\tnotifySourceElementRequestor(methodDeclaration.typeParameters());\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8627bab3103d529e636d98e0c471720", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "commitAfterChange": "59519e2b1686eb933c8efe8536442e5841102c2e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "-\t\t/* validate output locations */", "-\t\tif (projectOutputLocation == null) {", "+\t\t/* validate output location */", "+\t\tif (outputLocation == null) {", "-\t\t// tolerate null path, it will be reset to default", "-\t\tint length = classpath == null ? 0 : classpath.length; ", "-\t\t// collect other output locations", "-\t\tint outputsLength = length+1;", "-\t\tIPath[] outputLocations = new IPath[outputsLength];", "-\t\toutputLocations[length] = projectOutputLocation;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tIClasspathEntry entry = classpath[i];", "-\t\t\tIPath outputLocation = entry.getOutputLocation();", "-\t\t\tif (outputLocation != null) {", "-\t\t\t\tif (outputLocation.isAbsolute()) {", "-\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\toutputLocations[i] = outputLocation;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t\t\t}", "+\t\tif (outputLocation.isAbsolute()) {", "+\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t} else {", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean allowNestingInOutput = false;", "-\t\t", "+\t", "+\t\t// tolerate null path, it will be reset to default", "+\t\tint length = classpath == null ? 0 : classpath.length; ", "+\t", "-\t\t\tint kind = rawEntry.getEntryKind();", "-\t\t\tswitch(kind){", "+\t\t\tswitch(rawEntry.getEntryKind()){", "-\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "-\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "-\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "-\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "-\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "-\t\t\t\tfor (int j = 0; j < length; j++){", "+\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "-\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\tif (outputLocation != null) {", "-\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t", "-\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t}", "+\t", "+\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$"]}], "num": 71974}