{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2ce5c92bb8231cf434aac0e04b3ac1bc", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2cf7682f231a2efa8a4d2d55e0b95764", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "830277de86eee08c18b5e0da495c01b96cccdad2", "commitAfterChange": "a874c20c38675a0faf72bfd6c0cb69354f6ff3fb", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public int literalIndexForLdc(char[] stringCharArray)", "signatureAfterChange": " public int literalIndexForLdc(char[] stringCharArray)", "diff": ["-\tint savedCurrentIndex = this.currentIndex;", "-\tint savedCurrentOffset = this.currentOffset;", "-\tint index;", "-\tif ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t// The entry doesn't exit yet", "-\t\tthis.currentIndex++;", "-\t\t// Write the tag first", "-\t\twriteU1(StringTag);", "-\t\t", "-\t\t// Then the string index", "-\t\tint stringIndexOffset = this.currentOffset;", "-\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\tresizePoolContents(2);", "-\t\t}", "-\t\tcurrentOffset+=2;", "+    int savedCurrentIndex = this.currentIndex;", "+    int savedCurrentOffset = this.currentOffset;", "+    int index;", "+    if ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+        if ((index = -index)> 0xFFFF) {", "+            this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+        }", "+        // The entry doesn't exit yet", "+        this.currentIndex++;", "+        // Write the tag first", "+        int length = this.offsets.length;", "+        if (length <= index) {", "+        \t// resize", "+            System.arraycopy(this.offsets, 0, (this.offsets = new int[index * 2]), 0, length);", "+        }", "+        this.offsets[index] = this.currentOffset;", "+        writeU1(StringTag);", "-\t\tint stringIndex;", "-\t\tif ((stringIndex = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "-\t\t\t// The entry doesn't exit yet", "-\t\t\tthis.currentIndex++;", "-\t\t\t// Write the tag first", "-\t\t\twriteU1(Utf8Tag);", "-\t\t\t// Then the size of the stringName array", "-\t\t\tint lengthOffset = currentOffset;", "-\t\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t// enough space to write the length", "-\t\t\t\tresizePoolContents(2);", "-\t\t\t}", "-\t\t\tcurrentOffset += 2;", "-\t\t\tint length = 0;", "-\t\t\tfor (int i = 0; i < stringCharArray.length; i++) {", "-\t\t\t\tchar current = stringCharArray[i];", "-\t\t\t\tif ((current >= 0x0001) && (current <= 0x007F)) {", "-\t\t\t\t\t// we only need one byte: ASCII table", "-\t\t\t\t\tlength++;", "-\t\t\t\t\tif (currentOffset + 1 >= poolContent.length) {", "-\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\tresizePoolContents(1);", "-\t\t\t\t\t}", "-\t\t\t\t\tpoolContent[currentOffset++] = (byte)(current);", "-\t\t\t\t} else", "-\t\t\t\t\tif (current > 0x07FF) {", "-\t\t\t\t\t\t// we need 3 bytes", "-\t\t\t\t\t\tlength += 3;", "-\t\t\t\t\t\tif (currentOffset + 3 >= poolContent.length) {", "-\t\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\t\tresizePoolContents(3);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (currentOffset + 2 >= poolContent.length) {", "-\t\t\t\t\t\t\t// we need to resize the poolContent array because we won't have", "-\t\t\t\t\t\t\t// enough space to write the length", "-\t\t\t\t\t\t\tresizePoolContents(2);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// we can be 0 or between 0x0080 and 0x07FF", "-\t\t\t\t\t\t// In that case we only need 2 bytes", "-\t\t\t\t\t\tlength += 2;", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "-\t\t\t\t\t\tpoolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "-\t\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (length >= 65535) {", "-\t\t\t\tthis.currentOffset = savedCurrentOffset;", "-\t\t\t\tthis.currentIndex = savedCurrentIndex;", "-\t\t\t\tthis.stringCache.remove(stringCharArray);", "-\t\t\t\tthis.UTF8Cache.remove(stringCharArray);", "-\t\t\t\treturn 0;", "-\t\t\t}", "-\t\t\tpoolContent[lengthOffset++] = (byte) (length >> 8);", "-\t\t\tpoolContent[lengthOffset] = (byte) length;", "-\t\t\tstringIndex = -stringIndex;", "-\t\t}", "-\t\tif ((index = -index) > 0xFFFF){", "-\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t}", "-\t\tpoolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "-\t\tpoolContent[stringIndexOffset] = (byte) stringIndex;", "-\t}", "-\treturn index;", "+        // Then the string index", "+        int stringIndexOffset = this.currentOffset;", "+        if (currentOffset + 2 >= poolContent.length) {", "+            resizePoolContents(2);", "+        }", "+        currentOffset+=2;", "+", "+        int stringIndex;", "+        if ((stringIndex = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {", "+            if ((stringIndex = -stringIndex)> 0xFFFF) {", "+                this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "+            }", "+            // The entry doesn't exit yet", "+            this.currentIndex++;", "+            // Write the tag first", "+            length = this.offsets.length;", "+            if (length <= stringIndex) {", "+            \t// resize", "+                System.arraycopy(this.offsets, 0, (this.offsets = new int[stringIndex * 2]), 0, length);", "+            }", "+            this.offsets[stringIndex] = this.currentOffset;", "+            writeU1(Utf8Tag);", "+            // Then the size of the stringName array", "+            int lengthOffset = currentOffset;", "+            if (currentOffset + 2 >= poolContent.length) {", "+                // we need to resize the poolContent array because we won't have", "+                // enough space to write the length", "+                resizePoolContents(2);", "+            }", "+            currentOffset += 2;", "+            length = 0;", "+            for (int i = 0; i < stringCharArray.length; i++) {", "+                char current = stringCharArray[i];", "+                if ((current >= 0x0001) && (current <= 0x007F)) {", "+                    // we only need one byte: ASCII table", "+                    length++;", "+                    if (currentOffset + 1 >= poolContent.length) {", "+                        // we need to resize the poolContent array because we won't have", "+                        // enough space to write the length", "+                        resizePoolContents(1);", "+                    }", "+                    poolContent[currentOffset++] = (byte)(current);", "+                } else", "+                    if (current > 0x07FF) {", "+                        // we need 3 bytes", "+                        length += 3;", "+                        if (currentOffset + 3 >= poolContent.length) {", "+                            // we need to resize the poolContent array because we won't have", "+                            // enough space to write the length", "+                            resizePoolContents(3);", "+                        }", "+                        poolContent[currentOffset++] = (byte) (0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                    } else {", "+                        if (currentOffset + 2 >= poolContent.length) {", "+                            // we need to resize the poolContent array because we won't have", "+                            // enough space to write the length", "+                            resizePoolContents(2);", "+                        }", "+                        // we can be 0 or between 0x0080 and 0x07FF", "+                        // In that case we only need 2 bytes", "+                        length += 2;", "+                        poolContent[currentOffset++] = (byte) (0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000", "+                        poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000", "+                    }", "+            }", "+            if (length >= 65535) {", "+                this.currentOffset = savedCurrentOffset;", "+                this.currentIndex = savedCurrentIndex;", "+                this.stringCache.remove(stringCharArray);", "+                this.UTF8Cache.remove(stringCharArray);", "+                return 0;", "+            }", "+            poolContent[lengthOffset++] = (byte) (length >> 8);", "+            poolContent[lengthOffset] = (byte) length;", "+        }", "+        poolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);", "+        poolContent[stringIndexOffset] = (byte) stringIndex;", "+    }", "+    return index;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4c36eb46c95523904f99e2d8074438e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "a2ae3e117eaea10fecaf3678af5938ffa98d76f4", "commitAfterChange": "71ab6b3956db9fea4a8f81e891e05ac4d44d96d9", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "\r public int literalIndex(MethodBinding aMethodBinding)", "signatureAfterChange": "\r public int literalIndex(MethodBinding aMethodBinding)", "diff": ["+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r", "+\t\t\t\tif (index > 0xFFFF){\r", "+\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4fc25da0295ff3ee860a57bf40ed7a23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "1987bebfc0499fe07d643a641d2e74ff184f5cc7", "commitAfterChange": "2b6b723d87be49aecbb1b89e893d389af560ea10", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "signatureAfterChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "diff": ["-\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().bytecodeExceeds64KLimit(", "-\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\tif (this.codeStream.methodDeclaration != null) {", "+\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().bytecodeExceeds64KLimit(this.codeStream.methodDeclaration);", "+\t\t\t} else {", "+\t\t\t\tthis.codeStream.lambdaExpression.scope.problemReporter().bytecodeExceeds64KLimit(this.codeStream.lambdaExpression);", "+\t\t\t}", "-\t\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().abortDueToInternalError(", "-\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.methodDeclaration.selector)),", "-\t\t\t\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\t\t\tif (this.codeStream.methodDeclaration != null) {", "+\t\t\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().abortDueToInternalError(", "+\t\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.methodDeclaration.selector)),", "+\t\t\t\t\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.codeStream.lambdaExpression.scope.problemReporter().abortDueToInternalError(", "+\t\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.lambdaExpression.binding.selector)),", "+\t\t\t\t\t\t\t\tthis.codeStream.lambdaExpression);", "+\t\t\t\t\t}", "-\t\t\tfinal boolean methodDeclarationIsStatic = this.codeStream.methodDeclaration.isStatic();", "+\t\t\tfinal boolean methodDeclarationIsStatic = this.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.isStatic() : this.codeStream.lambdaExpression.binding.isStatic();", "-\t\t\t\t\tthis.codeStream.methodDeclaration.binding,", "+\t\t\t\t\tthis.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.binding : this.codeStream.lambdaExpression.binding,", "-\t\t\t\t\tthis.codeStream.methodDeclaration.binding,", "+\t\t\t\t\tthis.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.binding : this.codeStream.lambdaExpression.binding,"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "51a4525ae674ad879090dc32a5bb699f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceJavadocParser.java", "commitBeforeChange": "b9048812dd88e4e03993f3f1485c45b1b5d06172", "commitAfterChange": "746639968f86f3ad41d15e0e45898b6cf0685369", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected boolean parseIdentifierTag(boolean report)", "signatureAfterChange": " protected boolean parseIdentifierTag(boolean report)", "diff": ["+\t\t\t// Store first category id", "+\t\t\t\tlength += 5;", "+\t\t\t// Store optional additional category identifiers", "+\t\t\tconsumeToken();", "+\t\t\twhile (this.index < this.javadocEnd) {", "+\t\t\t\tif (readTokenSafely() == TerminalTokens.TokenNameIdentifier && (this.scanner.currentCharacter == ' ' || Character.isWhitespace(this.scanner.currentCharacter))) {", "+\t\t\t\t\tif (this.index > (this.lineEnd+1)) break;", "+\t\t\t\t\t// valid additional identifier", "+\t\t\t\t\tif (++this.categoriesPtr >= length) {", "+\t\t\t\t\t\tSystem.arraycopy(this.categories, 0, this.categories = new char[length+5][], 0, length);", "+\t\t\t\t\t\tlength += 5;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.categories[this.categoriesPtr] = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t} else {", "+\t\t\t\t\t// TODO (frederic) raise warning for invalid syntax when javadoc spec will be finalized...", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// Reset position to end of line", "+\t\t\tthis.index = this.lineEnd;", "+\t\t\tthis.scanner.currentPosition = this.lineEnd;", "+\t\t\tconsumeToken();"]}], "num": 49789}