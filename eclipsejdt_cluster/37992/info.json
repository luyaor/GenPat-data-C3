{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "91adf88c61a36c33206f34f9f6887183", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4fc25da0295ff3ee860a57bf40ed7a23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "1987bebfc0499fe07d643a641d2e74ff184f5cc7", "commitAfterChange": "2b6b723d87be49aecbb1b89e893d389af560ea10", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "signatureAfterChange": " \tpublic void completeCodeAttribute(int codeAttributeOffset)", "diff": ["-\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().bytecodeExceeds64KLimit(", "-\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\tif (this.codeStream.methodDeclaration != null) {", "+\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().bytecodeExceeds64KLimit(this.codeStream.methodDeclaration);", "+\t\t\t} else {", "+\t\t\t\tthis.codeStream.lambdaExpression.scope.problemReporter().bytecodeExceeds64KLimit(this.codeStream.lambdaExpression);", "+\t\t\t}", "-\t\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().abortDueToInternalError(", "-\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.methodDeclaration.selector)),", "-\t\t\t\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\t\t\tif (this.codeStream.methodDeclaration != null) {", "+\t\t\t\t\t\tthis.codeStream.methodDeclaration.scope.problemReporter().abortDueToInternalError(", "+\t\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.methodDeclaration.selector)),", "+\t\t\t\t\t\t\t\tthis.codeStream.methodDeclaration);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.codeStream.lambdaExpression.scope.problemReporter().abortDueToInternalError(", "+\t\t\t\t\t\t\t\tMessages.bind(Messages.abort_invalidExceptionAttribute, new String(this.codeStream.lambdaExpression.binding.selector)),", "+\t\t\t\t\t\t\t\tthis.codeStream.lambdaExpression);", "+\t\t\t\t\t}", "-\t\t\tfinal boolean methodDeclarationIsStatic = this.codeStream.methodDeclaration.isStatic();", "+\t\t\tfinal boolean methodDeclarationIsStatic = this.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.isStatic() : this.codeStream.lambdaExpression.binding.isStatic();", "-\t\t\t\t\tthis.codeStream.methodDeclaration.binding,", "+\t\t\t\t\tthis.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.binding : this.codeStream.lambdaExpression.binding,", "-\t\t\t\t\tthis.codeStream.methodDeclaration.binding,", "+\t\t\t\t\tthis.codeStream.methodDeclaration != null ? this.codeStream.methodDeclaration.binding : this.codeStream.lambdaExpression.binding,"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "926ba12e4bc4f390fb307e293c56bd39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "ee88edc6852ca240266a0a82beb39fc6a3f8a578", "commitAfterChange": "321d0d2c500c247f0447784febbb6a14ba5499be", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " public SearchMatch newDeclarationMatch(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator)", "signatureAfterChange": " public SearchMatch newDeclarationMatch(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator)", "diff": ["-\t\t// Redo arguments verif as in this case previous filter may accept different ones", "-\t\tboolean equals = true;", "-\t\tif (this.pattern.parameterSimpleNames != null) {", "-\t\t\tint paramLength = this.pattern.parameterSimpleNames.length;", "-\t\t\tfor (int i=0; equals && i<paramLength; i++) {", "-\t\t\t\tint level = resolveLevelForType(this.pattern.parameterSimpleNames[i], this.pattern.parameterQualifications[i], methodBinding.parameters[i]);", "-\t\t\t\tif (level == IMPOSSIBLE_MATCH) equals = false;", "+\t\t// If method parameters verification was not valid, then try to see if method arguments can match a method in hierarchy", "+\t\tif (this.methodDeclarationsWithInvalidParam.containsKey(reference)) {", "+\t\t\t// First see if this reference has already been resolved => report match if validated", "+\t\t\tBoolean report = (Boolean) this.methodDeclarationsWithInvalidParam.get(reference);", "+\t\t\tif (report != null) {", "+\t\t\t\tif (report.booleanValue()) {", "+\t\t\t\t\treturn super.newDeclarationMatch(reference, element, elementBinding, accuracy, length, locator);", "+\t\t\t\t}", "+\t\t\t\treturn null;", "-\t\t}", "-\t\t// If arguments are not equals then try to see if method arguments can match erasures in hierarchy", "-\t\tif (!equals && this.pattern.findDeclarations && this.mayBeGeneric) {", "-\t\t\tif (isErasureMethodOverride(methodBinding.declaringClass, methodBinding)) {", "+\t\t\tif (matchOverriddenMethod(methodBinding.declaringClass, methodBinding, null)) {", "+\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.TRUE);", "-\t\t\t\t\tpatternBinding = patternBinding.original();", "-\t\t\t\t\tif (!isErasureMethodOverride(patternBinding.declaringClass, patternBinding)) {", "+\t\t\t\t\tif (!matchOverriddenMethod(patternBinding.declaringClass, patternBinding, methodBinding)) {", "+\t\t\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.FALSE);", "+\t\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.TRUE);", "+\t\t\tthis.methodDeclarationsWithInvalidParam.put(reference, Boolean.FALSE);"]}], "num": 37992}