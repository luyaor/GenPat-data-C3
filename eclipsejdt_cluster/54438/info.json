{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a5e6cfac743f479428711ba4292c1aa2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3c20bf28ec91615d65d1ade97aee1e14", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 65, "methodNumberAfterChange": 65, "signatureBeforeChange": "  \tprivate void printJavadocBlockReference(StringBuffer buffer, FormatJavadocReference reference, FormatJavadocBlock block)", "signatureAfterChange": "  \tprivate void printJavadocBlockReference(FormatJavadocBlock block, FormatJavadocReference reference)", "diff": ["-\tprivate void printJavadocBlockReference(StringBuffer buffer, FormatJavadocReference reference, FormatJavadocBlock block) {", "-", "-\t\tboolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();", "-\t\tboolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();", "+\tprivate void printJavadocBlockReference(FormatJavadocBlock block, FormatJavadocReference reference) {", "+\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "-\t\tStringBuffer tokensBuffer = new StringBuffer();", "+\t\tboolean inlined = block.isInlined();", "+\t\tif (headerLine) maxColumn++;", "-\t\tint firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;", "-\t\tif (headerLine) firstColumn++;", "-\t\tStringBuffer indentationBuffer = null;", "-\t\tif (indentRootTags) {", "-\t\t\tint indentLevel = this.indentationLevel;", "-\t\t\tint indentations = this.numberOfIndentations;", "-\t\t\tthis.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;", "-\t\t\tthis.indentationLevel = this.numberOfIndentations * this.indentationSize;", "-\t\t\tint currentColumn = this.column;", "-\t\t\tthis.column = firstColumn;", "-\t\t\tif (indentParamTag) {", "-\t\t\t\tthis.indentationLevel += this.indentationSize;", "-\t\t\t\tthis.numberOfIndentations++;", "-\t\t\t}", "-\t\t\tprintIndentationIfNecessary(indentationBuffer = new StringBuffer());", "-\t\t\tfirstColumn = this.indentationLevel + 1;", "-\t\t\tthis.column = currentColumn;", "-\t\t\tthis.indentationLevel = indentLevel;", "-\t\t\tthis.numberOfIndentations = indentations;", "-\t\t}", "-", "-\t\t// Scan the text token per token to compact it and size it the max line length", "-\t\tint maxColumn = this.formatter.preferences.comment_line_length + 1;", "+\t\tthis.scanner.resetTo(block.tagEnd+1, reference.sourceEnd);", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tboolean needFormat = false;", "-\t\tthis.scanner.resetTo(reference.sourceStart, reference.sourceEnd);", "+\t\tint spacePosition = -1;", "+\t\tString newLineString = null;", "+\t\tStringBuffer newLineBuffer = null;", "+\t\tint firstColumn = -1;", "+\t    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;", "-\t\t\t\t\t\tbuffer.append(tokensBuffer);", "-\t\t\t\t\t\tthis.column += tokensBuffer.length();", "-\t\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t\t\tif (CharOperation.indexOf('\\n', this.scanner.source, this.scanner.startPosition, this.scanner.getCurrentTokenEndPosition()) >= 0) {", "-\t\t\t\t\t\t\t// consume line break", "-\t\t\t\t\t\t\tloop: while (true) {", "-\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "-\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\t\t\t\tpreviousToken = token; // will not insert space", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tif (previousToken != -1 || tokenLength > 1 || this.scanner.currentCharacter != ' ') needFormat = true;", "+\t\t\t\t\t\tif (previousToken == -1) { // space before reference", "+\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\tthis.column++;", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tif (previousToken == TerminalTokens.TokenNameCOMMA) { // space between method arguments", "+\t\t\t\t\t\t\tspacePosition = buffer.length();", "+\t\t\t\t\t\t\tbuffer.append(' ');", "+\t\t\t\t\t\t\tthis.column++; // space before reference", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tpreviousToken = token;", "-\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (!inlined && spacePosition > 0 && (this.column+tokenLength) > maxColumn) {", "+\t\t\t\t\t\t\t// not enough space on the line", "+\t\t\t\t\t\t\tthis.lastNumberOfNewLines++;", "+\t\t\t\t\t\t\tthis.line++;", "+\t\t\t\t\t\t\tif (newLineString == null) {", "+\t\t\t\t\t\t\t\tnewLineBuffer = new StringBuffer(this.lineSeparator);", "+\t\t\t\t\t\t    \tthis.column = 1;", "+\t\t\t\t\t\t    \tprintIndentationIfNecessary(newLineBuffer);", "+\t\t\t\t\t    \t\tnewLineBuffer.append(BLOCK_LINE_PREFIX);", "+\t\t\t\t\t    \t\tthis.column += BLOCK_LINE_PREFIX_LENGTH;", "+\t\t\t\t\t\t\t\tif (this.commentIndentation != null) {", "+\t\t\t\t\t\t\t    \tnewLineBuffer.append(this.commentIndentation);", "+\t\t\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "+\t\t\t\t\t\t    \t}", "+\t\t\t\t\t\t    \tnewLineString = newLineBuffer.substring(0, newLineBuffer.length()-1); // remove last space as buffer will be inserted before a space", "+\t\t\t\t\t\t    \tfirstColumn = this.column;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthis.column = firstColumn;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.column = firstColumn + buffer.length() - spacePosition - 1;", "+\t\t\t\t\t\t\tbuffer.insert(spacePosition, newLineString);", "+\t\t\t\t\t\t\tif (headerLine) {", "+\t\t\t\t\t\t\t\theaderLine = false;", "+\t\t\t\t\t\t\t\tmaxColumn--;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);", "+\t\t\t    \t\tthis.column += tokenLength;", "+\t\t\t    \t\tbreak;", "+\t\t\t\tpreviousToken = token;", "-\t\t\t\tcontinue;", "+\t\t\t\t// does not happen as syntax is correct", "-\t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "-    \t\tint tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;", "-    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "-    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || previousToken == -1;", "-    \t\tif (insertSpace) lastColumn++;", "-    \t\tif (headerLine) {", "-    \t\t\t// special case when text is on the same line of the javadoc's header", "-    \t\t\tif (lastColumn > maxColumn)  {", "-    \t\t\t\tlastColumn--; // new line gives an extra character", "-    \t\t\t}", "-    \t\t}", "-\t\t\tif (lastColumn > maxColumn) {", "-\t\t    \tString tokensString = tokensBuffer.toString().trim();", "-\t\t    \tint indentLength = indentationBuffer==null ? 0 : indentationBuffer.length();", "-\t\t\t\tif ((firstColumn-1+indentLength+tokensString.length()+tokenLength) > maxColumn) {", "-\t\t\t\t\t// there won't be enough room even if we break the line before the buffered tokens", "-\t\t\t\t\t// So add the buffered tokens now", "-\t\t\t\t\tif (buffer.length() == 0) {", "-\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t\t\tthis.column++;", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.append(tokensString);", "-\t\t\t\t\tthis.column += tokensString.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\t}", "-\t\t\t\t// not enough space on the line", "-\t\t\t\tthis.lastNumberOfNewLines++;", "-\t\t\t\tthis.line++;", "-\t\t    \tbuffer.append(this.lineSeparator);", "-\t\t    \tthis.column = 1;", "-\t\t    \tprintIndentationIfNecessary(buffer);", "-\t    \t\tbuffer.append(BLOCK_LINE_PREFIX);", "-\t\t    \tthis.column = headerLine ? firstColumn-1 : firstColumn;", "-\t\t    \tif (indentationBuffer != null) {", "-\t\t    \t\tbuffer.append(indentationBuffer);", "-\t\t    \t}", "-\t\t    \tif (tokensBuffer.length() > 0) {", "-\t\t\t\t\tbuffer.append(tokensString);", "-\t\t\t\t\tthis.column += tokensString.length();", "-\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t    \t}", "-\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\tthis.column += tokenLength;", "-\t\t\t\tif (headerLine) {", "-\t\t\t\t\tfirstColumn--;", "-\t\t\t\t\theaderLine = false;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// append token to the line", "-\t\t\t\tif (insertSpace) {", "-\t\t\t\t\ttokensBuffer.append(' ');", "-\t\t\t\t}", "-\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t}", "-\t\t\tpreviousToken = token;", "-\t\tif (tokensBuffer.length() > 0) {", "-\t\t\tbuffer.append(tokensBuffer);", "-\t\t\tthis.column += tokensBuffer.length();", "+\t\tif (needFormat) {", "+\t\t    addReplaceEdit(block.tagEnd+1, reference.sourceEnd, buffer.toString());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f50b579593baa6c2e49620caba7817d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "c4891fe70e58ba287a7bbc2f099afcf753974e95", "commitAfterChange": "f50252d848b2855a0e3b480a92607978678762ce", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["+\t\tchar[] tagName = this.scanner.getCurrentIdentifierSource();", "-\t\tchar pc = peekChar();", "-\t\tboolean validTag = false;", "-\t\tswitch (token) {", "-\t\t\tcase TerminalTokens.TokenNameIdentifier:", "-\t\t\tcase TerminalTokens.TokenNamereturn:", "-\t\t\tcase TerminalTokens.TokenNamethrows:", "-\t\t\tcase TerminalTokens.TokenNameabstract:", "-\t\t\tcase TerminalTokens.TokenNameassert:", "-\t\t\tcase TerminalTokens.TokenNameboolean:", "-\t\t\tcase TerminalTokens.TokenNamebreak:", "-\t\t\tcase TerminalTokens.TokenNamebyte:", "-\t\t\tcase TerminalTokens.TokenNamecase:", "-\t\t\tcase TerminalTokens.TokenNamecatch:", "-\t\t\tcase TerminalTokens.TokenNamechar:", "-\t\t\tcase TerminalTokens.TokenNameclass:", "-\t\t\tcase TerminalTokens.TokenNamecontinue:", "-\t\t\tcase TerminalTokens.TokenNamedefault:", "-\t\t\tcase TerminalTokens.TokenNamedo:", "-\t\t\tcase TerminalTokens.TokenNamedouble:", "-\t\t\tcase TerminalTokens.TokenNameelse:", "-\t\t\tcase TerminalTokens.TokenNameextends:", "-\t\t\tcase TerminalTokens.TokenNamefalse:", "-\t\t\tcase TerminalTokens.TokenNamefinal:", "-\t\t\tcase TerminalTokens.TokenNamefinally:", "-\t\t\tcase TerminalTokens.TokenNamefloat:", "-\t\t\tcase TerminalTokens.TokenNamefor:", "-\t\t\tcase TerminalTokens.TokenNameif:", "-\t\t\tcase TerminalTokens.TokenNameimplements:", "-\t\t\tcase TerminalTokens.TokenNameimport:", "-\t\t\tcase TerminalTokens.TokenNameinstanceof:", "-\t\t\tcase TerminalTokens.TokenNameint:", "-\t\t\tcase TerminalTokens.TokenNameinterface:", "-\t\t\tcase TerminalTokens.TokenNamelong:", "-\t\t\tcase TerminalTokens.TokenNamenative:", "-\t\t\tcase TerminalTokens.TokenNamenew:", "-\t\t\tcase TerminalTokens.TokenNamenull:", "-\t\t\tcase TerminalTokens.TokenNamepackage:", "-\t\t\tcase TerminalTokens.TokenNameprivate:", "-\t\t\tcase TerminalTokens.TokenNameprotected:", "-\t\t\tcase TerminalTokens.TokenNamepublic:", "-\t\t\tcase TerminalTokens.TokenNameshort:", "-\t\t\tcase TerminalTokens.TokenNamestatic:", "-\t\t\tcase TerminalTokens.TokenNamestrictfp:", "-\t\t\tcase TerminalTokens.TokenNamesuper:", "-\t\t\tcase TerminalTokens.TokenNameswitch:", "-\t\t\tcase TerminalTokens.TokenNamesynchronized:", "-\t\t\tcase TerminalTokens.TokenNamethis:", "-\t\t\tcase TerminalTokens.TokenNamethrow:", "-\t\t\tcase TerminalTokens.TokenNametransient:", "-\t\t\tcase TerminalTokens.TokenNametrue:", "-\t\t\tcase TerminalTokens.TokenNametry:", "-\t\t\tcase TerminalTokens.TokenNamevoid:", "-\t\t\tcase TerminalTokens.TokenNamevolatile:", "-\t\t\tcase TerminalTokens.TokenNamewhile:", "-\t\t\t\tvalidTag= true;", "-\t\t}", "-\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "-\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "-\t\t\tswitch (pc) {", "-\t\t\t\tcase '}':", "-\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "-\t\t\t\t\tbreak tagNameToken;", "-\t\t\t\tcase '!':", "-\t\t\t\tcase '#':", "-\t\t\t\tcase '%':", "-\t\t\t\tcase '&':", "-\t\t\t\tcase '\\'':", "-\t\t\t\tcase '\"':", "-\t\t\t\tcase ':':", "-\t\t\t\tcase '<':", "-\t\t\t\tcase '>':", "-\t\t\t\t\tvalidTag = false;", "-\t\t\t\t\t// fall thru next case to read character and resynch scanner", "-\t\t\t\tcase '-': // allowed in tag names as this character is often used in doclets (bug 68087)", "-\t\t\t\t\treadChar();", "-\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\tthis.scanner.currentPosition = this.index;", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault:", "-\t\t\t\t\tif (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;", "-\t\t\t\t\ttoken = readTokenAndConsume();", "-\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\tbreak;", "+\t\tif (this.scanner.currentCharacter != ' ' && !Character.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\tboolean validTag = true;", "+\t\t\ttagNameToken: while (token != TerminalTokens.TokenNameEOF && this.index < this.scanner.eofPosition) {", "+\t\t\t\tint length = tagName.length;", "+\t\t\t\t// !, \", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names", "+\t\t\t\tswitch (this.scanner.currentCharacter) {", "+\t\t\t\t\tcase '}':", "+\t\t\t\t\tcase '*': // break for '*' as this is perhaps the end of comment (bug 65288)", "+\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\tcase '!':", "+\t\t\t\t\tcase '#':", "+\t\t\t\t\tcase '%':", "+\t\t\t\t\tcase '&':", "+\t\t\t\t\tcase '\\'':", "+\t\t\t\t\tcase '\"':", "+\t\t\t\t\tcase ':':", "+\t\t\t\t\tcase '<':", "+\t\t\t\t\tcase '>':", "+\t\t\t\t\tcase '@':", "+\t\t\t\t\t\tvalidTag = false;", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tthis.index = this.scanner.currentPosition;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase '-': // allowed in tag names as this character is often used in doclets (bug 68087)", "+\t\t\t\t\t\tSystem.arraycopy(tagName, 0, tagName = new char[length+1], 0, length);", "+\t\t\t\t\t\ttagName[length] = this.scanner.currentCharacter;", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tthis.index = this.scanner.currentPosition;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (this.scanner.currentCharacter == ' ' || Character.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\ttoken = readTokenAndConsume();", "+\t\t\t\t\t\tchar[] ident = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\tSystem.arraycopy(tagName, 0, tagName = new char[length+ident.length], 0, length);", "+\t\t\t\t\t\tSystem.arraycopy(ident, 0, tagName, length, ident.length);", "+\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\tthis.scanner.getNextChar();", "-\t\t\tpc = peekChar();", "+\t\t\tif (!validTag) {", "+\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "-\t\tif (!validTag) {", "-\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "-\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\treturn false;", "-\t\t}", "-\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\tint length = tagName.length;", "-", "+\t", "-\t\tchar firstChar = this.source[this.tagSourceStart];", "-\t\t\t\tswitch (firstChar) {", "+\t\t\t\tswitch (tagName[0]) {", "-\t\t\t\t\t\tif (length == TAG_CATEGORY_LENGTH && CharOperation.equals(TAG_CATEGORY, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_CATEGORY_LENGTH && CharOperation.equals(TAG_CATEGORY, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_DEPRECATED_LENGTH && CharOperation.equals(TAG_DEPRECATED, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_DEPRECATED_LENGTH && CharOperation.equals(TAG_DEPRECATED, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_EXCEPTION_LENGTH && CharOperation.equals(TAG_EXCEPTION, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_EXCEPTION_LENGTH && CharOperation.equals(TAG_EXCEPTION, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_INHERITDOC_LENGTH && CharOperation.equals(TAG_INHERITDOC, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_INHERITDOC_LENGTH && CharOperation.equals(TAG_INHERITDOC, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_LINK_LENGTH && CharOperation.equals(TAG_LINK, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_LINK_LENGTH && CharOperation.equals(TAG_LINK, tagName)) {", "-\t\t\t\t\t\t} else if (length == TAG_LINKPLAIN_LENGTH && CharOperation.equals(TAG_LINKPLAIN, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\t} else if (length == TAG_LINKPLAIN_LENGTH && CharOperation.equals(TAG_LINKPLAIN, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_PARAM_LENGTH && CharOperation.equals(TAG_PARAM, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (length == TAG_PARAM_LENGTH && CharOperation.equals(TAG_PARAM, tagName)) {", "-\t\t\t\t\t\tif (length == TAG_SEE_LENGTH && this.source[this.tagSourceStart+1] == TAG_SEE[1] &&  this.source[this.tagSourceEnd] == TAG_SEE[2]) {", "+\t\t\t\t\t\tif (length == TAG_SEE_LENGTH && CharOperation.equals(TAG_SEE, tagName)) {", "-\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && length == TAG_VALUE_LENGTH && CharOperation.equals(TAG_VALUE, this.source, this.tagSourceStart, this.tagSourceEnd+1)) {", "+\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && length == TAG_VALUE_LENGTH && CharOperation.equals(TAG_VALUE, tagName)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "628a9bdb6df3795f05ea612b580affc8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 5, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod)", "diff": ["-}", "-void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t// methods includes the inherited methods that the currentMethod must comply with", "-\t// likely only 1 but could be more if mutiple declared supertypes define the method (1 superclass & 1 to many declared interfaces)", "-\tnextMethod : for (int i = length; --i >= 0;) {", "-\t\tMethodBinding inheritedMethod = methods[i];", "-\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\t// curentMethod is always resolved as its defined by the source type BUT the inheritedMethod may not be", "-\t\t// so now with generics, the inheritedMethod should be resolved since we don't want to waste time dealing", "-\t\t// with Unresolved types over & over", "-\t\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "-\t\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "-", "-\t\tif (checkForNameClash(currentMethod, inheritedMethod)) {", "-\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\tcontinue nextMethod;", "-\t\t}", "-", "-\t\tif (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {", "-\t\t\tif ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)", "-\t\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccImplementing;", "-\t\t} else {", "-\t\t\tcurrentMethod.modifiers |= CompilerModifiers.AccOverriding;", "-\t\t}", "-", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType();", "-\t\tif (currentMethod.returnType != inheritedMethod.returnType) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t}", "-", "-\t\t\tTypeBinding inheritedReturnType = inheritedMethod.returnType.leafComponentType();", "-\t\t\tTypeBinding returnType = currentMethod.returnType.leafComponentType();", "-\t\t\tif (inheritedReturnType.isRawType()) {", "-\t\t\t\tif (returnType.isParameterizedType() && hasBoundedParameters((ParameterizedTypeBinding) returnType)) {", "-\t\t\t\t\tthis.problemReporter(currentMethod).methodNameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedReturnType.isParameterizedType()) {", "-\t\t\t\tif (!returnType.isParameterizedType()) ", "-\t\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod, ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t} else if (inheritedReturnType.isTypeVariable()) {", "-\t\t\t\tthis.problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, inheritedMethod,  ((MethodDeclaration)currentMethod.sourceMethod()).returnType);", "-\t\t\t}", "-\t\t\taddBridgeMethod = true;", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!areReturnTypesEqual(original, currentMethod) || !areParametersEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "+}", "+MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {", "+\tif (inheritedMethod == null) return null;", "+", "+\t// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved", "+\t// should we push these tests to where they're needed? returnType.isCompatibleWith && parameter isEquivalentTo ?", "+\tif (currentMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);", "+\tif (inheritedMethod.declaringClass instanceof BinaryTypeBinding)", "+\t\t((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);", "+", "+\tTypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables();", "+\tif (inheritedTypeVariables == NoTypeVariables) return inheritedMethod;", "+\tTypeVariableBinding[] typeVariables = currentMethod == null ? NoTypeVariables : currentMethod.typeVariables;", "+", "+\tint inheritedLength = inheritedTypeVariables.length;", "+\tint length = typeVariables.length;", "+\tTypeBinding[] arguments = new TypeBinding[inheritedLength];", "+\tif (inheritedLength <= length) {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, inheritedLength);", "+\t} else {", "+\t\tSystem.arraycopy(typeVariables, 0, arguments, 0, length);", "+\t\tfor (int i = length; i < inheritedLength; i++)", "+\t\t\targuments[i] = inheritedTypeVariables[i].erasure();", "+\t}", "+\tParameterizedGenericMethodBinding substitute =", "+\t\tnew ParameterizedGenericMethodBinding(inheritedMethod, arguments, this.environment);", "+\tfor (int i = 0; i < inheritedLength; i++)", "+\t    if (!inheritedTypeVariables[i].boundCheck(substitute, arguments[i]))", "+\t    \treturn inheritedMethod; // incompatible due to bound check", "+   return substitute;", "+}"]}], "num": 54438}