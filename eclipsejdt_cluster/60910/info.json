{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bdb15c77b041d9ff2b1f2a312fc5cfc6", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7289468e4135f768aa2f02c70fd2b567", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "d7a2176a086ffe5cc9f82c35abb4d496e220561a", "commitAfterChange": "583238ffeb9a97546ad084c6e7cea427e3752805", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "-\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\tif (receiverErasure.findSuperTypeOriginatingFrom(fieldBinding.declaringClass) == null) {", "-\t\t\tthis.actualReceiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t}", "-\t}", "+\t// handle indirect inheritance thru variable secondary bound", "+\t// receiver may receive generic cast, as part of implicit conversion", "+\tTypeBinding oldReceiverType = this.actualReceiverType;", "+\tthis.actualReceiverType = this.actualReceiverType.getErasureCompatibleType(fieldBinding.declaringClass);", "+\tif (this.actualReceiverType != oldReceiverType && this.receiver.postConversionType(scope) != this.actualReceiverType) { // record need for explicit cast at codegen since receiver could not handle it", "+\t\tthis.bits |= NeedReceiverGenericCast;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d7595c91c4d8d8596e449efe4e978a0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "d7a2176a086ffe5cc9f82c35abb4d496e220561a", "commitAfterChange": "583238ffeb9a97546ad084c6e7cea427e3752805", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t// compute generic cast if necessary", "-\t\t\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "-\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\t\tif (receiverErasure.findSuperTypeOriginatingFrom(this.binding.declaringClass) == null) {", "-\t\t\t\t\tthis.actualReceiverType = this.binding.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\t// handle indirect inheritance thru variable secondary bound", "+\t\t\t// receiver may receive generic cast, as part of implicit conversion", "+\t\t\tTypeBinding oldReceiverType = this.actualReceiverType;", "+\t\t\tthis.actualReceiverType = this.actualReceiverType.getErasureCompatibleType(this.binding.declaringClass);", "+\t\t\tif (this.actualReceiverType != oldReceiverType && this.receiver.postConversionType(scope) != this.actualReceiverType) { // record need for explicit cast at codegen since receiver could not handle it", "+\t\t\t\tthis.bits |= NeedReceiverGenericCast;", "+\t\t\t}\t\t\t"]}], "num": 60910}