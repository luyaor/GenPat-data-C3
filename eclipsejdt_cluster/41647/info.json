{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1c90ba7a695188015ab213e3a66c870c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "86de0ca77bedcde801c356f34ebca617", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "1a542c460a449efbae14d1057ba233825602248d", "commitAfterChange": "1ddc6abfe5d6cd8ad8c71d5100cfa53f4e84487a", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \t\t \tprivate void analyzeShape()", "signatureAfterChange": " \t\t \tprivate void analyzeShape()", "diff": ["-\tprivate void analyzeShape() { // simple minded analysis for code assist.", "+\tprivate void analyzeShape() { // Simple minded analysis for code assist & potential compatibility.", "-\t\t\tthis.voidCompatible = /* ((Expression) this.body).statementExpression(); */ true;", "+\t\t\tthis.voidCompatible = this.assistNode ? true : ((Expression) this.body).statementExpression();", "-\t\t\t// We need to be a bit tolerant/fuzzy here: the code is being written \"just now\", if we are too pedantic, selection/completion will break;", "-\t\t\tthis.voidCompatible = true;", "-\t\t\tthis.valueCompatible = true;", "+\t\t\t// For code assist, we need to be a bit tolerant/fuzzy here: the code is being written \"just now\", if we are too pedantic, selection/completion will break;", "+\t\t\tif (this.assistNode) {", "+\t\t\t\tthis.voidCompatible = true;", "+\t\t\t\tthis.valueCompatible = true;", "+\t\t\t}", "+\t\t\tBlock block = (Block) this.body;", "+\t\t\t// support the idiom that { throw new Exception(); } is value compatible.", "+\t\t\tif (block.statements != null && block.statements.length == 1 && block.statements[0] instanceof ThrowStatement)", "+\t\t\t\tthis.valueCompatible = true;", "-\t\tthis.shapeAnalysisComplete = true;", "+\t\tif (this.assistNode)", "+\t\t\tthis.shapeAnalysisComplete = true;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d93a716f795f332e0d3cc17ed6b55f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \t\t \tprivate void analyzeShape()", "signatureAfterChange": " \t\t \tprivate void analyzeShape()", "diff": ["+\t\t    \t\tLambdaExpression.this.returnsValue = true;", "+\t\t    \t\tLambdaExpression.this.returnsVoid = true;", "-\t\t\tthis.valueCompatible = true;", "+\t\t\tthis.valueCompatible = true; // expression could be of type void - we can't determine that as we are working with unresolved expressions, for potential compatibility it is OK.", "-\t\t\tBlock block = (Block) this.body;", "-\t\t\t// support the idiom that { throw new Exception(); } is value compatible.", "-\t\t\tif (block.statements != null && block.statements.length == 1 && block.statements[0] instanceof ThrowStatement)", "-\t\t\t\tthis.valueCompatible = true;", "+\t\t\tif (!this.returnsValue && !this.returnsVoid)", "+\t\t\t\tthis.valueCompatible = this.body.doesNotCompleteNormally();"]}], "num": 41647}