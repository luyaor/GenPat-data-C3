{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b7d30fd221a00dbc2e690849e5d12270", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d282bf56c6485610b2285cfd44bba25", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (anonymousType == null && enclosingInstance == null) {", "+\t\tif (this.anonymousType == null && this.enclosingInstance == null) {", "-\t\t// ==> by construction, when there is an enclosing instance the typename may NOT be qualified", "-\t\t// ==> therefore by construction the type is always a SingleTypeReferenceType instead of being either ", "-\t\t// sometime a SingleTypeReference and sometime a QualifedTypeReference", "-", "+\t\t", "+\t\t\t} else if (type instanceof QualifiedTypeReference) {", "+\t\t\t\tscope.problemReporter().illegalUsageOfQualifiedTypeReference((QualifiedTypeReference)type);", "+\t\t\t\thasError = true;", "-\t\t\t\t\t\tCastExpression.checkNeedForEnclosingInstanceCast(scope, enclosingInstance, enclosingInstanceType, receiverType);", "+\t\t\t\t\tCastExpression.checkNeedForEnclosingInstanceCast(scope, enclosingInstance, enclosingInstanceType, receiverType);", "-", "+\t\t// resolve type arguments (for generic constructor call)", "+\t\tif (this.typeArguments != null) {", "+\t\t\tint length = this.typeArguments.length;", "+\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tTypeBinding argType = this.typeArguments[i].resolveType(scope);", "+\t\t\t\tif (argType == null) return null; // error already reported", "+\t\t\t\tthis.genericTypeArguments[i] = argType;", "+\t\t\t}", "+\t\t}", "+\t\t", "-\t\t", "+\t\tif ((receiverType.tagBits & TagBits.HasWildcard) != 0) {", "+\t\t    scope.problemReporter().cannotInstantiateWithWildcards(type, (ParameterizedTypeBinding)receiverType);", "+\t\t    return this.resolvedType = receiverType;", "+\t\t}\t\t\t\t", "-\t\t\t\tif (arguments != null) {", "-\t\t\t\t\tfor (int i = 0; i < arguments.length; i++) {", "-\t\t\t\t\t\targuments[i].implicitWidening(this.binding.parameters[i], argumentTypes[i]);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (argsContainCast) {", "-\t\t\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tif (this.arguments != null)", "+\t\t\t\t\tcheckInvocationArguments(scope, null, allocationType, binding, this.arguments, argumentTypes, argsContainCast, this);", "-\t\t\tscope.problemReporter().typeMismatchErrorActualTypeExpectedType(", "-\t\t\t\tthis.enclosingInstance,", "-\t\t\t\tenclosingInstanceType,", "-\t\t\t\texpectedType);", "+\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance);", "+\t\t// TODO (philippe) no deprecation check?", "-\t\t\t\tscope.problemReporter().typeMismatchErrorActualTypeExpectedType(", "-\t\t\t\t\tenclosingInstance,", "-\t\t\t\t\tenclosingInstanceType,", "-\t\t\t\t\tinheritedBinding.declaringClass.enclosingType());", "+\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, inheritedBinding.declaringClass.enclosingType(), enclosingInstance);", "-", "-\t\t// this promotion has to be done somewhere: here or inside the constructor of the", "-\t\t// anonymous class. We do it here while the constructor of the inner is then easier.", "-\t\tif (arguments != null) {", "-\t\t\tfor (int i = 0; i < arguments.length; i++) {", "-\t\t\t\targuments[i].implicitWidening(inheritedBinding.parameters[i], argumentTypes[i]);", "-\t\t\t}", "-\t\t\tif (argsContainCast) {", "-\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, this);", "-\t\t\t}", "-\t\t}", "+\t\tif (this.arguments != null)", "+\t\t\tcheckInvocationArguments(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this);", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae1736aca3e13de360dfa9071db4cb79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tFlowInfo condInfo = flowInfo.copy().unconditionalInits().discardNullRelatedInitializations();", "+\t\tFlowInfo condInfo = flowInfo.nullInfoLessUnconditionalCopy();", "-\t\t\t\t\t\t\tnew LoopingFlowContext(flowContext, this, null, null, scope)),", "+\t\t\t\t\t\t\tnew LoopingFlowContext(flowContext, flowInfo, this, null, ", "+\t\t\t\t\t\t\t\tnull, scope)),", "-\t\tFlowInfo actionInfo;", "+\t\tUnconditionalFlowInfo actionInfo;", "-\t\t\t\tcondLoopContext.complainOnDeferredChecks(scope, condInfo);", "+\t\t\t\tcondLoopContext.complainOnDeferredFinalChecks(scope, condInfo);", "+\t\t\t\tif (condLoopContext != null) {", "+\t\t\t\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope,", "+\t\t\t\t\t\tcondInfo);", "+\t\t\t\t}", "-\t\t\t\tactionInfo = condInfo.initsWhenTrue().copy().unconditionalInits().discardNullRelatedInitializations();", "+\t\t\t\tactionInfo = condInfo.initsWhenTrue().unconditionalCopy();", "-\t\t\t\t\tnew LoopingFlowContext(flowContext, this, breakLabel, continueLabel, scope);", "+\t\t\t\t\tnew LoopingFlowContext(flowContext, flowInfo, this, ", "+\t\t\t\t\t\tbreakLabel, continueLabel, scope);", "-\t\t} else {", "+\t\t} ", "+\t\telse {", "-\t\t\t\tnew LoopingFlowContext(flowContext, this, breakLabel, continueLabel, scope);", "+\t\t\t\tnew LoopingFlowContext(flowContext, flowInfo, this, breakLabel, ", "+\t\t\t\t\tcontinueLabel, scope);", "-\t\t\t\t\tactionInfo = initsWhenTrue.copy().unconditionalInits().discardNullRelatedInitializations();", "+\t\t\t\t\tactionInfo = initsWhenTrue.unconditionalCopy();", "-\t\t\t\tactionInfo = action.analyseCode(scope, loopingContext, actionInfo);", "+\t\t\t\tactionInfo = action.analyseCode(scope, loopingContext, actionInfo).", "+\t\t\t\t\tunconditionalInits();", "-\t\t\tif (!actionInfo.isReachable() && !loopingContext.initsOnContinue.isReachable()) {", "+\t\t\tif ((actionInfo.tagBits & ", "+\t\t\t\t\tloopingContext.initsOnContinue.tagBits &", "+\t\t\t\t\tFlowInfo.UNREACHABLE) != 0) {", "-\t\t\t} else {", "-\t\t\t\tif (condLoopContext != null)", "-\t\t\t\t\tcondLoopContext.complainOnDeferredChecks(scope, condInfo);", "-\t\t\t\tactionInfo = actionInfo.mergedWith(loopingContext.initsOnContinue.unconditionalInits());", "-\t\t\t\tloopingContext.complainOnDeferredChecks(scope, actionInfo);", "+\t\t\t} ", "+\t\t\telse {", "+\t\t\t\tif (condLoopContext != null) {", "+\t\t\t\t\tcondLoopContext.complainOnDeferredFinalChecks(scope, ", "+\t\t\t\t\t\t\tcondInfo);", "+\t\t\t\t}", "+\t\t\t\tactionInfo = actionInfo.mergedWith(loopingContext.initsOnContinue);", "+\t\t\t\tloopingContext.complainOnDeferredFinalChecks(scope, ", "+\t\t\t\t\t\tactionInfo);", "-\t\tFlowInfo exitBranch = condInfo.initsWhenFalse();", "-\t\texitBranch.addInitializationsFrom(flowInfo); // recover null inits from before condition analysis", "+\t\tFlowInfo exitBranch = flowInfo.copy();", "+\t\t// recover null inits from before condition analysis", "+\t\tLoopingFlowContext incrementContext = null;", "-\t\t\t\tLoopingFlowContext loopContext =", "-\t\t\t\t\tnew LoopingFlowContext(flowContext, this, null, null, scope);", "+\t\t\t\tincrementContext =", "+\t\t\t\t\tnew LoopingFlowContext(flowContext, flowInfo, this, null, ", "+\t\t\t\t\t\tnull, scope);", "+\t\t\t\tFlowInfo incrementInfo = actionInfo;", "-\t\t\t\t\tactionInfo = increments[i].analyseCode(scope, loopContext, actionInfo);", "+\t\t\t\t\tincrementInfo = increments[i].", "+\t\t\t\t\t\tanalyseCode(scope, incrementContext, incrementInfo);", "-\t\t\t\tloopContext.complainOnDeferredChecks(scope, actionInfo);", "+\t\t\t\tincrementContext.complainOnDeferredFinalChecks(scope,", "+\t\t\t\t\t\tactionInfo = incrementInfo.unconditionalInits());", "-\t\t\texitBranch.addPotentialInitializationsFrom(actionInfo.unconditionalInits());", "+\t\t\texitBranch.addPotentialInitializationsFrom(actionInfo).", "+\t\t\t\taddInitializationsFrom(condInfo.initsWhenFalse());", "+\t\t}", "+\t\telse {", "+\t\t\texitBranch.addInitializationsFrom(condInfo.initsWhenFalse());", "+\t\t}", "+\t\t// nulls checks", "+\t\tif (condLoopContext != null) {", "+\t\t\tcondLoopContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tactionInfo);", "+\t\t}", "+\t\tloopingContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\tactionInfo);", "+\t\tif (incrementContext != null) {", "+\t\t\tincrementContext.complainOnDeferredNullChecks(currentScope, ", "+\t\t\t\tactionInfo);"]}], "num": 31913}