{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7db8cd0cef1989d2660d9c4126bf4394", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79c22ef7f21f4f8720ec71218da7fc37", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "609e8a78b8310f5eb13403d8e1c67e488fec5ba8", "commitAfterChange": "706d05b886f888f588421e058e652ee36abfc780", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "diff": ["-\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=322001. We used to unconditionally check here", "-\t\t   for name clashes between the overridden inherited method and all other \"non-matching\"", "-\t\t   inherited methods with the same method selector here. ", "-\t\t   ", "-\t\t   This makes no sense when the current type is concrete as the overridden method has been", "-\t\t   effectively replaced and is hidden in the current class and cannot contribute to a clash.", "-\t\t   The overriding method or the bridge may collide with an inherited method, but that is being", "-\t\t   checked elsewhere. ", "-\t\t   ", "-\t\t   As a matter of fact, this is true even for abstract types, but we do retain the name clash", "-\t\t   check for abstract types here for compatibility with javac.", "-\t\t   ", "-\t\t   See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=293615 for a very similar issue.", "-\t\t*/", "-\t\tif (this.type.isAbstract()) { ", "-\t\t\tfor (int i = 0, l = allInheritedMethods == null ? 0 : allInheritedMethods.length; i < l; i++) {", "-\t\t\t\tif (allInheritedMethods[i] != null && detectInheritedNameClash(originalInherited, allInheritedMethods[i].original()))", "-\t\t\t\t\treturn;", "-\t\t\t}", "+\t\tfor (int i = 0, l = allInheritedMethods == null ? 0 : allInheritedMethods.length; i < l; i++) {", "+\t\t\tif (allInheritedMethods[i] != null && detectInheritedNameClash(originalInherited, allInheritedMethods[i].original()))", "+\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c935e6a771fedac9e8008f9f83010e84", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "2a23c62d5a3b74783613a638cca640e487db040a", "commitAfterChange": "79c4ba61903262b42e2a1f500afb283891f6e429", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "diff": ["-\t\tfor (int i = 0, l = allInheritedMethods == null ? 0 : allInheritedMethods.length; i < l; i++) {", "-\t\t\tif (allInheritedMethods[i] != null && detectInheritedNameClash(originalInherited, allInheritedMethods[i].original()))", "-\t\t\t\treturn;", "+\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=322001. We used to unconditionally check here", "+\t\t   for name clashes between the overridden inherited method and all other \"non-matching\"", "+\t\t   inherited methods with the same method selector here. ", "+\t\t   ", "+\t\t   This makes no sense when the current type is concrete as the overridden method has been", "+\t\t   effectively replaced and is hidden in the current class and cannot contribute to a clash.", "+\t\t   The overriding method or the bridge may collide with an inherited method, but that is being", "+\t\t   checked elsewhere. ", "+\t\t   ", "+\t\t   As a matter of fact, this is true even for abstract types, but we do retain the name clash", "+\t\t   check for abstract types here for compatibility with javac.", "+\t\t   ", "+\t\t   See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=293615 for a very similar issue.", "+\t\t*/", "+\t\tif (this.type.isAbstract()) { ", "+\t\t\tfor (int i = 0, l = allInheritedMethods == null ? 0 : allInheritedMethods.length; i < l; i++) {", "+\t\t\t\tif (allInheritedMethods[i] != null && detectInheritedNameClash(originalInherited, allInheritedMethods[i].original()))", "+\t\t\t\t\treturn;", "+\t\t\t}"]}], "num": 19567}