{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba3c07fc068b1f172ca1bb074d5e70a3", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a85396a15b0d50d34ba831d92669e1b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "7f7148c3b7ae3451b296c63ec6faa42df92b750d", "commitAfterChange": "e562014fc7f6276a90541f6d031954413a725f91", "methodNumberBeforeChange": 59, "methodNumberAfterChange": 59, "signatureBeforeChange": " protected void reportAccurateTypeReference(SearchMatch match, ASTNode typeRef, char[] name) throws CoreException", "signatureAfterChange": " protected void reportAccurateTypeReference(SearchMatch match, ASTNode typeRef, char[] name) throws CoreException", "diff": ["-\t", "-\t// Compute source positions of the qualified reference ", "+", "-\tScanner scanner = this.parser.scanner;", "-\tscanner.setSource(this.currentPossibleMatch.getContents());", "-\tscanner.resetTo(sourceStart, sourceEnd);", "+\t", "+\t// Compute source positions of the qualified reference ", "+\tif (name != null) {", "+\t\tScanner scanner = this.parser.scanner;", "+\t\tscanner.setSource(this.currentPossibleMatch.getContents());", "+\t\tscanner.resetTo(sourceStart, sourceEnd);", "-\tint token = -1;", "-\tint currentPosition;", "-\tdo {", "-\t\tcurrentPosition = scanner.currentPosition;", "-\t\ttry {", "-\t\t\ttoken = scanner.getNextToken();", "-\t\t} catch (InvalidInputException e) {", "-\t\t\t// ignore", "-\t\t}", "-\t\tif (token == TerminalTokens.TokenNameIdentifier && this.pattern.matchesName(name, scanner.getCurrentTokenSource())) {", "-\t\t\tint length = scanner.currentPosition-currentPosition;", "-\t\t\tmatch.setOffset(currentPosition);", "-\t\t\tmatch.setLength(length);", "-\t\t\treport(match);", "-\t\t\treturn;", "-\t\t}", "-\t} while (token != TerminalTokens.TokenNameEOF);", "+\t\tint token = -1;", "+\t\tint currentPosition;", "+\t\tdo {", "+\t\t\tcurrentPosition = scanner.currentPosition;", "+\t\t\ttry {", "+\t\t\t\ttoken = scanner.getNextToken();", "+\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t// ignore", "+\t\t\t}", "+\t\t\tif (token == TerminalTokens.TokenNameIdentifier && this.pattern.matchesName(name, scanner.getCurrentTokenSource())) {", "+\t\t\t\tint length = scanner.currentPosition-currentPosition;", "+\t\t\t\tmatch.setOffset(currentPosition);", "+\t\t\t\tmatch.setLength(length);", "+\t\t\t\treport(match);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t} while (token != TerminalTokens.TokenNameEOF);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed9a3501d982fe23acebf181bdaa60e3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "09c9d84aad79985551ce918cbcc33cdee71ab4e2", "commitAfterChange": "0f631524aef87d3ee7b5140c20a85cb2799ddd71", "methodNumberBeforeChange": 368, "methodNumberAfterChange": 368, "signatureBeforeChange": " private void jumpOverType()", "signatureAfterChange": " private void jumpOverType()", "diff": ["+\t\t", "+\t\tif (DEBUG_AUTOMATON) {", "+\t\t\tSystem.out.println(\"Jump         -\"); //$NON-NLS-1$", "+\t\t}", "+\t\t", "-\t\t\tpushOnAstStack(typeDeclaration);", "-\t\t\tif(this.astLengthPtr > 0) {", "-\t\t\t\tconcatNodeLists();", "-\t\t\t}", "-\t\t\t", "-\t\t\tif(this.currentElement != null) {", "-\t\t\t\tthis.currentElement = this.currentElement.add(typeDeclaration, 0);", "-\t\t\t}", "-\t\t\t", "-\t\t\ttry {", "-\t\t\t\tthis.currentToken = this.scanner.getNextToken();", "-\t\t\t} catch(InvalidInputException e){", "-\t\t\t\tif (!this.hasReportedError){", "-\t\t\t\t\tthis.problemReporter().scannerError(this, e.getMessage());", "-\t\t\t\t\tthis.hasReportedError = true;", "-\t\t\t\t}", "-\t\t\t\tthis.lastCheckPoint = this.scanner.currentPosition;", "-\t\t\t}", "+\t\t\t((RecoveryScanner)this.scanner).setPendingTokens(new int[]{TokenNameSEMICOLON, TokenNamebreak});", "-\t\t\tif(this.astPtr > -1 && this.astStack[this.astPtr] instanceof TypeDeclaration) {", "-\t\t\t\tthis.astStack[astPtr] = typeDeclaration;", "-\t\t\t\tthis.expressionStack[this.expressionPtr] = typeDeclaration.allocation;", "-\t\t\t}", "-\t\t\tthis.currentToken = TokenNameRBRACE;", "+\t\t\t((RecoveryScanner)this.scanner).setPendingTokens(new int[]{TokenNameIdentifier, TokenNameEQUAL, TokenNameIdentifier});", "+\t\t}", "+\t\t", "+\t\tthis.pendingRecoveredType = typeDeclaration;", "+\t\t", "+\t\ttry {", "+\t\t\tthis.currentToken = this.scanner.getNextToken();", "+\t\t} catch(InvalidInputException e){", "+\t\t\t// it's impossible because we added pending tokens before", "-\t\t\t\t\t? nextTypeDeclaration.declarationSourceStart", "-\t\t\t\t\t\t\t: nextTypeDeclaration.bodyStart;", "+\t\t\t\t\t? nextTypeDeclaration.declarationSourceStart ", "+\t\t\t\t\t\t\t: nextTypeDeclaration.allocation.sourceStart;"]}], "num": 1560}