{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "366ee44cb0ade80f75730794622c116f", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bcc3d0496ab4f9074f4703eb7b3bc85b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "330aeaad59d1633d10c0cd3a9ee9ac57073b385f", "commitAfterChange": "960ce528d76bd309a28ce655fc14cff77629ffa5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean commentParse(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean commentParse()", "diff": ["-\tprotected boolean commentParse(int javadocStart, int javadocEnd) {", "-", "+\tprotected boolean commentParse() {", "+\t\t", "-\t\t\tthis.scanner.resetTo(javadocStart, javadocEnd);", "-\t\t\tthis.endComment = javadocEnd;", "-\t\t\tthis.index = javadocStart;", "-\t\t\treadChar(); // starting '/'", "+\t\t\tthis.linePtr = getLineNumber(this.firstTagPosition);", "+\t\t\tint realStart = this.linePtr==1 ? javadocStart : this.scanner.getLineEnd(this.linePtr-1)+1;", "+\t\t\tif (realStart < javadocStart) realStart = javadocStart;", "+\t\t\tthis.scanner.resetTo(realStart, javadocEnd);", "+\t\t\tthis.index = realStart;", "+\t\t\tif (realStart == javadocStart) {", "+\t\t\t\treadChar(); // starting '/'", "+\t\t\t\treadChar(); // first '*'", "+\t\t\t}", "-\t\t\treadChar(); // first '*'", "-\t\t\tchar nextCharacter= readChar(); // second '*'", "-\t\t\t", "+\t\t\tchar nextCharacter = 0;", "+\t\t\tif (realStart == javadocStart) nextCharacter = readChar(); // second '*'", "+", "-\t\t\tthis.linePtr = getLineNumber(javadocStart);", "-\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.endComment : this.scanner.getLineEnd(this.linePtr);", "+\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.javadocEnd: this.scanner.getLineEnd(this.linePtr) - 1;", "-\t\t\twhile (!abort && this.index < this.endComment) {", "+\t\t\tcharacterLoop: while (!abort && this.index < this.javadocEnd) {", "-\t\t\t\tif (this.index >= this.endComment) {", "+\t\t\t\tif (this.index >= this.javadocEnd) {", "-\t\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) pushText(this.textStart, previousPosition);", "-\t\t\t\t\t\t\t\t\tpushText(this.textStart, this.inlineTagStart);", "+\t\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) pushText(this.textStart, this.inlineTagStart);", "-\t\t\t\t\t\t\t\tpushText(this.textStart, invalidTagLineEnd);", "+\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) pushText(this.textStart, invalidTagLineEnd);", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.endComment);", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.javadocEnd);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (this.kind == COMPIL_PARSER && this.tagValue == TAG_RETURN_VALUE && this.returnStatement != null) {", "+\t\t\t\t\t\t\t\trefreshReturnStatement();", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) pushText(this.textStart, previousPosition);", "+\t\t\t\t\t\tif (this.kind == COMPIL_PARSER && this.tagValue == TAG_RETURN_VALUE && this.returnStatement != null) {", "+\t\t\t\t\t\t\trefreshReturnStatement();", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "-\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\tif (this.kind == COMPIL_PARSER && this.tagValue == TAG_RETURN_VALUE && this.returnStatement != null) {", "+\t\t\t\t\t\t\trefreshReturnStatement();", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "-\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\tif (this.kind == COMPIL_PARSER && this.tagValue == TAG_RETURN_VALUE && this.returnStatement != null) {", "+\t\t\t\t\t\t\trefreshReturnStatement();", "+\t\t\t\t\t\t}", "-\t\t\t\t\tif (this.index >= this.endComment) end = invalidInlineTagLineEnd;", "+\t\t\t\t\tif (this.index >= this.javadocEnd) end = invalidInlineTagLineEnd;", "-\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\tpushText(this.textStart, previousPosition);", "-\t\t\t\t}", "+\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "+\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t}", "-\t\t\t} else if (this.lineStarted && this.textStart < previousPosition) {", "+\t\t\t} else if (this.kind == DOM_PARSER && this.lineStarted && this.textStart < previousPosition) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f87a7675d7ae83e42a13a4d28b83a91e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "da3abb814c31b6e1c2d43312de494af316e19273", "commitAfterChange": "8af0e3d96f10bb27360a77bbd330487cf3fdc8dd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference() throws InvalidInputException", "diff": ["-\tprotected boolean parseReference(boolean plain) throws InvalidInputException {", "-\t\tObject typeRef = null;", "-\t\tObject reference = null;", "-\t\tint previousPosition = -1;", "-\t\tint typeRefStartPosition = -1;", "-\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "-\t\t\tpreviousPosition = this.index;", "-\t\t\tint token = readToken();", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t}", "-\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tif (parseHref()) {", "+\tprotected boolean parseReference() throws InvalidInputException {", "+\t\tint currentPosition = this.scanner.currentPosition;", "+\t\ttry {", "+\t\t\tObject typeRef = null;", "+\t\t\tObject reference = null;", "+\t\t\tint previousPosition = -1;", "+\t\t\tint typeRefStartPosition = -1;", "+\t\t\t", "+\t\t\t// Get reference tokens", "+\t\t\tnextToken : while (this.index < this.scanner.eofPosition) {", "+\t\t\t\tpreviousPosition = this.index;", "+\t\t\t\tint token = readToken();", "+\t\t\t\tswitch (token) {", "+\t\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "-\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "-\t\t\t\t\t\tif (typeRef != null) {", "-\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "-\t\t\t\t\t\t\tpreviousPosition = start;", "-\t\t\t\t\t\t\ttypeRef = null;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "-\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn false;", "-\t\t\t\tcase TerminalTokens.TokenNameERROR :", "-\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\treference = parseMember(typeRef);", "-\t\t\t\t\t\tif (reference != null) {", "-\t\t\t\t\t\t\treturn pushSeeRef(reference, plain);", "+\t\t\t\t\t\tint start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidValueReference(start, getTokenEndPosition());", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak nextToken;", "-\t\t\t\tdefault :", "-\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tif (parseHref()) {", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.tagValue != TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidReference(start, this.lineEnd);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE && this.sourceParser != null) {", "+\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidValueReference(start, getIndexPosition());", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameERROR :", "+\t\t\t\t\t\tif (this.scanner.currentCharacter == '#') { // @see ...#member", "+\t\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t\treference = parseMember(typeRef);", "+\t\t\t\t\t\t\tif (reference != null) {", "+\t\t\t\t\t\t\t\treturn pushSeeRef(reference);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tif (typeRef == null) {", "+\t\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\ttypeRef = parseQualifiedName(true);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Verify that we got a reference", "-\t\tif (reference == null) reference = typeRef;", "-\t\tif (reference == null) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+", "+\t\t\t// Verify that we got a reference", "+\t\t\tif (reference == null) reference = typeRef;", "+\t\t\tif (reference == null) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\t\tif (this.kind == DOM_PARSER) createTag();", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingReference(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Reset position at the end of type reference", "+\t\t\tthis.index = this.lastIdentifierEndPosition+1;", "+\t\t\tthis.scanner.currentPosition = this.index;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingSeeReference(this.tagSourceStart, this.tagSourceEnd);", "-\t\t\treturn false;", "+", "+\t\t\t// In case of @value, we have an invalid reference (only static field refs are valid for this tag)", "+\t\t\tif (this.tagValue == TAG_VALUE_VALUE) {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(typeRefStartPosition, this.lineEnd);", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "+\t\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "+\t\t\tchar ch = peekChar();", "+\t\t\tif (ch == '(') {", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\t// Verify that we get white space after reference", "+\t\t\tif (!verifySpaceOrEndComment()) {", "+\t\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "+\t\t\t\tif (this.source[end]=='\\n') end--;", "+\t\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// Everything is OK, store reference", "+\t\t\treturn pushSeeRef(reference);", "-", "-\t\t// Reset position at the end of type reference", "-\t\tthis.index = this.lastIdentifierEndPosition+1;", "-\t\tthis.scanner.currentPosition = this.index;", "-\t\tthis.currentTokenType = -1;", "-", "-\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "-\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "-\t\tchar ch = peekChar();", "-\t\tif (ch == '(') {", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition+1));", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// Verify that we get white space after reference", "-\t\tif (!verifySpaceOrEndComment()) {", "-\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "-\t\t\tif (this.source[end]=='\\n') end--;", "-\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Everything is OK, store reference", "-\t\treturn pushSeeRef(reference, plain);", "-\t}", "+\t\tcatch (InvalidInputException ex) {", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidReference(currentPosition, getTokenEndPosition());"]}], "num": 51845}