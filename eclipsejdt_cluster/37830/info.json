{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "94c29e3a75476081cf93c75975fa5622", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "690f0126855d2ddddc75b86d818c64e9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "eaf0108cc4594b9874621f7838e6b5fcab99f228", "commitAfterChange": "505b0db16406f11df3227a34e8e784faefbd6e90", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];", "-\tint lastPosition = 0;", "-\tinterfacesToVisit[lastPosition] = type.superInterfaces();", "+\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[3][];", "+\tint lastPosition = -1;", "+\tReferenceBinding[] itsInterfaces = type.superInterfaces();", "+\tif (itsInterfaces != NoSuperInterfaces)", "+\t\tinterfacesToVisit[++lastPosition] = itsInterfaces;", "-\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();", "-\t\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "-\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) { // look at all methods which are NOT private or constructors or default abstract", "+\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) {", "-\t\t\t\t\t\t\tif (areTypesEqual(method.returnType, nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\t\t\t\t&& CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\t\t&& areTypesEqual(method.returnType, nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\tif (!(method.isDefault() && method.declaringClass.fPackage != type.fPackage)) { // ignore methods which have default visibility and are NOT defined in another package", "+\t\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();", "-\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f7e986c931c54ca6c06c31ed0f7c01a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "b418235473d69146fcb35be10bf158bb2b040cf7", "commitAfterChange": "eadf5ba6d44f28f071965cf829d67590b0a71974", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic void resolve(MethodScope initializationScope)", "signatureAfterChange": "  public void resolve(MethodScope initializationScope)", "diff": ["+", "+public void resolve(MethodScope initializationScope) {", "+\t// the two <constant = Constant.NotAConstant> could be regrouped into", "+\t// a single line but it is clearer to have two lines while the reason of their", "+\t// existence is not at all the same. See comment for the second one.", "+", "+\t//--------------------------------------------------------", "+\tif ((this.bits & ASTNode.HasBeenResolved) != 0) return;", "+\tif (this.binding == null || !this.binding.isValidBinding()) return;", "+\t", "+\tthis.bits |= ASTNode.HasBeenResolved;", "+", "+\t// check if field is hiding some variable - issue is that field binding already got inserted in scope", "+\t// thus must lookup separately in super type and outer context", "+\tClassScope classScope = initializationScope.enclosingClassScope();", "+\t", "+\tif (classScope != null) {", "+\t\tcheckHiding: {", "+\t\t\tSourceTypeBinding declaringType = classScope.enclosingSourceType();", "+\t\t\tcheckHidingSuperField: {", "+\t\t\t\tif (declaringType.superclass == null) break checkHidingSuperField;", "+\t\t\t\tBinding existingVariable = classScope.findField(declaringType.superclass, this.name, this,  false /*do not resolve hidden field*/);", "+\t\t\t\tif (existingVariable == null) break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\tif (!existingVariable.isValidBinding())  break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\tif (existingVariable instanceof FieldBinding) {", "+\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "+\t\t\t\t\tif (existingField.original() == this.binding) break checkHidingSuperField; // keep checking outer scenario", "+\t\t\t\t// collision with supertype field", "+\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\t\tbreak checkHiding; // already found a matching field", "+\t\t\t}\t\t\t\t\t", "+\t\t\t// only corner case is: lookup of outer field through static declaringType, which isn't detected by #getBinding as lookup starts", "+\t\t\t// from outer scope. Subsequent static contexts are detected for free.", "+\t\t\tScope outerScope = classScope.parent;", "+\t\t\tif (outerScope.kind == Scope.COMPILATION_UNIT_SCOPE) break checkHiding;", "+\t\t\tBinding existingVariable = outerScope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);", "+\t\t\tif (existingVariable == null) break checkHiding;", "+\t\t\tif (!existingVariable.isValidBinding()) break checkHiding;", "+\t\t\tif (existingVariable == this.binding) break checkHiding;", "+\t\t\tif (existingVariable instanceof FieldBinding) {", "+\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "+\t\t\t\tif (existingField.original() == this.binding) break checkHiding;", "+\t\t\t\tif (!existingField.isStatic() && declaringType.isStatic()) break checkHiding;", "+\t\t\t// collision with outer field or local variable", "+\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\tif (this.type != null ) { // enum constants have no declared type", "+\t\tthis.type.resolvedType = this.binding.type; // update binding for type reference", "+\tFieldBinding previousField = initializationScope.initializedField;", "+\tint previousFieldID = initializationScope.lastVisibleFieldID;", "+\ttry {", "+\t\tinitializationScope.initializedField = this.binding;", "+\t\tinitializationScope.lastVisibleFieldID = this.binding.id;", "-\tpublic void resolve(MethodScope initializationScope) {", "-", "-\t\t// the two <constant = Constant.NotAConstant> could be regrouped into", "-\t\t// a single line but it is clearer to have two lines while the reason of their", "-\t\t// existence is not at all the same. See comment for the second one.", "-", "-\t\t//--------------------------------------------------------", "-\t\tif (!this.hasBeenResolved && this.binding != null && this.binding.isValidBinding()) {", "-", "-\t\t\tthis.hasBeenResolved = true;", "-", "-\t\t\t// check if field is hiding some variable - issue is that field binding already got inserted in scope", "-\t\t\t// thus must lookup separately in super type and outer context", "-\t\t\tClassScope classScope = initializationScope.enclosingClassScope();", "+\t\tresolveAnnotations(initializationScope, this.annotations, this.binding);", "+\t\t// check @Deprecated annotation presence", "+\t\tif ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0", "+\t\t\t\t&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0", "+\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\tinitializationScope.problemReporter().missingDeprecatedAnnotationForField(this);", "+\t\t}\t\t\t\t\t\t", "+\t\t// the resolution of the initialization hasn't been done", "+\t\tif (this.initialization == null) {", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t} else {", "+\t\t\t// break dead-lock cycles by forcing constant to NotAConstant", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\tif (classScope != null) {", "-\t\t\t\tcheckHiding: {", "-\t\t\t\t\tSourceTypeBinding declaringType = classScope.enclosingSourceType();", "-\t\t\t\t\tcheckHidingSuperField: {", "-\t\t\t\t\t\tif (declaringType.superclass == null) break checkHidingSuperField;", "-\t\t\t\t\t\tBinding existingVariable = classScope.findField(declaringType.superclass, this.name, this,  false /*do not resolve hidden field*/);", "-\t\t\t\t\t\tif (existingVariable == null) break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\tif (!existingVariable.isValidBinding())  break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\tif (existingVariable instanceof FieldBinding) {", "-\t\t\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "-\t\t\t\t\t\t\tif (existingField.original() == this.binding) break checkHidingSuperField; // keep checking outer scenario", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// collision with supertype field", "-\t\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "-\t\t\t\t\t\tbreak checkHiding; // already found a matching field", "-\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t// only corner case is: lookup of outer field through static declaringType, which isn't detected by #getBinding as lookup starts", "-\t\t\t\t\t// from outer scope. Subsequent static contexts are detected for free.", "-\t\t\t\t\tScope outerScope = classScope.parent;", "-\t\t\t\t\tif (outerScope.kind == Scope.COMPILATION_UNIT_SCOPE) break checkHiding;", "-\t\t\t\t\tBinding existingVariable = outerScope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);", "-\t\t\t\t\tif (existingVariable == null) break checkHiding;", "-\t\t\t\t\tif (!existingVariable.isValidBinding()) break checkHiding;", "-\t\t\t\t\tif (existingVariable == this.binding) break checkHiding;", "-\t\t\t\t\tif (existingVariable instanceof FieldBinding) {", "-\t\t\t\t\t\tFieldBinding existingField = (FieldBinding) existingVariable;", "-\t\t\t\t\t\tif (existingField.original() == this.binding) break checkHiding;", "-\t\t\t\t\t\tif (!existingField.isStatic() && declaringType.isStatic()) break checkHiding;", "-\t\t\t\t\t}", "-\t\t\t\t\t// collision with outer field or local variable", "-\t\t\t\t\tinitializationScope.problemReporter().fieldHiding(this, existingVariable);", "+\t\t\tTypeBinding fieldType = this.binding.type;", "+\t\t\tTypeBinding initializationType;", "+\t\t\tthis.initialization.setExpectedType(fieldType); // needed in case of generic method invocation", "+\t\t\tif (this.initialization instanceof ArrayInitializer) {", "+", "+\t\t\t\tif ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {", "+\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t}", "-\t\t\t", "-\t\t\tif (this.type != null ) { // enum constants have no declared type", "-\t\t\t\tthis.type.resolvedType = this.binding.type; // update binding for type reference", "-\t\t\t}", "+\t\t\t} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {", "-\t\t\tFieldBinding previousField = initializationScope.initializedField;", "-\t\t\tint previousFieldID = initializationScope.lastVisibleFieldID;", "-\t\t\ttry {", "-\t\t\t\tinitializationScope.initializedField = this.binding;", "-\t\t\t\tinitializationScope.lastVisibleFieldID = this.binding.id;", "-", "-\t\t\t\tresolveAnnotations(initializationScope, this.annotations, this.binding);", "-\t\t\t\t// check @Deprecated annotation presence", "-\t\t\t\tif ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0", "-\t\t\t\t\t\t&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0", "-\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "-\t\t\t\t\tinitializationScope.problemReporter().missingDeprecatedAnnotationForField(this);", "-\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t// the resolution of the initialization hasn't been done", "-\t\t\t\tif (this.initialization == null) {", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t\tif (fieldType != initializationType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tinitializationScope.compilationUnitScope().recordTypeConversion(fieldType, initializationType);", "+\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)", "+\t\t\t\t\t\t|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))", "+\t\t\t\t\t\t|| initializationType.isCompatibleWith(fieldType)) {", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "+\t\t\t\t\tif (initializationType.needsUncheckedConversion(fieldType)) {", "+\t\t\t\t\t\t    initializationScope.problemReporter().unsafeTypeConversion(this.initialization, initializationType, fieldType);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.initialization instanceof CastExpression ", "+\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "+\t\t\t\t\t}\t\t\t\t\t\t\t\t", "+\t\t\t\t} else if (initializationScope.isBoxingCompatibleWith(initializationType, fieldType) ", "+\t\t\t\t\t\t\t\t\t|| (initializationType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "+\t\t\t\t\t\t\t\t\t\t\t&& !fieldType.isBaseType()", "+\t\t\t\t\t\t\t\t\t\t\t&& initialization.isConstantValueOfTypeAssignableToType(initializationType, initializationScope.environment().computeBoxingType(fieldType)))) {", "+\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "+\t\t\t\t\tif (this.initialization instanceof CastExpression ", "+\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "+\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "+\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t// break dead-lock cycles by forcing constant to NotAConstant", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\t\t\t", "-\t\t\t\t\tTypeBinding fieldType = this.binding.type;", "-\t\t\t\t\tTypeBinding initializationType;", "-\t\t\t\t\tthis.initialization.setExpectedType(fieldType); // needed in case of generic method invocation", "-\t\t\t\t\tif (this.initialization instanceof ArrayInitializer) {", "-", "-\t\t\t\t\t\tif ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {", "-\t\t\t\t\t\t\t((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {", "-", "-\t\t\t\t\t\tif (fieldType != initializationType) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\t\t\tinitializationScope.compilationUnitScope().recordTypeConversion(fieldType, initializationType);", "-\t\t\t\t\t\tif (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)", "-\t\t\t\t\t\t\t\t|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))", "-\t\t\t\t\t\t\t\t|| initializationType.isCompatibleWith(fieldType)) {", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t\tif (initializationType.needsUncheckedConversion(fieldType)) {", "-\t\t\t\t\t\t\t\t    initializationScope.problemReporter().unsafeTypeConversion(this.initialization, initializationType, fieldType);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (this.initialization instanceof CastExpression ", "-\t\t\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else if (initializationScope.isBoxingCompatibleWith(initializationType, fieldType) ", "-\t\t\t\t\t\t\t\t\t\t\t|| (initializationType.isBaseType()  // narrowing then boxing ?", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& !fieldType.isBaseType()", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& initialization.isConstantValueOfTypeAssignableToType(initializationType, initializationScope.environment().computeBoxingType(fieldType)))) {", "-\t\t\t\t\t\t\tthis.initialization.computeConversion(initializationScope, fieldType, initializationType);", "-\t\t\t\t\t\t\tif (this.initialization instanceof CastExpression ", "-\t\t\t\t\t\t\t\t\t&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {", "-\t\t\t\t\t\t\t\tCastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (this.binding.isFinal()){ // cast from constant actual type to variable type", "-\t\t\t\t\t\t\tthis.binding.setConstant(this.initialization.constant.castTo((this.binding.type.id << 4) + this.initialization.constant.typeID()));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "-\t\t\t\t\t}", "-\t\t\t\t\t// check for assignment with no effect", "-\t\t\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "-\t\t\t\t\t\tinitializationScope.problemReporter().assignmentHasNoEffect(this, this.name);", "-\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\tinitializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);", "-\t\t\t\t// Resolve Javadoc comment if one is present", "-\t\t\t\tif (this.javadoc != null) {", "-\t\t\t\t\t/*", "-\t\t\t\t\tif (classScope != null) {", "-\t\t\t\t\t\tthis.javadoc.resolve(classScope);", "-\t\t\t\t\t}", "-\t\t\t\t\t*/", "-\t\t\t\t\tthis.javadoc.resolve(initializationScope);", "-\t\t\t\t} else if (this.binding.declaringClass != null && !this.binding.declaringClass.isLocalType()) {", "-\t\t\t\t\tinitializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);", "+\t\t\t\tif (this.binding.isFinal()){ // cast from constant actual type to variable type", "+\t\t\t\t\tthis.binding.setConstant(this.initialization.constant.castTo((this.binding.type.id << 4) + this.initialization.constant.typeID()));", "-\t\t\t} finally {", "-\t\t\t\tinitializationScope.initializedField = previousField;", "-\t\t\t\tinitializationScope.lastVisibleFieldID = previousFieldID;", "-\t\t\t\tif (this.binding.constant() == null)", "-\t\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t} else {", "+\t\t\t\tthis.binding.setConstant(Constant.NotAConstant);", "+\t\t\t// check for assignment with no effect", "+\t\t\tif (this.binding == Assignment.getDirectBinding(this.initialization)) {", "+\t\t\t\tinitializationScope.problemReporter().assignmentHasNoEffect(this, this.name);", "+\t\t\t}\t\t\t\t\t", "-\t}", "+\t\t// Resolve Javadoc comment if one is present", "+\t\tif (this.javadoc != null) {", "+\t\t\t/*", "+\t\t\tif (classScope != null) {", "+\t\t\t\tthis.javadoc.resolve(classScope);", "+\t\t\t*/", "+\t\t\tthis.javadoc.resolve(initializationScope);", "+\t\t} else if (this.binding.declaringClass != null && !this.binding.declaringClass.isLocalType()) {", "+\t\t\tinitializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);", "+\t} finally {", "+\t\tinitializationScope.initializedField = previousField;", "+\t\tinitializationScope.lastVisibleFieldID = previousFieldID;", "+\t\tif (this.binding.constant() == null)", "+\t\t\tthis.binding.setConstant(Constant.NotAConstant);"]}], "num": 37830}