{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6172457fd86e9192a3cd381fbceec8c1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "33a5016894ba8ef757ec2a5e6f526c0f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "fc050f32403d0f4e404aa7bf852058bde7010c9c", "commitAfterChange": "9aa23d789697e75fd166c7fcd35afb3e194c7006", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments()", "signatureAfterChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "diff": ["-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "+}", "+private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i) {", "+\tFlowInfo catchInfo;", "+\tif (isUncheckedCatchBlock(i)) {", "+\t\tcatchInfo =", "+\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\thandlingContext.initsOnException(i)).", "+\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "+\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\thandlingContext.initsOnReturn).", "+\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "+\t} else {", "+\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "+\t\tcatchInfo =", "+\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "+\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t}", "+", "+\t// catch var is always set", "+\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t/*", "+\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\tthe try block that need to be detected , e.g.", "+\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t*/", "+\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "+\t}", "+\treturn catchInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "595245530c9a947297e85fb975bef4e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "71fc05771cd5c7e9f570121d2a71e73243d51c9b", "commitAfterChange": "2afe0ff8ea6baebe3984eac1cae395cec750c15a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments()", "signatureAfterChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "diff": ["-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "+}", "+private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i) {", "+\tFlowInfo catchInfo;", "+\tif (isUncheckedCatchBlock(i)) {", "+\t\tcatchInfo =", "+\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\thandlingContext.initsOnException(i)).", "+\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "+\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\thandlingContext.initsOnReturn).", "+\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "+\t} else {", "+\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "+\t\tcatchInfo =", "+\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "+\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "+\t}", "+", "+\t// catch var is always set", "+\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t/*", "+\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\tthe try block that need to be detected , e.g.", "+\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t*/", "+\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "+\t}", "+\treturn catchInfo;", "+}"]}], "num": 69622}