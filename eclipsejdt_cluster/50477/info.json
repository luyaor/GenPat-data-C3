{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6209edc3036d6356d285006200023210", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "102c0b26dfc57c0ca61a10d95b601ba2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 4, "signatureBeforeChange": " boolean areTypesEqual(TypeBinding one, TypeBinding two)", "signatureAfterChange": " boolean areTypesEqual(TypeBinding one, TypeBinding two)", "diff": ["-\tif (one instanceof ReferenceBinding && two instanceof ReferenceBinding)", "-\t\t// can compare unresolved to resolved reference bindings", "-\t\treturn CharOperation.equals(((ReferenceBinding) one).compoundName, ((ReferenceBinding) two).compoundName);", "+", "+\t// its possible that an UnresolvedReferenceBinding can be compared to its resolved type", "+\t// when they're both UnresolvedReferenceBindings then they must be identical like all other types", "+\t// all wrappers of UnresolvedReferenceBindings are converted as soon as the type is resolved", "+\t// so its not possible to have 2 arrays where one is UnresolvedX[] and the other is X[]", "+\tif (one instanceof UnresolvedReferenceBinding)", "+\t\treturn ((UnresolvedReferenceBinding) one).resolvedType == two;", "+\tif (two instanceof UnresolvedReferenceBinding)", "+\t\treturn ((UnresolvedReferenceBinding) two).resolvedType == one;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9408a7de0e3ea08b856f451b173c4e15", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 3, "signatureBeforeChange": " boolean areTypesEqual(TypeBinding one, TypeBinding two)", "signatureAfterChange": " boolean areTypesEqual(TypeBinding one, TypeBinding two)", "diff": ["-boolean areTypesEqual(TypeBinding one, TypeBinding two) {", "-\treturn one == two || super.areTypesEqual(one.erasure(), two.erasure());", "-}", "+}", "+boolean areTypesEqual(TypeBinding one, TypeBinding two) {", "+\tif (one == two) return true;", "+", "+\tswitch (one.bindingType()) {", "+\t\tcase Binding.PARAMETERIZED_TYPE :", "+\t\tcase Binding.RAW_TYPE :", "+\t\t\treturn one.isEquivalentTo(two);", "+//\t\tcase Binding.TYPE_PARAMETER : // won't work for variables from different classes - need substitution", "+\t}", "+", "+\t// Can skip this since we resolved each method before comparing it, see computeSubstituteMethod()", "+\t//\tif (one instanceof UnresolvedReferenceBinding)", "+\t//\t\treturn ((UnresolvedReferenceBinding) one).resolvedType == two;", "+\t//\tif (two instanceof UnresolvedReferenceBinding)", "+\t//\t\treturn ((UnresolvedReferenceBinding) two).resolvedType == one;", "+\treturn false; // all other type bindings are identical", "+}"]}], "num": 50477}