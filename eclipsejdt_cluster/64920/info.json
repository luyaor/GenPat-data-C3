{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3131b15b5154bc71982b96949bbd5d0a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "53565aeac1ed6c54a92ff73809bdb1b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "874e2c41609c64af417834df9af2e898d8dcf37a", "commitAfterChange": "4977ef90a9cbab898d33f6e3ba736939d7ac7a85", "methodNumberBeforeChange": 272, "methodNumberAfterChange": 467, "signatureBeforeChange": " public boolean expressionNonNullComparison(Expression expr, boolean checkForNull)", "signatureAfterChange": " public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location)", "diff": ["- */", "-public boolean expressionNonNullComparison(Expression expr, boolean checkForNull) {", "-\tint problemId = 0;", "-\tBinding binding = null;", "-\tString[] arguments = null;", "-\tint start = 0, end = 0;", "-", "-\tExpression location = expr;", "-\t// unwrap uninteresting nodes:", "-\twhile (true) {", "-\t\tif (expr instanceof Assignment)", "-\t\t\treturn false; // don't report against the assignment, but the variable", "-\t\telse if (expr instanceof CastExpression)", "-\t\t\texpr = ((CastExpression) expr).expression;", "-\t\telse", "-\t\t\tbreak;", "-\t}", "-\t// check all those kinds of expressions that can possible answer NON_NULL from nullStatus():", "-\tif (expr instanceof MessageSend) {", "-\t\tproblemId = checkForNull ", "-\t\t\t\t? IProblem.NonNullMessageSendComparisonYieldsFalse", "-\t\t\t\t: IProblem.RedundantNullCheckOnNonNullMessageSend;", "-\t\tMethodBinding method = ((MessageSend)expr).binding;", "-\t\tbinding = method;", "-\t\targuments = new String[] { new String(method.shortReadableName()) };", "-\t\tstart = location.sourceStart;", "-\t\tend = location.sourceEnd;", "-\t} else if (expr instanceof Reference && !(expr instanceof ThisReference) && !(expr instanceof ArrayReference)) {", "-\t\tFieldBinding field = ((Reference)expr).lastFieldBinding();", "-\t\tif (field == null) {", "-\t\t\treturn false;", "-\t\t}", "-\t\tif (field.isNonNull()) {", "-\t\t\tproblemId = checkForNull", "-\t\t\t\t\t? IProblem.NonNullSpecdFieldComparisonYieldsFalse", "-\t\t\t\t\t: IProblem.RedundantNullCheckOnNonNullSpecdField;", "-\t\t\tchar[][] nonNullName = this.options.nonNullAnnotationName;", "-\t\t\targuments = new String[] { new String(field.name), ", "-\t\t\t\t\t\t\t\t\t   new String(nonNullName[nonNullName.length-1]) };", "-\t\t} else {", "-\t\t\tproblemId = checkForNull", "-\t\t\t\t\t? IProblem.NonNullFieldComparisonYieldsFalse", "-\t\t\t\t\t: IProblem.RedundantNullCheckOnNonNullField;", "-\t\t\targuments = new String[] { new String(field.name) };", "-\t\t}", "-\t\tbinding = field;", "-\t\tstart = nodeSourceStart(binding, location);", "-\t\tend = nodeSourceEnd(binding, location);", "-\t} else if (expr instanceof AllocationExpression ", "-\t\t\t|| expr instanceof ArrayAllocationExpression ", "-\t\t\t|| expr instanceof ArrayInitializer", "-\t\t\t|| expr instanceof ClassLiteralAccess", "-\t\t\t|| expr instanceof ThisReference) {", "-\t\t// fall through", "-\t} else if (expr instanceof Literal) {", "-\t\tif (expr instanceof NullLiteral) {", "-\t\t\tneedImplementation(location); // reported as nonnull??", "-\t\t\treturn false;", "-\t\t}", "-\t\tif (expr.resolvedType != null && expr.resolvedType.isBaseType()) {", "-\t\t\t// false alarm, auto(un)boxing is involved", "-\t\t\treturn false;", "-\t\t}", "-\t\t// fall through", "-\t} else if (expr instanceof BinaryExpression) {", "-\t\tif ((expr.bits & ASTNode.ReturnTypeIDMASK) != TypeIds.T_JavaLangString) {", "-\t\t\t// false alarm, primitive types involved, must be auto(un)boxing?", "-\t\t\treturn false;", "-\t\t}", "-\t\t// fall through", "-\t} else if (expr instanceof ConditionalExpression) {", "-\t\tneedImplementation(location); // TODO", "-\t\treturn false;", "-\t} else {", "-\t\tneedImplementation(expr);", "-\t\treturn false;", "-\t}", "-\tif (problemId == 0) {", "-\t\t// standard case, fill in details now", "-\t\tproblemId = checkForNull ", "-\t\t\t\t? IProblem.NonNullExpressionComparisonYieldsFalse", "-\t\t\t\t: IProblem.RedundantNullCheckOnNonNullExpression;", "-\t\tstart = location.sourceStart;", "-\t\tend = location.sourceEnd;", "-\t\targuments = NoArgument;", "-\t}", "-\tthis.handle(problemId, arguments, arguments, start, end);", "-\treturn true;", "-}", "+public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location) {", "+\tString[] arguments = new String[] {new String(method.readableName())  };", "+\tthis.handle(", "+\t\tIProblem.RedundantNullCheckOnNonNullMessageSend,", "+\t\targuments,", "+\t\targuments,", "+\t\tlocation.sourceStart,", "+\t\tlocation.sourceEnd);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fd38e4197032d3286fbffce723a0931a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "8c93d4e99b8a943865cb7391e781eba5bb83dfc9", "commitAfterChange": "bd0edd7688142c1743cb6b10766dfc576040f113", "methodNumberBeforeChange": 467, "methodNumberAfterChange": 272, "signatureBeforeChange": " public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location)", "signatureAfterChange": " public boolean expressionNonNullComparison(Expression expr, boolean checkForNull)", "diff": ["+ */", "+public boolean expressionNonNullComparison(Expression expr, boolean checkForNull) {", "+\tint problemId;", "+\tBinding binding;", "+\tString[] arguments;", "+\tint start, end;", "+", "+\tExpression location = expr;", "+\t// unwrap uninteresting nodes:", "+\twhile (true) {", "+\t\tif (expr instanceof Assignment)", "+\t\t\treturn false; // don't report against the assignment, but the variable", "+\t\telse if (expr instanceof CastExpression)", "+\t\t\texpr = ((CastExpression) expr).expression;", "+\t\telse", "+\t\t\tbreak;", "+\t}", "+\t// check all those kinds of expressions that can possible answer NON_NULL from nullStatus():", "+\tif (expr instanceof MessageSend) {", "+\t\tproblemId = checkForNull ", "+\t\t\t\t? IProblem.NonNullMessageSendComparisonYieldsFalse", "+\t\t\t\t: IProblem.RedundantNullCheckOnNonNullMessageSend;", "+\t\tMethodBinding method = ((MessageSend)expr).binding;", "+\t\tbinding = method;", "+\t\targuments = new String[] { new String(method.shortReadableName()) };", "+\t\tstart = location.sourceStart;", "+\t\tend = location.sourceEnd;", "+\t} else if (expr instanceof Reference && !(expr instanceof ThisReference) && !(expr instanceof ArrayReference)) {", "+\t\tFieldBinding field = ((Reference)expr).lastFieldBinding();", "+\t\tif (field == null) {", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (field.isNonNull()) {", "+\t\t\tproblemId = checkForNull", "+\t\t\t\t\t? IProblem.NonNullSpecdFieldComparisonYieldsFalse", "+\t\t\t\t\t: IProblem.RedundantNullCheckOnNonNullSpecdField;", "+\t\t\tchar[][] nonNullName = this.options.nonNullAnnotationName;", "+\t\t\targuments = new String[] { new String(field.name), ", "+\t\t\t\t\t\t\t\t\t   new String(nonNullName[nonNullName.length-1]) };", "+\t\t} else {", "+\t\t\tproblemId = checkForNull", "+\t\t\t\t\t? IProblem.NonNullFieldComparisonYieldsFalse", "+\t\t\t\t\t: IProblem.RedundantNullCheckOnNonNullField;", "+\t\t\targuments = new String[] { new String(field.name) };", "+\t\t}", "+\t\tbinding = field;", "+\t\tstart = nodeSourceStart(binding, location);", "+\t\tend = nodeSourceEnd(binding, location);", "+\t} else if (expr instanceof AllocationExpression ", "+\t\t\t|| expr instanceof ArrayAllocationExpression ", "+\t\t\t|| expr instanceof ArrayInitializer", "+\t\t\t|| expr instanceof ClassLiteralAccess", "+\t\t\t|| expr instanceof ThisReference) {", "+\t\tproblemId = checkForNull ", "+\t\t\t\t? IProblem.NonNullExpressionComparisonYieldsFalse", "+\t\t\t\t: IProblem.RedundantNullCheckOnNonNullExpression;", "+\t\tstart = location.sourceStart;", "+\t\tend = location.sourceEnd;", "+\t\targuments = NoArgument;", "+\t} else if (expr instanceof Literal) {", "+\t\tif (expr instanceof NullLiteral) {", "+\t\t\tneedImplementation(location); // reported as nonnull??", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (expr.resolvedType != null && expr.resolvedType.isBaseType()) {", "+\t\t\t// false alarm, auto(un)boxing is involved", "+\t\t\treturn false;", "+\t\t}", "+\t\tproblemId = checkForNull ", "+\t\t\t\t? IProblem.NonNullExpressionComparisonYieldsFalse", "+\t\t\t\t: IProblem.RedundantNullCheckOnNonNullExpression;", "+\t\tstart = location.sourceStart;", "+\t\tend = location.sourceEnd;", "+\t\targuments = NoArgument;", "+\t} else if (expr instanceof ConditionalExpression) {", "+\t\tneedImplementation(location); // TODO", "+\t\treturn false;", "+\t} else {", "+\t\tneedImplementation(expr);", "+\t\treturn false;", "+\t}", "+\tthis.handle(problemId, arguments, arguments, start, end);", "+\treturn true;", "+}", "-}", "-public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location) {", "-\tString[] arguments = new String[] {new String(method.readableName())  };", "-\tthis.handle(", "-\t\tIProblem.RedundantNullCheckOnNonNullMessageSend,"]}], "num": 64920}