{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d2854dc819e899099abee97ca64aa8f0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b43c69d746e745dfc56d1b960230455c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 117, "signatureBeforeChange": "  \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["+\t// Version that just answers based on inference kind (at 1.8+) when available.", "+\tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site) {", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\tint inferenceKind = InferenceContext18.CHECK_UNKNOWN;", "+\t\t\tInferenceContext18 context = null;", "+\t\t\tif (site instanceof Invocation) {", "+\t\t\t\tInvocation invocation = (Invocation) site;", "+\t\t\t\tcontext = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);", "+\t\t\t\tif (context != null)", "+\t\t\t\t\tinferenceKind = context.inferenceKind;", "+\t\t\t} else if (site instanceof ReferenceExpression) {", "+\t\t\t\tinferenceKind = ((ReferenceExpression) site).inferenceKind;", "+\t\t\t}", "+\t\t\t/* 1.8+ Post inference compatibility check policy: For non-functional-type arguments, trust inference. For functional type arguments apply compatibility checks as inference", "+\t\t\t   engine may not have checked arguments that are not pertinent to applicability. One complication to deal with is when the generic method's parameter is its own type variable ", "+\t\t\t   and only applicability was inferred and applicability inference instantiated it with jlO due to lack of upper bounds in the bound set.", "+\t\t\t*/", "+\t\t\tif (site instanceof Invocation && context != null) { // this block can be readily seen to be not relevant for reference expressions", "+\t\t\t\tMethodBinding shallowOriginal = method.shallowOriginal();", "+\t\t\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "+\t\t\t\t\tTypeBinding argument = arguments[i];", "+\t\t\t\t\tif (!argument.isFunctionalType())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding parameter = InferenceContext18.getParameter(method.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (argument.isCompatibleWith(parameter, this))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "+\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tswitch (inferenceKind) {", "+\t\t\t\tcase InferenceContext18.CHECK_STRICT:", "+\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_LOOSE:", "+\t\t\t\t\treturn AUTOBOX_COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_VARARG:", "+\t\t\t\t\treturn VARARGS_COMPATIBLE;", "+\t\t\t\tdefault:", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t}", "+\t\treturn parameterCompatibilityLevel(method, arguments, false);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e78aaa97f4632527f7e68fb1c08e5c20", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 119, "methodNumberAfterChange": 119, "signatureBeforeChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["-\t\t\t/* 1.8+ Post inference compatibility check policy: For non-functional-type arguments, trust inference. For functional type arguments apply compatibility checks as inference", "-\t\t\t   engine may not have checked arguments that are not pertinent to applicability. One complication to deal with is when the generic method's parameter is its own type variable ", "-\t\t\t   and only applicability was inferred and applicability inference instantiated it with jlO due to lack of upper bounds in the bound set.", "-\t\t\t*/", "-\t\t\tif (site instanceof Invocation && context != null) { // this block can be readily seen to be not relevant for reference expressions", "+\t\t\t/* 1.8+ Post inference compatibility check policy: For non-functional-type arguments, trust inference. For functional type arguments apply compatibility checks after inference", "+\t\t\t   has completed to ensure arguments that were not pertinent to applicability which have only seen potential compatibility checks are actually compatible.", "+\t\t\t*/   ", "+\t\t\tif (site instanceof Invocation && context != null && context.stepCompleted >= InferenceContext18.TYPE_INFERRED) {", "-\t\t\t\t\tif (argument.isCompatibleWith(parameter, this))", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tif (context.stepCompleted >= InferenceContext18.TYPE_INFERRED)", "+\t\t\t\t\tif (!argument.isCompatibleWith(parameter, this))", "-\t\t\t\t\tcontinue; // Engine has already asserted potential compatibility and that is all we can do."]}], "num": 10798}