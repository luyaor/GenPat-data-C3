{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "22e1fc54a1fb3e7d6d9401cb08c7248d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ce2106f0c7b2b0442728187f3ed1554", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/align/Alignment.java", "commitBeforeChange": "62bb0df3439a3337bf19f66c0d56ac16589e94ca", "commitAfterChange": "848e612d33c010bc83985e60213e8fbc07d0fc75", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic Alignment(String name, int mode, int tieBreakRule, Scribe scribe, int fragmentCount, int sourceRestart, int continuationIndent)", "signatureAfterChange": " \tpublic Alignment(String name, int mode, int tieBreakRule, Scribe scribe, int fragmentCount, int sourceRestart, int continuationIndent)", "diff": ["-\t\tint indentSize = this.scribe.useTab ? 1 : this.scribe.tabSize;", "+\t\tfinal int indentSize = this.scribe.useTab ? 1 : this.scribe.tabSize;", "-\t\t    currentColumn = this.location.outputIndentationLevel * (this.scribe.useTab ?  this.scribe.tabSize : 1) + 1;", "+\t\t    currentColumn = this.location.outputIndentationLevel * indentSize + 1;", "+\t\t\tif (this.breakIndentationLevel == this.location.outputIndentationLevel) {", "+\t\t\t\tthis.breakIndentationLevel += (continuationIndent * indentSize);", "+\t\t\t}", "-\t\t\tthis.breakIndentationLevel = this.location.outputIndentationLevel + (continuationIndent * (this.scribe.useTab ?  1 : this.scribe.tabSize));", "-\t\t}", "-\t\t// reduce indentation of broken fragment in case first fragment would be before the subsequent ones", "-\t\tif ((mode & M_NEXT_SHIFTED_SPLIT) != 0) {", "-\t\t\tint firstFragmentNextIndentationLevel =  this.scribe.getNextIndentationLevel(currentColumn);", "-\t\t\tif (firstFragmentNextIndentationLevel < this.breakIndentationLevel) {", "-\t\t\t\tthis.breakIndentationLevel = firstFragmentNextIndentationLevel;", "-\t\t\t}", "+\t\t\tthis.breakIndentationLevel = this.location.outputIndentationLevel + continuationIndent * indentSize;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3554a7377db593299f0aa9ff66a80c1e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "3a9d0e9ebb77a4184e107b2ffacf2122d4d188cf", "commitAfterChange": "cc44d533509199a22dee3cb03412b30282a18add", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "signatureAfterChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "diff": ["+    \t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "+\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));", "-\t\t\t\t\tcase TerminalTokens.TokenNameStringLiteral:", "-\t\t\t\t\t\tif (this.scanner.currentPosition > this.scanner.eofPosition) {", "-\t\t\t\t\t\t\tthis.scanner.resetTo(this.scanner.startPosition, textEnd);", "-\t\t\t\t\t\t\tthis.scanner.getNextChar();", "-\t\t\t\t\t\t\ttoken = 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-    \t\t\tint tokenStart = this.scanner.getCurrentTokenStartPosition();", "-\t    \t\tboolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));", "-\t\t\t\t\tif (!isHtmlTag && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {", "+\t\t\t\t\tif (!isHtmlTag && tokensBufferLength > 0 && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f3c37f95f4d617729e09627fd807bdd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "388d6309502d2277c29518666e0a29b9ef8f3348", "commitAfterChange": "ef51b740fbbff33bb9bc830d786a838b3dd10149", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " public RecoveredElement buildInitialRecoveryState()", "signatureAfterChange": " public RecoveredElement buildInitialRecoveryState()", "diff": ["-\t\tif (true){ // experimenting restart recovery from scratch", "-\t\t\tthis.compilationUnit.currentPackage = null;", "-\t\t\tthis.compilationUnit.imports = null;", "-\t\t\tthis.compilationUnit.types = null;", "-\t\t\tthis.currentToken = 0;", "-\t\t\tthis.listLength = 0;", "-\t\t\tthis.listTypeParameterLength = 0;", "-\t\t\tthis.endPosition = 0;", "-\t\t\tthis.endStatementPosition = 0;", "-\t\t\treturn element;", "-\t\t}", "-\t\tif (this.compilationUnit.currentPackage != null){", "-\t\t\tthis.lastCheckPoint = this.compilationUnit.currentPackage.declarationSourceEnd+1;", "-\t\t}", "-\t\tif (this.compilationUnit.imports != null){", "-\t\t\tthis.lastCheckPoint = this.compilationUnit.imports[this.compilationUnit.imports.length -1].declarationSourceEnd+1;", "-\t\t}", "+\t\t// restart recovery from scratch", "+\t\tthis.compilationUnit.currentPackage = null;", "+\t\tthis.compilationUnit.imports = null;", "+\t\tthis.compilationUnit.types = null;", "+\t\tthis.currentToken = 0;", "+\t\tthis.listLength = 0;", "+\t\tthis.listTypeParameterLength = 0;", "+\t\tthis.endPosition = 0;", "+\t\tthis.endStatementPosition = 0;", "+\t\treturn element;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "727b81bc05beb47ec60b0fbbcbfe4cac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "14eeb335b7a4f4b5dc293b65ac56b4b7f62e99e5", "commitAfterChange": "000351037175db78f3f7a7716a67e8a0125ff547", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprotected boolean parseParam() throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseParam() throws InvalidInputException", "diff": ["-\t\t// Verify that there are whitespaces after tag", "-\t\tboolean isCompletionParser = (this.kind & COMPLETION_PARSER) != 0;", "-\t\tif (this.scanner.currentCharacter != ' ' && !ScannerHelper.isWhitespace(this.scanner.currentCharacter)) {", "-\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(start, this.scanner.getCurrentTokenEndPosition());", "-\t\t\tif (!isCompletionParser) {", "-\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\tthis.index = start;", "-\t\t\t}", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Get first non whitespace token", "-\t\tthis.identifierPtr = -1;", "-\t\tthis.identifierLengthPtr = -1;", "-\t\tboolean hasMultiLines = this.scanner.currentPosition > (this.lineEnd+1);", "-\t\tboolean isTypeParam = false;", "-\t\tboolean valid = true, empty = true;", "-\t\tboolean mayBeGeneric = this.sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\tint token = -1;", "-\t\tnextToken: while (true) {", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\ttry {", "-\t\t\t\ttoken = readToken();", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tvalid = false;", "-\t\t\t}", "-\t\t\tswitch (token) {", "-\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\tif (valid) { ", "-\t\t\t\t\t\t// store param name id", "-\t\t\t\t\t\tpushIdentifier(true, false);", "-\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t}", "-\t\t\t\t\t// fall through next case to report error", "-\t\t\t\tcase TerminalTokens.TokenNameLESS:", "-\t\t\t\t\tif (valid && mayBeGeneric) {", "-\t\t\t\t\t\t// store '<' in identifiers stack as we need to add it to tag element (bug 79809)", "-\t\t\t\t\t\tpushIdentifier(true, true);", "-\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tisTypeParam = true;", "-\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t}", "-\t\t\t\t\t// fall through next case to report error", "-\t\t\t\tdefault:", "-\t\t\t\t\tif (token == TerminalTokens.TokenNameLEFT_SHIFT) isTypeParam = true;", "-\t\t\t\t\tif (valid && !hasMultiLines) start = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\tvalid = false;", "-\t\t\t\t\tif (!hasMultiLines) {", "-\t\t\t\t\t\tempty = false;", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tend = this.lineEnd;", "-\t\t\t\t\t// when several lines, fall through next case to report problem immediately", "-\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) hasMultiLines = true;", "-\t\t\t\t\tif (valid) break;", "-\t\t\t\t\t// if not valid fall through next case to report error", "-\t\t\t\tcase TerminalTokens.TokenNameEOF:", "-\t\t\t\t\tif (this.reportProblems)", "-\t\t\t\t\t\tif (empty)", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "-\t\t\t\t\t\telse if (mayBeGeneric && isTypeParam)", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\t\t\t\tif (!isCompletionParser) {", "-\t\t\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\t\t\tthis.index = start;", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Scan more tokens for type parameter declaration", "-\t\tif (isTypeParam && mayBeGeneric) {", "-\t\t\t// Get type parameter name", "-\t\t\tnextToken: while (true) {", "+\t\ttry {", "+\t\t\t// Verify that there are whitespaces after tag", "+\t\t\tboolean isCompletionParser = (this.kind & COMPLETION_PARSER) != 0;", "+\t\t\tif (this.scanner.currentCharacter != ' ' && !ScannerHelper.isWhitespace(this.scanner.currentCharacter)) {", "+\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(start, this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\tthis.index = start;", "+\t\t\t\t}", "-\t\t\t\ttry {", "-\t\t\t\t\ttoken = readToken();", "-\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\tvalid = false;", "-\t\t\t\t}", "-\t\t\t\tswitch (token) {", "-\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\tif (valid && this.scanner.currentPosition <= (this.lineEnd+1)) break;", "-\t\t\t\t\t\t// if not valid fall through next case to report error", "-\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "-\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\t\t\t\tif (!isCompletionParser) {", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "-\t\t\t\t\t\t\tthis.index = start;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tif (valid) {", "-\t\t\t\t\t\t\t// store param name id", "-\t\t\t\t\t\t\tpushIdentifier(false, false);", "-\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tvalid = false;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\t\t\treturn false;", "-\t\t\t// Get last character of type parameter declaration", "-\t\t\tboolean spaces = false;", "+\t\t\t// Get first non whitespace token", "+\t\t\tthis.identifierPtr = -1;", "+\t\t\tthis.identifierLengthPtr = -1;", "+\t\t\tboolean hasMultiLines = this.scanner.currentPosition > (this.lineEnd+1);", "+\t\t\tboolean isTypeParam = false;", "+\t\t\tboolean valid = true, empty = true;", "+\t\t\tboolean mayBeGeneric = this.sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\t\tint token = -1;", "-\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) {", "-\t\t\t\t\t\t\t// do not accept type parameter declaration on several lines", "-\t\t\t\t\t\t\thasMultiLines = true;", "-\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\tif (valid) { ", "+\t\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\t\tpushIdentifier(true, false);", "+\t\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\tspaces = true;", "+\t\t\t\t\t\t// fall through next case to report error", "+\t\t\t\t\tcase TerminalTokens.TokenNameLESS:", "+\t\t\t\t\t\tif (valid && mayBeGeneric) {", "+\t\t\t\t\t\t\t// store '<' in identifiers stack as we need to add it to tag element (bug 79809)", "+\t\t\t\t\t\t\tpushIdentifier(true, true);", "+\t\t\t\t\t\t\tstart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tisTypeParam = true;", "+\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through next case to report error", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tif (token == TerminalTokens.TokenNameLEFT_SHIFT) isTypeParam = true;", "+\t\t\t\t\t\tif (valid && !hasMultiLines) start = this.scanner.getCurrentTokenStartPosition();", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\tif (!hasMultiLines) {", "+\t\t\t\t\t\t\tempty = false;", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tend = this.lineEnd;", "+\t\t\t\t\t\t// when several lines, fall through next case to report problem immediately", "+\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) hasMultiLines = true;", "-\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\tif (this.reportProblems)", "+\t\t\t\t\t\t\tif (empty)", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocMissingParamName(start, end, this.sourceParser.modifiers);", "+\t\t\t\t\t\t\telse if (mayBeGeneric && isTypeParam)", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\t\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "-\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tif (valid) {", "-\t\t\t\t\t\t\t// store '>' in identifiers stack as we need to add it to tag element (bug 79809)", "-\t\t\t\t\t\t\tpushIdentifier(false, true);", "-\t\t\t\t\t\t\tbreak nextToken;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (!spaces) end = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\t\t\t\t\tvalid = false;", "-\t\t\t\t\t\tbreak;", "-\t\t}", "-\t\t", "-\t\t// Verify that tag name is well followed by white spaces", "-\t\tif (valid) {", "-\t\t\tthis.currentTokenType = -1;", "-\t\t\tint restart = this.scanner.currentPosition;", "-\t\t\ttry {", "-\t\t\t\ttoken = readToken();", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tvalid = false;", "+\t\t\t", "+\t\t\t// Scan more tokens for type parameter declaration", "+\t\t\tif (isTypeParam && mayBeGeneric) {", "+\t\t\t\t// Get type parameter name", "+\t\t\t\tnextToken: while (true) {", "+\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttoken = readToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t}", "+\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\tif (valid && this.scanner.currentPosition <= (this.lineEnd+1)) break;", "+\t\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\t\t// store param name id", "+\t\t\t\t\t\t\t\tpushIdentifier(false, false);", "+\t\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Get last character of type parameter declaration", "+\t\t\t\tboolean spaces = false;", "+\t\t\t\tnextToken: while (true) {", "+\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\ttoken = readToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t}", "+\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\tif (this.scanner.currentPosition > (this.lineEnd+1)) {", "+\t\t\t\t\t\t\t\t// do not accept type parameter declaration on several lines", "+\t\t\t\t\t\t\t\thasMultiLines = true;", "+\t\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tspaces = true;", "+\t\t\t\t\t\t\tif (valid) break;", "+\t\t\t\t\t\t\t// if not valid fall through next case to report error", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameEOF:", "+\t\t\t\t\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\t\t\t\tif (!isCompletionParser) {", "+\t\t\t\t\t\t\t\tthis.scanner.currentPosition = start;", "+\t\t\t\t\t\t\t\tthis.index = start;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\tcase TerminalTokens.TokenNameGREATER:", "+\t\t\t\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tif (valid) {", "+\t\t\t\t\t\t\t\t// store '>' in identifiers stack as we need to add it to tag element (bug 79809)", "+\t\t\t\t\t\t\t\tpushIdentifier(false, true);", "+\t\t\t\t\t\t\t\tbreak nextToken;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tif (!spaces) end = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "-\t\t\t\tthis.scanner.currentPosition = restart;", "-\t\t\t\tthis.index = restart;", "-\t\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\t\t\treturn pushParamName(isTypeParam);", "+\t\t\t", "+\t\t\t// Verify that tag name is well followed by white spaces", "+\t\t\tif (valid) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tint restart = this.scanner.currentPosition;", "+\t\t\t\ttry {", "+\t\t\t\t\ttoken = readToken();", "+\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\tvalid = false;", "+\t\t\t\t}", "+\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\tthis.scanner.currentPosition = restart;", "+\t\t\t\t\tthis.index = restart;", "+\t\t\t\t\treturn pushParamName(isTypeParam);", "+\t\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Report problem", "-\t\tthis.currentTokenType = -1;", "-\t\tif (isCompletionParser) return false;", "-\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "-\t\twhile ((token=readToken()) != TerminalTokens.TokenNameWHITESPACE && token != TerminalTokens.TokenNameEOF) {", "+\t\t\t// Report problem", "+\t\t\tif (isCompletionParser) return false;", "+\t\t\twhile ((token=readToken()) != TerminalTokens.TokenNameWHITESPACE && token != TerminalTokens.TokenNameEOF) {", "+\t\t\t\tthis.currentTokenType = -1;", "+\t\t\t\tend = hasMultiLines ? this.lineEnd: this.scanner.getCurrentTokenEndPosition();", "+\t\t\t}", "+\t\t\tif (this.reportProblems)", "+\t\t\t\tif (mayBeGeneric && isTypeParam)", "+\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "+\t\t\t\telse", "+\t\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "+\t\t\tthis.scanner.currentPosition = start;", "+\t\t\tthis.index = start;", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\treturn false;", "+\t\t} finally {", "+\t\t\t// we have to make sure that this is reset to the previous value even if an exception occurs", "+\t\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\tif (this.reportProblems)", "-\t\t\tif (mayBeGeneric && isTypeParam)", "-\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTypeParameter(start, end);", "-\t\t\telse", "-\t\t\t\tthis.sourceParser.problemReporter().javadocInvalidParamTagName(start, end);", "-\t\tthis.scanner.currentPosition = start;", "-\t\tthis.index = start;", "-\t\tthis.currentTokenType = -1;", "-\t\tthis.scanner.tokenizeWhiteSpace = tokenWhiteSpace;", "-\t\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3f84edeec646b407e1b1d752dbb0d4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "d2861a7753e529217c872f1a7e1714670325b389", "commitAfterChange": "3fede7546d33952755c77985258d932ac43f63ce", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  \tprivate CompilationUnitDeclaration resolve( \t\t\tCompilationUnitDeclaration unit, \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "signatureAfterChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "diff": ["-\tprivate CompilationUnitDeclaration resolve(", "-\t\t\tCompilationUnitDeclaration unit,", "-\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit,", "+\t */", "+\tpublic CompilationUnitDeclaration resolve(", "+\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit,", "+\t\tCompilationUnitDeclaration unit = null;", "+\t\t\tthis.parseThreshold = 0; // will request a diet parse", "+\t\t\tbeginToCompile(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] { compilationUnit});", "+\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "+\t\t\tunit = this.unitsToProcess[0];", "+", "+\t\t\tint searchPosition = nodeSearcher.position;", "+\t\t\tif (searchPosition >= 0 && searchPosition <= compilationUnit.getContents().length) {", "+\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "+\t\t\t\t", "+\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "+\t\t\t\t", "+\t \t\t\tif (node != null) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "+\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "+\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "+\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "+\t\t\t\t\t\t} \t\t\t\t", "+\t \t\t\t\t}", "+\t \t\t\t}", "+\t\t\t}", "+\t\t\tif (unit.scope != null) {", "+\t\t\t\t// fault in fields & methods", "+\t\t\t\tunit.scope.faultInTypes();", "+\t\t\t\tif (unit.scope != null && verifyMethods) {", "+\t\t\t\t\t// http://dev.eclipse.org/bugs/show_bug.cgi?id=23117", "+ \t\t\t\t\t// verify inherited methods", "+\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "+\t\t\t\t}", "+\t\t\t\t// type checking", "+\t\t\t\tunit.resolve();\t\t", "+", "+\t\t\t\t// flow analysis", "+\t\t\t\tif (analyzeCode) unit.analyseCode();", "+\t\t", "+\t\t\t\t// code generation", "+\t\t\t\tif (generateCode) unit.generateCode();", "+\t\t\t}", "+\t\t\tif (this.unitsToProcess != null) this.unitsToProcess[0] = null; // release reference to processed unit declaration", "+\t\t\tthis.requestor.acceptResult(unit.compilationResult.tagAsAccepted());", "+\t\t\treturn unit;", "+\t\t} catch (AbortCompilation e) {", "+\t\t\tthis.handleInternalException(e, unit);", "+\t\t\treturn null;", "+\t\t} catch (Error e) {", "+\t\t\tthis.handleInternalException(e, unit, null);", "+\t\t\tthrow e; // rethrow", "+\t\t} catch (RuntimeException e) {", "+\t\t\tthis.handleInternalException(e, unit, null);", "+\t\t\tthrow e; // rethrow", "+\t\t} finally {", "+\t\t\t// No reset is performed there anymore since,", "+\t\t\t// within the CodeAssist (or related tools),", "+\t\t\t// the compiler may be called *after* a call", "+\t\t\t// to this resolve(...) method. And such a call", "+\t\t\t// needs to have a compiler with a non-empty", "+\t\t\t// environment.", "+\t\t\t// this.reset();", "+\t\t}", "+\t}", "-", "-\t\t\tthis.parser.getMethodBodies(unit); // no-op if method bodies have already been parsed", "-\t\t\t", "-\t\t\tif (nodeSearcher != null) {", "-\t\t\t\tint searchPosition = nodeSearcher.position;", "-\t\t\t\tif (searchPosition >= 0 && searchPosition <= sourceUnit.getContents().length) {", "-\t\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "-\t\t\t\t\t", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "-\t\t\t\t\t", "-\t\t \t\t\tif (node != null) {", "-\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "-\t\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "-\t\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "-\t\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "-\t\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "-\t\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "-\t\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "-\t\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "-\t\t\t\t\t\t\t} \t\t\t\t", "-\t\t \t\t\t\t}", "-\t\t \t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de53969e64e8dd697a4cc738fb861b5f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/IncrementalTests.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic void _testNewJCL()", "signatureAfterChange": "  \tpublic void testNewJCL()", "diff": ["-\t// TODO excluded test", "-\tpublic void _testNewJCL() {", "+\tpublic void testNewJCL() {", "-\t\texpectingSpecificProblemFor(object, new Problem(\"java.lang\", \"This compilation unit indirectly references the missing type java.lang.Throwable (typically some required class file is referencing a type outside the classpath)\", object, 1, 2, -1, IMarker.SEVERITY_ERROR)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\texpectingNoProblems();", "-\t\texpectingSpecificProblemFor(object, new Problem(\"java.lang\", \"This compilation unit indirectly references the missing type java.lang.RuntimeException (typically some required class file is referencing a type outside the classpath)\", object, 1, 2, -1, IMarker.SEVERITY_ERROR)); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\texpectingSpecificProblemFor(throwable, new Problem(\"java.lang\", \"This compilation unit indirectly references the missing type java.lang.RuntimeException (typically some required class file is referencing a type outside the classpath)\", throwable, 1, 2, -1, IMarker.SEVERITY_ERROR)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\texpectingNoProblems();"]}], "num": 28489}