{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c38445db908cdce15f21586b823b47ed", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1023aaa3227ef9cd24b5bb97c2b47d85", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "1666c32b249d36aa9547f4f66f511c5bb00d3d63", "commitAfterChange": "4e6bb96b0e120539a45cc4860f508bf12e097d37", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": "  public ParameterizedGenericMethodBinding createParameterizedGenericMethod(MethodBinding genericMethod, TypeBinding[] typeArguments)", "signatureAfterChange": " public ParameterizedGenericMethodBinding createParameterizedGenericMethod(MethodBinding genericMethod, TypeBinding[] typeArguments, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean inferredWithUncheckedConversion, boolean hasReturnProblem)", "diff": ["+}", "+public ParameterizedGenericMethodBinding createParameterizedGenericMethod(MethodBinding genericMethod, TypeBinding[] typeArguments,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tboolean inferredWithUncheckedConversion, boolean hasReturnProblem)", "+{", "+\t\t\t\tif (inferredWithUncheckedConversion) { // JSL 18.5.2: \"If unchecked conversion was necessary...\"", "+\t\t\t\t\t// don't tolerate remaining parameterized types / type variables, should have been eliminated by erasure:", "+\t\t\t\t\tif (cachedMethod.returnType.isParameterizedType() || cachedMethod.returnType.isTypeVariable()) continue;", "+\t\t\t\t\tfor (TypeBinding exc : cachedMethod.thrownExceptions)", "+\t\t\t\t\t\tif (exc.isParameterizedType() || exc.isTypeVariable()) continue nextCachedMethod;", "+\t\t\t\t}", "-\tParameterizedGenericMethodBinding parameterizedGenericMethod = new ParameterizedGenericMethodBinding(genericMethod, typeArguments, this);", "+\tParameterizedGenericMethodBinding parameterizedGenericMethod =", "+\t\t\tnew ParameterizedGenericMethodBinding(genericMethod, typeArguments, this, inferredWithUncheckedConversion, hasReturnProblem);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2bc1c82c9515d363e1d9a4a4351d52d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "8580e60642e681a1d666f59f018926e08e2e8a62", "commitAfterChange": "e4335f612db86aa6e739c4af37c0425a42aadb90", "methodNumberBeforeChange": 102, "methodNumberAfterChange": 102, "signatureBeforeChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType)", "signatureAfterChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\t\t\t\t\tif ((invocationSite instanceof Invocation) && mbk.typeVariables() != Binding.NO_TYPE_VARIABLES) {", "+\t\t\t\t\tif (((invocationSite instanceof Invocation) || (invocationSite instanceof ReferenceExpression))", "+\t\t\t\t\t\t\t&& mbk.typeVariables() != Binding.NO_TYPE_VARIABLES) ", "+\t\t\t\t\t{", "-\t\t\t\t\t\tInvocation invocation = (Invocation)invocationSite;", "-\t\t\t\t\t\tInferenceContext18 ic18 = new InferenceContext18(this, invocation.arguments(), invocation);", "-\t\t\t\t\t\tif (!ic18.isMoreSpecificThan(invocation, mbj, mbk, levelj == VARARGS_COMPATIBLE, levelk == VARARGS_COMPATIBLE)) {", "+\t\t\t\t\t\tExpression[] expressions = null;", "+\t\t\t\t\t\tif (invocationSite instanceof Invocation) {", "+\t\t\t\t\t\t\texpressions = ((Invocation)invocationSite).arguments();", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\texpressions = ((ReferenceExpression)invocationSite).createPseudoExpressions(argumentTypes);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tInferenceContext18 ic18 = new InferenceContext18(this, expressions, null);", "+\t\t\t\t\t\tif (!ic18.isMoreSpecificThan(mbj, mbk, levelj == VARARGS_COMPATIBLE, levelk == VARARGS_COMPATIBLE)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "404432c209c17c9fb488b691ee75401d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "dd10489904dda11a1b9c522a71a4705b9646605e", "commitAfterChange": "b0e8687830f97b9ddeb50b010730e5d2fdfd5916", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "signatureAfterChange": "  \tpublic Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException", "diff": ["+\t\tproper:", "-            \treturn (binding != null && binding.declaringClass.isCompatibleWith(this.right)) ? TRUE : FALSE;", "+            \treturn (binding != null && binding.declaringClass.isCompatibleWith(this.right, inferenceContext.scope)) ? TRUE : FALSE;", "+            } else if (this.left instanceof Invocation && this.left.isPolyExpression()) {", "+            \tInvocation invoc = (Invocation) this.left;", "+            \tMethodBinding binding = invoc.binding(this.right, false, null);", "+            \tif (binding instanceof ParameterizedGenericMethodBinding) {", "+            \t\tParameterizedGenericMethodBinding method = (ParameterizedGenericMethodBinding) binding;", "+\t\t\t\t\tInferenceContext18 leftCtx = invoc.getInferenceContext(method);", "+            \t\tif (leftCtx.stepCompleted < InferenceContext18.TYPE_INFERRED) {", "+            \t\t\tbreak proper; // fall through into nested inference below (not explicit in the spec!)", "+            \t\t}", "+            \t}"]}], "num": 12431}