{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "85f85878185e2ea0490b3dc2b2a7b0c9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25c277148ed5d5b25055fa1df4a47d81", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "924bb53fdc2b8abef6daacf4b8eb0fd3e9ce7fd5", "commitAfterChange": "a6002c5b8e946e1be020c41b3eb8e042f8637f31", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " public String[] getParameterNames() throws JavaModelException", "signatureAfterChange": " public String[] getParameterNames() throws JavaModelException", "diff": ["-\t// TODO (olivier) disable for now See https://bugs.eclipse.org/bugs/show_bug.cgi?id=117740", "-\tif (true) {", "-\t\t// produce fake ones", "-\t\treturn this.parameterNames = getRawParameterNames(paramCount);", "-\t}", "-\t\tString javadoc = null;", "-\t\ttry {", "-\t\t\tjavadoc = this.getAttachedJavadoc(null, \"UTF-8\"); //$NON-NLS-1$", "-\t\t} catch (JavaModelException e) {", "-\t\t\t// ignore", "-\t\t}", "-\t\tif (javadoc != null) {", "-\t\t\tfinal int indexOfOpenParen = javadoc.indexOf('(');", "+ \t\tString javadocContents = null;", "+ \t\tIType declaringType = this.getDeclaringType();", "+\t\tPerProjectInfo projectInfo = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(this.getJavaProject().getProject());", "+ \t\tsynchronized (projectInfo.javadocCache) {", "+ \t\t\tjavadocContents = (String) projectInfo.javadocCache.get(declaringType);", "+ \t\t\tif (javadocContents == null) {", "+ \t\t\t\tprojectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);", "+ \t\t\t}", "+ \t\t}", "+ \t\tif (javadocContents == null) {", "+ \t\t\tlong timeOut = 150; // default value", "+ \t\t\ttry {", "+ \t\t\t\tString option = this.getJavaProject().getOption(JavaCore.CODEASSIST_TIMEOUT_FOR_PARAMETER_NAMES, true);", "+ \t\t\t\tif (option != null) {", "+ \t\t\t\t\ttimeOut = Long.parseLong(option);", "+ \t\t\t\t}", "+ \t\t\t} catch(NumberFormatException e) {", "+ \t\t\t\t// ignore", "+ \t\t\t}", "+ \t\t\tfinal class ParametersNameCollector {", "+ \t\t\t\tString javadoc;", "+ \t\t\t\tpublic void setJavadoc(String s) {", "+ \t\t\t\t\tthis.javadoc = s;", "+ \t\t\t\t}", "+ \t\t\t\tpublic String getJavadoc() {", "+ \t\t\t\t\treturn this.javadoc;", "+ \t\t\t\t}", "+ \t \t\t}", "+ \t\t\t/*", "+ \t\t\t * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents", "+ \t\t\t */", "+\t \t\tfinal ParametersNameCollector nameCollector = new ParametersNameCollector();", "+\t\t\tThread collect = new Thread() {", "+\t\t\t\tpublic void run() {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tnameCollector.setJavadoc(BinaryMethod.this.getAttachedJavadoc(null, \"UTF-8\")); //$NON-NLS-1$", "+\t\t\t        } catch (JavaModelException e) {", "+\t \t\t        \t// ignore", "+\t \t\t        }", "+\t\t\t\t\tsynchronized(nameCollector) {", "+\t\t\t\t\t\tnameCollector.notify();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tcollect.start();", "+\t\t\tsynchronized(nameCollector) {", "+\t\t\t\ttry {", "+\t\t\t\t\tnameCollector.wait(timeOut);", "+\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\t// ignore", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tjavadocContents = nameCollector.getJavadoc();", "+ \t\t} else if (javadocContents != BinaryType.EMPTY_JAVADOC){", "+ \t\t\t// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type", "+ \t\t\tjavadocContents = extractJavadoc(declaringType, javadocContents);", "+ \t\t} else {", "+ \t\t\t// we don't want to set the parameter names", "+ \t\t\treturn getRawParameterNames(paramCount);", "+ \t\t}", "+\t\tif (javadocContents != null && javadocContents != BinaryType.EMPTY_JAVADOC) {", "+\t\t\tfinal int indexOfOpenParen = javadocContents.indexOf('(');", "-\t\t\t\tfinal int indexOfClosingParen = javadoc.indexOf(')', indexOfOpenParen);", "+\t\t\t\tfinal int indexOfClosingParen = javadocContents.indexOf(')', indexOfOpenParen);", "-\t\t\t\t\t\t\tjavadoc.substring(indexOfOpenParen + 1, indexOfClosingParen).toCharArray(),", "+\t\t\t\t\t\t\tjavadocContents.substring(indexOfOpenParen + 1, indexOfClosingParen).toCharArray(),"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b450a00e5cd591e69beba28a0df6901d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMethod.java", "commitBeforeChange": "05ffc45e7b8ab76e8a7e8ec987e52f6f3663e0c3", "commitAfterChange": "7c124cb865f103cbfba1919be3ee5fe920ce2ecf", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public String[] getParameterNames() throws JavaModelException", "signatureAfterChange": " public String[] getParameterNames() throws JavaModelException", "diff": ["- \t\tString javadocContents = null;", "- \t\tIType declaringType = this.getDeclaringType();", "+\t\tString javadocContents = null;", "+\t\tIType declaringType = this.getDeclaringType();", "- \t\tsynchronized (projectInfo.javadocCache) {", "- \t\t\tjavadocContents = (String) projectInfo.javadocCache.get(declaringType);", "- \t\t\tif (javadocContents == null) {", "- \t\t\t\tprojectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);", "- \t\t\t}", "- \t\t}", "- \t\tif (javadocContents == null) {", "- \t\t\tlong timeOut = 50; // default value", "- \t\t\ttry {", "- \t\t\t\tString option = this.getJavaProject().getOption(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, true);", "- \t\t\t\tif (option != null) {", "- \t\t\t\t\ttimeOut = Long.parseLong(option);", "- \t\t\t\t}", "- \t\t\t} catch(NumberFormatException e) {", "- \t\t\t\t// ignore", "- \t\t\t}", "- \t\t\tif (timeOut == 0) {", "- \t\t\t\t// don't try to fetch the values", "- \t\t\t\treturn this.parameterNames = getRawParameterNames(paramCount);", "- \t\t\t}", "- \t\t\tfinal class ParametersNameCollector {", "- \t\t\t\tString javadoc;", "- \t\t\t\tpublic void setJavadoc(String s) {", "- \t\t\t\t\tthis.javadoc = s;", "- \t\t\t\t}", "- \t\t\t\tpublic String getJavadoc() {", "- \t\t\t\t\treturn this.javadoc;", "- \t\t\t\t}", "- \t \t\t}", "- \t\t\t/*", "- \t\t\t * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents", "- \t\t\t */", "-\t \t\tfinal ParametersNameCollector nameCollector = new ParametersNameCollector();", "+\t\tsynchronized (projectInfo.javadocCache) {", "+\t\t\tjavadocContents = (String) projectInfo.javadocCache.get(declaringType);", "+\t\t\tif (javadocContents == null) {", "+\t\t\t\tprojectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);", "+\t\t\t}", "+\t\t}", "+\t\tif (javadocContents == null) {", "+\t\t\tlong timeOut = 50; // default value", "+\t\t\ttry {", "+\t\t\t\tString option = this.getJavaProject().getOption(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, true);", "+\t\t\t\tif (option != null) {", "+\t\t\t\t\ttimeOut = Long.parseLong(option);", "+\t\t\t\t}", "+\t\t\t} catch(NumberFormatException e) {", "+\t\t\t\t// ignore", "+\t\t\t}", "+\t\t\tif (timeOut == 0) {", "+\t\t\t\t// don't try to fetch the values", "+\t\t\t\treturn this.parameterNames = getRawParameterNames(paramCount);", "+\t\t\t}", "+\t\t\tfinal class ParametersNameCollector {", "+\t\t\t\tString javadoc;", "+\t\t\t\tpublic void setJavadoc(String s) {", "+\t\t\t\t\tthis.javadoc = s;", "+\t\t\t\t}", "+\t\t\t\tpublic String getJavadoc() {", "+\t\t\t\t\treturn this.javadoc;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t/*", "+\t\t\t * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents", "+\t\t\t */", "+\t\t\tfinal ParametersNameCollector nameCollector = new ParametersNameCollector();", "-\t\t\t        } catch (JavaModelException e) {", "-\t \t\t        \t// ignore", "-\t \t\t        }", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// ignore", "+\t\t\t\t\t}", "- \t\t} else if (javadocContents != BinaryType.EMPTY_JAVADOC){", "- \t\t\t// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type", "- \t\t\ttry {", "- \t\t\t\tjavadocContents = extractJavadoc(declaringType, javadocContents);", "- \t\t\t} catch(JavaModelException e) {", "- \t\t\t\t// ignore", "- \t\t\t}", "- \t\t} else {", "- \t\t\t// we don't want to set the parameter names", "- \t\t\treturn getRawParameterNames(paramCount);", "- \t\t}", "+\t\t} else if (javadocContents != BinaryType.EMPTY_JAVADOC){", "+\t\t\t// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type", "+\t\t\ttry {", "+\t\t\t\tjavadocContents = extractJavadoc(declaringType, javadocContents);", "+\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t// ignore", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// let's see if we can retrieve them from the debug infos", "+\t\t\tchar[][] argumentNames = info.getArgumentNames();", "+\t\t\tif (argumentNames != null && argumentNames.length == paramCount) {", "+\t\t\t\tString[] names = new String[paramCount];", "+\t\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\t\tnames[i] = new String(argumentNames[i]);", "+\t\t\t\t}", "+\t\t\t\treturn this.parameterNames = names;", "+\t\t\t}", "+\t\t\treturn getRawParameterNames(paramCount);", "+\t\t}", "+\t\t// let's see if we can retrieve them from the debug infos", "+\t\tchar[][] argumentNames = info.getArgumentNames();", "+\t\tif (argumentNames != null && argumentNames.length == paramCount) {", "+\t\t\tString[] names = new String[paramCount];", "+\t\t\tfor (int i = 0; i < paramCount; i++) {", "+\t\t\t\tnames[i] = new String(argumentNames[i]);", "+\t\t\t}", "+\t\t\treturn this.parameterNames = names;", "+\t\t}"]}], "num": 34865}