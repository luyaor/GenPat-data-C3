{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9df66700ffebb0d0e390367fb1e8ac6", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "096b65794363e16fe39bba7273051f59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredField.java", "commitBeforeChange": "7cfd16cce02bf6c15cc69b5ed56b855234dd7ed5", "commitAfterChange": "95a3577e20e21c393d791bf9201b4e713942cf20", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " public RecoveredElement updateOnOpeningBrace(int braceStart, int braceEnd)", "signatureAfterChange": " public RecoveredElement updateOnOpeningBrace(int braceStart, int braceEnd)", "diff": ["-\tif (this.fieldDeclaration.declarationSourceEnd == 0", "-\t\t&& (this.fieldDeclaration.type instanceof ArrayTypeReference || this.fieldDeclaration.type instanceof ArrayQualifiedTypeReference)", "-\t\t&& !this.alreadyCompletedFieldInitialization){", "-\t\tthis.bracketBalance++;", "-\t\treturn null; // no update is necessary\t(array initializer)", "+\tif (this.fieldDeclaration.declarationSourceEnd == 0) {", "+\t\tif (this.fieldDeclaration.type instanceof ArrayTypeReference || this.fieldDeclaration.type instanceof ArrayQualifiedTypeReference) {", "+\t\t\tif (!this.alreadyCompletedFieldInitialization) {", "+\t\t\t\tthis.bracketBalance++;", "+\t\t\t\treturn null; // no update is necessary\t(array initializer)", "+\t\t\t}", "+\t\t} else {  // https://bugs.eclipse.org/bugs/show_bug.cgi?id=308980", "+\t\t\t// in case an initializer bracket is opened in a non-array field", "+\t\t\t// eg. int field = {..", "+\t\t\tthis.bracketBalance++;", "+\t\t\treturn null; // no update is necessary\t(array initializer)", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a0635d32b611c590a971e0272f71c918", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMethod)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMethod)", "diff": ["-\tif (!this.type.isInterface())", "-\t\tif (method.declaringClass.isClass() || !this.type.implementsInterface(method.declaringClass, false))", "-\t\t\tif (otherMethod.declaringClass.isClass() || !this.type.implementsInterface(otherMethod.declaringClass, false))", "-\t\t\t\treturn true; // do not complain since the superclass already got blamed", "-", "+\t/* We used to have some checks here to see if we would have already blamed the super type and if so avoid blaming", "+\t   the current type again. I have gotten rid of them as they in fact short circuit error reporting in cases where", "+\t   they should not. This means that occasionally we would report the error twice - the diagnostics is valid however,", "+\t   albeit arguably redundant. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=334313. For an example of a test", "+\t   where we do this extra reporting see org.eclipse.jdt.core.tests.compiler.regression.MethodVerifyTest.test159()", "+\t */"]}], "num": 66817}