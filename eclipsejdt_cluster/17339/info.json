{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "23648c5952991a1fb97c1fc3d9bc85fa", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34567f66a32cf1b129cbb5fc4f3a5642", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "d5b9ab15bb3f769b7e2ac485fe6da55027818828", "commitAfterChange": "e98478cd38caef5e23457b8b0fdc364bf2846afc", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 4, "signatureBeforeChange": " \t\t  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "signatureAfterChange": "  \tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException", "diff": ["+\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "+", "+\t\tint modulo = 0; // should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "+\t\tint iToken = 0;", "+\t\tchar[] argName = null;", "+\t\tint ptr = astPtr;", "+\t\tint lptr = astLengthPtr;", "+", "+\t\t// Parse arguments declaration if method reference", "+\t\tnextArg : while (this.index < this.scanner.eofPosition) {", "+", "+\t\t\t// Read argument type reference", "+\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "+\t\t\tTypeReference typeRef;", "+\t\t\ttry {", "+\t\t\t\ttypeRef = parseQualifiedName(false);", "+\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tboolean firstArg = modulo == 0;", "+\t\t\tif (firstArg) { // verify position", "+\t\t\t\tif (iToken != 0)", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t} else if ((iToken % modulo) != 0) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tif (typeRef == null) {", "+\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "+\t\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\t\treturn msg;", "+\t\t\t\t}", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t\tiToken++;", "+", "+\t\t\t// Read possible array declaration", "+\t\t\tint dim = 0;", "+\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\tdim++;", "+\t\t\t\t}", "+\t\t\t\tlong pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;", "+\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "+\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "+\t\t\t\t} else {", "+\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "+\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read argument name", "+\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "+\t\t\t\tconsumeToken();", "+\t\t\t\tif (firstArg) { // verify position", "+\t\t\t\t\tif (iToken != 1)", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t} else if ((iToken % modulo) != 1) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "+\t\t\t\t\tif (!firstArg) {", "+\t\t\t\t\t\tbreak nextArg;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (argName != null) { // verify that no argument name is declared", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+", "+\t\t\t// Verify token position", "+\t\t\tif (firstArg) {", "+\t\t\t\tmodulo = iToken + 1;", "+\t\t\t} else {", "+\t\t\t\tif ((iToken % modulo) != (modulo - 1)) {", "+\t\t\t\t\tbreak nextArg;", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Read separator or end arguments declaration", "+\t\t\tint token = readToken();", "+\t\t\tchar[] name = argName == null ? new char[0] : argName;", "+\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner", "+\t\t\t\t\t\t.getCurrentTokenStartPosition()", "+\t\t\t\t\t\t- 1, typeRef);", "+\t\t\t\tpushOnAstStack(expr, firstArg);", "+\t\t\t\tconsumeToken();", "+\t\t\t\tiToken++;", "+\t\t\t} else if (token == TerminalTokens.TokenNameRPAREN) {", "+\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name,", "+\t\t\t\t\t\targStart,", "+\t\t\t\t\t\tthis.scanner.getCurrentTokenStartPosition()- 1,", "+\t\t\t\t\t\ttypeRef);", "+\t\t\t\tpushOnAstStack(expr, (iToken == (modulo - 1)));", "+\t\t\t\tint size = astLengthStack[astLengthPtr--];", "+\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "+\t\t\t\tfor (int i = (size - 1); i >= 0; i--) {", "+\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "+\t\t\t\t}", "+\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "+\t\t\t\tmsg.receiver = receiver;", "+\t\t\t\treturn msg;", "+\t\t\t} else {", "+\t\t\t\tbreak nextArg;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Invalid input: reset ast stacks pointers", "+\t\tconsumeToken();", "+\t\tif (iToken > 0) {", "+\t\t\tthis.astPtr = ptr;", "+\t\t\tthis.astLengthPtr = lptr;", "+\t\t}", "+\t\tthrow new InvalidInputException();", "+\t}", "-\tprivate AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {", "-", "-\t\tint modulo = 0;\t// should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)", "-\t\tint iToken = 0;", "-\t\tchar[] argName = null;", "-\t\tint ptr = astPtr;", "-\t\tint lptr = astLengthPtr;", "-", "-\t\t// Parse arguments declaration if method reference", "-\t\tnextArg: while (this.index < this.scanner.eofPosition) {", "-", "-\t\t\t// Read argument type reference", "-\t\t\tint argStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\tTypeReference typeRef;", "-\t\t\t\ttypeRef = parseQualifiedName(false);", "-\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\tbreak nextArg;", "-\t\t\tboolean firstArg = modulo == 0;", "-\t\t\tif (firstArg) { // verify position", "-\t\t\t\tif (iToken != 0) break nextArg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != 0) break nextArg;", "-\t\t\t}", "-\t\t\tif (typeRef == null) {", "-\t\t\t\tif (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);", "-\t\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\t\treturn msg;", "-\t\t\t\t} ", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t\tiToken++;", "-", "-\t\t\t// Read possible array declaration", "-\t\t\tint dim = 0;", "-\t\t\tif (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\twhile (readToken() == TerminalTokens.TokenNameLBRACKET) {", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tif (readToken() != TerminalTokens.TokenNameRBRACKET) {", "-\t\t\t\t\t\tbreak nextArg;", "-\t\t\t\t\t}", "-\t\t\t\t\tconsumeToken();", "-\t\t\t\t\tdim++;", "-\t\t\t\t}", "-\t\t\t\tlong pos = ((long)typeRef.sourceStart)<<32 + typeRef.sourceEnd;", "-\t\t\t\tif (typeRef instanceof AnnotationSingleTypeReference) {", "-\t\t\t\t\tAnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);", "-\t\t\t\t} else {", "-\t\t\t\t\tAnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;", "-\t\t\t\t\ttypeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Read argument name", "-\t\t\tif (readToken() == TerminalTokens.TokenNameIdentifier) {", "-\t\t\t\tconsumeToken();", "-\t\t\t\tif (firstArg) { // verify position", "-\t\t\t\t\tif (iToken != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\telse {", "-\t\t\t\t\tif ((iToken % modulo) != 1) break nextArg;", "-\t\t\t\t}", "-\t\t\t\tif (argName == null) { // verify that all arguments name are declared", "-\t\t\t\t\tif (!firstArg)  break nextArg;", "-\t\t\t\t}", "-\t\t\t\targName = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif (argName != null) { // verify that no argument name is declared", "-\t\t\t\t\tbreak nextArg;", "-\t\t\t\t}", "-\t\t\t}", "-", "-\t\t\t// Verify token position", "-\t\t\tif (firstArg) {", "-\t\t\t\tmodulo = iToken+1;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tif ((iToken % modulo) != (modulo-1)) break nextArg;", "-\t\t\t}", "-", "-\t\t\t// Read separator or end arguments declaration", "-\t\t\tint token = readToken();", "-\t\t\tchar[] name = argName==null ? new char[0] : argName;", "-\t\t\tif (token == TerminalTokens.TokenNameCOMMA) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, firstArg);", "-\t\t\t\tconsumeToken();", "-\t\t\t\tiToken++;", "-\t\t\t}", "-\t\t\telse if (token == TerminalTokens.TokenNameRPAREN) {", "-\t\t\t\tAnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);", "-\t\t\t\tpushOnAstStack(expr, (iToken==(modulo-1)));", "-\t\t\t\tint size = astLengthStack[astLengthPtr--];", "-\t\t\t\tAnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];", "-\t\t\t\tfor (int i=(size-1); i>=0; i--) {", "-\t\t\t\t\targuments[i] = (AnnotationArgumentExpression) astStack[astPtr--];", "-\t\t\t\t}", "-\t\t\t\tAnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);", "-\t\t\t\tmsg.receiver = receiver;", "-\t\t\t\treturn msg;", "-\t\t\t}", "-\t\t\telse {", "-\t\t\t\tbreak nextArg;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// Invalid input: reset ast stacks pointers", "-\t\tconsumeToken();", "-\t\tif (iToken > 0) {", "-\t\t\tthis.astPtr = ptr;", "-\t\t\tthis.astLengthPtr = lptr;", "-\t\t}", "-\t\tthrow new InvalidInputException();", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6913b4df3fde76f405df2bbd0bc98100", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/DeleteTests.java", "commitBeforeChange": "e7fbe3d2e46c3f4c5a40be9178ef6e8a36680f90", "commitAfterChange": "01f17876d50bd632100cd19774bf74ad112ea3f6", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " public void testDeleteMultipleMembersFromVariousCUs() throws CoreException", "signatureAfterChange": " public void testDeleteMultipleMembersFromVariousCUs() throws CoreException", "diff": ["-\tcreateFolder(\"P/a/b/c\");", "-\tcreateFile(", "-\t\t\"P/a/b/c/X.java\",", "-\t\t\"package a.b.c;\\n\" +", "-\t\t\"import java.util.Vector;\\n\" +", "-\t\t\"import java.util.Enumeration;\\n\" +", "-\t\t\"public class X {\\n\" +", "-\t\t\"  public static void main(String[] args) {\\n\" +", "-\t\t\"    System.out.println(\\\"Hello World\\\");\\n\" +", "-\t\t\"  }\\n\" +", "-\t\t\"  static class Bar {\\n\" +", "-\t\t\"    private final java.lang.String test = \\\"testminor\\\";\\n\" +", "-\t\t\"    public Bar() {\\n\" +", "-\t\t\"      super();\\n\" +", "-\t\t\"    }\\n\" +", "-\t\t\"    private void test() {\\n\" +", "-\t\t\"    }\\n\" +", "-\t\t\"  }\\n\" +", "-\t\t\"}\"", "-\t);", "-\tcreateFile(", "-\t\t\"P/a/b/Y.java\",", "-\t\t\"package a.b;\\n\" +", "-\t\t\"public class Y {\\n\" +", "-\t\t\"  int foo;\\n\" +", "-\t\t\"  public static void main(String[] args) {\\n\" +", "-\t\t\"    System.out.println(\\\"Hello World\\\");\\n\" +", "-\t\t\"  }\\n\" +", "-\t\t\"}\"", "-\t);", "-\t", "-\t// elements to be deleted:", "-\t// from a/b/c/X.java:", "-\t//   java.util.Vector", "-\t//\t  main", "-\t//   Bar (inner type)", "-\t//\t    Bar (constructor)", "-\t//\t    test", "-\t//   Bar (inner type, same as above)", "-", "-\t// from a/b/Y.java", "-\t//   foo", "-\t//   main", "-\t", "-\tICompilationUnit cuX = getCompilationUnit(\"P/a/b/c/X.java\");", "-\tIType typeX = cuX.getType(\"X\");", "-\tIType typeBar = typeX.getType(\"Bar\");", "-", "-\tIJavaElement[] toBeDeleted = new IJavaElement[8];", "-\ttoBeDeleted[0] = cuX.getImport(\"java.util.Vector\");", "-\ttoBeDeleted[1] = typeX.getMethod(\"main\", new String[] {\"[QString;\"});", "-\ttoBeDeleted[2] = typeBar;", "-\ttoBeDeleted[3] = typeBar.getMethod(\"Bar\", new String[] {});", "-\ttoBeDeleted[4] = typeBar.getMethod(\"test\", new String[] {});", "-\ttoBeDeleted[5] = typeBar;", "-\t", "-\tICompilationUnit cuY = getCompilationUnit(\"P/a/b/Y.java\");", "-\tIType typeY = cuY.getType(\"Y\");", "-\t", "-\ttoBeDeleted[6] = typeY.getField(\"foo\");", "-\ttoBeDeleted[7] = typeY.getMethod(\"main\", new String[] {\"[QString;\"});", "-\t", "+\t\tcreateFolder(\"P/a/b/c\");", "+\t\tcreateFile(", "+\t\t\t\"P/a/b/c/X.java\",", "+\t\t\t\"package a.b.c;\\n\" +", "+\t\t\t\"import java.util.Vector;\\n\" +", "+\t\t\t\"import java.util.Enumeration;\\n\" +", "+\t\t\t\"public class X {\\n\" +", "+\t\t\t\"  public static void main(String[] args) {\\n\" +", "+\t\t\t\"    System.out.println(\\\"Hello World\\\");\\n\" +", "+\t\t\t\"  }\\n\" +", "+\t\t\t\"  static class Bar {\\n\" +", "+\t\t\t\"    private final java.lang.String test = \\\"testminor\\\";\\n\" +", "+\t\t\t\"    public Bar() {\\n\" +", "+\t\t\t\"      super();\\n\" +", "+\t\t\t\"    }\\n\" +", "+\t\t\t\"    private void test() {\\n\" +", "+\t\t\t\"    }\\n\" +", "+\t\t\t\"  }\\n\" +", "+\t\t\t\"}\"", "+\t\t);", "+\t\tcreateFile(", "+\t\t\t\"P/a/b/Y.java\",", "+\t\t\t\"package a.b;\\n\" +", "+\t\t\t\"public class Y {\\n\" +", "+\t\t\t\"  int foo;\\n\" +", "+\t\t\t\"  public static void main(String[] args) {\\n\" +", "+\t\t\t\"    System.out.println(\\\"Hello World\\\");\\n\" +", "+\t\t\t\"  }\\n\" +", "+\t\t\t\"}\"", "+\t\t);", "+\t\t", "+\t\t// elements to be deleted:", "+\t\t// from a/b/c/X.java:", "+\t\t//   java.util.Vector", "+\t\t//\t  main", "+\t\t//   Bar (inner type)", "+\t\t//\t    Bar (constructor)", "+\t\t//\t    test", "+\t\t//   Bar (inner type, same as above)", "+\t", "+\t\t// from a/b/Y.java", "+\t\t//   foo", "+\t\t//   main", "+\t\t", "+\t\tICompilationUnit cuX = getCompilationUnit(\"P/a/b/c/X.java\");", "+\t\tIType typeX = cuX.getType(\"X\");", "+\t\tIType typeBar = typeX.getType(\"Bar\");", "+\t", "+\t\tIJavaElement[] toBeDeleted = new IJavaElement[8];", "+\t\ttoBeDeleted[0] = cuX.getImport(\"java.util.Vector\");", "+\t\ttoBeDeleted[1] = typeX.getMethod(\"main\", new String[] {\"[QString;\"});", "+\t\ttoBeDeleted[2] = typeBar;", "+\t\ttoBeDeleted[3] = typeBar.getMethod(\"Bar\", new String[] {});", "+\t\ttoBeDeleted[4] = typeBar.getMethod(\"test\", new String[] {});", "+\t\ttoBeDeleted[5] = typeBar;", "+\t\t", "+\t\tICompilationUnit cuY = getCompilationUnit(\"P/a/b/Y.java\");", "+\t\tIType typeY = cuY.getType(\"Y\");", "+\t\t", "+\t\ttoBeDeleted[6] = typeY.getField(\"foo\");", "+\t\ttoBeDeleted[7] = typeY.getMethod(\"main\", new String[] {\"[QString;\"});", "+\t"]}], "num": 17339}