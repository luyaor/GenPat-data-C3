{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "856394afd53007349a31cdf4b26b3a39", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ba9e496daaaff5b0c2260ecfdd2a6fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java", "commitBeforeChange": "da50a11f1737dbee3925e1da64ad7f9cbaff2e84", "commitAfterChange": "99342a278896e2f8caf142911ce817f7cc97d106", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public void resolve(BlockScope scope)", "signatureAfterChange": "\r \r public void bind(MethodScope scope, TypeBinding typeBinding, boolean used)", "diff": ["-public void resolve(BlockScope scope) {\r", "-\t// an argument may be final ==> cannot be assigned\r", "-\tsuper.resolve(scope);\r", "-\tbinding.isArgument = true;\r", "-\tbinding.used = true;\r", "+public void bind(MethodScope scope, TypeBinding typeBinding, boolean used) {\r", "+\tif (this.type != null) this.type.binding = typeBinding; // record the resolved type into the type reference\r", "+\tint modifierFlag = this.modifiers;\r", "+\tif ((this.binding = scope.duplicateName(this.name)) != null) {\r", "+\t\t//the name already exist....may carry on with the first binding ....\r", "+\t\tscope.problemReporter().redefineArgument(this);\r", "+\t} else {\r", "+\t\tscope.addLocalVariable(this.binding = new LocalVariableBinding(this.name, typeBinding, modifierFlag, true)); //true stand for argument instead of just local\r", "+\t\tif (isTypeUseDeprecated(typeBinding, scope))\r", "+\t\t\tscope.problemReporter().deprecatedType(typeBinding, this.type);\r", "+\t\tthis.binding.declaration = this;\r", "+\t\tthis.binding.used = used;\r", "+\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ace2285d55c8545d35b8957ab891fe48", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java", "commitBeforeChange": "c45031a708344453f01f911278a63ebae41b9cba", "commitAfterChange": "c49a7bd34f8c2781dba76984d24d83335183205f", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding genericType, int rank)", "signatureAfterChange": "  \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding genericType, int rank)", "diff": ["-\t\tresolveAnnotations(scope);", "-\t\tWildcardBinding wildcard = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);", "-\t\treturn this.resolvedType = wildcard;", "+\t\tthis.resolvedType = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);", "+\t\tresolveAnnotations(scope);", "+\t\tif (boundType != null && boundType.hasNullTypeAnnotations() && this.resolvedType.hasNullTypeAnnotations()) {", "+\t\t\tif (((boundType.tagBits | this.resolvedType.tagBits) & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) { // are both set?", "+\t\t\t\tAnnotation annotation = this.bound.findAnnotation(boundType.tagBits & TagBits.AnnotationNullMASK);", "+\t\t\t\tscope.problemReporter().contradictoryNullAnnotationsOnBounds(annotation, this.resolvedType.tagBits);", "+\t\t\t\tthis.resolvedType = this.resolvedType.unannotated();", "+\t\t\t\tthis.bound.resolvedType = ((WildcardBinding)this.resolvedType).bound = boundType.unannotated();", "+\t\t\t}", "+\t\t}", "+\t\treturn this.resolvedType;"]}], "num": 8625}