{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4f266b6cb036d659ef75683f861ee89c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "059d209aa95914a9f8544791c56456c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FloatLiteral.java", "commitBeforeChange": "e366dcd1a6233f6a837e263c2cd88adca7cd095d", "commitAfterChange": "2d7d13f61421f5cdd98db8e6cd189ee1894e9387", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void computeConstant()", "signatureAfterChange": " \tpublic void computeConstant()", "diff": ["-\t\t//the source is correctly formated so the exception should never occurs", "-\t\t\t/*", "-\t\t\t * this can happen if this is an hexadecimal floating-point literal and the libraries used ", "-\t\t\t * are < 1.5", "-\t\t\t */", "-\t\t\tcomputedValue = new Float(Util.getFloatingPoint(source));", "+\t\t\t// hex floating point literal", "+\t\t\t// being rejected by 1.4 libraries where Float.valueOf(...) doesn't handle hex decimal floats", "+\t\t\ttry {", "+\t\t\t\tfloat v = FloatUtil.valueOfHexFloatLiteral(source);", "+\t\t\t\tif (v == Float.POSITIVE_INFINITY) {", "+\t\t\t\t\t// error: the number is too large to represent", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tif (Float.isNaN(v)) {", "+\t\t\t\t\t// error: the number is too small to represent", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tvalue = v;", "+\t\t\t\tconstant = Constant.fromValue(v);", "+\t\t\t} catch (NumberFormatException e1) {", "+\t\t\t\t// if the computation of the constant fails", "+\t\t\t}", "+\t\t\treturn;", "-\t\tif (computedValue.doubleValue() > Float.MAX_VALUE) {", "-\t\t\treturn; //may be Infinity", "+\t\tfinal float floatValue = computedValue.floatValue();", "+\t\tif (floatValue > Float.MAX_VALUE) {", "+\t\t\t// error: the number is too large to represent", "+\t\t\treturn;", "-\t\tif (computedValue.floatValue() < Float_MIN_VALUE) {", "+\t\tif (floatValue < Float.MIN_VALUE) {", "-\t\t\t//only a true 0 can be made of zeros", "-\t\t\t//1.00000000e-46f is illegal ....", "-\t\t\tlabel : for (int i = 0; i < source.length; i++) {", "+\t\t\t// a true 0 only has '0' and '.' in mantissa", "+\t\t\t// 1.0e-5000d is non-zero, but underflows to 0", "+\t\t\tboolean isHexaDecimal = false;", "+\t\t\tlabel : for (int i = 0; i < source.length; i++) { //it is welled formated so just test against '0' and potential . D d  ", "-\t\t\t\t\tcase '.' :", "-\t\t\t\t\tcase 'f' :", "-\t\t\t\t\tcase 'F' :", "+\t\t\t\t\tcase '.' :", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tisHexaDecimal = true;", "+\t\t\t\t\tcase 'f' :", "+\t\t\t\t\tcase 'F' :", "+\t\t\t\t\tcase 'd' :", "+\t\t\t\t\tcase 'D' :", "+\t\t\t\t\t\tif (isHexaDecimal) {", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// starting the exponent - mantissa is all zero", "+\t\t\t\t\t\t// no exponent - mantissa is all zero", "+\t\t\t\t\t\tbreak label;", "-\t\t\t\t\t\tbreak label; //exposant are valid !....", "+\t\t\t\t\t\tbreak label;", "-\t\t\t\t\t\treturn; //error", "+\t\t\t\t\t\t// error: the number is too small to represent", "+\t\t\t\t\t\treturn;", "-\t\tconstant = Constant.fromValue(value = computedValue.floatValue());", "+\t\tvalue = floatValue;", "+\t\tconstant = Constant.fromValue(value);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c98223e245be64a79803965d1d3c9c2c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoubleLiteral.java", "commitBeforeChange": "e366dcd1a6233f6a837e263c2cd88adca7cd095d", "commitAfterChange": "2d7d13f61421f5cdd98db8e6cd189ee1894e9387", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void computeConstant()", "signatureAfterChange": " \tpublic void computeConstant()", "diff": ["-\t\t//the source is correctly formated so the exception should never occurs", "-\t\t\t/*", "-\t\t\t * this can happen if this is an hexadecimal floating-point literal and the libraries used ", "-\t\t\t * are < 1.5", "-\t\t\t */", "-\t\t\tcomputedValue = new Double(Util.getFloatingPoint(source));", "+\t\t\t// hex floating point literal", "+\t\t\t// being rejected by 1.4 libraries where Double.valueOf(...) doesn't handle hex decimal floats", "+\t\t\ttry {", "+\t\t\t\tdouble v = FloatUtil.valueOfHexDoubleLiteral(source);", "+\t\t\t\tif (v == Double.POSITIVE_INFINITY) {", "+\t\t\t\t\t// error: the number is too large to represent", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tif (Double.isNaN(v)) {", "+\t\t\t\t\t// error: the number is too small to represent", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t\tvalue = v;", "+\t\t\t\tconstant = Constant.fromValue(v);", "+\t\t\t} catch (NumberFormatException e1) {", "+\t\t\t\t// if the computation of the constant fails", "+\t\t\t}", "+\t\t\treturn;", "-\t\tif (doubleValue > Double.MAX_VALUE)", "-\t\t\treturn; //may be Infinity", "-\t\tif (doubleValue < Double.MIN_VALUE) { //only a true 0 can be made of zeros", "-\t\t\t//2.00000000000000000e-324 is illegal .... ", "+\t\tif (doubleValue > Double.MAX_VALUE) {", "+\t\t\t// error: the number is too large to represent", "+\t\t\treturn;", "+\t\t}", "+\t\tif (doubleValue < Double.MIN_VALUE) {", "+\t\t\t// see 1F6IGUU", "+\t\t\t// a true 0 only has '0' and '.' in mantissa", "+\t\t\t// 1.0e-5000d is non-zero, but underflows to 0", "+\t\t\tboolean isHexaDecimal = false;", "-\t\t\t\t\tcase 'd' :", "-\t\t\t\t\tcase 'D' :", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tisHexaDecimal = true;", "+\t\t\t\t\tcase 'f' :", "+\t\t\t\t\tcase 'F' :", "+\t\t\t\t\tcase 'd' :", "+\t\t\t\t\tcase 'D' :", "+\t\t\t\t\t\tif (isHexaDecimal) {", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// starting the exponent - mantissa is all zero", "+\t\t\t\t\t\t// no exponent - mantissa is all zero", "+\t\t\t\t\t\tbreak label;", "-\t\t\t\t\t\tbreak label; //exposant are valid....!", "+\t\t\t\t\t\tbreak label;", "+\t\t\t\t\t\t// error: the number is too small to represent", "-\t\t} //error", "-", "-\t\tconstant = Constant.fromValue(value = doubleValue);", "+\t\t}", "+\t\tvalue = doubleValue;", "+\t\tconstant = Constant.fromValue(value);"]}], "num": 19975}