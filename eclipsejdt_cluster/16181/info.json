{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "702301f11dc879c3f4f0580efc1b8090", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0133dc31f33e40cc12bda391cb1e399d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType)", "signatureAfterChange": " public void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType)", "diff": ["-\t */", "-\tpublic void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType) {", "-\t\tif (runtimeTimeType == null || compileTimeType == null)", "-\t\t\treturn;\t\t\t\t", "-\t\tif ((bits & Binding.FIELD) != 0 && this.binding != null && this.binding.isValidBinding()) {", "-\t\t\t// set the generic cast after the fact, once the type expectation is fully known (no need for strict cast)", "-\t\t\tFieldBinding field = (FieldBinding) this.binding;", "-\t\t\tFieldBinding originalBinding = field.original();", "-\t\t\tTypeBinding originalType = originalBinding.type;", "-\t\t    // extra cast needed if method return type is type variable", "-\t\t\tif (originalBinding != field ", "-\t\t\t\t\t&& originalType != field.type", "-\t\t\t\t\t&& runtimeTimeType.id != T_JavaLangObject", "-\t\t\t\t\t&& (originalType.tagBits & TagBits.HasTypeVariable) != 0) {", "-\t\t    \tTypeBinding targetType = (!compileTimeType.isBaseType() && runtimeTimeType.isBaseType()) ", "-\t\t    \t\t? compileTimeType  // unboxing: checkcast before conversion", "-\t\t    \t\t: runtimeTimeType;", "-\t\t        this.genericCast = originalType.genericCast(scope.boxing(targetType));", "-\t\t        if (this.genericCast instanceof ReferenceBinding) {", "-\t\t\t\t\tReferenceBinding referenceCast = (ReferenceBinding) this.genericCast;", "-\t\t\t\t\tif (!referenceCast.canBeSeenBy(scope)) {", "-\t\t\t        \tscope.problemReporter().invalidType(this, ", "-\t\t\t        \t\t\tnew ProblemReferenceBinding(", "-\t\t\t\t\t\t\t\t\tCharOperation.splitOn('.', referenceCast.shortReadableName()),", "-\t\t\t\t\t\t\t\t\treferenceCast,", "-\t\t\t\t\t\t\t\t\tProblemReasons.NotVisible));", "-\t\t\t\t\t}", "-\t\t        }\t\t\t\t        ", "-\t\t\t} \t", "-\t\t}", "-\t\tsuper.computeConversion(scope, runtimeTimeType, compileTimeType);", "-\t}\t", "+ */", "+public void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType) {", "+\tif (runtimeTimeType == null || compileTimeType == null)", "+\t\treturn;\t\t\t\t", "+\tif ((this.bits & Binding.FIELD) != 0 && this.binding != null && this.binding.isValidBinding()) {", "+\t\t// set the generic cast after the fact, once the type expectation is fully known (no need for strict cast)", "+\t\tFieldBinding field = (FieldBinding) this.binding;", "+\t\tFieldBinding originalBinding = field.original();", "+\t\tTypeBinding originalType = originalBinding.type;", "+\t    // extra cast needed if method return type is type variable", "+\t\tif (originalBinding != field ", "+\t\t\t\t&& originalType != field.type", "+\t\t\t\t&& runtimeTimeType.id != TypeIds.T_JavaLangObject", "+\t\t\t\t&& (originalType.tagBits & TagBits.HasTypeVariable) != 0) {", "+\t    \tTypeBinding targetType = (!compileTimeType.isBaseType() && runtimeTimeType.isBaseType()) ", "+\t    \t\t? compileTimeType  // unboxing: checkcast before conversion", "+\t    \t\t: runtimeTimeType;", "+\t        this.genericCast = originalType.genericCast(scope.boxing(targetType));", "+\t        if (this.genericCast instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding referenceCast = (ReferenceBinding) this.genericCast;", "+\t\t\t\tif (!referenceCast.canBeSeenBy(scope)) {", "+\t\t        \tscope.problemReporter().invalidType(this, ", "+\t\t        \t\t\tnew ProblemReferenceBinding(", "+\t\t\t\t\t\t\t\tCharOperation.splitOn('.', referenceCast.shortReadableName()),", "+\t\t\t\t\t\t\t\treferenceCast,", "+\t\t\t\t\t\t\t\tProblemReasons.NotVisible));", "+\t\t\t\t}", "+\t        }\t\t\t\t        ", "+\t\t} \t", "+\t}", "+\tsuper.computeConversion(scope, runtimeTimeType, compileTimeType);", "+}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d236a54e32322db29264a734c8086b4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType)", "signatureAfterChange": " public void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType)", "diff": ["-\t */", "-\tpublic void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType) {", "-\t\tif (runtimeTimeType == null || compileTimeType == null)", "-\t\t\treturn;\t\t", "-\t\t// set the generic cast after the fact, once the type expectation is fully known (no need for strict cast)", "-\t\tFieldBinding field = null;", "-\t\tint length = this.otherBindings == null ? 0 : this.otherBindings.length;", "-\t\tif (length == 0) {", "-\t\t\tif ((this.bits & Binding.FIELD) != 0 && this.binding != null && this.binding.isValidBinding()) {", "-\t\t\t\tfield = (FieldBinding) this.binding;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tfield  = this.otherBindings[length-1];", "-\t\t}", "-\t\tif (field != null) {", "-\t\t\tFieldBinding originalBinding = field.original();", "-\t\t\tTypeBinding originalType = originalBinding.type;", "-\t\t    // extra cast needed if method return type has type variable", "-\t\t\tif (originalBinding != field ", "-\t\t\t\t\t&& originalType != field.type", "-\t\t\t    \t&& runtimeTimeType.id != T_JavaLangObject", "-\t\t\t    \t&& (originalType.tagBits & TagBits.HasTypeVariable) != 0) {", "-\t\t    \tTypeBinding targetType = (!compileTimeType.isBaseType() && runtimeTimeType.isBaseType()) ", "-\t\t    \t\t? compileTimeType  // unboxing: checkcast before conversion", "-\t\t    \t\t: runtimeTimeType;", "-\t\t    \tsetGenericCast(length, originalType.genericCast(targetType));", "-\t\t\t} \t", "-\t\t}", "-\t\tsuper.computeConversion(scope, runtimeTimeType, compileTimeType);", "-\t}", "+ */", "+public void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType) {", "+\tif (runtimeTimeType == null || compileTimeType == null)", "+\t\treturn;\t\t", "+\t// set the generic cast after the fact, once the type expectation is fully known (no need for strict cast)", "+\tFieldBinding field = null;", "+\tint length = this.otherBindings == null ? 0 : this.otherBindings.length;", "+\tif (length == 0) {", "+\t\tif ((this.bits & Binding.FIELD) != 0 && this.binding != null && this.binding.isValidBinding()) {", "+\t\t\tfield = (FieldBinding) this.binding;", "+\t\t}", "+\t} else {", "+\t\tfield  = this.otherBindings[length-1];", "+\t}", "+\tif (field != null) {", "+\t\tFieldBinding originalBinding = field.original();", "+\t\tTypeBinding originalType = originalBinding.type;", "+\t    // extra cast needed if method return type has type variable", "+\t\tif (originalBinding != field ", "+\t\t\t\t&& originalType != field.type", "+\t\t    \t&& runtimeTimeType.id != TypeIds.T_JavaLangObject", "+\t\t    \t&& (originalType.tagBits & TagBits.HasTypeVariable) != 0) {", "+\t    \tTypeBinding targetType = (!compileTimeType.isBaseType() && runtimeTimeType.isBaseType()) ", "+\t    \t\t? compileTimeType  // unboxing: checkcast before conversion", "+\t    \t\t: runtimeTimeType;", "+\t    \tsetGenericCast(length, originalType.genericCast(targetType));", "+\t\t} \t", "+\t}", "+\tsuper.computeConversion(scope, runtimeTimeType, compileTimeType);", "+}"]}], "num": 16181}