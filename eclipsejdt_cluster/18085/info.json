{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "afd57713ee335412750f080dd1f7c373", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8ddd5566dd0853655dbe645080b11fa6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java", "commitBeforeChange": "1111836d0685bb4771145e4e9ae98946f97841ba", "commitAfterChange": "2401f89c1204c75ca8439111af06317b0964f8ae", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 66, "signatureBeforeChange": " public static ITypeHierarchy load(IType type, InputStream input) throws JavaModelException", "signatureAfterChange": " public static ITypeHierarchy load(IType type, InputStream input) throws JavaModelException", "diff": ["+ */", "+public static ITypeHierarchy load(IType type, InputStream input) throws JavaModelException {", "+\ttry {", "+\t\tTypeHierarchy typeHierarchy = new TypeHierarchy();", "+\t\ttypeHierarchy.initialize(1);", "+\t\t", "+\t\tIType[] types = new IType[SIZE];", "+\t\tint typeCount = 0;", "+\t\t", "+\t\tbyte version = (byte)input.read();", "+\t", "+\t\tif(version != VERSION) {", "+\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "+\t\t}", "+\t\tbyte generalInfo = (byte)input.read();", "+\t\tif((generalInfo & COMPUTE_SUBTYPES) != 0) {", "+\t\t\ttypeHierarchy.computeSubtypes = true;", "+\t\t}", "+\t\t", "+\t\tbyte b;", "+\t\tbyte[] bytes;", "+\t\tint length;", "+\t\t", "+\t\t// read project", "+\t\tlength = 0;", "+\t\tbytes = new byte[SIZE];", "+\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "+\t\t\tif(bytes.length == length) {", "+\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);;", "+\t\t\t}", "+\t\t\tbytes[length++]=(byte)b;", "+\t\t}", "+\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\tif(length > 0) {", "+\t\t\ttypeHierarchy.project = (IJavaProject)JavaCore.create(new String(bytes));", "+\t\t\ttypeHierarchy.scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {typeHierarchy.project});", "+\t\t} else {", "+\t\t\ttypeHierarchy.project = null;", "+\t\t\ttypeHierarchy.scope = SearchEngine.createWorkspaceScope();", "+\t\t}", "+\t\t", "+\t\t// read missing type", "+\t\tlength = 0;", "+\t\tbytes = new byte[SIZE];", "+\t\tdo {", "+\t\t\tb = (byte)input.read();", "+\t\t\t", "+\t\t\tif(bytes.length == length) {", "+\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);;", "+\t\t\t}", "+\t", "+\t\t\tif(b == SEPARATOR1 || b == SEPARATOR2) {", "+\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);;", "+\t\t\t\ttypeHierarchy.missingTypes.add(new String(bytes));", "+\t\t\t\tlength = 0;", "+\t\t\t} else {", "+\t\t\t\tbytes[length++] = b;", "+\t\t\t}", "+\t\t} while(b != SEPARATOR1);", "+", "+\t\t", "+", "+\t\t// read types", "+\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 1;", "+\t\t\tbytes[0]=(byte)b;", "+\t\t\t", "+\t\t\t// read type memento", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR4){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\tIType element = (IType)JavaCore.create(new String(bytes));", "+\t\t\t", "+\t\t\tif(types.length == typeCount) {", "+\t\t\t\tSystem.arraycopy(types, 0, types = new IType[typeCount * 2], 0, typeCount);", "+\t\t\t}", "+\t\t\ttypes[typeCount++] = element;", "+\t\t\t", "+\t\t\t// read flags", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 0;", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR4){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\t", "+\t\t\tInteger flags = bytesToFlags(bytes);", "+\t\t\tif(flags != null) {", "+\t\t\t\ttypeHierarchy.cacheFlags(element, flags.intValue());", "+\t\t\t}", "+\t\t\t", "+\t\t\t// read info", "+\t\t\tbyte info = (byte)input.read();", "+\t\t\t", "+\t\t\t", "+\t\t\tif((info & INTERFACE) != 0) {", "+\t\t\t\ttypeHierarchy.addInterface(element);", "+\t\t\t}", "+\t\t\tif((info & COMPUTED_FOR) != 0) {", "+\t\t\t\tif(!element.equals(type)) {", "+\t\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR)); ", "+\t\t\t\t}", "+\t\t\t\ttypeHierarchy.type = element;", "+\t\t\t}", "+\t\t\tif((info & ROOT) != 0) {", "+\t\t\t\ttypeHierarchy.addRootClass(element);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// read super class", "+\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 1;", "+\t\t\tbytes[0]=(byte)b;", "+\t\t\t", "+\t\t\t// read type", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR3){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\tint subClass = new Integer(new String(bytes)).intValue();", "+\t\t\t", "+\t\t\t// read super type", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 0;", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR1){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\tint superClass = new Integer(new String(bytes)).intValue();", "+\t\t\t", "+\t\t\ttypeHierarchy.cacheSuperclass(", "+\t\t\t\ttypes[subClass],", "+\t\t\t\ttypes[superClass]);", "+\t\t}", "+\t\t", "+\t\t// read super interface", "+\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 1;", "+\t\t\tbytes[0]=(byte)b;", "+\t\t\t", "+\t\t\t// read type", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR3){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\tint subClass = new Integer(new String(bytes)).intValue();", "+\t\t\t", "+\t\t\t// read super interface", "+\t\t\tbytes = new byte[SIZE];", "+\t\t\tlength = 0;", "+\t\t\twhile((b = (byte)input.read()) != SEPARATOR1){", "+\t\t\t\tif(bytes.length == length) {", "+\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "+\t\t\t\t}", "+\t\t\t\tbytes[length++]=(byte)b;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "+\t\t\tIType[] superInterfaces = new IType[(bytes.length / 2) + 1];", "+\t\t\tint interfaceCount = 0;", "+\t\t\t", "+\t\t\tint j = 0;", "+\t\t\tbyte[] b2;", "+\t\t\tfor (int i = 0; i < bytes.length; i++) {", "+\t\t\t\tif(bytes[i] == SEPARATOR2){", "+\t\t\t\t\tb2 = new byte[i - j];", "+\t\t\t\t\tSystem.arraycopy(bytes, j, b2, 0, i - j);", "+\t\t\t\t\tj = i + 1;", "+\t\t\t\t\tsuperInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tb2 = new byte[bytes.length - j];", "+\t\t\tSystem.arraycopy(bytes, j, b2, 0, bytes.length - j);", "+\t\t\tsuperInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];", "+\t\t\t", "+\t\t\ttypeHierarchy.cacheSuperInterfaces(", "+\t\t\t\ttypes[subClass],", "+\t\t\t\tsuperInterfaces);", "+\t\t}", "+\t\treturn typeHierarchy;", "+\t} catch(IOException e){", "+\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "+\t}", "+}", "- */", "-public static ITypeHierarchy load(IType type, InputStream input) throws JavaModelException {", "-\ttry {", "-\t\tTypeHierarchy typeHierarchy = new TypeHierarchy();", "-\t\ttypeHierarchy.initialize(1);", "-\t\t", "-\t\tIType[] types = new IType[10];", "-\t\tint typeCount = 0;", "-\t\t", "-\t\tbyte version = (byte)input.read();", "-\t", "-\t\tif(version != VERSION) {", "-\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "-\t\t}", "-\t\tbyte generalInfo = (byte)input.read();", "-\t\tif((generalInfo & COMPUTE_SUBTYPES) != 0) {", "-\t\t\ttypeHierarchy.computeSubtypes = true;", "-\t\t}", "-\t\t", "-\t\tbyte b;", "-\t\tbyte[] bytes;", "-\t\tint length;", "-\t\t", "-\t\t// read project", "-\t\tlength = 0;", "-\t\tbytes = new byte[10];", "-\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "-\t\t\tif(bytes.length == length) {", "-\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);;", "-\t\t\t}", "-\t\t\tbytes[length++]=(byte)b;", "-\t\t}", "-\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\tif(length > 0) {", "-\t\t\ttypeHierarchy.project = (IJavaProject)JavaCore.create(new String(bytes));", "-\t\t\ttypeHierarchy.scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {typeHierarchy.project});", "-\t\t} else {", "-\t\t\ttypeHierarchy.project = null;", "-\t\t\ttypeHierarchy.scope = SearchEngine.createWorkspaceScope();", "-\t\t}", "-\t\t", "-\t\t// read missing type", "-\t\tlength = 0;", "-\t\tbytes = new byte[10];", "-\t\tdo {", "-\t\t\tb = (byte)input.read();", "-\t\t\t", "-\t\t\tif(bytes.length == length) {", "-\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);;", "-\t\t\t}", "-\t", "-\t\t\tif(b == SEPARATOR1 || b == SEPARATOR2) {", "-\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);;", "-\t\t\t\ttypeHierarchy.missingTypes.add(new String(bytes));", "-\t\t\t\tlength = 0;", "-\t\t\t} else {", "-\t\t\t\tbytes[length++] = b;", "-\t\t\t}", "-\t\t} while(b != SEPARATOR1);", "-", "-\t\t", "-", "-\t\t// read types", "-\t\tint count = 0;", "-\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 1;", "-\t\t\tbytes[0]=(byte)b;", "-\t\t\t", "-\t\t\t// read type memento", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR4){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\tIType element = (IType)JavaCore.create(new String(bytes));", "-\t\t\t", "-\t\t\tif(types.length == typeCount) {", "-\t\t\t\tSystem.arraycopy(types, 0, types = new IType[typeCount * 2], 0, typeCount);", "-\t\t\t}", "-\t\t\ttypes[count++] = element;", "-\t\t\t", "-\t\t\t// read flags", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 0;", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR4){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\t", "-\t\t\tInteger flags = bytesToFlags(bytes);", "-\t\t\tif(flags != null) {", "-\t\t\t\ttypeHierarchy.cacheFlags(element, flags.intValue());", "-\t\t\t}", "-\t\t\t", "-\t\t\t// read info", "-\t\t\tbyte info = (byte)input.read();", "-\t\t\t", "-\t\t\t", "-\t\t\tif((info & INTERFACE) != 0) {", "-\t\t\t\ttypeHierarchy.addInterface(element);", "-\t\t\t}", "-\t\t\tif((info & COMPUTED_FOR) != 0) {", "-\t\t\t\tif(!element.equals(type)) {", "-\t\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR)); ", "-\t\t\t\t}", "-\t\t\t\ttypeHierarchy.type = element;", "-\t\t\t}", "-\t\t\tif((info & ROOT) != 0) {", "-\t\t\t\ttypeHierarchy.addRootClass(element);", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// read super class", "-\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 1;", "-\t\t\tbytes[0]=(byte)b;", "-\t\t\t", "-\t\t\t// read type", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR3){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\tint subClass = new Integer(new String(bytes)).intValue();", "-\t\t\t", "-\t\t\t// read super type", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 0;", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR1){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\tint superClass = new Integer(new String(bytes)).intValue();", "-\t\t\t", "-\t\t\ttypeHierarchy.cacheSuperclass(", "-\t\t\t\ttypes[subClass],", "-\t\t\t\ttypes[superClass]);", "-\t\t}", "-\t\t", "-\t\t// read super interface", "-\t\twhile((b = (byte)input.read()) != SEPARATOR1) {", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 1;", "-\t\t\tbytes[0]=(byte)b;", "-\t\t\t", "-\t\t\t// read type", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR3){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\tint subClass = new Integer(new String(bytes)).intValue();", "-\t\t\t", "-\t\t\t// read super interface", "-\t\t\tbytes = new byte[10];", "-\t\t\tlength = 0;", "-\t\t\twhile((b = (byte)input.read()) != SEPARATOR1){", "-\t\t\t\tif(bytes.length == length) {", "-\t\t\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length*2], 0, length);", "-\t\t\t\t}", "-\t\t\t\tbytes[length++]=(byte)b;", "-\t\t\t}", "-\t\t\tSystem.arraycopy(bytes, 0, bytes = new byte[length], 0, length);", "-\t\t\tIType[] superInterfaces = new IType[(bytes.length / 2) + 1];", "-\t\t\tint interfaceCount = 0;", "-\t\t\t", "-\t\t\tint j = 0;", "-\t\t\tbyte[] b2;", "-\t\t\tfor (int i = 0; i < bytes.length; i++) {", "-\t\t\t\tif(bytes[i] == SEPARATOR2){", "-\t\t\t\t\tb2 = new byte[i - j];", "-\t\t\t\t\tSystem.arraycopy(bytes, j, b2, 0, i - j);", "-\t\t\t\t\tj = i + 1;", "-\t\t\t\t\tsuperInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tb2 = new byte[bytes.length - j];", "-\t\t\tSystem.arraycopy(bytes, j, b2, 0, bytes.length - j);", "-\t\t\tsuperInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];", "-\t\t\t", "-\t\t\ttypeHierarchy.cacheSuperInterfaces(", "-\t\t\t\ttypes[subClass],", "-\t\t\t\tsuperInterfaces);", "-\t\t}", "-\t\treturn typeHierarchy;", "-\t} catch(IOException e){", "-\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "-\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f9a636e6d9f29001bcb0fd8f371fd021", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java", "commitBeforeChange": "d5c3de1bf49901f78640f1692fd5e63eca3fdc62", "commitAfterChange": "59d1426d6ce986de5d867421d1fe44ed55b3b34c", "methodNumberBeforeChange": 307, "methodNumberAfterChange": 307, "signatureBeforeChange": " \tpublic void test0660() throws JavaModelException", "signatureAfterChange": " \tpublic void test0660() throws JavaModelException", "diff": ["-\t\t\tString key = variableBinding.getKey();", "+\t\t\t// String key = variableBinding.getKey();", "-\t\t\tnode = getASTNode(unit, 0, 0, 1);", "+\t\t\tnode = getASTNode(unit, 0, 0, 0);", "-\t\t\tString key2 = variableBinding.getKey();", "-\t\t\tassertFalse(\"Keys should not be equals\", key2.equals(key));", "+\t\t\t// String key2 = variableBinding.getKey();", "+\t\t\t//assertFalse(\"Keys should not be equals\", key2.equals(key));"]}], "num": 18085}