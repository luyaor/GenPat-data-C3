{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9e74177dc2eb71061fc243261034cb85", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36d60e1d0b3bac94604ed709b9eb4f08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "ba0154713ba7d434aa2e47b80fd55a84048c10dc", "commitAfterChange": "c691caa0dc4c5d86bd6e9b8bfd831e689219e521", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tInsideSubRoutineFlowContext insideSubContext;", "-\t\tFinallyFlowContext finallyContext;", "-\t\tUnconditionalFlowInfo subInfo;", "-\t\t\t// no finally block", "-\t\t\tinsideSubContext = null;", "-\t\t\tfinallyContext = null;", "-\t\t\tsubInfo = null;", "+\t\t\t// no finally block -- this is a simplified copy of the else part", "+\t\t\t// process the try block in a context handling the local exceptions.", "+\t\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\t\tflowContext,", "+\t\t\t\t\tthis.tryBlock,", "+\t\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\t\tthis.scope,", "+\t\t\t\t\tflowInfo.unconditionalInits());", "+\t", "+\t\t\tFlowInfo tryInfo;", "+\t\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\t\ttryInfo = flowInfo;", "+\t\t\t\tthis.tryBlockExit = false;", "+\t\t\t} else {", "+\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t}", "+\t", "+\t\t\t// check unreachable catch blocks", "+\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+\t", "+\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\t\tif (this.catchArguments != null) {", "+\t\t\t\tint catchCount;", "+\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+\t", "+\t\t\t\t\t// catch var is always set", "+\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t\t/*", "+\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t\t}", "+\t\t\t\t\tcatchInfo =", "+\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tflowContext,", "+\t\t\t\t\t\t\tcatchInfo);", "+\t\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "+\t\t\treturn tryInfo;", "+\t\t\tInsideSubRoutineFlowContext insideSubContext;", "+\t\t\tFinallyFlowContext finallyContext;", "+\t\t\tUnconditionalFlowInfo subInfo;", "-\t\t}", "-\t\t// process the try block in a context handling the local exceptions.", "-\t\tExceptionHandlingFlowContext handlingContext =", "-\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\tinsideSubContext == null ? flowContext : insideSubContext,", "-\t\t\t\tthis.tryBlock,", "-\t\t\t\tthis.caughtExceptionTypes,", "-\t\t\t\tthis.scope,", "-\t\t\t\tflowInfo.unconditionalInits());", "-", "-\t\tFlowInfo tryInfo;", "-\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\ttryInfo = flowInfo;", "-\t\t\tthis.tryBlockExit = false;", "-\t\t} else {", "-\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t}", "-", "-\t\t// check unreachable catch blocks", "-\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-", "-\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "-\t\tif (this.catchArguments != null) {", "-\t\t\tint catchCount;", "-\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\tfor (int i = 0; i < catchCount; i++) {", "-\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "-\t\t\t\tFlowInfo catchInfo =", "-\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t// remove null info to protect point of ", "-\t\t\t\t\t\t\t// exception null info ", "-\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "-\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tFlowContext catchContext = insideSubContext == null ? flowContext : insideSubContext;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g. ", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t}", "-\t\t\t\tcatchInfo =", "-\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcatchContext,", "-\t\t\t\t\t\tcatchInfo);", "-\t\t\t\tthis.catchExits[i] = ", "-\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t// process the try block in a context handling the local exceptions.", "+\t\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\t\tinsideSubContext,", "+\t\t\t\t\tthis.tryBlock,", "+\t\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\t\tthis.scope,", "+\t\t\t\t\tflowInfo.unconditionalInits());", "+\t", "+\t\t\tFlowInfo tryInfo;", "+\t\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\t\ttryInfo = flowInfo;", "+\t\t\t\tthis.tryBlockExit = false;", "+\t\t\t} else {", "+\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t}", "-\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "-\t\t\treturn tryInfo;", "-\t\t}", "-", "-", "-\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "-\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "-\t\tfinallyContext/* NN null with subRoutineStartLabel, which returns */.complainOnDeferredChecks( ", "-\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "-\t\t\t\t? flowInfo.unconditionalCopy().", "-\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "-\t\t\t\t\t\t// exited at any point", "-\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\tinsideSubContext/* NN null with subRoutineStartLabel, which returns */.", "-\t\t\t\t\t\t\tinitsOnReturn)", "-\t\t\t\t: insideSubContext.initsOnReturn,", "-\t\t\tcurrentScope);", "-\t\tif (subInfo == FlowInfo.DEAD_END) {", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "-\t\t\treturn subInfo;", "-\t\t} else {", "-\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\t\treturn mergedInfo;", "+\t", "+\t\t\t// check unreachable catch blocks", "+\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+\t", "+\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\t\tif (this.catchArguments != null) {", "+\t\t\t\tint catchCount;", "+\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+\t", "+\t\t\t\t\t// catch var is always set", "+\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t\t/*", "+\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t\t}", "+\t\t\t\t\tcatchInfo =", "+\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tinsideSubContext,", "+\t\t\t\t\t\t\tcatchInfo);", "+\t\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "+\t\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "+\t\t\tfinallyContext.complainOnDeferredChecks( ", "+\t\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "+\t\t\t\t\t? flowInfo.unconditionalCopy().", "+\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "+\t\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "+\t\t\t\t\t\t\t// exited at any point", "+\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\tinsideSubContext.initsOnReturn)", "+\t\t\t\t\t: insideSubContext.initsOnReturn,", "+\t\t\t\tcurrentScope);", "+\t\t\t", "+\t\t\tif (subInfo == FlowInfo.DEAD_END) {", "+\t\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "+\t\t\t\treturn subInfo;", "+\t\t\t} else {", "+\t\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "+\t\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "+\t\t\t\treturn mergedInfo;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cdc14e9e61a4edd1514791e960996a03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  static State read(DataInputStream in) throws IOException", "signatureAfterChange": "  static State read(IProject project, DataInputStream in) throws IOException", "diff": ["-static State read(DataInputStream in) throws IOException {", "+static State read(IProject project, DataInputStream in) throws IOException {", "+\tif (!project.getName().equals(newState.javaProjectName)) {", "+\t\tif (JavaBuilder.DEBUG)", "+\t\t\tSystem.out.println(\"Project's name does not match... answered null\"); //$NON-NLS-1$", "+\t\treturn null;", "+\t}", "-\tnewState.outputLocationString = in.readUTF();", "-\tnewState.classpathLocations = new ClasspathLocation[length];", "-\tString encoding = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot().getProject(newState.javaProjectName)).getOption(JavaCore.CORE_ENCODING, true);", "-\tfor (int i = 0; i < length; ++i) {", "+\tnewState.sourceLocations = new ClasspathMultiDirectory[length];", "+\tfor (int i = 0; i < length; i++) {", "+\t\tIContainer sourceFolder = project, outputFolder = project;", "+\t\tString folderName;", "+\t\tif ((folderName = in.readUTF()).length() > 0) sourceFolder = project.getFolder(folderName);", "+\t\tif ((folderName = in.readUTF()).length() > 0) outputFolder = project.getFolder(folderName);", "+\t\tClasspathMultiDirectory md =", "+\t\t\t(ClasspathMultiDirectory) ClasspathLocation.forSourceFolder(sourceFolder, outputFolder, readNames(in));", "+\t\tif (in.readBoolean())", "+\t\t\tmd.hasIndependentOutputFolder = true;", "+\t\tnewState.sourceLocations[i] = md;", "+\t}", "+", "+\tlength = in.readInt();", "+\tnewState.binaryLocations = new ClasspathLocation[length];", "+\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forSourceFolder(in.readUTF(), in.readUTF(), encoding);", "+\t\t\t\tnewState.binaryLocations[i] = newState.sourceLocations[in.readInt()];", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forBinaryFolder(in.readUTF());", "+\t\t\t\tIContainer outputFolder = project;", "+\t\t\t\tString folderName = in.readUTF();", "+\t\t\t\tif (folderName.length() > 0) outputFolder = project.getFolder(folderName);", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean());", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(project.getFile(in.readUTF()));", "+\t\t\t\tbreak;", "+\t\t\tcase 4 :", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "-\tString[] internedLocations = new String[length = in.readInt()];", "+\tString[] internedTypeLocators = new String[length = in.readInt()];", "-\t\tinternedLocations[i] = in.readUTF();", "+\t\tinternedTypeLocators[i] = in.readUTF();", "-\tnewState.typeLocations = new SimpleLookupTable(length = in.readInt());", "+\tnewState.typeLocators = new SimpleLookupTable(length = in.readInt());", "-\t\tnewState.typeLocations.put(in.readUTF(), internedLocations[in.readInt()]);", "+\t\tnewState.typeLocators.put(in.readUTF(), internedTypeLocators[in.readInt()]);", "-\t\tString location = internedLocations[in.readInt()];", "+\t\tString typeLocator = internedTypeLocators[in.readInt()];", "-\t\t\t\tfor (int j = 0, qLength = qualifiedNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qualifiedNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = simpleNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = simpleNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, qLength = qNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = sNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = sNames.length; j < m; j++)", "-\t\tnewState.references.put(location, collection);", "+\t\tnewState.references.put(typeLocator, collection);"]}], "num": 25579}