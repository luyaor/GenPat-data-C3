{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "713c53f7944001f847997952b5144708", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab3ebc6b636d29d661e40c267f9c330a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "+\t// to each of the traversed try statements, so that execution will terminate properly.", "+", "+\t// lookup the label, this should answer the returnContext", "+", "+\tif (this.expression != null) {", "+\t\tflowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);", "-\tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "-\t\t// to each of the traversed try statements, so that execution will terminate properly.", "-\t", "-\t\t// lookup the label, this should answer the returnContext", "-\t", "-\t\tif (this.expression != null) {", "-\t\t\tflowInfo = this.expression.analyseCode(currentScope, flowContext, flowInfo);", "-\t\t}", "-\t\t// compute the return sequence (running the finally blocks)", "-\t\tFlowContext traversedContext = flowContext;", "-\t\tint subIndex = 0, maxSub = 5;", "-\t\tboolean saveValueNeeded = false;", "-\t\tboolean hasValueToSave = this.expression != null && this.expression.constant == Constant.NotAConstant;", "-\t\tdo {", "-\t\t\tSubRoutineStatement sub;", "-\t\t\tif ((sub = traversedContext.subRoutine()) != null) {", "-\t\t\t\tif (this.subroutines == null){", "-\t\t\t\t\tthis.subroutines = new SubRoutineStatement[maxSub];", "-\t\t\t\t}", "-\t\t\t\tif (subIndex == maxSub) {", "-\t\t\t\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[maxSub *= 2]), 0, subIndex); // grow", "-\t\t\t\t}", "-\t\t\t\tthis.subroutines[subIndex++] = sub;", "-\t\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t\t\t\tsaveValueNeeded = false;", "-\t\t\t\t\tisAnySubRoutineEscaping = true;", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t// compute the return sequence (running the finally blocks)", "+\tFlowContext traversedContext = flowContext;", "+\tint subCount = 0;", "+\tboolean saveValueNeeded = false;", "+\tboolean hasValueToSave = this.expression != null ", "+\t\t\t\t\t\t&& this.expression.constant == Constant.NotAConstant ", "+\t\t\t\t\t\t&& !(this.expression instanceof NullLiteral);", "+\tdo {", "+\t\tSubRoutineStatement sub;", "+\t\tif ((sub = traversedContext.subroutine()) != null) {", "+\t\t\tif (this.subroutines == null){", "+\t\t\t\tthis.subroutines = new SubRoutineStatement[5];", "-\t\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-\t", "-\t\t\tASTNode node;", "-\t\t\tif ((node = traversedContext.associatedNode) instanceof SynchronizedStatement) {", "-\t\t\t\tisSynchronized = true;", "-\t", "+\t\t\tif (subCount == this.subroutines.length) {", "+\t\t\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount*2]), 0, subCount); // grow", "+\t\t\t}", "+\t\t\tthis.subroutines[subCount++] = sub;", "+\t\t\tif (sub.isSubRoutineEscaping()) {", "+\t\t\t\tsaveValueNeeded = false;", "+\t\t\t\tthis.isAnySubRoutineEscaping = true;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof SynchronizedStatement) {", "+\t\t\t\tthis.isSynchronized = true;", "-\t", "-\t\t\t} else if (traversedContext instanceof InitializationFlowContext) {", "-\t\t\t\t\tcurrentScope.problemReporter().cannotReturnInInitializer(this);", "-\t\t\t\t\treturn FlowInfo.DEAD_END;", "-\t\t} while ((traversedContext = traversedContext.parent) != null);", "-\t\t", "-\t\t// resize subroutines", "-\t\tif ((subroutines != null) && (subIndex != maxSub)) {", "-\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[subIndex]), 0, subIndex);", "+\t\t} else if (traversedContext instanceof InitializationFlowContext) {", "+\t\t\t\tcurrentScope.problemReporter().cannotReturnInInitializer(this);", "+\t\t\t\treturn FlowInfo.DEAD_END;", "+\t} while ((traversedContext = traversedContext.parent) != null);", "-\t\t// secret local variable for return value (note that this can only occur in a real method)", "-\t\tif (saveValueNeeded) {", "-\t\t\tif (this.saveValueVariable != null) {", "-\t\t\t\tthis.saveValueVariable.useFlag = LocalVariableBinding.USED;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tthis.saveValueVariable = null;", "-\t\t\tif (!isSynchronized && this.expression != null && this.expression.resolvedType == TypeBinding.BOOLEAN) {", "-\t\t\t\tthis.expression.bits |= IsReturnedValue;", "-\t\t\t}", "-\t\t}", "-\t\treturn FlowInfo.DEAD_END;", "+\t// resize subroutines", "+\tif ((this.subroutines != null) && (subCount != this.subroutines.length)) {", "+\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount]), 0, subCount);", "+\t// secret local variable for return value (note that this can only occur in a real method)", "+\tif (saveValueNeeded) {", "+\t\tif (this.saveValueVariable != null) {", "+\t\t\tthis.saveValueVariable.useFlag = LocalVariableBinding.USED;", "+\t\t}", "+\t} else {", "+\t\tthis.saveValueVariable = null;", "+\t\tif (!this.isSynchronized && this.expression != null && this.expression.resolvedType == TypeBinding.BOOLEAN) {", "+\t\t\tthis.expression.bits |= ASTNode.IsReturnedValue;", "+\t\t}", "+\t}", "+\treturn FlowInfo.DEAD_END;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbfca4867e96a1b932dc4c3de49ed669", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "-\t\t// to each of the traversed try statements, so that execution will terminate properly.", "+\t// here requires to generate a sequence of finally blocks invocations depending corresponding", "+\t// to each of the traversed try statements, so that execution will terminate properly.", "-\t\t// lookup the label, this should answer the returnContext", "-\t\tFlowContext targetContext = (label == null) ", "-\t\t\t? flowContext.getTargetContextForDefaultBreak()", "-\t\t\t: flowContext.getTargetContextForBreakLabel(label);", "+\t// lookup the label, this should answer the returnContext", "+\tFlowContext targetContext = (this.label == null) ", "+\t\t? flowContext.getTargetContextForDefaultBreak()", "+\t\t: flowContext.getTargetContextForBreakLabel(this.label);", "-\t\tif (targetContext == null) {", "-\t\t\tif (label == null) {", "-\t\t\t\tcurrentScope.problemReporter().invalidBreak(this);", "-\t\t\t} else {", "-\t\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\t\t}", "-\t\t\treturn flowInfo; // pretend it did not break since no actual target", "+\tif (targetContext == null) {", "+\t\tif (this.label == null) {", "+\t\t\tcurrentScope.problemReporter().invalidBreak(this);", "+\t\t} else {", "+\t\t\tcurrentScope.problemReporter().undefinedLabel(this); ", "-\t\t", "-\t\ttargetLabel = targetContext.breakLabel();", "-\t\tFlowContext traversedContext = flowContext;", "-\t\tint subIndex = 0, maxSub = 5;", "-\t\tsubroutines = new SubRoutineStatement[maxSub];", "-\t\t", "-\t\tdo {", "-\t\t\tSubRoutineStatement sub;", "-\t\t\tif ((sub = traversedContext.subRoutine()) != null) {", "-\t\t\t\tif (subIndex == maxSub) {", "-\t\t\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[maxSub*=2]), 0, subIndex); // grow", "-\t\t\t\t}", "-\t\t\t\tsubroutines[subIndex++] = sub;", "-\t\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\treturn flowInfo; // pretend it did not break since no actual target", "+\t}", "+\t", "+\tthis.targetLabel = targetContext.breakLabel();", "+\tFlowContext traversedContext = flowContext;", "+\tint subCount = 0;", "+\tthis.subroutines = new SubRoutineStatement[5];", "+\t", "+\tdo {", "+\t\tSubRoutineStatement sub;", "+\t\tif ((sub = traversedContext.subroutine()) != null) {", "+\t\t\tif (subCount == this.subroutines.length) {", "+\t\t\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount*2]), 0, subCount); // grow", "-\t\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-", "-\t\t\tASTNode node;", "-\t\t\tif ((node = traversedContext.associatedNode) instanceof TryStatement) {", "-\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "-\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "-\t\t\t} else if (traversedContext == targetContext) {", "-\t\t\t\t// only record break info once accumulated through subroutines, and only against target context", "-\t\t\t\ttargetContext.recordBreakFrom(flowInfo);", "+\t\t\tthis.subroutines[subCount++] = sub;", "+\t\t\tif (sub.isSubRoutineEscaping()) {", "-\t\t} while ((traversedContext = traversedContext.parent) != null);", "-\t\t", "-\t\t// resize subroutines", "-\t\tif (subIndex != maxSub) {", "-\t\t\tSystem.arraycopy(subroutines, 0, (subroutines = new SubRoutineStatement[subIndex]), 0, subIndex);", "-\t\treturn FlowInfo.DEAD_END;", "-\t}", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+\t\t", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}", "+\t\t} else if (traversedContext == targetContext) {", "+\t\t\t// only record break info once accumulated through subroutines, and only against target context", "+\t\t\ttargetContext.recordBreakFrom(flowInfo);", "+\t\t\tbreak;", "+\t\t}", "+\t} while ((traversedContext = traversedContext.parent) != null);", "+\t// resize subroutines", "+\tif (subCount != this.subroutines.length) {", "+\t\tSystem.arraycopy(this.subroutines, 0, (this.subroutines = new SubRoutineStatement[subCount]), 0, subCount);", "+\treturn FlowInfo.DEAD_END;", "+}"]}], "num": 43598}