{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "6455e9a096a52428927c24281e2b0c26", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39cd47642d8f4647797a78bf258c78d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java", "commitBeforeChange": "1c5e7e547be721f9ec87cd4dd76a42ec63ff0bb1", "commitAfterChange": "021e1bbe1df76f3c86c477a6dfa61edf287069ab", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-", "-\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "-\t\tif (index == null) return true;", "-\t\tReadWriteMonitor monitor = index.monitor;", "-\t\tif (monitor == null) return true; // index got deleted since acquired", "-", "+\t\t", "+\t\tReadWriteMonitor monitor = null;", "+\t\t\t// Get source folder entries. Libraries are done as a separate job", "+\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "+\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "+\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "+\t\t\tint length = entries.length;", "+\t\t\tIClasspathEntry[] sourceEntries = new IClasspathEntry[length];", "+\t\t\tint sourceEntriesNumber = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) ", "+\t\t\t\t\tsourceEntries[sourceEntriesNumber++] = entry;", "+\t\t\t}", "+\t\t\tif (sourceEntriesNumber == 0) ", "+\t\t\t\t// nothing to index", "+\t\t\t\t// also the project might be a library folder (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89815)", "+\t\t\t\treturn true;", "+\t\t\tif (sourceEntriesNumber != length)", "+\t\t\t\tSystem.arraycopy(sourceEntries, 0, sourceEntries = new IClasspathEntry[sourceEntriesNumber], 0, sourceEntriesNumber);", "+\t", "+\t\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\t\tif (index == null) return true;", "+\t\t\tmonitor = index.monitor;", "+\t\t\tif (monitor == null) return true; // index got deleted since acquired", "+\t\t\t", "-\t\t\tJavaProject javaProject = (JavaProject)JavaCore.create(this.project);", "-\t\t\t// Do not create marker nor log problems while getting raw classpath (see bug 41859)", "-\t\t\tIClasspathEntry[] entries = javaProject.getRawClasspath(false, false);", "-\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {", "+\t\t\tfor (int i = 0; i < sourceEntriesNumber; i++) {", "-\t\t\t\tIClasspathEntry entry = entries[i];", "-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) { // Index only source folders. Libraries are done as a separate job", "-\t\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "-\t\t\t\t\tif (sourceFolder != null) {", "-\t\t\t\t\t\t", "-\t\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "-\t\t\t\t\t\tfinal HashSet outputs = new HashSet();", "-\t\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "-\t\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "-\t\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "-\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\t\t\tIPath output = entries[j].getOutputLocation();", "-\t\t\t\t\t\t\t\tif (output != null) {", "-\t\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\tIClasspathEntry entry = sourceEntries[i];", "+\t\t\t\tIResource sourceFolder = root.findMember(entry.getPath());", "+\t\t\t\tif (sourceFolder != null) {", "+\t\t\t\t\t", "+\t\t\t\t\t// collect output locations if source is project (see http://bugs.eclipse.org/bugs/show_bug.cgi?id=32041)", "+\t\t\t\t\tfinal HashSet outputs = new HashSet();", "+\t\t\t\t\tif (sourceFolder.getType() == IResource.PROJECT) {", "+\t\t\t\t\t\t// Do not create marker nor log problems while getting output location (see bug 41859)", "+\t\t\t\t\t\toutputs.add(javaProject.getOutputLocation(false, false));", "+\t\t\t\t\t\tfor (int j = 0; j < sourceEntriesNumber; j++) {", "+\t\t\t\t\t\t\tIPath output = sourceEntries[j].getOutputLocation();", "+\t\t\t\t\t\t\tif (output != null) {", "+\t\t\t\t\t\t\t\toutputs.add(output);", "-\t\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "-\t\t\t\t\t\t", "-\t\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "-\t\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "-\t\t\t\t\t\tif (max == 0) {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tsourceFolder.accept(", "-\t\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "-\t\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "-\t\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "-\t\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "-\t\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "-\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "-\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t}", "+\t\t\t\t\tfinal boolean hasOutputs = !outputs.isEmpty();", "+\t\t\t\t\t", "+\t\t\t\t\tfinal char[][] inclusionPatterns = ((ClasspathEntry) entry).fullInclusionPatternChars();", "+\t\t\t\t\tfinal char[][] exclusionPatterns = ((ClasspathEntry) entry).fullExclusionPatternChars();", "+\t\t\t\t\tif (max == 0) {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (file.getLocation() == null) return false;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "-\t\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "-\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(file.getFullPath().toString(), file);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null && inclusionPatterns == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\t// if there are inclusion patterns then we must walk the children", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestFullPath(), inclusionPatterns, exclusionPatterns, true)) ", "+\t\t\t\t\t\t\t\t\t\t\t\t    return false;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t},", "-\t\t\t\t\t\t\t\tIResource.NONE", "-\t\t\t\t\t\t\t);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tsourceFolder.accept(", "+\t\t\t\t\t\t\tnew IResourceProxyVisitor() {", "+\t\t\t\t\t\t\t\tpublic boolean visit(IResourceProxy proxy) {", "+\t\t\t\t\t\t\t\t\tif (isCancelled) return false;", "+\t\t\t\t\t\t\t\t\tswitch(proxy.getType()) {", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FILE :", "+\t\t\t\t\t\t\t\t\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(proxy.getName())) {", "+\t\t\t\t\t\t\t\t\t\t\t\tIFile file = (IFile) proxy.requestResource();", "+\t\t\t\t\t\t\t\t\t\t\t\tIPath location = file.getLocation();", "+\t\t\t\t\t\t\t\t\t\t\t\tif (location == null) return false;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(file, inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\t\tString path = file.getFullPath().toString();", "+\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.put(path,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tindexedFileNames.get(path) == null || indexLastModified < location.toFile().lastModified()", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t? (Object) file", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t: (Object) OK);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\tcase IResource.FOLDER :", "+\t\t\t\t\t\t\t\t\t\t\tif (exclusionPatterns != null || inclusionPatterns != null)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (Util.isExcluded(proxy.requestResource(), inclusionPatterns, exclusionPatterns))", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t\t\tif (hasOutputs && outputs.contains(proxy.requestFullPath()))", "+\t\t\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t},", "+\t\t\t\t\t\t\tIResource.NONE", "+\t\t\t\t\t\t);", "-\t\t\tfor (int i = 0, length = names.length; i < length; i++) {", "+\t\t\tfor (int i = 0, namesLength = names.length; i < namesLength; i++) {", "-\t\t\tmonitor.exitRead(); // free read lock", "+\t\t\tif (monitor != null)", "+\t\t\t\tmonitor.exitRead(); // free read lock"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc8392b12ceb2ea622873ccaa8a5fb39", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AnnotationParser.java", "commitBeforeChange": "6a44e0777af1a4632e0d20c0e9b92d35d2ad59f3", "commitAfterChange": "2ca339c139c0fe73a5bd2705f66592731098d347", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "signatureAfterChange": " \tpublic boolean checkDeprecation(int annotationStart, int annotationEnd)", "diff": ["-\t\tchar[] source = this.scanner.source;", "-\t\tif (false/*this.sourceParser.checkAnnotation*/) {", "-\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "-\t\t} else {", "-\t\t\tthis.annotation = null;", "-\t\t} ", "-\t", "-\t\tint firstLineNumber = this.scanner.getLineNumber(annotationStart);", "-\t\tint lastLineNumber = this.scanner.getLineNumber(annotationEnd);", "-\t\tint[] index = new int[]{ 0 };", "-\t\t\t\t", "-\t\t// scan line per line, since tags are supposed to be at beginning of lines only", "-\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "-\t\t\tint lineStart = this.scanner.getLineStart(line);", "-\t\t\tif (line == firstLineNumber) lineStart = annotationStart + 3; // skip leading /**", "-\t\t\tint lineEnd = this.scanner.getLineEnd(line);", "-\t\t\tif (line == lastLineNumber) lineEnd = annotationEnd - 2; // remove trailing */", "-\t\t\tindex[0] = lineStart;", "-\t\t\tboolean foundStar = false;", "-\t\t\twhile (index[0] < lineEnd) {", "-\t\t\t\tchar nextCharacter = getNextCharacter(source, index); // consider unicodes", "-\t\t\t\tswitch(nextCharacter) {", "-\t\t\t\t\tcase '@' :", "-\t\t\t\t\t\tif (this.annotation == null) {", "-\t\t\t\t\t\t\tif ((getNextCharacter(source, index) == 'd')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'p')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'r')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'c')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'a')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 't')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'e')", "-\t\t\t\t\t\t\t\t&& (getNextCharacter(source, index) == 'd')) {", "-\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "-\t\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\ttry {", "+\t\t\tthis.source = this.sourceParser.scanner.source;", "+\t\t\tif (this.sourceParser.options.checkAnnotation) {", "+\t\t\t\tthis.annotation = new Annotation(annotationStart, annotationEnd);", "+\t\t\t\tthis.identifierPtr = -1;", "+\t\t\t} else {", "+\t\t\t\tthis.annotation = null;", "+\t\t\t} ", "+\t\t", "+\t\t\tint firstLineNumber = this.sourceParser.scanner.getLineNumber(annotationStart);", "+\t\t\tint lastLineNumber = this.sourceParser.scanner.getLineNumber(annotationEnd);", "+\t\t\t\t\t", "+\t\t\t// scan line per line, since tags must be at beginning of lines only", "+\t\t\tnextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {", "+\t\t\t\tboolean foundStar = false;", "+\t\t\t\tint lineStart = line == firstLineNumber ", "+\t\t\t\t\t\t? annotationStart + 3 \t\t// skip leading /**", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineStart(line);", "+\t\t\t\tthis.index[0] = lineStart;", "+\t\t\t\tint lineEnd = line == lastLineNumber", "+\t\t\t\t\t\t? annotationEnd - 2 \t\t// remove trailing */", "+\t\t\t\t\t\t:  this.sourceParser.scanner.getLineEnd(line);", "+\t\t\t\twhile (this.index[0] < lineEnd) {", "+\t\t\t\t\tchar nextCharacter = readChar(); // consider unicodes", "+\t\t\t\t\tswitch(nextCharacter) {", "+\t\t\t\t\t\tcase '@' :", "+\t\t\t\t\t\t\tif (this.annotation == null) {", "+\t\t\t\t\t\t\t\tif ((readChar() == 'd')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'p')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'r')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'c')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'a')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 't')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'e')", "+\t\t\t\t\t\t\t\t\t&& (readChar() == 'd')) {", "+\t\t\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.", "+\t\t\t\t\t\t\t\t\tnextCharacter = readChar();", "+\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {", "+\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\tbreak nextLine; // done", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tcontinue nextLine;", "+\t\t\t\t\t\t\t} ", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index[0], lineEnd);", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tswitch (this.scanner.getNextToken()) {", "+\t\t\t\t\t\t\t\t\tcase  TerminalTokens.TokenNameIdentifier :", "+\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "+\t\t\t\t\t\t\t\t\t\tif (CharOperation.equals(tag, TAG_DEPRECATED)) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_PARAM)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseParam();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_THROWS) || CharOperation.equals(tag, TAG_EXCEPTION)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseThrows();", "+\t\t\t\t\t\t\t\t\t\t} else if (CharOperation.equals(tag, TAG_SEE)) {", "+\t\t\t\t\t\t\t\t\t\t\tparseSee();", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNamereturn :", "+\t\t\t\t\t\t\t\t\t\tparseReturn();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t} ", "-/*", "- \t\t\t\t\t\t// parse annotation", "-\t\t\t\t\t\tint tagStart = index[0], tagEnd = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tsaveScannerState();", "-\t\t\t\t\t\t\tthis.scanner.startPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentPosition = index[0];", "-\t\t\t\t\t\t\tthis.scanner.currentCharacter = -1;", "-\t\t\t\t\t\t\t// read tag", "-\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t} finally {", "-\t\t\t\t\t\t\tloadScannerState();", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\t\tdo {", "-\t\t\t\t\t\t\tnextCharacter = getNextCharacter(source, index);", "-\t\t\t\t\t\t\t// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk", "-\t\t\t\t\t\t\tif (Character.isWhitespace(nextCharacter) || nextCharacter == '*') break; ", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = nextCharacter;", "-\t\t\t\t\t\t\ttagEnd = index[0];", "-\t\t\t\t\t\t} while (index[0] < lineEnd);", "-\t\t\t\t\t\tif (bufferLength == 0) continue nextLine;", "-\t\t\t\t\t\tchar[] tag = null;", "-\t\t\t\t\t\tswitch(this.annotationBuffer[0]) {", "-\t\t\t\t\t\t\tcase 'd' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_DEPRECATED, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_DEPRECATED;", "-\t\t\t\t\t\t\t\t\tfoundDeprecated = true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 'e' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_EXCEPTION, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_EXCEPTION;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 't' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_THROWS, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_THROWS;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 's' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_SEE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SEE;", "-\t\t\t\t\t\t\t\t} else if (CharOperation.equals(Annotation.TAG_SINCE, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_SINCE;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'p' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_PARAM, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_PARAM;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t\tcase 'r' :", "-\t\t\t\t\t\t\t\tif (CharOperation.equals(Annotation.TAG_RETURN, this.annotationBuffer, 0, bufferLength)) {", "-\t\t\t\t\t\t\t\t\ttag = Annotation.TAG_RETURN;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (tag == null) {", "-\t\t\t\t\t\t\ttag = new char[bufferLength];", "-\t\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, tag, 0, bufferLength);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t// read argument", "-\t\t\t\t\t\tint argumentStart = index[0];", "-\t\t\t\t\t\twhile (argumentStart < lineEnd && Character.isWhitespace(source[argumentStart])) argumentStart++; // trim argument leading spaces", "-\t\t\t\t\t\tint argumentEnd = lineEnd-1;", "-\t\t\t\t\t\twhile (argumentEnd > argumentStart && Character.isWhitespace(source[argumentEnd])) argumentEnd--; // trim argument trailing spaces", "-\t\t\t\t\t\tbufferLength = 0;", "-\t\t\t\t\t\tfor (index[0] = argumentStart; index[0] <= argumentEnd;) {", "-\t\t\t\t\t\t\tthis.annotationBuffer[bufferLength++] = getNextCharacter(source, index);", "-\t\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\t\tchar[] argument = new char[bufferLength];", "-\t\t\t\t\t\tSystem.arraycopy(this.annotationBuffer, 0, argument, 0, bufferLength);", "-\t\t\t\t\t\tannotation.record(tag, argument, tagStart, argumentEnd);", "-*/\t\t\t\t\t\t", "-\t\t\t\t\t\tcontinue nextLine;", "-\t\t\t\t\tcase '*' :", "-\t\t\t\t\t\tif (foundStar) continue nextLine;", "-\t\t\t\t\t\tfoundStar = true;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault :", "-\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t\tcase '*' :", "+\t\t\t\t\t\t\tif (foundStar) continue nextLine;", "+\t\t\t\t\t\t\tfoundStar = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tif (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;", "+\t\t\t\t\t}", "-\t\t}", "-\t\t", "+\t\t} finally {", "+\t\t\tthis.source = null; // release source as soon as finished", "+\t\t}\t\t"]}], "num": 68773}