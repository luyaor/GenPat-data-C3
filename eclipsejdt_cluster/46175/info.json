{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3549ffa06e6feb89f4401c62a79ed58d", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "43d3dcb7032a3330a206d0090f007634", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9c0097e084b2c48ccca0e818ba9c1c1a50818167", "commitAfterChange": "ed04e9efb45ff73e01fac12a6ae0aba550054536", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 32, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][] typeNames, \t\t\t\t\t\t\t\t\tint[] wildcards, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tboolean declaration, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[] patternTypeSignature, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tboolean declaration, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tchar[][] typeNames,", "-\t\t\t\t\t\t\t\t\tint[] wildcards,", "+\t\t\t\t\t\t\t\t\tchar[] patternTypeSignature,", "-\tif (type == null) return level;", "+\tif (type == null || patternTypeSignature == null) return level;", "-\tif (typeNames == null || typeNames.length == 0) {", "+\tchar[][] patternTypeArguments = Signature.getTypeArguments(patternTypeSignature);", "+\tif (patternTypeArguments == null || patternTypeArguments.length == 0) {", "-\t", "+", "-\t\tint length = typeNames.length;", "+\t\tint length = patternTypeArguments.length;", "-\t\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, typeNames, wildcards, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {", "+\t\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeSignature, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {", "-\t\tint length = typeNames.length;", "+\t\tint length = patternTypeArguments.length;", "-\t\t\tchar[] argType = typeNames[i];", "+\t\t\tchar[] typeArgument = patternTypeArguments[i];", "-\t\t\tint patternWildcard = wildcards == null ? -1 : wildcards[i];", "-\t\t\tif (patternWildcard == Wildcard.UNBOUND) continue; // unbound parameter always match", "-", "-\t\t\t// try to resolve pattern", "-\t\t\tTypeBinding patternBinding = getTypeNameBinding(i);", "-\t\t\tif (patternBinding != null) {", "-\t\t\t\t// We can bind pattern type name => verify that types are compatible", "-\t\t\t\tif (argTypeBinding == patternBinding) continue;", "-\t\t\t\tif (argTypeBinding.isWildcard()) {", "-\t\t\t\t\tTypeBinding bound = ((WildcardBinding) argTypeBinding).bound;", "-\t\t\t\t\tswitch (patternWildcard) {", "-\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\tif (bound == null || patternBinding.isCompatibleWith(bound))", "-\t\t\t\t\t\t\t\t// argument type is in bound hierarchy => match", "-\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\tif (bound == null || bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t// argument type is a subclass of bound => match", "-\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tdefault: //UNBOUND", "-\t\t\t\t\t\t\t// there's no bound name => match", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\tswitch (patternTypeArguments[i][0]) {", "+\t\t\t\tcase Signature.C_STAR : // unbound parameter always match", "+\t\t\t\tcase Signature.C_SUPER : // needs pattern type parameter binding", "+\t\t\t\t\t// skip to next type argument as it will be resolved later", "+\t\t\t\t\tcontinue;", "+\t\t\t\tcase Signature.C_EXTENDS :", "+\t\t\t\t\t// remove wildcard from patter type argument", "+\t\t\t\t\ttypeArgument = CharOperation.subarray(typeArgument, 1, typeArgument.length);", "+\t\t\t\tdefault :", "+\t\t\t\t\t// no wildcard", "+\t\t\t\t\tbreak;", "-\t\t\t", "-\t\t\t// pattern hasn't be solved, try to see if names match in hierarchy", "+\t\t\t// get pattern type argument from its signature", "+\t\t\ttypeArgument = Signature.toCharArray(typeArgument);", "+", "+\t\t\t// Verify that names match...", "-\t\t\t\t\tif (CharOperation.equals(argType, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(argType, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\tif (CharOperation.equals(typeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.equals(typeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\tif (!CharOperation.equals(argType, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&", "-\t\t\t\t\t!CharOperation.equals(argType, argTypeBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\tif (!CharOperation.equals(typeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&", "+\t\t\t\t\t!CharOperation.equals(typeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\tif (CharOperation.equals(argType, refBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(argType, refBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\tif (CharOperation.equals(typeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\tCharOperation.equals(typeArgument, refBinding.readableName(), this.isCaseSensitive)) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9eaa86fa36842ca391d70194b508447d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "4043b8a88c35a2c1612858cff67743727f25247b", "commitAfterChange": "6b8da2bd2bb1367c9817dbe3821476ed638f0906", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 33, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[] patternTypeSignature, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tboolean declaration, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments, \t\t\t\t\t\t\t\t\tint depth, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tTypeBinding type)", "diff": ["-\t\t\t\t\t\t\t\t\tchar[] patternTypeSignature,", "+\t\t\t\t\t\t\t\t\tchar[][][] patternTypeArguments,", "+\t\t\t\t\t\t\t\t\tint depth,", "-\t\t\t\t\t\t\t\t\tboolean declaration,", "-\tif (type == null || patternTypeSignature == null) return level;", "-", "-\t// pattern has no type parameter, return standard result", "-\tchar[][] patternTypeArguments = Signature.getTypeArguments(patternTypeSignature);", "-\tif (patternTypeArguments == null || patternTypeArguments.length == 0) {", "-\t\treturn level;", "-\t}", "+\tif (type == null || patternTypeArguments == null|| patternTypeArguments.length == 0) return level;", "-\t\tint length = patternTypeArguments.length;", "+\t\tint length = patternTypeArguments[depth].length;", "-\t} else if (!type.isParameterizedType() && !isRawType) {", "+\t} else if (isRawType) {", "+\t\treturn level; // raw type always match", "+\t} else if (!type.isParameterizedType()) {", "-\t\t// Binding is parameterized type", "-\t\tif (paramTypeBinding.arguments == null) {", "-\t\t\t// binding has no type parameters => ok for raw types", "-\t\t\tif (isRawType) return level;", "-\t\t\t// need to verify hierarchy for member types (raw type of generic member", "-\t\t\t// are stored as parameterized types...)", "-\t\t\tif (type.isMemberType() && qualificationPattern != null) {", "-\t\t\t\tint lastDot = CharOperation.lastIndexOf('.', qualificationPattern);", "-\t\t\t\tchar[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);", "-\t\t\t\tchar[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);", "-\t\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeSignature, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {", "+\t\t// When there's no type argument, no verification is necessary ", "+\t\tif (paramTypeBinding.arguments != null) {", "+", "+\t\t\t// type parameters length must match at least specified type names length", "+\t\t\tint length = patternTypeArguments[depth].length;", "+\t\t\tif (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;", "+\t", "+\t\t\t// verify each pattern type parameter", "+\t\t\tnextTypeArgument: for (int i= 0; i<length; i++) {", "+\t\t\t\tchar[] patternTypeArgument = patternTypeArguments[depth][i];", "+\t\t\t\tTypeBinding argTypeBinding = paramTypeBinding.arguments[i];", "+\t\t\t\t// get corresponding pattern wildcard", "+\t\t\t\tswitch (patternTypeArgument[0]) {", "+\t\t\t\t\tcase Signature.C_STAR : // unbound parameter always match", "+\t\t\t\t\tcase Signature.C_SUPER : // needs pattern type parameter binding", "+\t\t\t\t\t\t// skip to next type argument as it will be resolved later", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tcase Signature.C_EXTENDS :", "+\t\t\t\t\t\t// remove wildcard from patter type argument", "+\t\t\t\t\t\tpatternTypeArgument = CharOperation.subarray(patternTypeArgument, 1, patternTypeArgument.length);", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\t// no wildcard", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\t// get pattern type argument from its signature", "+\t\t\t\tpatternTypeArgument = Signature.toCharArray(patternTypeArgument);", "+\t", "+\t\t\t\t// Verify that names match...", "+\t\t\t\t// ...special case for wildcard", "+\t\t\t\tif (argTypeBinding.isWildcard()) {", "+\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;", "+\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t// We cannot know in this case...", "+\t\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "+\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t// there's no bound name to match => valid", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\t// Look for bound name in hierarchy", "+\t\t\t\t\tReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;", "+\t\t\t\t\twhile (boundBinding != null) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tboundBinding = boundBinding.superclass();", "+\t\t\t\t\t}", "-\t\t\t\treturn level;", "-\t\t\t}", "-\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t}", "-", "-\t\t// type parameters length must match at least specified type names length", "-\t\tint length = patternTypeArguments.length;", "-\t\tif (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;", "-", "-\t\t// for generic type declaration, verification is different than for parameterized type", "-\t\tif (declaration) {", "-\t\t\t// TODO (frederic) more verification to do here with type parameter bounds?", "-\t\t\treturn level;", "-\t\t}", "-", "-\t\t// verify each pattern type parameter", "-\t\tnextTypeArgument: for (int i= 0; i<length; i++) {", "-\t\t\tchar[] typeArgument = patternTypeArguments[i];", "-\t\t\tTypeBinding argTypeBinding = paramTypeBinding.arguments[i];", "-\t\t\t// get corresponding pattern wildcard", "-\t\t\tswitch (patternTypeArguments[i][0]) {", "-\t\t\t\tcase Signature.C_STAR : // unbound parameter always match", "-\t\t\t\tcase Signature.C_SUPER : // needs pattern type parameter binding", "-\t\t\t\t\t// skip to next type argument as it will be resolved later", "+\t\t\t\t", "+\t\t\t\t// See if names match", "+\t\t\t\tif (CharOperation.equals(patternTypeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\tCharOperation.equals(patternTypeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\tcase Signature.C_EXTENDS :", "-\t\t\t\t\t// remove wildcard from patter type argument", "-\t\t\t\t\ttypeArgument = CharOperation.subarray(typeArgument, 1, typeArgument.length);", "-\t\t\t\tdefault :", "-\t\t\t\t\t// no wildcard", "-\t\t\t\t\tbreak;", "-\t\t\t}", "-\t\t\t// get pattern type argument from its signature", "-\t\t\ttypeArgument = Signature.toCharArray(typeArgument);", "-", "-\t\t\t// Verify that names match...", "-\t\t\t// First if type argument is a wildcard", "-\t\t\tif (argTypeBinding.isWildcard()) {", "-\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;", "-\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "-\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t// there's no bound name to match => valid", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t// try to match name in hierarchy", "-\t\t\t\tReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;", "-\t\t\t\twhile (boundBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(typeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(typeArgument, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\t// found name in hierarchy => match", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "+", "+\t\t\t\t// Get reference binding", "+\t\t\t\tReferenceBinding refBinding = null;", "+\t\t\t\tif (argTypeBinding.isArrayType()) {", "+\t\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "+\t\t\t\t\tif (!leafBinding.isBaseType()) {", "+\t\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t\tboundBinding = boundBinding.superclass();", "+\t\t\t\t} else if (!argTypeBinding.isBaseType()) {", "+\t\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "+\t\t\t\t}", "+\t\t\t\t// Scan hierarchy", "+\t\t\t\tif (refBinding != null) {", "+\t\t\t\t\trefBinding = refBinding.superclass();", "+\t\t\t\t\twhile (refBinding != null) {", "+\t\t\t\t\t\tif (CharOperation.equals(patternTypeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "+\t\t\t\t\t\t\tCharOperation.equals(patternTypeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "+\t\t\t\t\t\t\t// found name in hierarchy => match", "+\t\t\t\t\t\t\tcontinue nextTypeArgument;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\trefBinding = refBinding.superclass();", "+\t\t\t\t\t}", "-\t\t\t", "-\t\t\t// try to match names when there's no wildcard", "-\t\t\t// first get real binding", "-\t\t\tReferenceBinding refBinding = null;", "-\t\t\tif (argTypeBinding.isArrayType()) {", "-\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "-\t\t\t\tif (!leafBinding.isBaseType()) {", "-\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t}", "-\t\t\t} else if (!argTypeBinding.isBaseType()) {", "-\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "-\t\t\t}", "-\t\t\t// Compare name", "-\t\t\tif (refBinding == null) {", "-\t\t\t\t// Based type", "-\t\t\t\tif (!CharOperation.equals(typeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&", "-\t\t\t\t\t!CharOperation.equals(typeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\twhile (refBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(typeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(typeArgument, refBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\t// found name in hierarchy => match", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "-\t\t\t\t\t}", "-\t\t\t\t\trefBinding = refBinding.superclass();", "-\t\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Recurse on enclosing type", "+\t\tTypeBinding enclosingType = paramTypeBinding.enclosingType();", "+\t\tif (enclosingType != null && enclosingType.isParameterizedType() && depth < patternTypeArguments.length && qualificationPattern != null) {", "+\t\t\tint lastDot = CharOperation.lastIndexOf('.', qualificationPattern);", "+\t\t\tchar[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);", "+\t\t\tchar[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);", "+\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeArguments, depth+1, mustResolve, enclosingType) == IMPOSSIBLE_MATCH) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa0b25121d8bf854e65301c9fec4f78b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java", "commitBeforeChange": "d26bd96cc9e1c9e59f2c9d083b9a2725de90852a", "commitAfterChange": "8b048c313a1c6f07bac23f1c84c9ba7d1df315ac", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected int resolveLevelForType (char[] simpleNamePattern, \t\t\t\t\t\t\t\t\tchar[] qualificationPattern, \t\t\t\t\t\t\t\t\tchar[][] typeNames, \t\t\t\t\t\t\t\t\tboolean mustResolve, \t\t\t\t\t\t\t\t\tboolean declaration, \t\t\t\t\t\t\t\t\tTypeBinding type)", "signatureAfterChange": " protected TypeBinding getTypeNameBinding(int index)", "diff": ["+ */", "+protected TypeBinding getTypeNameBinding(int index) {", "+\treturn this.pattern.getTypeNameBinding(this.unitScope, index);", "- */", "-protected int resolveLevelForType (char[] simpleNamePattern,", "-\t\t\t\t\t\t\t\t\tchar[] qualificationPattern,", "-\t\t\t\t\t\t\t\t\tchar[][] typeNames,", "-\t\t\t\t\t\t\t\t\tboolean mustResolve,", "-\t\t\t\t\t\t\t\t\tboolean declaration,", "-\t\t\t\t\t\t\t\t\tTypeBinding type) {", "-\tint level = resolveLevelForType(simpleNamePattern, qualificationPattern, type);", "-\tif (level == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;", "-\tif (type == null) return level;", "-", "-\t// pattern has no type parameter", "-\tif (typeNames == null || typeNames.length == 0) {", "-\t\treturn level;", "-\t}", "-\t", "-\t// pattern has type parameter(s) or type argument(s)", "-\tboolean isRawType = type.isRawType();", "-\tif (type.isGenericType()) {", "-\t\t// Binding is generic, get its type variable(s)", "-\t\tTypeVariableBinding[] typeVariables = null;", "-\t\tif (type instanceof SourceTypeBinding) {", "-\t\t\tSourceTypeBinding sourceTypeBinding = (SourceTypeBinding) type;", "-\t\t\ttypeVariables = sourceTypeBinding.typeVariables;", "-\t\t} else if (type instanceof BinaryTypeBinding) {", "-\t\t\tBinaryTypeBinding binaryTypeBinding = (BinaryTypeBinding) type;", "-\t\t\tif (mustResolve)", "-\t\t\t\ttypeVariables = binaryTypeBinding.typeVariables(); // TODO (frederic) do we really want to resolve?", "-\t\t}", "-\t\t// type variables length must match at least specified type names length", "-\t\tif (typeVariables == null || typeVariables.length == 0) {", "-\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t}", "-\t\tint length = typeNames.length;", "-\t\tif (typeVariables.length != length) return IMPOSSIBLE_MATCH;", "-\t\t// verify each parameters", "-\t\treturn level; // we can't do better", "-\t\t// TODO (frederic) need to do more verifications here?", "-\t} else if (!type.isParameterizedType() && !isRawType) {", "-\t\t// Standard types (ie. neither generic nor parameterized nor raw types)", "-\t\t// cannot match pattern when it has type parameters or arguments", "-\t\treturn IMPOSSIBLE_MATCH;", "-\t} else {", "-\t\t// Binding is parameterized type", "-\t\tParameterizedTypeBinding paramTypeBinding = (ParameterizedTypeBinding) type;", "-\t\tif (paramTypeBinding.arguments == null) {", "-\t\t\t// binding has no type parameters => ok for raw types", "-\t\t\tif (isRawType) return level;", "-\t\t\t// need to verify hierarchy for member types", "-\t\t\tif (type.isMemberType() && qualificationPattern != null) {", "-\t\t\t\tint lastDot = CharOperation.lastIndexOf('.', qualificationPattern);", "-\t\t\t\tchar[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);", "-\t\t\t\tchar[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);", "-\t\t\t\tif (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, typeNames, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t}", "-\t\t\t\treturn level;", "-\t\t\t}", "-\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t}", "-\t\t// type parameters length must match at least specified type names length", "-\t\tint length = typeNames.length;", "-\t\tif (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;", "-\t\t// verify each type parameter", "-\t\tif (declaration) {", "-\t\t\t// TODO (frederic) more verification to do here with type parameter bounds?", "-\t\t\treturn level;", "-\t\t}", "-\t\tnextTypeArgument: for (int i= 0; i<length; i++) {", "-\t\t\tchar[] argType = typeNames[i];", "-\t\t\tTypeBinding argTypeBinding = paramTypeBinding.arguments[i];", "-\t\t\t// get pattern wildcard", "-\t\t\tint patternWildcard = this.pattern.wildcards[i];", "-\t\t\tif (patternWildcard == Wildcard.UNBOUND) continue;", "-\t\t\t// try to resolve pattern", "-\t\t\tTypeBinding patternBinding = this.pattern.getTypeNameBinding(this.unitScope, i);", "-\t\t\tif (patternBinding != null) {", "-\t\t\t\t// We can bind pattern type name => verify that types are compatible", "-\t\t\t\tif (argTypeBinding == patternBinding) continue;", "-\t\t\t\tif (argTypeBinding.isWildcard()) {", "-\t\t\t\t\tTypeBinding bound = ((WildcardBinding) argTypeBinding).bound;", "-\t\t\t\t\tif (this.pattern.wildcards != null) {", "-\t\t\t\t\t\tswitch (this.pattern.wildcards[i]) {", "-\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\tif (bound == null || patternBinding.isCompatibleWith(bound))", "-\t\t\t\t\t\t\t\t\t// argument type is in bound hierarchy => valid", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\tif (bound == null || bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t\t// argument type is a subclass of bound => valid", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tdefault: //UNBOUND", "-\t\t\t\t\t\t\t\t// there's no bound name to match => valid", "-\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "-\t\t\t", "-\t\t\t// pattern hasn't be solved, try to see if names match in hierarchy", "-\t\t\t// First if type argument is a wildcard", "-\t\t\tif (argTypeBinding.isWildcard()) {", "-\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;", "-\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t// We cannot know in this case...", "-\t\t\t\t\t\tlevel = INACCURATE_MATCH;", "-\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t// there's no bound name to match => valid", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t\t\t\t// try to match name in hierarchy", "-\t\t\t\tReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;", "-\t\t\t\twhile (boundBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(argType, boundBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(argType, boundBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "-\t\t\t\t\t}", "-\t\t\t\t\tboundBinding = boundBinding.superclass();", "-\t\t\t\t}", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "-\t\t\t", "-\t\t\t// try to match names when there's no wildcard", "-\t\t\tReferenceBinding refBinding = null;", "-\t\t\tif (argTypeBinding.isArrayType()) {", "-\t\t\t\tTypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;", "-\t\t\t\tif (!leafBinding.isBaseType()) {", "-\t\t\t\t\trefBinding = (ReferenceBinding) leafBinding;", "-\t\t\t\t}", "-\t\t\t} else if (!argTypeBinding.isBaseType()) {", "-\t\t\t\trefBinding = (ReferenceBinding) argTypeBinding;", "-\t\t\t}", "-\t\t\tif (refBinding == null) {", "-\t\t\t\t// Based type", "-\t\t\t\tif (!CharOperation.equals(argType, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&", "-\t\t\t\t\t!CharOperation.equals(argType, argTypeBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\twhile (refBinding != null) {", "-\t\t\t\t\tif (CharOperation.equals(argType, refBinding.shortReadableName(), this.isCaseSensitive) ||", "-\t\t\t\t\t\tCharOperation.equals(argType, refBinding.readableName(), this.isCaseSensitive)) {", "-\t\t\t\t\t\tcontinue nextTypeArgument;", "-\t\t\t\t\t}", "-\t\t\t\t\trefBinding = refBinding.superclass();", "-\t\t\t\t}", "-\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t}", "-\t\t}", "-\t\treturn level;", "-\t}"]}], "num": 46175}