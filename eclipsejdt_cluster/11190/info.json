{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b6a0db6810b10ad6bf56acbb45c9bb57", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3b73423293c979e5973259a163c7a86c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "af330be1052a8d3b1a31b10596d367fb42f89f79", "commitAfterChange": "b3a6b4ddf9d5bd5365b7e897739a001bb2ff860b", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod)", "signatureAfterChange": " boolean doesSubstituteMethodOverride(MethodBinding method, MethodBinding substituteMethod)", "diff": ["+// if it does not then a name clash error is likely", "-\tif (doTypeVariablesClash(method, substituteMethod)) return false;", "-\tif (areParametersEqual(method, substituteMethod)) return true;", "-\tif (method.declaringClass == substituteMethod.declaringClass) return false;", "+\tif (!areParametersEqual(method, substituteMethod)) {", "+\t\t// method can still override substituteMethod in cases like :", "+\t\t// <U extends Number> void c(U u) {}", "+\t\t// @Override void c(Number n) {}", "+\t\t// but method cannot have a \"generic-enabled\" parameter type", "+\t\tif (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))", "+\t\t\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);", "+\t\treturn false;", "+\t}", "+\tif (substituteMethod instanceof ParameterizedGenericMethodBinding) {", "+\t\t// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does", "+\t\treturn ! (hasGenericParameter(method) && method.typeVariables == Binding.NO_TYPE_VARIABLES);", "+\t}", "+", "+\t// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()", "+\treturn method.typeVariables == Binding.NO_TYPE_VARIABLES;", "+}", "-\tTypeBinding[] inheritedParams = substituteMethod.parameters;", "-\tint length = params.length;", "-\tif (length != inheritedParams.length)", "-\t\treturn false;", "-", "-\t// also allow a method such as Number foo(Number) to override <U> T foo(T) where T extends Number", "-\tif (method.typeVariables != Binding.NO_TYPE_VARIABLES || !substituteMethod.hasSubstitutedParameters())", "-\t\treturn false;", "-", "-\tfor (int i = 0; i < length; i++) {", "-\t\tif (inheritedParams[i].kind() == Binding.TYPE_PARAMETER) {", "-\t\t\tif (params[i] != ((TypeVariableBinding) inheritedParams[i]).upperBound())", "-\t\t\t\treturn false;", "-\t\t} else if (params[i] != inheritedParams[i]) {", "-\t\t\treturn false;\t\t\t", "-\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "641715c8512a99dac96326b8b56bd37e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "36cfe82a075699d2a0eb4fa6f987724ecb548c8c", "commitAfterChange": "37d61d5c5c650829214bf858cd078e7d345a9a26", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["-private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "+void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {", "-\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "-\t\t\t&& isTypeSubstituable(currentMethod.returnType, inheritedMethod.returnType);", "-\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t\t// can be [] of Class#RAW vs. Class<T>", "-\t\t\tif (!isReturnTypeSubstituable(currentMethod, inheritedMethod)) {", "-\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t\t\tcontinue nextMethod;", "-\t\t\t} else if (inheritedMethod.typeVariables.length != currentMethod.typeVariables.length) {", "-\t\t\t\t// TODO (kent) work to do on this case", "-\t\t\t\tif (currentMethod.typeVariables.length == 0 && inheritedMethod.declaringClass.isRawType()) {", "-\t\t\t\t\t// bug 69626", "-\t\t\t\t\t// no error since the inheritedMethod's type variables are ignored in raw types... why does a raw type binding not remove the type variables?", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-//\t\t\t\t\tthis.problemReporter(currentMethod).nameClash(currentMethod, inheritedMethod);", "-\t\t\t\t\tcontinue nextMethod;", "+\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "+\t\t\tthis.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "+\t\t} else {", "+\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\t\tif (inheritedMethod.isFinal())", "+\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "+\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "-\t\t    MethodBinding original = inheritedMethod.original();", "-\t\t    if (!isReturnTypeSubstituable(original, currentMethod) || !areParameterErasuresEqual(original, currentMethod))", "-\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "-\t\t}", "-", "-\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\tif (inheritedMethod.isFinal())", "-\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);"]}], "num": 11190}