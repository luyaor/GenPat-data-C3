{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba528a50fe9b77e647761aa1340de751", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87449223cc40ea8b6c01b45c1628eee9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "signatureAfterChange": "  public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["-\t}", "-\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "-\t", "-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "-\t", "-\t\t//If inlinable field, forget the access emulation, the code gen will directly target it", "-\t\tif (constant != Constant.NotAConstant)", "-\t\t\treturn;", "-\t", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\tFieldBinding codegenField = fieldBinding.original();", "-\t\t\tthis.codegenBinding = codegenField;", "-\t\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t\t&& (codegenField.isPrivate() // private access", "-\t\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "-\t\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "-\t\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "-\t\t\t\t\t\tenclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "-\t\t\t\treturn;", "-\t\t\t// if the binding declaring class is not visible, need special action", "-\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t\t// and not from Object or implicit static field access.\t", "-\t\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "-\t\t\t\t\t&& !this.actualReceiverType.isArrayType()", "-\t\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "-\t\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "-\t\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "-\t\t\t\t\t\t&& fieldBinding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "+", "+\t//If inlinable field, forget the access emulation, the code gen will directly target it", "+\tif (this.constant != Constant.NotAConstant)", "+\t\treturn;", "+", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\tFieldBinding codegenField = fieldBinding.original();", "+\t\tthis.codegenBinding = codegenField;", "+\t\tif (((this.bits & ASTNode.DepthMASK) != 0)", "+\t\t\t&& (codegenField.isPrivate() // private access", "+\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "+\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "+\t\t\tif (this.syntheticAccessors == null)", "+\t\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\t\tthis.syntheticAccessors[isReadAccess ? SingleNameReference.READ : SingleNameReference.WRITE] = ", "+\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "+\t\t\t\t\tenclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "+\t\t\treturn;", "+\t\t}", "+\t\t// if the binding declaring class is not visible, need special action", "+\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t\t// and not from Object or implicit static field access.\t", "+\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "+\t\t\t\t&& !this.actualReceiverType.isArrayType()", "+\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "+\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "+\t\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "+\t\t\t\t\t&& fieldBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields", "-\t\t\t\t}", "-\t\t\t}\t\t\t\t\t", "-\t\t}", "+\t\t\t}", "+\t\t}\t\t\t\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a786b048b9ccc1ff722dd11cc5c2311", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["+\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\t\t// if field from parameterized type got found, use the original field at codegen time", "+\t\tif (this.binding instanceof ParameterizedFieldBinding) {", "+\t\t    ParameterizedFieldBinding parameterizedField = (ParameterizedFieldBinding) this.binding;", "+\t\t    this.codegenBinding = parameterizedField.originalField;", "+\t\t    FieldBinding fieldCodegenBinding = (FieldBinding)this.codegenBinding;", "+\t\t    // extra cast needed if field type was type variable", "+\t\t    if ((fieldCodegenBinding.type.tagBits & TagBits.HasTypeVariable) != 0) {", "+\t\t        this.genericCast = fieldCodegenBinding.type.genericCast(parameterizedField.type);", "+\t\t    }", "+\t\t}\t\t", "+\t\t\t\t\t\t\t&& fieldBinding.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "+\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "+\t\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "+\t\t\t\t\t\tenclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).addSyntheticMethod((FieldBinding) this.codegenBinding, isReadAccess);", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess((FieldBinding)this.codegenBinding, this, isReadAccess);", "-\t}", "-\tpublic void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {", "-\t", "-\t\tif (!flowInfo.isReachable()) return;", "-\t\tif ((bits & FIELD) != 0) {", "-\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\tif (((bits & DepthMASK) != 0) ", "-\t\t\t\t&& (fieldBinding.isPrivate() // private access", "-\t\t\t\t\t|| (fieldBinding.isProtected() // implicit protected access", "-\t\t\t\t\t\t\t&& fieldBinding.declaringClass.getPackage() ", "-\t\t\t\t\t\t\t\t!= currentScope.enclosingSourceType().getPackage()))) {", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[WRITE] = ", "-\t\t\t\t\t((SourceTypeBinding)currentScope.enclosingSourceType().", "-\t\t\t\t\t\tenclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).", "-\t\t\t\t\t\t\taddSyntheticMethod(fieldBinding, false);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(fieldBinding, this);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t\t// if the binding declaring class is not visible, need special action", "-\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t\t// and not from Object or implicit static field access.\t", "-\t\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "-\t\t\t\t&& !this.actualReceiverType.isArrayType()\t", "-\t\t\t\t&& fieldBinding.declaringClass != null", "-\t\t\t\t&& fieldBinding.constant == NotAConstant", "-\t\t\t\t&& ((currentScope.environment().options.targetJDK >= ClassFileConstants.JDK1_2 ", "-\t\t\t\t\t\t&& !fieldBinding.isStatic()", "-\t\t\t\t\t\t&& fieldBinding.declaringClass.id != T_Object) // no change for Object fields (if there was any)", "-\t\t\t\t\t|| !fieldBinding.declaringClass.canBeSeenBy(currentScope))){", "-\t\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);", "+\t\t\t\tthis.codegenBinding = ", "+\t\t\t\t    currentScope.enclosingSourceType().getUpdatedFieldBinding(", "+\t\t\t\t\t        (FieldBinding) this.codegenBinding, ", "+\t\t\t\t\t        (ReferenceBinding)this.actualReceiverType.erasure());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ce7eb50bd6523bf6fc1c6d0bf4d421c9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["+\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\t\t// if field from parameterized type got found, use the original field at codegen time", "+\t\tif (this.binding instanceof ParameterizedFieldBinding) {", "+\t\t    ParameterizedFieldBinding parameterizedField = (ParameterizedFieldBinding) this.binding;", "+\t\t    this.codegenBinding = parameterizedField.originalField;", "+", "+\t\t    // extra cast needed if field type has type variable", "+\t\t    if ((this.codegenBinding.type.tagBits & TagBits.HasTypeVariable) != 0) {", "+\t\t        this.genericCast = this.codegenBinding.type.genericCast(parameterizedField.type);", "+\t\t    }\t\t    ", "+\t\t} else {", "+\t\t    this.codegenBinding = this.binding;", "+\t\t}", "+\t\t", "+\t\t\t\tif (syntheticAccessors == null)", "+\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "+\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "+\t\t\t\t\t((SourceTypeBinding) binding.declaringClass).addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "+\t\t\tif (syntheticAccessors == null)", "+\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "+\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = destinationType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "+\t\t\t\tif (syntheticAccessors == null)", "+\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "+\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = currentCompatibleType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "+\t\tif (this.binding.declaringClass != this.receiverType", "+\t\t\t&& this.binding.declaringClass != null // array.length", "+\t\t\t&& this.binding.constant == NotAConstant", "+\t\t\t\t&& this.binding.declaringClass.id != T_Object)", "+\t\t\t\t|| !this.binding.declaringClass.canBeSeenBy(currentScope))) {", "+\t\t\t\t\tthis.codegenBinding,", "+\t\t\t\t\t(ReferenceBinding) this.receiverType.erasure());", "-\t */", "-\tpublic void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {", "-", "-\t\tif (!flowInfo.isReachable()) return;", "-\t\tif (binding.isPrivate()) {", "-\t\t\tif (currentScope.enclosingSourceType() != binding.declaringClass) {", "-\t\t\t\tsyntheticWriteAccessor =", "-\t\t\t\t\t((SourceTypeBinding) binding.declaringClass).addSyntheticMethod(binding, false);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(binding, this);", "-\t\t\t\treturn;", "-\t\t\t}", "-", "-\t\t} else if (receiver instanceof QualifiedSuperReference) { // qualified super", "-", "-\t\t\t// qualified super need emulation always", "-\t\t\tSourceTypeBinding destinationType =", "-\t\t\t\t(SourceTypeBinding) (((QualifiedSuperReference) receiver)", "-\t\t\t\t\t.currentCompatibleType);", "-\t\t\tsyntheticWriteAccessor = destinationType.addSyntheticMethod(binding, false);", "-\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(binding, this);", "-\t\t\treturn;", "-", "-\t\t} else if (binding.isProtected()) {", "-", "-\t\t\tSourceTypeBinding enclosingSourceType;", "-\t\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t\t&& binding.declaringClass.getPackage()", "-\t\t\t\t\t!= (enclosingSourceType = currentScope.enclosingSourceType()).getPackage()) {", "-", "-\t\t\t\tSourceTypeBinding currentCompatibleType =", "-\t\t\t\t\t(SourceTypeBinding) enclosingSourceType.enclosingTypeAt(", "-\t\t\t\t\t\t(bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\tsyntheticWriteAccessor =", "-\t\t\t\t\tcurrentCompatibleType.addSyntheticMethod(binding, false);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldWriteAccess(binding, this);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t}", "-\t\t// if the binding declaring class is not visible, need special action", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\tif (binding.declaringClass != this.receiverType", "-\t\t\t&& !this.receiverType.isArrayType()", "-\t\t\t&& binding.declaringClass != null // array.length", "-\t\t\t&& binding.constant == NotAConstant", "-\t\t\t&& ((currentScope.environment().options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t&& binding.declaringClass.id != T_Object)", "-\t\t\t//no change for Object fields (in case there was)", "-\t\t\t\t|| !binding.declaringClass.canBeSeenBy(currentScope))) {", "-\t\t\tthis.codegenBinding =", "-\t\t\t\tcurrentScope.enclosingSourceType().getUpdatedFieldBinding(", "-\t\t\t\t\tbinding,", "-\t\t\t\t\t(ReferenceBinding) this.receiverType);", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2e67473db0298489d798e3d920119bc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "30dfd49146d073c0ca77ec54f45987be483492de", "commitAfterChange": "b6791838b5fdf2dfb8325a3a5a7e1c11f48ab412", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["-\t */", "-\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "-", "-\t\tif (!flowInfo.isReachable()) return;", "-\t\t// if field from parameterized type got found, use the original field at codegen time", "-\t\tthis.codegenBinding = this.binding.original();", "-\t\t", "-\t\tif (binding.isPrivate()) {", "-\t\t\tif ((currentScope.enclosingSourceType() != this.codegenBinding.declaringClass) && !binding.isConstantValue()) {", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "-\t\t\t\t\t((SourceTypeBinding) this.codegenBinding.declaringClass).addSyntheticMethod(this.codegenBinding, isReadAccess);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "-\t\t\t\treturn;", "-\t\t\t}", "-", "-\t\t} else if (receiver instanceof QualifiedSuperReference) { // qualified super", "-", "-\t\t\t// qualified super need emulation always", "-\t\t\tSourceTypeBinding destinationType =", "-\t\t\t\t(SourceTypeBinding) (((QualifiedSuperReference) receiver)", "-\t\t\t\t\t.currentCompatibleType);", "+ */", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\tif (!flowInfo.isReachable()) return;", "+\t// if field from parameterized type got found, use the original field at codegen time", "+\tthis.codegenBinding = this.binding.original();", "+\t", "+\tif (binding.isPrivate()) {", "+\t\tif ((currentScope.enclosingSourceType() != this.codegenBinding.declaringClass) ", "+\t\t\t\t&& binding.constant() == Constant.NotAConstant) {", "-\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = destinationType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "+\t\t\t\t((SourceTypeBinding) this.codegenBinding.declaringClass).addSyntheticMethod(this.codegenBinding, isReadAccess);", "-", "-\t\t} else if (binding.isProtected()) {", "-", "-\t\t\tSourceTypeBinding enclosingSourceType;", "-\t\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t\t&& binding.declaringClass.getPackage()", "-\t\t\t\t\t!= (enclosingSourceType = currentScope.enclosingSourceType()).getPackage()) {", "-", "-\t\t\t\tSourceTypeBinding currentCompatibleType =", "-\t\t\t\t\t(SourceTypeBinding) enclosingSourceType.enclosingTypeAt(", "-\t\t\t\t\t\t(bits & DepthMASK) >> DepthSHIFT);", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = currentCompatibleType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "-\t\t\t\treturn;", "-\t\t\t}", "-\t\t// if the binding declaring class is not visible, need special action", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t// and not from Object or implicit static field access.\t", "-\t\tif (this.binding.declaringClass != this.receiverType", "-\t\t\t\t&& !this.receiverType.isArrayType()", "-\t\t\t\t&& this.binding.declaringClass != null // array.length", "-\t\t\t\t&& !this.binding.isConstantValue()) {", "-\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(receiver.isImplicitThis() && this.codegenBinding.isStatic()))", "-\t\t\t\t\t&& this.binding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "-\t\t\t\t|| !this.binding.declaringClass.canBeSeenBy(currentScope)) {", "-\t", "-\t\t\t\tthis.codegenBinding =", "-\t\t\t\t\tcurrentScope.enclosingSourceType().getUpdatedFieldBinding(", "-\t\t\t\t\t\tthis.codegenBinding,", "-\t\t\t\t\t\t(ReferenceBinding) this.receiverType.erasure());", "-\t\t\t}", "-\t\t}\t\t", "-\t}", "+\t} else if (receiver instanceof QualifiedSuperReference) { // qualified super", "+\t\t// qualified super need emulation always", "+\t\tSourceTypeBinding destinationType =", "+\t\t\t(SourceTypeBinding) (((QualifiedSuperReference) receiver)", "+\t\t\t\t.currentCompatibleType);", "+\t\tif (syntheticAccessors == null)", "+\t\t\tsyntheticAccessors = new MethodBinding[2];", "+\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = destinationType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "+\t\treturn;", "+", "+\t} else if (binding.isProtected()) {", "+", "+\t\tSourceTypeBinding enclosingSourceType;", "+\t\tif (((bits & DepthMASK) != 0)", "+\t\t\t&& binding.declaringClass.getPackage()", "+\t\t\t\t!= (enclosingSourceType = currentScope.enclosingSourceType()).getPackage()) {", "+", "+\t\t\tSourceTypeBinding currentCompatibleType =", "+\t\t\t\t(SourceTypeBinding) enclosingSourceType.enclosingTypeAt(", "+\t\t\t\t\t(bits & DepthMASK) >> DepthSHIFT);", "+\t\t\tif (syntheticAccessors == null)", "+\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "+\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = currentCompatibleType.addSyntheticMethod(this.codegenBinding, isReadAccess);", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(this.codegenBinding, this, isReadAccess);", "+\t\t\treturn;", "+\t// if the binding declaring class is not visible, need special action", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t// and not from Object or implicit static field access.\t", "+\tif (this.binding.declaringClass != this.receiverType", "+\t\t\t&& !this.receiverType.isArrayType()", "+\t\t\t&& this.binding.declaringClass != null // array.length", "+\t\t\t&& this.binding.constant() == Constant.NotAConstant) {", "+\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !(receiver.isImplicitThis() && this.codegenBinding.isStatic()))", "+\t\t\t\t&& this.binding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+\t\t\t|| !this.binding.declaringClass.canBeSeenBy(currentScope)) {", "+\t\t\tthis.codegenBinding =", "+\t\t\t\tcurrentScope.enclosingSourceType().getUpdatedFieldBinding(", "+\t\t\t\t\tthis.codegenBinding,", "+\t\t\t\t\t(ReferenceBinding) this.receiverType.erasure());", "+\t\t}", "+\t}\t\t", "+}"]}], "num": 30636}