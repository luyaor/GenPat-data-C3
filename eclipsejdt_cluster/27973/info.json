{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c524c13602a9dc52645a6e161a504d33", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4e96304e08db0a989b58a4461c21913d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java", "commitBeforeChange": "808ee1989aa546fef406f77c37a96f979df5219f", "commitAfterChange": "2528937997399f978f8c04c6800f46f957dbd27f", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(char[] pattern, char[] name, boolean prefixMatch)", "diff": ["+ */", "+public static final boolean camelCaseMatch(char[] pattern, char[] name, boolean prefixMatch) {", "+\tif (pattern == null)", "+\t\treturn true; // null pattern is equivalent to '*'", "+\tif (name == null)", "+\t\treturn false; // null name cannot match", "+", "+\treturn camelCaseMatch(pattern, 0, pattern.length, name, 0, name.length, prefixMatch);", "+}", "-\t\tif (iPattern == patternEnd) {", "-\t\t\t// We have exhausted pattern, so it's a match", "-\t\t\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7a280ce0af19a1969ddf2ccecad3a495", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "7bf8b664251457ee19a0ca0f4e524593e5cebbd2", "commitAfterChange": "c844b42e53f5e6c13f3c402081599074b3dd58c2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "diff": ["-\tif (name == null)", "-\t\treturn false; // null name cannot match", "-\tif (pattern == null)", "-\t\treturn true; // null pattern is equivalent to '*'", "-\tif (patternEnd < 0) \tpatternEnd = pattern.length();", "-\tif (nameEnd < 0) nameEnd = name.length();", "-", "-\tif (patternEnd <= patternStart) return nameEnd <= nameStart;", "-\tif (nameEnd <= nameStart) return false;", "-\t// check first pattern char", "-\tif (name.charAt(nameStart) != pattern.charAt(patternStart)) {", "-\t\t// first char must strictly match (upper/lower)", "-\t\treturn false;", "-\t}", "-", "-\tchar patternChar, nameChar;", "-\tint iPattern = patternStart;", "-\tint iName = nameStart;", "-", "-\t// Main loop is on pattern characters", "-\twhile (true) {", "-", "-\t\tiPattern++;", "-\t\tiName++;", "-", "-\t\tif (iPattern == patternEnd) {", "-\t\t\t// We have exhausted pattern, so it's a match", "-\t\t\treturn true;", "-\t\t}", "-", "-\t\tif (iName == nameEnd){", "-\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// For as long as we're exactly matching, bring it on (even if it's a lower case character)", "-\t\tif ((patternChar = pattern.charAt(iPattern)) == name.charAt(iName)) {", "-\t\t\tcontinue;", "-\t\t}", "-", "-\t\t// If characters are not equals, then it's not a match if patternChar is lowercase", "-\t\tif (patternChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar)) {", "-\t\t\treturn false;", "-\t\t}", "-", "-\t\t// patternChar is uppercase, so let's find the next uppercase in name", "-\t\twhile (true) {", "-\t\t\tif (iName == nameEnd){", "-\t            //\tWe have exhausted name (and not pattern), so it's not a match", "-\t\t\t\treturn false;", "-\t\t\t}", "-", "-\t\t\tnameChar = name.charAt(iName);", "-", "-\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL | ScannerHelper.C_DIGIT)) != 0) {", "-\t\t\t\t\t// nameChar is lowercase    ", "-\t\t\t\t\tiName++;", "-\t\t\t\t// nameChar is uppercase...", "-\t\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\t\t//.. and it does not match patternChar, so it's not a match", "-\t\t\t\t\treturn false;", "-\t\t\t\t} else {", "-\t\t\t\t\t//.. and it matched patternChar. Back to the big loop", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\telse if (Character.isJavaIdentifierPart(nameChar) && !Character.isUpperCase(nameChar)) {", "-\t\t\t\t// nameChar is lowercase    ", "-\t\t\t\tiName++;", "-\t\t\t// nameChar is uppercase...", "-\t\t\t} else  if (patternChar != nameChar) {", "-\t\t\t\t//.. and it does not match patternChar, so it's not a match", "-\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\t//.. and it matched patternChar. Back to the big loop", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\t// At this point, either name has been exhausted, or it is at an uppercase letter.", "-\t\t// Since pattern is also at an uppercase letter", "-\t}", "+\treturn CharOperation.camelCaseMatch(pattern.toCharArray(), patternStart, patternEnd, name.toCharArray(), nameStart, nameEnd);"]}], "num": 27973}