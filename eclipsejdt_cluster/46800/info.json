{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "505867c06e9e93bde85415ba99a5f7c7", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8eb7d75199d9ec2c499740baeb4fda8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "2894ba75386697d7bf484434d073fb6ffaf6cec9", "commitAfterChange": "c5ef0e6fd93c55fc5204e498f5b58ab9f95c6ab7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal Map<AnnotationProcessorFactory, FactoryPath.Attributes> factories, \t\t\tfinal Set<AnnotationProcessorFactory> currentRoundDispatchedBatchFactories, \t\t\tfinal ProcessorEnvImpl processorEnv, \t\t\tfinal List<IFile> filesWithMissingType, \t\t\tfinal List<ICompilationUnit> unitsForFilesWithMissingType, \t\t\tfinal int internalRound)", "signatureAfterChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal Map<IFile, Set<IFile>> lastGeneratedFiles, \t\t\tfinal ProcessorEnvImpl processorEnv)", "diff": ["-\t\t\tfinal Map<AnnotationProcessorFactory, FactoryPath.Attributes> factories,", "-\t\t\tfinal Set<AnnotationProcessorFactory> currentRoundDispatchedBatchFactories,", "-\t\t\tfinal ProcessorEnvImpl processorEnv,", "-\t\t\tfinal List<IFile> filesWithMissingType,", "-\t\t\tfinal List<ICompilationUnit> unitsForFilesWithMissingType,", "-\t\t\tfinal int internalRound)", "+\t\t\tfinal Map<IFile, Set<IFile>> lastGeneratedFiles,", "+\t\t\tfinal ProcessorEnvImpl processorEnv)", "-\t\tfinal IFile[] files = processorEnv.getFiles();", "-\t\tfinal Map<IFile, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = ", "-\t\t\tnew HashMap<IFile, Set<AnnotationTypeDeclaration>>(files.length * 4/3 + 1);", "+\t\tfinal ICompilationParticipantResult[] cpResults = processorEnv.getFilesWithAnnotation();", "+\t\tfinal Map<ICompilationParticipantResult, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = ", "+\t\t\tnew HashMap<ICompilationParticipantResult, Set<AnnotationTypeDeclaration>>(cpResults.length * 4/3 + 1);", "-\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( _factories.size() * 4/3 + 1 );", "-\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );\t\t", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( _factories.size() * 4/3 + 1 );\t\t", "-\t\tfor( Map.Entry<AnnotationProcessorFactory, FactoryPath.Attributes> entry : factories.entrySet() ){", "+\t\tfor( Map.Entry<AnnotationProcessorFactory, FactoryPath.Attributes> entry : _factories.entrySet() ){", "-\t\taddAllFilesWithMissingTypeError(filesWithMissingType, unitsForFilesWithMissingType, processorEnv);", "-\t\t", "-\t\t// Batch processors only get executed on a full/clean build and only get called once", "-\t\t// within one round APT dispatch.\t\t", "-\t\tif( internalRound == 0 ){", "+\t\t// Batch processors only get executed on a full/clean build", "+\t\tif( !batchFactory2Annos.isEmpty() || ", "+\t\t\t(_dispatchedBatchFactories != null && !_dispatchedBatchFactories.isEmpty()) ){ ", "+\t\t\t\t", "+\t\t\tprocessorEnv.beginBatchProcessing();", "-\t\t\t\tprocessorEnv.setBatchProcessing();", "-\t\t\t\tfor(AnnotationProcessorFactory factory : factories.keySet() ){\t\t\t", "+\t\t\t\t_currentDispatchBatchFactories = new LinkedHashSet<AnnotationProcessorFactory>();", "+\t\t\t\tfor(AnnotationProcessorFactory factory : _factories.keySet() ){\t\t\t", "-\t\t\t\t\t\tcurrentRoundDispatchedBatchFactories.add(factory);", "+\t\t\t\t\t\t_currentDispatchBatchFactories.add(factory);", "-\t\t\t\t}\t\t\t", "-\t\t\t}", "-\t\t\tprocessorEnv.setBatchProcessing();", "+\t\t\t\t}", "+\t\t\t}\t", "+\t\t\t// We have to dispatch to factories even though we may not have discovered any annotations.", "+\t\t\t// This is a documented APT behavior that we have to observe. ", "+\t\t\t// TODO: where do we put the results in the case?", "-\t\t\t\tif(currentRoundDispatchedBatchFactories.contains(prevRoundFactory))", "+\t\t\t\tif(_currentDispatchBatchFactories.contains(prevRoundFactory))", "+\t\t\t", "+\t\t\t// Currently, we are putting everything in the first file with annotations.", "+\t\t\t// TODO: is this the correct thing to do? ", "+\t\t\t// what about the case where there are no files with annotations? ", "+\t\t\t// where to put the result? ", "+\t\t\tif( cpResults.length >  0 ){", "+\t\t\t\tfinal GeneratedFileManager gfm = _aptProject.getGeneratedFileManager();", "+\t\t\t\treportResult(", "+\t\t\t\t\t\tcpResults[0],  // just put it all in ", "+\t\t\t\t\t\tlastGeneratedFiles.get(null), ", "+\t\t\t\t\t\tprocessorEnv.getAllGeneratedFiles(),", "+\t\t\t\t\t\tprocessorEnv.getModifiedGeneratedFiles(), ", "+\t\t\t\t\t\tprocessorEnv.getProblems(),  // this is empty in batch mode.", "+\t\t\t\t\t\tprocessorEnv.getTypeDependencies(),  // this is empty in batch mode.", "+\t\t\t\t\t\tgfm, ", "+\t\t\t\t\t\tprocessorEnv);", "+\t\t\t\tprocessorEnv.completedBatchProcessing();", "+\t\t\t}", "-\t\t\tfor( int fileIndex=0, numFiles=files.length; fileIndex<numFiles; fileIndex ++ ){", "-\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesInFile = file2AnnotationDecls.get(files[fileIndex]);", "+\t\t\tfor(ICompilationParticipantResult curResult : cpResults ){", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesInFile = file2AnnotationDecls.get(curResult);", "-\t\t\t\tfor(AnnotationProcessorFactory factory : factories.keySet() ){", "+\t\t\t\tfor(AnnotationProcessorFactory factory : _factories.keySet() ){", "-\t\t\t\t\t\tprocessorEnv.setFileProcessing(files[fileIndex]);", "+\t\t\t\t\t\tprocessorEnv.beginFileProcessing(curResult);", "+\t\t\t\t", "+\t\t\t\tfinal GeneratedFileManager gfm = _aptProject.getGeneratedFileManager();", "+\t\t\t\tfinal IFile curFile = curResult.getFile();", "+\t\t\t\treportResult(", "+\t\t\t\t\t\tcurResult,", "+\t\t\t\t\t\tlastGeneratedFiles.get(curFile),", "+\t\t\t\t\t\tprocessorEnv.getAllGeneratedFiles(),", "+\t\t\t\t\t\tprocessorEnv.getModifiedGeneratedFiles(),", "+\t\t\t\t\t\tprocessorEnv.getProblems(),", "+\t\t\t\t\t\tprocessorEnv.getTypeDependencies(),", "+\t\t\t\t\t\tgfm,", "+\t\t\t\t\t\tprocessorEnv);", "+\t\t\t\tprocessorEnv.completedFileProcessing();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0b4366bd6d8f8fd10c88340b3c02416", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "372799d5bd955eabbf1069fe0bbf8aba8ea8af85", "commitAfterChange": "baf433f0226e8b9036b18a28d560e5a42cb8b949", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations( \t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env)", "signatureAfterChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal List<AnnotationProcessorFactory> factories, \t\t\tfinal ProcessorEnvImpl processorEnv)", "diff": ["+\t */", "+\tprivate void runAPTInMixedMode(", "+\t\t\tfinal List<AnnotationProcessorFactory> factories,", "+\t\t\tfinal ProcessorEnvImpl processorEnv)", "+\t{", "+\t\tfinal Map<IFile, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = ", "+\t\t\tnew HashMap<IFile, Set<AnnotationTypeDeclaration>>(_filesToProcess.length * 4/3 + 1);", "+\t\tfinal Map<String, AnnotationTypeDeclaration> annotationDecls = ", "+\t\t\tprocessorEnv.getAllAnnotationTypes(file2AnnotationDecls);\t", "+\t\t", "+\t\tSystem.err.println(file2AnnotationDecls);", "+\t\t", "+\t\tif (annotationDecls.isEmpty())", "+\t\t{", "+\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\ttrace( \"runAPT:  leaving early because annotationDecls is empty\" ); //$NON-NLS-1$", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\t// file based processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> fileFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );", "+\t\t", "+\t\t// batch processing factory to the set of annotations that it 'claims'", "+\t\tfinal Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> batchFactory2Annos =", "+\t\t\tnew HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( factories.size() * 4/3 + 1 );\t\t", "+\t\t", "+\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\tSet<AnnotationTypeDeclaration> annotationTypes = getFactorySupportedAnnotations(factory, annotationDecls);", "+\t\t\tif( annotationTypes != null ){", "+\t\t\t\t", "+\t\t\t\tboolean batch = isBatchFactory(factory);", "+\t\t\t\tMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration> > factory2Annos = ", "+\t\t\t\t\tbatch ? batchFactory2Annos : fileFactory2Annos;", "+\t\t\t\tif( annotationTypes.size() == 0 ){", "+\t\t\t\t\t// this factory is claiming all (remaining) annotations. ", "+\t\t\t\t\tannotationTypes = new HashSet<AnnotationTypeDeclaration>(annotationDecls.values());", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t\tannotationDecls.clear();", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\telse{", "+\t\t\t\t\tfactory2Annos.put(factory, annotationTypes);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif( annotationDecls.isEmpty() )", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t", "+\t\tif( ! annotationDecls.isEmpty() )", "+\t\t\t; // TODO: (theodora) log unclaimed annotations.", "+\t\t", "+\t\t// Dispatch to the batch process factories first.", "+\t\t// Batch processors only get executed on a full/clean build.", "+\t\tif( !batchFactory2Annos.isEmpty() ){", "+\t\t\tprocessorEnv.setBatchProcessing();", "+\t\t\t// Once we figure out which factory claims what annotation,", "+\t\t\t// the order of the factory doesn't matter.", "+\t\t\t// But in order to make things consists between runs, will ", "+\t\t\t// dispatch base on factory order.", "+\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);", "+\t\t\t\tif( annotationTypes == null ) continue;", "+\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\tfactory.getProcessorFor(annotationTypes, processorEnv);", "+\t\t\t\tif( processor != null ){", "+\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\ttrace( \"runAPT: invoking batch processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\tprocessor.process();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Now, do the file based dispatch", "+\t\tif( !fileFactory2Annos.isEmpty() ){", "+\t\t\tfor( int fileIndex=0, numFiles=_filesToProcess.length; fileIndex<numFiles; fileIndex ++ ){", "+\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesInFile = file2AnnotationDecls.get(_filesToProcess[fileIndex]);", "+\t\t\t\tif( annotationTypesInFile == null || annotationTypesInFile.isEmpty() )", "+\t\t\t\t\tcontinue;", "+\t\t\t\tfor( int i=0, size=factories.size(); i<size; i++ ){", "+\t\t\t\t\tfinal AnnotationProcessorFactory factory = factories.get(i);", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypesForFactory = fileFactory2Annos.get(factory);", "+\t\t\t\t\tif( annotationTypesForFactory == null || annotationTypesForFactory.isEmpty() ) ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> intersect = setIntersect(annotationTypesInFile, annotationTypesForFactory);", "+\t\t\t\t\tif( intersect != null && !intersect.isEmpty() ){", "+\t\t\t\t\t\tprocessorEnv.setFileProcessing(_filesToProcess[fileIndex]);", "+\t\t\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\t\t\tfactory.getProcessorFor(intersect, processorEnv);", "+\t\t\t\t\t\tif( processor != null ){", "+\t\t\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\t\t\ttrace( \"runAPT: invoking file-based processor \" + processor.getClass().getName() ); //$NON-NLS-1$", "+\t\t                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\t\t\tprocessor.process();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "-", "-\tprivate static Map<String, AnnotationTypeDeclaration> getAnnotationTypeDeclarations(", "-\t\t\tCompilationUnit astCompilationUnit, BaseProcessorEnv env) {", "-\t\tfinal List<Annotation> instances = new ArrayList<Annotation>();", "-\t\tfinal AnnotationVisitor visitor = new AnnotationVisitor(instances);", "-\t\tastCompilationUnit.accept(visitor);", "-\t\tfinal Map<String, AnnotationTypeDeclaration> decls = new HashMap<String, AnnotationTypeDeclaration>();", "-\t\tfor (int i = 0, size = instances.size(); i < size; i++) {", "-\t\t\tfinal Annotation instance = instances.get(i);", "-\t\t\tfinal ITypeBinding annoType = instance.resolveTypeBinding();", "-\t\t\tif (annoType == null)", "-\t\t\t\tcontinue;", "-\t\t\tfinal TypeDeclarationImpl annoDecl = Factory.createReferenceType(", "-\t\t\t\t\tannoType, env);", "-\t\t\tif (annoDecl.kind() == EclipseMirrorImpl.MirrorKind.TYPE_ANNOTATION)", "-\t\t\t\tdecls.put(annoDecl.getQualifiedName(),", "-\t\t\t\t\t\t(AnnotationTypeDeclaration) annoDecl);", "-\t\t}", "-\t\treturn decls;", "-\t}"]}], "num": 46800}