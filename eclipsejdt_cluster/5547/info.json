{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8914075366dde762d4ea6a20dc5c71d0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "21adab4f00e08f64b329ce6088e90c59", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "bde9840f9573d77080a23dfde60bdb51dc549649", "commitAfterChange": "e5950298e29dbaf979a85e6f3f4a27d3f4b008e8", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "signatureAfterChange": " \tprotected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "diff": ["-\t\tICompilationUnit[] compilationUnits = null;", "-\t\ttry {", "-\t\t\tcompilationUnits = pkg.getCompilationUnits();", "-\t\t} catch (JavaModelException npe) {", "-\t\t\t// the package is not present", "-\t\t\tcompilationUnits = new ICompilationUnit[0];", "-\t\t}", "-", "-\t\t// replace with working copies to look inside", "-\t\tint length= compilationUnits.length;", "-\t\tboolean[] isWorkingCopy = new boolean[length];", "-\t\tint workingCopiesSize;", "-\t\tif (this.unitsToLookInside != null && (workingCopiesSize = this.unitsToLookInside.size()) > 0) {", "-\t\t\tMap temp = new HashMap(workingCopiesSize);", "-\t\t\ttemp.putAll(this.unitsToLookInside);", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tICompilationUnit unit = compilationUnits[i];", "-\t\t\t\tICompilationUnit workingCopy = (ICompilationUnit)temp.remove(unit);", "-\t\t\t\tif (workingCopy != null) {", "-\t\t\t\t\tcompilationUnits[i] = workingCopy;", "-\t\t\t\t\tisWorkingCopy[i] = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// add remaining working copies that belong to this package", "-\t\t\tint index = 0;", "-\t\t\tCollection values = temp.values();", "-\t\t\tIterator iterator = values.iterator();", "-\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\tICompilationUnit workingCopy = (ICompilationUnit)iterator.next();", "-\t\t\t\tif (pkg.equals(workingCopy.getParent())) {", "-\t\t\t\t\tif (index == 0) {", "-\t\t\t\t\t\tint valuesLength = values.size();", "-\t\t\t\t\t\tindex = length;", "-\t\t\t\t\t\tlength += valuesLength;", "-\t\t\t\t\t\tSystem.arraycopy(compilationUnits, 0, compilationUnits = new ICompilationUnit[length], 0, index);", "-\t\t\t\t\t\tSystem.arraycopy(isWorkingCopy, 0, isWorkingCopy = new boolean[length], 0, index);", "+\t\tif (!partialMatch) {", "+\t\t\tint firstDot = name.indexOf('.');", "+\t\t\tString topLevelTypeName = firstDot == -1 ? name : name.substring(0, firstDot);", "+\t\t\t", "+\t\t\t// look in unitsToLookInside first", "+\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "+\t\t\tif (typeMap != null) {", "+\t\t\t\tObject object = typeMap.get(topLevelTypeName);", "+\t\t\t\tif (object instanceof IType) {", "+\t\t\t\t\tIType type = getMemberType((IType) object, name, firstDot);", "+\t\t\t\t\tif (acceptType(type, acceptFlags)) {", "+\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t\treturn; // don't continue with compilation unit", "-\t\t\t\t\tisWorkingCopy[index] = true; ", "-\t\t\t\t\tcompilationUnits[index++] = workingCopy;", "+\t\t\t\t} else if (object instanceof IType[]) {", "+\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "+\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++) {", "+\t\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tIType type = getMemberType(topLevelTypes[i], name, firstDot);", "+\t\t\t\t\t\tif (acceptType(type, acceptFlags)) {", "+\t\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t\t\treturn; // return the first one", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\tif (index > 0 && index < length) {", "-\t\t\t\tSystem.arraycopy(compilationUnits, 0, compilationUnits = new ICompilationUnit[index], 0, index);", "-\t\t\t\tSystem.arraycopy(isWorkingCopy, 0, isWorkingCopy = new boolean[index], 0, index);", "-\t\t\t\tlength = index;", "-\t\t\t}", "-\t\t}", "-\t\tString matchName = name;", "-\t\tint index= name.indexOf('$');", "-\t\tboolean potentialMemberType = false;", "-\t\tString potentialMatchName = null;", "-\t\tif (index != -1) {", "-\t\t\t//the compilation unit name of the inner type", "-\t\t\tpotentialMatchName = name.substring(0, index);", "-\t\t\tpotentialMemberType = true;", "-\t\t}", "-", "-\t\t/**", "-\t\t * In the following, matchName will never have the extension \".java\" and ", "-\t\t * the compilationUnits always will. So compare ignoring extension if we're looking for ", "-\t\t * an exact match.", "-\t\t */", "-\t\tString unitName = partialMatch ? matchName.toLowerCase() : matchName;", "-\t\tString potentialUnitName = null;", "-\t\tif (potentialMemberType) {", "-\t\t\tpotentialUnitName = partialMatch ? potentialMatchName.toLowerCase() : potentialMatchName;", "-\t\t}", "-", "-\t\tfor (int i= 0; i < length; i++) {", "-\t\t\tif (requestor.isCanceled())", "-\t\t\t\treturn;", "-\t\t\tICompilationUnit compilationUnit= compilationUnits[i];", "-\t\t\t", "-\t\t\tif ((isWorkingCopy[i] && !potentialMemberType)", "-\t\t\t\t\t|| nameMatches(unitName, compilationUnit, partialMatch)) {", "-\t\t\t\t\t\t", "-\t\t\t\tIType[] types= null;", "-\t\t\t\ttry {", "-\t\t\t\t\ttypes= compilationUnit.getTypes();", "-\t\t\t\t} catch (JavaModelException npe) {", "-\t\t\t\t\tcontinue; // the compilation unit is not present", "-\t\t\t\t}", "-\t\t\t\tint typeLength= types.length;", "-\t\t\t\tfor (int j= 0; j < typeLength; j++) {", "+\t\t\t// look in compilation units", "+\t\t\ttry {", "+\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "+\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "-\t\t\t\t\tIType type= types[j];", "-\t\t\t\t\tif (nameMatches(matchName, type, partialMatch)) {", "-\t\t\t\t\t\tif (acceptType(type, acceptFlags)) requestor.acceptType(type);", "+\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "+\t\t\t\t\tString cuName = cu.getElementName();", "+\t\t\t\t\tint lastDot = cuName.lastIndexOf('.');", "+\t\t\t\t\tif (!topLevelTypeName.equals(cuName.substring(0, lastDot))) ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tIType type = cu.getType(topLevelTypeName);", "+\t\t\t\t\ttype = getMemberType(type, name, firstDot);", "+\t\t\t\t\tif (acceptType(type, acceptFlags)) { // accept type checks for existence", "+\t\t\t\t\t\trequestor.acceptType(type);", "+\t\t\t\t\t\tbreak;  // since an exact match was requested, no other matching type can exist", "-\t\t\t} else if (potentialMemberType && nameMatches(potentialUnitName, compilationUnit, partialMatch)) {", "-\t\t\t\tIType[] types= null;", "-\t\t\t\ttry {", "-\t\t\t\t\ttypes= compilationUnit.getTypes();", "-\t\t\t\t} catch (JavaModelException npe) {", "-\t\t\t\t\tcontinue; // the compilation unit is not present", "-\t\t\t\t}", "-\t\t\t\tint typeLength= types.length;", "-\t\t\t\tfor (int j= 0; j < typeLength; j++) {", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// package doesn't exist -> ignore", "+\t\t\t}", "+\t\t} else {", "+\t\t\tString prefix = name.toLowerCase();", "+\t\t\tint firstDot = prefix.indexOf('.');", "+\t\t\t", "+\t\t\t// look in unitsToLookInside first", "+\t\t\tHashMap typeMap = (HashMap) (this.unitsToLookInside == null ? null : this.unitsToLookInside.get(pkg));", "+\t\t\tif (typeMap != null) {", "+\t\t\t\tIterator iterator = typeMap.values().iterator();", "+\t\t\t\twhile (iterator.hasNext()) {", "-\t\t\t\t\tIType type= types[j]; ", "-\t\t\t\t\tif (nameMatches(potentialMatchName, type, partialMatch)) {", "-\t\t\t\t\t\tseekQualifiedMemberTypes(name.substring(index + 1, name.length()), type, partialMatch, requestor, acceptFlags);", "+\t\t\t\t\tObject object = iterator.next();", "+\t\t\t\t\tif (object instanceof IType) {", "+\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, (IType) object, requestor, acceptFlags);", "+\t\t\t\t\t} else if (object instanceof IType[]) {", "+\t\t\t\t\t\tIType[] topLevelTypes = (IType[]) object;", "+\t\t\t\t\t\tfor (int i = 0, length = topLevelTypes.length; i < length; i++)", "+\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, topLevelTypes[i], requestor, acceptFlags);", "-", "+\t\t\t", "+\t\t\t// look in compilation units", "+\t\t\ttry {", "+\t\t\t\tString cuPrefix = firstDot == -1 ? prefix : prefix.substring(0, firstDot);", "+\t\t\t\tICompilationUnit[] compilationUnits = pkg.getCompilationUnits();", "+\t\t\t\tfor (int i = 0, length = compilationUnits.length; i < length; i++) {", "+\t\t\t\t\tif (requestor.isCanceled())", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\tICompilationUnit cu = compilationUnits[i];", "+\t\t\t\t\tif (!cu.getElementName().toLowerCase().startsWith(cuPrefix))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tIType[] types = cu.getTypes();", "+\t\t\t\t\t\tfor (int j = 0, typeLength = types.length; j < typeLength; j++)", "+\t\t\t\t\t\t\tseekTypesInTopLevelType(prefix, firstDot, types[j], requestor, acceptFlags);", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// cu doesn't exist -> ignore", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// package doesn't exist -> ignore", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac8abdbe9ec0d2f7ec4e46ebddb7dd05", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java", "commitBeforeChange": "87b777c1fc477e9b3f12a1e072f005600f998f84", "commitAfterChange": "f66fb438b9cc0be7e04e5e7cd4ac6af72beb4f11", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 31, "signatureBeforeChange": " \tprotected void buildUsingBatchCompiler(String options) throws IOException", "signatureAfterChange": " \tprotected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String projectOutput, final String compliance) throws CoreException", "diff": ["-\t */", "-\tprotected void buildUsingBatchCompiler(String options) throws IOException {", "-\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "-\t\tfinal IWorkspaceRoot workspaceRoot = workspace.getRoot();", "-\t\tfinal String targetWorkspacePath = workspaceRoot.getProject(JavaCore.PLUGIN_ID).getLocation().toFile().getCanonicalPath();", "-\t\tfinal String sources = targetWorkspacePath + File.separator + \"compiler\";", "-\t\tfinal String bins = targetWorkspacePath + File.separator + \"bin\"; //$NON-NLS-1$", "-\t\tfinal String logs = targetWorkspacePath + File.separator + \"log.txt\"; //$NON-NLS-1$", "-", "-\t\t// Warm up", "-\t\tString cmdLine = sources + \" -1.4 -g -preserveAllLocals \"+(options==null?\"\":options)+\" -d \" + bins + \" -log \" + logs; //$NON-NLS-1$ //$NON-NLS-2$", "-\t\tint errorsCount = 0;", "-\t\tfor (int i=0; i<2; i++) {", "-\t\t\tStringWriter errStrWriter = new StringWriter();", "-\t\t\tPrintWriter err = new PrintWriter(errStrWriter);", "-\t\t\tPrintWriter out = new PrintWriter(new StringWriter());", "-\t\t\tMain main = new Main(out, err, false);", "-\t\t\tmain.compile(Main.tokenize(cmdLine));", "-\t\t\tif (main.globalErrorsCount > 0 && main.globalErrorsCount != errorsCount) {", "-\t\t\t\tSystem.out.println(this.scenarioShortName+\": \"+errorsCount+\" Unexpected compile ERROR!\");", "-\t\t\t\tif (DEBUG) {", "-\t\t\t\t\tSystem.out.println(errStrWriter.toString());", "-\t\t\t\t\tSystem.out.println(\"--------------------\");", "-\t\t\t\t}", "-\t\t\t\terrorsCount = main.globalErrorsCount;", "-\t\t\t}", "-\t\t}", "-", "-\t\t// Clear memory", "-\t\trunGc();", "-", "-\t\t// Measures", "-\t\tint max = MEASURES_COUNT * 2;", "-\t\tint warnings = 0;", "-\t\tfor (int i = 0; i < max; i++) {", "-\t\t\tStringWriter errStrWriter = new StringWriter();", "-\t\t\tPrintWriter err = new PrintWriter(errStrWriter);", "-\t\t\tPrintWriter out = new PrintWriter(new StringWriter());", "-\t\t\tMain main = new Main(out, err, false);", "-\t\t\tmain.compile(Main.tokenize(cmdLine));", "-\t\t\tif (main.globalErrorsCount > 0 && main.globalErrorsCount != errorsCount) {", "-\t\t\t\tSystem.out.println(this.scenarioShortName+\": \"+errorsCount+\" Unexpected compile ERROR!\");", "-\t\t\t\tif (DEBUG) {", "-\t\t\t\t\tSystem.out.println(errStrWriter.toString());", "-\t\t\t\t\tSystem.out.println(\"--------------------\");", "-\t\t\t\terrorsCount = main.globalErrorsCount;", "-\t\t\tcleanupDirectory(new File(bins));", "-\t\t\twarnings = main.globalWarningsCount;", "-\t\t// Commit measures", "-", "-\t\t\tSystem.out.println(\"\\t- \"+warnings+\" warnings found while performing batch compilation.\");", "+\t */", "+\tprotected IJavaProject createJavaProject(final String projectName, final String[] sourceFolders, final String projectOutput, final String compliance) throws CoreException {", "+\t\tfinal IJavaProject[] result = new IJavaProject[1];", "+\t\tIWorkspaceRunnable create = new IWorkspaceRunnable() {", "+\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {", "+\t\t\t\t", "+\t\t\t\t// create classpath entries ", "+\t\t\t\tIProject project = ENV.getProject(projectName);", "+\t\t\t\tIPath projectPath = project.getFullPath();", "+\t\t\t\tint sourceLength = sourceFolders == null ? 0 : sourceFolders.length;", "+\t\t\t\tIClasspathEntry[] entries = new IClasspathEntry[sourceLength+1];", "+\t\t\t\tfor (int i= 0; i < sourceLength; i++) {", "+\t\t\t\t\tIPath sourcePath = new Path(sourceFolders[i]);", "+\t\t\t\t\tint segmentCount = sourcePath.segmentCount();", "+\t\t\t\t\tif (segmentCount > 0) {", "+\t\t\t\t\t\t// create folder and its parents", "+\t\t\t\t\t\tIContainer container = project;", "+\t\t\t\t\t\tfor (int j = 0; j < segmentCount; j++) {", "+\t\t\t\t\t\t\tIFolder folder = container.getFolder(new Path(sourcePath.segment(j)));", "+\t\t\t\t\t\t\tif (!folder.exists()) {", "+\t\t\t\t\t\t\t\tfolder.create(true, true, null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontainer = folder;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// create source entry", "+\t\t\t\t\tentries[i] = ", "+\t\t\t\t\t\tJavaCore.newSourceEntry(", "+\t\t\t\t\t\t\tprojectPath.append(sourcePath), ", "+\t\t\t\t\t\t\tnew IPath[0],", "+\t\t\t\t\t\t\tnew IPath[0], ", "+\t\t\t\t\t\t\tnull", "+\t\t\t\t\t\t);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// Add JRE_LIB entry", "+\t\t\t\tentries[sourceLength] = JavaCore.newVariableEntry(", "+\t\t\t\t\t\t\t\tnew Path(\"JRE_LIB\"),", "+\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\tnull);", "+", "+\t\t\t\t// create project's output folder", "+\t\t\t\tIPath outputPath = new Path(projectOutput);", "+\t\t\t\tif (outputPath.segmentCount() > 0) {", "+\t\t\t\t\tIFolder output = project.getFolder(outputPath);", "+\t\t\t\t\tif (!output.exists()) {", "+\t\t\t\t\t\toutput.create(true, true, null);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// set classpath and output location", "+\t\t\t\tIJavaProject javaProject = ENV.getJavaProject(projectName);", "+\t\t\t\tjavaProject.setRawClasspath(entries, projectPath.append(outputPath), null);", "+\t\t\t\t", "+\t\t\t\t// set compliance level options", "+\t\t\t\tif (\"1.5\".equals(compliance)) {", "+\t\t\t\t\tMap options = new HashMap();", "+\t\t\t\t\toptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "+\t\t\t\t\toptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);\t", "+\t\t\t\t\toptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);\t", "+\t\t\t\t\tjavaProject.setOptions(options);", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tresult[0] = javaProject;", "+\t\t\t}", "+\t\t};", "+\t\tResourcesPlugin.getWorkspace().run(create, null);\t", "+\t\treturn result[0];", "+\t}"]}], "num": 5547}