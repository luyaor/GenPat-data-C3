{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e2d587ea6bcb030c997e6dced43eadb9", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0332e89e55267d7d3ba5472eae6a6035", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CreateTypeMemberOperation.java", "commitBeforeChange": "90d481edc9060cc498a8f085b08186108312e37b", "commitAfterChange": "f3a3c06f6e68ab7680c250209b9759ac3d56fec6", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 2, "signatureBeforeChange": " private IDOMNode deprecatedGenerateElementDOM() throws JavaModelException", "signatureAfterChange": " protected ASTNode generateElementAST(ASTRewrite rewriter, IDocument document, ICompilationUnit cu) throws JavaModelException", "diff": ["+}", "+protected ASTNode generateElementAST(ASTRewrite rewriter, IDocument document, ICompilationUnit cu) throws JavaModelException {", "+\tif (this.createdNode == null) {", "+\t\tthis.source = removeIndentAndNewLines(this.source, document, cu);", "+\t\tASTParser parser = ASTParser.newParser(AST.JLS3);", "+\t\tparser.setSource(this.source.toCharArray());", "+\t\tparser.setProject(getCompilationUnit().getJavaProject());", "+\t\tparser.setKind(ASTParser.K_CLASS_BODY_DECLARATIONS);", "+\t\tASTNode node = parser.createAST(this.progressMonitor);", "+\t\tString createdNodeSource;", "+\t\tif (node.getNodeType() != ASTNode.TYPE_DECLARATION) {", "+\t\t\tcreatedNodeSource = generateSyntaxIncorrectAST();", "+\t\t\tif (this.createdNode == null)", "+\t\t\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_CONTENTS));", "+\t\t} else {", "+\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;", "+\t\t\tthis.createdNode = (ASTNode) typeDeclaration.bodyDeclarations().iterator().next();", "+\t\t\tcreatedNodeSource = this.source;", "+\t\t}", "+\t\tif (this.alteredName != null) {", "+\t\t\tSimpleName newName = this.createdNode.getAST().newSimpleName(this.alteredName);", "+\t\t\tSimpleName oldName = rename(this.createdNode, newName);", "+\t\t\tint nameStart = oldName.getStartPosition();", "+\t\t\tint nameEnd = nameStart + oldName.getLength();", "+\t\t\tStringBuffer newSource = new StringBuffer();", "+\t\t\tif (this.source.equals(createdNodeSource)) {", "+\t\t\t\tnewSource.append(createdNodeSource.substring(0, nameStart));", "+\t\t\t\tnewSource.append(this.alteredName);", "+\t\t\t\tnewSource.append(createdNodeSource.substring(nameEnd));", "+\t\t\t} else {", "+\t\t\t\t// syntacticaly incorrect source", "+\t\t\t\tint createdNodeStart = this.createdNode.getStartPosition();", "+\t\t\t\tint createdNodeEnd = createdNodeStart + this.createdNode.getLength();", "+\t\t\t\tnewSource.append(createdNodeSource.substring(createdNodeStart, nameStart));", "+\t\t\t\tnewSource.append(this.alteredName);", "+\t\t\t\tnewSource.append(createdNodeSource.substring(nameEnd, createdNodeEnd));", "+\t\t\t\t", "+\t\t\t}", "+\t\t\tthis.source = newSource.toString();", "+\t\t}", "+\t}", "+\tif (rewriter == null) return this.createdNode;", "+\t// return a string place holder (instead of the created node) so has to not lose comments and formatting", "+\treturn rewriter.createStringPlaceholder(this.source, this.createdNode.getNodeType());", "+}", "-// TODO - JDOM - remove once model ported off of JDOM", "-private IDOMNode deprecatedGenerateElementDOM() throws JavaModelException {", "-\treturn generateElementDOM();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2520ae119ac1df47f43b2ea23e0de9ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "ab74babcdf0f89ee66e36b91189c0d301a4da95d", "commitAfterChange": "66a4221dd418603b7f2bc6722d99e4e300585ef1", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "signatureAfterChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "diff": ["-\t\tboolean verifyValues = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tboolean source15 = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\t\tint scopeModifiers = -1;", "-\t\t\tint modifiers = fieldRef.binding==null ? -1 : fieldRef.binding.modifiers;", "-\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, modifiers);", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, scopeModifiers);", "-\t\t\telse if (verifyValues && fieldRef.binding != null && fieldRef.binding.isValidBinding()) {", "+\t\t\telse if (source15 && fieldRef.binding != null && fieldRef.binding.isValidBinding()) {", "-\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, modifiers);", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocInvalidValueReference(fieldRef.sourceStart, fieldRef.sourceEnd, scopeModifiers);", "-\t\t\t", "+", "-\t\t// If not 1.5 level, verification is finished", "-\t\tif (!verifyValues)  return;", "+\t\t// Verify type references", "+\t\tif ((reference instanceof JavadocSingleTypeReference || reference instanceof JavadocQualifiedTypeReference) && reference.resolvedType instanceof ReferenceBinding) {", "+\t\t\tReferenceBinding resolvedType = (ReferenceBinding) reference.resolvedType;", "+\t\t\tif (reference.resolvedType.isValidBinding()) {", "-\t\t// Verify that message reference are not used for @value tags", "-\t\telse if (reference instanceof JavadocMessageSend) {", "-\t\t\tJavadocMessageSend msgSend = (JavadocMessageSend) reference;", "-\t\t\tint modifiers = msgSend.binding==null ? -1 : msgSend.binding.modifiers;", "-\t\t\tif (msgSend.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "-\t\t\t\tscope.problemReporter().javadocInvalidValueReference(msgSend.sourceStart, msgSend.sourceEnd, modifiers);", "+\t\t\t\t// member types", "+\t\t\t\tif (resolvedType.isMemberType()) {", "+\t\t\t\t\tReferenceBinding topLevelType = resolvedType;", "+\t\t\t\t\tint depth = 0;", "+\t\t\t\t\twhile (topLevelType.enclosingType() != null) {", "+\t\t\t\t\t\ttopLevelType = topLevelType.enclosingType();", "+\t\t\t\t\t\tdepth++;", "+\t\t\t\t\t}", "+\t\t\t\t\tClassScope topLevelScope = scope.classScope();", "+\t\t\t\t\t// when scope is not on compilation unit type, then inner class may not be visible...", "+\t\t\t\t\tif (topLevelScope.parent.kind != Scope.COMPILATION_UNIT_SCOPE ||", "+\t\t\t\t\t\t!CharOperation.equals(topLevelType.sourceName, topLevelScope.referenceContext.name)) {", "+\t\t\t\t\t\ttopLevelScope = topLevelScope.outerMostClassScope();", "+\t\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\t\t\t// inner class single reference can only be done in same unit", "+\t\t\t\t\t\t\tif ((!source15 && depth == 1) || topLevelType != topLevelScope.referenceContext.binding) {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t// inner class qualified reference can only be done in same package", "+\t\t\t\t\t\t\tif (topLevelType.getPackage() != topLevelScope.referenceContext.binding.getPackage()) {", "+\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+", "+\t\t\t\t// reference must have enough visibility to be used", "+\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "+\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t}", "-\t\t// Verify that constructorreference are not used for @value tags", "+\t\t// Verify that message reference are not used for @value tags", "+\t\tif (reference instanceof JavadocMessageSend) {", "+\t\t\tJavadocMessageSend msgSend = (JavadocMessageSend) reference;", "+", "+\t\t\t// tag value", "+\t\t\tif (source15 && msgSend.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "+\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocInvalidValueReference(msgSend.sourceStart, msgSend.sourceEnd, scopeModifiers);", "+\t\t\t}", "+", "+\t\t}", "+", "+\t\t// Verify that constructor reference are not used for @value tags", "-\t\t\tint modifiers = alloc.binding==null ? -1 : alloc.binding.modifiers;", "-\t\t\tif (alloc.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "-\t\t\t\tscope.problemReporter().javadocInvalidValueReference(alloc.sourceStart, alloc.sourceEnd, modifiers);", "+", "+\t\t\t// tag value", "+\t\t\tif (source15 && alloc.tagValue == JavadocTagConstants.TAG_VALUE_VALUE) { // cannot refer to method for @value tag", "+\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocInvalidValueReference(alloc.sourceStart, alloc.sourceEnd, scopeModifiers);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "81852b0679afbe5cd7f6d543171897ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "e8d96e56e13118d9f9047fcbd38a9ee4769bcc83", "commitAfterChange": "0e8f4e0ca4c462961b44d5a44fb8fe6d622a551b", "methodNumberBeforeChange": 96, "methodNumberAfterChange": 96, "signatureBeforeChange": " protected void validateOptions(boolean didSpecifyCompliance) throws InvalidInputException", "signatureAfterChange": " protected void validateOptions(boolean didSpecifyCompliance) throws InvalidInputException", "diff": ["-\t\t\tif (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);", "-\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t}", "-\t\t\tif (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);", "-\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t}", "-\t\t\tif (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);", "-\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_6.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t}", "-\t\t\tif (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_7);", "-\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_7);", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_6.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_7.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_7);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_7);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_7);", "+\t\t\t}", "-\t}", "-\tif (this.didSpecifySource) {", "+\t} else if (this.didSpecifySource) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b7717d03ca3d13d641bb6cdbfc97e78b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "8314261f38c45d82db5de5aae3122b7f00653bdb", "commitAfterChange": "15609ca5b715c56c97cf6995e327646cb9a6dd97", "methodNumberBeforeChange": 122, "methodNumberAfterChange": 122, "signatureBeforeChange": " protected void validateOptions(boolean didSpecifyCompliance)", "signatureAfterChange": " protected void validateOptions(boolean didSpecifyCompliance)", "diff": ["+\t\t} else if (CompilerOptions.VERSION_1_8.equals(version)) {", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_6.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_7.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_7);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_8.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "+\t\t\t}", "+\t\t} else if (CompilerOptions.VERSION_1_8.equals(version)) {", "+\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);", "+\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "-\tif (sourceVersion.equals(CompilerOptions.VERSION_1_7)", "+\tif (sourceVersion.equals(CompilerOptions.VERSION_1_8)", "+\t\t\t&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_8) {", "+\t\t// compliance must be 1.8 if source is 1.8", "+\t\tthrow new IllegalArgumentException(this.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_8)); //$NON-NLS-1$", "+\t} else if (sourceVersion.equals(CompilerOptions.VERSION_1_7)", "+\t\t\t// target must be 1.8 if source is 1.8", "+\t\t\tif (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_8", "+\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_8){", "+\t\t\t\tthrow new IllegalArgumentException(this.bind(\"configure.incompatibleTargetForSource\", (String) targetVersion, CompilerOptions.VERSION_1_8)); //$NON-NLS-1$", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c8d4bfda0ecde31fe8aec1c7a558d949", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "5bad0f0933acdc658d4e40a7d9becfd8568dd235", "commitAfterChange": "4316c760d5aabce67e5ab83fef96d7ef0cdbee57", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t// Structured to report as many errors as possible in bail out situations.", "+\t\t", "-", "-\t\tif (isConstructorReference()) {", "+\t\t", "+\t\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "+    \tif (isConstructorReference()) {", "-\t\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "+\t\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\t\tif (isMethodReference() && this.receiverType.isRawType())", "-\t\t\t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "+\t\t\t\tif (isMethodReference() && this.receiverType.isRawType()) {", "+\t\t\t\t\tif ((this.lhs.bits & ASTNode.IgnoreRawTypeCheck) == 0 && compilerOptions.getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "+\t\t\t\t\t\tscope.problemReporter().rawTypeReference(this.lhs, this.receiverType);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+        this.method.binding = this.binding;", "-        boolean throwsTantrum = false;", "-        \tthrowsTantrum = true;", "-        if (this.binding.isAbstract()) {", "-        \tif (this.lhs instanceof SuperReference || this.lhs instanceof QualifiedSuperReference) {", "-        \t\tscope.problemReporter().cannotReferToAbstractMethod(this, this.binding);", "-        \t\treturn null;", "-        \t}", "-        }", "-        if (throwsTantrum)", "+        if (this.binding.isAbstract() && this.lhs.isSuper()) {", "+        \tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "+        }", "-        this.method.binding = this.binding;", "- ", "-        return this.resolvedType;", "+        if (this.binding.isStatic() && this.binding.declaringClass != this.receiverType) {", "+\t\t\tscope.problemReporter().indirectAccessToStaticMethod(this, this.binding);", "+\t\t}", "+            \t", "+    \tif (checkInvocationArguments(scope, null, this.receiverType, this.binding, null, descriptorParameters, false, this)) {", "+    \t\tthis.bits |= ASTNode.Unchecked;", "+    \t}", "+", "+    \tif (isMethodUseDeprecated(this.binding, scope, true))", "+    \t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+", "+    \tif (this.descriptor.returnType.id != TypeIds.T_void) {", "+    \t\t// from 1.5 source level on, array#clone() returns the array type (but binding still shows Object)", "+    \t\tTypeBinding returnType = null;", "+    \t\tif (this.binding == scope.environment().arrayClone) {", "+    \t\t\treturnType = this.receiverType;", "+    \t\t} else {", "+    \t\t\tif ((this.bits & ASTNode.Unchecked) != 0 && this.resolvedTypeArguments == null) {", "+    \t\t\t\treturnType = this.binding.returnType;", "+    \t\t\t\tif (returnType != null) {", "+    \t\t\t\t\treturnType = scope.environment().convertToRawType(returnType.erasure(), true);", "+    \t\t\t\t}", "+    \t\t\t} else {", "+    \t\t\t\treturnType = this.binding.returnType;", "+    \t\t\t\tif (returnType != null) {", "+    \t\t\t\t\treturnType = returnType.capture(scope, this.sourceEnd);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope)) {", "+    \t\t\tscope.problemReporter().incompatibleReturnType(this, this.binding, this.descriptor.returnType);", "+    \t\t}", "+    \t}", "+    \tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+    \t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.resolvedTypeArguments, this.typeArguments);", "+    \t}", "+    \treturn (this.resolvedType.tagBits & TagBits.HasMissingType) == 0", "+    \t\t\t\t? this.resolvedType", "+    \t\t\t\t: null;\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "efac381bd6a3753d2cba804519357404", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "59758b3ac964ea48fbbbf5d314c8ed8b19dc60bb", "commitAfterChange": "bf7f7505c8fbaf610dcfc16c3f38ab20112ea07c", "methodNumberBeforeChange": 122, "methodNumberAfterChange": 122, "signatureBeforeChange": " protected void validateOptions(boolean didSpecifyCompliance)", "signatureAfterChange": " protected void validateOptions(boolean didSpecifyCompliance)", "diff": ["+\t\t} else if (CompilerOptions.VERSION_1_8.equals(version)) {", "+\t\t\tif (this.didSpecifySource) {", "+\t\t\t\tObject source = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t\tif (CompilerOptions.VERSION_1_3.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_4.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(source)", "+\t\t\t\t\t\t|| CompilerOptions.VERSION_1_6.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_7.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_7);", "+\t\t\t\t} else if (CompilerOptions.VERSION_1_8.equals(source)) {", "+\t\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);", "+\t\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "+\t\t\t}", "+\t\t} else if (CompilerOptions.VERSION_1_8.equals(version)) {", "+\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);", "+\t\t\tif (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);", "-\tif (sourceVersion.equals(CompilerOptions.VERSION_1_7)", "+\tif (sourceVersion.equals(CompilerOptions.VERSION_1_8)", "+\t\t\t&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_8) {", "+\t\t// compliance must be 1.8 if source is 1.8", "+\t\tthrow new IllegalArgumentException(this.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_8)); //$NON-NLS-1$", "+\t} else if (sourceVersion.equals(CompilerOptions.VERSION_1_7)", "+\t\t\t// target must be 1.8 if source is 1.8", "+\t\t\tif (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_8", "+\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_8){", "+\t\t\t\tthrow new IllegalArgumentException(this.bind(\"configure.incompatibleTargetForSource\", (String) targetVersion, CompilerOptions.VERSION_1_8)); //$NON-NLS-1$", "+\t\t\t}"]}], "num": 39740}