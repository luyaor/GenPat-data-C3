{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4aa0816fd92225801f9b9a787a75b15f", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13432d4212580b3ed3b4123fb41efe58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "ad94e7c70968c32bc14232e983e71554b9e4e876", "commitAfterChange": "2a5005d0f0faf2e32a9545440516f869ce34bcdd", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "diff": ["-\t\t//TODO: (philippe) investigate why exactly test76 fails if ignoreEnclosingArgInConstructorCall is always false", "+\t\t\t\t", "-\t\t// identity check", "-\t\tif (!currentMethodScope.isStatic ", "-\t\t\t&& (!currentMethodScope.isConstructorCall || ignoreEnclosingArgInConstructorCall)", "-\t\t\t&& (sourceType == targetEnclosingType", "-\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType)))) {", "-\t\t\tif (currentMethodScope.isConstructorCall) {", "-\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t// use 'this' if possible", "+\t\tif (!currentMethodScope.isConstructorCall && !currentMethodScope.isStatic) {", "+\t\t\tif (sourceType == targetEnclosingType || (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType))) {", "+\t\t\t\treturn EmulationPathToImplicitThis; // implicit this is good enough", "-\t\t\tif (currentMethodScope.isStatic){", "-\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t\t}", "-\t\t\treturn EmulationPathToImplicitThis; // implicit this is good enough", "+\t\t\t} else if (currentMethodScope.isStatic){", "+\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t\t\tif (currentMethodScope.isStatic){", "-\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "-\t\t\t\t}", "+\t\t\t\t// reject allocation and super constructor call", "+\t\t\t\tif (ignoreEnclosingArgInConstructorCall ", "+\t\t\t\t\t\t&& currentMethodScope.isConstructorCall ", "+\t\t\t\t\t\t&& (sourceType == targetEnclosingType || (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType)))) {", "+\t\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e3015ae51f0a0dfb71531ead5e965638", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "4b1cb82b00b0f3c43755c37280deb732ae600c1a", "commitAfterChange": "1caf2b41c370e66c328190589dd64f01b35d7384", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean denyEnclosingArgInConstructorCall)", "diff": ["-\t\t\tboolean ignoreEnclosingArgInConstructorCall) {", "+\t\t\tboolean denyEnclosingArgInConstructorCall) {", "-\t\tif (!currentMethodScope.isConstructorCall && !currentMethodScope.isStatic) {", "+\t\tif (!currentMethodScope.isStatic && !currentMethodScope.isConstructorCall) {", "-\t\t\t\tif (ignoreEnclosingArgInConstructorCall ", "+\t\t\t\tif (denyEnclosingArgInConstructorCall", "+\t\tif (sourceType.isAnonymousType()) {", "+\t\t\tReferenceBinding enclosingType = sourceType.enclosingType();", "+\t\t\tif (enclosingType.isNestedType()) {", "+\t\t\t\tNestedTypeBinding nestedEnclosingType = (NestedTypeBinding) enclosingType;", "+\t\t\t\tSyntheticArgumentBinding enclosingArgument = nestedEnclosingType.getSyntheticArgument(nestedEnclosingType.enclosingType(), onlyExactMatch);", "+\t\t\t\tif (enclosingArgument != null) {", "+\t\t\t\t\tFieldBinding syntheticField = sourceType.getSyntheticField(enclosingArgument);", "+\t\t\t\t\tif (syntheticField != null) {", "+\t\t\t\t\t\tif (syntheticField.type == targetEnclosingType || (!onlyExactMatch && ((ReferenceBinding)syntheticField.type).findSuperTypeErasingTo(targetEnclosingType) != null))", "+\t\t\t\t\t\t\treturn new Object[] { syntheticField };", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+"]}], "num": 6425}