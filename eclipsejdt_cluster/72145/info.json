{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "71d1b5353a6578bf0fda4ccb43a6149b", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02797927902e1033b3e620e668740020", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java", "commitBeforeChange": "57e4d4c87d35c6ae3978a396ec1884b0ad8efb22", "commitAfterChange": "a02dc2635b15c289c546ca96a49f66d7180ade17", "methodNumberBeforeChange": 66, "methodNumberAfterChange": 66, "signatureBeforeChange": " public boolean isTypeArgumentContainedBy(TypeBinding otherType)", "signatureAfterChange": " public boolean isTypeArgumentContainedBy(TypeBinding otherType)", "diff": ["-\t\t\tWildcardBinding wildcard = capture.wildcard;", "-\t\t\tTypeBinding upperBound = null;", "-\t\t\tTypeBinding [] otherBounds = null;", "-\t\t\tswitch (wildcard.boundKind) {", "-\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\treturn false; // T super syntax isn't allowed, impossible capture.", "-\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\tTypeVariableBinding variable = wildcard.genericType.typeVariables()[wildcard.rank];", "-\t\t\t\t\tupperBound = variable.upperBound();", "-\t\t\t\t\totherBounds = variable.boundsCount() > 1 ? variable.otherUpperBounds() : null;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\tupperBound = wildcard.bound;", "-\t\t\t\t\totherBounds = wildcard.otherBounds;", "-\t\t\t\t\tbreak;", "+\t\t\tif (capture instanceof CaptureBinding18) {", "+\t\t\t\t// by analogy to CaptureBinding but accepting the fact that .wildcard is null:", "+\t\t\t\tCaptureBinding18 cb18 = (CaptureBinding18) capture;", "+\t\t\t\tif (cb18.firstBound != null) {", "+\t\t\t\t\tif (cb18.lowerBound != null)", "+\t\t\t\t\t\treturn false; // type containment is not defined for variables with both upper and lower bound", "+\t\t\t\t\tTypeBinding[] otherBounds = null; ", "+\t\t\t\t\tint len = cb18.upperBounds.length; // by construction non-null if firstBound is set", "+\t\t\t\t\tif (len > 1)", "+\t\t\t\t\t\tSystem.arraycopy(cb18.upperBounds, 1, otherBounds = new TypeBinding[len-1], 0, len-1);", "+\t\t\t\t\totherType = capture.environment.createWildcard(null, 0, cb18.firstBound, otherBounds, Wildcard.EXTENDS);", "+\t\t\t\t} else if (cb18.lowerBound != null) {", "+\t\t\t\t\totherType = capture.environment.createWildcard(null, 0, cb18.lowerBound, null, Wildcard.SUPER);", "+\t\t\t\t} else {", "+\t\t\t\t\treturn false; // not wellformed", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tTypeBinding upperBound = null;", "+\t\t\t\tTypeBinding [] otherBounds = null;", "+\t\t\t\tWildcardBinding wildcard = capture.wildcard;", "+\t\t\t\tswitch (wildcard.boundKind) {", "+\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\treturn false; // T super syntax isn't allowed, impossible capture.", "+\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\tTypeVariableBinding variable = wildcard.genericType.typeVariables()[wildcard.rank];", "+\t\t\t\t\t\tupperBound = variable.upperBound();", "+\t\t\t\t\t\totherBounds = variable.boundsCount() > 1 ? variable.otherUpperBounds() : null;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\tupperBound = wildcard.bound;", "+\t\t\t\t\t\totherBounds = wildcard.otherBounds;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t\t// Given class A<T extends B<?>>, A<?> cannot be the universe of all parameterizations of A", "+\t\t\t\tif (upperBound.id == TypeIds.T_JavaLangObject && otherBounds == null) {", "+\t\t\t\t\treturn false; // but given class A<T>, A<?> stays an unbounded wildcard, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=348956", "+\t\t\t\t}", "+\t\t\t\totherType = capture.environment.createWildcard(null, 0, upperBound, otherBounds, Wildcard.EXTENDS);", "-\t\t\t// Given class A<T extends B<?>>, A<?> cannot be the universe of all parameterizations of A", "-\t\t\tif (upperBound.id == TypeIds.T_JavaLangObject && otherBounds == null) {", "-\t\t\t\treturn false; // but given class A<T>, A<?> stays an unbounded wildcard, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=348956", "-\t\t\t}", "-\t\t\totherType = capture.environment.createWildcard(null, 0, upperBound, otherBounds, Wildcard.EXTENDS);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0a2844608de42fd7429ea65732a0c692", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "1b98b39107e931dc0893df1da7a410cad5cc4745", "commitAfterChange": "9635fd418f2d5b55fe3d3dc4ccb7797a5daf3a53", "methodNumberBeforeChange": 77, "methodNumberAfterChange": 77, "signatureBeforeChange": " \tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope)", "signatureAfterChange": " \tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope)", "diff": ["+\t\t} else if(parent instanceof MemberValuePair) {", "+\t\t\tMemberValuePair memberValuePair = (MemberValuePair) parent;", "+\t\t\tif(memberValuePair.binding != null) {", "+\t\t\t\taddExpectedType(memberValuePair.binding.returnType);", "+\t\t\t}", "+\t\t} else if (parent instanceof NormalAnnotation) {", "+\t\t\tNormalAnnotation annotation = (NormalAnnotation) parent;", "+\t\t\tMemberValuePair[] memberValuePairs = annotation.memberValuePairs();", "+\t\t\tif(memberValuePairs == null || memberValuePairs.length == 0) {", "+\t\t\t\tif(annotation.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\t\tMethodBinding[] methodBindings =", "+\t\t\t\t\t\t((ReferenceBinding)annotation.resolvedType).availableMethods();", "+\t\t\t\t\tif(methodBindings != null &&", "+\t\t\t\t\t\t\tmethodBindings.length == 1 &&", "+\t\t\t\t\t\t\tCharOperation.equals(methodBindings[0].selector, VALUE)) {", "+\t\t\t\t\t\taddExpectedType(methodBindings[0].returnType);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "419dd9d083539e1bd730f783ff3fff5c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java", "commitBeforeChange": "d135b079aa3cba8ba7f809e3b8fa111052de185d", "commitAfterChange": "c29ff6f3ca53453d86d6a9de68da632d3d253455", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 90, "signatureBeforeChange": " protected void popElement(int kind)", "signatureAfterChange": " protected void popElement(int kind)", "diff": ["-protected void popElement(int kind){", "-\tif(this.elementPtr < 0 || this.elementKindStack[this.elementPtr] != kind) return;", "-\tthis.previousKind = this.elementKindStack[this.elementPtr];", "-\tthis.previousInfo = this.elementInfoStack[this.elementPtr];", "-\tthis.previousObjectInfo = this.elementObjectInfoStack[this.elementPtr];", "-", "-\tthis.elementObjectInfoStack[this.elementPtr] = null;", "-", "-\tswitch (kind) {", "-\t\tdefault :", "-\t\t\tthis.elementPtr--;", "-\t\t\tbreak;", "+// the name is a misnomer, we allow \"pop\"s not just at the TOS. Lambda wants to be sticky till fully reduced, however we do want other elements poppped at the right point, so ... ", "+protected void popElement(int kind) {", "+\t", "+\tif (this.elementPtr < 0)", "+\t\treturn;", "+\t", "+\tint stackPointer = this.elementPtr;", "+\t", "+\tif (this.elementKindStack[stackPointer] == K_LAMBDA_EXPRESSION_DELIMITER) {", "+\t\tif (kind == K_FIELD_INITIALIZER_DELIMITER) // wait until lambda is reduced.", "+\t\t\treturn;", "-}", "+\t", "+\tif (kind != K_LAMBDA_EXPRESSION_DELIMITER) {", "+\t\twhile (this.elementKindStack[stackPointer] == K_LAMBDA_EXPRESSION_DELIMITER) {", "+\t\t\tstackPointer --;", "+\t\t}", "+\t}", "+\tif (stackPointer < 0 || this.elementKindStack[stackPointer] != kind)", "+\t\treturn;", "+\t", "+\tthis.previousKind = this.elementKindStack[stackPointer];", "+\tthis.previousInfo = this.elementInfoStack[stackPointer];", "+\tthis.previousObjectInfo = this.elementObjectInfoStack[stackPointer];", "+", "+\tfinal int length = this.elementPtr - stackPointer;", "+\tif (length > 0) {", "+\t\tSystem.arraycopy(this.elementKindStack, stackPointer + 1, this.elementKindStack, stackPointer, length);", "+\t\tSystem.arraycopy(this.elementInfoStack, stackPointer + 1, this.elementInfoStack, stackPointer, length);", "+\t\tSystem.arraycopy(this.elementObjectInfoStack, stackPointer + 1, this.elementObjectInfoStack, stackPointer, length);", "+\t}", "+\tthis.elementObjectInfoStack[this.elementPtr] = null;", "+\tthis.elementPtr--;", "+ }"]}], "num": 72145}