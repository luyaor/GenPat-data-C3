{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db3fe52dbd083006d077082334584695", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f739b36258e22d3206a255228cd2d93", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "55f4964943e2f63287728b29450cbefa492d313d", "commitAfterChange": "ffcfe0dac7f476f076089d3cdae600b5982efdfb", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "signatureAfterChange": "  public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)", "diff": ["-\tif (arguments != null){", "+\tif (binding.isVararg()) {", "+\t\t// 4 possibilities exist for a call to the vararg method foo(int i, int ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})", "+\t\tTypeBinding[] params = binding.parameters;", "+\t\tint lastIndex = params.length - 1;", "+\t\tfor (int i = 0; i < lastIndex; i++) {", "+\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "+\t\t}", "+", "+\t\tArrayBinding varArgsType = (ArrayBinding) params[lastIndex]; // parameterType has to be an array type", "+\t\tint argLength = arguments == null ? 0 : arguments.length;", "+\t\tif (lastIndex < argLength) { // vararg argument was provided", "+\t\t\tif (params.length == argLength && varArgsType.dimensions() == arguments[lastIndex].resolvedType.dimensions()) {", "+\t\t\t\t// called with matching array : foo(1, new int[] {1, 2}", "+\t\t\t\targuments[lastIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t} else {", "+\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "+\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "+\t\t\t\tcodeStream.generateInlinedValue(argLength - lastIndex);", "+\t\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "+\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "+\t\t\t\tfor (int i = 0, max = argLength - lastIndex; i < max; i++) {", "+\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\tcodeStream.generateInlinedValue(i);", "+\t\t\t\t\targuments[i + lastIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// generate code for an empty array of parameterType", "+\t\t\tcodeStream.generateInlinedValue(0);", "+\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "+\t\t}", "+\t} else if (arguments != null){"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c3244f8fc2803756a1c619e94b1d30c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IntersectionCastTypeReference.java", "commitBeforeChange": "86284f2db6c7ac41b63c1766c9b7b3a016d95a9a", "commitAfterChange": "c8d8bdad35a9dc8d924116cabb6dd00986cff218", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope scope, boolean checkBounds)", "diff": ["-\t\treturn (this.resolvedType = null);", "+", "+\t\tint length = this.typeReferences.length;", "+\t\tReferenceBinding[] intersectingTypes = new ReferenceBinding[length];", "+\t\tboolean hasError = false;", "+\t\t", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tfinal TypeReference typeReference = this.typeReferences[i];", "+\t\t\tTypeBinding type = typeReference.resolveType(scope, checkBounds);", "+\t\t\tif (type == null || ((type.tagBits & TagBits.HasMissingType) != 0)) {", "+\t\t\t\thasError = true;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (i == 0) {", "+\t\t\t\tif (type.isBaseType()) { // rejected in grammar for i > 0", "+\t\t\t\t\tscope.problemReporter().onlyReferenceTypesInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (type.isArrayType()) { // javac rejects the pedantic cast: (X[] & Serializable & Cloneable) new X[0], what is good for the goose ...", "+\t\t\t\t\tscope.problemReporter().illegalArrayTypeInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t} else if (!type.isInterface()) {  // TODO: understand how annotations play here ...", "+\t\t\t\tscope.problemReporter().boundMustBeAnInterface(typeReference, type);", "+\t\t\t\thasError = true;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tfor (int j = 0; j < i; j++) {", "+\t\t\t\tif (intersectingTypes[j] == type) {", "+\t\t\t\t\tscope.problemReporter().duplicateBoundInIntersectionCast(typeReference);", "+\t\t\t\t\thasError = true;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tintersectingTypes[i] = (ReferenceBinding) type;", "+\t\t}", "+\t\tif (hasError) {", "+\t\t\treturn null;", "+\t\t}", "+\t\treturn (this.resolvedType = scope.environment().createIntersectionCastType(intersectingTypes));"]}], "num": 14175}