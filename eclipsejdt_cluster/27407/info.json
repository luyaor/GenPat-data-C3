{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e5cc3463ffed6de5518e53e8ae8e5ef2", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83d03769f660ec10417f8b0c32a0d2b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/ElementProc.java", "commitBeforeChange": "f4eb00a745a91dbc4b9bd7fa4022524e166e1b90", "commitAfterChange": "a4f11659e59fa8a478723fa3bc2c5651f04c5382", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "signatureAfterChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "diff": ["+\t// Always return false from this processor, because it supports \"*\".", "-\t\tMap<String, String> options = processingEnv.getOptions();", "-\t\tif (!options.containsKey(\"org.eclipse.jdt.compiler.apt.tests.processors.elements.ElementProc\")) {", "+\t\tif (roundEnv.processingOver()) {", "+\t\t\t// We're not interested in the postprocessing round.", "-\t\tfor (Element e : roundEnv.getRootElements()) {", "-\t\t\tSystem.out.println(\"Found element \" + e.getSimpleName());", "+\t\tMap<String, String> options = processingEnv.getOptions();", "+\t\tif (!options.containsKey(CLASSNAME)) {", "+\t\t\t// Disable this processor unless we are intentionally performing the test.", "+\t\t\treturn false;", "+\t\t", "+\t\t// Verify that we get the root elements we expect", "+\t\tSet<String> expectedRootElementNames = new HashSet<String>(_rootElementNames.length);", "+\t\tfor (String name : _rootElementNames) {", "+\t\t\texpectedRootElementNames.add(name);", "+\t\t}", "+\t\tSet<? extends Element> actualRootElements = roundEnv.getRootElements();", "+\t\tif (null == actualRootElements) {", "+\t\t\tElementProc.reportError(\"getRootElements() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tfor (Element e : actualRootElements) {", "+\t\t\tString name = e.getSimpleName().toString();", "+\t\t\tif (!expectedRootElementNames.remove(name)) {", "+\t\t\t\tElementProc.reportError(\"Missing root element \" + name);", "+\t\t\t}", "+\t\t}", "+\t\tif (!expectedRootElementNames.isEmpty()) {", "+\t\t\tElementProc.reportError(\"Found extra root elements including \" + expectedRootElementNames.iterator().next());", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Check some basic attributes", "+\t\tTypeElement elementIA = _elementUtils.getTypeElement(\"targets.model.pa.IA\");", "+\t\tif (elementIA == null) {", "+\t\t\tElementProc.reportError(\"element IA was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tTypeElement elementAB = _elementUtils.getTypeElement(\"targets.model.pb.AB\");", "+\t\tif (elementAB == null) {", "+\t\t\tElementProc.reportError(\"element AB was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementIA.getKind() != ElementKind.INTERFACE) {", "+\t\t\tElementProc.reportError(\"IA claims to not be an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementAB.getKind() != ElementKind.CLASS) {", "+\t\t\tElementProc.reportError(\"AB claims to not be a class\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Can we look at what interfaces AB implements?", "+\t\tList<? extends TypeMirror> ABinterfaces = elementAB.getInterfaces();", "+\t\tif (null == ABinterfaces) {", "+\t\t\tElementProc.reportError(\"AB.getInterfaces() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tboolean foundIAinterface = false;", "+\t\tfor (TypeMirror type : ABinterfaces) {", "+\t\t\tElement decl = _typeUtils.asElement(type);", "+\t\t\tif (null == decl) {", "+\t\t\t\tElementProc.reportError(\"One of AB's interfaces, \" + type.toString() + \", produced null from Types.asElement()\");", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\tif (elementIA.equals(decl)) {", "+\t\t\t\tfoundIAinterface = true;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (!foundIAinterface) {", "+\t\t\tElementProc.reportError(\"AB does not have IA as an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\tElementProc.reportSuccess();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b68fc655fd44b3fa75d725ac50452434", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/ElementProc.java", "commitBeforeChange": "29d06747dc9924aaa37b6f5478bee32ae657345a", "commitAfterChange": "635d51c73a886e470d16e7ebb8d1b4a9177433d4", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "signatureAfterChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "diff": ["+\t// The return value does not signify success or failure!", "-\t\t\tElementProc.reportError(\"getRootElements() returned null\");", "+\t\t\treportError(\"getRootElements() returned null\");", "-\t\t\t\tElementProc.reportError(\"Missing root element \" + name);", "+\t\t\t\treportError(\"Missing root element \" + name);", "-\t\t\tElementProc.reportError(\"Found extra root elements including \" + expectedRootElementNames.iterator().next());", "+\t\t\treportError(\"Found extra root elements including \" + expectedRootElementNames.iterator().next());", "-\t\t// Check some basic attributes", "-\t\tTypeElement elementIA = _elementUtils.getTypeElement(\"targets.model.pa.IA\");", "-\t\tif (elementIA == null) {", "-\t\t\tElementProc.reportError(\"element IA was not found\");", "-\t\t\treturn false;", "-\t\t}", "-\t\tTypeElement elementAB = _elementUtils.getTypeElement(\"targets.model.pb.AB\");", "-\t\tif (elementAB == null) {", "-\t\t\tElementProc.reportError(\"element AB was not found\");", "-\t\t\treturn false;", "-\t\t}", "-\t\tif (elementIA.getKind() != ElementKind.INTERFACE) {", "-\t\t\tElementProc.reportError(\"IA claims to not be an interface\");", "-\t\t\treturn false;", "-\t\t}", "-\t\tif (elementAB.getKind() != ElementKind.CLASS) {", "-\t\t\tElementProc.reportError(\"AB claims to not be a class\");", "+\t\tif (!collectElements()) {", "-\t\t// Can we look at what interfaces AB implements?", "-\t\tList<? extends TypeMirror> ABinterfaces = elementAB.getInterfaces();", "-\t\tif (null == ABinterfaces) {", "-\t\t\tElementProc.reportError(\"AB.getInterfaces() returned null\");", "+\t\tif (!examineABInterfaces()) {", "-\t\tboolean foundIAinterface = false;", "-\t\tfor (TypeMirror type : ABinterfaces) {", "-\t\t\tElement decl = _typeUtils.asElement(type);", "-\t\t\tif (null == decl) {", "-\t\t\t\tElementProc.reportError(\"One of AB's interfaces, \" + type.toString() + \", produced null from Types.asElement()\");", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t\tif (elementIA.equals(decl)) {", "-\t\t\t\tfoundIAinterface = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\t\t", "+\t\tif (!examineDHierarchy()) {", "+\t\t\treturn false;", "-\t\tif (!foundIAinterface) {", "-\t\t\tElementProc.reportError(\"AB does not have IA as an interface\");", "+\t\t", "+\t\tif (!examineAMethodsAndFields()) {", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\tif (!examinePBPackage()) {"]}], "num": 27407}