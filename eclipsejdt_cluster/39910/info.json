{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "68e6a6ef94c67fa6dfdc57ad5268b9b7", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f3f04da4199f27ef918ea47e62ec85e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "7548eaaea6e1259875e63eaf19dcd9a6bb7fd118", "commitAfterChange": "3d5aa7d7eabaf3445aad76f168f1c9da2ba34591", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 10, "signatureBeforeChange": " public void add(IJavaElement element) throws JavaModelException", "signatureAfterChange": "  private boolean encloses(String scopePath, String path, int index)", "diff": ["-//\tadd(element, element.getJavaProject());", "-\tadd(element, null);", "-}", "+", "+private boolean encloses(String scopePath, String path, int index) {", "+\tif (this.pathWithSubFolders[index]) {", "+\t\tif (path.startsWith(scopePath)) {", "+\t\t\treturn true;", "+\t\t}", "+\t} else {", "+\t\t// if not looking at subfolders, this scope encloses the given path ", "+\t\t// if this path is a direct child of the scope's ressource", "+\t\t// or if this path is the scope's resource (see bug 13919 Declaration for package not found if scope is not project)", "+\t\tif (path.startsWith(scopePath) ", "+\t\t\t&& ((scopePath.length() == path.lastIndexOf('/'))", "+\t\t\t\t|| (scopePath.length() == path.length()))) {", "+\t\t\treturn true;", "+\t\t}", "+\t}", "+\treturn false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2fd6ef0d94b6df8679824db923169097", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "acb688302e3cacbdc42738d6941f0a71f5b00f9c", "commitAfterChange": "37562c5a562cc71ff03559ef16cdaf50168f2116", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic boolean visit(AnonymousLocalTypeDeclaration anonymousTypeDeclaration, BlockScope unused)", "signatureAfterChange": " \tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope unused)", "diff": ["-\tpublic boolean visit(AnonymousLocalTypeDeclaration anonymousTypeDeclaration, BlockScope unused) {", "+\tpublic boolean visit(TypeDeclaration typeDeclaration, BlockScope unused) {", "-\t\t\tString simpleName = \"\"; //$NON-NLS-1$", "+\t\t\tString simpleName;", "+\t\t\tif ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {\t\t\t\t", "+\t\t\t\tsimpleName = \"\"; //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tsimpleName = new String(typeDeclaration.name);", "+\t\t\t}", "-\t\t\tif (occurrenceCount == null)", "+\t\t\tif (occurrenceCount == null) {", "-\t\t\telse", "+\t\t\t} else {", "+\t\t\t}", "-\t\t\treportMatching(anonymousTypeDeclaration, enclosingElement, -1, nodeSet, occurrenceCount.intValue());", "-\t\t\treturn false; // don't visit members as this was done during reportMatching(...)", "-\t\t} catch (CoreException e) {", "-\t\t\tthrow new WrappedCoreException(e);", "-\t\t}", "-\t}", "+\t\t\tif ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {\t\t\t\t", "+\t\t\t\treportMatching(typeDeclaration, enclosingElement, -1, nodeSet, occurrenceCount.intValue());", "+\t\t\t} else {", "+\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(typeDeclaration);", "+\t\t\t\treportMatching(typeDeclaration, enclosingElement, level != null ? level.intValue() : -1, nodeSet, occurrenceCount.intValue());", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5fa00b7d4ae5156eac53fa0e3194fadc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " protected void findMethodBinding(BlockScope scope)", "signatureAfterChange": "  protected TypeBinding findMethodBinding(BlockScope scope)", "diff": ["- */", "-protected void findMethodBinding(BlockScope scope) {", "-\tthis.binding = this.receiver.isImplicitThis()", "-\t\t\t? scope.getImplicitMethod(this.selector, this.argumentTypes, this)", "+", "+protected TypeBinding findMethodBinding(BlockScope scope) {", "+\t", "+\t", "+\tthis.binding = this.receiver.isImplicitThis() ? ", "+\t\t\tscope.getImplicitMethod(this.selector, this.argumentTypes, this) ", "+", "+\tif (this.binding == null) // can't happen ? I think we always get a problem binding, anyways.", "+\t\treturn null;", "+\t", "+\tif (this.binding instanceof PolyParameterizedGenericMethodBinding)", "+\t\treturn new PolyTypeBinding(this);", "+\t", "-\t\t\treturn;", "+\t\t\treturn this.binding.returnType;", "-\t\tInferenceContext18 ctx = getInferenceContext(pgmb);", "-\t\tif (ctx == null || ctx.stepCompleted < InferenceContext18.BINDINGS_UPDATED)", "-\t\t\treturn;", "-\t\t\t\treturn;", "+\t\t\t\treturn this.binding.returnType;", "-\t\t\treturn;", "+\t\t\treturn this.binding.returnType;", "-\t\t\treturn;", "+\t\t\treturn this.binding.returnType;", "-\t\t\t\treturn;", "+\t\t\t\treturn this.binding.returnType;", "-\t\tif (scope.parameterCompatibilityLevel(this.binding, finalArgumentTypes, false, false) == Scope.NOT_COMPATIBLE)", "+\t\tif (scope.parameterCompatibilityLevel(this.binding, finalArgumentTypes, false) == Scope.NOT_COMPATIBLE)", "-}", "+\treturn this.binding.returnType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71f66bf19ded41fd62ccdff6a52692be", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "83b2f6a03c3dc62e9f0da4478de073882f53022b", "commitAfterChange": "3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 48, "signatureBeforeChange": " public MethodBinding resolveTypesFor(MethodBinding method)", "signatureAfterChange": " public MethodBinding resolveTypesFor(MethodBinding method)", "diff": ["+\t", "+\tif (this != this.prototype)", "+\t\treturn this.prototype.resolveTypesFor(method);", "+\t", "-\tif (this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "+\tfinal long sourceLevel = this.scope.compilerOptions().sourceLevel;", "+\tif (sourceLevel >= ClassFileConstants.JDK1_5) {", "-\tif (this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_7) {", "+\tif (sourceLevel >= ClassFileConstants.JDK1_7) {", "+\t\t\t\tif (sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\t\tAnnotationBinding [] annotations = method.getAnnotations();", "+\t\t\t\t\tif (annotations != null && annotations != Binding.NO_ANNOTATIONS) {", "+\t\t\t\t\t\tASTNode.copySE8AnnotationsToType(methodDecl.scope, method, annotations);", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\t\t\t\t\t\tmethod.returnType = method.returnType.unannotated();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// annotation was mistakenly associated to the method, create the annotated type now:", "-\t\t\t\t\t\t\tmethod.returnType = this.scope.environment().createAnnotatedType(method.returnType, nullTagBits);", "+\t\t\t\t\t\t\tmethod.returnType.tagBits &= ~TagBits.AnnotationNullMASK;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7dcba064337a4e9a31f44ed3d3957356", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 5, "signatureBeforeChange": " public void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess){", "+\t// if field from parameterized type got found, use the original field at codegen time", "+\tif (this.binding instanceof ParameterizedFieldBinding) {", "+\t    ParameterizedFieldBinding parameterizedField = (ParameterizedFieldBinding) this.binding;", "+\t    this.codegenBinding = parameterizedField.originalField;", "+\t    // extra cast needed if field type was type variable", "+\t    if (this.codegenBinding.type.isTypeVariable()) {", "+\t        TypeVariableBinding variableReturnType = (TypeVariableBinding) this.codegenBinding.type;", "+\t        if (variableReturnType.firstBound != parameterizedField.type) { // no need for extra cast if same as first bound anyway", "+\t\t\t    this.genericCast = parameterizedField.type.erasure();", "+\t        }", "+\t    }", "+\t} else {", "+\t    this.codegenBinding = this.binding;", "- */", "-public void manageSyntheticWriteAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo){", "-\t// The private access will be managed through the code generation", "-", "-\tif (!flowInfo.isReachable()) return;", "-\t", "+\t\t", "-\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(this.binding, (ReferenceBinding)this.delegateThis.type);", "+\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(this.codegenBinding, (ReferenceBinding)this.delegateThis.type.erasure());", "-\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(this.binding, (ReferenceBinding) this.receiverType);", "+\t\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(this.codegenBinding, (ReferenceBinding) this.receiverType.erasure());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88d62a654d4334754cf92d0dac1315d5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "581702d71a138ac97fe73cfd2b06cc855f39a496", "commitAfterChange": "d47f7e16ee9a06ebea0c1bfa73440fda6af0235f", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 42, "signatureBeforeChange": " \tprotected void putInfo(IJavaElement element, Object info)", "signatureAfterChange": " \tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements) throws JavaModelException", "diff": ["-\tprotected void putInfo(IJavaElement element, Object info) {", "-\t\tthis.cache.putInfo(element, info);", "+\t */", "+\tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements) throws JavaModelException {", "+\t\twhile (openedElement != null) {", "+\t\t\tif (!newElements.containsKey(openedElement)) {", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tif (this.cache.peekAtInfo(openedElement) != null) {", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\topenedElement = openedElement.getParent();", "+\t\t}", "+\t\t", "+\t\tIterator iterator = newElements.keySet().iterator();", "+\t\twhile (iterator.hasNext()) {", "+\t\t\tIJavaElement element = (IJavaElement)iterator.next();", "+\t\t\tObject info = newElements.get(element);", "+\t\t\tthis.cache.putInfo(element, info);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9fb1bacc1613130135a6e479404e01ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java", "commitBeforeChange": "bba2bca88efef9ed01c7e2181bcf1d41e5989888", "commitAfterChange": "bf39b08bac5fe04538b98cd37961d265ad6d7cd8", "methodNumberBeforeChange": 213, "methodNumberAfterChange": 15, "signatureBeforeChange": "  \tprivate void appendOutputForConstantString(IConstantPoolEntry constantPoolEntry)", "signatureAfterChange": " \tprivate String getLocalVariableName(int i)", "diff": ["+\t}", "+\tprivate String getLocalVariableName(int i) {", "+\t\tString localVariableName = null;", "+\t\tif (this.hashMap != null) {", "+\t\t\tif (i < 4) {", "+\t\t\t\tlocalVariableName = (String) this.hashMap.get(INDEXES[i]);", "+\t\t\t} else {", "+\t\t\t\tlocalVariableName = (String) this.hashMap.get(new Integer(i));", "+\t\t\t}", "+\t\t}", "+\t\tif (localVariableName == null) {", "+\t\t\tlocalVariableName = Util.bind(\"disassembler.localvariablename\", Integer.toString(i)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t}", "+\t\treturn localVariableName;", "-", "-\tprivate void appendOutputForConstantString(IConstantPoolEntry constantPoolEntry) {", "-\t\tthis.buffer", "-\t\t\t.append(\"<String \\\"\") //$NON-NLS-1$", "-\t\t\t.append(constantPoolEntry.getStringValue())", "-\t\t\t.append(\"\\\">\"); //$NON-NLS-1$", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3ca6648343c2518bf303c6a25874e1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "signatureAfterChange": " public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo)", "diff": ["+", "+\t// if method from parameterized type got found, use the original method at codegen time", "+\tthis.codegenBinding = this.binding.original();", "+\tif (this.codegenBinding != this.binding) {", "+\t    // extra cast needed if method return type was type variable", "+\t    if (this.codegenBinding.returnType.isTypeVariable()) {", "+\t        TypeVariableBinding variableReturnType = (TypeVariableBinding) this.codegenBinding.returnType;", "+\t        if (variableReturnType.firstBound != this.binding.returnType) { // no need for extra cast if same as first bound anyway", "+\t\t\t    this.genericCast = this.binding.returnType;", "+\t        }", "+\t    }", "+\t} ", "-\t\t\t\t&& (!this.receiver.isImplicitThis() || !this.binding.isStatic())", "+\t\t\t\t&& (!this.receiver.isImplicitThis() || !this.codegenBinding.isStatic())", "-\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedMethodBinding(this.binding, (ReferenceBinding) this.qualifyingType);", "+\t\tthis.codegenBinding = currentScope.enclosingSourceType().getUpdatedMethodBinding(this.codegenBinding, (ReferenceBinding) this.qualifyingType.erasure());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b8bdc016bc7f514c1a9f6f629e096bcd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "8d8cc91b7aba4777ee9418a3cef6e1e163bfbf27", "commitAfterChange": "d0534e0376f1634b8fe35d19dde78d7433440f37", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo, int initialReachMode)", "diff": ["-\t\t} else if ((this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) != TagBits.IsLocalType) {", "+\t\t} else if (!constructorBinding.isOrEnclosedByPrivateType()) {", "+ \t\t}", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=264991, Don't complain about this", "+\t\t// constructor being unused if the base class doesn't have a no-arg constructor.", "+\t\t// See that a seemingly unused constructor that chains to another constructor with a", "+\t\t// this(...) can be flagged as being unused without hesitation.", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=265142", "+\t\tif (this.constructorCall.accessMode != ExplicitConstructorCall.This) {", "+\t\t\tReferenceBinding superClass = constructorBinding.declaringClass.superclass();", "+\t\t\tif (superClass == null)", "+\t\t\t\tbreak checkUnused;", "+\t\t\t// see if there is a no-arg super constructor", "+\t\t\tMethodBinding methodBinding = superClass.getExactConstructor(Binding.NO_PARAMETERS);", "+\t\t\tif (methodBinding == null)", "+\t\t\t\tbreak checkUnused;", "+\t\t\tif (!methodBinding.canBeSeenBy(SuperReference.implicitSuperConstructorCall(), this.scope))", "+\t\t\t\tbreak checkUnused;", "+\t\t\t// otherwise default super constructor exists, so go ahead and complain unused."]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c1250afc789782f83949198d591b11bb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/DecodeCodeFormatterPreferences.java", "commitBeforeChange": "b9fba611699cd3de6aaeecf1e218591cb72fa466", "commitAfterChange": "7464b1ea1c1edb40a36aa8ba9bb025cac2275919", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void startElement(String uri, String localName, String qName, \t\t\tAttributes attributes) throws SAXException", "signatureAfterChange": " \tpublic void startElement(String uri, String localName, String qName, \t\t\tAttributes attributes) throws SAXException", "diff": ["-\t\tSystem.out.println(localName);", "-\t\tSystem.out.println(qName);", "+\t\t", "-\t\tfor (int i = 0; i < attributesLength; i++) {", "-\t\t\tSystem.out.println(\"\\t\" + attributes.getValue(i));", "+\t\tif (\"profile\".equals(qName)) {", "+\t\t\tif (attributesLength == 1) {", "+\t\t\t\tif (\"name\".equals(attributes.getQName(0)) && profileName.equals(attributes.getValue(0))) {", "+\t\t\t\t\trecord = true;", "+\t\t\t\t\tentries = new HashMap();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else if (\"setting\".equals(qName) && record) {", "+\t\t\tif (attributesLength == 2) {", "+\t\t\t\tentries.put(attributes.getValue(0), attributes.getValue(1));", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe0fbfff739816fb8c9519518145824e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "c458ad2d505b6f4a7e2ec3bba3954504b01472bd", "commitAfterChange": "f802d6fc991463cb62d45c1ee5e011116f9ae063", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tprivate Openable createElement(IResource resource, int elementType, RootInfo rootInfo)", "signatureAfterChange": " \tprivate Openable createElement(IResource resource, int elementType, RootInfo rootInfo)", "diff": ["-\t\t\t\t\t\telement = (Openable)rootInfo.project;", "+\t\t\t\t\t\telement = rootInfo.project;", "-\t\t\t\telement = rootInfo == null ? JavaCore.create(resource) : rootInfo.project.getPackageFragmentRoot(resource);", "+\t\t\t\telement = rootInfo == null ? JavaCore.create(resource) : rootInfo.getPackageFragmentRoot(resource);", "-\t\t\t\t// find the element that encloses the resource", "-\t\t\t\tthis.popUntilPrefixOf(path);", "-\t\t\t\t", "-\t\t\t\tif (this.currentElement == null) {", "-\t\t\t\t\telement = rootInfo == null ? JavaCore.create(resource) : JavaModelManager.create(resource, rootInfo.project);", "-\t\t\t\t} else {", "-\t\t\t\t\t// find the root", "-\t\t\t\t\tIPackageFragmentRoot root = this.currentElement.getPackageFragmentRoot();", "-\t\t\t\t\tif (root == null) {", "-\t\t\t\t\t\telement =  rootInfo == null ? JavaCore.create(resource) : JavaModelManager.create(resource, rootInfo.project);", "-\t\t\t\t\t} else if (((JavaProject)root.getJavaProject()).contains(resource)) {", "+\t\t\t\tif (rootInfo != null) {", "+\t\t\t\t\tif (rootInfo.project.contains(resource)) {", "+\t\t\t\t\t\tIPackageFragmentRoot root = rootInfo.getPackageFragmentRoot(null);", "-\t\t\t\t\t\tIPath pkgPath = path.removeFirstSegments(root.getPath().segmentCount());", "+\t\t\t\t\t\tIPath pkgPath = path.removeFirstSegments(rootInfo.rootPath.segmentCount());", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// find the element that encloses the resource", "+\t\t\t\t\tthis.popUntilPrefixOf(path);", "+\t\t\t\t", "+\t\t\t\t\tif (this.currentElement == null) {", "+\t\t\t\t\t\telement = JavaCore.create(resource);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// find the root", "+\t\t\t\t\t\tIPackageFragmentRoot root = this.currentElement.getPackageFragmentRoot();", "+\t\t\t\t\t\tif (root == null) {", "+\t\t\t\t\t\t\telement =  JavaCore.create(resource);", "+\t\t\t\t\t\t} else if (((JavaProject)root.getJavaProject()).contains(resource)) {", "+\t\t\t\t\t\t\t// create package handle", "+\t\t\t\t\t\t\tIPath pkgPath = path.removeFirstSegments(root.getPath().segmentCount());", "+\t\t\t\t\t\t\tString pkg = Util.packageName(pkgPath);", "+\t\t\t\t\t\t\tif (pkg == null) return null;", "+\t\t\t\t\t\t\telement = root.getPackageFragment(pkg);", "+\t\t\t\t\t\t}"]}], "num": 39910}