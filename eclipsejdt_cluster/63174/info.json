{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e718ad5da417a97ed41e63a88b67437d", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c2d0e4d7a222352e09f47f3a87592e5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "1b6654cd80f53a2bb9b675efa0032a1013c4e291", "commitAfterChange": "0ab412e84edca675e938008720ddbff9326e27ed", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "signatureAfterChange": " boolean checkInheritedReturnTypes(MethodBinding[] methods, int length)", "diff": ["-\tfor (int i = 0, l = this.type.isAbstract() ? length - 2 : 0; i <= l;) {", "+\t// but if first method is concrete, then only check it against the rest", "+\tfor (int i = 0, l = methods[0].isAbstract() ? length - 2 : 0; i <= l;) {", "-\t\t\t\tif (this.type.isInterface())", "+\t\t\t\tif (this.type.isInterface()) {", "+\t\t\t\t} else {", "+\t\t\t\t\tif (method.declaringClass.isClass() || !this.type.implementsInterface(method.declaringClass, false))", "+\t\t\t\t\t\tif (methods[j].declaringClass.isClass() || !this.type.implementsInterface(methods[j].declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod; // do not complain since the superclass already got blamed", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b37e5878e21e1ea9ae7e4ea3801784c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "a78bb88c7ea4587ba8eb2a245492f61be802a95c", "commitAfterChange": "778e64a3c8e6903c625067607c9068d73d8cd5e5", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "  void checkForRedundantSuperinterfaces(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "signatureAfterChange": "  void checkForRedundantSuperinterfaces(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "diff": ["-\tfor (int i = 0, l = superInterfaces.length; i < l; i++)", "-\t\tinterfacesToCheck.add(superInterfaces[i]);", "+\tnext : for (int i = 0, l = superInterfaces.length; i < l; i++) {", "+\t\tReferenceBinding toCheck = superInterfaces[i];", "+\t\tfor (int j = 0; j < l; j++) {", "+\t\t\tif (i != j && toCheck.implementsInterface(superInterfaces[j], true)) {", "+\t\t\t\tTypeReference[] refs = this.type.scope.referenceContext.superInterfaces;", "+\t\t\t\tfor (int r = 0, rl = refs.length; r < rl; r++) {", "+\t\t\t\t\tif (refs[r].resolvedType == toCheck) {", "+\t\t\t\t\t\tproblemReporter().redundantSuperInterface(this.type, refs[r], toCheck, superInterfaces[j]);", "+\t\t\t\t\t\tcontinue next;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tinterfacesToCheck.add(toCheck);", "+\t}", "+"]}], "num": 63174}