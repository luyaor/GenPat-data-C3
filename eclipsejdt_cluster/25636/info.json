{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d5ff2f2857cca8d690b55fc5e2986ae8", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5d1c9da11cf238068f7601bb5cdacc79", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "b2ae5b84e851673c2a38346fddf34788249a797b", "commitAfterChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "-\t\t/* validate output location */", "-\t\tif (outputLocation == null) {", "+\t\t/* validate output locations */", "+\t\tif (projectOutputLocation == null) {", "-\t\tif (outputLocation.isAbsolute()) {", "-\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t}", "-\t\t} else {", "-\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t}", "-\t", "-\t\tboolean allowNestingInOutput = false;", "-\t\tboolean hasSource = false;", "-\t\tboolean hasLibFolder = false;", "-\t", "+\t\t// collect other output locations", "+\t\tint outputsLength = length+1;", "+\t\tIPath[] outputLocations = new IPath[outputsLength];", "+\t\toutputLocations[length] = projectOutputLocation;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\tIPath outputLocation = entry.getOutputLocation();", "+\t\t\tif (outputLocation != null) {", "+\t\t\t\tif (outputLocation.isAbsolute()) {", "+\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\toutputLocations[i] = outputLocation;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean hasSource = false;", "+\t\tboolean hasLibFolder = false;", "+\t\t", "-\t\t\tswitch(rawEntry.getEntryKind()){", "+\t\t\tint kind = rawEntry.getEntryKind();", "+\t\t\tswitch(kind){", "-\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "+\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "+\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "+\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "+\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "+\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "+\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\t\t\tif (outputLocation != null ", "+\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "+\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "-\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "+\t\t\t\tfor (int j = 0; j < length; j++){", "-\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t}", "-\t", "-\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\tfor (int j = 0; j < outputsLength; j++) {", "+\t\t\t\tIPath outputLocation = outputLocations[j];", "+\t\t\t\tif (outputLocation != null) {", "+\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t", "+\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f8627bab3103d529e636d98e0c471720", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "4d607b0a1e816e979fcd959b6151941b0be77df7", "commitAfterChange": "59519e2b1686eb933c8efe8536442e5841102c2e", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {", "+\tpublic static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {", "-\t\t/* validate output locations */", "-\t\tif (projectOutputLocation == null) {", "+\t\t/* validate output location */", "+\t\tif (outputLocation == null) {", "-\t\t// tolerate null path, it will be reset to default", "-\t\tint length = classpath == null ? 0 : classpath.length; ", "-\t\t// collect other output locations", "-\t\tint outputsLength = length+1;", "-\t\tIPath[] outputLocations = new IPath[outputsLength];", "-\t\toutputLocations[length] = projectOutputLocation;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tIClasspathEntry entry = classpath[i];", "-\t\t\tIPath outputLocation = entry.getOutputLocation();", "-\t\t\tif (outputLocation != null) {", "-\t\t\t\tif (outputLocation.isAbsolute()) {", "-\t\t\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\toutputLocations[i] = outputLocation;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\t\t\t}", "+\t\tif (outputLocation.isAbsolute()) {", "+\t\t\tif (!projectPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());", "+\t\t} else {", "+\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);", "-\t\tboolean[] allowNestingInOutput = new boolean[length+1];", "+\t\tboolean allowNestingInOutput = false;", "-\t\t", "+\t", "+\t\t// tolerate null path, it will be reset to default", "+\t\tint length = classpath == null ? 0 : classpath.length; ", "+\t", "-\t\t\tint kind = rawEntry.getEntryKind();", "-\t\t\tswitch(kind){", "+\t\t\tswitch(rawEntry.getEntryKind()){", "-\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with a binary output - in which case nesting inside output is legal", "-\t\t\t\t\t\t\t\t\t\tIPath resolvedPath = resolvedEntry.getPath();", "-\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < outputsLength; k++) {", "-\t\t\t\t\t\t\t\t\t\t\tIPath outputLocation = outputLocations[k];", "-\t\t\t\t\t\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t\t\t\t\t\t&& resolvedPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\t\t\t\t\t\tallowNestingInOutput[k] = true;\t\t", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal", "+\t\t\t\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\t\t\t\tif (kind != IClasspathEntry.CPE_SOURCE", "-\t\t\t\t\t\t\t&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "+\t\t\t\t\tif (!org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {", "-\t\t\t\t\tIPath rawPath = rawEntry.getPath();", "-\t\t\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\t\t\tif (outputLocation != null ", "-\t\t\t\t\t\t\t\t&& rawPath.equals(outputLocation)) {", "-\t\t\t\t\t\t\tallowNestingInOutput[j] = true;\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;", "-\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output", "+\t\tif (!hasSource && !hasLibFolder) allowNestingInOutput = true; // if no source and no lib folder, then allowed", "-\t\t\t\tfor (int j = 0; j < length; j++){", "+\t\t\t\tfor (int j = 0; j < classpath.length; j++){", "-\t\t\tfor (int j = 0; j < outputsLength; j++) {", "-\t\t\t\tIPath outputLocation = outputLocations[j];", "-\t\t\t\tif (outputLocation != null) {", "-\t\t\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t", "-\t\t\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "-\t\t\t\t\tif (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\tif (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestOutputInEntry\", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$", "+\t\t\t}", "+\t", "+\t\t\t// prevent nesting entry inside output location - when distinct from project or a source folder", "+\t\t\tif (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {", "+\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.cannotNestEntryInOutput\", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$"]}], "num": 25636}