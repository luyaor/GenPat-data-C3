{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b500e516c7cfda3ed5793ec2e3a9a070", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94c01c3db3be47947406c75dc1523b58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "c48ecebe36df1bdca1948a66baeb643827a9b9c4", "commitAfterChange": "df8a00dea42b2c33f742d8ce1045c2aa42b28f3e", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " void computeInheritedMethods(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "signatureAfterChange": " void computeInheritedMethods(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "diff": ["-\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[3][];", "-\tint lastPosition = -1;", "+\tReferenceBinding[] interfacesToVisit = null;", "+\tint nextPosition = 0;", "-\tif (itsInterfaces != Binding.NO_SUPERINTERFACES)", "-\t\tinterfacesToVisit[++lastPosition] = itsInterfaces;", "+\tif (itsInterfaces != Binding.NO_SUPERINTERFACES) {", "+\t\tnextPosition = itsInterfaces.length;", "+\t\tinterfacesToVisit = itsInterfaces;", "+\t}", "-\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t\t\t\tif (interfacesToVisit == null) {", "+\t\t\t\t\t\tinterfacesToVisit = itsInterfaces;", "+\t\t\t\t\t\tnextPosition = interfacesToVisit.length;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint itsLength = itsInterfaces.length;", "+\t\t\t\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "+\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "+\t\t\t\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "+\t\t\t\t\t\t\tReferenceBinding next = itsInterfaces[a];", "+\t\t\t\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "+\t\t\t\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "+\t\t\t\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\torg.eclipse.jdt.internal.compiler.util.SimpleSet interfacesSeen = new org.eclipse.jdt.internal.compiler.util.SimpleSet(lastPosition * 2);", "-\tfor (int i = 0; i <= lastPosition; i++) {", "-\t\tReferenceBinding[] interfaces = interfacesToVisit[i];", "-\t\tfor (int j = 0, l = interfaces.length; j < l; j++) {", "-\t\t\tsuperType = interfaces[j];", "-\t\t\tif (!interfacesSeen.includes(superType)) {", "-\t\t\t\tinterfacesSeen.add(superType);", "-\t\t\t\tif (superType.isValidBinding()) {", "-\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != Binding.NO_SUPERINTERFACES) {", "-\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tMethodBinding[] methods = superType.unResolvedMethods();", "-\t\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "-\t\t\t\t\t\tMethodBinding inheritedMethod = methods[m];", "-\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (existingMethods == null) {", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tint length = existingMethods.length;", "-\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "-\t\t\t\t\t\t\tfor (int e = 0; e < length; e++)", "-\t\t\t\t\t\t\t\tif (isInterfaceMethodImplemented(inheritedMethod, existingMethods[e], superType))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod; // skip interface method with the same signature if visible to its declaringClass", "-\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "-\t\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "-\t\t\t\t\t}", "+\tfor (int i = 0; i < nextPosition; i++) {", "+\t\tsuperType = interfacesToVisit[i];", "+\t\tif (superType.isValidBinding()) {", "+\t\t\tif ((itsInterfaces = superType.superInterfaces()) != Binding.NO_SUPERINTERFACES) {", "+\t\t\t\tint itsLength = itsInterfaces.length;", "+\t\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "+\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "+\t\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "+\t\t\t\t\tReferenceBinding next = itsInterfaces[a];", "+\t\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "+\t\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "+\t\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "+", "+\t\t\tMethodBinding[] methods = superType.unResolvedMethods();", "+\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "+\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "+\t\t\t\tif (existingMethods == null) {", "+\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "+\t\t\t\t} else {", "+\t\t\t\t\tint length = existingMethods.length;", "+\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "+\t\t\t\t\tfor (int e = 0; e < length; e++)", "+\t\t\t\t\t\tif (isInterfaceMethodImplemented(inheritedMethod, existingMethods[e], superType))", "+\t\t\t\t\t\t\tcontinue nextMethod; // skip interface method with the same signature if visible to its declaringClass", "+\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\texistingMethods[length] = inheritedMethod;", "+\t\t\t\t}", "+\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2811524c72967f387c237948ecde42d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "a8e18c32dc806d659bf5d8f2444be6f4268510d4", "commitAfterChange": "73072a493445774e509d0c21f3c359a527fa380b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void acceptInterface( \t\tchar[] packageName, \t\tchar[] interfaceName, \t\tint modifiers, \t\tAccessRestriction accessRestriction)", "signatureAfterChange": "  \tpublic void acceptType(char[] packageName, char[] typeName, int modifiers, AccessRestriction accessRestriction)", "diff": ["+\tpublic void acceptType(char[] packageName, char[] typeName, int modifiers, AccessRestriction accessRestriction) {", "+\t\t\t\tint length = 0;", "+\t\t\t\tint kind = modifiers & (IConstants.AccInterface+IConstants.AccEnum+IConstants.AccAnnotation);", "+\t\t\t\tswitch (kind) {", "+\t\t\t\t\tcase IConstants.AccAnnotation:", "+\t\t\t\t\tcase IConstants.AccAnnotation+IConstants.AccInterface:", "+\t\t\t\t\t\tchar[][] acceptedAnnotation = new char[2][];", "+\t\t\t\t\t\tacceptedAnnotation[0] = packageName;", "+\t\t\t\t\t\tacceptedAnnotation[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedAnnotations == null) {", "+\t\t\t\t\t\t\tthis.acceptedAnnotations = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedAnnotationsModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedAnnotationsCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedAnnotations.length;", "+\t\t\t\t\t\tif(length == this.acceptedAnnotationsCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedAnnotations, 0, this.acceptedAnnotations = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedAnnotationsModifiers, 0, this.acceptedAnnotationsModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedAnnotationsModifiers[this.acceptedAnnotationsCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedAnnotations[this.acceptedAnnotationsCount++] = acceptedAnnotation;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase IConstants.AccEnum:", "+\t\t\t\t\t\tchar[][] acceptedEnum = new char[2][];", "+\t\t\t\t\t\tacceptedEnum[0] = packageName;", "+\t\t\t\t\t\tacceptedEnum[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedEnums == null) {", "+\t\t\t\t\t\t\tthis.acceptedEnums = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedEnumsModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedEnumsCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedEnums.length;", "+\t\t\t\t\t\tif(length == this.acceptedEnumsCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedEnums, 0, this.acceptedEnums = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedEnumsModifiers, 0, this.acceptedEnumsModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedEnumsModifiers[this.acceptedEnumsCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedEnums[this.acceptedEnumsCount++] = acceptedEnum;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase IConstants.AccInterface:", "+\t\t\t\t\t\tchar[][] acceptedInterface= new char[2][];", "+\t\t\t\t\t\tacceptedInterface[0] = packageName;", "+\t\t\t\t\t\tacceptedInterface[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedInterfaces == null) {", "+\t\t\t\t\t\t\tthis.acceptedInterfaces = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedInterfacesModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedInterfacesCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedInterfaces.length;", "+\t\t\t\t\t\tif(length == this.acceptedInterfacesCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedInterfaces, 0, this.acceptedInterfaces = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedInterfacesModifiers, 0, this.acceptedInterfacesModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedInterfacesModifiers[this.acceptedInterfacesCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedInterfaces[this.acceptedInterfacesCount++] = acceptedInterface;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tchar[][] acceptedClass = new char[2][];", "+\t\t\t\t\t\tacceptedClass[0] = packageName;", "+\t\t\t\t\t\tacceptedClass[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedClasses == null) {", "+\t\t\t\t\t\t\tthis.acceptedClasses = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedClassesModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedClassesCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedClasses.length;", "+\t\t\t\t\t\tif(length == this.acceptedClassesCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedClasses, 0, this.acceptedClasses = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedClasses, 0, this.acceptedClassesModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedClassesModifiers[this.acceptedClassesCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedClasses[this.acceptedClassesCount++] = acceptedClass;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tthis.requestor.acceptType(", "-\t */", "-\tpublic void acceptInterface(", "-\t\tchar[] packageName,", "-\t\tchar[] interfaceName,", "-\t\tint modifiers,", "-\t\tAccessRestriction accessRestriction) {", "-", "-\t\tif (CharOperation.equals(interfaceName, this.selectedIdentifier)) {", "-\t\t\tif(mustQualifyType(packageName, interfaceName)) {", "-\t\t\t\tchar[][] acceptedInterface= new char[2][];", "-\t\t\t\tacceptedInterface[0] = packageName;", "-\t\t\t\tacceptedInterface[1] = interfaceName;", "-\t\t\t\t", "-\t\t\t\tif(this.acceptedInterfaces == null) {", "-\t\t\t\t\tthis.acceptedInterfaces = new char[10][][];", "-\t\t\t\t\tthis.acceptedInterfacesCount = 0;", "-\t\t\t\t}", "-\t\t\t\tint length = this.acceptedInterfaces.length;", "-\t\t\t\tif(length == this.acceptedInterfacesCount) {", "-\t\t\t\t\tSystem.arraycopy(this.acceptedInterfaces, 0, this.acceptedInterfaces = new char[(length + 1) * 2][][], 0, length);", "-\t\t\t\t}", "-\t\t\t\tthis.acceptedInterfaces[this.acceptedInterfacesCount++] = acceptedInterface;", "-\t\t\t\t", "-\t\t\t} else {", "-\t\t\t\tthis.noProposal = false;", "-\t\t\t\tthis.requestor.acceptInterface(", "-\t\t\t\t\tpackageName,", "-\t\t\t\t\tinterfaceName,", "+\t\t\t\t\tmodifiers,"]}], "num": 55125}