{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "587b61a65d414d3b4ae12d65c10c4e6c", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "290ef2a9f6858a78fbe48a33a658f954", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "588d952e65c684f03af494cb86d8547bcdcd3cc2", "commitAfterChange": "fe9d14fbc45b94989972b155e3ba906b870f20df", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 71, "signatureBeforeChange": " \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \t\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t*/", "-\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "-\t\tboolean varargsStatus = visible[0].isVarargs();", "-\t\tfor (int i = 1; i < visibleSize; i++) {", "-\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "-\t\t\t\t// visible is a mix of fixed & variable arity methods, so double check the varargs methods, but consider their vararg argument as a fixed array", "-\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "-\t\t\t\tint newSize = 0;", "-\t\t\t\tfor (int j = 0; j < visibleSize; j++)", "-\t\t\t\t\tif (!visible[j].isVarargs() || computeCompatibleMethod(visible[j], argumentTypes, invocationSite, false) != null)", "-\t\t\t\t\t\ttemp[newSize++] = visible[j];", "-\t\t\t\tvisible = temp;", "-\t\t\t\tvisibleSize = newSize;", "-\t\t\t\tbreak;", "+\t\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\t\t\tboolean varargsStatus = visible[0].isVarargs();", "+\t\t\tfor (int i = 1; i < visibleSize; i++) {", "+\t\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "+\t\t\t\t\t// visible is a mix of fixed & variable arity methods, so double check the varargs methods, but consider their vararg argument as a fixed array", "+\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "+\t\t\t\t\tint newSize = 0;", "+\t\t\t\t\tfor (int j = 0; j < visibleSize; j++)", "+\t\t\t\t\t\tif (!visible[j].isVarargs() || computeCompatibleMethod(visible[j], argumentTypes, invocationSite, false) != null)", "+\t\t\t\t\t\t\ttemp[newSize++] = visible[j];", "+\t\t\t\t\tvisible = temp;", "+\t\t\t\t\tvisibleSize = newSize;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "-\t\t}", "-", "-\t\tMethodBinding method = null;", "-\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "-\t\t\tmethod = visible[i];", "-\t\t\tfor (int j = 0; j < visibleSize; j++) {", "-\t\t\t\tif (i == j) continue;", "-\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(visible[j], method.parameters, invocationSite, false);", "-\t\t\t\tif (compatibleMethod == null)", "-\t\t\t\t\tcontinue nextVisible;", "+\t", "+\t\t\tMethodBinding method = null;", "+\t\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "+\t\t\t\tmethod = visible[i];", "+\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\t\tif (i == j) continue;", "+\t\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters))", "+\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t}", "+\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "+\t\t\t\treturn method;", "-\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\treturn method;", "-\t\t}", "-\t\treturn new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);", "-\t}\t", "+\t\t\treturn new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);", "+\t\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dccd36691b77037b0b628af24bb9d795", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "4075c9316d3502762c17ed452f06fa6d926713f3", "commitAfterChange": "19a1913b17e3092170a28a811c1b6c80eb2c4989", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 70, "signatureBeforeChange": "  \t\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "-\t\t\tboolean varargsStatus = visible[0].isVarargs();", "-\t\t\tfor (int i = 1; i < visibleSize; i++) {", "-\t\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "-\t\t\t\t\t// visible is a mix of fixed & variable arity methods, so double check the varargs methods, but consider their vararg argument as a fixed array", "-\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "-\t\t\t\t\tint newSize = 0;", "-\t\t\t\t\tfor (int j = 0; j < visibleSize; j++)", "-\t\t\t\t\t\tif (!visible[j].isVarargs() || visible[j].areParametersCompatibleWith(argumentTypes))", "-\t\t\t\t\t\t\ttemp[newSize++] = visible[j];", "-\t\t\t\t\tvisible = temp;", "-\t\t\t\t\tvisibleSize = newSize;", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t}", "-\t", "-\t\t\tMethodBinding method = null;", "-\t\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "-\t\t\t\tmethod = visible[i];", "+\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\t\tboolean varargsStatus = visible[0].isVarargs();", "+\t\tfor (int i = 1; i < visibleSize; i++) {", "+\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "+\t\t\t\t// visible can be a mix of fixed & variable arity methods, so re-check the varargs methods but consider their last arg as a fixed array", "+\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "+\t\t\t\tint newSize = 0;", "+\t\t\t\tint argLength = argumentTypes.length;", "-\t\t\t\t\tif (i == j) continue;", "-\t\t\t\t\t// tiebkreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters))", "-\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tif (visible[j].isVarargs())", "+\t\t\t\t\t\tif (visible[j].parameters.length != argLength", "+\t\t\t\t\t\t\t|| !argumentTypes[argLength - 1].isCompatibleWith(visible[j].parameters[argLength - 1]))", "+\t\t\t\t\t\t\t\tcontinue; // forget this varargs method since its last arg is not an exact match", "+\t\t\t\t\ttemp[newSize++] = visible[j];", "-\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\t\treturn method;", "+\t\t\t\tvisible = temp;", "+\t\t\t\tvisibleSize = newSize;", "+\t\t\t\tbreak;", "-\t\t\treturn new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);", "-\t\t}\t", "+\t\t}", "+", "+\t\tMethodBinding method = null;", "+\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "+\t\t\tmethod = visible[i];", "+\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\tif (i == j) continue;", "+\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "+\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "+\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "+\t\t\t\t\t\tint paramLength = method.parameters.length;", "+\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "+\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "+\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "+\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "+\t\t\treturn method;", "+\t\t}", "+\t\treturn new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);", "+\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa99a3446c926daceebff2f4dc8bccd7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "1585d95aacd546d0fef8e25ddee2f5a6f64f7c62", "commitAfterChange": "bcf6d39cea27ed7bf3bf85709bd7e60dc5605058", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 72, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tboolean varargsStatus = visible[0].isVarargs();", "-\t\tfor (int i = 1; i < visibleSize; i++) {", "-\t\t\tif (visible[i].isVarargs() != varargsStatus) {", "-\t\t\t\t// visible can be a mix of fixed & variable arity methods, so re-check the varargs methods but consider their last arg as a fixed array", "-\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleSize];", "-\t\t\t\tint newSize = 0;", "-\t\t\t\tint argLength = argumentTypes.length;", "-\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "-\t\t\t\t\tif (visible[j].isVarargs())", "-\t\t\t\t\t\tif (visible[j].parameters.length != argLength", "-\t\t\t\t\t\t\t|| !argumentTypes[argLength - 1].isCompatibleWith(visible[j].parameters[argLength - 1]))", "-\t\t\t\t\t\t\t\tcontinue; // forget this varargs method since its last arg is not an exact match", "-\t\t\t\t\ttemp[newSize++] = visible[j];", "-\t\t\t\t}", "-\t\t\t\tvisible = temp;", "-\t\t\t\tvisibleSize = newSize;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "+\t\tint[] compatibilityLevels = new int[visibleSize];", "+\t\tfor (int i = 0; i < visibleSize; i++)", "+\t\t\tcompatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);", "-\t\tMethodBinding method = null;", "-\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "-\t\t\tmethod = visible[i];", "-\t\t\tfor (int j = 0; j < visibleSize; j++) {", "-\t\t\t\tif (i == j) continue;", "-\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "-\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "-\t\t\t\t\t\tint paramLength = method.parameters.length;", "-\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "-\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "+\t\tfor (int level = 0; level <= 2; level++) {", "+\t\t\tnextVisible : for (int i = 0; i < visibleSize; i++) {", "+\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now", "+\t\t\t\tMethodBinding method = visible[i];", "+\t\t\t\tfor (int j = 0; j < visibleSize; j++) {", "+\t\t\t\t\tif (i == j || compatibilityLevels[j] != level) continue;", "+\t\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "+\t\t\t\t\tif (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "+\t\t\t\t\t\tif (method.isVarargs() && visible[j].isVarargs()) {", "+\t\t\t\t\t\t\tint paramLength = method.parameters.length;", "+\t\t\t\t\t\t\tif (paramLength == visible[j].parameters.length && paramLength == argumentTypes.length + 1) {", "+\t\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) visible[j].parameters[paramLength - 1]).elementsType();", "+\t\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "+\t\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "+\t\t\t\treturn method;", "-\t\t\tcompilationUnitScope().recordTypeReferences(method.thrownExceptions);", "-\t\t\treturn method;"]}], "num": 2839}