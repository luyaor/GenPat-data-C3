{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e5a5a28699bff10953acfb15918573cb", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c58caf74fce8f1f73675669b1ef8246", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "89c18bd033b87a7a12d6c68b0ebd2f3c37c4e5ee", "commitAfterChange": "3fcbb850162acb838f146eb8136c34f914b17c6f", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r private void computeInheritedMethods()", "signatureAfterChange": "\r private void computeInheritedMethods()", "diff": ["+\tReferenceBinding superType;\r", "-\t\tReferenceBinding superType = this.type;\r", "-\t\tMethodBinding[] nonVisibleDefaultMethods = null;\r", "-\t\tint nonVisibleCount = 0;\r", "+\t\tsuperType = this.type;\r", "+\t} else { // check interface methods against Object\r", "+\t\tsuperType = this.type.scope.getJavaLangObject();\r", "+\t}\r", "+\tMethodBinding[] nonVisibleDefaultMethods = null;\r", "+\tint nonVisibleCount = 0;\r", "-\t\twhile ((superType = superType.superclass()) != null) {\r", "-\t\t\tif (superType.isValidBinding()) {\r", "-\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "-\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "-\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "-\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "-\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "-\t\t\t\t}\r", "+\twhile (superType != null) {\r", "+\t\tif (superType.isValidBinding()) {\r", "+\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();\r", "+\t\t\tif (itsInterfaces != NoSuperInterfaces) {\r", "+\t\t\t\tif (++lastPosition == interfacesToVisit.length)\r", "+\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);\r", "+\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;\r", "+\t\t\t}\r", "-\t\t\t\tMethodBinding[] methods = superType.methods();\r", "-\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {\r", "-\t\t\t\t\tMethodBinding method = methods[m];\r", "-\t\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) { // look at all methods which are NOT private or constructors or default abstract\r", "-\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "-\t\t\t\t\t\tif (existingMethods != null)\r", "-\t\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)\r", "-\t\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)\r", "-\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))\r", "+\t\t\tMethodBinding[] methods = superType.methods();\r", "+\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {\r", "+\t\t\t\tMethodBinding method = methods[m];\r", "+\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) { // look at all methods which are NOT private or constructors or default abstract\r", "+\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);\r", "+\t\t\t\t\tif (existingMethods != null)\r", "+\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++)\r", "+\t\t\t\t\t\t\tif (method.returnType == existingMethods[i].returnType)\r", "+\t\t\t\t\t\t\t\tif (method.areParametersEqual(existingMethods[i]))\r", "+\t\t\t\t\t\t\t\t\tcontinue nextMethod;\r", "+\t\t\t\t\tif (nonVisibleDefaultMethods != null)\r", "+\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)\r", "+\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)\r", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector))\r", "+\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))\r", "-\t\t\t\t\t\tif (nonVisibleDefaultMethods != null)\r", "-\t\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)\r", "-\t\t\t\t\t\t\t\tif (method.returnType == nonVisibleDefaultMethods[i].returnType)\r", "-\t\t\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector))\r", "-\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(nonVisibleDefaultMethods[i]))\r", "-\t\t\t\t\t\t\t\t\t\t\tcontinue nextMethod;\r", "-\t\t\t\t\t\tif (!(method.isDefault() && (method.declaringClass.fPackage != type.fPackage))) { // ignore methods which have default visibility and are NOT defined in another package\r", "-\t\t\t\t\t\t\tif (existingMethods == null)\r", "-\t\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "-\t\t\t\t\t\t\telse\r", "-\t\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "-\t\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "-\t\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "-\t\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)\r", "-\t\t\t\t\t\t\t\tnonVisibleDefaultMethods = new MethodBinding[10];\r", "-\t\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)\r", "-\t\t\t\t\t\t\t\tSystem.arraycopy(nonVisibleDefaultMethods, 0,\r", "-\t\t\t\t\t\t\t\t\t(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]), 0, nonVisibleCount);\r", "-\t\t\t\t\t\t\tnonVisibleDefaultMethods[nonVisibleCount++] = method;\r", "+\t\t\t\t\tif (!(method.isDefault() && (method.declaringClass.fPackage != type.fPackage))) { // ignore methods which have default visibility and are NOT defined in another package\r", "+\t\t\t\t\t\tif (existingMethods == null)\r", "+\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];\r", "+\t\t\t\t\t\telse\r", "+\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,\r", "+\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);\r", "+\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;\r", "+\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)\r", "+\t\t\t\t\t\t\tnonVisibleDefaultMethods = new MethodBinding[10];\r", "+\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)\r", "+\t\t\t\t\t\t\tSystem.arraycopy(nonVisibleDefaultMethods, 0,\r", "+\t\t\t\t\t\t\t\t(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]), 0, nonVisibleCount);\r", "+\t\t\t\t\t\tnonVisibleDefaultMethods[nonVisibleCount++] = method;\r", "-\t\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract\r", "-\t\t\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);\r", "+\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract\r", "+\t\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);\r", "-\t\t\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);\r", "-\t\t\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued\r", "-\t\t\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {\r", "-\t\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {\r", "-\t\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {\r", "-\t\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);\r", "-\t\t\t\t\t\t\t\t\t\t\tbreak foundMatch;\r", "-\t\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);\r", "+\t\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued\r", "+\t\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {\r", "+\t\t\t\t\t\t\t\tif (method.returnType == current[i].returnType) {\r", "+\t\t\t\t\t\t\t\t\tif (method.areParametersEqual(current[i])) {\r", "+\t\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);\r", "+\t\t\t\t\t\t\t\t\t\tbreak foundMatch;\r", "+\t\t\tsuperType = superType.superclass();\r", "-\t\t\tReferenceBinding superType = interfaces[j];\r", "+\t\t\tsuperType = interfaces[j];\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "92df2c9d6cfbe37e62a80d8474f85c1a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "607ff419d62fc0f91055d1c2d16685459d9fa667", "commitAfterChange": "0cad9a75d8029433899afbdf88cbb39e8dd0618a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " void computeInheritedMethods()", "signatureAfterChange": " void computeInheritedMethods()", "diff": ["+\t// only want to remember inheritedMethods that can have an impact on the current type", "+\t// if an inheritedMethod has been 'replaced' by a supertype's method then skip it", "+", "-\t\t\t\tMethodBinding method = methods[m];", "-\t\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "+\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\tif (inheritedMethod.isPrivate() || inheritedMethod.isConstructor() || inheritedMethod.isDefaultAbstract())", "-\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (areReturnTypesEqual(method, existingMethods[i]) && areParametersEqual(method, existingMethods[i])) {", "-\t\t\t\t\t\t\tif (method.isDefault() && method.isAbstract() && method.declaringClass.fPackage != type.fPackage)", "-\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(method);", "+\t\t\t\t\t\tif (doesMethodOverride(existingMethods[i], inheritedMethod)) {", "+\t\t\t\t\t\t\tif (inheritedMethod.isDefault() && inheritedMethod.isAbstract())", "+\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(inheritedMethod);", "-\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(method.selector);", "+\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (areReturnTypesEqual(method, nonVisible[i]) && areParametersEqual(method, nonVisible[i])) ", "+\t\t\t\t\t\tif (doesMethodOverride(nonVisible[i], inheritedMethod))", "-\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "+\t\t\t\tif (!inheritedMethod.isDefault() || inheritedMethod.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "+\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "-\t\t\t\t\t\tnonVisible = new MethodBinding[] {method};", "+\t\t\t\t\t\tnonVisible = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\tnonVisible[length] = method;", "+\t\t\t\t\t\tnonVisible[length] = inheritedMethod;", "-\t\t\t\t\tnonVisibleDefaultMethods.put(method.selector, nonVisible);", "+\t\t\t\t\tnonVisibleDefaultMethods.put(inheritedMethod.selector, nonVisible);", "-\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "-\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);", "+\t\t\t\t\tif (inheritedMethod.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, inheritedMethod);", "-\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);", "+\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\t\tif (areReturnTypesEqual(method, current[i]) && areParametersEqual(method, current[i])) {", "-\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "+\t\t\t\t\t\t\tif (doesMethodOverride(current[i], inheritedMethod)) {", "+\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], inheritedMethod);", "-\t\t\t\t\t\tMethodBinding method = methods[m];", "-\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "+\t\t\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "+\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\t\t\tif (areParametersEqual(method, existing) && existing.declaringClass.implementsInterface(superType, true))", "+\t\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "+\t\t\t\t\t\t\t\tif (areParametersEqual(existing, inheritedMethod) && existing.declaringClass.implementsInterface(superType, true))", "+// so if the implemented method is abstract & has a different return type then did it get a bridge method?", "-\t\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);"]}], "num": 43773}