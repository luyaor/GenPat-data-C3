{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a4a7973c83b66c66915debdef5455aac", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3921a0955bba75a5d1540b3b4e65dc1d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "f0ca1f9e3571a6c8cc7bcfc8fee3982374c51194", "commitAfterChange": "c4fa4d272fd0c5fb7e1db44c8cef0ea47f3df504", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["+\t\t\tboolean compliant14 = compilerOptions().complianceLevel < ClassFileConstants.JDK1_5;", "+\t\t\t\t} else if (compliant14 && invocationSite instanceof MessageSend", "+\t\t\t\t\t\t   && param.kind() == Binding.PARAMETERIZED_TYPE && param.erasure().id == TypeIds.T_JavaLangClass", "+\t\t\t\t\t\t   && ((ParameterizedTypeBinding) param).arguments.length == 1 ", "+\t\t\t\t\t\t   && ((ParameterizedTypeBinding) param).arguments[0] instanceof TypeVariableBinding ", "+\t\t\t\t\t\t   && arguments[i] instanceof BinaryTypeBinding && arguments[i].erasure().id == TypeIds.T_JavaLangClass) {", "+\t\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=328775. Class literals are special in that", "+\t\t\t\t\t   they carry (and are the only expressions that can carry) full parameterization information", "+\t\t\t\t\t   even in 1.4 source code. For inference during method selection/invocation to work properly,", "+\t\t\t\t\t   resolve class literal expression's type to be a parameterized type if in 1.4 we encounter", "+\t\t\t\t\t   a method that expects a parameter of the type Class<>   ", "+\t\t\t\t\t */", "+\t\t\t\t\tif (newArgs == null) {", "+\t\t\t\t\t\tnewArgs = new TypeBinding[argLength];", "+\t\t\t\t\t\tSystem.arraycopy(arguments, 0, newArgs, 0, argLength);", "+\t\t\t\t\t}", "+\t\t\t\t\tClassLiteralAccess classLiteral = (ClassLiteralAccess) ((MessageSend) invocationSite).arguments[i];", "+\t\t\t\t\t// Integer.class --> Class<Integer>, perform boxing of base types (int.class --> Class<Integer>)", "+\t\t\t\t\t// BundleWiring.class --> Class<BundleWiring>", "+\t\t\t\t\tTypeBinding boxedType = boxing(classLiteral.targetType);", "+\t\t\t\t\tnewArgs[i] = classLiteral.resolvedType = environment().createParameterizedType(((ParameterizedTypeBinding)param).genericType(), new TypeBinding[]{ boxedType }, null /*not a member*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9132171e88311f0d14284361be46bfc3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "25d057e481a8674bd29dd96dfbc223d170a5d43f", "commitAfterChange": "addbb66dfc65753fddbe6114fef5f3dfb7e5200c", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t\tif (typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\tboolean compliant14 = compilerOptions().complianceLevel < ClassFileConstants.JDK1_5;", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=330435, inference should kick in only at source 1.5+", "+\t\tif (typeVariables != Binding.NO_TYPE_VARIABLES && compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) { // generic method", "-\t\t\t\t} else if (compliant14 && invocationSite instanceof MessageSend", "-\t\t\t\t\t\t   && param.kind() == Binding.PARAMETERIZED_TYPE && param.erasure().id == TypeIds.T_JavaLangClass", "-\t\t\t\t\t\t   && ((ParameterizedTypeBinding) param).arguments.length == 1 ", "-\t\t\t\t\t\t   && ((ParameterizedTypeBinding) param).arguments[0] instanceof TypeVariableBinding ", "-\t\t\t\t\t\t   && arguments[i] instanceof BinaryTypeBinding && arguments[i].erasure().id == TypeIds.T_JavaLangClass) {", "-\t\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=328775. Class literals are special in that", "-\t\t\t\t\t   they carry (and are the only expressions that can carry) full parameterization information", "-\t\t\t\t\t   even in 1.4 source code. For inference during method selection/invocation to work properly,", "-\t\t\t\t\t   resolve class literal expression's type to be a parameterized type if in 1.4 we encounter", "-\t\t\t\t\t   a method that expects a parameter of the type Class<>   ", "-\t\t\t\t\t */", "-\t\t\t\t\tif (newArgs == null) {", "-\t\t\t\t\t\tnewArgs = new TypeBinding[argLength];", "-\t\t\t\t\t\tSystem.arraycopy(arguments, 0, newArgs, 0, argLength);", "-\t\t\t\t\t}", "-\t\t\t\t\tClassLiteralAccess classLiteral = (ClassLiteralAccess) ((MessageSend) invocationSite).arguments[i];", "-\t\t\t\t\t// Integer.class --> Class<Integer>, perform boxing of base types (int.class --> Class<Integer>)", "-\t\t\t\t\t// BundleWiring.class --> Class<BundleWiring>", "-\t\t\t\t\tTypeBinding boxedType = boxing(classLiteral.targetType);", "-\t\t\t\t\tnewArgs[i] = classLiteral.resolvedType = environment().createParameterizedType(((ParameterizedTypeBinding)param).genericType(), new TypeBinding[]{ boxedType }, null /*not a member*/);"]}], "num": 8530}