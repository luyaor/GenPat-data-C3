{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "09e9a18d7b351823ccaacb6832cf9678", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3766a4801827deb0850b104fabf9a13c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "77ac300d6d124e9b071b4e62fab3a583e6eecdc4", "commitAfterChange": "fbf658958d1eb066a4b5c16fdea253c3d8d5019c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "+\t\tTypeBinding lhsType;", "+    \tif (this.constant != Constant.NotAConstant) {", "+    \t\tthis.constant = Constant.NotAConstant;", "+    \t\tthis.enclosingScope = scope;", "+    \t\tif (isConstructorReference())", "+    \t\t\tthis.lhs.bits |= ASTNode.IgnoreRawTypeCheck; // raw types in constructor references are to be treated as though <> were specified.", "+", "+    \t\tlhsType = this.lhs.resolveType(scope);", "+    \t\tif (this.typeArguments != null) {", "+    \t\t\tint length = this.typeArguments.length;", "+    \t\t\tthis.typeArgumentsHaveErrors = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "+    \t\t\tthis.resolvedTypeArguments = new TypeBinding[length];", "+    \t\t\tfor (int i = 0; i < length; i++) {", "+    \t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+    \t\t\t\tif ((this.resolvedTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+    \t\t\t\t\tthis.typeArgumentsHaveErrors = true;", "+    \t\t\t\t}", "+    \t\t\t\tif (this.typeArgumentsHaveErrors && typeReference instanceof Wildcard) { // resolveType on wildcard always return null above, resolveTypeArgument is the real workhorse.", "+    \t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t\tif (this.typeArgumentsHaveErrors)", "+    \t\t\t\treturn this.resolvedType;", "+    \t\t}", "+    \t} else {", "+    \t\tif (this.typeArgumentsHaveErrors)", "+\t\t\t\treturn this.resolvedType;", "+    \t\tlhsType = this.lhs.resolvedType;", "+    \t}", "+", "+    \tif (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {", "+\t\t\treturn new PolyTypeBinding(this);", "+\t\t}", "-\t\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "-    \tif (isConstructorReference())", "-\t\t\tthis.lhs.bits |= ASTNode.IgnoreRawTypeCheck; // raw types in constructor references are to be treated as though <> were specified.", "-\t\t", "-\t\tTypeBinding lhsType = this.lhs.resolveType(scope);", "-\t\tif (this.typeArguments != null) {", "-\t\t\tint length = this.typeArguments.length;", "-\t\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\tthis.resolvedTypeArguments = new TypeBinding[length];", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "-\t\t\t\tif ((this.resolvedTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\t\targHasError = true;", "-\t\t\t\t}", "-\t\t\t\tif (argHasError && typeReference instanceof Wildcard) { // resolveType on wildcard always return null above, resolveTypeArgument is the real workhorse.", "-\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (argHasError)", "-\t\t\t\treturn this.resolvedType;", "-\t\t}", "-\t\t", "-\t\tif (lhsType == null || !lhsType.isValidBinding()) ", "+    \tif (lhsType == null || !lhsType.isValidBinding()) ", "-        this.binding = someMethod != null && someMethod.isValidBinding() ? someMethod : anotherMethod != null && anotherMethod.isValidBinding() ? anotherMethod : null;", "-        this.method.binding = this.binding;", "+        this.method.binding = this.binding = someMethod != null && someMethod.isValidBinding() ? someMethod : ", "+        \t\t\t\t\t\t\t\t\t\t\tanotherMethod != null && anotherMethod.isValidBinding() ? anotherMethod : null;", "+", "-    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope))", "+    \t\tif (!returnType.isCompatibleWith(this.descriptor.returnType, scope) && !isBoxingCompatible(returnType, this.descriptor.returnType, this, scope)) {", "+    \t\t\tthis.method.binding = this.binding = null;", "+    \t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4f73be4afa81ee36d0b963a8ab33414", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "1a542c460a449efbae14d1057ba233825602248d", "commitAfterChange": "1ddc6abfe5d6cd8ad8c71d5100cfa53f4e84487a", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t", "+    \t\tif (this.typeArgumentsHaveErrors || lhsType == null)", "+\t\t\t\treturn this.resolvedType = null;", "+\t", "+    \t\tif (lhsType.problemId() == ProblemReasons.AttemptToBypassDirectSuper)", "+    \t\t\tlhsType = lhsType.closestMatch();\t// improve resolving experience", "+        \tif (lhsType == null || !lhsType.isValidBinding()) ", "+    \t\t\treturn this.resolvedType = null;\t// nope, no useful type found", "+        \t", "+    \t\tthis.receiverType = lhsType;", "+\t\t\tthis.haveReceiver = true;", "+\t\t\tif (this.lhs instanceof NameReference) {", "+\t\t\t\tif ((this.lhs.bits & ASTNode.RestrictiveFlagMASK) == Binding.TYPE) {", "+\t\t\t\t\tthis.haveReceiver = false;", "+\t\t\t\t}", "+\t\t\t} else if (this.lhs instanceof TypeReference) {", "+\t\t\t\tthis.haveReceiver = false;", "+\t\t\t}", "+\t\t\tif (!this.haveReceiver && !this.lhs.isSuper() && !this.isArrayConstructorReference())", "+\t\t\t\tthis.receiverType = lhsType.capture(scope, this.sourceStart, this.sourceEnd);", "+", "+\t\t\tif (!lhsType.isRawType()) // RawType::m and RawType::new are not exact method references", "+\t    \t\tthis.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);", "+", "+    \t\tif (isConstructorReference() && !lhsType.canBeInstantiated()) {", "+    \t\t\tscope.problemReporter().cannotInstantiate(this.lhs, lhsType);", "+    \t\t\treturn this.resolvedType = null;", "+    \t\t}", "+    \t\t", "+    \t\tif (this.lhs instanceof TypeReference && ((TypeReference)this.lhs).hasNullTypeAnnotation()) {", "+    \t\t\tscope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);", "+    \t\t}", "+", "+\t    \tif (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {", "+\t    \t\treturn this.resolvedType = new PolyTypeBinding(this);", "+\t\t\t}", "-    \tif (lhsType != null && !lhsType.isRawType()) // RawType::m and RawType::new are not exact method references", "-    \t\tthis.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);", "-", "-    \tif (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {", "-    \t\treturn new PolyTypeBinding(this);", "-\t\t}", "-\t\tsuper.resolveType(scope);", "+    \tsuper.resolveType(scope);", "-    \tif (lhsType == null) ", "-\t\t\treturn this.resolvedType = null; \t// no hope", "-\t\tif (lhsType.problemId() == ProblemReasons.AttemptToBypassDirectSuper)", "-\t\t\tlhsType = lhsType.closestMatch();\t// improve resolving experience", "-    \tif (!lhsType.isValidBinding()) ", "-\t\t\treturn this.resolvedType = null;\t// nope, no useful type found", "-    \t", "-\t\tif (isConstructorReference() && !lhsType.canBeInstantiated()) {", "-\t\t\tscope.problemReporter().cannotInstantiate(this.lhs, lhsType);", "-\t\t\treturn this.resolvedType = null;", "-\t\t}", "-\t\t", "-\t\tif (this.lhs instanceof TypeReference && ((TypeReference)this.lhs).hasNullTypeAnnotation()) {", "-\t\t\tscope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);", "-\t\t}", "-", "-\t\tthis.receiverType = lhsType;", "-\t\t", "-\t\tthis.haveReceiver = true;", "-\t\tif (this.lhs instanceof NameReference) {", "-\t\t\tif ((this.lhs.bits & ASTNode.RestrictiveFlagMASK) == Binding.TYPE) {", "-\t\t\t\tthis.haveReceiver = false;", "-\t\t\t}", "-\t\t} else if (this.lhs instanceof TypeReference) {", "-\t\t\tthis.haveReceiver = false;", "-\t\t}", "-\t\t", "-\t\tif (!this.haveReceiver && !this.lhs.isSuper() && !this.isArrayConstructorReference())", "-\t\t\tthis.receiverType = lhsType.capture(scope, this.sourceStart, this.sourceEnd);", "-\t\t"]}], "num": 36893}