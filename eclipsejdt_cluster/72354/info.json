{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1043c81dfaa4252439b718055e7203cf", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "095593a20d87a15ebac7b6eeeadad510", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "6c797406271c70e354dc360e4e2b55dc743bf914", "commitAfterChange": "6bb034ac24fec033a91d15d668c7ba33f5039fc9", "methodNumberBeforeChange": 177, "methodNumberAfterChange": 177, "signatureBeforeChange": " public void javadocInvalidConstructor(Statement statement, MethodBinding targetConstructor, int modifiers)", "signatureAfterChange": " public void javadocInvalidConstructor(Statement statement, MethodBinding targetConstructor, int modifiers)", "diff": ["-\tif (!javadocVisibility(this.options.reportInvalidJavadocTagsVisibility, modifiers)) {", "-\t\treturn;", "-\t}", "-//\tboolean insideDefaultConstructor = ", "-//\t\t(this.referenceContext instanceof ConstructorDeclaration)", "-//\t\t\t&& ((ConstructorDeclaration)this.referenceContext).isDefaultConstructor();", "-//\tboolean insideImplicitConstructorCall =", "-//\t\t(statement instanceof ExplicitConstructorCall)", "-//\t\t\t&& (((ExplicitConstructorCall) statement).accessMode == ExplicitConstructorCall.ImplicitSuper);", "-", "+\tif (!javadocVisibility(this.options.reportInvalidJavadocTagsVisibility, modifiers)) return;", "-//\t\t\tif (insideDefaultConstructor){", "-//\t\t\t\tid = IProblem.JavadocUndefinedConstructorInDefaultConstructor;", "-//\t\t\t} else if (insideImplicitConstructorCall){", "-//\t\t\t\tid = IProblem.JavadocUndefinedConstructorInImplicitConstructorCall;", "-//\t\t\t} else {", "-\t\t\t\tid = IProblem.JavadocUndefinedConstructor;", "-//\t\t\t}", "+\t\t\tid = IProblem.JavadocUndefinedConstructor;", "-//\t\t\tif (insideDefaultConstructor){", "-//\t\t\t\tid = IProblem.JavadocNotVisibleConstructorInDefaultConstructor;", "-//\t\t\t} else if (insideImplicitConstructorCall){", "-//\t\t\t\tid = IProblem.JavadocNotVisibleConstructorInImplicitConstructorCall;", "-//\t\t\t} else {", "-\t\t\t\tid = IProblem.JavadocNotVisibleConstructor;", "-//\t\t\t}", "+\t\t\tid = IProblem.JavadocNotVisibleConstructor;", "-//\t\t\tif (insideDefaultConstructor){", "-//\t\t\t\tid = IProblem.AmbiguousConstructorInDefaultConstructor;", "-//\t\t\t} else if (insideImplicitConstructorCall){", "-//\t\t\t\tid = IProblem.AmbiguousConstructorInImplicitConstructorCall;", "-//\t\t\t} else {", "-\t\t\t\tid = IProblem.JavadocAmbiguousConstructor;", "-//\t\t\t}", "+\t\t\tid = IProblem.JavadocAmbiguousConstructor;", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ccd26576e98e99116203a83870811b5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java", "commitBeforeChange": "e749248b2d171474b4cec0b274f15c474b2172fa", "commitAfterChange": "49bbfb9368cdcf7ee010de91440ff4d54ad31533", "methodNumberBeforeChange": 96, "methodNumberAfterChange": 142, "signatureBeforeChange": " public void incorrectEnclosingInstanceReference( \tQualifiedThisReference reference,  \tTypeBinding qualificationType)", "signatureAfterChange": " public void noSuchEnclosingInstance(TypeBinding targetType, AstNode location, boolean isConstructorCall)", "diff": ["-public void incorrectEnclosingInstanceReference(", "-\tQualifiedThisReference reference, ", "-\tTypeBinding qualificationType) {", "-\t\t", "-\tthis.handle(", "-\t\tIProblem.IncorrectEnclosingInstanceReference, ", "-\t\tnew String[] { new String(qualificationType.readableName())}, ", "-\t\tnew String[] { new String(qualificationType.shortReadableName())}, ", "-\t\treference.sourceStart, ", "-\t\treference.sourceEnd); ", "-}", "+public void noSuchEnclosingInstance(TypeBinding targetType, AstNode location, boolean isConstructorCall) {", "+", "+\tint id;", "+", "+\tif (isConstructorCall) {", "+\t\t//28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation", "+\t\tid = IProblem.EnclosingInstanceInConstructorCall;", "+\t} else if ((location instanceof ExplicitConstructorCall)", "+\t\t\t\t&& ((ExplicitConstructorCall) location).accessMode == ExplicitConstructorCall.ImplicitSuper) {", "+\t\t//20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).", "+\t\tid = IProblem.MissingEnclosingInstanceForConstructorCall;", "+\t} else if (location instanceof AllocationExpression ", "+\t\t\t\t&& (((AllocationExpression) location).binding.declaringClass.isMemberType()", "+\t\t\t\t\t|| (((AllocationExpression) location).binding.declaringClass.isAnonymousType() ", "+\t\t\t\t\t\t&& ((AllocationExpression) location).binding.declaringClass.superclass().isMemberType()))) {", "+\t\t//21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).", "+\t\tid = IProblem.MissingEnclosingInstance;", "+\t} else { // default", "+\t\t//22 = No enclosing instance of the type {0} is accessible in scope", "+\t\tid = IProblem.IncorrectEnclosingInstanceReference;", "+\t}", "+", "+\tthis.handle(", "+\t\tid,", "+\t\tnew String[] { new String(targetType.readableName())}, ", "+\t\tnew String[] { new String(targetType.shortReadableName())}, ", "+\t\tlocation.sourceStart, ", "+\t\tlocation.sourceEnd); ", "+}"]}], "num": 72354}