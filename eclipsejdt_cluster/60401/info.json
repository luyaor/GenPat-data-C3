{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "84bd5c616d1ca3dc70d6739598e6138f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0335e37d00c3f47fe9dc2a2c5f41ea00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompoundAssignment.java", "commitBeforeChange": "67c70f0229b1ee30edee39ee40e49c055e5684f0", "commitAfterChange": "2d2c8e4351b8f7e6edd805ab55e60b91a4cccfa1", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tboolean expressionIsCast = this.expression instanceof CastExpression;", "+\t\tif (expressionIsCast)", "+\t\t\tthis.expression.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\t\tif (expressionIsCast)", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, this.operator, result, this.lhs, originalLhsType.id, false, this.expression, originalExpressionType.id, true);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c90504b29a5ee97b3c5590caec50eb7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a29a64421d33da260a7d362b9f95ba50806929de", "commitAfterChange": "128ece82f5c9df1393b097e56edcf89a686dc03c", "methodNumberBeforeChange": 173, "methodNumberAfterChange": 174, "signatureBeforeChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed, \t\tBinding[] missingElements, \t\tint[] missingElementsStarts, \t\tint[] missingElementsEnds, \t\tboolean missingElementsHaveProblems, \t\tchar[] castedReceiver, \t\tint receiverStart, \t\tint receiverEnd)", "signatureAfterChange": " \tprivate void findLocalMethods( \t\tchar[] methodName, \t\tTypeBinding[] typeArgTypes, \t\tTypeBinding[] argTypes, \t\tMethodBinding[] methods, \t\tScope scope, \t\tObjectVector methodsFound, \t\tboolean onlyStaticMethods, \t\tboolean exactMatch, \t\tReferenceBinding receiverType, \t\tInvocationSite invocationSite, \t\tScope invocationScope, \t\tboolean implicitCall, \t\tboolean superCall, \t\tboolean canBePrefixed, \t\tBinding[] missingElements, \t\tint[] missingElementsStarts, \t\tint[] missingElementsEnds, \t\tboolean missingElementsHaveProblems, \t\tchar[] castedReceiver, \t\tint receiverStart, \t\tint receiverEnd)", "diff": ["+\t\tboolean completionOnReferenceExpressionName = invocationSite instanceof ReferenceExpression;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tTypeBinding type = method.original().parameters[i];", "-\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();", "-\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();", "-\t\t\t}", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tTypeBinding type = method.original().parameters[i];", "+\t\t\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();", "+\t\t\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();", "+\t\t\t\t}", "-\t\t\t\t\tif (this.source != null", "+\t\t\t\t\tif (completionOnReferenceExpressionName)", "+\t\t\t\t\t\tcompletion = method.selector;", "+\t\t\t\t\telse if (this.source != null", "-\t\t\t\t\telse", "+\t\t\t\t\telse ", "-\t\t\t\t\tInternalCompletionProposal proposal =  createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);", "+\t\t\t\t\tInternalCompletionProposal proposal =  createProposal(completionOnReferenceExpressionName ? CompletionProposal.METHOD_NAME_REFERENCE : CompletionProposal.METHOD_REF, this.actualCompletionPosition);", "-\t\t\t\t\tproposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);", "+\t\t\t\t\tif (completionOnReferenceExpressionName)", "+\t\t\t\t\t\tproposal.setReplaceRange(this.endPosition - this.offset - methodLength, this.endPosition - this.offset);", "+\t\t\t\t\telse ", "+\t\t\t\t\t\tproposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f242c82e764ac3a7c830e30a40fe6596", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java", "commitBeforeChange": "46df66625bb01025e2f747d9b3cccffff9c1a6c7", "commitAfterChange": "c7ee0f26df56582a4fdd4c9183c2b927d77dbd19", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "  \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+\t\tboolean expressionIsCast;", "+\t\tif ((expressionIsCast = this.expression instanceof CastExpression) == true) this.expression.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\tint expressionId = expressionType.id;", "-\t\tif (expressionId > 15) {", "+\t\tint expressionTypeId = expressionType.id;", "+\t\tif (expressionTypeId > 15) {", "-", "+\t", "-", "+\t", "-\t\tint result = OperatorSignatures[tableId][(expressionId << 4) + expressionId];", "-\t\tthis.expression.implicitConversion = result >>> 12;", "-\t\tthis.bits |= result & 0xF;", "-\t\tswitch (result & 0xF) { // only switch on possible result type.....", "+\t\tint operatorSignature = OperatorSignatures[tableId][(expressionTypeId << 4) + expressionTypeId];", "+\t\tthis.expression.implicitConversion = operatorSignature >>> 12;", "+\t\tthis.bits |= operatorSignature & 0xF;", "+\t\tswitch (operatorSignature & 0xF) { // only switch on possible result type.....", "-\t\t\t\tif (expressionId != T_undefined)", "+\t\t\t\tif (expressionTypeId != T_undefined)", "-\t\t\t\t\texpressionId,", "+\t\t\t\t\texpressionTypeId,", "+\t\tif (expressionIsCast) {", "+\t\t// check need for operand cast", "+\t\t\tCastExpression.checkNeedForArgumentCast(scope, tableId, operatorSignature, this.expression, expressionTypeId);", "+\t\t}"]}], "num": 60401}