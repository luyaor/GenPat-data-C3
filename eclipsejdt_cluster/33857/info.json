{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1e618cf05bbf895eecfa767422d3246d", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "157a11ce493e5c9de5e5f7db3cfa56ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "a8073c80a69f6c184e71b3ada3faf15faa3ff3ae", "commitAfterChange": "33e49b6e14282ee69dc2c2cf0c73bec5e674cdf2", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "signatureAfterChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "diff": ["+\t\t\tMap implicitContainerAnnotations = null;", "-\t\t\t\tTypeBinding annotationType = annotation.getAnnotationType();", "+\t\t\t\tReferenceBinding annotationType = annotation.getAnnotationType();", "-\t\t\t\t\t\tfoundDuplicate = true;", "-\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "-\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "+\t\t\t\t\t\tif (annotationType.isRepeatableAnnotation()) {", "+\t\t\t\t\t\t\tReferenceBinding resolvedContainer = annotationType.resolveContainerAnnotation();", "+\t\t\t\t\t\t\tif (resolvedContainer != null) {", "+\t\t\t\t\t\t\t\t// Since this is a repeated annotation, we need to check if the container is also used - so store it", "+\t\t\t\t\t\t\t\t// in a map of (container's ReferenceBinding -> the repeated source Annotation)", "+\t\t\t\t\t\t\t\tif (implicitContainerAnnotations == null) implicitContainerAnnotations = new HashMap(3);", "+\t\t\t\t\t\t\t\timplicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);", "+\t\t\t\t\t\t\t\tAnnotation.checkAnnotationContainerTarget(sourceAnnotations[i], scope, annotationType, resolvedContainer);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tfoundDuplicate = true;", "+\t\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "+\t\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tdistinctAnnotations[j] = null; // report it only once", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[j], scope.compilerOptions().sourceLevel);", "-\t\t\t\t\t\tdistinctAnnotations[j] = null; // report it only once", "-\t\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[j]);", "-\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[i]);", "+\t\t\t\t\tscope.problemReporter().duplicateAnnotation(sourceAnnotations[i], scope.compilerOptions().sourceLevel);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (implicitContainerAnnotations != null) {", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tif (distinctAnnotations[i] == null) continue;", "+\t\t\t\t\tAnnotation annotation = sourceAnnotations[i];", "+\t\t\t\t\tReferenceBinding annotationType = distinctAnnotations[i].getAnnotationType();", "+\t\t\t\t\tif (implicitContainerAnnotations.containsKey(annotationType)) {", "+\t\t\t\t\t\tscope.problemReporter().repeatedAnnotationWithContainer((Annotation) implicitContainerAnnotations.get(annotationType), annotation);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3d1d820d3d82b6cbe585b89a6a4c6485", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "ea035aff9493ec8381c8d6bd9548845ad9f81e22", "commitAfterChange": "3c8b95412c50bb73a8372fbf9db9df68231cc311", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "signatureAfterChange": " \tpublic static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType)", "diff": ["+\t\t/* See if the recipient is meta-annotated with @Repeatable and if so validate constraints. We can't do this during resolution of @Repeatable itself as @Target and ", "+\t\t   @Retention etc could come later", "+\t\t*/   ", "-\t\t\t// See if this is meta-annotated as repeatable and if so validate constraints.", "-\t\t\t\tMemberValuePair[] valuePairs = annotation.memberValuePairs();", "-\t\t\t\tif (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {", "-\t\t\t\t\tannotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);", "-\t\t\t\t}", "+\t\t\t\tif (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable)", "+\t\t\t\t\tannotation.checkRepeatableMetaAnnotation(scope);", "+\t\t\t\tContainerAnnotation container = null;", "-\t\t\t\t\t\tif (annotationType.isRepeatableAnnotation()) {", "-\t\t\t\t\t\t\tReferenceBinding resolvedContainer = annotationType.resolveContainerAnnotation();", "-\t\t\t\t\t\t\tif (resolvedContainer != null) {", "-\t\t\t\t\t\t\t\t// Since this is a repeated annotation, we need to check if the container is also used - so store it", "-\t\t\t\t\t\t\t\t// in a map of (container's ReferenceBinding -> the repeated source Annotation)", "+\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "+\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tdistinctAnnotations[j] = null; // report/process it only once", "+\t\t\t\t\t\tif (annotationType.isRepeatableAnnotationType()) {", "+\t\t\t\t\t\t\tAnnotation persistibleAnnotation = sourceAnnotations[i].getPersistibleAnnotation();", "+\t\t\t\t\t\t\tif (persistibleAnnotation instanceof ContainerAnnotation)", "+\t\t\t\t\t\t\t\tcontainer = (ContainerAnnotation) persistibleAnnotation;", "+\t\t\t\t\t\t\tif (container == null) {  // first encounter with a duplicate.", "+\t\t\t\t\t\t\t\tReferenceBinding containerAnnotationType = annotationType.containerAnnotationType();", "+\t\t\t\t\t\t\t\tcontainer = new ContainerAnnotation(sourceAnnotations[i], containerAnnotationType, scope);", "-\t\t\t\t\t\t\t\timplicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);", "-\t\t\t\t\t\t\t\t// Validate the repeated *use* of a repeatable annotation.", "-\t\t\t\t\t\t\t\tAnnotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);", "+\t\t\t\t\t\t\t\timplicitContainerAnnotations.put(containerAnnotationType, sourceAnnotations[i]);", "+\t\t\t\t\t\t\tcontainer.addContainee(sourceAnnotations[j]);", "-\t\t\t\t\t\t\tif (distinctAnnotations == annotations) {", "-\t\t\t\t\t\t\t\tSystem.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tdistinctAnnotations[j] = null; // report it only once", "+\t\t\t\tif (container != null) {", "+\t\t\t\t\tcontainer.resolveType(scope);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bfe051ac913485252da55a407a47c865", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "3a2c07095325b8093bf4d50c97ee67b15f50e18e", "commitAfterChange": "b09d2126c38d49158f7469476885c30cd6012f32", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient)", "signatureAfterChange": " \tpublic static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient)", "diff": ["+\t\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\t\t// need to fill the instances array", "+\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\t\tAnnotation annot = sourceAnnotations[j];", "+\t\t\t\t\t\t\t\tannotations[j] = annot.getCompilerAnnotation();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t/*", "-\t\t\t\t\t\t * Annotations are shared between two locals, but we still need to record", "-\t\t\t\t\t\t * the suppress annotation range for the second local", "-\t\t\t\t\t\t */", "-\t\t\t\t\t\tif ((otherLocalTagBits & TagBits.AnnotationSuppressWarnings) != 0) {", "+\t\t\t\t\t\tif ((otherLocalTagBits & TagBits.AnnotationSuppressWarnings) == 0) {", "+\t\t\t\t\t\t\t// None of the annotations is a SuppressWarnings annotation", "+\t\t\t\t\t\t\t// need to fill the instances array", "+\t\t\t\t\t\t\tif (annotations != null) {", "+\t\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\t\t\tAnnotation annot = sourceAnnotations[j];", "+\t\t\t\t\t\t\t\t\tannotations[j] = annot.getCompilerAnnotation();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (annotations != null) {", "+\t\t\t\t\t\t\t// One of the annotations at least is a SuppressWarnings annotation", "-\t\t\t\t\t\t\tannotation.recordSuppressWarnings(scope, localDeclaration.declarationSourceStart, localDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);", "+\t\t\t\t\t\t\tint declarationSourceEnd = localDeclaration.declarationSourceEnd;", "+\t\t\t\t\t\t\tint declarationSourceStart = localDeclaration.declarationSourceStart;", "+\t\t\t\t\t\t\tfor (int j = 0; j < length; j++) {", "+\t\t\t\t\t\t\t\tAnnotation annot = sourceAnnotations[j];", "+\t\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t\t * Annotations are shared between two locals, but we still need to record", "+\t\t\t\t\t\t\t\t * the suppress annotation range for the second local", "+\t\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\t\tAnnotationBinding annotationBinding = annot.getCompilerAnnotation();", "+\t\t\t\t\t\t\t\tannotations[j] = annotationBinding;", "+\t\t\t\t\t\t\t\tif (annotationBinding != null) {", "+\t\t\t\t\t\t\t\t\tfinal ReferenceBinding annotationType = annotationBinding.getAnnotationType();", "+\t\t\t\t\t\t\t\t\tif (annotationType != null && annotationType.id == TypeIds.T_JavaLangSuppressWarnings) {", "+\t\t\t\t\t\t\t\t\t\tannot.recordSuppressWarnings(scope, declarationSourceStart, declarationSourceEnd, scope.compilerOptions().suppressWarnings);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t// need to fill the instances array", "-\t\t\t\t\tannotations[0] = annotation.getCompilerAnnotation();", "-\t\t\t\t\tfor (int j = 1; j < length; j++) {", "-\t\t\t\t\t\tAnnotation annot = sourceAnnotations[j];", "-\t\t\t\t\t\tannotations[j] = annot.getCompilerAnnotation();", "-\t\t\t\t\t}"]}], "num": 33857}