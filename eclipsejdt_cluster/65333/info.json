{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ef823ad2d01a861b5a26df01619af222", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2208c739f80c67122e6d6cc429ee9e9e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "702c62fec0923d7526ca23efea5c1bb4f5a2ef27", "commitAfterChange": "48a78bfcb529886e24e5f62b1bc56f7d3678e46a", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\t\t\tcopy = cachedResolvedCopy(targetType, false);", "+\t\t\tcopy = cachedResolvedCopy(targetType, false, true);", "-\t\t}", "-\t\tif (copy == null) {", "-\t\t\treturn null;", "-\t\t}", "-\t\t", "-\t\t/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and ", "-\t\t   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only", "-\t\t   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.", "-\t\t*/", "-\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "-\t\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\t\ttry {", "-\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\t\tcopy.analyzeExceptions();", "-\t\t\t} finally {", "-\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f953f50210128afc7cba45e82702a7c7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "-\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\ttry {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "-\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "-\t\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "-\t\t\t\t// value compatibility of block lambda's is the only open question.", "-\t\t\t\tcopy.valueCompatible |= copy.doesNotCompleteNormally();", "-\t\t\t} else {", "-\t\t\t\tif (!copy.returnsVoid)", "-\t\t\t\t\tcopy.valueCompatible = true; // optimistically, TODO: is this OK??", "+\t\t", "+\t\t/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and ", "+\t\t   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only", "+\t\t   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.", "+\t\t*/", "+\t\tif (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {", "+\t\t\tfinal CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();", "+\t\t\tboolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\t\ttry {", "+\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = false;", "+\t\t\t\tcopy.analyzeExceptions();", "+\t\t\t} finally {", "+\t\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "+\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t} finally {", "-\t\t\tcompilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);"]}], "num": 65333}