{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "66f188f68e110a05d493b3f4e6757885", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2fbbff1122be228bd88bd4de1013ef85", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "b031afa5d276b867791e1b801c0ddbbd905837a2", "commitAfterChange": "af60458069f14dd1b42612d075df4c51d6608d2d", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " void checkForNameClash(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " void checkForNameClash(MethodBinding currentMethod, MethodBinding inheritedMethod)", "diff": ["-\tif (inheritedMethod.isStatic()) return;", "+\tif (inheritedMethod.isStatic() || currentMethod.isStatic()) {", "+\t\tMethodBinding original = inheritedMethod.original(); // can be the same as inherited", "+\t\tif (this.type.scope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_7 && currentMethod.areParameterErasuresEqual(original)) {", "+\t\t\tproblemReporter(currentMethod).methodNameClashHidden(currentMethod, inheritedMethod.declaringClass.isRawType() ? inheritedMethod : original);", "+\t\t}", "+\t\treturn; // no chance of bridge method's clashing", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d0f66de693b84b6c5d95b5e94dd0132", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java", "commitBeforeChange": "a4e58088a1010e10b50ef0d8683567f65215eac1", "commitAfterChange": "e58a2ebf19f99fca487e8ddd26a3dd844cc59501", "methodNumberBeforeChange": 85, "methodNumberAfterChange": 85, "signatureBeforeChange": "  protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options)", "signatureAfterChange": "  protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options)", "diff": ["-\t\t// restore applied null annotation from tagBits:", "-\t    if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {", "-\t    \tchar[][] nonNullAnnotationName = options.nonNullAnnotationName;", "-\t\t\tnameBuffer.append('@').append(nonNullAnnotationName[nonNullAnnotationName.length-1]).append(' ');", "-\t    }", "-\t    if ((this.tagBits & TagBits.AnnotationNullable) != 0) {", "-\t    \tchar[][] nullableAnnotationName = options.nullableAnnotationName;", "-\t\t\tnameBuffer.append('@').append(nullableAnnotationName[nullableAnnotationName.length-1]).append(' ');", "-\t    }", "+\t\tif (options.usesNullTypeAnnotations()) {", "+\t\t\tfor (AnnotationBinding annotation : this.typeAnnotations) {", "+\t\t\t\tTypeBinding annotationType = annotation.getAnnotationType();", "+\t\t\t\tif (annotationType.id == TypeIds.T_ConfiguredAnnotationNonNull || annotation.type.id == TypeIds.T_ConfiguredAnnotationNullable) {", "+\t\t\t\t\tnameBuffer.append('@').append(annotationType.shortReadableName()).append(' ');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// restore applied null annotation from tagBits:", "+\t\t    if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\t    \tchar[][] nonNullAnnotationName = options.nonNullAnnotationName;", "+\t\t\t\tnameBuffer.append('@').append(nonNullAnnotationName[nonNullAnnotationName.length-1]).append(' ');", "+\t\t    }", "+\t\t    if ((this.tagBits & TagBits.AnnotationNullable) != 0) {", "+\t\t    \tchar[][] nullableAnnotationName = options.nullableAnnotationName;", "+\t\t\t\tnameBuffer.append('@').append(nullableAnnotationName[nullableAnnotationName.length-1]).append(' ');", "+\t\t    }", "+\t\t}"]}], "num": 62328}