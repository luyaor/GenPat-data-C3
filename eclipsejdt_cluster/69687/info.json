{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7a21867bac11e55f6e5b0bfd5e99a26c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "05236ac0a12df01d483833c9969c48bc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTVisitorTest.java", "commitBeforeChange": "4005c370e6cbaf5fe897eaa7c9410e92ff25148d", "commitAfterChange": "f0d3823e693314be74db80c5730855ddd690aa1f", "methodNumberBeforeChange": 251, "methodNumberAfterChange": 257, "signatureBeforeChange": " \tpublic void testTryStatement()", "signatureAfterChange": " \tpublic void testTryStatement()", "diff": ["+\t/** @deprecated using deprecated code */", "+\t\tint level = this.ast.apiLevel();", "+\t\tif (level >= AST.JLS4) {", "+\t\t\tVariableDeclarationExpression vde1= this.ast.newVariableDeclarationExpression(this.W1);", "+\t\t\tvde1.setType(this.T1);", "+\t\t\tx1.resources().add(vde1);", "+\t\t\tVariableDeclarationExpression vde2= this.ast.newVariableDeclarationExpression(this.W2);", "+\t\t\tvde2.setType(this.T2);", "+\t\t\tx1.resources().add(vde2);", "+\t\t}", "-\t\tassertTrue(result.equals(\"[(sTY\"+this.B1S+\"[(cc\"+this.V1S+\"[(sBsB)]\"+\"cc)]\"+\"[(cc\"+this.V2S+\"[(sBsB)]\"+\"cc)]\"+\"[(sBsB)]\"+\"sTY)]\")); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$", "+\t\tassertEquals(\"[(sTY\"", "+\t\t\t\t+(level >= AST.JLS4 ? \"[(eVD\"+this.T1S+this.W1S+\"eVD)]\"+\"[(eVD\"+this.T2S+this.W2S+\"eVD)]\" : \"\")", "+\t\t\t\t+this.B1S+\"[(cc\"+this.V1S+\"[(sBsB)]\"+\"cc)]\"+\"[(cc\"+this.V2S+\"[(sBsB)]\"+\"cc)]\"+\"[(sBsB)]\"+\"sTY)]\", result); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bcbe1bfd18fe09b7867b210ec4f23db", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "signatureAfterChange": " \t\tfinal Binding getTypeOrPackage(char[] name, int mask)", "diff": ["-\t*/", "-\tfinal Binding getTypeOrPackage(char[] name, int mask) {", "-\t\tScope scope = this;", "-\t\tReferenceBinding foundType = null;", "-\t\tif ((mask & TYPE) == 0) {", "-\t\t\tScope next = scope;", "-\t\t\twhile ((next = scope.parent) != null)", "-\t\t\t\tscope = next;", "-\t\t} else {", "-\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "-\t\t\t\tswitch (scope.kind) {", "-\t\t\t\t\tcase METHOD_SCOPE :", "-\t\t\t\t\tcase BLOCK_SCOPE :", "-\t\t\t\t\t\tReferenceBinding localType = ((BlockScope) scope).findLocalType(name); // looks in this scope only", "-\t\t\t\t\t\tif (localType != null) {", "-\t\t\t\t\t\t\tif (foundType != null && foundType != localType)", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\treturn localType;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase CLASS_SCOPE :", "-\t\t\t\t\t\tSourceTypeBinding sourceType = ((ClassScope) scope).referenceContext.binding;", "-\t\t\t\t\t\t// 6.5.5.1 - simple name favors member type over top-level type in same unit", "-\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "-\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn memberType;", "-\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t*/", "+\t\tfinal Binding getTypeOrPackage(char[] name, int mask) {", "+\t\t\tScope scope = this;", "+\t\t\tReferenceBinding foundType = null;", "+\t\t\tboolean insideStaticContext = false;", "+\t\t\tboolean resolvingHierarchy = false;", "+\t\t\tif ((mask & TYPE) == 0) {", "+\t\t\t\tScope next = scope;", "+\t\t\t\twhile ((next = scope.parent) != null)", "+\t\t\t\t\tscope = next;", "+\t\t\t} else {", "+\t\t\t\tdone : while (true) { // done when a COMPILATION_UNIT_SCOPE is found", "+\t\t\t\t\tswitch (scope.kind) {", "+\t\t\t\t\t\tcase METHOD_SCOPE :", "+\t\t\t\t\t\t\tMethodScope methodScope = (MethodScope) scope;", "+\t\t\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodScope.referenceMethod();", "+\t\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) {", "+\t\t\t\t\t\t\t\tTypeVariableBinding typeVariable = methodDecl.binding.getTypeVariable(name);", "+\t\t\t\t\t\t\t\tif (typeVariable != null)\treturn typeVariable;", "-\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "-\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundType == null)", "-\t\t\t\t\t\t\t\t\t\treturn memberType; ", "-\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t\tif (foundType != memberType)", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\tinsideStaticContext |= methodScope.isStatic;", "+\t\t\t\t\t\tcase BLOCK_SCOPE :", "+\t\t\t\t\t\t\tReferenceBinding localType = ((BlockScope) scope).findLocalType(name); // looks in this scope only", "+\t\t\t\t\t\t\tif (localType != null) {", "+\t\t\t\t\t\t\t\tif (foundType != null && foundType != localType)", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn localType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase CLASS_SCOPE :", "+\t\t\t\t\t\t\tSourceTypeBinding sourceType = ((ClassScope) scope).referenceContext.binding;", "+\t\t\t\t\t\t\tif (sourceType.isHierarchyBeingConnected()) {", "+\t\t\t\t\t\t\t\t// type variables take precedence over the source type, ex. class X <X> extends X == class X <Y> extends Y ", "+\t\t\t\t\t\t\t\tTypeVariableBinding typeVariable = sourceType.getTypeVariable(name);", "+\t\t\t\t\t\t\t\tif (typeVariable != null)", "+\t\t\t\t\t\t\t\t\treturn typeVariable;", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(name, sourceType.sourceName))", "+\t\t\t\t\t\t\t\t\treturn sourceType;", "+\t\t\t\t\t\t\t\tresolvingHierarchy = true;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// type variables take precedence over member types", "+\t\t\t\t\t\t\tTypeVariableBinding typeVariable = sourceType.getTypeVariable(name);", "+\t\t\t\t\t\t\tif (typeVariable != null) {", "+\t\t\t\t\t\t\t\tif (resolvingHierarchy)", "+\t\t\t\t\t\t\t\t\t// class X <T> { class MX extends T {}}", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, IllegalSuperTypeVariable); // cannot bind to a type variable", "+\t\t\t\t\t\t\t\tif (insideStaticContext) // do not consider this type modifiers: access is legite within same type", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\treturn typeVariable;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tinsideStaticContext |= (sourceType.modifiers & AccStatic) != 0; // not isStatic()", "+\t\t\t\t\t\t\t// 6.5.5.1 - member types have precedence over top-level type in same unit", "+\t\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "+\t\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\treturn memberType;", "+\t\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "+\t\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\tif (foundType == null)", "+\t\t\t\t\t\t\t\t\t\t\treturn memberType; ", "+\t\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundType != memberType)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "+\t\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "+\t\t\t\t\t\t\t\t\tfoundType = memberType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (CharOperation.equals(sourceType.sourceName, name)) {", "+\t\t\t\t\t\t\t\tif (foundType != null && foundType != sourceType && foundType.problemId() != NotVisible)", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn sourceType;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "+\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t}", "+\t\t\t\t\tscope = scope.parent;", "+\t\t\t\t}", "+\t\t\t\tif (foundType != null && foundType.problemId() != NotVisible)", "+\t\t\t\t\treturn foundType;", "+\t\t\t}", "+\t", "+\t\t\t// at this point the scope is a compilation unit scope", "+\t\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "+\t\t\tPackageBinding currentPackage = unitScope.fPackage; ", "+\t\t\t// ask for the imports + name", "+\t\t\tif ((mask & TYPE) != 0) {", "+\t\t\t\t// check single type imports.", "+\t", "+\t\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\t\tif (imports != null) {", "+\t\t\t\t\tHashtableOfObject typeImports = unitScope.resolvedSingeTypeImports;", "+\t\t\t\t\tif (typeImports != null) {", "+\t\t\t\t\t\tImportBinding typeImport = (ImportBinding) typeImports.get(name);", "+\t\t\t\t\t\tif (typeImport != null) {", "+\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// walk all the imports since resolvedSingeTypeImports is not yet initialized", "+\t\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\t\t\tImportBinding typeImport = imports[i];", "+\t\t\t\t\t\t\tif (!typeImport.onDemand) {", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\t\t\tif (unitScope.resolveSingleTypeImport(typeImport) != null) {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "-\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "-\t\t\t\t\t\t\t\tfoundType = memberType;", "-\t\t\t\t\t\tif (CharOperation.equals(sourceType.sourceName, name)) {", "-\t\t\t\t\t\t\tif (foundType != null && foundType != sourceType && foundType.problemId() != NotVisible)", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\treturn sourceType;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\t\tbreak done;", "-\t\t\t\t}", "-\t\t\t\tscope = scope.parent;", "-\t\t\t}", "-\t\t\tif (foundType != null && foundType.problemId() != NotVisible)", "-\t\t\t\treturn foundType;", "-\t\t}", "-", "-\t\t// at this point the scope is a compilation unit scope", "-\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "-\t\tPackageBinding currentPackage = unitScope.fPackage; ", "-\t\t// ask for the imports + name", "-\t\tif ((mask & TYPE) != 0) {", "-\t\t\t// check single type imports.", "-", "-\t\t\tImportBinding[] imports = unitScope.imports;", "-\t\t\tif (imports != null) {", "-\t\t\t\tHashtableOfObject typeImports = unitScope.resolvedSingeTypeImports;", "-\t\t\t\tif (typeImports != null) {", "-\t\t\t\t\tImportBinding typeImport = (ImportBinding) typeImports.get(name);", "-\t\t\t\t\tif (typeImport != null) {", "-\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "-\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "-\t\t\t\t} else {", "-\t\t\t\t\t// walk all the imports since resolvedSingeTypeImports is not yet initialized", "+\t\t\t\t}", "+\t\t\t\t// check if the name is in the current package, skip it if its a sub-package", "+\t\t\t\tunitScope.recordReference(currentPackage.compoundName, name);", "+\t\t\t\tBinding binding = currentPackage.getTypeOrPackage(name);", "+\t\t\t\tif (binding instanceof ReferenceBinding) return binding; // type is always visible to its own package", "+\t", "+\t\t\t\t// check on demand imports", "+\t\t\t\tif (imports != null) {", "+\t\t\t\t\tboolean foundInImport = false;", "+\t\t\t\t\tReferenceBinding type = null;", "-\t\t\t\t\t\tImportBinding typeImport = imports[i];", "-\t\t\t\t\t\tif (!typeImport.onDemand) {", "-\t\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "-\t\t\t\t\t\t\t\tif (unitScope.resolveSingleTypeImport(typeImport) != null) {", "-\t\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\tImportBinding someImport = imports[i];", "+\t\t\t\t\t\tif (someImport.onDemand) {", "+\t\t\t\t\t\t\tBinding resolvedImport = someImport.resolvedImport;", "+\t\t\t\t\t\t\tReferenceBinding temp = resolvedImport instanceof PackageBinding", "+\t\t\t\t\t\t\t\t? findType(name, (PackageBinding) resolvedImport, currentPackage)", "+\t\t\t\t\t\t\t\t: findDirectMemberType(name, (ReferenceBinding) resolvedImport);", "+\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tImportReference importReference = someImport.reference;", "-\t\t\t\t\t\t\t\t\treturn typeImport.resolvedImport; // already know its visible", "+\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand packages.", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "+\t\t\t\t\t\t\t\t\ttype = temp;", "+\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t} else if (foundType == null) {", "+\t\t\t\t\t\t\t\t\tfoundType = temp;", "+\t\t\t\t\tif (type != null) return type;", "-\t\t\t// check if the name is in the current package, skip it if its a sub-package", "-\t\t\tunitScope.recordReference(currentPackage.compoundName, name);", "-\t\t\tBinding binding = currentPackage.getTypeOrPackage(name);", "-\t\t\tif (binding instanceof ReferenceBinding) return binding; // type is always visible to its own package", "-", "-\t\t\t// check on demand imports", "-\t\t\tif (imports != null) {", "-\t\t\t\tboolean foundInImport = false;", "-\t\t\t\tReferenceBinding type = null;", "-\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\t\tImportBinding someImport = imports[i];", "-\t\t\t\t\tif (someImport.onDemand) {", "-\t\t\t\t\t\tBinding resolvedImport = someImport.resolvedImport;", "-\t\t\t\t\t\tReferenceBinding temp = resolvedImport instanceof PackageBinding", "-\t\t\t\t\t\t\t? findType(name, (PackageBinding) resolvedImport, currentPackage)", "-\t\t\t\t\t\t\t: findDirectMemberType(name, (ReferenceBinding) resolvedImport);", "-\t\t\t\t\t\tif (temp != null) {", "-\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "-\t\t\t\t\t\t\t\tImportReference importReference = someImport.reference;", "-\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\tif (foundInImport)", "-\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand packages.", "-\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "-\t\t\t\t\t\t\t\ttype = temp;", "-\t\t\t\t\t\t\t\tfoundInImport = true;", "-\t\t\t\t\t\t\t} else if (foundType == null) {", "-\t\t\t\t\t\t\t\tfoundType = temp;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (type != null) return type;", "+\t", "+\t\t\tunitScope.recordSimpleReference(name);", "+\t\t\tif ((mask & PACKAGE) != 0) {", "+\t\t\t\tPackageBinding packageBinding = unitScope.environment.getTopLevelPackage(name);", "+\t\t\t\tif (packageBinding != null) return packageBinding;", "+\t", "+\t\t\t// Answer error binding -- could not find name", "+\t\t\tif (foundType != null) return foundType; // problem type from above", "+\t\t\treturn new ProblemReferenceBinding(name, NotFound);", "-", "-\t\tunitScope.recordSimpleReference(name);", "-\t\tif ((mask & PACKAGE) != 0) {", "-\t\t\tPackageBinding packageBinding = unitScope.environment.getTopLevelPackage(name);", "-\t\t\tif (packageBinding != null) return packageBinding;", "-\t\t}", "-", "-\t\t// Answer error binding -- could not find name", "-\t\tif (foundType != null) return foundType; // problem type from above", "-\t\treturn new ProblemReferenceBinding(name, NotFound);", "-\t}"]}], "num": 69687}