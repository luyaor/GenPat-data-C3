{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c463925f2078e414110c600a74b1d469", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4395b191e41f3650a898ce16fd1e66d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "de65819236a978eabe6f11a104e36a24db789ea9", "commitAfterChange": "1b976600c434b11b3265b882431a4b1ae03c69f7", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate void generateElementValue(Expression defaultValue, int attributeOffset)", "signatureAfterChange": " \tprivate void generateElementValue(Expression defaultValue, int attributeOffset)", "diff": ["-\t\t\tif (contentsOffset + 3 >= this.contents.length) {", "-\t\t\t\tresizeContents(3);", "-\t\t\t}", "-\t\t\tswitch (constant.typeID()) {", "-\t\t\t\tcase T_boolean :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'Z';", "-\t\t\t\t\tint booleanValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.booleanValue() ? 1 : 0);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (booleanValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) booleanValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_byte :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'B';", "-\t\t\t\t\tint integerValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.intValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (integerValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) integerValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_char :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'C';", "-\t\t\t\t\tintegerValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.intValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (integerValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) integerValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_int :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'I';", "-\t\t\t\t\tintegerValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.intValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (integerValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) integerValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_short :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'S';", "-\t\t\t\t\tintegerValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.intValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (integerValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) integerValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_float :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'F';", "-\t\t\t\t\tint floatValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.floatValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (floatValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) floatValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_double :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'D';", "-\t\t\t\t\tint doubleValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.doubleValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (doubleValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) doubleValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_long :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 'J';", "-\t\t\t\t\tint longValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(constant.longValue());", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) (longValueIndex >> 8);", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) longValueIndex;", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase T_String :", "-\t\t\t\t\tcontents[contentsOffset++] = (byte) 's';", "-\t\t\t\t\tint stringValueIndex =", "-\t\t\t\t\t\tconstantPool.literalIndex(", "-\t\t\t\t\t\t\t((StringConstant) constant).stringValue());", "-\t\t\t\t\tif (stringValueIndex == -1) {", "-\t\t\t\t\t\tif (!creatingProblemType) {", "-\t\t\t\t\t\t\t// report an error and abort: will lead to a problem type classfile creation", "-\t\t\t\t\t\t\tTypeDeclaration typeDeclaration = referenceBinding.scope.referenceContext;", "-\t\t\t\t\t\t\ttypeDeclaration.scope.problemReporter().stringConstantIsExceedingUtf8Limit(defaultValue);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// already inside a problem type creation : no attribute", "-\t\t\t\t\t\t\tcontentsOffset = attributeOffset;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcontents[contentsOffset++] = (byte) (stringValueIndex >> 8);", "-\t\t\t\t\t\tcontents[contentsOffset++] = (byte) stringValueIndex;", "-\t\t\t\t\t}", "-\t\t\t}", "+\t\t\tgenerateElementValue(attributeOffset, defaultValue, constant);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e291535315a25e17fbda57d8f503195b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.tests/src/org/eclipse/jdt/apt/tests/annotations/valueconversion/ValueConversionProcessor.java", "commitBeforeChange": "a6fb7155fd890e70fc93ff099a2bfa78beffa3e9", "commitAfterChange": "dade23c0ca1cb5b996dfae1d1cfc189d06d41a6f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \t@SuppressWarnings(\"nls\") \tpublic void process()", "signatureAfterChange": " \t \t@SuppressWarnings(\"nls\") \tpublic void process()", "diff": ["-\t{", "-\t\ttry{", "-\t\t\tfinal TypeDeclaration test = _env.getTypeDeclaration(\"sample.Test\");", "-\t\t\tif( test == null )", "-\t\t\t\tTestCase.assertNotNull(\"failed to locate type 'sample.Test'\", test);", "-\t\t\t", "-\t\t\tfinal Collection<AnnotationMirror> annotations = test.getAnnotationMirrors();", "-\t\t\tfinal int numAnnotations = annotations == null ? 0 : annotations.size();", "-\t\t\tTestCase.assertEquals(\"annotation number mismatch\", 1, numAnnotations);", "-\t\t\t", "-\t\t\tfinal AnnotationMirror annotation = annotations.iterator().next();", "-\t\t\tfinal AnnotationType annotationType = annotation.getAnnotationType();", "-\t\t\t", "-\t\t\tTestCase.assertEquals(", "-\t\t\t\t\t\"annotation type mismatch\", ", "-\t\t\t\t\t\"sample.Test.Annotation\", ", "-\t\t\t\t\tannotationType.getDeclaration().getQualifiedName());", "-\t\t\t", "-\t\t\tfinal Map<AnnotationTypeElementDeclaration, AnnotationValue> elementValues =", "-\t\t\t\tannotation.getElementValues();", "-\t\t\t", "-\t\t\tfor( Map.Entry<AnnotationTypeElementDeclaration, AnnotationValue> entry : ", "-\t\t\t\t elementValues.entrySet() ){", "-\t\t\t\t", "-\t\t\t\tAnnotationTypeElementDeclaration elementDecl = entry.getKey();", "-\t\t\t\tfinal String name = elementDecl.getSimpleName();", "-\t\t\t\tfinal AnnotationValue value = entry.getValue();", "-\t\t\t\t", "-\t\t\t\tif( name.length() == 1 )", "-\t\t\t\t{", "-\t\t\t\t\tfinal Class expectedType;", "-\t\t\t\t\tswitch(name.charAt(0))", "-\t\t\t\t\t{", "-\t\t\t\t\tcase 'b':", "-\t\t\t\t\t\texpectedType = Byte.class;", "-\t\t\t\t\t\tbreak;\t\t\t\t\t", "-\t\t\t\t\tcase 'c':", "-\t\t\t\t\t\texpectedType = Character.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 's':", "-\t\t\t\t\t\texpectedType = Short.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 'i':", "-\t\t\t\t\t\texpectedType = Integer.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 'l':", "-\t\t\t\t\t\texpectedType = Long.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 'f':", "-\t\t\t\t\t\texpectedType = Float.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase 'd':", "-\t\t\t\t\t\texpectedType = Double.class;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tTestCase.assertNotNull(\"unexpected member \" + name, null);", "-\t\t\t\t\t\tthrow new IllegalStateException(); // won't get here.", "-\t\t\t\t\t}", "-\t\t\t\t\tassertValueTypeMatch(name, value.getValue(), expectedType);", "-\t\t\t\t}\t", "-\t\t\t\telse{", "-\t\t\t\t\t@SuppressWarnings(\"unused\")", "-\t\t\t\t\tfinal Class expectedElementType;", "-\t\t\t\t\tif( \"chars\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Character.class;", "-\t\t\t\t\telse if( \"bytes\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Byte.class;", "-\t\t\t\t\telse if( \"shorts\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Short.class;", "-\t\t\t\t\telse if( \"ints\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Integer.class;", "-\t\t\t\t\telse if( \"longs\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Long.class;", "-\t\t\t\t\telse if( \"floats\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Float.class;", "-\t\t\t\t\telse if( \"doubles\".equals(name) )", "-\t\t\t\t\t\texpectedElementType = Double.class;", "-\t\t\t\t\telse{", "-\t\t\t\t\t\tTestCase.assertNotNull(\"unexpected member \" + name, null);", "-\t\t\t\t\t\tthrow new IllegalStateException(); // won't get here.", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tcatch( ComparisonFailure failure ){\t\t\t", "-\t\t\tif (!ProcessorTestStatus.hasErrors()) {", "-\t\t\t\tProcessorTestStatus.failWithoutException(failure.toString());", "-\t\t\t}", "-\t\t\tthrow failure;", "-\t\t}", "-\t\tcatch( junit.framework.AssertionFailedError error ){", "-\t\t\tif (!ProcessorTestStatus.hasErrors()) {", "-\t\t\t\tProcessorTestStatus.failWithoutException(error.toString());", "-\t\t\t}", "-\t\t\tthrow error;", "-\t\t}", "-\t}", "+\t\tfinal TypeDeclaration test = _env.getTypeDeclaration(\"sample.Test\");", "+\t\tif( test == null )", "+\t\t\tTestCase.assertNotNull(\"failed to locate type 'sample.Test'\", test);", "+\t\ttestCompilerAPIPath(test);", "+\t\ttestReflectionPath(test);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f65c2a92374bf4f46e5f8c3a0502c16a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java", "commitBeforeChange": "731fe0d2952c3083dab81ac412f56109dd816295", "commitAfterChange": "b7ee6a874c851c7037f430220f1f330c599f0f24", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic static char[] getInputStreamAsCharArray(InputStream stream, int length, String encoding) \t\tthrows IOException", "signatureAfterChange": " \tpublic static char[] getInputStreamAsCharArray(InputStream stream, int length, String encoding) \t\tthrows IOException", "diff": ["+\t\tint totalRead = 0;", "-\t\t\tint contentsLength = 0;", "-\t\t\tint amountRead = -1;", "-\t\t\tdo {", "-\t\t\t\tint amountRequested = Math.max(stream.available(), DEFAULT_READING_SIZE);  // read at least 8K", "-", "-\t\t\t\t// resize contents if needed", "-\t\t\t\tif (contentsLength + amountRequested > contents.length) {", "-\t\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\t\tcontents,", "-\t\t\t\t\t\t0,", "-\t\t\t\t\t\tcontents = new char[contentsLength + amountRequested],", "-\t\t\t\t\t\t0,", "-\t\t\t\t\t\tcontentsLength);", "-\t\t\t\t}", "-", "-\t\t\t\t// read as many chars as possible", "-\t\t\t\tamountRead = reader.read(contents, contentsLength, amountRequested);", "-", "-\t\t\t\tif (amountRead > 0) {", "-\t\t\t\t\t// remember length of contents", "-\t\t\t\t\tcontentsLength += amountRead;", "-\t\t\t\t}", "-\t\t\t} while (amountRead != -1);", "-", "-\t\t\t// Do not keep first character for UTF-8 BOM encoding", "-\t\t\tint start = 0;", "-\t\t\tif (contentsLength > 0 && UTF_8.equals(encoding)) {", "-\t\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "-\t\t\t\t\tcontentsLength--;", "-\t\t\t\t\tstart = 1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// resize contents if necessary", "-\t\t\tif (contentsLength < contents.length) {", "-\t\t\t\tSystem.arraycopy(", "-\t\t\t\t\tcontents,", "-\t\t\t\t\tstart,", "-\t\t\t\t\tcontents = new char[contentsLength],", "-\t\t\t\t\t0,", "-\t\t\t\t\tcontentsLength);", "-\t\t\t}", "-\t\t\tcontents = new char[length];", "-\t\t\tint len = 0;", "-\t\t\tint readSize = 0;", "-\t\t\twhile ((readSize != -1) && (len != length)) {", "-\t\t\t\t// See PR 1FMS89U", "-\t\t\t\t// We record first the read size. In this case len is the actual read size.", "-\t\t\t\tlen += readSize;", "-\t\t\t\treadSize = reader.read(contents, len, length - len);", "-\t\t\t}", "-\t\t\t// Do not keep first character for UTF-8 BOM encoding", "-\t\t\tint start = 0;", "-\t\t\tif (length > 0 && UTF_8.equals(encoding)) {", "-\t\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "-\t\t\t\t\tlen--;", "-\t\t\t\t\tstart = 1;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// See PR 1FMS89U", "-\t\t\t// Now we need to resize in case the default encoding used more than one byte for each", "-\t\t\t// character", "-\t\t\tif (len != length)", "-\t\t\t\tSystem.arraycopy(contents, start, (contents = new char[len]), 0, len);", "+\t\t\t// length is a good guess when the encoding produces less or the same amount of characters than the file length", "+\t\t\tcontents = new char[length]; // best guess", "+\t\twhile (true) {", "+\t\t\tint amountRequested;", "+\t\t\tif (totalRead < length) {", "+\t\t\t\t// until known length is met, reuse same array sized eagerly", "+\t\t\t\tamountRequested = length - totalRead;", "+\t\t\t} else {", "+\t\t\t\t// reading beyond known length", "+\t\t\t\tint current = reader.read(); ", "+\t\t\t\tif (current < 0) break;", "+\t\t\t\t", "+\t\t\t\tamountRequested = Math.max(stream.available(), DEFAULT_READING_SIZE);  // read at least 8K", "+\t\t\t\t", "+\t\t\t\t// resize contents if needed", "+\t\t\t\tif (totalRead + 1 + amountRequested > contents.length)", "+\t\t\t\t\tSystem.arraycopy(contents, \t0, \tcontents = new char[totalRead + 1 + amountRequested], 0, totalRead);", "+\t\t\t\t", "+\t\t\t\t// add current character", "+\t\t\t\tcontents[totalRead++] = (char) current; // coming from totalRead==length", "+\t\t\t}", "+\t\t\t// read as many chars as possible", "+\t\t\tint amountRead = reader.read(contents, totalRead, amountRequested);", "+\t\t\tif (amountRead < 0) break;", "+\t\t\ttotalRead += amountRead;", "+\t\t}", "+", "+\t\t// Do not keep first character for UTF-8 BOM encoding", "+\t\tint start = 0;", "+\t\tif (totalRead > 0 && UTF_8.equals(encoding)) {", "+\t\t\tif (contents[0] == 0xFEFF) { // if BOM char then skip", "+\t\t\t\ttotalRead--;", "+\t\t\t\tstart = 1;", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// resize contents if necessary", "+\t\tif (totalRead < contents.length)", "+\t\t\tSystem.arraycopy(contents, start, contents = new char[totalRead], \t0, \ttotalRead);", "+"]}], "num": 40242}