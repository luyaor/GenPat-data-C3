{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "68577440aa501a341d6364ebe08a64b5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "026ab5cf8f6990907d96c675a673de05", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java", "commitBeforeChange": "c85c898de3099d8d87b870385bc47667302c5e21", "commitAfterChange": "73c6d3ea7dc5df8e531fcab68ea3f39bbd288577", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope)", "signatureAfterChange": " public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope)", "diff": ["-\t */", "-\tpublic void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {", "+ */", "+public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {", "+\t", "+\t// check redundant final assignments", "+\tfor (int i = 0; i < this.assignCount; i++) {", "+\t\tVariableBinding variable = this.finalVariables[i];", "+\t\tif (variable == null) continue;", "-\t\t// check redundant final assignments", "-\t\tfor (int i = 0; i < assignCount; i++) {", "-\t\t\tVariableBinding variable = finalVariables[i];", "-\t\t\tif (variable == null) continue;", "-\t\t\t", "-\t\t\tboolean complained = false; // remember if have complained on this final assignment", "-\t\t\tif (variable instanceof FieldBinding) {", "-\t\t\t\t// final field", "-\t\t\t\tif (flowInfo.isPotentiallyAssigned((FieldBinding)variable)) {", "-\t\t\t\t\tcomplained = true;", "-\t\t\t\t\tscope.problemReporter().duplicateInitializationOfBlankFinalField((FieldBinding)variable, finalAssignments[i]);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// final local variable", "-\t\t\t\tif (flowInfo.isPotentiallyAssigned((LocalVariableBinding) variable)) {", "-\t\t\t\t\tcomplained = true;", "-\t\t\t\t\tscope.problemReporter().duplicateInitializationOfFinalLocal(", "-\t\t\t\t\t\t(LocalVariableBinding) variable,", "-\t\t\t\t\t\tfinalAssignments[i]);", "-\t\t\t\t}", "+\t\tboolean complained = false; // remember if have complained on this final assignment", "+\t\tif (variable instanceof FieldBinding) {", "+\t\t\t// final field", "+\t\t\tif (flowInfo.isPotentiallyAssigned((FieldBinding)variable)) {", "+\t\t\t\tcomplained = true;", "+\t\t\t\tscope.problemReporter().duplicateInitializationOfBlankFinalField((FieldBinding)variable, finalAssignments[i]);", "-\t\t\t// any reference reported at this level is removed from the parent context ", "-\t\t\t// where it could also be reported again", "-\t\t\tif (complained) {", "-\t\t\t\tFlowContext currentContext = parent;", "-\t\t\t\twhile (currentContext != null) {", "-\t\t\t\t\t//if (currentContext.isSubRoutine()) {", "-\t\t\t\t\tcurrentContext.removeFinalAssignmentIfAny(finalAssignments[i]);", "-\t\t\t\t\t//}", "-\t\t\t\t\tcurrentContext = currentContext.parent;", "-\t\t\t\t}", "+\t\t} else {", "+\t\t\t// final local variable", "+\t\t\tif (flowInfo.isPotentiallyAssigned((LocalVariableBinding) variable)) {", "+\t\t\t\tcomplained = true;", "+\t\t\t\tscope.problemReporter().duplicateInitializationOfFinalLocal(", "+\t\t\t\t\t(LocalVariableBinding) variable,", "+\t\t\t\t\tthis.finalAssignments[i]);", "-\t\t", "-\t\t// check inconsistent null checks", "-\t\tfor (int i = 0; i < nullCount; i++) {", "-\t\t\tExpression expression = nullReferences[i];", "-\t\t\tif (expression == null) continue;", "-\t\t\t// final local variable", "-\t\t\tLocalVariableBinding local = expression.localVariableBinding();", "-\t\t\tswitch (nullStatus[i]) {", "-\t\t\t\tcase FlowInfo.NULL :", "-\t\t\t\t\tif (flowInfo.isDefinitelyNull(local)) {", "-\t\t\t\t\t\tnullReferences[i] = null;", "-\t\t\t\t\t\tthis.parent.recordUsingNullReference(scope, local, expression, nullStatus[i], flowInfo);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase FlowInfo.NON_NULL :", "-\t\t\t\t\tif (flowInfo.isDefinitelyNonNull(local)) {", "-\t\t\t\t\t\tnullReferences[i] = null;", "-\t\t\t\t\t\tthis.parent.recordUsingNullReference(scope, local, expression, nullStatus[i], flowInfo);", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "+\t\t// any reference reported at this level is removed from the parent context ", "+\t\t// where it could also be reported again", "+\t\tif (complained) {", "+\t\t\tFlowContext currentContext = this.parent;", "+\t\t\twhile (currentContext != null) {", "+\t\t\t\t//if (currentContext.isSubRoutine()) {", "+\t\t\t\tcurrentContext.removeFinalAssignmentIfAny(this.finalAssignments[i]);", "+\t\t\t\t//}", "+\t\t\t\tcurrentContext = currentContext.parent;", "+\t", "+\t// check inconsistent null checks", "+\tif (this.deferNullDiagnostic) { // within an enclosing loop, be conservative", "+\t\tfor (int i = 0; i < this.nullCount; i++) {", "+\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\tLocalVariableBinding local = this.nullLocals[i];", "+\t\t\tswitch (this.nullCheckTypes[i]) {", "+\t\t\t\tcase CAN_ONLY_NULL_NON_NULL :", "+\t\t\t\tcase CAN_ONLY_NULL:", "+\t\t\t\t\tif (flowInfo.isProtectedNonNull(local)) {", "+\t\t\t\t\t\tif (nullCheckTypes[i] == CAN_ONLY_NULL_NON_NULL) {", "+\t\t\t\t\t\t\tscope.problemReporter().localVariableCannotBeNull(local, expression);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (flowInfo.isProtectedNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableCanOnlyBeNull(local, expression);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase MAY_NULL :", "+\t\t\t\t\tif (flowInfo.isProtectedNonNull(local)) {", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (flowInfo.isProtectedNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableCanOnlyBeNull(local, expression);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\t// never happens", "+\t\t\t}", "+\t\t\tthis.parent.recordUsingNullReference(scope, local, expression, ", "+\t\t\t\t\tthis.nullCheckTypes[i], flowInfo);", "+\t\t}", "+\t}", "+\telse { // no enclosing loop, be as precise as possible right now", "+\t\tfor (int i = 0; i < this.nullCount; i++) {", "+\t\t\tExpression expression = this.nullReferences[i];", "+\t\t\t// final local variable", "+\t\t\tLocalVariableBinding local = this.nullLocals[i];", "+\t\t\tswitch (this.nullCheckTypes[i]) {", "+\t\t\t\tcase CAN_ONLY_NULL_NON_NULL :", "+\t\t\t\t\tif (flowInfo.isDefinitelyNonNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableCannotBeNull(local, expression);\t\t\t\t", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\tcase CAN_ONLY_NULL:", "+\t\t\t\t\tif (flowInfo.isDefinitelyNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableCanOnlyBeNull(local, expression);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase MAY_NULL :", "+\t\t\t\t\tif (flowInfo.isDefinitelyNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableCanOnlyBeNull(local, expression);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (flowInfo.isPotentiallyNull(local)) {", "+\t\t\t\t\t\tscope.problemReporter().localVariableMayBeNull(local, expression);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\t// should not happen", "+\t\t\t}", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb7e8af762e424be5aa3b9caab32fd0a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "c7e61e314902d7cf48e71c1a1c0437bb40107c2e", "commitAfterChange": "8a1621e802c664e59aba36b8a87f59ae57902e37", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\t\tif ((sourceMethod.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\tlong nullBits = sourceMethod.tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\tif (nullBits == TagBits.AnnotationNullMASK) {", "-\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TagBits.AnnotationNullMASK; // avoid secondary problems", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (nullBits != 0 && sourceMethod.isConstructor()) {", "+\t\t\t\t\t\t\tif (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)", "+\t\t\t\t\t\t\t\tscope.problemReporter().nullAnnotationUnsupportedLocation(this);", "+\t\t\t\t\t\t\t// for declaration annotations the inapplicability will be reported below", "+\t\t\t\t\t\t\tsourceMethod.tagBits &= ~TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t// fields don't yet have their type resolved, in 1.8 null annotations", "+\t\t\t\t\t\t// will be transfered from the field to its type during STB.resolveTypeFor().", "-\t\t\t\t\t\tvariable.tagBits |= tagBits;", "+\t\t\t\t\t\tif ((annotationType.tagBits & TagBits.AnnotationTargetMASK) == TagBits.AnnotationForTypeUse) {", "+\t\t\t\t\t\t\tif (variable.type != null) {", "+\t\t\t\t\t\t\t\tif (variable.type.isBaseType()) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().illegalAnnotationForBaseType(this, variable.type);", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tlong nullTagBits = tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t\tvariable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);", "+\t\t\t\t\t\t\t\t\tif ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\t\tvariable.type.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {", "+\t\t\t\t\t\t\t\tvariable.tagBits |= tagBits;", "+\t\t\t\t\t\t\t\tif ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\tvariable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else if (variable.type != null) {", "+\t\t\t\t\t\t\t\t// bits not relating to null analysis go into the variable:", "+\t\t\t\t\t\t\t\tvariable.tagBits |= tagBits & ~TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t// null bits go into the type:", "+\t\t\t\t\t\t\t\tlong nullTagBits = tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\tif (nullTagBits != 0) {", "+\t\t\t\t\t\t\t\t\tvariable.type = scope.environment().pushAnnotationIntoType(variable.type, variable.declaration.type, nullTagBits);", "+\t\t\t\t\t\t\t\t\tif ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "+\t\t\t\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "+\t\t\t\t\t\t\t\t\t\tvariable.type = variable.type.unannotated();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif ((variable.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {", "-\t\t\t\t\t\t\tscope.problemReporter().contradictoryNullAnnotations(this);", "-\t\t\t\t\t\t\tvariable.tagBits &= ~TAGBITS_NULLABLE_OR_NONNULL; // avoid secondary problems"]}], "num": 33157}