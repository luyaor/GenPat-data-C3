{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bc4ac364aa0eee5cd5e23c7cd77b517b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cd26ce022484a18558be546137db6a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "c2258f3a34b02ad7356115c6022b2790f990bcd4", "commitAfterChange": "b114726e6672732b572036987107a1d4de90980d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tthis.actualReceiverType = this.receiver.resolveType(scope); ", "+\tboolean receiverCast = false, argsContainCast = false; ", "+\tif (this.receiver instanceof CastExpression) {", "+\t\tthis.receiver.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\treceiverCast = true;", "+\t}", "+\tthis.actualReceiverType = receiver.resolveType(scope); ", "+\tif (receiverCast && this.actualReceiverType != null) {", "+\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "+\t\tif (((CastExpression)this.receiver).expression.resolvedType == this.actualReceiverType) { ", "+\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "+\t\t}", "+\t}", "+\t// resolve type arguments (for generic constructor call)", "+\tif (this.typeArguments != null) {", "+\t\tint length = this.typeArguments.length;", "+\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\treturn null;", "+\t\t}", "+\t}", "-\t\tfor (int i = 0; i < length; i++)", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\targsContainCast = true;", "+\t\t\t}", "-\t\tif (argHasError)", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\tif(actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "+\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)actualReceiverType, selector, new TypeBinding[]{}, this);", "+\t\t\t}\t\t\t", "+\t\t}", "-\tif (this.actualReceiverType == null) ", "+\tif (this.actualReceiverType == null) {", "-", "+\t}", "-\t\tif (this.receiver instanceof NameReference) {", "-\t\t\tif ((((NameReference) this.receiver).bits & Binding.TYPE) != 0) {", "-\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\t\t\t\treturn null;", "+\t\tif (receiver instanceof NameReference ", "+\t\t\t\t&& (((NameReference) receiver).bits & Binding.TYPE) != 0) {", "+\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\t} else {", "+\t\t\t// compute generic cast if necessary", "+\t\t\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "+\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeErasingTo((ReferenceBinding)this.binding.declaringClass.erasure());", "+\t\t\t\tif (match == null) {", "+\t\t\t\t\tthis.actualReceiverType = this.binding.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t}", "+\t\t\treceiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "-\tif (this.arguments != null)", "-\t\tfor (int i = 0; i < this.arguments.length; i++)", "-\t\t\tthis.arguments[i].computeConversion(scope, this.binding.parameters[i], argumentTypes[i]);", "+\tcheckInvocationArguments(scope, this.receiver, actualReceiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "-\tif (this.binding.isAbstract()) {", "-\t\tif (this.receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\t\t\treturn null;", "+\tif (binding.isAbstract()) {", "+\t\tif (receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "-\tif (isMethodUseDeprecated(this.binding, scope))", "-\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\tif (isMethodUseDeprecated(binding, scope))", "+\t\tscope.problemReporter().deprecatedMethod(binding, this);", "-\treturn this.resolvedType = this.binding.returnType;", "+\t// from 1.5 compliance on, array#clone() returns the array type (but binding still shows Object)", "+\tif (actualReceiverType.isArrayType() ", "+\t\t\t&& this.binding.parameters == NoParameters ", "+\t\t\t&& scope.compilerOptions().complianceLevel >= JDK1_5 ", "+\t\t\t&& CharOperation.equals(this.binding.selector, CLONE)) {", "+\t\tthis.resolvedType = actualReceiverType;", "+\t} else {", "+\t\tTypeBinding returnType = this.binding.returnType;", "+\t\tif (returnType != null) returnType = returnType.capture(scope, this.sourceEnd);", "+\t\tthis.resolvedType = returnType;", "+\t}", "+\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "afbc76f8b01ef7f91ea259a5bea633c6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-", "-\tthis.constant = Constant.NotAConstant;", "-\tboolean receiverCast = false, argsContainCast = false;", "-\tif (this.receiver instanceof CastExpression) {", "-\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\treceiverCast = true;", "-\t}", "-\tthis.actualReceiverType = this.receiver.resolveType(scope);", "-\tif (receiverCast && this.actualReceiverType != null) {", "-\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "-\t\tif (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {", "-\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);", "+\t", "+\tif (this.constant != Constant.NotAConstant) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\tboolean receiverCast = false;", "+\t\tif (this.receiver instanceof CastExpression) {", "+\t\t\tthis.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\treceiverCast = true;", "-\t}", "-\t// resolve type arguments (for generic constructor call)", "-\tif (this.typeArguments != null) {", "-\t\tint length = this.typeArguments.length;", "-\t\tboolean argHasError = false; // typeChecks all arguments", "-\t\tthis.genericTypeArguments = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\targHasError = true;", "+\t\tthis.actualReceiverType = this.receiver.resolveType(scope);", "+\t\tif (receiverCast && this.actualReceiverType != null) {", "+\t\t\t// due to change of declaring class with receiver type, only identity cast should be notified", "+\t\t\tif (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {", "+\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);", "-\t\tif (argHasError) {", "+\t\t// resolve type arguments (for generic constructor call)", "+\t\tif (this.typeArguments != null) {", "+\t\t\tint length = this.typeArguments.length;", "+\t\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\targHasError = true;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\t// will check for null after args are resolved", "+\t\tif (this.arguments != null) {", "+\t\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\t\tint length = this.arguments.length;", "+\t\t\tthis.argumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tthis.argsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "+\t\t\t\tif ((this.argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "+\t\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\tif(this.actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "+\t\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);", "+\t\t\t\t}", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\tif (this.actualReceiverType == null) {", "+\t\t\treturn null;", "+\t\t}", "+\t\t// base type cannot receive any message", "+\t\tif (this.actualReceiverType.isBaseType()) {", "+\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\t// will check for null after args are resolved", "-\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "-\tif (this.arguments != null) {", "-\t\tboolean argHasError = false; // typeChecks all arguments", "-\t\tint length = this.arguments.length;", "-\t\targumentTypes = new TypeBinding[length];", "-\t\tTypeBinding argumentType;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression argument = this.arguments[i];", "-\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\targsContainCast = true;", "-\t\t\t}", "-\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\tif ((argumentType = argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)", "-\t\t\t\targHasError = true;", "-\t\t\tif (argumentType != null && argumentType.kind() == Binding.POLY_TYPE) {", "-\t\t\t\tif (this.innerInferenceHelper == null)", "-\t\t\t\t\tthis.innerInferenceHelper = new InnerInferenceHelper();", "-\t\t\t}", "-\t\t}", "-\t\tif (argHasError) {", "-\t\t\tif(this.actualReceiverType instanceof ReferenceBinding) {", "-\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);", "-\t\t\t}", "-\t\t\treturn null;", "-\t\t}", "-\t}", "-\tif (this.actualReceiverType == null) {", "-\t\treturn null;", "-\t}", "-\t// base type cannot receive any message", "-\tif (this.actualReceiverType.isBaseType()) {", "-\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "-\t\treturn null;", "-\t}", "-", "-\tfindMethodBinding(scope, argumentTypes);", "+\tfindMethodBinding(scope);", "-\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, argumentTypes, this)", "-\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, argumentTypes, this);", "+\t\t\t\t\t? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, this.argumentTypes, this)", "+\t\t\t\t\t: localScope.getMethod(this.delegateThis.type, this.selector, this.argumentTypes, this);", "-\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "+\t\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);", "+\t\t\t\t\tscope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);", "-\tif (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "+\tif (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {"]}], "num": 48824}