{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e961c69f850afbc12620c3c60dd7b23e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fbc813f358f88a18c9a537d302964f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\tboolean isExactMatch = true;", "-\t\t\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\t\t\t\t\t\tisExactMatch = false;", "+\t\t\t\t\t\tif (methodBinding == null)", "-\t\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (!isExactMatch) {", "-\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t// likely not a match in the first place, 2 cases are possible", "-\t\t\t\t\t\t\t\t\t\t// first is when methodBinding was found thru inheritance starting from an nested type - in this case do not want to search outer scope", "-\t\t\t\t\t\t\t\t\t\t// second is when normal search turned up only this selector match so NotFound is expected", "-\t\t\t\t\t\t\t\t\t\t// except in 1.5 when static import methods can match correctly", "-\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {", "-\t\t\t\t\t\t\t\t\t\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 && !receiverType.isNestedType()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak; // need to search for static import method matches", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, ProblemReasons.NotVisible);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "+\t\t\t\t\t\t\t\tif (!methodBinding.isStatic()) {", "-\t", "-\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "-\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "-\t\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+", "+\t\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != Binding.NO_METHODS", "+\t\t\t\t\t\t\t\t\t\t|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn foundFuzzyProblem;", "+\t\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "-\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tfuzzyProblem = methodBinding;", "+\t\t\t\t\t\t\t}", "+", "+\t\t\t\t\t\t\tif (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)", "+\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)", "-\t\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t", "+\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\tProblemReasons.InheritedNameHidesEnclosingName);", "+", "+\t\tif (foundFuzzyProblem != null)", "+\t\t\tif (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)", "+\t\t\t\treturn foundFuzzyProblem;", "+\t\tif (foundInsideProblem != null)", "+\t\t\treturn foundInsideProblem;", "+", "+\t\t\tif (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)", "+\t\t\t\treturn foundFuzzyProblem; // static imports lose to methods from Object", "+", "-\t\t\t\tMethodBinding[] visible = null;", "+\t\t\t\tObjectVector visible = null;", "-\t\t\t\t\t\tif (possible != null && possible != foundMethod) {", "+\t\t\t\t\t\tif (possible != null && possible != foundFuzzyProblem) {", "-\t\t\t\t\t\t\t\tif (foundMethod == null)", "-\t\t\t\t\t\t\t\t\tfoundMethod = possible; // answer as error case match", "+\t\t\t\t\t\t\t\tif (foundFuzzyProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = possible; // answer as error case match", "-\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "-\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || !foundMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\tif (!importBinding.onDemand && foundMethod.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t\t\tskipOnDemand = true;", "-\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\tif (visible == null || !visible.contains(compatibleMethod)) {", "+\t\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t} else if (visible == null) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new MethodBinding[] {foundMethod, compatibleMethod};", "-\t\t\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tint visibleLength = visible.length;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleLength + 1];", "-\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(visible, 0, temp, 0, visibleLength);", "-\t\t\t\t\t\t\t\t\t\t\t\t\ttemp[visibleLength] = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = temp;", "+\t\t\t\t\t\t\t\t\t\t\t\tif (visible == null)", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new ObjectVector(3);", "+\t\t\t\t\t\t\t\t\t\t\t\tvisible.add(compatibleMethod);", "-\t\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\t\t\t\t\t\t} else if (foundFuzzyProblem == null) {", "+\t\t\t\t\t\t\t\t\tfoundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);", "-\t\t\t\tif (visible != null)", "-\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(visible, visible.length, argumentTypes, invocationSite, null);", "-\t\t\t}", "-\t\t\tif (foundMethod != null) {", "-\t\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "-\t\t\t\treturn foundMethod;", "+\t\t\t\tif (visible != null) {", "+\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visible.size];", "+\t\t\t\t\tvisible.copyInto(temp);", "+\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);", "+\t\t\t\t}", "+\t\tif (foundMethod != null) {", "+\t\t\tinvocationSite.setActualReceiverType(foundMethod.declaringClass);", "+\t\t\treturn foundMethod;", "+\t\t}", "-\t\tif (foundInsideProblem != null)", "-\t\t\treturn foundInsideProblem;", "-\t\tif (foundMethod != null)", "-\t\t\treturn foundMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e6c1d84ced1386f1a1ec0faa926e259", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "f5a6b32f5440a6dc40e1353ed6c94f89e64c1de3", "commitAfterChange": "53dd39a8862ca5242dbb932ca83dc2b678997664", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "signatureAfterChange": " public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved)", "diff": ["-\tboolean primitive = false;", "-\tchar primitiveSig = ' ';", "-\tint index = 0;", "+\tint arrayCount = CharOperation.occurencesOf('[', typeName);", "+\tchar[] sig;", "-\t// primitive type?", "-\tswitch (typeName[index]) {", "+\tswitch (typeName[0]) {", "+\t\t// primitive type?", "-\t\t\tif (CharOperation.fragmentEquals(BOOLEAN, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_BOOLEAN;", "-\t\t\t\tindex += BOOLEAN.length;\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(BOOLEAN, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_BOOLEAN;", "-\t\t\t} else if (CharOperation.fragmentEquals(BYTE, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_BYTE;", "-\t\t\t\tindex += BYTE.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\t} else if (CharOperation.fragmentEquals(BYTE, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_BYTE;", "-\t\t\tif (CharOperation.fragmentEquals(CHAR, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_CHAR;", "-\t\t\t\tindex += CHAR.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(CHAR, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_CHAR;", "-\t\t\tif (CharOperation.fragmentEquals(DOUBLE, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_DOUBLE;", "-\t\t\t\tindex += DOUBLE.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(DOUBLE, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_DOUBLE;", "-\t\t\tif (CharOperation.fragmentEquals(FLOAT, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_FLOAT;", "-\t\t\t\tindex += FLOAT.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(FLOAT, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_FLOAT;", "-\t\t\tif (CharOperation.fragmentEquals(INT, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_INT;", "-\t\t\t\tindex += INT.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(INT, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_INT;", "-\t\t\tif (CharOperation.fragmentEquals(LONG, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_LONG;", "-\t\t\t\tindex += LONG.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(LONG, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_LONG;", "-\t\t\tif (CharOperation.fragmentEquals(SHORT, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_SHORT;", "-\t\t\t\tindex += SHORT.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(SHORT, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_SHORT;", "-\t\t\tif (CharOperation.fragmentEquals(VOID, typeName, index, true)) {", "-\t\t\t\tprimitiveSig = C_VOID;", "-\t\t\t\tindex += SHORT.length;\t\t\t\t", "-\t\t\t\tprimitive = true;\t\t\t", "+\t\t\tif (CharOperation.fragmentEquals(VOID, typeName, 0, true)) {", "+\t\t\t\tsig = new char[arrayCount+1];", "+\t\t\t\tsig[arrayCount] = C_VOID;", "+\t\t\t}", "+\t\tdefault:", "+\t\t\t// non primitive type", "+\t\t\tint sigLength = arrayCount + 1 + length + 1; // e.g. '[[[Ljava.lang.String;'", "+\t\t\tsig = new char[sigLength];", "+\t\t\tint sigIndex = arrayCount+1; // index in sig", "+\t\t\tint startID = 0; // start of current ID in typeName", "+\t\t\tint index = 0; // index in typeName", "+\t\t\twhile (index < length) {", "+\t\t\t\tchar currentChar = typeName[index];", "+\t\t\t\tswitch (currentChar) {", "+\t\t\t\t\tcase '.':", "+\t\t\t\t\t\tif (startID == -1) throw new IllegalArgumentException(new String(typeName));", "+\t\t\t\t\t\tif (startID < index) {", "+\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tsig[sigIndex++] = C_DOT;", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\tstartID = index;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase '[':", "+\t\t\t\t\t\tif (startID != -1) {", "+\t\t\t\t\t\t\tif (startID < index) {", "+\t\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tstartID = -1; // no more id after []", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault :", "+\t\t\t\t\t\tif (startID != -1 && CharOperation.isWhitespace(currentChar)) {", "+\t\t\t\t\t\t\tif (startID < index) {", "+\t\t\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\t\t\t\t\tsigIndex += index-startID;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tstartID = index+1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// last id", "+\t\t\tif (startID != -1 && startID < index) {", "+\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "+\t\t\t\tsigIndex += index-startID;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// add L (or Q) at the beigininig and ; at the end", "+\t\t\tsig[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;", "+\t\t\tsig[sigIndex++] = C_NAME_END;", "+\t\t\t", "+\t\t\t// resize if needed", "+\t\t\tif (sigLength > sigIndex) {", "+\t\t\t\tSystem.arraycopy(sig, 0, sig = new char[sigIndex], 0, sigIndex);", "-\t// non primitive type and array count", "-\tchar[] sig = primitive ? null : new char[length];", "-\tint sigIndex = 0;", "-\tint arrayCount = 0;", "-\tint startID = primitive ? -1 : 0;", "-\twhile (index < length) {", "-\t\tchar currentChar = typeName[index];", "-\t\tswitch (currentChar) {", "-\t\t\tcase '.':", "-\t\t\t\tif (startID == -1) throw new IllegalArgumentException(new String(typeName));", "-\t\t\t\tif (startID < index) {", "-\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t}", "-\t\t\t\tint sigLength = sig.length;", "-\t\t\t\tif (sigIndex >= sigLength) {", "-\t\t\t\t\tSystem.arraycopy(sig, 0, sig = new char[sigLength*2], 0, sigLength);", "-\t\t\t\t}", "-\t\t\t\tsig[sigIndex++] = C_DOT;", "-\t\t\t\tindex++;", "-\t\t\t\tstartID = index;", "-\t\t\t\tbreak;", "-\t\t\tcase '[':", "-\t\t\t\tarrayCount++;", "-\t\t\t\tif (startID != -1) {", "-\t\t\t\t\tif (startID < index) {", "-\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t\t}", "-\t\t\t\t\tstartID = -1; // no more id after []", "-\t\t\t\t}", "-\t\t\t\tindex++;", "-\t\t\t\tbreak;", "-\t\t\tdefault :", "-\t\t\t\tif (startID != -1 && CharOperation.isWhitespace(currentChar)) {", "-\t\t\t\t\tif (startID < index) {", "-\t\t\t\t\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\t\t\t\t\tsigIndex += index-startID;", "-\t\t\t\t\t}", "-\t\t\t\t\tstartID = index+1;", "-\t\t\t\t}", "-\t\t\t\tindex++;", "-\t\t\t\tbreak;", "-\t\t}", "-\t}", "-\t// last id", "-\tif (startID != -1 && startID < index) {", "-\t\tsig = CharOperation.append(sig, sigIndex, typeName, startID, index);", "-\t\tsigIndex += index-startID;", "+\t// add array info", "+\tfor (int i = 0; i < arrayCount; i++) {", "+\t\tsig[i] = C_ARRAY;", "-\t// build result", "-\tchar[] result;", "-\tif (primitive) {", "-\t\tresult = new char[arrayCount+1];", "-\t\tresult[arrayCount] = primitiveSig;", "-\t} else {", "-\t\tint resultLength = arrayCount + 1 + sigIndex + 1; // e.g. '[[[Ljava.lang.String;'", "-\t\tresult = new char[resultLength];", "-\t\tSystem.arraycopy(sig, 0, result, arrayCount + 1, sigIndex);", "-\t\tresult[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;", "-\t\tresult[resultLength-1] = C_NAME_END;", "-\t}", "-\tfor (int i = 0; i < arrayCount; i++) {", "-\t\tresult[i] = C_ARRAY;", "-\t}", "-\treturn result;", "+\treturn sig;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5fda1fbaed0095a15dc3d1bd0c33aae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java", "commitBeforeChange": "7065da01531bf4c318c59206b62aa1503a948abe", "commitAfterChange": "0d303c13e0085d7aef9947e46f37c617f206a066", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprivate static AbstractMethodDeclaration convert(ISourceMethod sourceMethod, CompilationResult compilationResult)", "signatureAfterChange": " \tprivate CompilationUnitDeclaration convert( \t\tISourceType[] sourceTypes, \t\tboolean needFieldsAndMethods, \t\tboolean needMemberTypes, \t\tCompilationResult compilationResult)", "diff": ["+\t */", "+\tprivate CompilationUnitDeclaration convert(", "+\t\tISourceType[] sourceTypes,", "+\t\tboolean needFieldsAndMethods,", "+\t\tboolean needMemberTypes,", "+\t\tCompilationResult compilationResult) {", "+\t\tthis.unit = new CompilationUnitDeclaration(problemReporter, compilationResult, 0);", "+\t\t\tthis.unit.currentPackage =", "+\t\tthis.unit.imports = new ImportReference[importCount];", "+\t\t\tthis.unit.imports[i] = createImportReference(importNames[i], start, end);", "+\t\tthis.unit.types = new TypeDeclaration[typeCount];", "+\t\t\tthis.unit.types[i] =", "+\t\treturn this.unit;", "-\tprivate static AbstractMethodDeclaration convert(ISourceMethod sourceMethod, CompilationResult compilationResult) {"]}], "num": 3024}