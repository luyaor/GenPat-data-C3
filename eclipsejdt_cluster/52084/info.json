{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "78d43ebe8d9848524b986385eed678f0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "88c7151f2a20c80a064adbae0ab292b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTParser.java", "commitBeforeChange": "1ffd93ec138fc38a22c082921b3ee25a9e75ba37", "commitAfterChange": "cef21f9db5e181946eac0a0d175b10763094848c", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 19, "signatureBeforeChange": " \t \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "signatureAfterChange": " \t \tprivate ASTNode internalCreateAST(IProgressMonitor monitor)", "diff": ["-\t\t\t\t\tIJavaElement element = null;", "-\t\t\t\t\tif (this.compilationUnitSource != null) {", "-\t\t\t\t\t\t/*", "-\t\t\t\t\t\t * this.compilationUnitSource is an instance of org.eclipse.jdt.internal.core.CompilationUnit that implements", "-\t\t\t\t\t\t * both org.eclipse.jdt.core.ICompilationUnit and org.eclipse.jdt.internal.compiler.env.ICompilationUnit", "-\t\t\t\t\t\t */ ", "-\t\t\t\t\t\tsourceUnit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) this.compilationUnitSource;", "-\t\t\t\t\t\t/*", "-\t\t\t\t\t\t * use a BasicCompilation that caches the source instead of using the compilationUnitSource directly", "-\t\t\t\t\t\t * (if it is a working copy, the source can change between the parse and the AST convertion)", "-\t\t\t\t\t\t * (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=75632)", "-\t\t\t\t\t\t */", "-\t\t\t\t\t\tsourceUnit = new BasicCompilationUnit(sourceUnit.getContents(), sourceUnit.getPackageName(), new String(sourceUnit.getFileName()), this.project);", "-\t\t\t\t\t\telement = this.compilationUnitSource;", "-\t\t\t\t\t} else if (this.classFileSource != null) {", "+\t\t\t\t\tWorkingCopyOwner wcOwner = this.workingCopyOwner;", "+\t\t\t\t\tif (this.typeRoot instanceof ICompilationUnit) {", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t * this.compilationUnitSource is an instance of org.eclipse.jdt.internal.core.CompilationUnit that implements", "+\t\t\t\t\t\t\t * both org.eclipse.jdt.core.ICompilationUnit and org.eclipse.jdt.internal.compiler.env.ICompilationUnit", "+\t\t\t\t\t\t\t */ ", "+\t\t\t\t\t\t\tsourceUnit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) this.typeRoot;", "+\t\t\t\t\t\t\t/*", "+\t\t\t\t\t\t\t * use a BasicCompilation that caches the source instead of using the compilationUnitSource directly", "+\t\t\t\t\t\t\t * (if it is a working copy, the source can change between the parse and the AST convertion)", "+\t\t\t\t\t\t\t * (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=75632)", "+\t\t\t\t\t\t\t */", "+\t\t\t\t\t\t\tsourceUnit = new BasicCompilationUnit(sourceUnit.getContents(), sourceUnit.getPackageName(), new String(sourceUnit.getFileName()), this.project);", "+\t\t\t\t\t\t\twcOwner = ((ICompilationUnit) this.typeRoot).getOwner();", "+\t\t\t\t\t} else if (this.typeRoot instanceof IClassFile) {", "-\t\t\t\t\t\t\tString sourceString = this.classFileSource.getSource();", "+\t\t\t\t\t\t\tString sourceString = this.typeRoot.getSource();", "-\t\t\t\t\t\t\tPackageFragment packageFragment = (PackageFragment) this.classFileSource.getParent();", "-\t\t\t\t\t\t\tBinaryType type = (BinaryType) this.classFileSource.getType();", "+\t\t\t\t\t\t\tPackageFragment packageFragment = (PackageFragment) this.typeRoot.getParent();", "+\t\t\t\t\t\t\tBinaryType type = (BinaryType) this.typeRoot.findPrimaryType();", "-\t\t\t\t\t\t\telement = this.classFileSource;", "-\t\t\t\t\t\tthis.compilationUnitSource == null ? this.workingCopyOwner : this.compilationUnitSource.getOwner(),", "+\t\t\t\t\t\twcOwner,", "-\t\t\t\t\tresult.setJavaElement(element);", "+\t\t\t\t\tresult.setTypeRoot(this.typeRoot);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d903ce4c18a8c60c4e16df2b357d9ad6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "b93a217fe6b68aa2016c37812b125d5d097ba1a3", "commitAfterChange": "1beaef02926dace59f07acb73879fd00f7c0b3eb", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": "  protected void checkAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requiredType, Expression expression, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  protected void checkAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requiredType, Expression expression, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+\tif (expression instanceof ConditionalExpression && expression.isPolyExpression()) {", "+\t\t// drill into both branches using existing nullStatus per branch:", "+\t\tConditionalExpression ce = (ConditionalExpression) expression;", "+\t\tinternalCheckAgainstNullTypeAnnotation(scope, requiredType, ce.valueIfTrue, ce.ifTrueNullStatus, flowContext);", "+\t\tinternalCheckAgainstNullTypeAnnotation(scope, requiredType, ce.valueIfFalse, ce.ifFalseNullStatus, flowContext);", "+\t\treturn;", "+\t}", "+\tinternalCheckAgainstNullTypeAnnotation(scope, requiredType, expression, nullStatus, flowContext);", "+}"]}], "num": 52084}