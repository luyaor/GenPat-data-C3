{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a8760cb8bcd33b9d5207cbc3ce2a6205", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "02a3a12f1943e82adcfca53f1dbf8920", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/ClasspathTests.java", "commitBeforeChange": "7878f4c2228c677604ec88f1859c6284007a67ac", "commitAfterChange": "1cebc3fd53a475c41ac0b2d0681333cea8569134", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void testMissingLibrary() throws JavaModelException", "signatureAfterChange": " \t \tpublic void testMissingLibrary2() throws JavaModelException", "diff": ["-\tpublic void testMissingLibrary() throws JavaModelException {", "-\t\tenv.addClass(root, \"p1\", \"Test1\", //$NON-NLS-1$ //$NON-NLS-2$", "-\t\tenv.addClass(root, \"p2\", \"Test2\", //$NON-NLS-1$ //$NON-NLS-2$", "+\t", "+\tpublic void testMissingLibrary2() throws JavaModelException {", "+\t\tIPath projectPath = env.addProject(\"Project\"); //$NON-NLS-1$", "+\t\tenv.removePackageFragmentRoot(projectPath, \"\"); //$NON-NLS-1$", "+\t\tIPath root = env.addPackageFragmentRoot(projectPath, \"src\"); //$NON-NLS-1$", "+\t\tIPath bin = env.setOutputFolder(projectPath, \"bin\"); //$NON-NLS-1$", "+\t\tIPath classTest1 = env.addClass(root, \"p1\", \"Test1\", //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t\"package p1;\\n\"+ //$NON-NLS-1$", "+\t\t\t\"public class Test1 {}\" //$NON-NLS-1$", "+\t\t);", "+\t\tIPath classTest2 = env.addClass(root, \"p2\", \"Test2\", //$NON-NLS-1$ //$NON-NLS-2$", "-\t\texpectingOnlyProblemsFor(new IPath[] {projectPath, classTest3});", "-\t\texpectingOnlySpecificProblemsFor(projectPath,", "-\t\t\tnew Problem[] {", "-\t\t\t\tnew Problem(\"\", \"The project was not built since its classpath is incomplete. Cannot find the class file for java.lang.Object. Fix the classpath then try rebuilding this project.\", projectPath), //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\tnew Problem(\"p2\", \"This compilation unit indirectly references the missing type java.lang.Object (typically some required class file is referencing a type outside the classpath)\", classTest3) //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t}", "-\t\t);", "+\t\texpectingSpecificProblemFor(", "+\t\t\tprojectPath,", "+\t\t\tnew Problem(\"\", \"The project was not built since its classpath is incomplete. Cannot find the class file for java.lang.Object. Fix the classpath then try rebuilding this project.\", projectPath)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t", "+\t\tProblem[] prob1 = env.getProblemsFor(classTest1);", "+\t\tProblem[] prob2 = env.getProblemsFor(classTest2);", "+\t\tProblem[] prob3 = env.getProblemsFor(classTest3);", "+\t\tassertEquals(\"too much problems\", prob1.length + prob2.length + prob3.length,1);", "+\t\tif(prob1.length == 1) {", "+\t\t\texpectingSpecificProblemFor(classTest1, new Problem(\"p1\", \"This compilation unit indirectly references the missing type java.lang.Object (typically some required class file is referencing a type outside the classpath)\", classTest1)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t} else if (prob2.length == 1) {", "+\t\t\texpectingSpecificProblemFor(classTest2, new Problem(\"p2\", \"This compilation unit indirectly references the missing type java.lang.Object (typically some required class file is referencing a type outside the classpath)\", classTest2)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t} else {", "+\t\t\texpectingSpecificProblemFor(classTest3, new Problem(\"p2\", \"This compilation unit indirectly references the missing type java.lang.Object (typically some required class file is referencing a type outside the classpath)\", classTest3)); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "11ea8dab8d137e004b92744c1d30e76a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 56, "methodNumberAfterChange": 86, "signatureBeforeChange": " protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "diff": ["- */", "-protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException {", "-", "-\t// create buffer -  compilation units only use default buffer factory", "-\tBufferManager bufManager = getBufferManager();", "-\tIBuffer buffer = getBufferFactory().createBuffer(this);", "-\tif (buffer == null) return null;", "-\t", "-\t// set the buffer source", "-\tif (buffer.getCharacters() == null){", "-\t\tIFile file = (IFile)this.getResource();", "-\t\tif (file == null || !file.exists()) throw newNotPresentException();", "-\t\tbuffer.setContents(Util.getResourceContentsAsCharArray(file));", "-\t}", "-", "-\t// add buffer to buffer cache", "-\tbufManager.addBuffer(buffer);", "-\t\t\t", "-\t// listen to buffer changes", "-\tbuffer.addBufferChangedListener(this);", "-\t", "-\treturn buffer;", "-}", "+ */", "+protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException {", "+", "+\t// create buffer", "+\tboolean isWorkingCopy = info instanceof WorkingCopyElementInfo;", "+\tIBuffer buffer = ", "+\t\tisWorkingCopy ", "+\t\t\t? this.owner.createBuffer(this) ", "+\t\t\t: BufferManager.getDefaultBufferManager().createBuffer(this);", "+\tif (buffer == null) return null;", "+\t", "+\t// set the buffer source", "+\tif (buffer.getCharacters() == null) {", "+\t\tif (isWorkingCopy) {", "+\t\t\tICompilationUnit original = new CompilationUnit((IPackageFragment)getParent(), getElementName(), DefaultCompilationUnitOwner.PRIMARY);", "+\t\t\tif (original.isOpen()) {", "+\t\t\t\tbuffer.setContents(original.getSource());", "+\t\t\t} else {", "+\t\t\t\tIFile file = (IFile)original.getResource();", "+\t\t\t\tif (file == null || !file.exists()) {", "+\t\t\t\t\t// initialize buffer with empty contents", "+\t\t\t\t\tbuffer.setContents(CharOperation.NO_CHAR);", "+\t\t\t\t} else {", "+\t\t\t\t\tbuffer.setContents(Util.getResourceContentsAsCharArray(file));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tIFile file = (IFile)this.getResource();", "+\t\t\tif (file == null || !file.exists()) throw newNotPresentException();", "+\t\t\tbuffer.setContents(Util.getResourceContentsAsCharArray(file));", "+\t\t}", "+\t}", "+", "+\t// add buffer to buffer cache", "+\tBufferManager bufManager = getBufferManager();", "+\tbufManager.addBuffer(buffer);", "+\t\t\t", "+\t// listen to buffer changes", "+\tbuffer.addBufferChangedListener(this);", "+\t", "+\treturn buffer;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16dcfd5a4a4d26f7f3d4099e6ef36861", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "067d4c602423adaae99e87247cc8cdbc112437d7", "commitAfterChange": "57396a418c2c0c112a60b670e887da389156bc9b", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "-\t\t\t\t\t&& scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "+\t\t\t\t\t&& compilerOptions.getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {", "-\t\t\t&& scope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_5 ", "+\t\t\t&& compilerOptions.complianceLevel >= ClassFileConstants.JDK1_5 ", "+\tif (receiver.isSuper() && compilerOptions.getSeverity(CompilerOptions.OverridingMethodWithoutSuperInvocation) != ProblemSeverities.Ignore) {", "+\t\tfinal ReferenceContext referenceContext = scope.methodScope().referenceContext;", "+\t\tif (referenceContext instanceof AbstractMethodDeclaration) {", "+\t\t\tfinal AbstractMethodDeclaration abstractMethodDeclaration = (AbstractMethodDeclaration) referenceContext;", "+\t\t\tMethodBinding enclosingMethodBinding = abstractMethodDeclaration.binding;", "+\t\t\tif (enclosingMethodBinding.isOverriding()", "+\t\t\t\t\t&& CharOperation.equals(this.binding.selector, enclosingMethodBinding.selector)", "+\t\t\t\t\t&& this.binding.areParametersEqual(enclosingMethodBinding)) {", "+\t\t\t\tabstractMethodDeclaration.bits |= ASTNode.OverridingMethodWithSupercall;", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f75eac9a9abbdf316d417c7c1ca33a2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tprivate boolean detectCycle( \t\tSourceTypeBinding sourceType, \t\tReferenceBinding superType, \t\tTypeReference reference)", "signatureAfterChange": " \tprivate boolean detectCycle(SourceTypeBinding sourceType, ReferenceBinding superType, TypeReference reference)", "diff": ["-\tprivate boolean detectCycle(", "-\t\tSourceTypeBinding sourceType,", "-\t\tReferenceBinding superType,", "-\t\tTypeReference reference) {", "+\tprivate boolean detectCycle(SourceTypeBinding sourceType, ReferenceBinding superType, TypeReference reference) {", "+\t\tif (superType.isRawType())", "+\t\t\tsuperType = ((RawTypeBinding) superType).type;", "+", "+\t\t}", "+", "+\t\tif (superType.isMemberType()) {", "+\t\t\tReferenceBinding current = superType.enclosingType();", "+\t\t\tdo {", "+\t\t\t\tif (current.isHierarchyBeingConnected()) {", "+\t\t\t\t\tproblemReporter().hierarchyCircularity(sourceType, current, reference);", "+\t\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\tcurrent.tagBits |= HierarchyHasProblems;", "+\t\t\t\t\treturn true;", "+\t\t\t\t}", "+\t\t\t} while ((current = current.enclosingType()) != null);", "-\t\t\t\thasCycle |= detectCycle(sourceType, superType.superclass(), reference);", "-\t\t\t\tif ((superType.superclass().tagBits & HierarchyHasProblems) != 0) {", "+\t\t\t\tReferenceBinding parentType = superType.superclass();", "+\t\t\t\tif (parentType.isParameterizedType())", "+\t\t\t\t\tparentType = ((ParameterizedTypeBinding) parentType).type;", "+\t\t\t\thasCycle |= detectCycle(sourceType, parentType, reference);", "+\t\t\t\tif ((parentType.tagBits & HierarchyHasProblems) != 0) {", "-\t\t\t\t\tsuperType.tagBits |= HierarchyHasProblems; // propagate down the hierarchy", "+\t\t\t\t\tparentType.tagBits |= HierarchyHasProblems; // propagate down the hierarchy", "+\t\t\t\t\tif (anInterface.isParameterizedType())", "+\t\t\t\t\t\tanInterface = ((ParameterizedTypeBinding) anInterface).type;", "-\t\tif ((superType.tagBits & EndHierarchyCheck) == 0", "-\t\t\t&& (superType.tagBits & BeginHierarchyCheck) != 0) {", "+\t\tif (superType.isHierarchyBeingConnected()) {"]}], "num": 14181}