{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b8ec75cf118f227e081f2ac6f833f6d0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "12901ca58731950abce971cea9f85cd1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java", "commitBeforeChange": "0271031e5844c32df2646c3a81a2c00b29e7d251", "commitAfterChange": "14c82497ad7236bee9eedf2d9ff4867e4a47ff21", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": " private AstNode[] nodesInRange(int start, int end, Map set)", "signatureAfterChange": " private void purgeMethodStatements(TypeDeclaration type, boolean checkEachMethod)", "diff": ["-private AstNode[] nodesInRange(int start, int end, Map set) {", "-\t// collect nodes in the given range", "-\tArrayList nodes = new ArrayList();", "-\tfor (Iterator keys = set.keySet().iterator(); keys.hasNext();) {", "-\t\tAstNode node = (AstNode)keys.next();", "-\t\tif (start <= node.sourceStart && node.sourceEnd <= end) {", "-\t\t\tAstNode node1 = (AstNode) o1;", "-\t\t\tAstNode node2 = (AstNode) o2;", "-\t\t\treturn node1.sourceStart - node2.sourceStart;", "-\t\t", "+private void purgeMethodStatements(TypeDeclaration type, boolean checkEachMethod) {", "+\tAbstractMethodDeclaration[] methods = type.methods;", "+\tif (methods != null) {", "+\t\tif (checkEachMethod) {", "+\t\t\tfor (int j = 0, k = methods.length; j < k; j++) {", "+\t\t\t\tAbstractMethodDeclaration method = methods[j];", "+\t\t\t\tif (!hasPotentialNodes(method.declarationSourceStart, method.declarationSourceEnd))", "+\t\t\t\t\tmethod.statements = null;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfor (int j = 0, k = methods.length; j < k; j++)", "+\t\t\t\tmethods[j].statements = null;", "+\t\t}", "+\t}", "+", "+\tMemberTypeDeclaration[] memberTypes = type.memberTypes;", "+\tif (memberTypes != null) {", "+\t\tfor (int i = 0, l = memberTypes.length; i < l; i++) {", "+\t\t\tTypeDeclaration memberType = memberTypes[i];", "+\t\t\tboolean alsoHasMatchingMethods = checkEachMethod &&", "+\t\t\t\thasPotentialNodes(memberType.declarationSourceStart, memberType.declarationSourceEnd);", "+\t\t\tpurgeMethodStatements(memberType, alsoHasMatchingMethods);", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60753b78bce8bb3641402c390d47cd5c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "d4a90dd90535197bda12b521c603853c2f8eb60c", "commitAfterChange": "d473849794f95ce2b5cbae060ffe683ee81ff056", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 34, "signatureBeforeChange": " private void purgeMethodStatements(TypeDeclaration type, MatchingNodeSet nodeSet, boolean checkEachMethod)", "signatureAfterChange": " private void purgeMethodStatements(TypeDeclaration type, boolean checkEachMethod)", "diff": ["+private void purgeMethodStatements(TypeDeclaration type, boolean checkEachMethod) {", "+\tcheckEachMethod = checkEachMethod", "+\t\t&& this.currentPossibleMatch.nodeSet.hasPossibleNodes(type.declarationSourceStart, type.declarationSourceEnd);", "+\tAbstractMethodDeclaration[] methods = type.methods;", "+\tif (methods != null) {", "+\t\tif (checkEachMethod) {", "+\t\t\tfor (int j = 0, k = methods.length; j < k; j++) {", "+\t\t\t\tAbstractMethodDeclaration method = methods[j];", "+\t\t\t\tif (!this.currentPossibleMatch.nodeSet.hasPossibleNodes(method.declarationSourceStart, method.declarationSourceEnd))", "+\t\t\t\t\tmethod.statements = null;", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfor (int j = 0, k = methods.length; j < k; j++)", "+\t\t\t\tmethods[j].statements = null;", "+\t\t}", "+\t}", "+", "+\tMemberTypeDeclaration[] memberTypes = type.memberTypes;", "+\tif (memberTypes != null)", "+\t\tfor (int i = 0, l = memberTypes.length; i < l; i++)", "+\t\t\tpurgeMethodStatements(memberTypes[i], checkEachMethod);", "+}", "-private void purgeMethodStatements(TypeDeclaration type, MatchingNodeSet nodeSet, boolean checkEachMethod) {", "-\tcheckEachMethod = checkEachMethod && nodeSet.hasPossibleNodes(type.declarationSourceStart, type.declarationSourceEnd);", "-\tAbstractMethodDeclaration[] methods = type.methods;", "-\tif (methods != null) {", "-\t\tif (checkEachMethod) {", "-\t\t\tfor (int j = 0, k = methods.length; j < k; j++) {", "-\t\t\t\tAbstractMethodDeclaration method = methods[j];", "-\t\t\t\tif (!nodeSet.hasPossibleNodes(method.declarationSourceStart, method.declarationSourceEnd))", "-\t\t\t\t\tmethod.statements = null;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tfor (int j = 0, k = methods.length; j < k; j++)", "-\t\t\t\tmethods[j].statements = null;", "-\t\t}", "-\t}", "-", "-\tMemberTypeDeclaration[] memberTypes = type.memberTypes;", "-\tif (memberTypes != null)", "-\t\tfor (int i = 0, l = memberTypes.length; i < l; i++)", "-\t\t\tpurgeMethodStatements(memberTypes[i], nodeSet, checkEachMethod);", "-}"]}], "num": 63210}