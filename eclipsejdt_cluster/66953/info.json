{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bf7c7feca723dd72768773a8eaf1b5db", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4f309940f0b01a8d4d58b5885ee3946d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "9d0a10f56589d65d04aaea495d852ef502b02233", "commitAfterChange": "913c08568caa0adfd1165460a3e2394884803092", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type)", "signatureAfterChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "diff": ["-protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type) {", "+protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes) {", "-\tif (level != IMPOSSIBLE_MATCH) return level;", "+\tif (level != IMPOSSIBLE_MATCH) {", "+\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t}", "+\t\treturn level;", "+\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass());", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, type.superclass(), argumentTypes);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (argumentTypes != null) {", "+\t\t\t\t// need to verify if method may be overridden", "+\t\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "+\t\t\t\tfor (int i=0, length=methods.length; i<length; i++) {", "+\t\t\t\t\tMethodBinding method = methods[i];", "+\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "+\t\t\t\t\tif (argumentTypes.length == parameters.length) {", "+\t\t\t\t\t\tboolean found = true;", "+\t\t\t\t\t\tfor (int j=0,l=parameters.length; j<l; j++) {", "+\t\t\t\t\t\t\tif (parameters[j].erasure() != argumentTypes[j].erasure()) {", "+\t\t\t\t\t\t\t\tfound = false;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (found) { // one method match in hierarchy", "+\t\t\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "+\t\t\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "+\t\t\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "+\t\t\t\t\t\t\t\t// store the fact that the method is overridden", "+\t\t\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}", "-\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i]);", "-\t\tif (level != IMPOSSIBLE_MATCH) return level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\tlevel = resolveLevelAsSubtype(qualifiedPattern, interfaces[i], null);", "+\t\tif (level != IMPOSSIBLE_MATCH) {", "+\t\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "+\t\t\t}", "+\t\t\treturn level | SUB_INVOCATION_FLAVOR; // add flavor to returned level", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c66039ac2367fbb40d5e869eab4c1061", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java", "commitBeforeChange": "3edfc82342658662e3a25a41e35742d4e6f8a5e9", "commitAfterChange": "605cc5dd745b7e1d6935bfc34c1be6fcea51b4ab", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "signatureAfterChange": " protected int resolveLevelAsSubtype(char[] qualifiedPattern, ReferenceBinding type, TypeBinding[] argumentTypes)", "diff": ["-\t\tif (!type.isAbstract() && !type.isInterface()) { // if concrete class, then method is overridden", "+\t\tMethodBinding method = argumentTypes == null ? null : getMethodBinding(type, argumentTypes);", "+\t\tif (((method != null && !method.isAbstract()) || !type.isAbstract()) && !type.isInterface()) { // if concrete, then method is overridden", "-\t\t\t\tMethodBinding[] methods = type.getMethods(this.pattern.selector);", "-\t\t\t\tfor (int i=0, length=methods.length; i<length; i++) {", "-\t\t\t\t\tMethodBinding method = methods[i];", "-\t\t\t\t\tTypeBinding[] parameters = method.parameters;", "-\t\t\t\t\tif (argumentTypes.length == parameters.length) {", "-\t\t\t\t\t\tboolean found = true;", "-\t\t\t\t\t\tfor (int j=0,l=parameters.length; j<l; j++) {", "-\t\t\t\t\t\t\tif (parameters[j].erasure() != argumentTypes[j].erasure()) {", "-\t\t\t\t\t\t\t\tfound = false;", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (found) { // one method match in hierarchy", "-\t\t\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "-\t\t\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "-\t\t\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "-\t\t\t\t\t\t\t\t// store the fact that the method is overridden", "-\t\t\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\tMethodBinding method = getMethodBinding(type, argumentTypes);", "+\t\t\t\tif (method != null) { // one method match in hierarchy", "+\t\t\t\t\tif ((level & OVERRIDDEN_METHOD_FLAVOR) != 0) {", "+\t\t\t\t\t\t// this method is already overridden on a super class, current match is impossible", "+\t\t\t\t\t\treturn IMPOSSIBLE_MATCH;", "+\t\t\t\t\t}", "+\t\t\t\t\tif (!method.isAbstract() && !type.isInterface()) {", "+\t\t\t\t\t\t// store the fact that the method is overridden", "+\t\t\t\t\t\tlevel |= OVERRIDDEN_METHOD_FLAVOR;"]}], "num": 66953}