{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "09b124702b5e09f71180e666fad67bc7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0866d3ebba625cd4dfd04f1667ed8976", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java", "commitBeforeChange": "bb7b9521196186c5be108c1f350a453c12233137", "commitAfterChange": "871cac4ba4cecfc6322ce0af5777177652a514a9", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \t@Override \tpublic boolean visit(SwitchStatement node)", "signatureAfterChange": "  \t@Override \tpublic boolean visit(SwitchStatement node)", "diff": ["+\t\tList<Statement> statements = node.statements();", "-\t\t\tint openBraceIndex = this.tm.firstIndexIn(node, TokenNameLBRACE);", "-\t\t\tthis.tm.get(openBraceIndex + 1).indent();", "-\t\t\tint closeBraceIndex = this.tm.lastIndexIn(node, TokenNameRBRACE);", "-\t\t\tthis.tm.get(closeBraceIndex).unindent();", "+\t\t\tint nonBreakStatementEnd = -1;", "+\t\t\tfor (Statement statement : statements) {", "+\t\t\t\tif (statement instanceof SwitchCase) {", "+\t\t\t\t\tif (nonBreakStatementEnd >= 0) {", "+\t\t\t\t\t\t// indent only comments between previous and current statement", "+\t\t\t\t\t\tthis.tm.get(nonBreakStatementEnd + 1).indent();", "+\t\t\t\t\t\tthis.tm.firstTokenIn(statement, -1).unindent();", "+\t\t\t\t\t}", "+\t\t\t\t} else if (!(statement instanceof BreakStatement || statement instanceof Block)) {", "+\t\t\t\t\tindent(statement);", "+\t\t\t\t}", "+\t\t\t\tnonBreakStatementEnd = (statement instanceof BreakStatement || statement instanceof ReturnStatement)", "+\t\t\t\t\t\t? -1 : this.tm.lastIndexIn(statement, -1);", "+\t\t\t}", "+\t\t\tif (nonBreakStatementEnd >= 0) {", "+\t\t\t\t// indent comments between last statement and closing brace ", "+\t\t\t\tthis.tm.get(nonBreakStatementEnd + 1).indent();", "+\t\t\t\tthis.tm.lastTokenIn(node, TokenNameRBRACE).unindent();", "+\t\t\t}", "+\t\t}", "+\t\tif (this.options.indent_breaks_compare_to_cases) {", "+\t\t\tfor (Statement statement : statements) {", "+\t\t\t\tif (statement instanceof BreakStatement)", "+\t\t\t\t\tindent(statement);", "+\t\t\t}", "-\t\tboolean isBreakStatement = false;", "-\t\tList<Statement> statements = node.statements();", "-\t\t\tif (isBreakStatement) // actually, was break statement", "-\t\t\t\tthis.tm.firstTokenIn(statement, -1).indent();", "-\t\t\tisBreakStatement = statement instanceof BreakStatement;", "-\t\t\tif (this.options.indent_switchstatements_compare_to_cases", "-\t\t\t\t\t&& (isBreakStatement || statement instanceof SwitchCase || statement instanceof Block)) {", "-\t\t\t\tunindent(statement);", "-\t\t\t}", "-\t\t\tif (isBreakStatement) {", "-\t\t\t\tif (this.options.indent_breaks_compare_to_cases)", "-\t\t\t\t\tindent(statement);", "-\t\t\t\tthis.tm.firstTokenAfter(statement, -1).unindent();", "-\t\t\t}", "-\t\tif (isBreakStatement) // actually, was break statement", "-\t\t\tthis.tm.lastTokenIn(node, -1).indent();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "096ba91f599a5cb5905c7dfb44ee9a1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, Scope scope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope)", "diff": ["-\tpublic boolean isCompatibleWith(TypeBinding left, Scope scope) {", "-\t\tif (this.binding != null && this.binding.isValidBinding() // binding indicates if full resolution has already happened", "-\t\t\t\t&& this.resolvedType != null && this.resolvedType.isValidBinding()) {", "-\t\t\treturn this.resolvedType.isCompatibleWith(left, scope);", "-\t\t}", "+\tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope) {", "+\t\tReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "+\t\tif (copy != null)", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "+\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tfinal MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\tboolean isCompatible;", "-\t\tsetExpectedType(left);", "-\t\t\tthis.binding = null;", "-\t\t\tthis.trialResolution = true;", "-\t\t\tthis.binding = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(left) : null;", "-\t\t\tif (this.binding == null) {", "-\t\t\t\tresolveType(this.enclosingScope);", "-\t\t\t\tregisterResult(left, this.binding);", "+\t\t\tcopy = copy();", "+\t\t\tif (copy == null) { // should never happen even for code assist.", "+\t\t\t\treturn false;", "+\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\tcopy.setExpectedType(targetType);", "+\t\t\tcopy.resolveType(this.enclosingScope);", "+\t\t\tregisterCopy(targetType, copy);", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "-\t\t\tisCompatible = this.binding != null && this.binding.isValidBinding();", "-\t\t\tthis.binding = null;", "-\t\t\tsetExpectedType(null);", "-\t\t\tthis.trialResolution = false;", "-\t\treturn isCompatible;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09c6b4c6e9d4c42b4c726dd00b27a2fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment, boolean recurseInContainers)", "signatureAfterChange": " \tpublic static IJavaModelStatus validateClasspathEntry(IJavaProject project, IClasspathEntry entry, boolean checkSourceAttachment, boolean recurseInContainers)", "diff": ["-\t\tString entryPathMsg = pathStartsWithProject ? path.removeFirstSegments(1).toString() : path.makeRelative().toString();", "+\t\tString entryPathMsg = pathStartsWithProject ? path.removeFirstSegments(1).makeRelative().toString() : path.toString();", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalVariablePath\", path.makeRelative().toString(), projectName));\t\t\t\t\t //$NON-NLS-1$", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalVariablePath\", entryPathMsg, projectName));\t\t\t\t\t //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.makeRelative().toString(), path.makeRelative().toString(), projectName})); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.toString(), path.toString(), projectName})); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\treturn  new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.makeRelative().toString(), path.makeRelative().toString(), projectName})); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\treturn  new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.toString(), path.toString(), projectName})); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\treturn  new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.toString(), path.makeRelative().toString(), projectName})); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\treturn  new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundSourceAttachment\", new String [] {sourceAttachment.toString(), path.toOSString(), projectName})); //$NON-NLS-1$", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundLibrary\", path.makeRelative().toString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\t\tboolean isExternal = path.getDevice() != null || !workspaceRoot.getProject(path.segment(0)).exists();", "+\t\t\t\t\t\tif (isExternal) {", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundLibrary\", path.toOSString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundLibrary\", entryPathMsg, projectName)); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalLibraryPath\", path.makeRelative().toString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalLibraryPath\", entryPathMsg, projectName)); //$NON-NLS-1$", "-\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundProject\", path.makeRelative().segment(0).toString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundProject\", path.segment(0), projectName)); //$NON-NLS-1$", "-\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.closedProject\", path.segment(0).toString())); //$NON-NLS-1$", "+\t\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.closedProject\", path.segment(0))); //$NON-NLS-1$", "-\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundProject\", path.segment(0).toString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.unboundProject\", path.segment(0), projectName)); //$NON-NLS-1$", "-\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalProjectPath\", path.segment(0).toString(), projectName)); //$NON-NLS-1$", "+\t\t\t\t\treturn new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind(\"classpath.illegalProjectPath\", path.segment(0), projectName)); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0bbdc44851b594296a2afce9a4bd8b2b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "eedafe9176d5ca60193623550822839844fd4aae", "commitAfterChange": "16a0328cb89c7e4d508e8edfc85e1af4879c13c7", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic void computePackageFragmentRoots( \t\tIClasspathEntry resolvedEntry, \t\tObjectVector accumulatedRoots,  \t\tHashSet rootIDs,  \t\tboolean insideOriginalProject, \t\tboolean checkExistency, \t\tboolean retrieveExportedRoots) throws JavaModelException", "signatureAfterChange": " \tpublic void computePackageFragmentRoots( \t\tIClasspathEntry resolvedEntry, \t\tObjectVector accumulatedRoots,  \t\tHashSet rootIDs,  \t\tIClasspathEntry referringEntry, \t\tboolean checkExistency, \t\tboolean retrieveExportedRoots, \t\tMap rootToResolvedEntries) throws JavaModelException", "diff": ["-\t\tboolean insideOriginalProject,", "+\t\tIClasspathEntry referringEntry,", "-\t\tboolean retrieveExportedRoots) throws JavaModelException {", "+\t\tboolean retrieveExportedRoots,", "+\t\tMap rootToResolvedEntries) throws JavaModelException {", "+\t\tIPackageFragmentRoot root = null;", "-\t\t\t\t\t\t\taccumulatedRoots.add(", "-\t\t\t\t\t\t\t\tgetPackageFragmentRoot((IResource)target));", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "+\t\t\t\t\t\t\troot = getPackageFragmentRoot((IResource)target);", "-\t\t\t\t\t\tIPackageFragmentRoot root = getFolderPackageFragmentRoot(entryPath);", "-\t\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\troot = getFolderPackageFragmentRoot(entryPath);", "-\t\t\t\tif (!insideOriginalProject && !resolvedEntry.isExported()) return;", "+\t\t\t\tif (referringEntry != null  && !resolvedEntry.isExported()) return;", "-\t\t\t\t\t\tIResource resource = (IResource) target;", "-\t\t\t\t\t\tIPackageFragmentRoot root = getPackageFragmentRoot(resource);", "-\t\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\troot = getPackageFragmentRoot((IResource) target);", "-\t\t\t\t\t\t\taccumulatedRoots.add(", "-\t\t\t\t\t\t\t\tnew JarPackageFragmentRoot(entryPath, this));", "-\t\t\t\t\t\t\trootIDs.add(rootID);", "+\t\t\t\t\t\t\troot = new JarPackageFragmentRoot(entryPath, this);", "-\t\t\t\t\tIPackageFragmentRoot root = getPackageFragmentRoot(entryPath);", "-\t\t\t\t\tif (root != null) {", "-\t\t\t\t\t\taccumulatedRoots.add(root);", "-\t\t\t\t\t\trootIDs.add(rootID);", "-\t\t\t\t\t}", "+\t\t\t\t\troot = getPackageFragmentRoot(entryPath);", "-\t\t\t\tif (!insideOriginalProject && !resolvedEntry.isExported()) return;", "+\t\t\t\tif (referringEntry != null && !resolvedEntry.isExported()) return;", "-\t\t\t\t\t\t\tfalse, ", "+\t\t\t\t\t\t\trootToResolvedEntries == null ? resolvedEntry : ((ClasspathEntry)resolvedEntry).combineWith(referringEntry), // only combine if need to build the reverse map ", "-\t\t\t\t\t\t\tretrieveExportedRoots);", "+\t\t\t\t\t\t\tretrieveExportedRoots,", "+\t\t\t\t\t\t\trootToResolvedEntries);", "+\t\t}", "+\t\tif (root != null) {", "+\t\t\taccumulatedRoots.add(root);", "+\t\t\trootIDs.add(rootID);", "+\t\t\tif (rootToResolvedEntries != null) rootToResolvedEntries.put(root, ((ClasspathEntry)resolvedEntry).combineWith(referringEntry));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "683947e3048a6a1388c3a7e4fa718ece", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java", "commitBeforeChange": "4c2a905aadc81c8c888c5fc5a111e98f871b85f1", "commitAfterChange": "2837bd360df1c376bc39df62191694b92b14b919", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate boolean checkAnnotations()", "signatureAfterChange": " \tprivate boolean checkNegative2()", "diff": ["-\tprivate boolean checkAnnotations() {", "+\t */", "+\tprivate boolean checkNegative2() {", "+\t\tList<? extends Element> enclosedElements = _elementN2.getEnclosedElements();", "+\t\tfor (Element element : enclosedElements) {", "+\t\t\tString name = element.getSimpleName().toString();", "+\t\t\tif (\"m1\".equals(name)) {", "+\t\t\t\tAnnotationMirror am2 = findAnnotation(element, \"Anno2\");", "+\t\t\t\tif (_reportFailingCases && null == am2) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno2 on method Negative2.m1\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m2\".equals(name)) {", "+\t\t\t\tAnnotationMirror am1 = findAnnotation(element, \"Anno1\");", "+\t\t\t\tif (_reportFailingCases && null == am1) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno1 on method Negative2.m2\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tAnnotationMirror am3 = findAnnotation(element, \"FakeAnno3\");", "+\t\t\t\tif (_reportFailingCases && null == am3) {", "+\t\t\t\t\treportError(\"Couldn't find annotation FakeAnno3 on method Negative2.m2\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m3\".equals(name)) {", "+\t\t\t\tAnnotationMirror am2 = findAnnotation(element, \"Anno2\");", "+\t\t\t\tif (_reportFailingCases && null == am2) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno2 on method Negative2.m3\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tAnnotationMirror am3 = findAnnotation(element, \"FakeAnno3\");", "+\t\t\t\tif (_reportFailingCases && null == am3) {", "+\t\t\t\t\treportError(\"Couldn't find annotation FakeAnno3 on method Negative2.m3\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (\"m4\".equals(name)) {", "+\t\t\t\tAnnotationMirror am4 = findAnnotation(element, \"Anno4\");", "+\t\t\t\tif (_reportFailingCases && null == am4) {", "+\t\t\t\t\treportError(\"Couldn't find annotation Anno4 on method Negative2.m4\");", "+\t\t\t\t\treturn false;", "+\t\t\t\t}", "+\t\t\t\tMap<? extends ExecutableElement, ? extends AnnotationValue> values = am4.getElementValues();", "+\t\t\t\tfor (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : values.entrySet()) {", "+\t\t\t\t\tif (\"value\".equals(entry.getKey().getSimpleName().toString())) {", "+\t\t\t\t\t\tString value = entry.getValue().getValue().toString();", "+\t\t\t\t\t\tif (!\"123\".equals(value) && !\"<error>\".equals(value)) {", "+\t\t\t\t\t\t\treportError(\"Unexpected value for Anno4 on Negative1.s1: \" + value);", "+\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn true;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91ec2fd63e54f2874539d86f63a08c10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "148d909d5d1bb379a215402c9ae6d0c2993ad9d1", "commitAfterChange": "918eef64ca6418a800e340287b8f92eb641467b8", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 73, "signatureBeforeChange": " \tpublic boolean visit(IfStatement ifStatement, BlockScope scope)", "signatureAfterChange": " \tpublic boolean visit(IfStatement ifStatement, BlockScope scope)", "diff": ["-\t\t\t\t\tif (elseStatement == null || this.preferences.insert_new_line_in_control_statements) {", "-\t\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tif (elseStatement != null && this.preferences.insert_new_line_in_control_statements) {", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t\tif (elseStatement != null) {", "+\t\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t\t}", "-\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t\tif (elseStatement != null) {", "+\t\t\t\t\tthis.scribe.printNewLine();", "+\t\t\t\t}", "-\t\t\tthis.scribe.printTrailingComment();", "+\t\t\tif (this.preferences.insert_new_line_in_control_statements) {", "+\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t}", "-\t\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\t\tthis.scribe.printTrailingComment();", "+\t\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printNewLine();", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printTrailingComment();", "-\t\t\t\tthis.scribe.printNewLine();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ba0089ffef7c6dbd75d5f645bc16f1b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java", "commitBeforeChange": "c1214b6b7704c3bec1f1750c6983e09a52efaa01", "commitAfterChange": "a5f15775fe7fcb24ae5a0930116a996c10a2359a", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\t\t\t\tif (parameter.isTypeVariable()) {", "-\t\t\t\t\t\tbuffer.append(parameter.getQualifiedName());", "-\t\t\t\t\t} else if (parameter.isArray() && parameter.getElementType().isTypeVariable()) {", "-\t\t\t\t\t\tint dimensions = parameter.getDimensions();", "-\t\t\t\t\t\tbuffer.append(parameter.getElementType().getQualifiedName());", "-\t\t\t\t\t\tfor (int j = 0; j < dimensions; j++) {", "-\t\t\t\t\t\t\tbuffer.append('[').append(']');", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tbuffer.append(parameter.getKey());", "-\t\t\t\t\t\tbuffer.append(',');", "-\t\t\t\t\t}", "+\t\t\t\t\taddParameterKey(buffer, parameter);", "+\t\t\t\t\tbuffer.append(',');", "-\t\t\tthis.key = String.valueOf(buffer);", "+\t\t\tITypeBinding[] types = getTypeParameters();", "+\t\t\tif (types.length > 0) {", "+\t\t\t\tbuffer.append('<');", "+\t\t\t\tfor (int i = 0, max = types.length; i < max; i++) {", "+\t\t\t\t\tITypeBinding typeParameter = types[i];", "+\t\t\t\t\taddParameterKey(buffer, typeParameter);", "+\t\t\t\t\tITypeBinding[] bounds = ((TypeBinding) typeParameter).getTypeBounds();", "+\t\t\t\t\tfor (int j = 0, length = bounds.length; j < length; j++) {", "+\t\t\t\t\t\tITypeBinding bound = bounds[j];", "+\t\t\t\t\t\tbuffer.append(':');", "+\t\t\t\t\t\taddParameterKey(buffer, bound);", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('>');", "+\t\t\t}", "+\t\t\tthis.key = buffer.toString();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fcd437a47abe81afa001f73c413b8661", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "81c62d5935a591fe4cf87abbebf09e04755572ce", "commitAfterChange": "18c9ee28439dc99049f5f8ecbf6109b62307dc52", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tprivate void verifyTypeReference(Expression reference, Scope scope, boolean source15, ReferenceBinding resolvedType)", "signatureAfterChange": "  \tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers)", "diff": ["-\tprivate void verifyTypeReference(Expression reference, Scope scope, boolean source15, ReferenceBinding resolvedType) {", "+\tprivate void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers) {", "+", "+\t\t\t// reference must have enough visibility to be used", "+\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, modifiers)) {", "+//\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\tscope.problemReporter().javadocHiddenReference(typeReference.sourceStart, reference.sourceEnd, scope, modifiers);", "+\t\t\t\treturn;", "+\t\t\t}", "+", "+\t\t\t// type reference must have enough visibility to be used", "+\t\t\tif (reference != typeReference) {", "+\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType.modifiers)) {", "+//\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "+\t\t\t\t\tscope.problemReporter().javadocHiddenReference(typeReference.sourceStart, typeReference.sourceEnd, scope, resolvedType.modifiers);", "+\t\t\t\t\treturn;", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "+\t\t\t\t\tif (typeReference instanceof JavadocSingleTypeReference) {", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\treturn;", "-\t\t\t\t\t} else if (reference instanceof JavadocQualifiedTypeReference) {", "-\t\t\t\t\t\tJavadocQualifiedTypeReference qualifiedTypeReference = (JavadocQualifiedTypeReference) reference;", "+\t\t\t\t\t}", "+\t\t\t\t\t/*", "+\t\t\t\t\tif (typeReference instanceof JavadocQualifiedTypeReference) {", "+\t\t\t\t\t\tJavadocQualifiedTypeReference qualifiedTypeReference = (JavadocQualifiedTypeReference) typeReference;", "-\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\tscope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);", "+\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t*/", "-\t\t\t}", "-", "-\t\t\t// reference must have enough visibility to be used", "-\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "-\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);"]}], "num": 29832}