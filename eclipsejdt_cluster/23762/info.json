{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ada4f0b0c527aadc2eb0d3073e416f76", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "24db879ab3e8bf057c14c4e8d9a26b7b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java", "commitBeforeChange": "bb161cc0f24c88013c90d4f52d2200284e6436fc", "commitAfterChange": "2f5fd18c93661c661012397a8eb704f52a56558d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, final Openable openable)", "signatureAfterChange": " \tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable)", "diff": ["-\tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, final Openable openable) {", "+\tpublic IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable) {", "-\t\t\tIJavaElement currentElement = openable;", "-\t\t\tHashSet knownElements = new HashSet();", "+\t\t    ASTNode[] nodeStack = new ASTNode[10];", "+\t\t    int nodeIndex = -1;", "+\t\t    public void push(ASTNode node) {", "+\t\t        try {", "+\t\t            this.nodeStack[++this.nodeIndex] = node;", "+\t\t        } catch (IndexOutOfBoundsException e) {", "+\t\t            System.arraycopy(this.nodeStack, 0, this.nodeStack = new ASTNode[this.nodeStack.length*2], 0, this.nodeIndex-1);", "+\t\t            this.nodeStack[this.nodeIndex] = node;", "+\t\t        }", "+\t\t    }", "+\t\t    ", "+\t\t    public void pop(ASTNode node) {", "+\t\t    \twhile (this.nodeIndex >= 0 && this.nodeStack[this.nodeIndex--] != node);", "+\t\t    }", "+\t\t    ", "-\t\t\t\tif (node == toBeFound) {", "-\t\t\t\t\tcurrentElement = ", "-\t\t\t\t\t\tnew LocalVariable(", "-\t\t\t\t\t\t\t(JavaElement)currentElement, ", "-\t\t\t\t\t\t\tnew String(node.name), ", "-\t\t\t\t\t\t\tnode.declarationSourceStart,", "-\t\t\t\t\t\t\tnode.declarationSourceEnd,", "-\t\t\t\t\t\t\tnode.sourceStart,", "-\t\t\t\t\t\t\tnode.sourceEnd,", "-\t\t\t\t\t\t\tUtil.typeSignature(node.type));", "-\t\t\t\t\t// NB: no need to update occurence count as the variable is defined by its positions", "-\t\t\t\t\tthrow new EndVisit();", "-\t\t\t\t}", "+\t\t\t    push(node);", "+\t\t\t\tif (node == toBeFound) throw new EndVisit();", "+\t\t\tpublic void endVisit(Argument node, BlockScope scope) {", "+\t\t\t    pop(node);", "+            }", "-\t\t\t\tcurrentElement = ", "-\t\t\t\t\t((IType)currentElement).getMethod(", "-\t\t\t\t\t\tcurrentElement.getElementName(), ", "-\t\t\t\t\t\tUtil.typeParameterSignatures(node));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\t\tcurrentElement = ((IType)currentElement).getField(new String(node.name));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t    pop(node);", "-\t\t\t\tcurrentElement = updateOccurenceCount(((IType)currentElement).getInitializer(1));", "+\t\t\t    push(node);", "-\t\t\tpublic void endVisit(Initializer node, MethodScope scope) {", "-\t\t\t\tcurrentElement = currentElement.getParent();", "-\t\t\t}", "+\t\t\t// don't pop initializers (used to count how many occurrences are in the type)", "-\t\t\t\tif (node == toBeFound) {", "-\t\t\t\t\tcurrentElement = ", "-\t\t\t\t\t\tnew LocalVariable(", "-\t\t\t\t\t\t\t(JavaElement)currentElement, ", "-\t\t\t\t\t\t\tnew String(node.name), ", "-\t\t\t\t\t\t\tnode.declarationSourceStart,", "-\t\t\t\t\t\t\tnode.declarationSourceEnd,", "-\t\t\t\t\t\t\tnode.sourceStart,", "-\t\t\t\t\t\t\tnode.sourceEnd,", "-\t\t\t\t\t\t\tUtil.typeSignature(node.type));", "-\t\t\t\t\t// NB: no need to update occurence count as the variable is defined by its positions", "-\t\t\t\t\tthrow new EndVisit();", "-\t\t\t\t}", "+\t\t\t    push(node);", "+\t\t\t\tif (node == toBeFound) throw new EndVisit();", "+\t\t\tpublic void endVisit(LocalDeclaration node, BlockScope scope) {", "+\t\t\t    pop(node);", "+            }", "-\t\t\t\tif ((node.bits & ASTNode.IsAnonymousTypeMASK) != 0) {", "-\t\t\t\t\tcurrentElement = updateOccurenceCount(((IMember)currentElement).getType(\"\", 1)); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = updateOccurenceCount(((IMember)currentElement).getType(new String(node.name), 1));", "-\t\t\t\t}", "+\t\t\t    push(node);", "-\t\t\t\t\tcurrentElement = ((IType)currentElement).getDeclaringType();", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\t    pop(node);", "+\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the method)", "-\t\t\t\tcurrentElement = ((IType)currentElement).getType(new String(node.name));", "+\t\t\t    push(node);", "-\t\t\t\t\tcurrentElement = ((IType)currentElement).getDeclaringType();", "-\t\t\t\t} else {", "-\t\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\t    pop(node);", "+\t\t\t\t// don't pop local/anonymous types (used to count how many occurrences are in the initializer)", "-\t\t\t\tcurrentElement = ", "-\t\t\t\t\t((IType)currentElement).getMethod(", "-\t\t\t\t\t\tnew String(node.selector), ", "-\t\t\t\t\t\tUtil.typeParameterSignatures(node));", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\t\tif (currentElement instanceof ICompilationUnit) {", "-\t\t\t\t\tcurrentElement = ((ICompilationUnit)currentElement).getType(new String(node.name));", "-\t\t\t\t} else {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tcurrentElement = ((IClassFile)currentElement).getType();", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\t// class file doesn't exit: ignore", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t    push(node);", "-\t\t\t\tcurrentElement = currentElement.getParent();", "+\t\t\t\tpop(node);", "-\t\t\tprivate IJavaElement updateOccurenceCount(IJavaElement element) {", "-\t\t\t\twhile (knownElements.contains(element)) {", "-\t\t\t\t\t((JavaElement)element).occurrenceCount++;", "-\t\t\t\t}", "-\t\t\t\tknownElements.add(element);", "-\t\t\t\treturn element;", "-\t\t\t}", "-\t\t\treturn visitor.currentElement;", "+\t\t    ASTNode[] nodeStack = visitor.nodeStack;", "+\t\t    int end = visitor.nodeIndex;", "+\t\t    int start = 0;", "+\t\t    ", "+\t\t    // find the inner most type declaration if binary type", "+\t\t    ASTNode typeDecl = null;", "+\t\t    if (openable instanceof ClassFile) {", "+\t\t\t\tfor (int i = end; i >= 0; i--) {", "+\t\t\t\t    if (nodeStack[i] instanceof TypeDeclaration) {", "+\t\t\t\t        typeDecl = nodeStack[i];", "+\t\t\t\t        start = i;", "+\t\t\t\t        break;", "+\t\t\t\t    }", "+\t\t\t\t}", "+\t\t    }", "+\t\t\t", "+\t\t\t// find the openable corresponding to this type declaration", "+\t\t\tif (typeDecl != null) {", "+\t\t\t    openable = getOpenable(typeDecl, openable);", "+\t\t\t}", "+\t\t\t", "+\t\t\treturn createElement(nodeStack, start, end, openable);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94d7053c88e3a439153dbd03c6644d32", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java", "commitBeforeChange": "b79c29d7f1a4a20398432bd28f19825acd39464f", "commitAfterChange": "acb9838f14c6b1a5ef6950eb28bfa26497eccaa4", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "signatureAfterChange": " \tpublic boolean performConcurrentJob(IJob searchJob, int waitingPolicy, IProgressMonitor progress)", "diff": ["-\t\t\t\t\t\tint awaitingWork;", "-\t\t\t\t\t\tIJob previousJob = null;", "-\t\t\t\t\t\tIJob currentJob;", "-\t\t\t\t\t\t\tint totalWork = this.awaitingJobsCount();", "-\t\t\t\t\t\t\tif (progress != null && totalWork > 0) {", "-\t\t\t\t\t\t\t\tsubProgress = new SubProgressMonitor(progress, concurrentJobWork / 2);", "+\t\t\t\t\t\t\tint totalWork = 1000;", "+\t\t\t\t\t\t\tif (progress != null) {", "+\t\t\t\t\t\t\t\tsubProgress = new SubProgressMonitor(progress, concurrentJobWork * 8 / 10);", "-\t\t\t\t\t\t\t\tconcurrentJobWork = concurrentJobWork / 2;", "+\t\t\t\t\t\t\t\tconcurrentJobWork = concurrentJobWork * 2 / 10;", "-\t\t\t\t\t\t\t\twhile ((awaitingWork = awaitingJobsCount()) > 0) {", "+\t\t\t\t\t\t\t\tIJob previousJob = null;", "+\t\t\t\t\t\t\t\tint awaitingJobsCount;", "+\t\t\t\t\t\t\t\tint lastJobsCount = totalWork;", "+\t\t\t\t\t\t\t\tfloat lastWorked = 0;", "+\t\t\t\t\t\t\t\tfloat totalWorked = 0;", "+\t\t\t\t\t\t\t\twhile ((awaitingJobsCount = awaitingJobsCount()) > 0) {", "-\t\t\t\t\t\t\t\t\tcurrentJob = currentJob();", "+\t\t\t\t\t\t\t\t\tIJob currentJob = currentJob();", "-\t\t\t\t\t\t\t\t\t\t\t\tMessages.bind(Messages.manager_filesToIndex, Integer.toString(awaitingWork))); ", "-\t\t\t\t\t\t\t\t\t\t\tsubProgress.worked(1);", "+\t\t\t\t\t\t\t\t\t\t\t\tMessages.bind(Messages.manager_filesToIndex, Integer.toString(awaitingJobsCount)));", "+\t\t\t\t\t\t\t\t\t\t\t// ratio of the amount of work relative to the total work", "+\t\t\t\t\t\t\t\t\t\t\tfloat ratio = awaitingJobsCount < totalWork ? 1 : ((float) totalWork) / awaitingJobsCount;", "+\t\t\t\t\t\t\t\t\t\t\tif (lastJobsCount > awaitingJobsCount) {", "+\t\t\t\t\t\t\t\t\t\t\t\ttotalWorked += (lastJobsCount - awaitingJobsCount) * ratio;", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t// more jobs were added, just increment by the ratio", "+\t\t\t\t\t\t\t\t\t\t\t\ttotalWorked += ratio;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (totalWorked - lastWorked >= 1) {", "+\t\t\t\t\t\t\t\t\t\t\t\tsubProgress.worked((int) (totalWorked - lastWorked));", "+\t\t\t\t\t\t\t\t\t\t\t\tlastWorked = totalWorked;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tlastJobsCount = awaitingJobsCount;"]}], "num": 23762}