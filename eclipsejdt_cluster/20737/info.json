{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d0fd3e1f31b6f7e45d252a1e7b1facba", "detectedBy": ["DIFF_DBSCAN", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "073504b1be43c0d0c9993ce3c3639926", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic void complete(ICompilationUnit sourceUnit, int completionPosition)", "signatureAfterChange": "\r public void complete(ICompilationUnit sourceUnit, int completionPosition)", "diff": ["-\t */\r", "-\tpublic void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "-\t\ttry {\r", "-\t\t\tactualCompletionPosition = completionPosition - 1;\r", "-\t\t\t// for now until we can change the UI.\r", "-\t\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "-\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\tparser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "-\r", "-\t\t\t//\t\tboolean completionNodeFound = false;\r", "-\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t// scan the package & import statements first\r", "-\t\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "-\t\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "-\t\t\t\t\treturn;\r", "-\t\t\t\t}\r", "-\t\t\t\tImportReference[] imports = parsedUnit.imports;\r", "-\t\t\t\tif (imports != null) {\r", "-\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "-\t\t\t\t\t\tImportReference importReference = imports[i];\r", "-\t\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "-\t\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "-\t\t\t\t\t\t\treturn;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\tif (parsedUnit.types != null) {\r", "-\t\t\t\t\ttry {\r", "-\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "-\t\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "+ */\r", "+public void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "+\ttry {\r", "+\t\tint actualCompletionPosition = completionPosition - 1; // for now until we can change the UI.\r", "+\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "+\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "+\r", "+//\t\tboolean completionNodeFound = false;\r", "+\t\tif (parsedUnit != null) {\r", "+\t\t\t// scan the package & import statements first\r", "+\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "+\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "+\t\t\t\treturn;\r", "+\t\t\t}\r", "+\t\t\tImportReference[] imports = parsedUnit.imports;\r", "+\t\t\tif (imports != null) {\r", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "+\t\t\t\t\tImportReference importReference = imports[i];\r", "+\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "+\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "+\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tif (parsedUnit.types != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "+\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} catch (CompletionNodeFound e) {\r", "-\t\t\t\t\t\t//\t\t\t\t\tcompletionNodeFound = true;\r", "-\t\t\t\t\t\tif (e.astNode != null)\r", "-\t\t\t\t\t\t\t// if null then we found a problem in the completion node\r", "-\t\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "+\t\t\t\t} catch (CompletionNodeFound e) {\r", "+//\t\t\t\t\tcompletionNodeFound = true;\r", "+\t\t\t\t\tif (e.astNode != null) // if null then we found a problem in the completion node\r", "+\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "-\r", "-\t\t\t/* Ignore package, import, class & interface keywords for now...\r", "-\t\t\t\t\tif (!completionNodeFound) {\r", "-\t\t\t\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "-\t\t\t\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "-\t\t\t\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "-\t\t\t\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "-\t\t\t\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "-\t\t\t\t\t}\r", "-\t\t\t*/\r", "-\t\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "-\t\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "-\t\t}\r", "-\t}\r", "+/* Ignore package, import, class & interface keywords for now...\r", "+\t\tif (!completionNodeFound) {\r", "+\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "+\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "+\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "+\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "+\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "+\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "+*/\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "+\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90094f05af920c1bafcda27537839b62", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic void complete(ICompilationUnit sourceUnit, int completionPosition)", "signatureAfterChange": "\r public void complete(ICompilationUnit sourceUnit, int completionPosition)", "diff": ["-\t */\r", "-\tpublic void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "-\t\ttry {\r", "-\t\t\tactualCompletionPosition = completionPosition - 1;\r", "-\t\t\t// for now until we can change the UI.\r", "-\t\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "-\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\tparser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "-\r", "-\t\t\t//\t\tboolean completionNodeFound = false;\r", "-\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t// scan the package & import statements first\r", "-\t\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "-\t\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "-\t\t\t\t\treturn;\r", "-\t\t\t\t}\r", "-\t\t\t\tImportReference[] imports = parsedUnit.imports;\r", "-\t\t\t\tif (imports != null) {\r", "-\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "-\t\t\t\t\t\tImportReference importReference = imports[i];\r", "-\t\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "-\t\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "-\t\t\t\t\t\t\treturn;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\tif (parsedUnit.types != null) {\r", "-\t\t\t\t\ttry {\r", "-\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "-\t\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "+ */\r", "+public void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "+\ttry {\r", "+\t\tint actualCompletionPosition = completionPosition - 1; // for now until we can change the UI.\r", "+\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "+\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "+\r", "+//\t\tboolean completionNodeFound = false;\r", "+\t\tif (parsedUnit != null) {\r", "+\t\t\t// scan the package & import statements first\r", "+\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "+\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "+\t\t\t\treturn;\r", "+\t\t\t}\r", "+\t\t\tImportReference[] imports = parsedUnit.imports;\r", "+\t\t\tif (imports != null) {\r", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "+\t\t\t\t\tImportReference importReference = imports[i];\r", "+\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "+\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "+\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tif (parsedUnit.types != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "+\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} catch (CompletionNodeFound e) {\r", "-\t\t\t\t\t\t//\t\t\t\t\tcompletionNodeFound = true;\r", "-\t\t\t\t\t\tif (e.astNode != null)\r", "-\t\t\t\t\t\t\t// if null then we found a problem in the completion node\r", "-\t\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "+\t\t\t\t} catch (CompletionNodeFound e) {\r", "+//\t\t\t\t\tcompletionNodeFound = true;\r", "+\t\t\t\t\tif (e.astNode != null) // if null then we found a problem in the completion node\r", "+\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "-\r", "-\t\t\t/* Ignore package, import, class & interface keywords for now...\r", "-\t\t\t\t\tif (!completionNodeFound) {\r", "-\t\t\t\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "-\t\t\t\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "-\t\t\t\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "-\t\t\t\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "-\t\t\t\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "-\t\t\t\t\t}\r", "-\t\t\t*/\r", "-\t\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "-\t\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "-\t\t}\r", "-\t}\r", "+/* Ignore package, import, class & interface keywords for now...\r", "+\t\tif (!completionNodeFound) {\r", "+\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "+\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "+\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "+\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "+\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "+\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "+*/\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "+\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9ff718d4caaa70fcf4c01895785fd5a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \tpublic void complete(ICompilationUnit sourceUnit, int completionPosition)", "signatureAfterChange": "\r public void complete(ICompilationUnit sourceUnit, int completionPosition)", "diff": ["-\t */\r", "-\tpublic void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "-\t\ttry {\r", "-\t\t\tactualCompletionPosition = completionPosition - 1;\r", "-\t\t\t// for now until we can change the UI.\r", "-\t\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "-\t\t\tCompilationUnitDeclaration parsedUnit =\r", "-\t\t\t\tparser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "-\r", "-\t\t\t//\t\tboolean completionNodeFound = false;\r", "-\t\t\tif (parsedUnit != null) {\r", "-\t\t\t\t// scan the package & import statements first\r", "-\t\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "-\t\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "-\t\t\t\t\treturn;\r", "-\t\t\t\t}\r", "-\t\t\t\tImportReference[] imports = parsedUnit.imports;\r", "-\t\t\t\tif (imports != null) {\r", "-\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "-\t\t\t\t\t\tImportReference importReference = imports[i];\r", "-\t\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "-\t\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "-\t\t\t\t\t\t\treturn;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\tif (parsedUnit.types != null) {\r", "-\t\t\t\t\ttry {\r", "-\t\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "-\t\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "+ */\r", "+public void complete(ICompilationUnit sourceUnit, int completionPosition) {\r", "+\ttry {\r", "+\t\tint actualCompletionPosition = completionPosition - 1; // for now until we can change the UI.\r", "+\t\tCompilationResult result = new CompilationResult(sourceUnit, 1, 1);\r", "+\t\tCompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, result, actualCompletionPosition);\r", "+\r", "+//\t\tboolean completionNodeFound = false;\r", "+\t\tif (parsedUnit != null) {\r", "+\t\t\t// scan the package & import statements first\r", "+\t\t\tif (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {\r", "+\t\t\t\tfindPackages((CompletionOnPackageReference) parsedUnit.currentPackage);\r", "+\t\t\t\treturn;\r", "+\t\t\t}\r", "+\t\t\tImportReference[] imports = parsedUnit.imports;\r", "+\t\t\tif (imports != null) {\r", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {\r", "+\t\t\t\t\tImportReference importReference = imports[i];\r", "+\t\t\t\t\tif (importReference instanceof CompletionOnImportReference) {\r", "+\t\t\t\t\t\tfindImports((CompletionOnImportReference) importReference);\r", "+\t\t\t\t\t\treturn;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\r", "+\t\t\tif (parsedUnit.types != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tlookupEnvironment.buildTypeBindings(parsedUnit);\r", "+\t\t\t\t\tif ((unitScope = parsedUnit.scope) != null) {\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t} catch (CompletionNodeFound e) {\r", "-\t\t\t\t\t\t//\t\t\t\t\tcompletionNodeFound = true;\r", "-\t\t\t\t\t\tif (e.astNode != null)\r", "-\t\t\t\t\t\t\t// if null then we found a problem in the completion node\r", "-\t\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "+\t\t\t\t} catch (CompletionNodeFound e) {\r", "+//\t\t\t\t\tcompletionNodeFound = true;\r", "+\t\t\t\t\tif (e.astNode != null) // if null then we found a problem in the completion node\r", "+\t\t\t\t\t\tcomplete(e.astNode, e.qualifiedBinding, e.scope);\r", "-\r", "-\t\t\t/* Ignore package, import, class & interface keywords for now...\r", "-\t\t\t\t\tif (!completionNodeFound) {\r", "-\t\t\t\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "-\t\t\t\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "-\t\t\t\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "-\t\t\t\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "-\t\t\t\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "-\t\t\t\t\t}\r", "-\t\t\t*/\r", "-\t\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "-\t\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "-\t\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "-\t\t} finally {\r", "-\t\t\treset();\r", "-\t\t}\r", "-\t}\r", "+/* Ignore package, import, class & interface keywords for now...\r", "+\t\tif (!completionNodeFound) {\r", "+\t\t\tif (parsedUnit == null || parsedUnit.types == null) {\r", "+\t\t\t\t// this is not good enough... can still be trying to define a second type\r", "+\t\t\t\tCompletionScanner scanner = (CompletionScanner) parser.scanner;\r", "+\t\t\t\tsetSourceRange(scanner.completedIdentifierStart, scanner.completedIdentifierEnd);\r", "+\t\t\t\tfindKeywords(scanner.completionIdentifier, mainDeclarations, null);\r", "+\t\t\t// currently have no way to know if extends/implements are possible keywords\r", "+*/\t} catch (IndexOutOfBoundsException e) { // work-around internal failure - 1GEMF6D\r", "+\t} catch (InvalidCursorLocation e) { // may eventually report a usefull error\r", "+\t} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object\r", "+\t} finally {\r", "+\t\treset();\r", "+}\r"]}], "num": 20737}