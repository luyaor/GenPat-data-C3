{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0648dbf142a1d0d82b0185f9ab2bea8d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2237f5dc77632c453d4bb094f5446aaa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "75871e5cf780d193f3aa131d6533bfb3e88085a3", "commitAfterChange": "262c2d405c84f8f17d09d055f013ac895aa0dc67", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 28, "signatureBeforeChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] tokens,\r \t\tIJavaElement element,\r \t\tint[] accuracies)\r \t\tthrows CoreException", "diff": ["-\t\t\t\r", "-\t\tthis.reportAccurateReference(\r", "-\t\t\tsourceStart,\r", "-\t\t\tsourceEnd,\r", "-\t\t\tqualifiedName,\r", "-\t\t\telement,\r", "-\t\t\tnew int[] {accuracy},\r", "-\t\t\tfalse);\r", "-\t}\r", "+\t */\r", "+\tpublic void reportAccurateReference(\r", "+\t\tint sourceStart,\r", "+\t\tint sourceEnd,\r", "+\t\tchar[][] tokens,\r", "+\t\tIJavaElement element,\r", "+\t\tint[] accuracies)\r", "+\t\tthrows CoreException {\r", "+\r", "+\t\t// compute source positions of the qualified reference \r", "+\t\tScanner scanner = parser.scanner;\r", "+\t\tscanner.setSourceBuffer(\r", "+\t\t\tthis.potentialMatches[this.potentialMatchesIndex].getSource());\r", "+\t\tscanner.resetTo(sourceStart, sourceEnd);\r", "+\r", "+\t\tint refSourceStart = -1, refSourceEnd = -1;\r", "+\t\tint length = tokens.length;\r", "+\t\tint token = -1;\r", "+\t\tint previousValid = -1;\r", "+\t\tint i = 0;\r", "+\t\tint accuracyIndex = 0;\r", "+\t\tdo {\r", "+\t\t\tint currentPosition = scanner.currentPosition;\r", "+\t\t\t// read token\r", "+\t\t\ttry {\r", "+\t\t\t\ttoken = scanner.getNextToken();\r", "+\t\t\t} catch (InvalidInputException e) {\r", "+\t\t\t}\r", "+\t\t\tif (token != TerminalSymbols.TokenNameEOF) {\r", "+\t\t\t\tchar[] currentTokenSource = scanner.getCurrentTokenSource();\r", "+\t\t\t\tboolean equals = false;\r", "+\t\t\t\twhile (i < length\r", "+\t\t\t\t\t&& !(equals = CharOperation.equals(tokens[i++], currentTokenSource))) {\r", "+\t\t\t\t}\r", "+\t\t\t\tif (equals && (previousValid == -1 || previousValid == i - 2)) {\r", "+\t\t\t\t\tpreviousValid = i - 1;\r", "+\t\t\t\t\tif (refSourceStart == -1) {\r", "+\t\t\t\t\t\trefSourceStart = currentPosition;\r", "+\t\t\t\t\trefSourceEnd = scanner.currentPosition - 1;\r", "+\t\t\t\t} else {\r", "+\t\t\t\t}\r", "+\t\t\t\t// read '.'\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\ttoken = scanner.getNextToken();\r", "+\t\t\t\t} catch (InvalidInputException e) {\r", "+\t\t\tif (accuracies[accuracyIndex] != -1) {\r", "+\t\t\t\t// accept reference\r", "+\t\t\t\tif (refSourceStart != -1) {\r", "+\t\t\t\t\tthis.report(refSourceStart, refSourceEnd, element, accuracies[accuracyIndex]);\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\tthis.report(sourceStart, sourceEnd, element, accuracies[accuracyIndex]);\r", "+\t\t\t\t}\r", "+\t\t\t\ti = 0;\r", "+\t\t\t}\r", "+\t\t\trefSourceStart = -1;\r", "+\t\t\tpreviousValid = -1;\r", "+\t\t\tif (accuracyIndex < accuracies.length-1) {\r", "+\t\t} while (token != TerminalSymbols.TokenNameEOF);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2ee45d769b2b3fea762afbf9e604f23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "e944f831810e143e8894d05428eb208a2cd78cce", "commitAfterChange": "45b2548f21c6553964603037785b1fef0bb3e0d3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void adaptRegions()", "signatureAfterChange": " \tprivate void adaptRegions()", "diff": ["-\t\tthis.adaptedRegions = new IRegion[this.regions.length];", "-\t\tfor (int i = 0, max = this.regions.length; i < max; i++) {", "+\t\tint max = this.regions.length;", "+\t\tif (max == 1) {", "+\t\t\t// It's not necessary to adapt the single region which covers all the source", "+\t\t\tif (this.regions[0].getOffset() == 0 && this.regions[0].getLength() == this.scannerEndPosition) {", "+\t\t\t\tthis.adaptedRegions = this.regions;", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+\t\tthis.adaptedRegions = new IRegion[max];", "+\t\tint commentIndex = 0;", "+\t\tfor (int i = 0; i < max; i++) {", "+\t\t\tint length = aRegion.getLength();", "+", "+\t\t\t// First look if the region starts or ends inside a comment", "+\t\t\tint index = getCommentIndex(commentIndex, offset);", "+\t\t\tint adaptedOffset = offset;", "+\t\t\tint adaptedLength = length;", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the offset of the region is inside a comment => restart the region from the comment start", "+\t\t\t\tadaptedOffset = this.commentPositions[index][0];", "+\t\t\t\tif (adaptedOffset < 0) adaptedOffset = -adaptedOffset;", "+\t\t\t\tadaptedLength = length + offset - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t\t// include also the indentation edit just before the comment if any", "+\t\t\t\tfor (int j=0; j<this.editsIndex; j++) {", "+\t\t\t\t\tint editOffset = this.edits[j].offset;", "+\t\t\t\t\tint editEnd = editOffset + this.edits[j].length;", "+\t\t\t\t\tif (editEnd == adaptedOffset) {", "+\t\t\t\t\t\tif (j > 0 && this.edits[j].replacement.trim().length() == 0) {", "+\t\t\t\t\t\t\tadaptedLength += adaptedOffset - this.edits[j].offset;", "+\t\t\t\t\t\t\tadaptedOffset = editOffset;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (editEnd > adaptedOffset) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tindex = getCommentIndex(commentIndex, offset+length-1);", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the region end is inside a comment => set the region end at the comment end", "+\t\t\t\tint commentEnd = this.commentPositions[index][1];", "+\t\t\t\tif (commentEnd < 0) commentEnd = -commentEnd;", "+\t\t\t\tadaptedLength = commentEnd - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t}", "+\t\t\tif (adaptedLength != length) {", "+\t\t\t\t// adapt the region and jump to next one", "+\t\t\t\tthis.adaptedRegions[i] = new Region(adaptedOffset, adaptedLength);", "+\t\t\t\tcontinue;", "+\t\t\t}", "+", "-\t\t\t\tint length = aRegion.getLength();"]}], "num": 66123}