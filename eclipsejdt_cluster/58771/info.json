{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b9b905aa6bf01327a0e22ff3371c09bf", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd7d5e01513e69c2462083ec483c3a2f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "8a55616a15f0e12ee24162781746f45ed8c24b78", "commitAfterChange": "d7c285a09f8cde2ba05e7f838f10ce545b90c736", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "\r public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo)", "signatureAfterChange": "\r \r \tpublic void analyseCode(\r \t\tClassScope classScope,\r \t\tInitializationFlowContext initializerFlowContext,\r \t\tFlowInfo flowInfo)", "diff": ["-\tpublic int referenceCount = 0; // count how many times this constructor is referenced from other local constructors\r", "-public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo) {\r", "-\tif (ignoreFurtherInvestigation)\r", "-\t\treturn;\r", "-\ttry {\r", "-\t\tExceptionHandlingFlowContext constructorContext = new ExceptionHandlingFlowContext(\r", "-\t\t\tinitializerFlowContext.parent, \r", "-\t\t\tthis, \r", "-\t\t\tbinding.thrownExceptions, \r", "-\t\t\tscope,\r", "-\t\t\tFlowInfo.DeadEnd);\r", "-\t\tinitializerFlowContext.checkInitializerExceptions(scope, constructorContext, flowInfo);\r", "-\t\t\r", "-\t\t// propagate to constructor call\r", "-\t\tif (constructorCall != null) {\r", "-\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely\r", "-\t\t\t// set since they are supposed to be set inside other local constructor\r", "-\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {\r", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "-\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "-\t\t\t\t\tFieldBinding field;\r", "-\t\t\t\t\tif (!(field = fields[i]).isStatic()) {\r", "-\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);\r", "+\r", "+\tpublic void analyseCode(\r", "+\t\tClassScope classScope,\r", "+\t\tInitializationFlowContext initializerFlowContext,\r", "+\t\tFlowInfo flowInfo) {\r", "+\r", "+\t\tif (ignoreFurtherInvestigation)\r", "+\t\t\treturn;\r", "+\t\ttry {\r", "+\t\t\tExceptionHandlingFlowContext constructorContext =\r", "+\t\t\t\tnew ExceptionHandlingFlowContext(\r", "+\t\t\t\t\tinitializerFlowContext.parent,\r", "+\t\t\t\t\tthis,\r", "+\t\t\t\t\tbinding.thrownExceptions,\r", "+\t\t\t\t\tscope,\r", "+\t\t\t\t\tFlowInfo.DeadEnd);\r", "+\t\t\tinitializerFlowContext.checkInitializerExceptions(\r", "+\t\t\t\tscope,\r", "+\t\t\t\tconstructorContext,\r", "+\t\t\t\tflowInfo);\r", "+\r", "+\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones\r", "+\t\t\tif (binding.declaringClass.isAnonymousType()) {\r", "+\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;\r", "+\t\t\t\tif (computedExceptions != null){\r", "+\t\t\t\t\tint size;\r", "+\t\t\t\t\tif ((size = computedExceptions.size()) > 0){\r", "+\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;\r", "+\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);\r", "+\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;\r", "-\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);\r", "-\t\t}\r", "-\t\t// propagate to statements\r", "-\t\tif (statements != null){\r", "-\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {\r", "-\t\t\t\tStatement stat;\r", "-\t\t\t\tif (!flowInfo.complainIfUnreachable((stat = statements[i]), scope)) {\r", "-\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t\r", "+\t\t\t// propagate to constructor call\r", "+\t\t\tif (constructorCall != null) {\r", "+\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely\r", "+\t\t\t\t// set since they are supposed to be set inside other local constructor\r", "+\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {\r", "+\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "+\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "+\t\t\t\t\t\tFieldBinding field;\r", "+\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {\r", "+\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t}\r", "+\t\t\t// propagate to statements\r", "+\t\t\tif (statements != null) {\r", "+\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {\r", "+\t\t\t\t\tStatement stat;\r", "+\t\t\t\t\tif (!flowInfo.complainIfUnreachable((stat = statements[i]), scope)) {\r", "+\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);\r", "+\t\t\t\t\t}\r", "-\t\t}\r", "-\t\t// check for missing returning path\r", "-\t\tneedFreeReturn = !((flowInfo == FlowInfo.DeadEnd) || flowInfo.isFakeReachable());\r", "+\t\t\t// check for missing returning path\r", "+\t\t\tneedFreeReturn =\r", "+\t\t\t\t!((flowInfo == FlowInfo.DeadEnd) || flowInfo.isFakeReachable());\r", "-\t\t// check missing blank final field initializations\r", "-\t\tif ((constructorCall != null) && (constructorCall.accessMode != ExplicitConstructorCall.This)){\r", "-\t\t\tflowInfo = flowInfo.mergedWith(initializerFlowContext.initsOnReturn);\r", "-\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "-\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "-\t\t\t\tFieldBinding field;\r", "-\t\t\t\tif ((!(field = fields[i]).isStatic())\r", "-\t\t\t\t\t&& field.isFinal()\r", "-\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {\r", "-\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(field, isDefaultConstructor ? (AstNode)scope.referenceType() : this);\r", "+\t\t\t// check missing blank final field initializations\r", "+\t\t\tif ((constructorCall != null)\r", "+\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {\r", "+\t\t\t\tflowInfo = flowInfo.mergedWith(initializerFlowContext.initsOnReturn);\r", "+\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();\r", "+\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {\r", "+\t\t\t\t\tFieldBinding field;\r", "+\t\t\t\t\tif ((!(field = fields[i]).isStatic())\r", "+\t\t\t\t\t\t&& field.isFinal()\r", "+\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {\r", "+\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(\r", "+\t\t\t\t\t\t\tfield,\r", "+\t\t\t\t\t\t\tisDefaultConstructor ? (AstNode) scope.referenceType() : this);\r", "+\t\t\t\t\t}\r", "+\t\t} catch (AbortMethod e) {\r", "+\t\t\tthis.ignoreFurtherInvestigation = true;\r", "-\t} catch (AbortMethod e) {\r", "-\t\tthis.ignoreFurtherInvestigation = true;\t\t\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e481a65c3614de687d0fb0ad26a3e0b7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic void analyseCode( \t\tClassScope classScope, \t\tInitializationFlowContext initializerFlowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo)", "diff": ["+ */", "+public void analyseCode(ClassScope classScope, InitializationFlowContext initializerFlowContext, FlowInfo flowInfo) {", "+\tanalyseCode(classScope, initializerFlowContext, flowInfo, FlowInfo.REACHABLE);", "+}", "-\tpublic void analyseCode(", "-\t\tClassScope classScope,", "-\t\tInitializationFlowContext initializerFlowContext,", "-\t\tFlowInfo flowInfo) {", "-\t\tif (ignoreFurtherInvestigation)", "-\t\t\treturn;", "-", "-\t\tif (this.binding != null && !this.binding.isUsed() && (this.binding.isPrivate() || (this.binding.declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) == TagBits.IsLocalType)) {", "-\t\t\tif (!classScope.referenceCompilationUnit().compilationResult.hasSyntaxError) {", "-\t\t\t\tscope.problemReporter().unusedPrivateConstructor(this);", "-\t\t\t", "-\t\t// check constructor recursion, once all constructor got resolved", "-\t\tif (isRecursive(null /*lazy initialized visited list*/)) {\t\t\t\t", "-\t\t\tthis.scope.problemReporter().recursiveConstructorInvocation(this.constructorCall);", "-\t\t\t", "-\t\ttry {", "-\t\t\tExceptionHandlingFlowContext constructorContext =", "-\t\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\t\tinitializerFlowContext.parent,", "-\t\t\t\t\tthis,", "-\t\t\t\t\tbinding.thrownExceptions,", "-\t\t\t\t\tscope,", "-\t\t\t\t\tFlowInfo.DEAD_END);", "-\t\t\tinitializerFlowContext.checkInitializerExceptions(", "-\t\t\t\tscope,", "-\t\t\t\tconstructorContext,", "-\t\t\t\tflowInfo);", "-", "-\t\t\t// anonymous constructor can gain extra thrown exceptions from unhandled ones", "-\t\t\tif (binding.declaringClass.isAnonymousType()) {", "-\t\t\t\tArrayList computedExceptions = constructorContext.extendedExceptions;", "-\t\t\t\tif (computedExceptions != null){", "-\t\t\t\t\tint size;", "-\t\t\t\t\tif ((size = computedExceptions.size()) > 0){", "-\t\t\t\t\t\tReferenceBinding[] actuallyThrownExceptions;", "-\t\t\t\t\t\tcomputedExceptions.toArray(actuallyThrownExceptions = new ReferenceBinding[size]);", "-\t\t\t\t\t\tbinding.thrownExceptions = actuallyThrownExceptions;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// tag parameters as being set", "-\t\t\tif (this.arguments != null) {", "-\t\t\t\tfor (int i = 0, count = this.arguments.length; i < count; i++) {", "-\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t\t// propagate to constructor call", "-\t\t\tif (constructorCall != null) {", "-\t\t\t\t// if calling 'this(...)', then flag all non-static fields as definitely", "-\t\t\t\t// set since they are supposed to be set inside other local constructor", "-\t\t\t\tif (constructorCall.accessMode == ExplicitConstructorCall.This) {", "-\t\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-\t\t\t\t\t\tFieldBinding field;", "-\t\t\t\t\t\tif (!(field = fields[i]).isStatic()) {", "-\t\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(field);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tflowInfo = constructorCall.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t}", "-\t\t\t// propagate to statements", "-\t\t\tif (statements != null) {", "-\t\t\t\tboolean didAlreadyComplain = false;", "-\t\t\t\tfor (int i = 0, count = statements.length; i < count; i++) {", "-\t\t\t\t\tStatement stat = statements[i];", "-\t\t\t\t\tif (!stat.complainIfUnreachable(flowInfo, scope, didAlreadyComplain)) {", "-\t\t\t\t\t\tflowInfo = stat.analyseCode(scope, constructorContext, flowInfo);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tdidAlreadyComplain = true;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// check for missing returning path", "-\t\t\tthis.needFreeReturn = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-", "-", "-\t\t\t// check missing blank final field initializations", "-\t\t\tif ((constructorCall != null)", "-\t\t\t\t&& (constructorCall.accessMode != ExplicitConstructorCall.This)) {", "-\t\t\t\tflowInfo = flowInfo.mergedWith(constructorContext.initsOnReturn);", "-\t\t\t\tFieldBinding[] fields = binding.declaringClass.fields();", "-\t\t\t\t\tif ((!(field = fields[i]).isStatic())", "-\t\t\t\t\t\t&& field.isFinal()", "-\t\t\t\t\t\t&& (!flowInfo.isDefinitelyAssigned(fields[i]))) {", "-\t\t\t\t\t\tscope.problemReporter().uninitializedBlankFinalField(", "-\t\t\t\t\t\t\tfield,", "-\t\t\t\t\t\t\tisDefaultConstructor ? (ASTNode) scope.referenceType() : this);", "-\t\t\t// check unreachable catch blocks", "-\t\t\tconstructorContext.complainIfUnusedExceptionHandlers(this);", "-\t\t} catch (AbortMethod e) {", "-\t\t\tthis.ignoreFurtherInvestigation = true;", "-\t}"]}], "num": 58771}