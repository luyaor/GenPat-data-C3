{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f7700625aba544dbed1dee24348a089b", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7405c8666f3e4a755d8d3f31ae271201", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "27fd6b1218a2223f75b9add3ad72e983a5f4500b", "commitAfterChange": "d2861a7753e529217c872f1a7e1714670325b389", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "signatureAfterChange": "  \tprivate CompilationUnitDeclaration resolve( \t\t\tCompilationUnitDeclaration unit, \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "diff": ["-\t */", "-\tpublic CompilationUnitDeclaration resolve(", "-\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit,", "+\tprivate CompilationUnitDeclaration resolve(", "+\t\t\tCompilationUnitDeclaration unit,", "+\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit,", "-\t\tCompilationUnitDeclaration unit = null;", "-\t\t\tthis.parseThreshold = 0; // will request a diet parse", "-\t\t\tbeginToCompile(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] { compilationUnit});", "-\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "-\t\t\tunit = this.unitsToProcess[0];", "-", "-\t\t\tint searchPosition = nodeSearcher.position;", "-\t\t\tif (searchPosition >= 0 && searchPosition <= compilationUnit.getContents().length) {", "-\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "-\t\t\t\t", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "-\t\t\t\t", "-\t \t\t\tif (node != null) {", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "-\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "-\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "-\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "-\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "-\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "-\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "-\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "-\t\t\t\t\t\t} \t\t\t\t", "-\t \t\t\t\t}", "-\t \t\t\t}", "-\t\t\t}", "-\t\t\tif (unit.scope != null) {", "-\t\t\t\t// fault in fields & methods", "-\t\t\t\tunit.scope.faultInTypes();", "-\t\t\t\tif (unit.scope != null && verifyMethods) {", "-\t\t\t\t\t// http://dev.eclipse.org/bugs/show_bug.cgi?id=23117", "- \t\t\t\t\t// verify inherited methods", "-\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "-\t\t\t\t}", "-\t\t\t\t// type checking", "-\t\t\t\tunit.resolve();\t\t", "-", "-\t\t\t\t// flow analysis", "-\t\t\t\tif (analyzeCode) unit.analyseCode();", "-\t\t", "-\t\t\t\t// code generation", "-\t\t\t\tif (generateCode) unit.generateCode();", "-\t\t\t}", "-\t\t\tif (this.unitsToProcess != null) this.unitsToProcess[0] = null; // release reference to processed unit declaration", "-\t\t\tthis.requestor.acceptResult(unit.compilationResult.tagAsAccepted());", "-\t\t\treturn unit;", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.handleInternalException(e, unit);", "-\t\t\treturn null;", "-\t\t} catch (Error e) {", "-\t\t\tthis.handleInternalException(e, unit, null);", "-\t\t\tthrow e; // rethrow", "-\t\t} catch (RuntimeException e) {", "-\t\t\tthis.handleInternalException(e, unit, null);", "-\t\t\tthrow e; // rethrow", "-\t\t} finally {", "-\t\t\t// No reset is performed there anymore since,", "-\t\t\t// within the CodeAssist (or related tools),", "-\t\t\t// the compiler may be called *after* a call", "-\t\t\t// to this resolve(...) method. And such a call", "-\t\t\t// needs to have a compiler with a non-empty", "-\t\t\t// environment.", "-\t\t\t// this.reset();", "-\t\t}", "-\t}", "+", "+\t\t\tthis.parser.getMethodBodies(unit); // no-op if method bodies have already been parsed", "+\t\t\t", "+\t\t\tif (nodeSearcher != null) {", "+\t\t\t\tint searchPosition = nodeSearcher.position;", "+\t\t\t\tif (searchPosition >= 0 && searchPosition <= sourceUnit.getContents().length) {", "+\t\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "+\t\t\t\t\t", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "+\t\t\t\t\t", "+\t\t \t\t\tif (node != null) {", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+\t\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "+\t\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "+\t\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "+\t\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "+\t\t\t\t\t\t\t} \t\t\t\t", "+\t\t \t\t\t\t}", "+\t\t \t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c09f30e73f8e6af7a38b6c722b2884d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java", "commitBeforeChange": "9ccc53063dda8b7e1afdde95ae36a8417c582abc", "commitAfterChange": "7143e72571bb2e6a2e74f6791210a97b375b5ab6", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic CompilationUnitDeclaration resolve( \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "signatureAfterChange": "  \tprivate CompilationUnitDeclaration resolve( \t\t\tCompilationUnitDeclaration unit, \t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit, \t\t\tNodeSearcher nodeSearcher, \t\t\tboolean verifyMethods, \t\t\tboolean analyzeCode, \t\t\tboolean generateCode)", "diff": ["-\t */", "-\tpublic CompilationUnitDeclaration resolve(", "-\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit compilationUnit,", "+\tprivate CompilationUnitDeclaration resolve(", "+\t\t\tCompilationUnitDeclaration unit,", "+\t\t\torg.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit,", "-\t\tCompilationUnitDeclaration unit = null;", "-\t\t\tthis.parseThreshold = 0; // will request a diet parse", "-\t\t\tbeginToCompile(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] { compilationUnit});", "-\t\t\t// process all units (some more could be injected in the loop by the lookup environment)", "-\t\t\tunit = this.unitsToProcess[0];", "-", "-\t\t\tint searchPosition = nodeSearcher.position;", "-\t\t\tif (searchPosition >= 0 && searchPosition <= compilationUnit.getContents().length) {", "-\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "-\t\t\t\t", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "-\t\t\t\t", "-\t \t\t\tif (node != null) {", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "-\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "-\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "-\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "-\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "-\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "-\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "-\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "-\t\t\t\t\t\t} \t\t\t\t", "-\t \t\t\t\t}", "-\t \t\t\t}", "-\t\t\t}", "-\t\t\tif (unit.scope != null) {", "-\t\t\t\t// fault in fields & methods", "-\t\t\t\tunit.scope.faultInTypes();", "-\t\t\t\tif (unit.scope != null && verifyMethods) {", "-\t\t\t\t\t// http://dev.eclipse.org/bugs/show_bug.cgi?id=23117", "- \t\t\t\t\t// verify inherited methods", "-\t\t\t\t\tunit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());", "-\t\t\t\t}", "-\t\t\t\t// type checking", "-\t\t\t\tunit.resolve();\t\t", "-", "-\t\t\t\t// flow analysis", "-\t\t\t\tif (analyzeCode) unit.analyseCode();", "-\t\t", "-\t\t\t\t// code generation", "-\t\t\t\tif (generateCode) unit.generateCode();", "-\t\t\t}", "-\t\t\tif (this.unitsToProcess != null) this.unitsToProcess[0] = null; // release reference to processed unit declaration", "-\t\t\tthis.requestor.acceptResult(unit.compilationResult.tagAsAccepted());", "-\t\t\treturn unit;", "-\t\t} catch (AbortCompilation e) {", "-\t\t\tthis.handleInternalException(e, unit);", "-\t\t\treturn null;", "-\t\t} catch (Error e) {", "-\t\t\tthis.handleInternalException(e, unit, null);", "-\t\t\tthrow e; // rethrow", "-\t\t} catch (RuntimeException e) {", "-\t\t\tthis.handleInternalException(e, unit, null);", "-\t\t\tthrow e; // rethrow", "-\t\t} finally {", "-\t\t\t// No reset is performed there anymore since,", "-\t\t\t// within the CodeAssist (or related tools),", "-\t\t\t// the compiler may be called *after* a call", "-\t\t\t// to this resolve(...) method. And such a call", "-\t\t\t// needs to have a compiler with a non-empty", "-\t\t\t// environment.", "-\t\t\t// this.reset();", "-\t\t}", "-\t}", "+", "+\t\t\tif (nodeSearcher == null) {", "+\t\t\t\tthis.parser.getMethodBodies(unit); // no-op if method bodies have already been parsed", "+\t\t\t} else {", "+\t\t\t\tint searchPosition = nodeSearcher.position;", "+\t\t\t\tif (searchPosition >= 0 && searchPosition <= sourceUnit.getContents().length) {", "+\t\t\t\t\tunit.traverse(nodeSearcher, unit.scope);", "+\t\t\t\t\t", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode node = nodeSearcher.found;", "+\t\t\t\t\t", "+\t\t \t\t\tif (node != null) {", "+\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingTypeDeclaration = nodeSearcher.enclosingType;", "+\t\t  \t\t\t\tif (node instanceof AbstractMethodDeclaration) {", "+\t\t\t\t\t\t\t((AbstractMethodDeclaration)node).parseStatements(this.parser, unit);", "+\t\t \t\t\t\t} else if (enclosingTypeDeclaration != null) {", "+\t\t\t\t\t\t\tif (node instanceof org.eclipse.jdt.internal.compiler.ast.Initializer) {", "+\t\t\t \t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.Initializer) node).parseStatements(this.parser, enclosingTypeDeclaration, unit);", "+\t\t \t\t\t\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {  \t\t\t\t\t", "+\t\t\t\t\t\t\t\t((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration)node).parseMethod(this.parser, unit);", "+\t\t\t\t\t\t\t} \t\t\t\t", "+\t\t \t\t\t\t}", "+\t\t \t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t"]}], "num": 12792}