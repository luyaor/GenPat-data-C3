{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5bd8bc6c135e52acdbf9df4f21949890", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8c8d16f99e42ca1ea65087fe6eeb1599", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "bd260a80ad431844690d641f800683459b9c2904", "commitAfterChange": "153b885ea368bcdf606fcdf8ffbb265189dbdbee", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["+", "+\t\t// skip tracks inherited methods which can be safely ignored for one of these reasons:", "+\t\t// - methods that have matched other inherited methods", "+\t\t// \t\teither because they match the same currentMethod or match each other", "+\t\t// - methods that are overridden by a current method", "+\t\tboolean[] skip = new boolean[inheritedLength];", "+\t\t\t\t\t\t\t// already checked compatibility, do visibility etc. also indicate overriding? If so ignore inheritedMethod further downstream", "+\t\t\t\t\t\t\tskip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "-\t\t// skip tracks which inherited methods have matched other inherited methods", "-\t\t// either because they match the same currentMethod or match each other", "-\t\tboolean[] skip = new boolean[inheritedLength];", "-\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface()) {", "+\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface() && !inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod, true)) {", "-\t\t\t\t\tif (isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod)) {", "-\t\t\t\t\t\t\tif (index == -1)", "-\t\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\t\tif (foundMatch[j] == null)", "-\t\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "-\t\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\tif (((!inheritedMethod.isAbstract() || otherInheritedMethod.isAbstract()) \t\t// if (abstract(inherited) => abstract(other)) check if inherited overrides other ", "+\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\t|| ((!otherInheritedMethod.isAbstract() || inheritedMethod.isAbstract())\t// if (abstract(other) => abstract(inherited)) check if other overrides inherited ", "+\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(otherInheritedMethod, inheritedMethod))) ", "+\t\t\t\t\t{", "+\t\t\t\t\t\tif (index == -1)", "+\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\t\t\t\tif (foundMatch[j] == null)", "+\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t\t\t\tskip[j] = true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f4af30e5b52ea78372e8b14618cd9b58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "277792ba446c3713bcfdc898c37875d45fc06c18", "commitAfterChange": "d7fda4759a019de5fb7c9bf7ef54190fb344bbaf", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": "  void checkMethods()", "signatureAfterChange": "  void checkMethods()", "diff": ["+", "+\t\t// skip tracks inherited methods which can be safely ignored for one of these reasons:", "+\t\t// - methods that have matched other inherited methods", "+\t\t// \t\teither because they match the same currentMethod or match each other", "+\t\t// - methods that are overridden by a current method", "+\t\tboolean[] skip = new boolean[inheritedLength];", "+\t\t\t\t\t\t\t// already checked compatibility, do visibility etc. also indicate overriding? If so ignore inheritedMethod further downstream", "+\t\t\t\t\t\t\tskip[j] = couldMethodOverride(currentMethod, inheritedMethod);", "-\t\t// skip tracks which inherited methods have matched other inherited methods", "-\t\t// either because they match the same currentMethod or match each other", "-\t\tboolean[] skip = new boolean[inheritedLength];", "-\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface()) {", "+\t\t\t\t\tif (otherInheritedMethod.declaringClass.isInterface() && !inheritedMethod.declaringClass.isInterface()) {", "-\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod)) {", "+\t\t\t\t\t} else if (areMethodsCompatible(inheritedMethod, otherInheritedMethod, true)) {", "-\t\t\t\t\tif (isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod)) {", "-\t\t\t\t\t\t\tif (index == -1)", "-\t\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "-\t\t\t\t\t\t\tif (foundMatch[j] == null)", "-\t\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "-\t\t\t\t\t\t\tskip[j] = true;", "+\t\t\t\t\tif (((!inheritedMethod.isAbstract() || otherInheritedMethod.isAbstract()) \t\t// if (abstract(inherited) => abstract(other)) check if inherited overrides other ", "+\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(inheritedMethod, otherInheritedMethod))", "+\t\t\t\t\t\t|| ((!otherInheritedMethod.isAbstract() || inheritedMethod.isAbstract())\t// if (abstract(other) => abstract(inherited)) check if other overrides inherited ", "+\t\t\t\t\t\t\t\t&& isSubstituteParameterSubsignature(otherInheritedMethod, inheritedMethod))) ", "+\t\t\t\t\t{", "+\t\t\t\t\t\tif (index == -1)", "+\t\t\t\t\t\t\tmatchingInherited[++index] = inheritedMethod;", "+\t\t\t\t\t\tif (foundMatch[j] == null)", "+\t\t\t\t\t\t\tmatchingInherited[++index] = otherInheritedMethod;", "+\t\t\t\t\t\tskip[j] = true;"]}], "num": 59179}