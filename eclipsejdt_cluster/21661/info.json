{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7b34462d3c0cbd6f0ccf2812f63fc451", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "525c2a41be585ed54c168f34f1c3c3f5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java", "commitBeforeChange": "dca0c800b618e06354348679c785dbf10c5f5a8f", "commitAfterChange": "cab98b2b8859caae533ee4cfbe628b2265262135", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "signatureAfterChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "diff": ["-\t\tif (this.left instanceof LambdaExpression || this.left instanceof ReferenceExpression) {", "-\t\t\tScope scope = inferenceContext.scope;", "-\t\t\tif (!this.right.isFunctionalInterface(scope))", "+\t\tScope scope = inferenceContext.scope;", "+\t\tif (!this.right.isFunctionalInterface(scope))", "+\t\t\treturn FALSE;", "+\t\tMethodBinding sam = this.right.getSingleAbstractMethod(scope, true);", "+\t\tif (sam == null)", "+\t\t\treturn FALSE;", "+\t\tif (this.left instanceof LambdaExpression) {", "+\t\t\tif (((LambdaExpression)this.left).argumentsTypeElided()) {", "+\t\t\t\tint nParam = sam.parameters.length;", "+\t\t\t\tfor (int i = 0; i < nParam; i++)", "+\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "+\t\t\t\t\t\treturn FALSE;", "+\t\t\t}", "+\t\t\tif (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))", "-\t\t\tMethodBinding sam = this.right.getSingleAbstractMethod(scope, true);", "-\t\t\tif (sam == null)", "-\t\t\t\treturn FALSE;", "-\t\t\tif (this.left instanceof LambdaExpression) {", "-\t\t\t\tif (((LambdaExpression)this.left).argumentsTypeElided()) {", "-\t\t\t\t\tint nParam = sam.parameters.length;", "-\t\t\t\t\tfor (int i = 0; i < nParam; i++)", "-\t\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "-\t\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "+\t\t} else { // reference expression", "+\t\t\tif (!((ReferenceExpression)this.left).isExactMethodReference()) {\t\t\t\t\t", "+\t\t\t\tint nParam = sam.parameters.length;", "+\t\t\t\tfor (int i = 0; i < nParam; i++)", "+\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "+\t\t\t\t\t\treturn FALSE;", "-\t\t\t} else { // reference expression", "-\t\t\t\tif (!((ReferenceExpression)this.left).isExactMethodReference()) {\t\t\t\t\t", "-\t\t\t\t\tint nParam = sam.parameters.length;", "-\t\t\t\t\tfor (int i = 0; i < nParam; i++)", "-\t\t\t\t\t\tif (!sam.parameters[i].isProperType(true))", "-\t\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t\tif (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))", "-\t\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tTypeBinding[] thrown = sam.thrownExceptions;", "-\t\t\tTypeBinding[] e = new TypeBinding[thrown.length];", "-\t\t\tint n = 0;", "-\t\t\tfor (int i = 0; i < thrown.length; i++)", "-\t\t\t\tif (!thrown[i].isProperType(true))", "-\t\t\t\t\te[n++] = thrown[i];", "-\t\t\tTypeBinding[] ePrime = null;", "-\t\t\tif (this.left instanceof LambdaExpression) {", "-// TODO find exceptions thrown by the lambda's body", "-//\t\t\t\t((LambdaExpression)this.left).", "-//\t\t\t\tInferenceContext18.missingImplementation(\"NYI\");", "-\t\t\t} else {", "-\t\t\t\tReferenceExpression referenceExpression = (ReferenceExpression)this.left;", "-\t\t\t\tMethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);", "-\t\t\t\tif (method != null)", "-\t\t\t\t\tePrime = method.thrownExceptions;", "-\t\t\t}", "-\t\t\tif (ePrime == null)", "-\t\t\t\treturn TRUE; // TODO is it a bug if we actually get here?", "-\t\t\tint m = ePrime.length;", "-\t\t\tif (n == 0) {", "-\t\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\t\tcontinue actual;", "-\t\t\t\t\treturn FALSE;", "-\t\t\t\t}", "-\t\t\t\treturn TRUE;", "-\t\t\t} else {", "-\t\t\t\tList result = new ArrayList();", "-\t\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\t\tcontinue actual;", "-\t\t\t\t\tfor (int j = 0; j < n; j++)", "-\t\t\t\t\t\tresult.add(new ConstraintTypeFormula(ePrime[i], e[j], SUBTYPE));", "-\t\t\t\t}\t\t\t\t", "-\t\t\t\tfor (int j = 0; j < n; j++)", "-\t\t\t\t\tresult.add(new ConstraintExceptionFormula(this.left, e[j]));", "-\t\t\t\treturn result.toArray(new ConstraintFormula[result.size()]);", "-\t\t\t}", "-\t\t} else if (this.left.isPolyExpression()) {", "-\t\t\t// parenthesized: transparent in our AST", "-", "-\t\t\tif (this.left instanceof ConditionalExpression) {", "-\t\t\t\tConditionalExpression conditional = (ConditionalExpression) this.left;", "-\t\t\t\treturn new ConstraintFormula[] {", "-\t\t\t\t\t\tnew ConstraintExceptionFormula(conditional.valueIfTrue, this.right),", "-\t\t\t\t\t\tnew ConstraintExceptionFormula(conditional.valueIfFalse, this.right)", "-\t\t\t\t};", "-\t\treturn TRUE;", "+\t\tTypeBinding[] thrown = sam.thrownExceptions;", "+\t\tTypeBinding[] e = new TypeBinding[thrown.length];", "+\t\tint n = 0;", "+\t\tfor (int i = 0; i < thrown.length; i++)", "+\t\t\tif (!thrown[i].isProperType(true))", "+\t\t\t\te[n++] = thrown[i];", "+\t\tTypeBinding[] ePrime = null;", "+\t\tif (this.left instanceof LambdaExpression) {", "+// TODO find exceptions thrown by the lambda's body, see 18.2.5 bullet 5", "+//\t\t\t\t((LambdaExpression)this.left).", "+//\t\t\t\tInferenceContext18.missingImplementation(\"NYI\");", "+\t\t} else {", "+\t\t\tReferenceExpression referenceExpression = (ReferenceExpression)this.left;", "+\t\t\tMethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);", "+\t\t\tif (method != null)", "+\t\t\t\tePrime = method.thrownExceptions;", "+\t\t}", "+\t\tif (ePrime == null)", "+\t\t\treturn TRUE; // TODO is it a bug if we actually get here?", "+\t\tint m = ePrime.length;", "+\t\tif (n == 0) {", "+\t\t\tactual: for (int i = 0; i < m; i++) {", "+\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "+\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "+\t\t\t\t\t\tcontinue actual;", "+\t\t\t\treturn FALSE;", "+\t\t\t}", "+\t\t\treturn TRUE;", "+\t\t} else {", "+\t\t\tList result = new ArrayList();", "+\t\t\tactual: for (int i = 0; i < m; i++) {", "+\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "+\t\t\t\t\tif (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))", "+\t\t\t\t\t\tcontinue actual;", "+\t\t\t\tfor (int j = 0; j < n; j++)", "+\t\t\t\t\tresult.add(new ConstraintTypeFormula(ePrime[i], e[j], SUBTYPE));", "+\t\t\t}\t\t\t\t", "+\t\t\tfor (int j = 0; j < n; j++)", "+\t\t\t\tresult.add(new ConstraintExceptionFormula(this.left, e[j]));", "+\t\t\treturn result.toArray(new ConstraintFormula[result.size()]);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94c01c3db3be47947406c75dc1523b58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "c48ecebe36df1bdca1948a66baeb643827a9b9c4", "commitAfterChange": "df8a00dea42b2c33f742d8ce1045c2aa42b28f3e", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " void computeInheritedMethods(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "signatureAfterChange": " void computeInheritedMethods(ReferenceBinding superclass, ReferenceBinding[] superInterfaces)", "diff": ["-\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[3][];", "-\tint lastPosition = -1;", "+\tReferenceBinding[] interfacesToVisit = null;", "+\tint nextPosition = 0;", "-\tif (itsInterfaces != Binding.NO_SUPERINTERFACES)", "-\t\tinterfacesToVisit[++lastPosition] = itsInterfaces;", "+\tif (itsInterfaces != Binding.NO_SUPERINTERFACES) {", "+\t\tnextPosition = itsInterfaces.length;", "+\t\tinterfacesToVisit = itsInterfaces;", "+\t}", "-\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t\t\t\tif (interfacesToVisit == null) {", "+\t\t\t\t\t\tinterfacesToVisit = itsInterfaces;", "+\t\t\t\t\t\tnextPosition = interfacesToVisit.length;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint itsLength = itsInterfaces.length;", "+\t\t\t\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "+\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "+\t\t\t\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "+\t\t\t\t\t\t\tReferenceBinding next = itsInterfaces[a];", "+\t\t\t\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "+\t\t\t\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "+\t\t\t\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\torg.eclipse.jdt.internal.compiler.util.SimpleSet interfacesSeen = new org.eclipse.jdt.internal.compiler.util.SimpleSet(lastPosition * 2);", "-\tfor (int i = 0; i <= lastPosition; i++) {", "-\t\tReferenceBinding[] interfaces = interfacesToVisit[i];", "-\t\tfor (int j = 0, l = interfaces.length; j < l; j++) {", "-\t\t\tsuperType = interfaces[j];", "-\t\t\tif (!interfacesSeen.includes(superType)) {", "-\t\t\t\tinterfacesSeen.add(superType);", "-\t\t\t\tif (superType.isValidBinding()) {", "-\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != Binding.NO_SUPERINTERFACES) {", "-\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\tMethodBinding[] methods = superType.unResolvedMethods();", "-\t\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "-\t\t\t\t\t\tMethodBinding inheritedMethod = methods[m];", "-\t\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\t\t\tif (existingMethods == null) {", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tint length = existingMethods.length;", "-\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "-\t\t\t\t\t\t\tfor (int e = 0; e < length; e++)", "-\t\t\t\t\t\t\t\tif (isInterfaceMethodImplemented(inheritedMethod, existingMethods[e], superType))", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod; // skip interface method with the same signature if visible to its declaringClass", "-\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "-\t\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "-\t\t\t\t\t}", "+\tfor (int i = 0; i < nextPosition; i++) {", "+\t\tsuperType = interfacesToVisit[i];", "+\t\tif (superType.isValidBinding()) {", "+\t\t\tif ((itsInterfaces = superType.superInterfaces()) != Binding.NO_SUPERINTERFACES) {", "+\t\t\t\tint itsLength = itsInterfaces.length;", "+\t\t\t\tif (nextPosition + itsLength >= interfacesToVisit.length)", "+\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);", "+\t\t\t\tnextInterface : for (int a = 0; a < itsLength; a++) {", "+\t\t\t\t\tReferenceBinding next = itsInterfaces[a];", "+\t\t\t\t\tfor (int b = 0; b < nextPosition; b++)", "+\t\t\t\t\t\tif (next == interfacesToVisit[b]) continue nextInterface;", "+\t\t\t\t\tinterfacesToVisit[nextPosition++] = next;", "+", "+\t\t\tMethodBinding[] methods = superType.unResolvedMethods();", "+\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "+\t\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "+\t\t\t\tif (existingMethods == null) {", "+\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "+\t\t\t\t} else {", "+\t\t\t\t\tint length = existingMethods.length;", "+\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "+\t\t\t\t\tfor (int e = 0; e < length; e++)", "+\t\t\t\t\t\tif (isInterfaceMethodImplemented(inheritedMethod, existingMethods[e], superType))", "+\t\t\t\t\t\t\tcontinue nextMethod; // skip interface method with the same signature if visible to its declaringClass", "+\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\texistingMethods[length] = inheritedMethod;", "+\t\t\t\t}", "+\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2811524c72967f387c237948ecde42d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "a8e18c32dc806d659bf5d8f2444be6f4268510d4", "commitAfterChange": "73072a493445774e509d0c21f3c359a527fa380b", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic void acceptInterface( \t\tchar[] packageName, \t\tchar[] interfaceName, \t\tint modifiers, \t\tAccessRestriction accessRestriction)", "signatureAfterChange": "  \tpublic void acceptType(char[] packageName, char[] typeName, int modifiers, AccessRestriction accessRestriction)", "diff": ["+\tpublic void acceptType(char[] packageName, char[] typeName, int modifiers, AccessRestriction accessRestriction) {", "+\t\t\t\tint length = 0;", "+\t\t\t\tint kind = modifiers & (IConstants.AccInterface+IConstants.AccEnum+IConstants.AccAnnotation);", "+\t\t\t\tswitch (kind) {", "+\t\t\t\t\tcase IConstants.AccAnnotation:", "+\t\t\t\t\tcase IConstants.AccAnnotation+IConstants.AccInterface:", "+\t\t\t\t\t\tchar[][] acceptedAnnotation = new char[2][];", "+\t\t\t\t\t\tacceptedAnnotation[0] = packageName;", "+\t\t\t\t\t\tacceptedAnnotation[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedAnnotations == null) {", "+\t\t\t\t\t\t\tthis.acceptedAnnotations = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedAnnotationsModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedAnnotationsCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedAnnotations.length;", "+\t\t\t\t\t\tif(length == this.acceptedAnnotationsCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedAnnotations, 0, this.acceptedAnnotations = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedAnnotationsModifiers, 0, this.acceptedAnnotationsModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedAnnotationsModifiers[this.acceptedAnnotationsCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedAnnotations[this.acceptedAnnotationsCount++] = acceptedAnnotation;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase IConstants.AccEnum:", "+\t\t\t\t\t\tchar[][] acceptedEnum = new char[2][];", "+\t\t\t\t\t\tacceptedEnum[0] = packageName;", "+\t\t\t\t\t\tacceptedEnum[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedEnums == null) {", "+\t\t\t\t\t\t\tthis.acceptedEnums = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedEnumsModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedEnumsCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedEnums.length;", "+\t\t\t\t\t\tif(length == this.acceptedEnumsCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedEnums, 0, this.acceptedEnums = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedEnumsModifiers, 0, this.acceptedEnumsModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedEnumsModifiers[this.acceptedEnumsCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedEnums[this.acceptedEnumsCount++] = acceptedEnum;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase IConstants.AccInterface:", "+\t\t\t\t\t\tchar[][] acceptedInterface= new char[2][];", "+\t\t\t\t\t\tacceptedInterface[0] = packageName;", "+\t\t\t\t\t\tacceptedInterface[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedInterfaces == null) {", "+\t\t\t\t\t\t\tthis.acceptedInterfaces = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedInterfacesModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedInterfacesCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedInterfaces.length;", "+\t\t\t\t\t\tif(length == this.acceptedInterfacesCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedInterfaces, 0, this.acceptedInterfaces = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedInterfacesModifiers, 0, this.acceptedInterfacesModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedInterfacesModifiers[this.acceptedInterfacesCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedInterfaces[this.acceptedInterfacesCount++] = acceptedInterface;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tchar[][] acceptedClass = new char[2][];", "+\t\t\t\t\t\tacceptedClass[0] = packageName;", "+\t\t\t\t\t\tacceptedClass[1] = typeName;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(this.acceptedClasses == null) {", "+\t\t\t\t\t\t\tthis.acceptedClasses = new char[10][][];", "+\t\t\t\t\t\t\tthis.acceptedClassesModifiers = new int[10];", "+\t\t\t\t\t\t\tthis.acceptedClassesCount = 0;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlength = this.acceptedClasses.length;", "+\t\t\t\t\t\tif(length == this.acceptedClassesCount) {", "+\t\t\t\t\t\t\tint newLength = (length + 1)* 2;", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedClasses, 0, this.acceptedClasses = new char[newLength][][], 0, length);", "+\t\t\t\t\t\t\tSystem.arraycopy(this.acceptedClasses, 0, this.acceptedClassesModifiers = new int[newLength], 0, length);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.acceptedClassesModifiers[this.acceptedClassesCount] = modifiers;", "+\t\t\t\t\t\tthis.acceptedClasses[this.acceptedClassesCount++] = acceptedClass;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\tthis.requestor.acceptType(", "-\t */", "-\tpublic void acceptInterface(", "-\t\tchar[] packageName,", "-\t\tchar[] interfaceName,", "-\t\tint modifiers,", "-\t\tAccessRestriction accessRestriction) {", "-", "-\t\tif (CharOperation.equals(interfaceName, this.selectedIdentifier)) {", "-\t\t\tif(mustQualifyType(packageName, interfaceName)) {", "-\t\t\t\tchar[][] acceptedInterface= new char[2][];", "-\t\t\t\tacceptedInterface[0] = packageName;", "-\t\t\t\tacceptedInterface[1] = interfaceName;", "-\t\t\t\t", "-\t\t\t\tif(this.acceptedInterfaces == null) {", "-\t\t\t\t\tthis.acceptedInterfaces = new char[10][][];", "-\t\t\t\t\tthis.acceptedInterfacesCount = 0;", "-\t\t\t\t}", "-\t\t\t\tint length = this.acceptedInterfaces.length;", "-\t\t\t\tif(length == this.acceptedInterfacesCount) {", "-\t\t\t\t\tSystem.arraycopy(this.acceptedInterfaces, 0, this.acceptedInterfaces = new char[(length + 1) * 2][][], 0, length);", "-\t\t\t\t}", "-\t\t\t\tthis.acceptedInterfaces[this.acceptedInterfacesCount++] = acceptedInterface;", "-\t\t\t\t", "-\t\t\t} else {", "-\t\t\t\tthis.noProposal = false;", "-\t\t\t\tthis.requestor.acceptInterface(", "-\t\t\t\t\tpackageName,", "-\t\t\t\t\tinterfaceName,", "+\t\t\t\t\tmodifiers,"]}], "num": 21661}