{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fb4f90b041e6abd40adba39151c91c49", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5077d0fd59cb46381e2bc332d5cfa5e2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic void generateArguments(MethodBinding binding, Expression[] arguments, BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateArguments(MethodBinding binding, Expression[] arguments, BlockScope currentScope, CodeStream codeStream)", "diff": ["+\t */", "+\t\t", "-\t\t\t// 5 possibilities exist for a call to the vararg method foo(int i, int ... value) : foo(1), foo(1, null), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})", "+\t\t\t// 5 possibilities exist for a call to the vararg method foo(int i, int ... value) : ", "+\t\t\t//      foo(1), foo(1, null), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})", "-\t\t\tint lastIndex = params.length - 1;", "-\t\t\tfor (int i = 0; i < lastIndex; i++) {", "+\t\t\tint paramLength = params.length;", "+\t\t\tint varArgIndex = paramLength - 1;", "+\t\t\tfor (int i = 0; i < varArgIndex; i++) {", "-\t\t\tArrayBinding varArgsType = (ArrayBinding) params[lastIndex]; // parameterType has to be an array type", "+\t\t\tArrayBinding varArgsType = (ArrayBinding) params[varArgIndex]; // parameterType has to be an array type", "-\t\t\tif (lastIndex < argLength) { // vararg argument was provided", "-\t\t\t\tif (params.length == argLength) {", "-\t\t\t\t\tTypeBinding lastType = arguments[lastIndex].resolvedType;", "-\t\t\t\t\tif (varArgsType.dimensions() == lastType.dimensions() || lastType == NullBinding) {", "-\t\t\t\t\t\t// called with matching array : foo(1, new int[] {1, 2}", "-\t\t\t\t\t\targuments[lastIndex].generateCode(currentScope, codeStream, true);", "-\t\t\t\t\t\treturn;", "+", "+\t\t\tgenerateVarargsArgument: {", "+\t\t\t\tif (argLength >= paramLength) {", "+\t\t\t\t\t// right number of arguments - could be inexact - pass argument as is", "+\t\t\t\t\tTypeBinding lastType = arguments[varArgIndex].resolvedType;", "+\t\t\t\t\tif (lastType == NullBinding || varArgsType.dimensions() == lastType.dimensions()) {", "+\t\t\t\t\t\t// foo(1, new int[]{2, 3}) or foo(1, null) --> last arg is passed as-is", "+\t\t\t\t\t\targuments[varArgIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\t\tbreak generateVarargsArgument;", "+\t\t\t\t\t// right number but not directly compatible or too many arguments - wrap extra into array", "+\t\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "+\t\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "+\t\t\t\t\tcodeStream.generateInlinedValue(argLength - varArgIndex);", "+\t\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "+\t\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "+\t\t\t\t\tfor (int i = varArgIndex; i < argLength; i++) {", "+\t\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\t\tcodeStream.generateInlinedValue(i - varArgIndex);", "+\t\t\t\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "+\t\t\t\t\t}", "+\t\t\t\t} else { // not enough arguments - pass extra empty array", "+\t\t\t\t\t// scenario: foo(1) --> foo(1, new int[0])", "+\t\t\t\t\t// generate code for an empty array of parameterType", "+\t\t\t\t\tcodeStream.generateInlinedValue(0);", "+\t\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "-\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "-\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "-\t\t\t\tcodeStream.generateInlinedValue(argLength - lastIndex);", "-\t\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "-\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "-\t\t\t\tfor (int i = 0, max = argLength - lastIndex; i < max; i++) {", "-\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\tcodeStream.generateInlinedValue(i);", "-\t\t\t\t\targuments[i + lastIndex].generateCode(currentScope, codeStream, true);", "-\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// generate code for an empty array of parameterType", "-\t\t\t\tcodeStream.generateInlinedValue(0);", "-\t\t\t\tcodeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array", "-\t\t} else if (arguments != null) {", "+\t\t} else if (arguments != null) { // standard generation for method arguments"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e39bf2b2992025cd65a84c7f43d27b8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "80adc997ad4594d86c098c1d65d4ab0307d988e5", "commitAfterChange": "bd9f1604b7023aa96308289af9053f02dd227d2f", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void generateArguments(MethodBinding binding, Expression[] arguments, BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateArguments(MethodBinding binding, Expression[] arguments, BlockScope currentScope, CodeStream codeStream)", "diff": ["+\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "-\t\t\tgenerateVarargsArgument: {", "-\t\t\t\tif (argLength >= paramLength) {", "-\t\t\t\t\t// right number of arguments - could be inexact - pass argument as is", "-\t\t\t\t\tTypeBinding lastType = arguments[varArgIndex].resolvedType;", "-\t\t\t\t\tif (lastType == NullBinding", "-\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "-\t\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType))) {", "-\t\t\t\t\t\t// foo(1, new int[]{2, 3}) or foo(1, null) --> last arg is passed as-is", "-\t\t\t\t\t\targuments[varArgIndex].generateCode(currentScope, codeStream, true);", "-\t\t\t\t\t\tbreak generateVarargsArgument;", "-\t\t\t\t\t}", "-\t\t\t\t\t// right number but not directly compatible or too many arguments - wrap extra into array", "-\t\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "-\t\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "-\t\t\t\t\tcodeStream.generateInlinedValue(argLength - varArgIndex);", "-\t\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "-\t\t\t\t\tint elementsTypeID = varArgsType.elementsType().id;", "-\t\t\t\t\tfor (int i = varArgIndex; i < argLength; i++) {", "-\t\t\t\t\t\tcodeStream.dup();", "-\t\t\t\t\t\tcodeStream.generateInlinedValue(i - varArgIndex);", "-\t\t\t\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "-\t\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "-\t\t\t\t\t}", "-\t\t\t\t} else { // not enough arguments - pass extra empty array", "-\t\t\t\t\t// scenario: foo(1) --> foo(1, new int[0])", "-\t\t\t\t\t// generate code for an empty array of parameterType", "-\t\t\t\t\tcodeStream.generateInlinedValue(0);", "-\t\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "+\t\t\tif (argLength > paramLength) {", "+\t\t\t\t// right number but not directly compatible or too many arguments - wrap extra into array", "+\t\t\t\t// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)", "+\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "+\t\t\t\tcodeStream.generateInlinedValue(argLength - varArgIndex);", "+\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "+\t\t\t\tfor (int i = varArgIndex; i < argLength; i++) {", "+\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\tcodeStream.generateInlinedValue(i - varArgIndex);", "+\t\t\t\t\targuments[i].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "+\t\t\t} else if (argLength == paramLength) {", "+\t\t\t\t// right number of arguments - could be inexact - pass argument as is", "+\t\t\t\tTypeBinding lastType = arguments[varArgIndex].resolvedType;", "+\t\t\t\tif (lastType == NullBinding", "+\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "+\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType))) {", "+\t\t\t\t\t// foo(1, new int[]{2, 3}) or foo(1, null) --> last arg is passed as-is", "+\t\t\t\t\targuments[varArgIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t\t} else {", "+\t\t\t\t\t// right number but not directly compatible or too many arguments - wrap extra into array", "+\t\t\t\t\t// need to gen elements into an array, then gen each remaining element into created array", "+\t\t\t\t\tcodeStream.generateInlinedValue(1);", "+\t\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array", "+\t\t\t\t\tcodeStream.dup();", "+\t\t\t\t\tcodeStream.generateInlinedValue(0);", "+\t\t\t\t\targuments[varArgIndex].generateCode(currentScope, codeStream, true);", "+\t\t\t\t\tcodeStream.arrayAtPut(elementsTypeID, false);", "+\t\t\t\t}", "+\t\t\t} else { // not enough arguments - pass extra empty array", "+\t\t\t\t// scenario: foo(1) --> foo(1, new int[0])", "+\t\t\t\t// generate code for an empty array of parameterType", "+\t\t\t\tcodeStream.generateInlinedValue(0);", "+\t\t\t\tcodeStream.newArray(varArgsType); // create a mono-dimensional array"]}], "num": 2753}