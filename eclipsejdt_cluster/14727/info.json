{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a216e8564128c522e8b58f9028438bf6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64a5dde86c649cbe76d87790de6b1cc3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java", "commitBeforeChange": "d5a32e245b27c645dcf70347396d7253765682d3", "commitAfterChange": "562bd70d52b78a80d9ea0f036f9a91cfb91468db", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void recordUsingNullReference(Scope scope, LocalVariableBinding local, \t\t\tASTNode location, int checkType, FlowInfo flowInfo)", "signatureAfterChange": "  \tpublic void recordUsingNullReference(Scope scope, LocalVariableBinding local, \t\t\tASTNode location, int checkType, FlowInfo flowInfo)", "diff": ["+\t\t\t// if reference is being recorded inside an assert, we will not raise redundant null check warnings", "+\t\t\tcheckType |= (this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING);", "+\t\t\tint checkTypeWithoutHideNullWarning = checkType & ~FlowContext.HIDE_NULL_COMPARISON_WARNING_MASK;", "-\t\t\t\tswitch (checkType) {", "+\t\t\t\tswitch (checkTypeWithoutHideNullWarning) {", "-\t\t\t\t\t\t\tif (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\tif (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "+\t\t\t\t\t\t\t\tif ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, reference);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "+\t\t\t\t\t\t\t} else if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {", "+\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, reference);", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\tswitch(checkType & CONTEXT_MASK) {", "+\t\t\t\t\t\t\tswitch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\t\t\tif ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, reference);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, reference);", "+\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\tswitch(checkType & CONTEXT_MASK) {", "+\t\t\t\t\t\t\tswitch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\tswitch (checkType) {", "+\t\t\t\tswitch (checkTypeWithoutHideNullWarning) {", "-\t\t\t\t\t\t\tif (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\tif (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {", "+\t\t\t\t\t\t\t\tif ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNonNullComparedToNull(local, location);", "+\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\tswitch(checkType & CONTEXT_MASK) {", "+\t\t\t\t\t\t\tswitch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "+\t\t\t\t\t\t\t\t\tif ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tflowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, reference);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tif (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {", "-\t\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().localVariableNullComparedToNonNull(local, reference);", "+\t\t\t\t\t\t\t\t\tflowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);", "-\t\t\t\t\t\t\tswitch(checkType & CONTEXT_MASK) {", "+\t\t\t\t\t\t\tswitch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t\t\t\t\t\t\tif (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "+\t\t\t\t\t\t\t\t\tif (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning", "-\t\t\t// if the contention is inside assert statement, we want to avoid null warnings only in case of", "-\t\t\t// comparisons and not in case of assignment, instanceof, or may be null.", "-\t\t\tif(((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) || checkType == MAY_NULL", "-\t\t\t\t\t|| (checkType & CONTEXT_MASK) == FlowContext.IN_ASSIGNMENT", "-\t\t\t\t\t|| (checkType & CONTEXT_MASK) == FlowContext.IN_INSTANCEOF) {", "-\t\t\t\trecordNullReference(local, location, checkType);", "-\t\t\t}", "+\t\t\trecordNullReference(local, location, checkType);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a91cc24a82867db23462e5394e003be4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "c9df47e6bc4127d80d1e16ea8353f464e792fda3", "commitAfterChange": "514d8e9afb885d3be64fa67a03a4dd281867840f", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic MethodBinding findMethod( \t\tReferenceBinding receiverType, \t\tchar[] selector, \t\tTypeBinding[] argumentTypes, \t\tInvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t// Internal use only", "-\tpublic MethodBinding findMethod(", "-\t\tReferenceBinding receiverType,", "-\t\tchar[] selector,", "-\t\tTypeBinding[] argumentTypes,", "-\t\tInvocationSite invocationSite) {", "-", "+\t// Internal use only - use findMethod()", "+\tpublic MethodBinding findMethod(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "-\t\tMethodBinding matchingMethod = null;", "-\t\tObjectVector found = new ObjectVector(); //TODO (kent) should rewrite to remove #matchingMethod since found is allocated anyway", "-", "+\t\tObjectVector found = new ObjectVector(3);", "+\t\tlong complianceLevel = compilerOptions().complianceLevel;", "-\t\t\tint currentLength = currentMethods.length;", "-\t\t\tif (currentLength == 1) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 1) {", "+\t\t\tif (currentMethods.length > 0)", "-\t\t\t}", "-\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);", "+\t\t\tfindMethodInSuperInterfaces(currentType, selector, found);", "-\t\tboolean isCompliant14 = compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4;", "+\t\tboolean isCompliant14 = compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4;", "-", "-\t\t\tif (isCompliant14 && (mustBePublic || matchingMethod != null || found.size > 0)) {", "-\t\t\t\tnextMethod: for (int i = 0, l = currentLength; i < l; i++) { // currentLength can be modified inside the loop", "-\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "-\t\t\t\t\tif (mustBePublic && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "-\t\t\t\t\t\tcurrentLength--;", "-\t\t\t\t\t\tcurrentMethods[i] = null;", "-\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t}", "-", "-\t\t\t\t\t// if 1.4 compliant, must filter out redundant protected methods from superclasses", "-\t\t\t\t\t// protected method need to be checked only - default access is already dealt with in #canBeSeen implementation", "-\t\t\t\t\t// when checking that p.C -> q.B -> p.A cannot see default access members from A through B.", "-\t\t\t\t\t// if ((currentMethod.modifiers & AccProtected) == 0) continue nextMethod;", "-\t\t\t\t\t// BUT we can also ignore any overridden method since we already know the better match (fixes 80028)", "-\t\t\t\t\tif (matchingMethod != null) {", "-\t\t\t\t\t\tif (currentMethod.areParametersEqual(matchingMethod)) {", "-\t\t\t\t\t\t\t// TODO (kent) Add cases that justify these tests", "-\t\t\t\t\t\t\tif (matchingMethod.typeVariables != Binding.NO_TYPE_VARIABLES && invocationSite.genericTypeArguments() == null)", "-\t\t\t\t\t\t\t\tcontinue nextMethod; // keep inherited substituted methods to detect anonymous errors", "-\t\t\t\t\t\t\tif (matchingMethod.hasSubstitutedParameters() && !currentMethod.original().areParametersEqual(matchingMethod.original()))", "-\t\t\t\t\t\t\t\tcontinue nextMethod; // keep inherited substituted methods to detect anonymous errors", "+\t\t\tif (currentLength > 0) {", "+\t\t\t\tif (isCompliant14 && (mustBePublic || found.size > 0)) {", "+\t\t\t\t\tnextMethod: for (int i = 0, l = currentLength; i < l; i++) { // currentLength can be modified inside the loop", "+\t\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t\tif (currentMethod == null) continue nextMethod;", "+\t\t\t\t\t\tif (mustBePublic && !currentMethod.isPublic()) { // only public methods from Object are visible to interface receiverTypes", "-\t\t\t\t\t\t\tcurrentMethods[i] = null; // discard this match", "+\t\t\t\t\t\t\tcurrentMethods[i] = null;", "-\t\t\t\t\t} else {", "+", "+\t\t\t\t\t\t// if 1.4 compliant, must filter out redundant protected methods from superclasses", "+\t\t\t\t\t\t// protected method need to be checked only - default access is already dealt with in #canBeSeen implementation", "+\t\t\t\t\t\t// when checking that p.C -> q.B -> p.A cannot see default access members from A through B.", "+\t\t\t\t\t\t// if ((currentMethod.modifiers & AccProtected) == 0) continue nextMethod;", "+\t\t\t\t\t\t// BUT we can also ignore any overridden method since we already know the better match (fixes 80028)", "-\t\t\t\t\t\t\tif (((MethodBinding) found.elementAt(j)).areParametersEqual(currentMethod)) {", "+\t\t\t\t\t\t\tMethodBinding matchingMethod = (MethodBinding) found.elementAt(j);", "+\t\t\t\t\t\t\tif (currentMethod.areParametersEqual(matchingMethod)) {", "+\t\t\t\t\t\t\t\tif (complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t\t\t\t\t\t\tif (matchingMethod.typeVariables != Binding.NO_TYPE_VARIABLES && invocationSite.genericTypeArguments() == null)", "+\t\t\t\t\t\t\t\t\t\tcontinue nextMethod; // keep inherited substituted methods to detect anonymous errors", "+\t\t\t\t\t\t\t\t\tif (matchingMethod.hasSubstitutedParameters() && !currentMethod.original().areParametersEqual(matchingMethod.original()))", "+\t\t\t\t\t\t\t\t\t\tcontinue nextMethod; // keep inherited substituted methods to detect anonymous errors", "+\t\t\t\t\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {", "-\t\t\t\tmatchingMethod = currentMethods[0];", "-\t\t\t} else if (currentLength > 0) {", "-\t\t\t\tif (matchingMethod != null) {", "-\t\t\t\t\tfound.add(matchingMethod);", "-\t\t\t\t\tmatchingMethod = null;", "-\t\t\t\t}", "-\t\t\t\t// append currentMethods, filtering out null entries", "-\t\t\t\tint maxMethod = currentMethods.length;", "-\t\t\t\tif (maxMethod == currentLength) { // no method was eliminated for 1.4 compliance (see above)", "-\t\t\t\t\tfound.addAll(currentMethods);", "-\t\t\t\t} else {", "-\t\t\t\t\tfor (int i = 0, max = currentMethods.length; i < max; i++) {", "-\t\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "-\t\t\t\t\t\tif (currentMethod != null) found.add(currentMethod);", "+\t\t\t\tif (currentLength > 0) {", "+\t\t\t\t\t// append currentMethods, filtering out null entries", "+\t\t\t\t\tif (currentMethods.length == currentLength) {", "+\t\t\t\t\t\tfound.addAll(currentMethods);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tfor (int i = 0, max = currentMethods.length; i < max; i++) {", "+\t\t\t\t\t\t\tMethodBinding currentMethod = currentMethods[i];", "+\t\t\t\t\t\t\tif (currentMethod != null)", "+\t\t\t\t\t\t\t\tfound.add(currentMethod);", "+\t\t\t\t\t\t}", "-\t\tboolean checkedMatchingMethod = false; // is matchingMethod meeting argument expectation ?", "-\t\t\t\t\t\tswitch (candidatesCount) {", "-\t\t\t\t\t\t\tcase 0: ", "-\t\t\t\t\t\t\t\tmatchingMethod = compatibleMethod; // if only one match, reuse matchingMethod", "-\t\t\t\t\t\t\t\tcheckedMatchingMethod = true; // matchingMethod is known to exist and match params here", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tcase 1:", "-\t\t\t\t\t\t\t\tcandidates = new MethodBinding[foundSize]; // only lazily created if more than one match", "-\t\t\t\t\t\t\t\tcandidates[0] = matchingMethod; // copy back", "-\t\t\t\t\t\t\t\tmatchingMethod = null;", "-\t\t\t\t\t\t\t\t// fall through", "-\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\tcandidates[candidatesCount] = compatibleMethod;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcandidatesCount++;", "+\t\t\t\t\t\tif (candidatesCount == 0)", "+\t\t\t\t\t\t\tcandidates = new MethodBinding[foundSize];", "+\t\t\t\t\t\tcandidates[candidatesCount++] = compatibleMethod;", "-\t\tif (candidatesCount > 0)", "-\t\t\tproblemMethod = null; // forget the problem method if candidates were found", "-", "-\t\t// if only one matching method left (either from start or due to elimination of rivals), then match is in matchingMethod", "-\t\tif (matchingMethod != null) {", "-\t\t\tif (!checkedMatchingMethod) {", "-\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(matchingMethod, argumentTypes, invocationSite);", "-\t\t\t\tif (compatibleMethod != null) {", "-\t\t\t\t\tif (compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\tmatchingMethod = compatibleMethod;", "-\t\t\t\t\t\tcheckedMatchingMethod = true;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tproblemMethod = compatibleMethod;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (checkedMatchingMethod) {", "-\t\t\t\t// (if no default abstract) must explicitly look for one instead, which could be a better match", "-\t\t\t\tif (!matchingMethod.canBeSeenBy(receiverType, invocationSite, this)) {", "-\t\t\t\t\t// ignore matching method (to be consistent with multiple matches, none visible (matching method is then null)", "-\t\t\t\t\tMethodBinding interfaceMethod =", "-\t\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, null, found);\t\t\t\t\t\t", "-\t\t\t\t\tif (interfaceMethod != null) return interfaceMethod;", "-\t\t\t\t\tunitScope.recordTypeReferences(matchingMethod.thrownExceptions);", "-\t\t\t\t\treturn matchingMethod;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t// when receiverType is abstract then need to find possible matches in interfaces", "-\t\t\tif (receiverType.isAbstract() || receiverType.isTypeVariable())", "-\t\t\t\tmatchingMethod =", "-\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "-\t\t\tif (matchingMethod != null) return matchingMethod;", "-\t\t\treturn problemMethod;", "-\t\t}", "-\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "+\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found);", "-\t\t\tif (problemMethod != null) return problemMethod;", "+\t\t\tif (problemMethod != null) return problemMethod;", "-\t\t\treturn bestGuess;", "-\t\t}", "-", "-\t\t// check for duplicate parameterized methods", "-\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "-\t\t\tfor (int i = 0; i < candidatesCount; i++) {", "-\t\t\t\tMethodBinding current = candidates[i];", "-\t\t\t\tif (current instanceof ParameterizedGenericMethodBinding)", "-\t\t\t\t\tcurrent = ((ParameterizedGenericMethodBinding) current).originalMethod;", "-\t\t\t\tif (current instanceof ParameterizedMethodBinding)", "-\t\t\t\t\tfor (int j = i + 1; j < candidatesCount; j++)", "-\t\t\t\t\t\tif (current.declaringClass == candidates[j].declaringClass && current.areParametersEqual(candidates[j]))", "-\t\t\t\t\t\t\treturn new ProblemMethodBinding(candidates[i].selector, candidates[i].parameters, ProblemReasons.Ambiguous);", "-\t\t\t}", "+\t\t\treturn new ProblemMethodBinding(bestGuess, bestGuess.selector, argumentTypes, ProblemReasons.NotFound);", "+\t\t\tif (isCompliant14 && (receiverType.isAbstract() || receiverType.isTypeVariable())) {", "+\t\t\t\tMethodBinding interfaceMethod =", "+\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found);", "+\t\t\t\tif (interfaceMethod != null) {", "+\t\t\t\t\tcandidates = new MethodBinding[] {candidates[0], interfaceMethod};", "+\t\t\t\t\treturn mostSpecificMethodBinding(candidates, 2, argumentTypes, invocationSite, receiverType);", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);", "+\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found);", "-\t\tif (isCompliant14) {", "-\t\t\tmatchingMethod = mostSpecificMethodBinding(candidates, visiblesCount, argumentTypes, invocationSite, receiverType);", "-\t\t\tif (matchingMethod.isValidBinding() && parameterCompatibilityLevel(matchingMethod, argumentTypes) > COMPATIBLE) {", "+", "+\t\tif (complianceLevel <= ClassFileConstants.JDK1_3) {", "+\t\t\tReferenceBinding declaringClass = candidates[0].declaringClass;", "+\t\t\treturn !declaringClass.isInterface()", "+\t\t\t\t? mostSpecificClassMethodBinding(candidates, visiblesCount, invocationSite)", "+\t\t\t\t: mostSpecificInterfaceMethodBinding(candidates, visiblesCount, invocationSite);", "+\t\t}", "+", "+\t\t// check for duplicate parameterized methods", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\tfor (int i = 0; i < candidatesCount; i++) {", "+\t\t\t\tMethodBinding current = candidates[i];", "+\t\t\t\tif (current instanceof ParameterizedGenericMethodBinding)", "+\t\t\t\t\tcurrent = ((ParameterizedGenericMethodBinding) current).originalMethod;", "+\t\t\t\tif (current instanceof ParameterizedMethodBinding)", "+\t\t\t\t\tfor (int j = i + 1; j < candidatesCount; j++)", "+\t\t\t\t\t\tif (current.declaringClass == candidates[j].declaringClass && current.areParametersEqual(candidates[j]))", "+\t\t\t\t\t\t\treturn new ProblemMethodBinding(candidates[i].selector, candidates[i].parameters, ProblemReasons.Ambiguous);", "+\t\t\t}", "+\t\t}", "+", "+\t\tMethodBinding mostSpecificMethod = mostSpecificMethodBinding(candidates, visiblesCount, argumentTypes, invocationSite, receiverType);", "+\t\tif (complianceLevel >= ClassFileConstants.JDK1_5", "+\t\t\t&& mostSpecificMethod.isValidBinding()", "+\t\t\t&& parameterCompatibilityLevel(mostSpecificMethod, argumentTypes) > COMPATIBLE) {", "-\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, new ObjectVector());", "+\t\t\t\t\tfindDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found);", "-\t\t\t}", "-\t\t\treturn matchingMethod;", "-\t\tReferenceBinding declaringClass = candidates[0].declaringClass;", "-\t\treturn !declaringClass.isInterface()", "-\t\t\t? mostSpecificClassMethodBinding(candidates, visiblesCount, invocationSite)", "-\t\t\t: mostSpecificInterfaceMethodBinding(candidates, visiblesCount, invocationSite);", "+\t\treturn mostSpecificMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c827978e6f6f7620f1dbeb51c3068aa9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "dbb21f9a082cc8b4fc9a756e4b7778384b3f408c", "commitAfterChange": "bbd2ac48b173a123c7419ce013244d878b152c22", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 13, "signatureBeforeChange": "  void compareFormattedSource() throws IOException, Exception", "signatureAfterChange": "  void compareFormattedSource() throws IOException, Exception", "diff": ["-\tDefaultCodeFormatter codeFormatter = codeFormatter();", "-\t\tif (\"comments\".equals(COMPARE)) {", "-\t\t\tString[] oldFormattedComments = formattedComments(source, true);", "-\t\t\tString[] newFormattedComments = formattedComments(source, false);", "-\t\t\tint length = oldFormattedComments == null ? 0 : oldFormattedComments.length;", "-\t\t\tthis.abortOnFailure = false;", "-\t\t\tassertEquals(\"Unexpected number of comments!\", length, newFormattedComments == null ? 0 : newFormattedComments.length);", "-\t\t\tfor (int i=0; i<length; i++) {", "-\t\t\t\tString oldComment = oldFormattedComments[i];", "-\t\t\t\tString newComment = newFormattedComments[i];", "-\t\t\t\tif (oldComment == null) {", "-\t\t\t\t\tassertNull(\"Unexpected non-null new comment\", newComment);", "-\t\t\t\t} else {", "-\t\t\t\t\tString expected = cleanAllKnownDifferences(oldComment);", "-\t\t\t\t\tString actual = cleanAllKnownDifferences(newComment);", "-\t\t\t\t\tif (!expected.equals(actual)) {", "-\t\t\t\t\t\tString actualResult = runFormatter(codeFormatter, source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "-\t\t\t\t\t\tString expectedResult = expectedFormattedSource(source);", "-\t\t\t\t\t\tassertEquals(\"Unexpected difference with formatted comment \"+(i+1), Util.convertToIndependantLineDelimiter(expectedResult), Util.convertToIndependantLineDelimiter(actualResult));", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t// Format the source", "+\t\tString actualResult = runFormatter(codeFormatter(), source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "+", "+\t\t// Look for output to compare with", "+\t\tFile outputFile = new Path(OUTPUT_DIR.getPath()).append(this.path).toFile();", "+\t\tif (COMPARE) {", "+\t\t\tString expectedResult = new String(org.eclipse.jdt.internal.compiler.util.Util.getFileCharContent(outputFile, null));", "+\t\t\ttry {", "+\t\t\t\tassertSourceEquals(\"Unexpected format output!\", expectedResult, actualResult);", "+\t\t\t}", "+\t\t\tcatch (ComparisonFailure cf) {", "+\t\t\t\tthis.failureIndex = COMPARISON_FAILURE;", "+//\t\t\t\tFAILURES[COMPARISON_FAILURE].failures.add(this.path);", "+\t\t\t\tthrow cf;", "+\t\t\t}", "+\t\t\tcatch (AssertionFailedError afe) {", "+\t\t\t\tthis.failureIndex = COMPARISON_FAILURE;", "+//\t\t\t\tFAILURES[COMPARISON_FAILURE].failures.add(this.path);", "+\t\t\t\tthrow afe;", "-\t\t\tString actualResult = runFormatter(codeFormatter, source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "-\t\t\tif (!this.hasSpaceFailure && \"true\".equals(COMPARE)) {", "-\t\t\t\tString expectedResult = expectedFormattedSource(source);", "-\t\t\t\tassertLineEquals(actualResult, source, expectedResult, false);", "-\t\t\t}", "+\t\t\toutputFile.getParentFile().mkdirs();", "+\t\t\tUtil.writeToFile(actualResult, outputFile.getAbsolutePath());"]}], "num": 14727}