{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "956f64670e8f178715ad5eba09781cf0", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1621be3bcf8d3147a28b6227002484ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java", "commitBeforeChange": "e5bb4bddaa8ae27dfddec859067bcb3df83df4dc", "commitAfterChange": "65877d9109defab8c1c7191e1a9530b8bc8f9b43", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo)", "signatureAfterChange": "  \tpublic void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo flowInfo)", "diff": ["+\t\t\t\t\t// if this method uses a type parameter declared by the declaring class,", "+\t\t\t\t\t// it can't be static. https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682", "+\t\t\t\t\tif (this.arguments[i].binding != null && (this.arguments[i].binding.type instanceof TypeVariableBinding)) {", "+\t\t\t\t\t\tBinding declaringElement = ((TypeVariableBinding)this.arguments[i].binding.type).declaringElement;", "+\t\t\t\t\t\tif (this.binding != null && this.binding.declaringClass == declaringElement)", "+\t\t\t\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {", "+\t\t\t\t// method of a non-static member type can't be static.", "+\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t} else {", "+\t\t\t\t// method with empty body should not be flagged as static.", "+\t\t\t\tthis.bits &= ~ASTNode.CanBeStatic;", "+\t\t\t// check if the method could have been static", "+\t\t\tif (!this.binding.isStatic() && (this.bits & ASTNode.CanBeStatic) != 0) {", "+\t\t\t\tif(!this.binding.isOverriding() && !this.binding.isImplementing()) {", "+\t\t\t\t\tif (this.binding.isPrivate() || this.binding.isFinal() || this.binding.declaringClass.isFinal()) {", "+\t\t\t\t\t\tthis.scope.problemReporter().methodCanBeDeclaredStatic(this);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tthis.scope.problemReporter().methodCanBePotentiallyDeclaredStatic(this);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "313373deb58617b9edab7a8395d34dfd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\tif (receiverType == null) break checkParameterizedAllocation;", "+\t\t\t\t\tif (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;", "-\t\tif (receiverType == null) {", "+\t\tif (receiverType == null || !receiverType.isValidBinding()) {", "+\t\t", "+\t\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "-\t\t\t\tTypeReference typeReference = this.typeArguments[i];\t\t\t\t", "-\t\t\t\tTypeBinding argType = typeReference.resolveType(scope, true /* check bounds*/);", "-\t\t\t\tif (argType == null) {", "-\t\t\t\t\tif (typeReference instanceof Wildcard) {", "-\t\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t\t\t}", "-\t\t\t\t\treturn null; // error already reported", "+\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\targHasError = true;", "-\t\t\t\tthis.genericTypeArguments[i] = argType;", "+\t\t\t\tif (argHasError && typeReference instanceof Wildcard) {", "+\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (argHasError) {", "+\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t\t", "+\t\t\t\treturn null;", "+\t", "-\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "-\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "-\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "-\t\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "-\t\t\t\t}", "-\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this);", "-\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\t\t\t\tif (closestMatch != null) {", "-\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "-\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.binding = closestMatch;", "-\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "-\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "-\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tif (receiverType.isValidBinding()) {", "+\t\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "+\t\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "+\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this);", "+\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\treturn null;", "+\t\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "+\t\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\t\treturn null;", "+\t\t\t\t}\t\t\t\t\t", "-", "+\t\t\tif ((this.binding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "+\t\t\t}", "-\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance);", "+\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);", "-\t\t\tsuperType = new ProblemReferenceBinding(superType.sourceName(), superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\tsuperType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);", "+\t\t\tif (this.type != null && !this.type.resolvedType.isValidBinding()) {", "+\t\t\t\t// problem already got signaled on type reference, do not report secondary problem", "+\t\t\t\treturn null;", "+\t\t\t}\t\t", "+\t\t}", "+\t\tif ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tscope.problemReporter().missingTypeInConstructor(this, inheritedBinding);", "-\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance);", "+\t\t\t\tscope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cc5efa13ec57ca5e17bfcd33973235bd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\tif (!((LocalVariableBinding) this.binding).isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "-\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal(", "-\t\t\t\t\t\t\t(LocalVariableBinding) this.binding,", "-\t\t\t\t\t\t\tthis);", "+\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) this.binding;", "+\t\t\t\t\tif (!local.isFinal() && ((this.bits & ASTNode.DepthMASK) != 0))", "+\t\t\t\t\t\tscope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding) this.binding, this);", "-\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (local.type != null && (local.type.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\t// only complain if field reference (for local, its type got flagged already)", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (this.resolvedType != null ", "+\t\t\t\t\t\t\t&& (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\tFieldBinding lastField = this.otherBindings[this.otherBindings.length - 1];", "+\t\t\t\t\t\tscope.problemReporter().invalidField(this, new ProblemFieldBinding(lastField.declaringClass, lastField.name, ProblemReasons.NotFound), this.tokens.length, this.resolvedType.leafComponentType());", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn this.resolvedType;\t\t\t\t\t", "-\t\t\t\t\t", "-\t\t\t\t\treturn this.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tthis.resolvedType = getOtherFieldBindings(scope);", "+\t\t\t\t\tif (this.resolvedType != null ", "+\t\t\t\t\t\t\t&& (this.resolvedType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\t\t\tFieldBinding lastField = this.indexOfFirstFieldBinding == this.tokens.length ? (FieldBinding)this.binding : this.otherBindings[this.otherBindings.length - 1];", "+\t\t\t\t\t\tscope.problemReporter().invalidField(this, new ProblemFieldBinding(lastField.declaringClass, lastField.name, ProblemReasons.NotFound), this.tokens.length, this.resolvedType.leafComponentType());", "+\t\t\t\t\t\treturn null;", "+\t\t\t\t\t}", "+\t\t\t\t\treturn this.resolvedType;"]}], "num": 4992}