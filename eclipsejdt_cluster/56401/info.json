{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "744442838a52c7cb0d446409697ffb62", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1cf649673d686453c4c349e815dbc679", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java", "commitBeforeChange": "8e8664655ac66e3f161f9980a96f44314418e85c", "commitAfterChange": "76a2ec884825e9edb380555c61500f23750ece32", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic void finalizeProblems()", "signatureAfterChange": "  \tpublic void finalizeProblems()", "diff": ["+\t\tCompilerOptions options = scope.compilerOptions();", "+\t\tboolean hasErrors = false;", "-\t\t\tlong problemIrritant = ProblemReporter.getIrritant(problemID);", "-\t\t\tboolean isWarning = problem.isWarning();", "+\t\t\tif (problem.isError()) {", "+\t\t\t\tif (problemID != IProblem.UnusedWarningToken) {", "+\t\t\t\t// tolerate unused warning tokens which were promoted as errors", "+\t\t\t\t\thasErrors = true;", "+\t\t\t\t}", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tlong irritant = ProblemReporter.getIrritant(problemID);", "-\t\t\t\tif (isWarning) {", "-\t\t\t\t\tif ((problemIrritant & this.suppressWarningIrritants[iSuppress]) == 0)", "-\t\t\t\t\t\tcontinue nextSuppress;", "-\t\t\t\t\t// discard suppressed warning", "-\t\t\t\t\tremoved++;", "-\t\t\t\t\tproblems[iProblem] = null;", "-\t\t\t\t\tif (compilationResult.problemsMap != null) compilationResult.problemsMap.remove(problem);", "-\t\t\t\t\tif (compilationResult.firstErrors != null) compilationResult.firstErrors.remove(problem);", "-\t\t\t\t\tfoundIrritants[iSuppress] |= problemIrritant;", "-\t\t\t\t\tcontinue nextProblem;", "-\t\t\t\t} else {", "-\t\t\t\t\t// any error may prevent further warnings to be emitted, hence shouldn't report unused warning tokens if in same scope", "-\t\t\t\t\tfoundIrritants[iSuppress] = this.suppressWarningIrritants[iSuppress]; // treat as used", "-\t\t\t\t\tcontinue nextSuppress;\t\t\t\t\t", "-\t\t\t\t}", "+\t\t\t\tif ((irritant & this.suppressWarningIrritants[iSuppress]) == 0)", "+\t\t\t\t\tcontinue nextSuppress;", "+\t\t\t\t// discard suppressed warning", "+\t\t\t\tremoved++;", "+\t\t\t\tproblems[iProblem] = null;", "+\t\t\t\tif (compilationResult.problemsMap != null) compilationResult.problemsMap.remove(problem);", "+\t\t\t\tif (compilationResult.firstErrors != null) compilationResult.firstErrors.remove(problem);", "+\t\t\t\tfoundIrritants[iSuppress] |= irritant;", "+\t\t\t\tcontinue nextProblem;", "-\t\t// flag SuppressWarnings which had no effect", "-\t\tif (scope.compilerOptions().getSeverity(CompilerOptions.UnusedWarningToken) != ProblemSeverities.Ignore) {", "-\t\t\tfor (int iSuppress = 0, suppressCount = this.suppressWarningsCount; iSuppress < suppressCount; iSuppress++) {", "-\t\t\t\tAnnotation annotation = this.suppressWarningAnnotations[iSuppress];", "-\t\t\t\tif (annotation == null) continue; // implicit annotation", "-\t\t\t\tlong irritants = this.suppressWarningIrritants[iSuppress];", "-\t\t\t\tif (~irritants == 0) continue; // @SuppressWarnings(\"all\") also suppresses unused warning token", "-\t\t\t\tif (irritants != foundIrritants[iSuppress]) { // mismatch, some warning tokens were unused", "-\t\t\t\t\tMemberValuePair[] pairs = annotation.memberValuePairs();", "-\t\t\t\t\tpairLoop: for (int iPair = 0, pairCount = pairs.length; iPair < pairCount; iPair++) {", "-\t\t\t\t\t\tMemberValuePair pair = pairs[iPair];", "-\t\t\t\t\t\tif (CharOperation.equals(pair.name, TypeConstants.VALUE)) {", "-\t\t\t\t\t\t\tExpression value = pair.value;", "-\t\t\t\t\t\t\tif (value instanceof ArrayInitializer) {", "-\t\t\t\t\t\t\t\tArrayInitializer initializer = (ArrayInitializer) value;", "-\t\t\t\t\t\t\t\tExpression[] inits = initializer.expressions;", "-\t\t\t\t\t\t\t\tif (inits != null) {", "-\t\t\t\t\t\t\t\t\tfor (int iToken = 0, tokenCount = inits.length; iToken < tokenCount; iToken++) {", "-\t\t\t\t\t\t\t\t\t\tConstant cst = inits[iToken].constant;", "-\t\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == TypeIds.T_JavaLangString) {", "-\t\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "-\t\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t// flag SuppressWarnings which had no effect (only if no (mandatory) error got detected within unit", "+\t\tif (!hasErrors) {", "+\t\t\tint severity = options.getSeverity(CompilerOptions.UnusedWarningToken);", "+\t\t\tif (severity != ProblemSeverities.Ignore) {", "+\t\t\t\tboolean unusedWarningTokenIsWarning = (severity & ProblemSeverities.Error) == 0;", "+\t\t\t\tfor (int iSuppress = 0, suppressCount = this.suppressWarningsCount; iSuppress < suppressCount; iSuppress++) {", "+\t\t\t\t\tAnnotation annotation = this.suppressWarningAnnotations[iSuppress];", "+\t\t\t\t\tif (annotation == null) continue; // implicit annotation", "+\t\t\t\t\tlong irritants = this.suppressWarningIrritants[iSuppress];", "+\t\t\t\t\tif (unusedWarningTokenIsWarning && ~irritants == 0) continue; // @SuppressWarnings(\"all\") also suppresses unused warning token", "+\t\t\t\t\tif (irritants != foundIrritants[iSuppress]) { // mismatch, some warning tokens were unused", "+\t\t\t\t\t\tMemberValuePair[] pairs = annotation.memberValuePairs();", "+\t\t\t\t\t\tpairLoop: for (int iPair = 0, pairCount = pairs.length; iPair < pairCount; iPair++) {", "+\t\t\t\t\t\t\tMemberValuePair pair = pairs[iPair];", "+\t\t\t\t\t\t\tif (CharOperation.equals(pair.name, TypeConstants.VALUE)) {", "+\t\t\t\t\t\t\t\tExpression value = pair.value;", "+\t\t\t\t\t\t\t\tif (value instanceof ArrayInitializer) {", "+\t\t\t\t\t\t\t\t\tArrayInitializer initializer = (ArrayInitializer) value;", "+\t\t\t\t\t\t\t\t\tExpression[] inits = initializer.expressions;", "+\t\t\t\t\t\t\t\t\tif (inits != null) {", "+\t\t\t\t\t\t\t\t\t\tfor (int iToken = 0, tokenCount = inits.length; iToken < tokenCount; iToken++) {", "+\t\t\t\t\t\t\t\t\t\t\tConstant cst = inits[iToken].constant;", "+\t\t\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == TypeIds.T_JavaLangString) {", "+\t\t\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "+\t\t\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tif (unusedWarningTokenIsWarning) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tint start = value.sourceStart, end = value.sourceEnd;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong position = this.suppressWarningScopePositions[jSuppress];", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint startSuppress = (int) (position >>> 32);", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint endSuppress = (int) position;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (start < startSuppress) continue nextSuppress;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end > endSuppress) continue nextSuppress;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (~this.suppressWarningIrritants[jSuppress] == 0) break pairLoop; // suppress all?", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(inits[iToken]);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tConstant cst = value.constant;", "+\t\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == T_JavaLangString) {", "+\t\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "+\t\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "+\t\t\t\t\t\t\t\t\t\t\tif (unusedWarningTokenIsWarning) {", "-\t\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(inits[iToken]);", "+\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(value);", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}\t", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tConstant cst = value.constant;", "-\t\t\t\t\t\t\t\tif (cst != Constant.NotAConstant && cst.typeID() == T_JavaLangString) {", "-\t\t\t\t\t\t\t\t\tlong irritant = CompilerOptions.warningTokenToIrritant(cst.stringValue());", "-\t\t\t\t\t\t\t\t\tif (irritant != 0 && (foundIrritants[iSuppress] & irritant) == 0) {", "-\t\t\t\t\t\t\t\t\t\tint start = value.sourceStart, end = value.sourceEnd;", "-\t\t\t\t\t\t\t\t\t\tnextSuppress: for (int jSuppress = iSuppress - 1; jSuppress >= 0; jSuppress--) {", "-\t\t\t\t\t\t\t\t\t\t\tlong position = this.suppressWarningScopePositions[jSuppress];", "-\t\t\t\t\t\t\t\t\t\t\tint startSuppress = (int) (position >>> 32);", "-\t\t\t\t\t\t\t\t\t\t\tint endSuppress = (int) position;", "-\t\t\t\t\t\t\t\t\t\t\tif (start < startSuppress) continue nextSuppress;", "-\t\t\t\t\t\t\t\t\t\t\tif (end > endSuppress) continue nextSuppress;", "-\t\t\t\t\t\t\t\t\t\t\tif (~this.suppressWarningIrritants[jSuppress] == 0) break pairLoop; // suppress all?", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().unusedWarningToken(value);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}\t", "+\t\t\t\t\t\t\t\tbreak pairLoop;", "-\t\t\t\t\t\t\tbreak pairLoop;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5cb04fa26b9334ebcb96e8fe62335559", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "12f65faa0a3b984e9751d243a3eab6e6ab078ed7", "commitAfterChange": "36d2cf066100445cbe45dd4cf851204404f7d76f", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean commentParse()", "signatureAfterChange": " \tprotected boolean commentParse()", "diff": ["-\t\t\t// Init scanner position", "-\t\t\tthis.linePtr = getLineNumber(this.firstTagPosition);", "-\t\t\tint realStart = this.linePtr==1 ? javadocStart : this.scanner.getLineEnd(this.linePtr-1)+1;", "-\t\t\tif (realStart < javadocStart) realStart = javadocStart;", "-\t\t\tthis.scanner.resetTo(realStart, javadocEnd);", "-\t\t\tthis.index = realStart;", "-\t\t\tif (realStart == javadocStart) {", "-\t\t\t\treadChar(); // starting '/'", "-\t\t\t\treadChar(); // first '*'", "-\t\t\t}", "-\t\t\tint previousPosition = this.index;", "-\t\t\tchar nextCharacter = 0;", "-\t\t\tif (realStart == javadocStart) nextCharacter = readChar(); // second '*'", "-", "-\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.javadocEnd: this.scanner.getLineEnd(this.linePtr) - 1;", "+\t\t\tthis.spacePosition = -1;", "+\t\t\tboolean isFormatterParser = (this.kind & FORMATTER_COMMENT_PARSER) != 0;", "+", "+\t\t\t// Init scanner position", "+\t\t\tthis.linePtr = getLineNumber(this.firstTagPosition);", "+\t\t\tint realStart = this.linePtr==1 ? javadocStart : this.scanner.getLineEnd(this.linePtr-1)+1;", "+\t\t\tif (realStart < javadocStart) realStart = javadocStart;", "+\t\t\tthis.scanner.resetTo(realStart, javadocEnd);", "+\t\t\tthis.index = realStart;", "+\t\t\tif (realStart == javadocStart) {", "+\t\t\t\treadChar(); // starting '/'", "+\t\t\t\treadChar(); // first '*'", "+\t\t\t}", "+\t\t\tint previousPosition = this.index;", "+\t\t\tchar nextCharacter = 0;", "+\t\t\tif (realStart == javadocStart) {", "+\t\t\t\tnextCharacter = readChar(); // second '*'", "+\t\t\t\tthis.javadocTextStart = this.index;", "+\t\t\t}", "+\t\t\tthis.lineEnd = (this.linePtr == this.lastLinePtr) ? this.javadocEnd: this.scanner.getLineEnd(this.linePtr) - 1;", "-\t\t\t", "-\t\t\t\tif (this.index >= this.javadocEnd) {", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\t", "+", "+\t\t\t\t// Consume rules depending on the read character", "-\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\tif (isDomParser) refreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (isDomParser || isFormatterParser) {", "+\t\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < this.inlineTagStart) {", "-\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, this.inlineTagStart);", "+\t\t\t\t\t\t\t\tif (this.textStart != -1) {", "+\t\t\t\t\t\t\t\t\tint textEndPosition = this.inlineTagStart;", "+\t\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, invalidTagLineEnd);", "+\t\t\t\t\t\t\t\tint textEndPosition = invalidTagLineEnd;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "-\t\t\t\t\t\tif (this.lineStarted && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, previousPosition);", "+\t\t\t\t\t\tif (this.lineStarted) {", "+\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\tif (isFormatterParser) {", "+\t\t\t\t\t\t\t\tif (ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.spacePosition = previousPosition;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\tif (pushText) pushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "-\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\t\t\t\tint textEndPosition = previousPosition;", "+\t\t\t\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "+\t\t\t\t\t\t// Store the star position as text start while formatting", "+\t\t\t\t\t\tthis.starPosition = previousPosition;", "+\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t// do nothing for space or '*' characters", "+\t\t\t\t\t\t// Store first space position while formatting", "+\t\t\t\t\t\tif (isFormatterParser && !ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\t\tthis.spacePosition = previousPosition;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tcase '/':", "+\t\t\t\t\t\tif (previousChar == '*') {", "+\t\t\t\t\t\t\t// End of javadoc", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through default case", "+\t\t\t\t\t\tif (isFormatterParser && nextCharacter == '<') {", "+\t\t\t\t\t\t\t// html tags are meaningful for formatter parser", "+\t\t\t\t\t\t\tint initialIndex = this.index;", "+\t\t\t\t\t\t\tthis.scanner.resetTo(this.index, this.javadocEnd);", "+\t\t\t\t\t\t\tint endTextPosition = ScannerHelper.isWhitespace(previousChar) ? this.spacePosition : previousPosition;", "+\t\t\t\t\t\t\tif (parseHtmlTag(previousPosition, endTextPosition)) {", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (this.abort) return false;", "+\t\t\t\t\t\t\t// Wrong html syntax continue to process character normally", "+\t\t\t\t\t\t\tthis.scanner.currentPosition = initialIndex;", "+\t\t\t\t\t\t\tthis.index = initialIndex;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!this.lineStarted) {", "+\t\t\t\t\t\tif (!this.lineStarted || this.textStart == -1) {", "+\t\t\tthis.javadocTextEnd = this.starPosition-1;", "+", "-\t\t\t\tthis.inlineTagStarted = false;", "-\t\t\t\t\tint end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;", "+\t\t\t\t\tint end = this.javadocTextEnd<invalidInlineTagLineEnd ? this.javadocTextEnd : invalidInlineTagLineEnd;", "-\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {", "-\t\t\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\t\tint textEndPosition = this.javadocTextEnd;", "+\t\t\t\t\tif (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {", "+\t\t\t\t\t\ttextEndPosition = this.spacePosition;", "-\t\t\t\t\trefreshInlineTagPosition(previousPosition);", "+\t\t\t\t\tif (this.lineStarted && this.textStart != -1 && this.textStart < textEndPosition) {", "+\t\t\t\t\t\tpushText(this.textStart, textEndPosition);", "+\t\t\t\t\t}", "+\t\t\t\t\trefreshInlineTagPosition(textEndPosition);", "-\t\t\t} else if (pushText && this.lineStarted && this.textStart < previousPosition) {", "-\t\t\t\tpushText(this.textStart, previousPosition);", "+\t\t\t\tthis.inlineTagStarted = false;", "+\t\t\t} else if (pushText && this.lineStarted && this.textStart != -1 && this.textStart <= this.javadocTextEnd) {", "+\t\t\t\tpushText(this.textStart, this.starPosition);"]}], "num": 56401}