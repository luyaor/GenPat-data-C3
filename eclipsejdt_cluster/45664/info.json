{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fab712a881e5011e14ff8f42e543b164", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "23e4fd97cd03ce2aa0005f3e951e59d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "888ff915accf0f7dc08ba845bca467c94f1e290b", "commitAfterChange": "f69c200469412ca3b93e80844c6c1f4e077169ac", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 6, "signatureBeforeChange": "  protected boolean generateInfos(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException", "signatureAfterChange": " protected boolean buildStructure(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException", "diff": ["+}", "+protected boolean buildStructure(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException {", "+\t// check if this compilation unit can be opened", "+\tif (!(info instanceof WorkingCopyElementInfo)) { // no check is done on root kind or exclusion pattern for working copies", "+\t\tif (((IPackageFragment)getParent()).getKind() == IPackageFragmentRoot.K_BINARY", "+\t\t\t\t|| !isValidCompilationUnit()", "+\t\t\t\t|| !underlyingResource.isAccessible()) {", "+\t\t\tthrow newNotPresentException();", "+\t\t}", "+\t}", "+\tif (this.owner == DESTROYED_WC_OWNER) {", "+\t\tthrow newNotPresentException();", "+\t}", "+", "+\tCompilationUnitElementInfo unitInfo = (CompilationUnitElementInfo) info;", "+", "+\t// get buffer contents", "+\tIBuffer buffer = getBufferManager().getBuffer(CompilationUnit.this);", "+\tif (buffer == null) {", "+\t\tbuffer = openBuffer(pm, unitInfo); // open buffer independently from the info, since we are building the info", "+\t}", "+\tfinal char[] contents = buffer == null ? null : buffer.getCharacters();", "+", "+\t// generate structure and compute syntax problems if needed", "+\tCompilationUnitStructureRequestor requestor = new CompilationUnitStructureRequestor(this, unitInfo, newElements);", "+\tboolean computeProblems = computeProblems(info);", "+\tIProblemFactory factory = ", "+\t\tcomputeProblems ", "+\t\t\t?  CompilationUnitProblemFinder.getProblemFactory(getElementName().toCharArray(), (WorkingCopyElementInfo)unitInfo, pm) ", "+\t\t\t:  \tnew DefaultProblemFactory();", "+\tSourceElementParser parser = new SourceElementParser(requestor, factory, new CompilerOptions(getJavaProject().getOptions(true)));", "+\trequestor.parser = parser;", "+\tif (computeProblems) {", "+\t\t((WorkingCopyElementInfo)unitInfo).problems = new ArrayList();", "+\t}", "+\tCompilationUnitDeclaration unit = parser.parseCompilationUnit(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit() {", "+\t\t\tpublic char[] getContents() {", "+\t\t\t\treturn contents;", "+\t\t\t}", "+\t\t\tpublic char[] getMainTypeName() {", "+\t\t\t\treturn CompilationUnit.this.getMainTypeName();", "+\t\t\t}", "+\t\t\tpublic char[][] getPackageName() {", "+\t\t\t\treturn CompilationUnit.this.getPackageName();", "+\t\t\t}", "+\t\t\tpublic char[] getFileName() {", "+\t\t\t\treturn CompilationUnit.this.getFileName();", "+\t\t\t}", "+\t\t}, computeProblems /*full parse if compute problems*/);", "+\t", "+\t// update timestamp (might be IResource.NULL_STAMP if original does not exist)", "+\tif (underlyingResource == null) {", "+\t\tCompilationUnit original = new CompilationUnit((IPackageFragment)getParent(), getElementName(), DefaultCompilationUnitOwner.PRIMARY);", "+\t\tunderlyingResource = original.getResource();", "+\t}", "+\tunitInfo.fTimestamp = ((IFile)underlyingResource).getModificationStamp();", "+\t", "+\t// compute other problems if needed", "+\tif (computeProblems){", "+\t\tCompilationUnitProblemFinder.process(unit, this, (WorkingCopyElementInfo)unitInfo, pm); ", "+\t", "+\t\t// TODO: can now report problems as they are computed", "+\t\treportProblemsIfNeeded((WorkingCopyElementInfo)info);", "+\t}\t\t", "+\t", "+\treturn unitInfo.isStructureKnown();", "+}", "-", "-protected boolean generateInfos(OpenableElementInfo info, final IProgressMonitor pm, Map newElements, IResource underlyingResource) throws JavaModelException {", "-", "-\tif (getParent() instanceof JarPackageFragment) {", "-\t\t// ignore .java files in jar", "-\t\tthrow newNotPresentException();", "-\t} else {", "-\t\tCompilationUnitElementInfo unitInfo = (CompilationUnitElementInfo) info;", "-", "-\t\t// get buffer contents", "-\t\tIBuffer buffer = getBufferManager().getBuffer(CompilationUnit.this);", "-\t\tif (buffer == null) {", "-\t\t\tbuffer = openBuffer(pm); // open buffer independently from the info, since we are building the info", "-\t\t}", "-\t\tfinal char[] contents = buffer == null ? null : buffer.getCharacters();", "-", "-\t\t// generate structure", "-\t\tCompilationUnitStructureRequestor requestor = new CompilationUnitStructureRequestor(this, unitInfo, newElements);", "-\t\tIProblemFactory factory = new DefaultProblemFactory();", "-\t\tSourceElementParser parser = new SourceElementParser(requestor, factory, new CompilerOptions(getJavaProject().getOptions(true)));", "-\t\trequestor.parser = parser;", "-\t\t", "-\t\tparser.parseCompilationUnit(new org.eclipse.jdt.internal.compiler.env.ICompilationUnit() {", "-\t\t\t\tpublic char[] getContents() {", "-\t\t\t\t\treturn contents;", "-\t\t\t\t}", "-\t\t\t\tpublic char[] getMainTypeName() {", "-\t\t\t\t\treturn CompilationUnit.this.getMainTypeName();", "-\t\t\t\t}", "-\t\t\t\tpublic char[][] getPackageName() {", "-\t\t\t\t\treturn CompilationUnit.this.getPackageName();", "-\t\t\t\t}", "-\t\t\t\tpublic char[] getFileName() {", "-\t\t\t\t\treturn CompilationUnit.this.getFileName();", "-\t\t\t\t}", "-\t\t\t}, false/*diet parse*/);", "-\t\treturn unitInfo.isStructureKnown();", "-\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbde977a7cff2dfae52d37304d809d34", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprivate void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "signatureAfterChange": " \tprivate void checkProjectsBeingAddedOrRemoved(IResourceDelta delta)", "diff": ["-\t\tboolean processChildren = false;", "+\t\tIResourceDelta[] children = null;", "-\t\t\t\tprocessChildren = true;", "+\t\t\t\tchildren = delta.getAffectedChildren();", "-\t\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "+\t\t\t\t\t\taddToRootsToRefreshWithDependents(javaProject);", "-\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t\taddToParentInfo(javaProject);", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t// force to (re)read the .classpath file", "+\t\t\t\t\t\t\t\tjavaProject.getPerProjectInfo().readAndCacheClasspath(javaProject);", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {\t", "+\t\t\t\t\t\t\t\tif (VERBOSE) {", "+\t\t\t\t\t\t\t\t\te.printStackTrace();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tthis.state.updateProjectReferences(", "-\t\t\t\t\t\t\t\t\tjavaProject, ", "-\t\t\t\t\t\t\t\t\tnull/*no old classpath*/, ", "-\t\t\t\t\t\t\t\t\tnull/*compute new resolved classpath later*/, ", "-\t\t\t\t\t\t\t\t\tnull/*read raw classpath later*/, ", "-\t\t\t\t\t\t\t\t\tfalse/*cannot change resources*/);", "-\t\t\t\t\t\t\t} catch (JavaModelException e1) {", "-\t\t\t\t\t\t\t\t// project always exists", "-\t\t\t\t\t\t\t}\t\t\t\t\t", "+\t\t\t\t\t\t\tClasspathChange change = (ClasspathChange) this.classpathChanges.get(project);", "+\t\t\t\t\t\t\tthis.state.addProjectReferenceChange(javaProject, change == null ? null : change.oldResolvedClasspath);", "-\t\t\t\t\t\t\t\tthis.addToRootsToRefreshWithDependents(javaProject);", "+\t\t\t\t\t\t\t\taddToRootsToRefreshWithDependents(javaProject);", "-\t\t\t\t\t\t\t\t\t\tthis.addToParentInfo(javaProject);", "+\t\t\t\t\t\t\t\t\t\taddToParentInfo(javaProject);", "-\t\t\t\t\t\t\t\tif (wasJavaProject != isJavaProject) { ", "+\t\t\t\t\t\t\t\tif (wasJavaProject != isJavaProject) {", "-\t\t\t\t\t\t\t\t\t\tprocessChildren = true;", "+\t\t\t\t\t\t\t\t\t\tchildren = delta.getAffectedChildren();", "-\t\t\t\t\t\t\t\t\tprocessChildren = true;", "+\t\t\t\t\t\t\t\t\tchildren = delta.getAffectedChildren();", "-\t\t\t\t\treconcileClasspathFileUpdate(delta, (JavaProject)JavaCore.create(file.getProject()));", "+\t\t\t\t\tswitch (delta.getKind()) {", "+\t\t\t\t\t\tcase IResourceDelta.CHANGED :", "+\t\t\t\t\t\t\tint flags = delta.getFlags();", "+\t\t\t\t\t\t\tif ((flags & IResourceDelta.CONTENT) == 0  // only consider content change", "+\t\t\t\t\t\t\t\t&& (flags & IResourceDelta.ENCODING) == 0 // and encoding change", "+\t\t\t\t\t\t\t\t&& (flags & IResourceDelta.MOVED_FROM) == 0) {// and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through", "+\t\t\t\t\t\tcase IResourceDelta.ADDED :", "+\t\t\t\t\t\t\tjavaProject = (JavaProject)JavaCore.create(file.getProject());", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t// force to (re)read the .classpath file", "+\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\tjavaProject.getPerProjectInfo().readAndCacheClasspath(javaProject);", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t\t// project doesn't exist", "+\t\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "-\t\tif (processChildren) {", "-\t\t\tIResourceDelta[] children = delta.getAffectedChildren();", "+\t\tif (children != null) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e2c5de205985b54d0c1ea2d753aac78e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java", "commitBeforeChange": "0096213f4b70c6196247b76dbfbdc7d2b6019590", "commitAfterChange": "7882956f959d3c6393e0d8829373f1d0522732ab", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " protected void acceptBinaryMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, String[] parameterSignatures, char[] uniqueKey)", "signatureAfterChange": " protected void acceptBinaryMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, String[] parameterSignatures, char[] uniqueKey, boolean isConstructor)", "diff": ["-protected void acceptBinaryMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, String[] parameterSignatures, char[] uniqueKey) {", "+protected void acceptBinaryMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, String[] parameterSignatures, char[] uniqueKey, boolean isConstructor) {", "-\t\tif (uniqueKey != null)", "-\t\t\tmethod = new ResolvedBinaryMethod(", "-\t\t\t\t\t(JavaElement)method.getParent(),", "-\t\t\t\t\tmethod.getElementName(),", "-\t\t\t\t\tmethod.getParameterTypes(),", "-\t\t\t\t\tnew String(uniqueKey));", "-\t\taddElement(method);", "-\t\tif(SelectionEngine.DEBUG){", "-\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$", "-\t\t\tSystem.out.print(method.toString());", "-\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\ttry {", "+\t\t\tif(!isConstructor || ((JavaElement)method).getSourceMapper() == null) {", "+\t\t\t\tif (uniqueKey != null)", "+\t\t\t\t\tmethod = new ResolvedBinaryMethod(", "+\t\t\t\t\t\t\t(JavaElement)method.getParent(),", "+\t\t\t\t\t\t\tmethod.getElementName(),", "+\t\t\t\t\t\t\tmethod.getParameterTypes(),", "+\t\t\t\t\t\t\tnew String(uniqueKey));", "+\t\t\t\taddElement(method);", "+\t\t\t\tif(SelectionEngine.DEBUG){", "+\t\t\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$", "+\t\t\t\t\tSystem.out.print(method.toString());", "+\t\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tISourceRange range = method.getSourceRange();", "+\t\t\t\tif (range.getOffset() != -1 && range.getLength() != 0 ) {", "+\t\t\t\t\tif (uniqueKey != null)", "+\t\t\t\t\t\tmethod = new ResolvedBinaryMethod(", "+\t\t\t\t\t\t\t\t(JavaElement)method.getParent(),", "+\t\t\t\t\t\t\t\tmethod.getElementName(),", "+\t\t\t\t\t\t\t\tmethod.getParameterTypes(),", "+\t\t\t\t\t\t\t\tnew String(uniqueKey));", "+\t\t\t\t\taddElement(method);", "+\t\t\t\t\tif(SelectionEngine.DEBUG){", "+\t\t\t\t\t\tSystem.out.print(\"SELECTION - accept method(\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(method.toString());", "+\t\t\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// no range was actually found, but a method was originally given -> default constructor", "+\t\t\t\t\taddElement(type);", "+\t\t\t\t\tif(SelectionEngine.DEBUG){", "+\t\t\t\t\t\tSystem.out.print(\"SELECTION - accept type(\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(type.toString());", "+\t\t\t\t\t\tSystem.out.println(\")\"); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// an exception occurs, return nothing"]}], "num": 45664}