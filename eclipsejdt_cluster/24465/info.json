{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "165a20beae5ac355b61998ad71e06061", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "03ea310e5b319818f9dbea68a35052b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 5, "signatureBeforeChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "signatureAfterChange": " private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length)", "diff": ["+\t\tif (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "+\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "+\t\t\tcontinue nextMethod;", "+\t\t}", "+", "-\t\tif (!areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "+\t\tboolean addBridgeMethod = inheritedMethod.hasSubstitutedReturnType()", "+\t\t\t&& isSameOrSubTypeOf(currentMethod.returnType, inheritedMethod.returnType);", "+\t\tif (!addBridgeMethod && !areTypesEqual(currentMethod.returnType, inheritedMethod.returnType)) {", "-\t\t} else if (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method", "-\t\t\tthis.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);", "-\t\t} else {", "-\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "-\t\t\tif (inheritedMethod.isFinal())", "-\t\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\tcontinue nextMethod;", "+\t\t}", "-\t\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t\t}", "+\t\tif (addBridgeMethod || inheritedMethod.hasSubstitutedParameters()) {", "+\t\t    MethodBinding original = inheritedMethod.original();", "+\t\t    if (!areReturnTypeErasuresEqual(original, currentMethod) || !areParameterErasuresEqual(original, currentMethod))", "+\t\t\t\tthis.type.addSyntheticBridgeMethod(original, currentMethod);", "+\t\t}", "+", "+\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\tthis.checkExceptions(currentMethod, inheritedMethod);", "+\t\tif (inheritedMethod.isFinal())", "+\t\t\tthis.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\tif (!this.isAsVisible(currentMethod, inheritedMethod))", "+\t\t\tthis.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\t\tthis.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7ea8c7ec4e42418d02b5307c42a853e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "74cb74226fe254108607eae80c548bb2b6719e32", "commitAfterChange": "dadef2fc0573a510ff313dd625ee1ba4e2b2e6e3", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tprivate int generateMethodParameters(final MethodBinding binding)", "signatureAfterChange": " \tprivate int generateMethodParameters(final MethodBinding binding)", "diff": ["-\t\t\t// take into account the synthetic argument names", "-\t\t\tint modifier = (! declaringClass.isPrivate()) || declaringClass.isAnonymousType() ? ClassFileConstants.AccMandated : ClassFileConstants.AccSynthetic;", "+\t\t\t// Take into account the synthetic argument names", "+\t\t\t// This tracks JLS8, paragraph 8.8.9", "+\t\t\tboolean anonymousWithLocalSuper = declaringClass.isAnonymousType() && declaringClass.superclass().isLocalType();", "+\t\t\tboolean anonymousWithNestedSuper = declaringClass.isAnonymousType() && declaringClass.superclass().isNestedType();", "+\t\t\tboolean isImplicitlyDeclared = ((! declaringClass.isPrivate()) || declaringClass.isAnonymousType()) && !anonymousWithLocalSuper;", "+\t\t\t\t\t// This behaviour tracks JLS 15.9.5.1", "+\t\t\t\t\t// This covers that the parameter ending up in a nested class must be mandated \"on the way in\", even if it", "+\t\t\t\t\t// isn't the first. The practical relevance of this is questionable, since the constructor call will be", "+\t\t\t\t\t// generated by the same constructor.", "+\t\t\t\t\tboolean couldForwardToMandated = anonymousWithNestedSuper ? declaringClass.superclass().enclosingType().equals(syntheticArgumentTypes[i]) : true;", "+\t\t\t\t\tint modifier = couldForwardToMandated && isImplicitlyDeclared ? ClassFileConstants.AccMandated : ClassFileConstants.AccSynthetic;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b0ce8262eb910160627dff7d7872faf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "6b97e0e0385eaee70dad3a39c532ecba2f431f7d", "commitAfterChange": "b2f247d693fb1c4457e39814eacc8edd600c0ad7", "methodNumberBeforeChange": 86, "methodNumberAfterChange": 86, "signatureBeforeChange": " \tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements)", "signatureAfterChange": " \tprotected synchronized void putInfos(IJavaElement openedElement, Map newElements)", "diff": ["-\t\tIterator iterator = newElements.keySet().iterator();", "+\t\t// Need to put any JarPackageFragmentRoot in first.", "+\t\t// This is due to the way the LRU cache flushes entries.", "+\t\t// When a JarPackageFragment is flused from the LRU cache, the entire", "+\t\t// jar is flushed by removing the JarPackageFragmentRoot and all of its", "+\t\t// children (see ElementCache.close()). If we flush the JarPackageFragment ", "+\t\t// when its JarPackageFragmentRoot is not in the cache and the root is about to be ", "+\t\t// added (during the 'while' loop), we will end up in an inconsist state. ", "+\t\t// Subsequent resolution against package in the jar would fail as a result.", "+\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=102422", "+\t\t// (theodora)", "+\t\tfor(Iterator it = newElements.entrySet().iterator(); it.hasNext(); ) {", "+\t\t\tMap.Entry entry = (Map.Entry)it.next();", "+\t\t\tIJavaElement element = (IJavaElement)entry.getKey();", "+\t\t\tif( element instanceof JarPackageFragmentRoot ){", "+\t\t\t\tObject info = entry.getValue();", "+\t\t\t\tit.remove();", "+\t\t\t\tthis.cache.putInfo(element, info);", "+\t\t\t}", "+\t\t}\t", "+\t", "+\t\tIterator iterator = newElements.keySet().iterator();\t"]}], "num": 24465}