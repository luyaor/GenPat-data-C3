{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "14372cc028e74bef554fd7b9a9ce40d0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9bff70803e3f2d83949acb6924f527b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "c62ecfd031507c11ea236866605fedd6f3a952c5", "commitAfterChange": "ded73445e8c5cf2db0a4abcc53e1680f02ae6cf7", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count, int emptyLinesRules)", "diff": ["-\tprivate String getPreserveEmptyLines(int count) {", "+\tprivate String getPreserveEmptyLines(int count, int emptyLinesRules) {", "-\t\t\t// preserve line breaks in wrapping if specified", "-\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=198074", "-\t\t\tif (this.currentAlignment != null && !this.formatter.preferences.join_wrapped_lines) {", "-\t\t\t\t// Insert a new line only if it has not been already done before", "-\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)", "-\t\t\t\t// or when there's no direct member alignment", "-\t\t\t\t// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)", "-\t\t\t\tif (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {", "-\t\t\t\t\t", "-\t\t\t\t\t// Debug", "-\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "-\t\t\t\t\t\tSystem.out.println(\"Preserve empty lines:\"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current alignment: \"); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.print(this.currentAlignment.toString(new StringBuffer(), 1));", "-\t\t\t\t\t\tif (this.memberAlignment != null) {", "-\t\t\t\t\t\t\tSystem.out.println(\" - member alignment: \"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tSystem.out.print(this.memberAlignment.toString(new StringBuffer(), 1));", "-\t\t\t\t\t\t}", "+\t\t\tint currentIndentationLevel = this.indentationLevel;", "+\t\t\tint useAlignmentBreakIndentation = useAlignmentBreakIndentation(emptyLinesRules);", "+\t\t\tswitch (useAlignmentBreakIndentation) {", "+\t\t\t\tcase PRESERVE_EMPTY_LINES_DO_NOT_USE_ANY_INDENTATION:", "+\t\t\t\t\treturn Util.EMPTY_STRING;", "+\t\t\t\tdefault:", "+\t\t\t\t\t// Return the new indented line", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer(getNewLine());", "+\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\tif (useAlignmentBreakIndentation == PRESERVE_EMPTY_LINES_USE_TEMPORARY_INDENTATION) {", "+\t\t\t\t\t\tthis.indentationLevel = currentIndentationLevel;", "-", "-\t\t\t\t\t// Reset indentation level to the location output", "-\t\t\t\t\tthis.indentationLevel = this.currentAlignment.location.outputIndentationLevel;", "-", "-\t\t\t\t\t// Create new line", "-\t\t\t\t\tthis.tempBuffer.setLength(0);", "-\t\t\t\t\tthis.tempBuffer.append(getNewLine());", "-\t\t\t\t\t", "-\t\t\t\t\t// Look for current indentation", "-\t\t\t\t\tint currentIndentation = getCurrentIndentation(this.scanner.currentPosition);", "-\t\t\t\t\t", "-\t\t\t\t\t// Determine whether the alignment indentation can be used or not", "-\t\t\t\t\t// So far, the best algorithm is to use it when", "-\t\t\t\t\t// 1. this is not the opening brace of a local declaration assignment", "-\t\t\t\t\t// 2. this is not the first opening brace", "-\t\t\t\t\t//     or this is an array initializer alignment ", "-\t\t\t\t\t//     or this is an binary expression alignment", "-\t\t\t\t\t// 3. the indentation level is below the alignment break indentation", "-\t\t\t\t\tint currentTokenStartPosition = this.scanner.currentPosition;", "-\t\t\t\t\tint nextToken = -1;", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tnextToken = this.scanner.getNextToken();", "-\t\t\t\t\t} catch (InvalidInputException e) {", "-\t\t\t\t\t\t// skip", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "-\t\t\t\t\tboolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || this.currentAlignment.kind != Alignment.LOCAL_DECLARATION_ASSIGNMENT);", "-\t\t\t\t\tif (canUseAlignmentIndentation &&", "-\t\t\t\t\t\t\t(!this.formatBrace ||", "-\t\t\t\t\t\t\t\t\tthis.currentAlignment.kind == Alignment.ARRAY_INITIALIZER ||", "-\t\t\t\t\t\t\t\t\tthis.currentAlignment.kind == Alignment.BINARY_EXPRESSION) &&", "-\t\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel) {", "-\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Use the current indentation if over the computed indentation", "-\t\t\t\t\tif (this.indentationLevel < currentIndentation) {", "-\t\t\t\t\t\tthis.indentationLevel = currentIndentation;", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Debug", "-\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "-\t\t\t\t\t\tSystem.out.println(\" - format brace = \"+this.formatBrace); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current column = \"+(currentIndentation+1)); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println(\" - current position = \"+this.scanner.currentPosition); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.print(\" - current line = \"); //$NON-NLS-1$", "-\t\t\t\t\t\tint linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);", "-\t\t\t\t\t\tif (linePtr < 0) {", "-\t\t\t\t\t\t\tlinePtr = -linePtr - 1;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tint i = getLineEnd(linePtr)+1;", "-\t\t\t\t\t\tchar[] source = this.scanner.source;", "-\t\t\t\t\t\tint sourceLength = source.length;", "-\t\t\t\t\t\twhile (i < sourceLength && source[i] != '\\r') {", "-\t\t\t\t\t\t\tSystem.out.print(source[i++]);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tSystem.out.println();", "-\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "-\t\t\t\t\t\tSystem.out.println();", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// Set the flag to indicate that a specific indentation is currently in used", "-\t\t\t\t\tthis.preserveLineBreakIndentation = true;", "-\t\t\t\t\t", "-\t\t\t\t\t// Print the computed indentation in the buffer", "-\t\t\t\t\tprintIndentationIfNecessary(this.tempBuffer);", "-\t\t\t\t\treturn this.tempBuffer.toString();", "-\t\t\t\t}", "+\t\t\t\t\treturn buffer.toString();", "-\t\t\treturn Util.EMPTY_STRING;", "+\t\t\tuseAlignmentBreakIndentation(emptyLinesRules);", "+\t\t\tuseAlignmentBreakIndentation(emptyLinesRules);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c7f2517c199beb00295976f67b956aee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "900c13d17fd147c187a2b319111ff0c850c4ae89", "commitAfterChange": "f02cc00df615ce0df96d2675e50465c713b4b942", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tprivate String getPreserveEmptyLines(int count)", "signatureAfterChange": " \tprivate String getPreserveEmptyLines(int count)", "diff": ["-\t\t\t\t// insert a new line only if it has not been already done before", "-\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476", "-\t\t\t\tif (this.lastNumberOfNewLines == 0) {", "+\t\t\t\t// Insert a new line only if it has not been already done before", "+\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)", "+\t\t\t\t// or when there's no direct member alignment", "+\t\t\t\t// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)", "+\t\t\t\tif (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\"Preserve empty lines:\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(this.currentAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\tif (this.memberAlignment != null) {", "+\t\t\t\t\t\t\tSystem.out.println(\" - member alignment: \"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tSystem.out.print(this.memberAlignment.toString(new StringBuffer(), 1));", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+", "-\t\t\t\t\tthis.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;", "-\t\t\t\t\tthis.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;", "-\t\t\t\t\t// Create new line keeping the existing indentation", "+", "+\t\t\t\t\t// Create new line", "+\t\t\t\t\t", "+\t\t\t\t\t// Look for current indentation", "-\t\t\t\t\tAlignment rootAlignment = this.currentAlignment;", "-\t\t\t\t\twhile (rootAlignment.enclosing != null) {", "-\t\t\t\t\t\trootAlignment = rootAlignment.enclosing;", "+\t\t\t\t\t", "+\t\t\t\t\t// Determine whether the alignment indentation can be used or not", "+\t\t\t\t\t// So far, the best algorithm is to use it when", "+\t\t\t\t\t// 1. this is not the opening brace of a local declaration assignment", "+\t\t\t\t\t// 2. this is not the first opening brace", "+\t\t\t\t\t//     or this is an array initializer alignment ", "+\t\t\t\t\t//     or this is an binary expression alignment", "+\t\t\t\t\t// 3. the indentation level is below the alignment break indentation", "+\t\t\t\t\tint currentTokenStartPosition = this.scanner.currentPosition;", "+\t\t\t\t\tint nextToken = -1;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tnextToken = this.scanner.getNextToken();", "+\t\t\t\t\t} catch (InvalidInputException e) {", "+\t\t\t\t\t\t// skip", "-\t\t\t\t\tLocation location = rootAlignment.location;", "-\t\t\t\t\tif (currentColumn > location.inputColumn) {", "-\t\t\t\t\t\tint savedIndentation = this.indentationLevel;", "-\t\t\t\t\t\tthis.indentationLevel += currentColumn - location.inputColumn;", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\tthis.indentationLevel = savedIndentation;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tprintIndentationIfNecessary(buffer);", "+\t\t\t\t\tthis.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);", "+\t\t\t\t\tboolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || !this.currentAlignment.name.equals(\"localDeclarationAssignmentAlignment\")); //$NON-NLS-1$", "+\t\t\t\t\tif (canUseAlignmentIndentation &&", "+\t\t\t\t\t\t\t(!this.formatBrace ||", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"array_initializer\") || //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tthis.currentAlignment.name.equals(\"binaryExpressionAlignment\")) && //$NON-NLS-1$", "+\t\t\t\t\t\t\tthis.indentationLevel < this.currentAlignment.breakIndentationLevel) {", "+\t\t\t\t\t\tthis.indentationLevel = this.currentAlignment.breakIndentationLevel;", "+\t\t\t\t\t", "+\t\t\t\t\t// Use the current indentation if over the computed indentation", "+\t\t\t\t\tif (this.indentationLevel < currentColumn) {", "+\t\t\t\t\t\tthis.indentationLevel = currentColumn;", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Debug", "+\t\t\t\t\tif (DefaultCodeFormatter.DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\" - format brace = \"+this.formatBrace); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current column = \"+currentColumn); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(\" - current position = \"+this.scanner.currentPosition); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.print(\" - current line = \"); //$NON-NLS-1$", "+\t\t\t\t\t\tint linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);", "+\t\t\t\t\t\tif (linePtr < 0) {", "+\t\t\t\t\t\t\tlinePtr = -linePtr - 1;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tint i = getLineEnd(linePtr)+1;", "+\t\t\t\t\t\twhile (this.scanner.source[i] != '\\r') {", "+\t\t\t\t\t\t\tSystem.out.print(this.scanner.source[i++]);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t\tSystem.out.println(\" - indentation level = \"+this.indentationLevel); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println();", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// Set the flag to indicate that a specific indentation is currently in used", "+\t\t\t\t\tthis.preserveLineBreakIndentation = true;", "+\t\t\t\t\t", "+\t\t\t\t\t// Print the computed indentation in the buffer", "+\t\t\t\t\tprintIndentationIfNecessary(buffer);"]}], "num": 53639}