{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "db9da0d0293e80538831a222ebe0d030", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8a9b903e2300e6c67adcf47b46e2b7c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java", "commitBeforeChange": "1111836d0685bb4771145e4e9ae98946f97841ba", "commitAfterChange": "2401f89c1204c75ca8439111af06317b0964f8ae", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 71, "signatureBeforeChange": " public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException", "diff": ["+ */", "+public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException {", "+\ttry {", "+\t\t// compute types in hierarchy", "+\t\tHashtable hashtable = new Hashtable();", "+\t\tHashtable hashtable2 = new Hashtable();", "+\t\tint count = 0;", "+\t\t", "+\t\tif(type != null) {", "+\t\t\tInteger index = new Integer(count++);", "+\t\t\thashtable.put(type, index);", "+\t\t\thashtable2.put(index, type);", "+\t\t}", "+\t\tObject[] types = classToSuperclass.keySet().toArray();", "+\t\tfor (int i = 0; i < types.length; i++) {", "+\t\t\tObject t = types[i];", "+\t\t\tif(hashtable.get(t) == null) {", "+\t\t\t\tInteger index = new Integer(count++);", "+\t\t\t\thashtable.put(t, index);", "+\t\t\t\thashtable2.put(index, t);", "+\t\t\t}", "+\t\t\tObject superClass = classToSuperclass.get(t);", "+\t\t\tif(superClass != null && hashtable.get(superClass) == null) {", "+\t\t\t\tInteger index = new Integer(count++);", "+\t\t\t\thashtable.put(superClass, index);", "+\t\t\t\thashtable2.put(index, superClass);", "+\t\t\t}", "+\t\t}", "+\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "+\t\tfor (int i = 0; i < types.length; i++) {", "+\t\t\tObject t = types[i];", "+\t\t\tif(hashtable.get(t) == null) {", "+\t\t\t\tInteger index = new Integer(count++);", "+\t\t\t\thashtable.put(t, index);", "+\t\t\t\thashtable2.put(index, t);", "+\t\t\t}", "+\t\t\tObject[] sp = (Object[])typeToSuperInterfaces.get(t);", "+\t\t\tif(sp != null) {", "+\t\t\t\tfor (int j = 0; j < sp.length; j++) {", "+\t\t\t\t\tObject superInterface = sp[j];", "+\t\t\t\t\tif(sp[j] != null && hashtable.get(superInterface) == null) {", "+\t\t\t\t\t\tInteger index = new Integer(count++);", "+\t\t\t\t\t\thashtable.put(superInterface, index);", "+\t\t\t\t\t\thashtable2.put(index, superInterface);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t// save version of the hierarchy format", "+\t\toutput.write(VERSION);", "+\t\t", "+\t\t// save general info", "+\t\tbyte generalInfo = 0;", "+\t\tif(computeSubtypes) {", "+\t\t\tgeneralInfo |= COMPUTE_SUBTYPES;", "+\t\t}", "+\t\toutput.write(generalInfo);", "+\t\t", "+\t\t// save project", "+\t\tif(project != null) {", "+\t\t\toutput.write(project.getHandleIdentifier().getBytes());", "+\t\t}", "+\t\toutput.write(SEPARATOR1);", "+\t\t", "+\t\t// save missing types", "+\t\tfor (int i = 0; i < missingTypes.size(); i++) {", "+\t\t\tif(i != 0) {", "+\t\t\t\toutput.write(SEPARATOR2);", "+\t\t\t}", "+\t\t\toutput.write(((String)missingTypes.get(i)).getBytes());", "+\t\t\t", "+\t\t}", "+\t\toutput.write(SEPARATOR1);", "+\t\t", "+\t\t// save types", "+\t\tfor (int i = 0; i < count ; i++) {", "+\t\t\tIType t = (IType)hashtable2.get(new Integer(i));", "+\t\t\t", "+\t\t\t// n bytes", "+\t\t\toutput.write(t.getHandleIdentifier().getBytes());", "+\t\t\toutput.write(SEPARATOR4);", "+\t\t\toutput.write(flagsToBytes((Integer)typeFlags.get(t)));", "+\t\t\toutput.write(SEPARATOR4);", "+\t\t\tbyte info = CLASS;", "+\t\t\tif(type != null && type.equals(t)) {", "+\t\t\t\tinfo |= COMPUTED_FOR;", "+\t\t\t}", "+\t\t\tif(interfaces.contains(t)) {", "+\t\t\t\tinfo |= INTERFACE;", "+\t\t\t}", "+\t\t\tif(rootClasses.contains(t)) {", "+\t\t\t\tinfo |= ROOT;", "+\t\t\t}", "+\t\t\toutput.write(info);", "+\t\t}", "+\t\toutput.write(SEPARATOR1);", "+\t\t", "+\t\t// save superclasses", "+\t\ttypes = classToSuperclass.keySet().toArray();", "+\t\tfor (int i = 0; i < types.length; i++) {", "+\t\t\tIJavaElement key = (IJavaElement)types[i];", "+\t\t\tIJavaElement value = (IJavaElement)classToSuperclass.get(key);", "+\t\t\t", "+\t\t\toutput.write(((Integer)hashtable.get(key)).toString().getBytes());", "+\t\t\toutput.write('>');", "+\t\t\toutput.write(((Integer)hashtable.get(value)).toString().getBytes());", "+\t\t\toutput.write(SEPARATOR1);", "+\t\t}", "+\t\toutput.write(SEPARATOR1);", "+\t\t", "+\t\t// save superinterfaces", "+\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "+\t\tfor (int i = 0; i < types.length; i++) {", "+\t\t\tIJavaElement key = (IJavaElement)types[i];", "+\t\t\tIJavaElement[] values = (IJavaElement[])typeToSuperInterfaces.get(key);", "+\t\t\t", "+\t\t\tif(values.length > 0) {", "+\t\t\t\toutput.write(((Integer)hashtable.get(key)).toString().getBytes());", "+\t\t\t\toutput.write(SEPARATOR3);", "+\t\t\t\tfor (int j = 0; j < values.length; j++) {", "+\t\t\t\t\tIJavaElement value = values[j];", "+\t\t\t\t\tif(j != 0) output.write(SEPARATOR2);", "+\t\t\t\t\toutput.write(((Integer)hashtable.get(value)).toString().getBytes());", "+\t\t\t\t}", "+\t\t\t\toutput.write(SEPARATOR1);", "+\t\t\t}", "+\t\t}", "+\t\toutput.write(SEPARATOR1);", "+\t} catch(IOException e) {", "+\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "- */", "-public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException {", "-\ttry {", "-\t\t// compute types in hierarchy", "-\t\tHashtable hashtable = new Hashtable();", "-\t\tHashtable hashtable2 = new Hashtable();", "-\t\tint count = 0;", "-\t\t", "-\t\tif(type != null) {", "-\t\t\tInteger index = new Integer(count++);", "-\t\t\thashtable.put(type, index);", "-\t\t\thashtable2.put(index, type);", "-\t\t}", "-\t\tObject[] types = classToSuperclass.keySet().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\tif(hashtable.get(types[i]) == null) {", "-\t\t\t\tInteger index = new Integer(count++);", "-\t\t\t\thashtable.put(types[i], index);", "-\t\t\t\thashtable2.put(index, types[i]);", "-\t\t\t}", "-\t\t}", "-\t\ttypes = classToSuperclass.values().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\tif(hashtable.get(types[i]) == null) {", "-\t\t\t\tInteger index = new Integer(count++);", "-\t\t\t\thashtable.put(types[i], index);", "-\t\t\t\thashtable2.put(index, types[i]);", "-\t\t\t}", "-\t\t}", "-\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\tif(hashtable.get(types[i]) == null) {", "-\t\t\t\tInteger index = new Integer(count++);", "-\t\t\t\thashtable.put(types[i], index);", "-\t\t\t\thashtable2.put(index, types[i]);", "-\t\t\t}", "-\t\t}", "-\t\tObject[] tabTypes = typeToSuperInterfaces.values().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\ttypes = (Object[])tabTypes[i];", "-\t\t\tfor (int j = 0; j < types.length; j++) {", "-\t\t\t\tif(hashtable.get(types[j]) == null) {", "-\t\t\t\t\tInteger index = new Integer(count++);", "-\t\t\t\t\thashtable.put(types[j], index);", "-\t\t\t\t\thashtable2.put(index, types[j]);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "-\t\t}", "-\t\t", "-\t\t// save version of the hierarchy format", "-\t\toutput.write(VERSION);", "-\t\t", "-\t\t// save general info", "-\t\tbyte generalInfo = 0;", "-\t\tif(computeSubtypes) {", "-\t\t\tgeneralInfo |= COMPUTE_SUBTYPES;", "-\t\t}", "-\t\toutput.write(generalInfo);", "-\t\t", "-\t\t// save project", "-\t\tif(project != null) {", "-\t\t\toutput.write(project.getHandleIdentifier().getBytes());", "-\t\t}", "-\t\toutput.write(SEPARATOR1);", "-\t\t", "-\t\t// save missing types", "-\t\tfor (int i = 0; i < missingTypes.size(); i++) {", "-\t\t\tif(i != 0) {", "-\t\t\t\toutput.write(SEPARATOR2);", "-\t\t\t}", "-\t\t\toutput.write(((String)missingTypes.get(i)).getBytes());", "-\t\t\t", "-\t\t}", "-\t\toutput.write(SEPARATOR1);", "-\t\t", "-\t\t// save types", "-\t\tfor (int i = 0; i < count ; i++) {", "-\t\t\tIType t = (IType)hashtable2.get(new Integer(i));", "-\t\t\t", "-\t\t\t// n bytes", "-\t\t\toutput.write(t.getHandleIdentifier().getBytes());", "-\t\t\toutput.write(SEPARATOR4);", "-\t\t\toutput.write(flagsToBytes((Integer)typeFlags.get(t)));", "-\t\t\toutput.write(SEPARATOR4);", "-\t\t\tbyte info = CLASS;", "-\t\t\tif(type != null && type.equals(t)) {", "-\t\t\t\tinfo |= COMPUTED_FOR;", "-\t\t\t}", "-\t\t\tif(interfaces.contains(t)) {", "-\t\t\t\tinfo |= INTERFACE;", "-\t\t\t}", "-\t\t\tif(rootClasses.contains(t)) {", "-\t\t\t\tinfo |= ROOT;", "-\t\t\t}", "-\t\t\toutput.write(info);", "-\t\t}", "-\t\toutput.write(SEPARATOR1);", "-\t\t", "-\t\t// save superclasses", "-\t\ttypes = classToSuperclass.keySet().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\tIJavaElement key = (IJavaElement)types[i];", "-\t\t\tIJavaElement value = (IJavaElement)classToSuperclass.get(key);", "-\t\t\t", "-\t\t\toutput.write(((Integer)hashtable.get(key)).toString().getBytes());", "-\t\t\toutput.write('>');", "-\t\t\toutput.write(((Integer)hashtable.get(value)).toString().getBytes());", "-\t\t\toutput.write(SEPARATOR1);", "-\t\t}", "-\t\toutput.write(SEPARATOR1);", "-\t\t", "-\t\t// save superinterfaces", "-\t\ttypes = typeToSuperInterfaces.keySet().toArray();", "-\t\tfor (int i = 0; i < types.length; i++) {", "-\t\t\tIJavaElement key = (IJavaElement)types[i];", "-\t\t\tIJavaElement[] values = (IJavaElement[])typeToSuperInterfaces.get(key);", "-\t\t\t", "-\t\t\tif(values.length > 0) {", "-\t\t\t\toutput.write(((Integer)hashtable.get(key)).toString().getBytes());", "-\t\t\t\toutput.write(SEPARATOR3);", "-\t\t\t\tfor (int j = 0; j < values.length; j++) {", "-\t\t\t\t\tIJavaElement value = values[j];", "-\t\t\t\t\tif(j != 0) output.write(SEPARATOR2);", "-\t\t\t\t\toutput.write(((Integer)hashtable.get(value)).toString().getBytes());", "-\t\t\t\t}", "-\t\t\t\toutput.write(SEPARATOR1);", "-\t\t\t}", "-\t\t}", "-\t\toutput.write(SEPARATOR1);", "-\t} catch(IOException e) {", "-\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));", "-\t}", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e870a862a13fd1ea3dcac8a71b81017d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "99d47e4046e97803f75625986f5eb5ffc13cddfe", "commitAfterChange": "8282cb3c46786d73ca763e64384724ac9c0798d9", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 0, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["+\t */\t", "+\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "+\t\t", "+\t\tParameterizedGenericMethodBinding methodSubstitute;", "+\t\tTypeVariableBinding[] typeVariables = originalMethod.typeVariables;", "+\t\tTypeBinding[] substitutes = invocationSite.genericTypeArguments();", "+\t\t", "+\t\tcomputeSubstitutes: {", "+\t\t\tif (substitutes != null) {", "+\t\t\t\t// explicit type arguments got supplied", "+\t\t\t\tif (substitutes.length != typeVariables.length) {", "+\t\t\t        // incompatible due to wrong arity", "+\t\t\t        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, TypeParameterArityMismatch);", "+\t\t\t\t}", "+\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "+\t\t\t\tbreak computeSubstitutes;", "+\t\t\t}", "+\t\t\t", "+\t\t\t// perform type argument inference (15.12.2.7)", "+\t\t\t\t", "+\t\t\t// initializes the map of substitutes (var --> type[][]{ equal, extends, super}", "+\t\t\tTypeBinding[] parameters = originalMethod.parameters;", "+\t\t\tint varLength = typeVariables.length;", "+\t\t\tMap collectedSubstitutes = new HashMap(varLength);", "+\t\t\tfor (int i = 0; i < varLength; i++)", "+\t\t\t\tcollectedSubstitutes.put(typeVariables[i], new TypeBinding[3][]);", "+\t\t\t", "+\t\t\tsubstitutes = new TypeBinding[varLength];", "+\t\t\tmethodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, collectedSubstitutes, substitutes);", "+\t\t\tif (methodSubstitute == null) ", "+\t\t\t\treturn null;", "+\t\t\t// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method", "+\t\t\t", "+\t\t\t// 15.12.2.8 - inferring unresolved type arguments", "+\t\t\tif (hasUnresolvedTypeArgument(substitutes)) {", "+\t\t\t\tTypeBinding expectedType = null;", "+\t\t\t\t// if message invocation has expected type", "+\t\t\t\tif (invocationSite instanceof MessageSend) {", "+\t\t\t\t\tMessageSend message = (MessageSend) invocationSite;", "+\t\t\t\t\texpectedType = message.expectedType;", "+\t\t\t\t} ", "+\t\t\t\tif (expectedType == null) {", "+\t\t\t\t\tif (methodSubstitute.returnType.isTypeVariable()) {", "+\t\t\t\t\t\t// should be: if no expected type, then assume Object", "+\t\t\t\t\t\t// actually it rather seems to handle the returned variable case by expecting its erasure instead", "+\t\t\t\t\t\texpectedType = methodSubstitute.returnType.erasure();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\texpectedType = scope.getJavaLangObject(); ", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tmethodSubstitute = methodSubstitute.inferFromExpectedType(scope, expectedType, collectedSubstitutes, substitutes);", "+\t\t\t\tif (methodSubstitute == null) ", "+\t\t\t\t\treturn null;", "+\t\t\t}", "+\t\t}", "+\t\t// bounds check", "+\t\tif (!methodSubstitute.isRaw) {", "+\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "+\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "+\t\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitute))", "+\t\t\t        // incompatible due to bound check", "+\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitute, typeVariables[i] }, ParameterBoundMismatch);", "+\t\t\t}", "+\t\t}", "+", "+\t\treturn methodSubstitute;", "+\t}", "-\t */\t", "-\tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {", "-\t\t", "-\t\tParameterizedGenericMethodBinding methodSubstitute;", "-\t\tTypeVariableBinding[] typeVariables = originalMethod.typeVariables;", "-\t\tTypeBinding[] substitutes = invocationSite.genericTypeArguments();", "-\t\t", "-\t\tif (substitutes != null) {", "-\t\t\tif (substitutes.length != typeVariables.length) {", "-\t\t        // incompatible due to wrong arity", "-\t\t        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, TypeParameterArityMismatch);", "-\t\t\t}", "-\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t} else {", "-\t\t\t// perform type inference based on argument types and expected type", "-\t\t\t", "-\t\t\t// collect substitutes by pattern matching parameters and arguments", "-\t\t\tTypeBinding[] parameters = originalMethod.parameters;", "-\t\t\tint varLength = typeVariables.length;", "-\t\t\tHashMap collectedSubstitutes = new HashMap(varLength);", "-\t\t\tfor (int i = 0; i < varLength; i++)", "-\t\t\t\tcollectedSubstitutes.put(typeVariables[i], new TypeBinding[1]);", "-\t\t\t", "-\t\t\t// collect argument type mapping, handling varargs", "-\t\t\tif (originalMethod.isVarargs()) {", "-\t\t\t\tint paramLength = parameters.length;", "-\t\t\t\tint minArgLength = paramLength - 1;", "-\t\t\t\tint argLength = arguments.length;", "-\t\t\t\t// process mandatory arguments", "-\t\t\t\tfor (int i = 0; i < minArgLength; i++)", "-\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t\t// process optional arguments", "-\t\t\t\tif (minArgLength < argLength) {", "-\t\t\t\t\tTypeBinding varargType = parameters[minArgLength]; // last arg type - as is ?", "-\t\t\t\t\tif (paramLength != argLength // argument is passed as is ?", "-\t\t\t\t\t\t\t||  (arguments[minArgLength] != NullBinding", "-\t\t\t\t\t\t\t\t\t&& (arguments[minArgLength].dimensions() == 0))) { ", "-\t\t\t\t\t\tvarargType = ((ArrayBinding)varargType).elementsType(); // eliminate one array dimension", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int i = minArgLength; i < argLength; i++)", "-\t\t\t\t\t\tvarargType.collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tint paramLength = parameters.length;", "-\t\t\t\tfor (int i = 0; i < paramLength; i++)", "-\t\t\t\t\tparameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);", "-\t\t\t}", "-\t\t\tboolean needReturnTypeInference = false;", "-\t\t\tif (collectedSubstitutes.isEmpty()) {", "-\t\t\t\t// raw generic method inferred", "-\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, (RawTypeBinding)null, scope.environment());", "-\t\t\t} else {", "-\t\t\t\tsubstitutes = new TypeBinding[varLength];", "-\t\t\t\tfor (int i = 0; i < varLength; i++) {", "-\t\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) collectedSubstitutes.get(typeVariables[i]);", "-\t\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\t\t\tif (mostSpecificSubstitute == null)", "-\t\t\t\t\t\treturn null; // incompatible", "-\t\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "-\t\t\t\t\t\tneedReturnTypeInference = true;", "-\t\t\t\t\t    mostSpecificSubstitute = typeVariables[i];", "-\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tsubstitutes[i] = mostSpecificSubstitute;", "-\t\t\t\t}", "-\t\t\t\t// apply inferred variable substitutions", "-\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t\t}", "-\t", "-\t\t\tif (needReturnTypeInference && invocationSite instanceof MessageSend) {", "-\t\t\t\tMessageSend message = (MessageSend) invocationSite;", "-\t\t\t\tTypeBinding expectedType = message.expectedType;", "-\t\t\t\tif (expectedType == null) {", "-\t\t\t\t\t// 15.12.2.8 - if no expected type, then assume Object", "-\t\t\t\t\t// actually it rather seems to handle the returned variable case by expecting its erasure instead", "-\t\t\t\t\tif (methodSubstitute.returnType.isTypeVariable()) {", "-\t\t\t\t\t\texpectedType = methodSubstitute.returnType.erasure();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\texpectedType =scope.getJavaLangObject(); ", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tmethodSubstitute.inferFromExpectedType(expectedType, scope);", "-\t\t\t}", "-\t\t}", "-\t\t// check bounds", "-\t\tif (!methodSubstitute.isRaw) {", "-\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "-\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "-\t\t\t    TypeBinding substitute = substitutes[i];", "-\t\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitute))", "-\t\t\t        // incompatible due to bound check", "-\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitutes[i], typeVariables[i] }, ParameterBoundMismatch);", "-\t\t\t}", "-\t\t}", "-\t\treturn methodSubstitute;"]}], "num": 18369}