{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fc35532cdd963573b96b565a0b55057a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "446fda15b66909816064c0153d5f284e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "7eeea60289161cbc82181c2049d38d6375b340c4", "commitAfterChange": "bac0b688c9760eba84723fa01c9ef8fce3bf0175", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic TypeBinding[] getSolutions(TypeVariableBinding[] typeParameters, InvocationSite site, BoundSet boundSet)", "signatureAfterChange": " \tpublic TypeBinding[] getSolutions(TypeVariableBinding[] typeParameters, InvocationSite site, BoundSet boundSet)", "diff": ["+\t\tInferenceVariable[] outerVariables = null;", "+\t\tif (this.outerContext != null && this.outerContext.stepCompleted < TYPE_INFERRED)", "+\t\t\touterVariables = this.outerContext.inferenceVariables;", "-\t\t\t\t\tsubstitutions[i] = boundSet.getInstantiation(variable, this.environment);", "+\t\t\t\t\tTypeBinding outerVar = null;", "+\t\t\t\t\tif (outerVariables != null && (outerVar = boundSet.getEquivalentOuterVariable(variable, outerVariables)) != null)", "+\t\t\t\t\t\tsubstitutions[i] = outerVar;", "+\t\t\t\t\telse", "+\t\t\t\t\t\tsubstitutions[i] = boundSet.getInstantiation(variable, this.environment);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4ff32933964b3639579ac29c2811e38f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java", "commitBeforeChange": "1302cba8a2d9e7deb014096a0cf438c7f031d8f4", "commitAfterChange": "629f19b9848dc98d62568a3c9b1db94e81597d7a", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tpublic TypeBinding substitute(TypeBinding originalType)", "signatureAfterChange": " \tpublic TypeBinding substitute(TypeBinding originalType)", "diff": ["+\t\t\t\tReferenceBinding substitutedEnclosing = originalType.enclosingType();", "+\t\t\t\tif (substitutedEnclosing != null) {", "+\t\t\t\t\tsubstitutedEnclosing = (ReferenceBinding) this.substitute(substitutedEnclosing);", "+\t\t\t\t}\t\t\t\t", "-\t\t\t\treturn this.environment.createRawType(originalParameterizedType.type, originalParameterizedType.enclosingType());", "+\t\t\t\treturn this.environment.createRawType(originalParameterizedType.type, substitutedEnclosing);", "-\t            return this.environment.createRawType((ReferenceBinding)originalType, null);", "+\t\t\t\tsubstitutedEnclosing = originalType.enclosingType();", "+\t\t\t\tif (substitutedEnclosing != null) {", "+\t\t\t\t\tsubstitutedEnclosing = (ReferenceBinding) this.substitute(substitutedEnclosing);", "+\t\t\t\t}\t\t\t\t", "+\t            return this.environment.createRawType((ReferenceBinding)originalType, substitutedEnclosing);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94671b65c6017d1cbfe4eb87e545eae1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding18.java", "commitBeforeChange": "16915e9c0afdeb5e545794cd2c3b24bc7875ce66", "commitAfterChange": "df4a3da6e8d30ada6824d136133377b3a37cfebb", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tTypeBinding substituteInferenceVariable(InferenceVariable var, TypeBinding substituteType)", "signatureAfterChange": "  \tTypeBinding substituteInferenceVariable(InferenceVariable var, TypeBinding substituteType)", "diff": ["+\t\t\tTypeBinding currentFirstBound = null;", "+\t\t\tif (this.firstBound != null) {", "+\t\t\t\tcurrentFirstBound = this.firstBound.substituteInferenceVariable(var, substituteType);", "+\t\t\t\thaveSubstitution |= TypeBinding.notEquals(this.firstBound, currentFirstBound);", "+\t\t\t}", "+\t\t\t\tif (currentFirstBound != null)", "+\t\t\t\t\tnewCapture.firstBound = Scope.substitute(substitution, currentFirstBound);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b10d3ea9e2978bc1eb3fe186b2097bb1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java", "commitBeforeChange": "23d031b1b77753b1109ce0253088a2b7f49a7000", "commitAfterChange": "80f6342a7f709a2d6fe0cf3f1274abc00b566ec7", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "      @Override     public TypeMirror erasure(TypeMirror t)", "signatureAfterChange": "      @Override     public TypeMirror erasure(TypeMirror t)", "diff": ["-            return _env.getFactory().newTypeMirror(((ReferenceBinding) binding).erasure());", "+        \tTypeBinding type = ((ReferenceBinding) binding).erasure();", "+        \tif (type.isGenericType()) {", "+        \t\ttype = _env.getLookupEnvironment().convertToRawType(type, false);", "+        \t}", "+            return _env.getFactory().newTypeMirror(type);", "+            TypeBinding leafType = typeBinding.leafComponentType().erasure();", "+            if (leafType.isGenericType()) {", "+            \tleafType = _env.getLookupEnvironment().convertToRawType(leafType, false);", "+            }", "-                    this._env.getLookupEnvironment().createArrayType(", "-                            typeBinding.leafComponentType().erasure(),", "+                    this._env.getLookupEnvironment().createArrayType(leafType,"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f5692e64dc91949a52f1bb75e78672a3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["+\t\tInferenceContext inferenceContext = null;", "-\t\t\tInferenceContext inferenceContext = new InferenceContext(originalMethod);", "+\t\t\tinferenceContext = new InferenceContext(originalMethod);", "-\t\t// bounds check", "+\t\t/* bounds check: https://bugs.eclipse.org/bugs/show_bug.cgi?id=242159, Inferred types may contain self reference", "+\t\t   in formal bounds. If \"T extends I<T>\" is a original type variable and T was inferred to be I<T> due possibly", "+\t\t   to under constraints and resultant glb application per 15.12.2.8, using this.typeArguments to drive the bounds", "+\t\t   check against itself is doomed to fail. For, the variable T would after substitution be I<I<T>> and would fail", "+\t\t   bounds check against I<T>. Use the inferred types from the context directly - see that there is one round of", "+\t\t   extra substitution that has taken place to properly substitute a remaining unresolved variable which also appears", "+\t\t   in a formal bound  (So we really have a bounds mismatch between I<I<T>> and I<I<I<T>>>, in the absence of a fix.)", "+\t\t*/", "+\t\tSubstitution substitution = null;", "+\t\tif (inferenceContext != null) {", "+\t\t\tsubstitution = new LingeringTypeVariableEliminator(typeVariables, inferenceContext.substitutes, scope);", "+\t\t} else {", "+\t\t\tsubstitution = methodSubstitute;", "+\t\t}", "-\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i];", "+\t\t    TypeBinding substitute = methodSubstitute.typeArguments[i]; // retain for diagnostics", "+\t\t    TypeBinding substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check", "-\t\t\tswitch (typeVariable.boundCheck(methodSubstitute, substitute)) {", "+\t\t\tswitch (typeVariable.boundCheck(substitution, substituteForChecks)) {"]}], "num": 18138}