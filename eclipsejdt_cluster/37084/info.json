{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d9c0094d579db7d02bb3885f7f1eb956", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3051aa32fdb49a442ac383d26316cd96", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "03e37ed5506ed50fa30b9f5aa42ff423995a94bd", "commitAfterChange": "4111f058addae7e2d753cc95bd7546b1f787e4c8", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 38, "signatureBeforeChange": " public static char[] toCharArray(char[] signature) throws IllegalArgumentException", "signatureAfterChange": " public static char[] toCharArray(char[] signature) throws IllegalArgumentException", "diff": ["-\ttry {", "-", "-\t\t// compute result length", "-\t\tint resultLength = 0;", "-\t\tint index = -1;", "-\t\twhile (signature[++index] == C_ARRAY) {", "-\t\t\tresultLength += 2; // []", "+\t\tStringBuffer buffer = new StringBuffer(signature.length + 10);", "+\t\tappendTypeSignature(signature, 0, true, buffer);", "+\t\tchar[] result = new char[buffer.length()];", "+\t\tbuffer.getChars(0, buffer.length(), result, 0);", "+\t\treturn result;", "+}", "-\t\tswitch (signature[index]) {", "-\t\t\tcase C_BOOLEAN :", "-\t\t\t\tresultLength += BOOLEAN.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_BYTE :", "-\t\t\t\tresultLength += BYTE.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_CHAR :", "-\t\t\t\tresultLength += CHAR.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_DOUBLE :", "-\t\t\t\tresultLength += DOUBLE.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_FLOAT :", "-\t\t\t\tresultLength += FLOAT.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_INT :", "-\t\t\t\tresultLength += INT.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_LONG :", "-\t\t\t\tresultLength += LONG.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_SHORT :", "-\t\t\t\tresultLength += SHORT.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_VOID :", "-\t\t\t\tresultLength += VOID.length;", "-\t\t\t\tbreak;", "-\t\t\tcase C_TYPE_VARIABLE :", "-\t\t\t\t// TODO (jeem) - needs to handle type arguments", "-\t\t\t\tint end = CharOperation.indexOf(C_SEMICOLON, signature, index);", "-\t\t\t\tif (end == -1) throw new IllegalArgumentException();", "-\t\t\t\tint start = index + 1;", "-\t\t\t\tresultLength += end-start;", "-\t\t\t\tbreak;", "-\t\t", "-\t\tchar[] result = new char[resultLength];", "-\t\tcopyType(signature, 0, result, 0, true);", "-", "-\t\t/**", "-\t\t * Converts '$' separated type signatures into '.' separated type signature.", "-\t\t * NOTE: This assumes that the type signature is an inner type signature.", "-\t\t *       This is true in most cases, but someone can define a non-inner type ", "-\t\t *       name containing a '$'. However to tell the difference, we would have", "-\t\t *       to resolve the signature, which cannot be done at this point.", "-\t\t */", "-\t\tCharOperation.replace(result, C_DOLLAR, C_DOT);", "-", "-\t\treturn result;", "-\t} catch (ArrayIndexOutOfBoundsException e) {", "-\t\tthrow new IllegalArgumentException();", "-\t}\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82edbb86b925983e17411bb2882b0df6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "3b5e3bffb50578beec025e97315d017361527518", "commitAfterChange": "5c86bd5e83cfca7ff5f98996f0b172644cacbee7", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 29, "signatureBeforeChange": "\r public static String toString(String signature) throws IllegalArgumentException", "signatureAfterChange": "\r public static String toString(String signature) throws IllegalArgumentException", "diff": ["-\ttry {\r", "-\t\tif (signature.charAt(0) == C_PARAM_START) {\r", "-\t\t\treturn toString(signature, \"\", null, true, true); //$NON-NLS-1$\r", "-\t\t}\r", "-\t\tint arrayCount = getArrayCount(signature);\r", "-\t\tswitch (signature.charAt(arrayCount)) {\r", "-\t\t\tcase C_BOOLEAN :\r", "-\t\t\t\treturn arrayIfy(\"boolean\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_BYTE :\r", "-\t\t\t\treturn arrayIfy(\"byte\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_CHAR :\r", "-\t\t\t\treturn arrayIfy(\"char\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_DOUBLE :\r", "-\t\t\t\treturn arrayIfy(\"double\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_FLOAT :\r", "-\t\t\t\treturn arrayIfy(\"float\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_INT :\r", "-\t\t\t\treturn arrayIfy(\"int\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_LONG :\r", "-\t\t\t\treturn arrayIfy(\"long\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_SHORT :\r", "-\t\t\t\treturn arrayIfy(\"short\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_VOID :\r", "-\t\t\t\treturn arrayIfy(\"void\", arrayCount); //$NON-NLS-1$\r", "-\t\t\tcase C_RESOLVED :\r", "-\t\t\tcase C_UNRESOLVED :\r", "-\t\t\t\tint semi = signature.indexOf(C_SEMICOLON, arrayCount + 1);\r", "-\t\t\t\tif (semi == -1)\r", "-\t\t\t\t\tthrow new IllegalArgumentException();\r", "-\t\t\t\t\t\r", "-\t\t\t\t/**\r", "-\t\t\t\t * Converts '$' separated type signatures into '.' separated type signature.\r", "-\t\t\t\t * NOTE: This assumes that the type signature is an inner type signature.\r", "-\t\t\t\t *       This is true in most cases, but someone can define a non-inner type \r", "-\t\t\t\t *       name containing a '$'. However to tell the difference, we would have\r", "-\t\t\t\t *       to resolve the signature, which cannot be done at this point.\r", "-\t\t\t\t */\r", "-\t\t\t\tString qualifiedTypeName = signature.substring(arrayCount+1, semi).replace(C_DOLLAR, C_DOT);\r", "-\t\t\t\t\r", "-\t\t\t\treturn arrayIfy(qualifiedTypeName, arrayCount);\r", "-\t\t\tdefault :\r", "-\t\t\t\tthrow new IllegalArgumentException();\r", "-\t\t}\r", "-\t} catch (StringIndexOutOfBoundsException e) {\r", "-\t\tthrow new IllegalArgumentException();\r", "-\t}\r", "+\treturn new String(toCharArray(signature.toCharArray()));\r"]}], "num": 37084}