{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "738828760e87acf67f4aefac44697b3a", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "096ba91f599a5cb5905c7dfb44ee9a1f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding left, Scope scope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope)", "diff": ["-\tpublic boolean isCompatibleWith(TypeBinding left, Scope scope) {", "-\t\tif (this.binding != null && this.binding.isValidBinding() // binding indicates if full resolution has already happened", "-\t\t\t\t&& this.resolvedType != null && this.resolvedType.isValidBinding()) {", "-\t\t\treturn this.resolvedType.isCompatibleWith(left, scope);", "-\t\t}", "+\tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope) {", "+\t\tReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "+\t\tif (copy != null)", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "+\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tfinal MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\tboolean isCompatible;", "-\t\tsetExpectedType(left);", "-\t\t\tthis.binding = null;", "-\t\t\tthis.trialResolution = true;", "-\t\t\tthis.binding = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(left) : null;", "-\t\t\tif (this.binding == null) {", "-\t\t\t\tresolveType(this.enclosingScope);", "-\t\t\t\tregisterResult(left, this.binding);", "+\t\t\tcopy = copy();", "+\t\t\tif (copy == null) { // should never happen even for code assist.", "+\t\t\t\treturn false;", "+\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\tcopy.setExpectedType(targetType);", "+\t\t\tcopy.resolveType(this.enclosingScope);", "+\t\t\tregisterCopy(targetType, copy);", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "-\t\t\tisCompatible = this.binding != null && this.binding.isValidBinding();", "-\t\t\tthis.binding = null;", "-\t\t\tsetExpectedType(null);", "-\t\t\tthis.trialResolution = false;", "-\t\treturn isCompatible;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0ecb59a3c2f39d9cce3536a32920c981", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope)", "signatureAfterChange": " \t \tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope)", "diff": ["-\tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope) {", "-\t", "-\t\tif (this.exactMethodBinding != null) { // We may see inference variables in target type.", "-\t\t\tMethodBinding functionType = targetType.getSingleAbstractMethod(scope, true);", "-\t\t\tif (functionType == null)", "-\t\t\t\treturn null;", "-\t\t\tint n = functionType.parameters.length;", "-\t\t\tint k = this.exactMethodBinding.parameters.length;", "-\t\t\treturn (n == k || n == k + 1) ? this : null;", "-\t\t}", "-\t\t", "-\t\t// We are guaranteed here that we will not see inference variables in descriptor parameters.", "-\t\t\tregisterCopy(targetType, copy);", "-\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding() ? copy : null;", "+\t", "+\tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope) {", "+\t\tif (this.exactMethodBinding != null) { // We may see inference variables in target type.", "+\t\t\tMethodBinding functionType = targetType.getSingleAbstractMethod(scope, true);", "+\t\t\tif (functionType == null)", "+\t\t\t\treturn null;", "+\t\t\tint n = functionType.parameters.length;", "+\t\t\tint k = this.exactMethodBinding.parameters.length;", "+\t\t\treturn (n == k || n == k + 1) ? this : null;", "+\t\t}", "+\t\t// descriptors parameters should be free of inference variables.", "+\t\tReferenceExpression copy = cachedResolvedCopy(targetType); ", "+\t\treturn copy != null && copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding() ? copy : null;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6fe86975f1604f66746d4a7c51e16c7f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope)", "signatureAfterChange": "  \tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope)", "diff": ["-\t/** During inference: Try to find an applicable method binding without causing undesired side-effects. */", "-\tpublic MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope) {", "-\t\tif (this.exactMethodBinding != null) {", "+\tpublic ReferenceExpression resolveExpressionExpecting(TypeBinding targetType, Scope scope) {", "+\t", "+\t\tif (this.exactMethodBinding != null) { // We may see inference variables in target type.", "-\t\t\treturn (n == k || n == k + 1) ? this.exactMethodBinding : null;", "+\t\t\treturn (n == k || n == k + 1) ? this : null;", "-\t\tMethodBinding targetMethod = this.declarationPerTargetType != null ? this.declarationPerTargetType.get(targetType) : null;", "-\t\tif (targetMethod == null) {", "-\t\t\ttargetMethod = internalResolveTentatively(targetType, scope);", "-\t\t\tregisterResult(targetType, targetMethod);", "-\t\t}", "-\t\tif (targetMethod == null || !targetMethod.isValidBinding())", "-\t\t\treturn null;", "-\t\treturn targetMethod;", "-\t}", "+\t\t", "+\t\t// We are guaranteed here that we will not see inference variables in descriptor parameters.", "+\t\tReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "+\t\tif (copy != null)", "+\t\t\treturn copy;", "+\t\t", "+\t\t\tcopy = copy();", "+\t\t\tif (copy == null) { // should never happen even for code assist.", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\tcopy.setExpectedType(targetType);", "+\t\t\tcopy.resolveType(this.enclosingScope);", "+\t\t\tregisterCopy(targetType, copy);", "+\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding() ? copy : null;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff14950b16c989aa704c38df00bf5cab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 12, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope)", "signatureAfterChange": " \tprivate ReferenceExpression cachedResolvedCopy(TypeBinding targetType)", "diff": ["+\t// Cache resolved copies against various target types, so repeat overload resolution and possibly type inference could be avoided.", "+\tprivate ReferenceExpression cachedResolvedCopy(TypeBinding targetType) {", "+", "+\t\t\t", "+\t\t\tif (this.copiesPerTargetType == null)", "+\t\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, ReferenceExpression>();", "+\t\t\tthis.copiesPerTargetType.put(targetType, copy);", "+\t\t\t", "+\t\t\treturn copy;", "-\t\tReferenceExpression copy = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "-\t\tif (copy != null)", "-\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "-\t\t", "-\t\t// 15.13.2", "-\t\tfinal MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\tif (sam == null || !sam.isValidBinding())", "-\t\t\treturn false;", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\ttry {", "-\t\t\tcopy = copy();", "-\t\t\tif (copy == null) { // should never happen even for code assist.", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t\tcopy.setExpressionContext(this.expressionContext);", "-\t\t\tcopy.setExpectedType(targetType);", "-\t\t\tcopy.resolveType(this.enclosingScope);", "-\t\t\tregisterCopy(targetType, copy);", "-\t\t\treturn copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();", "-\t\t} finally {", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t}"]}], "num": 21740}