{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "170b56fa6d8955810b40f0f6a91016a6", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b962ab13452f2d2fddffea90106a3f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": " \tprivate void updateClasspathMarkers(IResourceDelta delta, DeltaProcessingState.ProjectUpdateInfo[] updates)", "signatureAfterChange": " \tprivate void validateClasspaths(IResourceDelta delta)", "diff": ["-\tprivate void updateClasspathMarkers(IResourceDelta delta, DeltaProcessingState.ProjectUpdateInfo[] updates) {", "-\t\t", "-\t\tMap preferredClasspaths = new HashMap(5);", "-\t\tMap preferredOutputs = new HashMap(5);", "+\tprivate void validateClasspaths(IResourceDelta delta) {", "-\t\t", "-\t\t// read .classpath files that have changed, and create markers if format is wrong or if an entry cannot be found", "-\t\tJavaModel.flushExternalFileCache();", "-\t\tupdateClasspathMarkers(delta, affectedProjects, preferredClasspaths, preferredOutputs); ", "+\t\tvalidateClasspaths(delta, affectedProjects); ", "-\t\t// update .classpath format markers for affected projects (dependent projects ", "+\t\t// validate classpaths of affected projects (dependent projects ", "-\t\t\t\tif (preferredClasspaths.get(javaProject) == null) { // not already updated", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tIPath projectPath = project.getFullPath();", "-\t\t\t\t\t\tIClasspathEntry[] classpath = javaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/); // allowed to reuse model cache", "-\t\t\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++) {", "-\t\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "-\t\t\t\t\t\t\tswitch (entry.getEntryKind()) {", "-\t\t\t\t\t\t\t\tcase IClasspathEntry.CPE_PROJECT:", "-\t\t\t\t\t\t\t\t\tif (affectedProjects.contains(entry.getPath())) {", "-\t\t\t\t\t\t\t\t\t\tjavaProject.updateClasspathMarkers(null, null);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "-\t\t\t\t\t\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\t\t\t\t\t\tIPath libProjectPath = entryPath.removeLastSegments(entryPath.segmentCount()-1);", "-\t\t\t\t\t\t\t\t\tif (!libProjectPath.equals(projectPath) // if library contained in another project", "-\t\t\t\t\t\t\t\t\t\t\t&& affectedProjects.contains(libProjectPath)) {", "-\t\t\t\t\t\t\t\t\t\tjavaProject.updateClasspathMarkers(null, null);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "+\t\t\t\ttry {", "+\t\t\t\t\tIPath projectPath = project.getFullPath();", "+\t\t\t\t\tIClasspathEntry[] classpath = javaProject.getResolvedClasspath(); // allowed to reuse model cache", "+\t\t\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++) {", "+\t\t\t\t\t\tIClasspathEntry entry = classpath[j];", "+\t\t\t\t\t\tswitch (entry.getEntryKind()) {", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_PROJECT:", "+\t\t\t\t\t\t\t\tif (affectedProjects.contains(entry.getPath())) {", "+\t\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "+\t\t\t\t\t\t\t\tIPath entryPath = entry.getPath();", "+\t\t\t\t\t\t\t\tIPath libProjectPath = entryPath.removeLastSegments(entryPath.segmentCount()-1);", "+\t\t\t\t\t\t\t\tif (!libProjectPath.equals(projectPath) // if library contained in another project", "+\t\t\t\t\t\t\t\t\t\t&& affectedProjects.contains(libProjectPath)) {", "+\t\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(javaProject);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t} catch(JavaModelException e) {", "-\t\t\t\t\t\t\t// project no longer exists", "+\t\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t\t\t// project no longer exists", "-\t\t\t}", "-\t\t}", "-\t\tif (!affectedProjects.isEmpty() || updates != null) {", "-\t\t\t// update all cycle markers since the given delta may have affected cycles", "-\t\t\tif (updates != null) {", "-\t\t\t\tfor (int i = 0, length = updates.length; i < length; i++) {", "-\t\t\t\t\tDeltaProcessingState.ProjectUpdateInfo info = updates[i];", "-\t\t\t\t\tif (!preferredClasspaths.containsKey(info.project))", "-\t\t\t\t\t\tpreferredClasspaths.put(info.project, info.newResolvedPath);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\ttry {", "-\t\t\t\tJavaProject.updateAllCycleMarkers(preferredClasspaths);", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// project no longer exist"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ba6602ed65fdbf19c1674408a823b6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "10a59ab8fb6256e59e155c071a356402964eb736", "commitAfterChange": "bacbe6f6e994ffc49a94960691c76bff97cb04d5", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t\t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t\t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\tif (!this.shapeAnalysisComplete && this.body instanceof Expression) {", "-\t\t\tExpression expression = (Expression) this.body;", "-\t\t\tthis.voidCompatible = expression.statementExpression();", "-\t\t\tthis.valueCompatible = true;", "-\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t}", "-", "-\t\tif (this.shapeAnalysisComplete) {", "-\t\t\tif (squarePegInRoundHole(sam))", "-\t\t\t\treturn false;", "-\t\t} ", "-", "-\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "-\t\ttry {", "-\t\t\tfinal LambdaExpression copy = copy();", "-\t\t\tif (copy == null)", "-\t\t\t\treturn false;", "-\t\t\tcopy.setExpressionContext(this.expressionContext);", "-\t\t\tcopy.setExpectedType(left);", "-\t\t\tif (this.resultExpressions == null)", "-\t\t\t\tthis.resultExpressions = new SimpleLookupTable(); // gather result expressions for most specific method analysis.", "-\t\t\tthis.resultExpressions.put(left, new Expression[0]);", "-\t\t\tcopy.resolveType(this.enclosingScope);", "-\t\t\tif (!this.shapeAnalysisComplete) {", "-\t\t\t\tif (!this.returnsVoid && !this.returnsValue && this.throwsException) {  // () -> { throw new Exception(); } is value compatible.", "-\t\t\t\t\tBlock block = (Block) this.body;", "-\t\t\t\t\tfinal Statement[] statements = block.statements;", "-\t\t\t\t\tfinal int statementsLength = statements == null ? 0 : statements.length;", "-\t\t\t\t\tStatement ultimateStatement = statementsLength == 0 ? null : statements[statementsLength - 1];", "-\t\t\t\t\tthis.valueCompatible = ultimateStatement instanceof ThrowStatement ? true: copy.doesNotCompleteNormally(); ", "-\t\t\t\t}", "-\t\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t\t\tif (squarePegInRoundHole(sam))", "+\t\tif (!this.shapeAnalysisComplete) {", "+\t\t\tIErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);", "+\t\t\ttry {", "+\t\t\t\tfinal LambdaExpression copy = copy();", "+\t\t\t\tif (copy == null)", "+\t\t\t\tcopy.setExpressionContext(this.expressionContext);", "+\t\t\t\tcopy.setExpectedType(left);", "+\t\t\t\tcopy.resolveType(this.enclosingScope);", "+", "+\t\t\t\tif (!argumentsTypeElided()) {", "+\t\t\t\t\tthis.argumentTypes = copy.argumentTypes;", "+\t\t\t\t}", "+\t\t\t", "+\t\t\t\tif (this.body instanceof Block) {", "+\t\t\t\t\tif (!this.returnsVoid) {", "+\t\t\t\t\t\tthis.valueCompatible = copy.doesNotCompleteNormally();", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tthis.voidCompatible = ((Expression) this.body).statementExpression();", "+\t\t\t\t}", "+\t\t\t", "+\t\t\t} finally {", "+\t\t\t\tthis.shapeAnalysisComplete = true;", "+\t\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\t} finally {", "-\t\t\tthis.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);", "-\t\treturn true;", "+", "+\t\treturn !squarePegInRoundHole(sam);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d98adc87be06f11d57367eecad6ee44", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java", "commitBeforeChange": "7cbfac0f262651a92552aa1b245acf5ef1db3bb0", "commitAfterChange": "b6e21c793f3617f9c60f843e02a0537d5bd09d93", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \t@Override \tpublic List<? extends VariableElement> getParameters()", "signatureAfterChange": "  \t@Override \tpublic List<? extends VariableElement> getParameters()", "diff": ["-\t\t\t\tboolean isEnumConstructor = binding.isConstructor()", "-\t\t\t\t\t\t&& binding.declaringClass.isEnum()", "-\t\t\t\t\t\t&& binding.declaringClass.isBinaryBinding()", "-\t\t\t\t\t\t&& ((binding.modifiers & ExtraCompilerModifiers.AccGenericSignature) == 0);", "-\t\t\t\tif (isEnumConstructor) {", "-\t\t\t\t\tif (length == 2) {", "-\t\t\t\t\t\t// the two arguments are only the two synthetic arguments", "-\t\t\t\t\t\treturn Collections.emptyList();", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int i = 2; i < length; i++) {", "-\t\t\t\t\t\tTypeBinding typeBinding = binding.parameters[i];", "-\t\t\t\t\t\tStringBuilder builder = new StringBuilder(\"arg\");//$NON-NLS-1$", "-\t\t\t\t\t\tbuilder.append(i - 2);", "-\t\t\t\t\t\tVariableElement param = new VariableElementImpl(_env,", "-\t\t\t\t\t\t\t\tnew AptBinaryLocalVariableBinding(", "-\t\t\t\t\t\t\t\t\t\tString.valueOf(builder).toCharArray(),", "-\t\t\t\t\t\t\t\t\t\ttypeBinding,", "-\t\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\t\tnull,", "-\t\t\t\t\t\t\t\t\t\tbinding));", "-\t\t\t\t\t\tparams.add(param);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tint i = 0;", "-\t\t\t\t\tfor (TypeBinding typeBinding : binding.parameters) {", "-\t\t\t\t\t\tStringBuilder builder = new StringBuilder(\"arg\");//$NON-NLS-1$", "+\t\t\t\tint i = 0;", "+\t\t\t\tfor (TypeBinding typeBinding : binding.parameters) {", "+\t\t\t\t\tchar name[] = binding.parameterNames.length > i ? binding.parameterNames[i] : null;", "+\t\t\t\t\tif (name == null) {", "+ \t\t\t\t\t\tStringBuilder builder = new StringBuilder(\"arg\");//$NON-NLS-1$", "-\t\t\t\t\t\tVariableElement param = new VariableElementImpl(_env,", "-\t\t\t\t\t\t\t\tnew AptBinaryLocalVariableBinding(", "-\t\t\t\t\t\t\t\t\t\tString.valueOf(builder).toCharArray(),", "-\t\t\t\t\t\t\t\t\t\ttypeBinding,", "-\t\t\t\t\t\t\t\t\t\t0,", "-\t\t\t\t\t\t\t\t\t\tparameterAnnotationBindings != null ? parameterAnnotationBindings[i] : null,", "-\t\t\t\t\t\t\t\t\t\tbinding));", "-\t\t\t\t\t\tparams.add(param);", "-\t\t\t\t\t\ti++;", "+\t\t\t\t\t\tname = String.valueOf(builder).toCharArray();", "+\t\t\t\t\tVariableElement param = new VariableElementImpl(_env,", "+\t\t\t\t\t\t\tnew AptBinaryLocalVariableBinding(", "+\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\ttypeBinding,", "+\t\t\t\t\t\t\t\t\t0,", "+\t\t\t\t\t\t\t\t\tparameterAnnotationBindings != null ? parameterAnnotationBindings[i] : null,", "+\t\t\t\t\t\t\t\t\tbinding));", "+\t\t\t\t\tparams.add(param);", "+\t\t\t\t\ti++;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e12aeb86f9ba514020b1f54184ada854", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathSourceJar.java", "commitBeforeChange": "a7e924b1651a1b9026ccc6590ce8e03365836a1b", "commitAfterChange": "d3da1d109c57a90a2bd8342736abf401463d58e5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String qualifiedBinaryFileName)", "signatureAfterChange": "  \tpublic NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String qualifiedBinaryFileName)", "diff": ["-\t\t\tZipEntry binaryEntry = this.zipFile.getEntry(qualifiedBinaryFileName);", "-\t\t\tif (binaryEntry != null) {", "-\t\t\t\tif (sourceEntry.getTime() > binaryEntry.getTime()) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\treturn new NameEnvironmentAnswer(new CompilationUnit(Util.getInputStreamAsCharArray(this.zipFile.getInputStream(sourceEntry), -1, this.encoding),", "-\t\t\t\t\t\t\t\tqualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - 6)  + SUFFIX_STRING_java, this.encoding),", "-\t\t\t\t\t\t\t\tfetchAccessRestriction(qualifiedBinaryFileName));", "-\t\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t\t// treat as if source file is missing", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);", "-\t\t\t\t\t\tif (reader != null) return new NameEnvironmentAnswer(reader, ", "-\t\t\t\t\t\t\t\tfetchAccessRestriction(qualifiedBinaryFileName));", "-\t\t\t\t\t} catch(ClassFormatException e) {", "-\t\t\t\t\t\t// treat as if class file is missing", "-\t\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t\t// treat as if class file is missing", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\ttry {", "-\t\t\t\t\treturn new NameEnvironmentAnswer(new CompilationUnit(Util.getInputStreamAsCharArray(this.zipFile.getInputStream(sourceEntry), -1, this.encoding),", "-\t\t\t\t\t\t\tqualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - 6)  + SUFFIX_STRING_java, this.encoding),", "-\t\t\t\t\t\t\tfetchAccessRestriction(qualifiedBinaryFileName));", "-\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t// treat as if source file is missing", "-\t\t\t\t}", "+\t\t\ttry {", "+\t\t\t\treturn new NameEnvironmentAnswer(new CompilationUnit(Util.getInputStreamAsCharArray(this.zipFile.getInputStream(sourceEntry), -1, this.encoding),", "+\t\t\t\t\t\tqualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - 6)  + SUFFIX_STRING_java, this.encoding),", "+\t\t\t\t\t\tfetchAccessRestriction(qualifiedBinaryFileName));", "+\t\t\t} catch (IOException e) {", "+\t\t\t\t// treat as if source file is missing"]}], "num": 43237}