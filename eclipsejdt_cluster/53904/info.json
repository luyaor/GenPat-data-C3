{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f300c8ee28cf8970be7d6486d425cc14", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "656d556557e4e43cbf74981e6b0748b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 29, "signatureBeforeChange": " private MethodBinding resolveTypesFor(MethodBinding method)", "signatureAfterChange": " private MethodBinding resolveTypesFor(MethodBinding method)", "diff": ["+    ", "+\tif (methodDecl == null) return null; // method could not be resolved in previous iteration", "+\t", "+\tTypeParameter[] typeParameters = methodDecl.typeParameters();", "+\tif (typeParameters != null) methodDecl.scope.connectTypeVariables(typeParameters);", "-\t\t\tresolvedExceptionType = (ReferenceBinding) exceptionTypes[i].getTypeBinding(scope);", "-\t\t\tif (!resolvedExceptionType.isValidBinding()) {", "-\t\t\t\tmethodDecl.scope.problemReporter().exceptionTypeProblem(this, methodDecl, exceptionTypes[i], resolvedExceptionType);", "-\t\t\t\t//methodDecl.scope.problemReporter().invalidType(exceptionTypes[i], resolvedExceptionType);", "+\t\t\tresolvedExceptionType = (ReferenceBinding) exceptionTypes[i].resolveType(methodDecl.scope);", "+\t\t\tif (resolvedExceptionType == null) {", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\tif (resolvedExceptionType.isGenericType() || resolvedExceptionType.isParameterizedType()) {", "+\t\t\t\tmethodDecl.scope.problemReporter().invalidParameterizedExceptionType(resolvedExceptionType, exceptionTypes[i]);", "+\t\t\t}", "+\t\t    if ((resolvedExceptionType.modifiers & AccGenericSignature) != 0) {", "+\t\t\t\tmethod.modifiers |= AccGenericSignature;", "-\t\t\tmethod.parameters[i] = arg.type.getTypeBinding(scope);", "-\t\t\tif (!method.parameters[i].isValidBinding()) {", "-\t\t\t\tmethodDecl.scope.problemReporter().argumentTypeProblem(this, methodDecl, arg, method.parameters[i]);", "-\t\t\t\t//methodDecl.scope.problemReporter().invalidType(arg, method.parameters[i]);", "+\t\t\tTypeBinding parameterType = arg.type.resolveType(methodDecl.scope);", "+\t\t\tif (parameterType == null) {", "-\t\t\t} else if (method.parameters[i] == VoidBinding) {", "+\t\t\t} else if (parameterType == VoidBinding) {", "-\t\t\t} else if (method.parameters[i].isArrayType() && ((ArrayBinding) method.parameters[i]).leafComponentType == VoidBinding) {", "+\t\t\t} else if (parameterType.isArrayType() && ((ArrayBinding) parameterType).leafComponentType == VoidBinding) {", "+\t\t\t} else {", "+\t\t\t    if (parameterType instanceof ReferenceBinding && (((ReferenceBinding)parameterType).modifiers & AccGenericSignature) != 0) {", "+\t\t\t\t\tmethod.modifiers |= AccGenericSignature;", "+\t\t\t\t}", "+\t\t\t\tmethod.parameters[i] = parameterType;", "-\t\tTypeReference returnType = ((MethodDeclaration) methodDecl).returnType;", "+\t\tTypeReference returnType = methodDecl instanceof MethodDeclaration", "+\t\t\t? ((MethodDeclaration) methodDecl).returnType", "+\t\t\t: ((AnnotationTypeMemberDeclaration) methodDecl).returnType;", "-\t\t\tmethod.returnType = returnType.getTypeBinding(scope);", "-\t\t\tif (!method.returnType.isValidBinding()) {", "-\t\t\t\tmethodDecl.scope.problemReporter().returnTypeProblem(this, (MethodDeclaration) methodDecl, method.returnType);", "-\t\t\t\t//methodDecl.scope.problemReporter().invalidType(returnType, method.returnType);", "-\t\t\t\tmethod.returnType = null;", "+\t\t    TypeBinding methodType = returnType.resolveType(methodDecl.scope);", "+\t\t\tif (methodType == null) {", "-\t\t\t} else if (method.returnType.isArrayType() && ((ArrayBinding) method.returnType).leafComponentType == VoidBinding) {", "+\t\t\t} else if (methodType.isArrayType() && ((ArrayBinding) methodType).leafComponentType == VoidBinding) {", "-\t\t\t\tmethod.returnType = null;", "+\t\t\t} else {", "+\t\t\t\tmethod.returnType = methodType;", "+\t\t\t\tif (methodType instanceof ReferenceBinding && (((ReferenceBinding)methodType).modifiers & AccGenericSignature) != 0) {", "+\t\t\t\t\tmethod.modifiers |= AccGenericSignature;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9483f59b32668cd38f3309458472b058", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java", "commitBeforeChange": "f342df887ac2bde5a33a69c02311bfd7246a7e43", "commitAfterChange": "aba5db418de65ea21899bfdf893833cd0fc3f586", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tprivate Object convertJDTPrimitiveToReflectionType(Object jdtValue, Class<?> expectedType)", "signatureAfterChange": " \tprivate Object convertJDTValueToReflectionType(Object jdtValue, TypeBinding actualType, Class<?> expectedType)", "diff": ["-\tprivate Object convertJDTPrimitiveToReflectionType(Object jdtValue, Class<?> expectedType) {", "-\t\tif (!(jdtValue instanceof Constant)) {", "+\tprivate Object convertJDTValueToReflectionType(Object jdtValue, TypeBinding actualType, Class<?> expectedType) {", "+\t\tif (expectedType.isPrimitive() || String.class.equals(expectedType)) {", "+\t\t\tif (jdtValue instanceof Constant) {", "+\t\t\t\tif (boolean.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).booleanValue();", "+\t\t\t\t}", "+\t\t\t\telse if (byte.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).byteValue();", "+\t\t\t\t}", "+\t\t\t\telse if (char.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).charValue();", "+\t\t\t\t}", "+\t\t\t\telse if (double.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).doubleValue();", "+\t\t\t\t}", "+\t\t\t\telse if (float.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).floatValue();", "+\t\t\t\t}", "+\t\t\t\telse if (int.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).intValue();", "+\t\t\t\t}", "+\t\t\t\telse if (long.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).longValue();", "+\t\t\t\t}", "+\t\t\t\telse if (short.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).shortValue();", "+\t\t\t\t}", "+\t\t\t\telse if (String.class.equals(expectedType)) {", "+\t\t\t\t\treturn ((Constant)jdtValue).stringValue();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// Primitive or string is expected, but our actual value cannot be coerced into one.", "+\t\t\t// TODO: if the actual value is an array of primitives, should we unpack the first one?", "-\t\tif (Boolean.class.equals(expectedType) || boolean.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).booleanValue();", "+\t\telse if (expectedType.isEnum()) {", "+\t\t\tObject returnVal = null;", "+\t        if (actualType != null && actualType.isEnum() && jdtValue instanceof FieldBinding) {", "+\t        \t", "+\t        \tFieldBinding binding = (FieldBinding)jdtValue;", "+\t        \ttry {", "+\t        \t\tField returnedField = null;", "+\t        \t\treturnedField = expectedType.getField( new String(binding.name) );", "+\t        \t\tif (null != returnedField) {", "+\t        \t\t\treturnVal = returnedField.get(null);", "+\t        \t\t}", "+\t        \t}", "+\t        \tcatch (NoSuchFieldException nsfe) {", "+\t        \t\t// return null", "+\t        \t}", "+\t        \tcatch (IllegalAccessException iae) {", "+\t        \t\t// return null", "+\t        \t}", "+\t        }", "+\t        return null == returnVal ? Factory.getMatchingDummyValue(expectedType) : returnVal;", "-\t\telse if (Byte.class.equals(expectedType) || byte.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).byteValue();", "-\t\t}", "-\t\telse if (Character.class.equals(expectedType) || char.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).charValue();", "-\t\t}", "-\t\telse if (Double.class.equals(expectedType) || double.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).doubleValue();", "-\t\t}", "-\t\telse if (Float.class.equals(expectedType) || float.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).floatValue();", "-\t\t}", "-\t\telse if (Integer.class.equals(expectedType) || int.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).intValue();", "-\t\t}", "-\t\telse if (Long.class.equals(expectedType) || long.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).longValue();", "-\t\t}", "-\t\telse if (String.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).stringValue();", "-\t\t}", "-\t\telse if (Short.class.equals(expectedType) || short.class.equals(expectedType)) {", "-\t\t\treturn ((Constant)jdtValue).shortValue();", "+\t\telse if (expectedType.isAnnotation()) {", "+\t\t\t// member value is expected to be an annotation type.  Wrap it in an Annotation proxy.", "+\t\t\tif (actualType.isAnnotationType() && jdtValue instanceof AnnotationBinding) {", "+\t\t\t\tAnnotationMirrorImpl annoMirror =", "+\t\t\t\t\t(AnnotationMirrorImpl)_env.getFactory().newAnnotationMirror((AnnotationBinding)jdtValue);", "+\t\t\t\treturn Proxy.newProxyInstance(expectedType.getClassLoader(),", "+\t\t\t\t\t\tnew Class[]{ expectedType }, annoMirror );", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\t// No way to cast a non-annotation value to an annotation type; return null to caller", "+\t\t\t\treturn null;", "+\t\t\t}"]}], "num": 53904}