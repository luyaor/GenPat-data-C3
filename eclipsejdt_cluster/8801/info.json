{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d6f52599389d46c8566daccad441c23a", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d65bc62d69c4d7915636f8fa0db2e92", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "6cd0099c2021e34815eaba987a586ae52dacf569", "commitAfterChange": "d6dc74869d8c303dbb7a6d8b327d8b104cd5865b", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tprivate ReferenceExpression registerCopy(TypeBinding targetType, ReferenceExpression copy)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(TypeBinding targetType, Scope scope)", "diff": ["-\t// Cache resolved copies against various target types, so repeat overload resolution and possibly type inference could be avoided.", "-\tprivate ReferenceExpression registerCopy(TypeBinding targetType, ReferenceExpression copy) {", "-\t\tif (this.copiesPerTargetType == null)", "-\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, ReferenceExpression>();", "-\t\tthis.copiesPerTargetType.put(targetType, copy);", "-\t\treturn copy;", "+\t\tReferenceExpression copy = cachedResolvedCopy(targetType);", "+\t\treturn copy != null && copy.resolvedType != null && copy.resolvedType.isValidBinding() && copy.binding != null && copy.binding.isValidBinding();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "787cd4f9c7aa8ad6f9cda45ce337be9e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 38, "signatureBeforeChange": " \tpublic LambdaExpression getResolvedCopyForInferenceTargeting(TypeBinding targetType)", "signatureAfterChange": " \tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope)", "diff": ["-\tpublic LambdaExpression getResolvedCopyForInferenceTargeting(TypeBinding targetType) {", "-\t\tLambdaExpression lambda = this.resolvedCopies != null ? this.resolvedCopies.get(targetType) : null;", "+\tpublic LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope) {", "+\t\tLambdaExpression lambda = this.copiesPerTargetType != null ? this.copiesPerTargetType.get(targetType) : null;", "-\t\t\tlambda = getResolvedCopyForInferenceTargeting0(targetType);", "-\t\t\tif (this.resolvedCopies == null)", "-\t\t\t\tthis.resolvedCopies = new HashMap<TypeBinding, LambdaExpression>();", "-\t\t\tthis.resolvedCopies.put(targetType, lambda);", "+\t\t\tlambda = getResolvedCopyForInferenceTargeting(targetType);", "+\t\t\tif (this.copiesPerTargetType == null)", "+\t\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();", "+\t\t\tthis.copiesPerTargetType.put(targetType, lambda);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fa280be9a3bd78b7c83dacc78ab9a35b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "9043b6a8e4132c7e53a6fb980711e9a0982fef9b", "commitAfterChange": "416292d2f4be39d514e933551cdaebb7c7ebd8a7", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprivate void registerResult(TypeBinding targetType, MethodBinding declaration)", "signatureAfterChange": " \tprivate ReferenceExpression registerCopy(TypeBinding targetType, ReferenceExpression copy)", "diff": ["-\t// Cache compile time declaration against various target types, so repeat overload resolution and possibly type inference could be avoided.", "-\tprivate void registerResult(TypeBinding targetType, MethodBinding declaration) {", "-\t\tif (this.declarationPerTargetType == null)", "-\t\t\tthis.declarationPerTargetType = new HashMap<TypeBinding, MethodBinding>();", "-\t\tthis.declarationPerTargetType.put(targetType, declaration);", "-\t}", "+\t// Cache resolved copies against various target types, so repeat overload resolution and possibly type inference could be avoided.", "+\tprivate ReferenceExpression registerCopy(TypeBinding targetType, ReferenceExpression copy) {", "+\t\tif (this.copiesPerTargetType == null)", "+\t\t\tthis.copiesPerTargetType = new HashMap<TypeBinding, ReferenceExpression>();", "+\t\tthis.copiesPerTargetType.put(targetType, copy);", "+\t\treturn copy;"]}], "num": 8801}