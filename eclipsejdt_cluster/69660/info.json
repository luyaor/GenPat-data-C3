{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7594db172575722d57ed17257a415edb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6f7a6e28f702a9d350a9d92a0e8eec52", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBound.java", "commitBeforeChange": "ff2fe8665a4cc197831509bf8ec85eecac35f7cf", "commitAfterChange": "b035f7a4c467249c63cc869fd5f75e4bad8cf303", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tTypeBound(InferenceVariable inferenceVariable, TypeBinding typeBinding, int relation, boolean isSoft)", "signatureAfterChange": " \t \tTypeBound(InferenceVariable inferenceVariable, TypeBinding typeBinding, int relation, boolean isSoft)", "diff": ["+\t\tif (((inferenceVariable.tagBits | this.right.tagBits) & TagBits.AnnotationNullMASK) != 0) {", "+\t\t\tif ((inferenceVariable.tagBits & TagBits.AnnotationNullMASK) == (this.right.tagBits & TagBits.AnnotationNullMASK)) {", "+\t\t\t\t// strip off identical nullness on both sides:", "+\t\t\t\tthis.left = (InferenceVariable) inferenceVariable.withoutToplevelNullAnnotation();", "+\t\t\t\tthis.right = this.right.withoutToplevelNullAnnotation();", "+\t\t\t} else {", "+\t\t\t\tlong mask = 0;", "+\t\t\t\t// extract hint, e.g.: T#0 <: @NonNull Right  =>  T#0 hinted as @NonNull", "+\t\t\t\tswitch (relation) {", "+\t\t\t\t\tcase SAME: \t\tmask = TagBits.AnnotationNullMASK; break;", "+\t\t\t\t\tcase SUBTYPE: \tmask = TagBits.AnnotationNonNull; break;  // sub of @Nullable is irrelevant", "+\t\t\t\t\tcase SUPERTYPE: mask = TagBits.AnnotationNullable; break; // super of @NonNull is irrelevant", "+\t\t\t\t}", "+\t\t\t\tinferenceVariable.prototype().nullHints |= this.right.tagBits & mask;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "79e674f14d6b4a4b08458ffbc55d60d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "ddf48a7e21056eecd0111cd750a59c8617c397eb", "commitAfterChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tpublic void addBound(TypeBound bound, LookupEnvironment environment)", "signatureAfterChange": "  \tpublic void addBound(TypeBound bound, LookupEnvironment environment)", "diff": ["-\t\tif (bound.equals(this.mostRecentBounds[0]) || bound.equals(this.mostRecentBounds[1]) || bound.equals(this.mostRecentBounds[2]) || bound.equals(this.mostRecentBounds[3])) {", "-\t\t\treturn;", "+\t\tfor (int recent = 0; recent < 4; recent++) {", "+\t\t\tif (bound.equals(this.mostRecentBounds[recent])) {", "+\t\t\t\tif (environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {", "+\t\t\t\t\tTypeBound existing = this.mostRecentBounds[recent];", "+\t\t\t\t\tlong boundNullBits = bound.right.tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\tlong existingNullBits = existing.right.tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\tif (boundNullBits != existingNullBits) {", "+\t\t\t\t\t\tif (existingNullBits == 0)", "+\t\t\t\t\t\t\texisting.right = bound.right;", "+\t\t\t\t\t\telse if (boundNullBits != 0) // combine bits from both sources, even if this creates a contradiction", "+\t\t\t\t\t\t\texisting.right = environment.createAnnotatedType(existing.right, environment.nullAnnotationsFromTagBits(boundNullBits));", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c01493b6a54f7e26410bdcf609db4686", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java", "commitBeforeChange": "26ecbd70f644b3e526f4a51dee0b94e84d57cade", "commitAfterChange": "63af609b0c4ca15a76568f63423f1cb23d7be92e", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic ParameterizedMethodBinding(final ParameterizedTypeBinding parameterizedDeclaringClass, MethodBinding originalMethod)", "signatureAfterChange": " \tpublic ParameterizedMethodBinding(final ParameterizedTypeBinding parameterizedDeclaringClass, MethodBinding originalMethod)", "diff": ["+", "+\t\t\t// after substitution transfer nullness information from type annotations:", "+\t\t\tif (parameterizedDeclaringClass.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {", "+\t\t\t\tlong returnNullBits = this.returnType.tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\tif (returnNullBits != 0L) {", "+\t\t\t\t\tthis.tagBits &= ~TagBits.AnnotationNullMASK;", "+\t\t\t\t\tthis.tagBits |= returnNullBits;", "+\t\t\t\t}", "+\t\t\t\tint parametersLen = this.parameters.length;", "+\t\t\t\tfor (int i=0; i<parametersLen; i++) {", "+\t\t\t\t\tlong paramTagBits = this.parameters[i].tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\tif (paramTagBits != 0) {", "+\t\t\t\t\t\tif (this.parameterNonNullness == null)", "+\t\t\t\t\t\t\tthis.parameterNonNullness = new Boolean[parametersLen];", "+\t\t\t\t\t\tthis.parameterNonNullness[i] = Boolean.valueOf(paramTagBits == TagBits.AnnotationNonNull);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}], "num": 69660}