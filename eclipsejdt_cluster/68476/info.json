{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "67d22a155345cca2b98c6610357e5b5b", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b7093a45ab0dc4019341c36a9df0223", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5a10f519c81ebdddb6bd4a37e304977f9bce5290", "commitAfterChange": "7b4e4fcfdd4d04f13dc930d8b751701d20daa4d2", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\tMethodBinding[] visible = null;", "-\t\t\t\t\t\t\t\t\t\t\tint matchingImportLevel = importBinding.onDemand ? 0 : 1;", "-\t\t\t\t\t\t\t\t\t\t\tif (matchingImportLevel == importLevel) {", "-\t\t\t\t\t\t\t\t\t\t\t\tscope = this;", "-\t\t\t\t\t\t\t\t\t\t\t\twhile (true) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (scope.kind) {", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase CLASS_SCOPE :", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(selector, argumentTypes, ((ClassScope) scope).referenceContext.binding, Ambiguous);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase COMPILATION_UNIT_SCOPE :", "-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, Ambiguous);", "-\t\t\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t\t\t\tscope = scope.parent;", "+\t\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || !foundMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (visible == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = new MethodBinding[] {foundMethod, compatibleMethod};", "+\t\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t\tint visibleLength = visible.length;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tMethodBinding[] temp = new MethodBinding[visibleLength + 1];", "+\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(visible, 0, temp, 0, visibleLength);", "+\t\t\t\t\t\t\t\t\t\t\t\t\ttemp[visibleLength] = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\t\t\t\tvisible = temp;", "-\t\t\t\t\t\t\t\t\t\t\tfoundMethod = compatibleMethod;", "-\t\t\t\t\t\t\t\t\t\t\timportLevel = matchingImportLevel;", "+\t\t\t\t\t\t\t\t\t\t\timportLevel = importBinding.onDemand ? 0 : 1;", "+\t\t\t\tif (visible != null)", "+\t\t\t\t\tfoundMethod = mostSpecificMethodBinding(visible, visible.length, argumentTypes, invocationSite);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ea0e853f982de8b228fed488fd616909", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "5b534766d4f50c0b706c85a960952c0a8d402690", "commitAfterChange": "9c01a288cfc10861d0cbe8d85e9282d8f2684406", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 75, "signatureBeforeChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "signatureAfterChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "diff": ["-\t\t\t\t\t\t// Count the lines until the exact start position of the code", "-\t\t\t\t\t\tthis.scanner.resetTo(end+1, nextStart-1);", "-\t\t\t\t\t\tint newLines = 0;", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "-\t\t\t\t\t\t\tloop: while (true) {", "-\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "-\t\t\t\t\t\t\t\t\t\tif (CharOperation.indexOf('\\n', this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition) < 0) {", "-\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tnewLines++;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "-\t\t\t\t\t\t\t\t\t\tnextStart = this.scanner.currentPosition + 1;", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\tdefault:", "-\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t// See whether there's a space before the code", "+\t\t\t\t\t\tboolean needLeadingSpace = false;", "+\t\t\t\t\t\tif (linesGap > 0) {", "+\t\t\t\t\t\t\tint lineStart = this.scanner.getLineStart(startLine);", "+\t\t\t\t\t\t\tif (nextStart > lineStart) { // if code starts at the line, then no leading space is needed", "+\t\t\t\t\t\t\t\tthis.scanner.resetTo(lineStart, nextStart-1);", "+\t\t\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\t\t\t// skip indentation", "+\t\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = false; // there may be no star after", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameMULTIPLY) {", "+\t\t\t\t\t\t\t\t\t\tnextStart = this.scanner.currentPosition;", "+\t\t\t\t\t\t\t\t\t\t// skip javadoc comment star", "+\t\t\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = true;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (token == TerminalTokens.TokenNameWHITESPACE) {", "+\t\t\t\t\t\t\t\t\t\tneedLeadingSpace = false;", "+\t\t\t\t\t\t\t\t\t\tnextStart++;", "+\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t\tcatch (InvalidInputException iie) {", "+\t\t\t\t\t\t\t\t\t// skip", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\tcatch (InvalidInputException iie) {", "-\t\t\t\t\t\t\t// skip", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Format gap lines before code", "+\t\t\t\t\t\tint newLines = linesGap;", "-\t\t    \t\t\tprintJavadocGapLines(end+1, nextStart-1, newLines, false/* clear first blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t\t\t\t\t\tprintJavadocGapLines(end+1, nextStart-1, newLines, false/* clear first blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t\t\t\t\t\tif (needLeadingSpace) {", "+\t\t\t\t\t\t\taddInsertEdit(nextStart, \" \"); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// Format the code", "+\t\t\t\t\t\t// Format the gap lines after the code"]}], "num": 68476}