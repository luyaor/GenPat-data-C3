{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8860c701a7693c289ecc0d36893253b2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0c280940b3a3591b3ec69e1bc26a74ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "931e434bb3e4b9f62577b10f8123cfc028893969", "commitAfterChange": "c0b519c3b149b13ea0f307f0d3414359b2cf0639", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": "  public TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\tpublic TypeBinding getOtherFieldBindings(BlockScope scope) {", "-\t\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "-\t\tint length = tokens.length;", "-\t\tFieldBinding field;", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tfield = (FieldBinding) this.binding;", "-\t\t\tif (!field.isStatic()) {", "-\t\t\t\t//must check for the static status....", "-\t\t\t\tif (indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "-\t\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "-\t\t\t\t\treturn null;", "-\t\t\t\t }", "-\t\t\t} else {", "+", "+public TypeBinding getOtherFieldBindings(BlockScope scope) {", "+\t// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)", "+\tint length = this.tokens.length;", "+\tFieldBinding field;", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tfield = (FieldBinding) this.binding;", "+\t\tif (!field.isStatic()) {", "+\t\t\t//must check for the static status....", "+\t\t\tif (this.indexOfFirstFieldBinding > 1  //accessing to a field using a type as \"receiver\" is allowed only with static field", "+\t\t\t\t\t || scope.methodScope().isStatic) { \t// the field is the first token of the qualified reference....", "+\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, field);", "+\t\t\t\treturn null;", "+\t\t\t }", "+\t\t} else {", "+\t\t\t// indirect static reference ?", "+\t\t\tif (this.indexOfFirstFieldBinding > 1 ", "+\t\t\t\t\t&& field.declaringClass != this.actualReceiverType", "+\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "+\t\t\t}", "+\t\t}", "+\t\t// only last field is actually a write access if any", "+\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) != 0 && this.indexOfFirstFieldBinding == length))", "+\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t} else {", "+\t\tfield = null;", "+\t}", "+\tTypeBinding type = ((VariableBinding) this.binding).type;", "+\tint index = this.indexOfFirstFieldBinding;", "+\tif (index == length) { //\trestrictiveFlag == FIELD", "+\t\tthis.constant = ((FieldBinding) this.binding).constant();", "+\t\t// perform capture conversion if read access", "+\t\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t\t: type;", "+\t}", "+\t// allocation of the fieldBindings array\tand its respective constants", "+\tint otherBindingsLength = length - index;", "+\tthis.otherCodegenBindings = this.otherBindings = new FieldBinding[otherBindingsLength];", "+\tthis.otherDepths = new int[otherBindingsLength];", "+\t", "+\t// fill the first constant (the one of the binding)", "+\tthis.constant = ((VariableBinding) this.binding).constant();", "+\t// save first depth, since will be updated by visibility checks of other bindings", "+\tint firstDepth = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t// iteration on each field\t", "+\twhile (index < length) {", "+\t\tchar[] token = this.tokens[index];", "+\t\tif (type == null)", "+\t\t\treturn null; // could not resolve type prior to this point", "+", "+\t\tthis.bits &= ~ASTNode.DepthMASK; // flush previous depth if any\t\t", "+\t\tFieldBinding previousField = field;", "+\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "+\t\tint place = index - this.indexOfFirstFieldBinding;", "+\t\tthis.otherBindings[place] = field;", "+\t\tthis.otherDepths[place] = (this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT;", "+\t\tif (field.isValidBinding()) {", "+\t\t\t// set generic cast of for previous field (if any)", "+\t\t\tif (previousField != null) {", "+\t\t\t\tTypeBinding fieldReceiverType = type;", "+\t\t\t\tTypeBinding receiverErasure = type.erasure();", "+\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "+\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t\t", "+\t\t\t\tFieldBinding originalBinding = previousField.original();", "+\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != TypeIds.T_JavaLangObject) {", "+\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "+\t\t\t    }", "+\t\t    }", "+\t\t\t// only last field is actually a write access if any", "+\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & ASTNode.IsStrictlyAssigned) !=0 && index+1 == length)) {", "+\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\t}", "+\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "+\t\t\tif (this.constant != Constant.NotAConstant) {", "+\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "+\t\t\t}", "+", "+\t\t\tif (field.isStatic()) {", "+\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "+\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\tif (indexOfFirstFieldBinding > 1 ", "-\t\t\t\t\t\t&& field.declaringClass != actualReceiverType", "-\t\t\t\t\t\t&& field.declaringClass.canBeSeenBy(scope)) {", "+\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t// only last field is actually a write access if any", "-\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) != 0 && indexOfFirstFieldBinding == length))", "-\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "+\t\t\ttype = field.type;", "+\t\t\tindex++;", "-\t\t\tfield = null;", "-\t\t}", "-\t\tTypeBinding type = ((VariableBinding) binding).type;", "-\t\tint index = indexOfFirstFieldBinding;", "-\t\tif (index == length) { //\trestrictiveFlag == FIELD", "-\t\t\tthis.constant = ((FieldBinding) binding).constant();", "-\t\t\t// perform capture conversion if read access", "-\t\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t\t: type;", "-\t\t}", "-\t\t// allocation of the fieldBindings array\tand its respective constants", "-\t\tint otherBindingsLength = length - index;", "-\t\totherCodegenBindings = otherBindings = new FieldBinding[otherBindingsLength];", "-\t\totherDepths = new int[otherBindingsLength];", "-\t\t", "-\t\t// fill the first constant (the one of the binding)", "-\t\tthis.constant = ((VariableBinding) binding).constant();", "-\t\t// save first depth, since will be updated by visibility checks of other bindings", "-\t\tint firstDepth = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t// iteration on each field\t", "-\t\twhile (index < length) {", "-\t\t\tchar[] token = tokens[index];", "-\t\t\tif (type == null)", "-\t\t\t\treturn null; // could not resolve type prior to this point", "-", "-\t\t\tbits &= ~DepthMASK; // flush previous depth if any\t\t", "-\t\t\tFieldBinding previousField = field;", "-\t\t\tfield = scope.getField(type.capture(scope, (int)this.sourcePositions[index]), token, this);", "-\t\t\tint place = index - indexOfFirstFieldBinding;", "-\t\t\totherBindings[place] = field;", "-\t\t\totherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;", "-\t\t\tif (field.isValidBinding()) {", "-\t\t\t\t// set generic cast of for previous field (if any)", "-\t\t\t\tif (previousField != null) {", "-\t\t\t\t\tTypeBinding fieldReceiverType = type;", "-\t\t\t\t\tTypeBinding receiverErasure = type.erasure();", "-\t\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "-\t\t\t\t\t\tif (receiverErasure.findSuperTypeWithSameErasure(field.declaringClass) == null) {", "-\t\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tFieldBinding originalBinding = previousField.original();", "-\t\t\t\t    if ((originalBinding.type.tagBits &  TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != T_JavaLangObject) {", "-\t\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "-\t\t\t\t    }", "-\t\t\t    }", "-\t\t\t\t// only last field is actually a write access if any", "-\t\t\t\tif (isFieldUseDeprecated(field, scope, (this.bits & IsStrictlyAssigned) !=0 && index+1 == length)) {", "-\t\t\t\t\tscope.problemReporter().deprecatedField(field, this);", "-\t\t\t\t}", "-\t\t\t\t// constant propagation can only be performed as long as the previous one is a constant too.", "-\t\t\t\tif (this.constant != Constant.NotAConstant) {", "-\t\t\t\t\tthis.constant = field.constant();\t\t\t\t\t", "-\t\t\t\t}", "-", "-\t\t\t\tif (field.isStatic()) {", "-\t\t\t\t\t// static field accessed through receiver? legal but unoptimal (optional warning)", "-\t\t\t\t\tscope.problemReporter().nonStaticAccessToStaticField(this, field);", "-\t\t\t\t\t// indirect static reference ?", "-\t\t\t\t\tif (field.declaringClass != type) {", "-\t\t\t\t\t\tscope.problemReporter().indirectAccessToStaticField(this, field);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\ttype = field.type;", "-\t\t\t\tindex++;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant; //don't fill other constants slots...", "-\t\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "-\t\t\t\tsetDepth(firstDepth);", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t}", "-\t\tsetDepth(firstDepth);", "-\t\ttype = (otherBindings[otherBindingsLength - 1]).type;", "-\t\t// perform capture conversion if read access", "-\t\treturn (type != null && (this.bits & IsStrictlyAssigned) == 0)", "-\t\t\t\t? type.capture(scope, this.sourceEnd)", "-\t\t\t\t: type;\t\t", "-\t}", "+\t\t\tthis.constant = Constant.NotAConstant; //don't fill other constants slots...", "+\t\t\tscope.problemReporter().invalidField(this, field, index, type);", "+\t\t\tsetDepth(firstDepth);", "+\t\t\treturn null;", "+\tsetDepth(firstDepth);", "+\ttype = (this.otherBindings[otherBindingsLength - 1]).type;", "+\t// perform capture conversion if read access", "+\treturn (type != null && (this.bits & ASTNode.IsStrictlyAssigned) == 0)", "+\t\t\t? type.capture(scope, this.sourceEnd)", "+\t\t\t: type;\t\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f843e616dd61ac6e3776f13133160161", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "302df05b099c1ea06faca0b00f806513c7db6904", "commitAfterChange": "c661afbb38268ca6f18a772df813f6c69bb9e17c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": " public TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\tint length = tokens.length;", "-\tif ((bits & FIELD) != 0) {", "-\t\tif (!((FieldBinding) binding).isStatic()) { //must check for the static status....", "-\t\t\tif (indexOfFirstFieldBinding == 1) {", "+\tint length = this.tokens.length;", "+\tif ((this.bits & FIELD) != 0) {", "+\t\tif (!((FieldBinding) this.binding).isStatic()) { //must check for the static status....", "+\t\t\tif (this.indexOfFirstFieldBinding == 1) {", "-\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);", "+\t\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) this.binding);", "-\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);", "+\t\t\t\tscope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) this.binding);", "-\t\tif (isFieldUseDeprecated((FieldBinding) binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && indexOfFirstFieldBinding == length)) {", "-\t\t\tscope.problemReporter().deprecatedField((FieldBinding) binding, this);", "+\t\tif (isFieldUseDeprecated((FieldBinding) this.binding, scope, (this.bits & IsStrictlyAssignedMASK) !=0 && this.indexOfFirstFieldBinding == length)) {", "+\t\t\tscope.problemReporter().deprecatedField((FieldBinding) this.binding, this);", "-\tTypeBinding type = ((VariableBinding) binding).type;", "-\tint index = indexOfFirstFieldBinding;", "+\tTypeBinding type = ((VariableBinding) this.binding).type;", "+\tint index = this.indexOfFirstFieldBinding;", "-\t\tconstant = FieldReference.getConstantFor((FieldBinding) binding, this, false, scope);", "+\t\tthis.constant = FieldReference.getConstantFor((FieldBinding) this.binding, this, false, scope);", "-\tconstant =", "-\t\t((bits & FIELD) != 0)", "-\t\t\t? FieldReference.getConstantFor((FieldBinding) binding, this, false, scope)", "-\t\t\t: ((VariableBinding) binding).constant;", "+\tthis.constant =", "+\t\t((this.bits & FIELD) != 0)", "+\t\t\t? FieldReference.getConstantFor((FieldBinding) this.binding, this, false, scope)", "+\t\t\t: ((VariableBinding) this.binding).constant;", "-\t\tchar[] token = tokens[index];", "+\t\tchar[] token = this.tokens[index];", "-\t\tint place = index - indexOfFirstFieldBinding;", "-\t\totherBindings[place] = field;", "+\t\tint place = index - this.indexOfFirstFieldBinding;", "+\t\tthis.otherBindings[place] = field;", "-\t\t\tif (delegateThis == null) {", "+\t\t\tif (this.delegateThis == null) {", "-\t\t\t\t\tdelegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "-\t\t\t\t\tif (delegateThis == null){  // if not found then internal error, field should have been found", "+\t\t\t\t\tthis.delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);", "+\t\t\t\t\tif (this.delegateThis == null){  // if not found then internal error, field should have been found", "-\t\t\t\t\tconstant = NotAConstant; //don't fill other constants slots...", "+\t\t\t\t\tthis.constant = NotAConstant; //don't fill other constants slots...", "-\t\t\tfield = localScope.getFieldForCodeSnippet(delegateThis.type, token, this);", "-\t\t\totherBindings[place] = field;", "+\t\t\tfield = localScope.getFieldForCodeSnippet(this.delegateThis.type, token, this);", "+\t\t\tthis.otherBindings[place] = field;", "-\t\t\tif (constant != NotAConstant){", "-\t\t\t\tconstant = someConstant;", "+\t\t\tif (this.constant != NotAConstant){", "+\t\t\t\tthis.constant = someConstant;", "-\t\t\tconstant = NotAConstant; //don't fill other constants slots...", "+\t\t\tthis.constant = NotAConstant; //don't fill other constants slots...", "-\treturn (otherBindings[otherBindingsLength - 1]).type;", "+\treturn (this.otherBindings[otherBindingsLength - 1]).type;"]}], "num": 17718}