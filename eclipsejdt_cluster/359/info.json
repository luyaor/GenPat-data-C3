{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b965e648c05db195dacada1cecd2057f", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3592058f60f72185226a894ac100a7c0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound)", "signatureAfterChange": "  public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound)", "diff": ["-\t}", "-\tpublic FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {", "-\t", "-\t\tboolean isReachable = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "-\t\t// compound assignment extra work", "-\t\tif (isCompound) { // check the variable part is initialized if blank final", "-\t\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\t\tcase Binding.FIELD : // reading a field", "-\t\t\t\t\tFieldBinding fieldBinding;", "-\t\t\t\t\tif ((fieldBinding = (FieldBinding) binding).isBlankFinal() ", "-\t\t\t\t\t\t\t&& currentScope.needBlankFinalFieldInitializationCheck(fieldBinding)) {", "-\t\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(fieldBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase Binding.LOCAL : // reading a local variable", "-\t\t\t\t\t// check if assigning a final blank field", "-\t\t\t\t\tLocalVariableBinding localBinding;", "-\t\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) binding)) {", "-\t\t\t\t\t\tcurrentScope.problemReporter().uninitializedLocalVariable(localBinding, this);", "-\t\t\t\t\t\t// we could improve error msg here telling \"cannot use compound assignment on final local variable\"", "-\t\t\t\t\t}", "-\t\t\t\t\tif (isReachable) {", "-\t\t\t\t\t\tlocalBinding.useFlag = LocalVariableBinding.USED;", "-\t\t\t\t\t} else if (localBinding.useFlag == LocalVariableBinding.UNUSED) {", "-\t\t\t\t\t\tlocalBinding.useFlag = LocalVariableBinding.FAKE_USED;", "-\t\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tif (assignment.expression != null) {", "-\t\t\tflowInfo = assignment.expression.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "-\t\t}", "-\t\tswitch (bits & RestrictiveFlagMASK) {", "-\t\t\tcase Binding.FIELD : // assigning to a field", "-\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, false /*write-access*/);", "-\t", "-\t\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\t\tReferenceBinding declaringClass = fieldBinding.declaringClass;", "-\t\t\t\t// check if accessing enum static field in initializer", "-\t\t\t\tif (declaringClass.isEnum()) {", "-\t\t\t\t\tMethodScope methodScope = currentScope.methodScope();", "-\t\t\t\t\tSourceTypeBinding sourceType = currentScope.enclosingSourceType();", "-\t\t\t\t\tif (fieldBinding.isStatic()", "-\t\t\t\t\t\t\t&& this.constant == Constant.NotAConstant", "-\t\t\t\t\t\t\t&& !methodScope.isStatic", "-\t\t\t\t\t\t\t&& (sourceType == declaringClass || sourceType.superclass == declaringClass) // enum constant body", "-\t\t\t\t\t\t\t&& methodScope.isInsideInitializerOrConstructor()) {", "-\t\t\t\t\t\tcurrentScope.problemReporter().enumStaticFieldUsedDuringInitialization(fieldBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t// check if assigning a final field", "-\t\t\t\tif (fieldBinding.isFinal()) {", "-\t\t\t\t\t// inside a context where allowed", "-\t\t\t\t\tif (!isCompound && fieldBinding.isBlankFinal() && currentScope.allowBlankFinalFieldAssignment(fieldBinding)) {", "-\t\t\t\t\t\tif (flowInfo.isPotentiallyAssigned(fieldBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfBlankFinalField(fieldBinding, this);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tflowContext.recordSettingFinal(fieldBinding, this, flowInfo);\t\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(fieldBinding);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase Binding.LOCAL : // assigning to a local variable ", "-\t\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) binding;", "-\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding)){// for local variable debug attributes", "-\t\t\t\t\tbits |= FirstAssignmentToLocal;", "-\t\t\t\t} else {", "-\t\t\t\t\tbits &= ~FirstAssignmentToLocal;", "-\t\t\t\t}", "-\t\t\t\tif (localBinding.isFinal()) {", "-\t\t\t\t\tif ((bits & DepthMASK) == 0) {", "-\t\t\t\t\t\t// tolerate assignment to final local in unreachable code (45674)", "-\t\t\t\t\t\tif ((isReachable && isCompound) || !localBinding.isBlankFinal()){", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalLocal(localBinding, this);", "-\t\t\t\t\t\t} else if (flowInfo.isPotentiallyAssigned(localBinding)) {", "-\t\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfFinalLocal(localBinding, this);", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tflowContext.recordSettingFinal(localBinding, this, flowInfo);\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalOuterLocal(localBinding, this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\telse /* avoid double diagnostic */ if ((localBinding.tagBits & TagBits.IsArgument) != 0) {", "-\t\t\t\t\tcurrentScope.problemReporter().parameterAssignment(localBinding, this);", "-\t\t\t\t}", "-\t\t\t\tflowInfo.markAsDefinitelyAssigned(localBinding);", "-\t\t}", "-\t\tmanageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);", "-\t\treturn flowInfo;", "-\t}", "+", "+public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {", "+\tboolean isReachable = (flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0;", "+\t// compound assignment extra work", "+\tif (isCompound) { // check the variable part is initialized if blank final", "+\t\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\t\t\tFieldBinding fieldBinding;", "+\t\t\t\tif ((fieldBinding = (FieldBinding) this.binding).isBlankFinal() ", "+\t\t\t\t\t\t&& currentScope.needBlankFinalFieldInitializationCheck(fieldBinding)) {", "+\t\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);", "+\t\t\t\t// check if assigning a final blank field", "+\t\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) this.binding)) {", "+\t\t\t\t\t// we could improve error msg here telling \"cannot use compound assignment on final local variable\"", "+\t\t\t\tif (isReachable) {", "+\tif (assignment.expression != null) {", "+\t\tflowInfo = assignment.expression.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();", "+\tswitch (this.bits & ASTNode.RestrictiveFlagMASK) {", "+\t\tcase Binding.FIELD : // assigning to a field", "+\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo, false /*write-access*/);", "+\t\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\t\tReferenceBinding declaringClass = fieldBinding.declaringClass;", "+\t\t\t// check if accessing enum static field in initializer", "+\t\t\tif (declaringClass.isEnum()) {", "+\t\t\t\tMethodScope methodScope = currentScope.methodScope();", "+\t\t\t\tSourceTypeBinding sourceType = currentScope.enclosingSourceType();", "+\t\t\t\tif (fieldBinding.isStatic()", "+\t\t\t\t\t\t&& this.constant == Constant.NotAConstant", "+\t\t\t\t\t\t&& !methodScope.isStatic", "+\t\t\t\t\t\t&& (sourceType == declaringClass || sourceType.superclass == declaringClass) // enum constant body", "+\t\t\t\t\t\t&& methodScope.isInsideInitializerOrConstructor()) {", "+\t\t\t\t\tcurrentScope.problemReporter().enumStaticFieldUsedDuringInitialization(fieldBinding, this);", "+\t\t\t\t}", "+\t\t\t}\t\t\t\t\t", "+\t\t\t// check if assigning a final field", "+\t\t\tif (fieldBinding.isFinal()) {", "+\t\t\t\t// inside a context where allowed", "+\t\t\t\tif (!isCompound && fieldBinding.isBlankFinal() && currentScope.allowBlankFinalFieldAssignment(fieldBinding)) {", "+\t\t\t\t\tif (flowInfo.isPotentiallyAssigned(fieldBinding)) {", "+\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfBlankFinalField(fieldBinding, this);", "+\t\t\t\t\t\tflowContext.recordSettingFinal(fieldBinding, this, flowInfo);\t\t\t\t\t\t", "+\t\t\t\t\tflowInfo.markAsDefinitelyAssigned(fieldBinding);", "+\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalField(fieldBinding, this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbreak;", "+\t\tcase Binding.LOCAL : // assigning to a local variable ", "+\t\t\tLocalVariableBinding localBinding = (LocalVariableBinding) this.binding;", "+\t\t\tif (!flowInfo.isDefinitelyAssigned(localBinding)){// for local variable debug attributes", "+\t\t\t\tthis.bits |= ASTNode.FirstAssignmentToLocal;", "+\t\t\t} else {", "+\t\t\t\tthis.bits &= ~ASTNode.FirstAssignmentToLocal;", "+\t\t\t}", "+\t\t\tif (localBinding.isFinal()) {", "+\t\t\t\tif ((this.bits & ASTNode.DepthMASK) == 0) {", "+\t\t\t\t\t// tolerate assignment to final local in unreachable code (45674)", "+\t\t\t\t\tif ((isReachable && isCompound) || !localBinding.isBlankFinal()){", "+\t\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalLocal(localBinding, this);", "+\t\t\t\t\t} else if (flowInfo.isPotentiallyAssigned(localBinding)) {", "+\t\t\t\t\t\tcurrentScope.problemReporter().duplicateInitializationOfFinalLocal(localBinding, this);", "+\t\t\t\t\t\tflowContext.recordSettingFinal(localBinding, this, flowInfo);\t\t\t\t\t\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\tcurrentScope.problemReporter().cannotAssignToFinalOuterLocal(localBinding, this);", "+\t\t\t}", "+\t\t\telse /* avoid double diagnostic */ if ((localBinding.tagBits & TagBits.IsArgument) != 0) {", "+\t\t\t\tcurrentScope.problemReporter().parameterAssignment(localBinding, this);", "+\t\t\t}", "+\t\t\tflowInfo.markAsDefinitelyAssigned(localBinding);", "+\t}", "+\tmanageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);", "+\treturn flowInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "87449223cc40ea8b6c01b45c1628eee9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "signatureAfterChange": "  public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess)", "diff": ["-\t}", "-\tpublic void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "-\t", "-\t\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "-\t", "-\t\t//If inlinable field, forget the access emulation, the code gen will directly target it", "-\t\tif (constant != Constant.NotAConstant)", "-\t\t\treturn;", "-\t", "-\t\tif ((bits & Binding.FIELD) != 0) {", "-\t\t\tFieldBinding fieldBinding = (FieldBinding) binding;", "-\t\t\tFieldBinding codegenField = fieldBinding.original();", "-\t\t\tthis.codegenBinding = codegenField;", "-\t\t\tif (((bits & DepthMASK) != 0)", "-\t\t\t\t&& (codegenField.isPrivate() // private access", "-\t\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "-\t\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "-\t\t\t\tif (syntheticAccessors == null)", "-\t\t\t\t\tsyntheticAccessors = new MethodBinding[2];", "-\t\t\t\tsyntheticAccessors[isReadAccess ? READ : WRITE] = ", "-\t\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "-\t\t\t\t\t\tenclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "-\t\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "-\t\t\t\treturn;", "-\t\t\t// if the binding declaring class is not visible, need special action", "-\t\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "-\t\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "-\t\t\t// and not from Object or implicit static field access.\t", "-\t\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "-\t\t\t\t\t&& !this.actualReceiverType.isArrayType()", "-\t\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "-\t\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "-\t\t\t\tCompilerOptions options = currentScope.compilerOptions();", "-\t\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "-\t\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "-\t\t\t\t\t\t&& fieldBinding.declaringClass.id != T_JavaLangObject) // no change for Object fields", "+", "+public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {", "+\tif ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)\treturn;", "+", "+\t//If inlinable field, forget the access emulation, the code gen will directly target it", "+\tif (this.constant != Constant.NotAConstant)", "+\t\treturn;", "+", "+\tif ((this.bits & Binding.FIELD) != 0) {", "+\t\tFieldBinding fieldBinding = (FieldBinding) this.binding;", "+\t\tFieldBinding codegenField = fieldBinding.original();", "+\t\tthis.codegenBinding = codegenField;", "+\t\tif (((this.bits & ASTNode.DepthMASK) != 0)", "+\t\t\t&& (codegenField.isPrivate() // private access", "+\t\t\t\t|| (codegenField.isProtected() // implicit protected access", "+\t\t\t\t\t\t&& codegenField.declaringClass.getPackage() != currentScope.enclosingSourceType().getPackage()))) {", "+\t\t\tif (this.syntheticAccessors == null)", "+\t\t\t\tthis.syntheticAccessors = new MethodBinding[2];", "+\t\t\tthis.syntheticAccessors[isReadAccess ? SingleNameReference.READ : SingleNameReference.WRITE] = ", "+\t\t\t    ((SourceTypeBinding)currentScope.enclosingSourceType().", "+\t\t\t\t\tenclosingTypeAt((this.bits & ASTNode.DepthMASK) >> ASTNode.DepthSHIFT)).addSyntheticMethod(codegenField, isReadAccess);", "+\t\t\tcurrentScope.problemReporter().needToEmulateFieldAccess(codegenField, this, isReadAccess);", "+\t\t\treturn;", "+\t\t}", "+\t\t// if the binding declaring class is not visible, need special action", "+\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding", "+\t\t// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type", "+\t\t// and not from Object or implicit static field access.\t", "+\t\tif (fieldBinding.declaringClass != this.actualReceiverType", "+\t\t\t\t&& !this.actualReceiverType.isArrayType()", "+\t\t\t\t&& fieldBinding.declaringClass != null // array.length", "+\t\t\t\t&& fieldBinding.constant() == Constant.NotAConstant) {", "+\t\t\tCompilerOptions options = currentScope.compilerOptions();", "+\t\t\tif ((options.targetJDK >= ClassFileConstants.JDK1_2", "+\t\t\t\t\t&& (options.complianceLevel >= ClassFileConstants.JDK1_4 || !fieldBinding.isStatic())", "+\t\t\t\t\t&& fieldBinding.declaringClass.id != TypeIds.T_JavaLangObject) // no change for Object fields", "-\t\t\t\t}", "-\t\t\t}\t\t\t\t\t", "-\t\t}", "+\t\t\t}", "+\t\t}\t\t\t\t\t", "+}"]}], "num": 359}