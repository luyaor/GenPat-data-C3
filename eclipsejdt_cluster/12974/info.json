{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cd12018944df893c662b2b0cb64a028e", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b43c69d746e745dfc56d1b960230455c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "b0ee678b65f48d1cfab35972dd53d6bd85389446", "commitAfterChange": "5a11933bf440021c4c92ce580c9967dadb549d6e", "methodNumberBeforeChange": 117, "methodNumberAfterChange": 117, "signatureBeforeChange": "  \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments)", "signatureAfterChange": " \tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site)", "diff": ["+\t// Version that just answers based on inference kind (at 1.8+) when available.", "+\tpublic int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, InvocationSite site) {", "+\t\tif (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && method instanceof ParameterizedGenericMethodBinding) {", "+\t\t\tint inferenceKind = InferenceContext18.CHECK_UNKNOWN;", "+\t\t\tInferenceContext18 context = null;", "+\t\t\tif (site instanceof Invocation) {", "+\t\t\t\tInvocation invocation = (Invocation) site;", "+\t\t\t\tcontext = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);", "+\t\t\t\tif (context != null)", "+\t\t\t\t\tinferenceKind = context.inferenceKind;", "+\t\t\t} else if (site instanceof ReferenceExpression) {", "+\t\t\t\tinferenceKind = ((ReferenceExpression) site).inferenceKind;", "+\t\t\t}", "+\t\t\t/* 1.8+ Post inference compatibility check policy: For non-functional-type arguments, trust inference. For functional type arguments apply compatibility checks as inference", "+\t\t\t   engine may not have checked arguments that are not pertinent to applicability. One complication to deal with is when the generic method's parameter is its own type variable ", "+\t\t\t   and only applicability was inferred and applicability inference instantiated it with jlO due to lack of upper bounds in the bound set.", "+\t\t\t*/", "+\t\t\tif (site instanceof Invocation && context != null) { // this block can be readily seen to be not relevant for reference expressions", "+\t\t\t\tMethodBinding shallowOriginal = method.shallowOriginal();", "+\t\t\t\tfor (int i = 0, length = arguments.length; i < length; i++) {", "+\t\t\t\t\tTypeBinding argument = arguments[i];", "+\t\t\t\t\tif (!argument.isFunctionalType())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding parameter = InferenceContext18.getParameter(method.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (argument.isCompatibleWith(parameter, this))", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tTypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());", "+\t\t\t\t\tif (shallowParameter.isPertinentToApplicability(argument, shallowOriginal))", "+\t\t\t\t\t\treturn NOT_COMPATIBLE;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tswitch (inferenceKind) {", "+\t\t\t\tcase InferenceContext18.CHECK_STRICT:", "+\t\t\t\t\treturn COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_LOOSE:", "+\t\t\t\t\treturn AUTOBOX_COMPATIBLE;", "+\t\t\t\tcase InferenceContext18.CHECK_VARARG:", "+\t\t\t\t\treturn VARARGS_COMPATIBLE;", "+\t\t\t\tdefault:", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t}", "+\t\treturn parameterCompatibilityLevel(method, arguments, false);", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d62c6ddb43afe947dcff024d6f47946a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java", "commitBeforeChange": "f682a4f20c4b7c328b7143bcd283abe7fc78f127", "commitAfterChange": "51edd6de0dc9df46bdb409b22473cd853bc26d79", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "\r \r private boolean isWorthBuilding() throws CoreException", "signatureAfterChange": "\r \r private boolean isWorthBuilding() throws CoreException", "diff": ["-//\tboolean abortBuilds = JavaCore.ABORT.equals(JavaCore.getOptions().get(OPTION_InvalidClasspathSwitch));\r", "-//\tif (abortBuilds) {\r", "-//\t\tIMarker[] markers =\r", "-//\t\t\tcurrentProject.findMarkers(IJavaModelMarker.BUILDPATH_PROBLEM_MARKER, false, IResource.DEPTH_ONE);\r", "-//\t\tif (markers.length > 0) {\r", "-//\t\t\tif (DEBUG)\r", "-//\t\t\t\tSystem.out.println(\"Aborted build because project is involved in a cycle or has classpath problems\"); //$NON-NLS-1$\r", "-//\r", "-//\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "-//\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "-//\r", "-//\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "-//\t\t\treturn false;\r", "-//\t\t}\r", "-//\t}\r", "-//\r", "-//\t// make sure all prereq projects have valid build states\r", "-//\tIProject[] requiredProjects = getRequiredProjects();\r", "-//\tnext : for (int i = 0, length = requiredProjects.length; i < length; i++) {\r", "-//\t\tIProject p = requiredProjects[i];\r", "-//\t\tif (getLastState(p) == null)  {\r", "-//\t\t\tif (!abortBuilds && !p.isOpen()) continue next; // skip closed projects if we're not aborting builds because of classpath problems\r", "-//\t\t\tif (DEBUG)\r", "-//\t\t\t\tSystem.out.println(\"Aborted build because prereq project \" + p.getName() //$NON-NLS-1$\r", "-//\t\t\t\t\t+ \" was not built\"); //$NON-NLS-1$\r", "-//\r", "-//\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "-//\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "-//\r", "-//\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "-//\t\t\tIMarker marker = currentProject.createMarker(ProblemMarkerTag);\r", "-//\t\t\tmarker.setAttribute(IMarker.MESSAGE, Util.bind(\"build.prereqProjectWasNotBuilt\", p.getName())); //$NON-NLS-1$\r", "-//\t\t\tmarker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);\r", "-//\t\t\treturn false;\r", "-//\t\t}\r", "-//\t}\r", "+\tboolean abortBuilds = JavaCore.ABORT.equals(JavaCore.getOptions().get(OPTION_InvalidClasspathSwitch));\r", "+\tabortBuilds = true;\r", "+\tif (abortBuilds) {\r", "+\t\tIMarker[] markers =\r", "+\t\t\tcurrentProject.findMarkers(IJavaModelMarker.BUILDPATH_PROBLEM_MARKER, false, IResource.DEPTH_ONE);\r", "+\t\tif (markers.length > 0) {\r", "+\t\t\tif (DEBUG)\r", "+\t\t\t\tSystem.out.println(\"Aborted build because project is involved in a cycle or has classpath problems\"); //$NON-NLS-1$\r", "+\r", "+\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "+\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "+\r", "+\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "+\t\t\treturn false;\r", "+\t\t}\r", "+\t}\r", "+\r", "+\t// make sure all prereq projects have valid build states\r", "+\tIProject[] requiredProjects = getRequiredProjects();\r", "+\tnext : for (int i = 0, length = requiredProjects.length; i < length; i++) {\r", "+\t\tIProject p = requiredProjects[i];\r", "+\t\tif (getLastState(p) == null)  {\r", "+\t\t\tif (!abortBuilds && !p.isOpen()) continue next; // skip closed projects if we're not aborting builds because of classpath problems\r", "+\t\t\tif (DEBUG)\r", "+\t\t\t\tSystem.out.println(\"Aborted build because prereq project \" + p.getName() //$NON-NLS-1$\r", "+\t\t\t\t\t+ \" was not built\"); //$NON-NLS-1$\r", "+\r", "+\t\t\t// remove all existing class files... causes all dependent projects to do the same\r", "+\t\t\tnew BatchImageBuilder(this).scrubOutputFolder();\r", "+\r", "+\t\t\tremoveProblemsFor(currentProject); // make this the only problem for this project\r", "+\t\t\tIMarker marker = currentProject.createMarker(ProblemMarkerTag);\r", "+\t\t\tmarker.setAttribute(IMarker.MESSAGE, Util.bind(\"build.prereqProjectWasNotBuilt\", p.getName())); //$NON-NLS-1$\r", "+\t\t\tmarker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);\r", "+\t\t\treturn false;\r", "+\t\t}\r", "+\t}\r"]}], "num": 12974}