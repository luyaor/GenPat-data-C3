{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d37ef60067e2f9a2e4a6388c01554cc9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "273c9d845a573c65cb0a361e0fc79892", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "71fc05771cd5c7e9f570121d2a71e73243d51c9b", "commitAfterChange": "2afe0ff8ea6baebe3984eac1cae395cec750c15a", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t\t\tTypeBinding type = resourceBinding.type;", "-\t\t\tif (type != null && type.isValidBinding()) {", "-\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "-\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "-\t\t\t\tif(closeMethod == null) {", "-\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=380112", "-\t\t\t\t\t// closeMethod could be null if the binding is from an interface", "-\t\t\t\t\t// extending from multiple interfaces.\t\t\t\t\t", "-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "-\t\t\t\t\t\tpublic boolean isSuperAccess() {return false;}", "-\t\t\t\t\t\tpublic boolean isTypeAccess() {return false;}", "-\t\t\t\t\t\tpublic void setActualReceiverType(ReferenceBinding receiverType) {/* empty */}", "-\t\t\t\t\t\tpublic void setDepth(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic void setFieldIndex(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic int sourceEnd() {return resource.sourceEnd(); }", "-\t\t\t\t\t\tpublic int sourceStart() {return resource.sourceStart(); }", "-\t\t\t\t\t\tpublic TypeBinding expectedType() { return null; }", "-\t\t\t\t\t};", "-\t\t\t\t\tcloseMethod = this.scope.compilationUnitScope().findMethod(binding, ConstantPool.Close, new TypeBinding[0], site, false);", "-\t\t\t\t}", "-\t\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "-\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "-\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\t\t}", "+\t\t\tMethodBinding closeMethod = findCloseMethod(resource, resourceBinding);", "+\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\tif (resourcesLength > 0) { ", "+\t\tif (resourcesLength > 0) {", "-\t\t\t\tFlowInfo catchInfo;", "-\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn).", "-\t\t\t\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "-\t\t\t\t} else {", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "-\t\t\t\t}", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g.", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "+\t\t\t\tFlowInfo catchInfo = prepareCatchInfo(flowInfo, handlingContext, tryInfo, i);", "-\t\t\t} ", "-\t\t\tTypeBinding type = resourceBinding.type;", "-\t\t\tif (type != null && type.isValidBinding()) {", "-\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "-\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "-\t\t\t\tif(closeMethod == null) {", "-\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=380112", "-\t\t\t\t\t// closeMethod could be null if the binding is from an interface", "-\t\t\t\t\t// extending from multiple interfaces.", "-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "-\t\t\t\t\t\tpublic boolean isSuperAccess() {return false;}", "-\t\t\t\t\t\tpublic boolean isTypeAccess() {return false;}", "-\t\t\t\t\t\tpublic void setActualReceiverType(ReferenceBinding receiverType) {/* empty */}", "-\t\t\t\t\t\tpublic void setDepth(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic void setFieldIndex(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic int sourceEnd() {return resource.sourceEnd(); }", "-\t\t\t\t\t\tpublic int sourceStart() {return resource.sourceStart(); }", "-\t\t\t\t\t\tpublic TypeBinding expectedType() { return null; }", "-\t\t\t\t\t};", "-\t\t\t\t\tcloseMethod = this.scope.compilationUnitScope().findMethod(binding, ConstantPool.Close, new TypeBinding[0], site, false);", "-\t\t\t\t}", "-\t\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "-\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "-\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tMethodBinding closeMethod = findCloseMethod(resource, resourceBinding);", "+\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\tFlowInfo catchInfo;", "-\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn).", "-\t\t\t\t\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "-\t\t\t\t}else {", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "-\t\t\t\t}", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g.", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "+\t\t\t\tFlowInfo catchInfo = prepareCatchInfo(flowInfo, handlingContext, tryInfo, i);", "-\t\tif (flowContext.initsOnFinally != null) {", "-\t\t\tflowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);", "-\t\t}", "+\t\tflowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b1feb8b89c7235ef14df3d0c514c5d92", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "fc050f32403d0f4e404aa7bf852058bde7010c9c", "commitAfterChange": "9aa23d789697e75fd166c7fcd35afb3e194c7006", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["-\t\t\tTypeBinding type = resourceBinding.type;", "-\t\t\tif (type != null && type.isValidBinding()) {", "-\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "-\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "-\t\t\t\tif(closeMethod == null) {", "-\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=380112", "-\t\t\t\t\t// closeMethod could be null if the binding is from an interface", "-\t\t\t\t\t// extending from multiple interfaces.\t\t\t\t\t", "-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "-\t\t\t\t\t\tpublic boolean isSuperAccess() {return false;}", "-\t\t\t\t\t\tpublic boolean isTypeAccess() {return false;}", "-\t\t\t\t\t\tpublic void setActualReceiverType(ReferenceBinding receiverType) {/* empty */}", "-\t\t\t\t\t\tpublic void setDepth(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic void setFieldIndex(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic int sourceEnd() {return resource.sourceEnd(); }", "-\t\t\t\t\t\tpublic int sourceStart() {return resource.sourceStart(); }", "-\t\t\t\t\t\tpublic TypeBinding expectedType() { return null; }", "-\t\t\t\t\t\tpublic boolean receiverIsImplicitThis() { return false;}", "-\t\t\t\t\t};", "-\t\t\t\t\tcloseMethod = this.scope.compilationUnitScope().findMethod(binding, ConstantPool.Close, new TypeBinding[0], site, false);", "-\t\t\t\t}", "-\t\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "-\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "-\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\t\t}", "+\t\t\tMethodBinding closeMethod = findCloseMethod(resource, resourceBinding);", "+\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\tif (resourcesLength > 0) { ", "+\t\tif (resourcesLength > 0) {", "-\t\t\t\tFlowInfo catchInfo;", "-\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn).", "-\t\t\t\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "-\t\t\t\t} else {", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "-\t\t\t\t}", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g.", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "+\t\t\t\tFlowInfo catchInfo = prepareCatchInfo(flowInfo, handlingContext, tryInfo, i);", "-\t\t\t} ", "-\t\t\tTypeBinding type = resourceBinding.type;", "-\t\t\tif (type != null && type.isValidBinding()) {", "-\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "-\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "-\t\t\t\tif(closeMethod == null) {", "-\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=380112", "-\t\t\t\t\t// closeMethod could be null if the binding is from an interface", "-\t\t\t\t\t// extending from multiple interfaces.", "-\t\t\t\t\tInvocationSite site = new InvocationSite() {", "-\t\t\t\t\t\tpublic TypeBinding[] genericTypeArguments() { return null;}", "-\t\t\t\t\t\tpublic boolean isSuperAccess() {return false;}", "-\t\t\t\t\t\tpublic boolean isTypeAccess() {return false;}", "-\t\t\t\t\t\tpublic void setActualReceiverType(ReferenceBinding receiverType) {/* empty */}", "-\t\t\t\t\t\tpublic void setDepth(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic void setFieldIndex(int depth) {/* empty */ }", "-\t\t\t\t\t\tpublic int sourceEnd() {return resource.sourceEnd(); }", "-\t\t\t\t\t\tpublic int sourceStart() {return resource.sourceStart(); }", "-\t\t\t\t\t\tpublic TypeBinding expectedType() { return null; }", "-\t\t\t\t\t\tpublic boolean receiverIsImplicitThis() { return false;}", "-\t\t\t\t\t};", "-\t\t\t\t\tcloseMethod = this.scope.compilationUnitScope().findMethod(binding, ConstantPool.Close, new TypeBinding[0], site, false);", "-\t\t\t\t}", "-\t\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "-\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "-\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\t\t}", "+\t\t\t}", "+\t\t\tMethodBinding closeMethod = findCloseMethod(resource, resourceBinding);", "+\t\t\tif (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);", "-\t\t\t\tFlowInfo catchInfo;", "-\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\thandlingContext.initsOnReturn).", "-\t\t\t\t\t\t\taddNullInfoFrom(handlingContext.initsOnFinally);", "-\t\t\t\t}else {", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\t\tcatchInfo =", "-\t\t\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t\t\t.addNullInfoFrom(initsOnException)\t// null info only from here, this is the only way to enter the catch block", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "-\t\t\t\t}", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g.", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);", "-\t\t\t\t}", "+\t\t\t\tFlowInfo catchInfo = prepareCatchInfo(flowInfo, handlingContext, tryInfo, i);", "-\t\tif (flowContext.initsOnFinally != null) {", "-\t\t\tflowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);", "-\t\t}", "+\t\tflowContext.mergeFinallyNullInfo(handlingContext.initsOnFinally);"]}], "num": 55721}