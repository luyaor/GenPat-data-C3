{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0b001c8d3208d67d0950ccdda7881674", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07115bfb056c591712fa85d0ccfa22da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java", "commitBeforeChange": "372db4ee3a74f029d1a0f2dad8a011aea73fd481", "commitAfterChange": "f8da33d36ca2a5b95dcb1b251fe713aa575aecda", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": " \t \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\t\tif (((statementInfo = statement", "-\t\t\t\t\t.analyseCode(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t(labelContext =", "-\t\t\t\t\t\t\tnew LabelFlowContext(", "-\t\t\t\t\t\t\t\tflowContext,", "-\t\t\t\t\t\t\t\tthis,", "-\t\t\t\t\t\t\t\tlabel,", "-\t\t\t\t\t\t\t\t(targetLabel = new BranchLabel()),", "-\t\t\t\t\t\t\t\tcurrentScope)),", "-\t\t\t\t\t\tflowInfo)).tagBits & FlowInfo.UNREACHABLE) != 0) {", "-\t\t\t\tif ((labelContext.initsOnBreak.tagBits & FlowInfo.UNREACHABLE) == 0) {", "-\t\t\t\t\t// an embedded loop has had no chance to reinject forgotten null info", "-\t\t\t\t\tmergedInfo = flowInfo.unconditionalCopy().", "-\t\t\t\t\t\taddInitializationsFrom(labelContext.initsOnBreak);", "-\t\t\t\t} else {", "-\t\t\t\t\tmergedInfo = labelContext.initsOnBreak;", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tmergedInfo = statementInfo.mergedWith(labelContext.initsOnBreak);", "+\t\t\tstatementInfo = statement.analyseCode(", "+\t\t\t\tcurrentScope,", "+\t\t\t\t(labelContext =", "+\t\t\t\t\tnew LabelFlowContext(", "+\t\t\t\t\t\tflowContext,", "+\t\t\t\t\t\tthis,", "+\t\t\t\t\t\tlabel,", "+\t\t\t\t\t\t(targetLabel = new BranchLabel()),", "+\t\t\t\t\t\tcurrentScope)),", "+\t\t\t\tflowInfo);", "+\t\t\tboolean reinjectNullInfo = (statementInfo.tagBits & FlowInfo.UNREACHABLE) != 0 &&", "+\t\t\t\t(labelContext.initsOnBreak.tagBits & FlowInfo.UNREACHABLE) == 0;", "+\t\t\tmergedInfo = statementInfo.mergedWith(labelContext.initsOnBreak);", "+\t\t\tif (reinjectNullInfo) {", "+\t\t\t\t// an embedded loop has had no chance to reinject forgotten null info", "+\t\t\t\t((UnconditionalFlowInfo)mergedInfo).addInitializationsFrom(flowInfo.unconditionalFieldLessCopy()).", "+\t\t\t\t\taddInitializationsFrom(labelContext.initsOnBreak.unconditionalFieldLessCopy());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3bd362432fc66e8dd644e01f28b88348", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "33bcc97ba28fd6319a8c922b4f8d989e4aab5311", "commitAfterChange": "fe8f03030c996e7f3abaa101bf62fc6c88122090", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "signatureAfterChange": " private FlowInfo prepareCatchInfo(FlowInfo flowInfo, ExceptionHandlingFlowContext handlingContext, FlowInfo tryInfo, int i)", "diff": ["-\t\tif ((handlingContext.tagBits & (FlowContext.DEFER_NULL_DIAGNOSTIC | FlowContext.PREEMPT_NULL_DIAGNOSTIC))", "-\t\t\t\t== FlowContext.DEFER_NULL_DIAGNOSTIC)", "-\t\t{", "-\t\t\t// if null diagnostics are being deferred, initsOnException are incomplete,", "-\t\t\t// need to start with the more accurate upstream flowInfo", "-\t\t\tcatchInfo =", "-\t\t\t\tflowInfo.unconditionalCopy()", "-\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\ttryInfo.unconditionalCopy())", "-\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());\t\t\t\t\t\t", "-\t\t} else {", "-\t\t\t// here initsOnException are precise, so use them as the only source for null information into the catch block:", "-\t\t\tcatchInfo =", "-\t\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "-\t\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "-\t\t\t\t\t.addNullInfoFrom(initsOnException)", "-\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());", "-\t\t}", "+\t\tcatchInfo =", "+\t\t\tflowInfo.nullInfoLessUnconditionalCopy()", "+\t\t\t\t.addPotentialInitializationsFrom(initsOnException)", "+\t\t\t\t.addNullInfoFrom(initsOnException) // <<== Null info only from here!", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\thandlingContext.initsOnReturn.nullInfoLessUnconditionalCopy());"]}], "num": 1685}