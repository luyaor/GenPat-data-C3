{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "feea6b3bc38ac5aadab2e1b13c2c91e1", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "70a2c9eb53d75de01c9cc4d14b4d1d21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "57bbae793b080e332ffbe7d9a1eee58929157c9e", "commitAfterChange": "b217112507f53a311f9d32f09e4f736a9ed00294", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tprivate final void addOptimizedReplaceEdit(int offset, int length, String replacement)", "signatureAfterChange": "  \tprivate final void addOptimizedReplaceEdit(int offset, int length, String replacement)", "diff": ["-\t\t\tif (previousOffset == offset && previousLength == length && (replacementLength == 0 || previous.replacement.length() == 0)) {", "+\t\t\tfinal String previousReplacement = previous.replacement;", "+\t\t\tfinal int previousReplacementLength = previousReplacement.length();", "+\t\t\tif (previousOffset == offset && previousLength == length && (replacementLength == 0 || previousReplacementLength == 0)) {", "-\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength + length, previous.replacement + replacement);", "+\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength + length, previousReplacement + replacement);", "+\t\t\t\t\t} else if (previousLength + length == previousReplacementLength) {", "+\t\t\t\t\t\t// check the characters. If they are identical, we can get rid of the previous edit", "+\t\t\t\t\t\tboolean canBeRemoved = true;", "+\t\t\t\t\t\tloop: for (int i = previousOffset; i < previousOffset + previousReplacementLength; i++) {", "+\t\t\t\t\t\t\tif (scanner.source[i] != previousReplacement.charAt(i - previousOffset)) {", "+\t\t\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength + length, previousReplacement);", "+\t\t\t\t\t\t\t\tcanBeRemoved = false;", "+\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (canBeRemoved) {", "+\t\t\t\t\t\t\tif (this.currentAlignment != null) {", "+\t\t\t\t\t\t\t\tfinal Location location = this.currentAlignment.location;", "+\t\t\t\t\t\t\t\tif (location.editsIndex == this.editsIndex) {", "+\t\t\t\t\t\t\t\t\tlocation.editsIndex--;", "+\t\t\t\t\t\t\t\t\tlocation.textEdit = previous;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.editsIndex--;", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength + length, previous.replacement);", "+\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength + length, previousReplacement);", "-\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength, previous.replacement + replacement);", "+\t\t\t\t\t\tthis.edits[this.editsIndex - 1] = new OptimizedReplaceEdit(previousOffset, previousLength, previousReplacement + replacement);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d2ee45d769b2b3fea762afbf9e604f23", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "e944f831810e143e8894d05428eb208a2cd78cce", "commitAfterChange": "45b2548f21c6553964603037785b1fef0bb3e0d3", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprivate void adaptRegions()", "signatureAfterChange": " \tprivate void adaptRegions()", "diff": ["-\t\tthis.adaptedRegions = new IRegion[this.regions.length];", "-\t\tfor (int i = 0, max = this.regions.length; i < max; i++) {", "+\t\tint max = this.regions.length;", "+\t\tif (max == 1) {", "+\t\t\t// It's not necessary to adapt the single region which covers all the source", "+\t\t\tif (this.regions[0].getOffset() == 0 && this.regions[0].getLength() == this.scannerEndPosition) {", "+\t\t\t\tthis.adaptedRegions = this.regions;", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+\t\tthis.adaptedRegions = new IRegion[max];", "+\t\tint commentIndex = 0;", "+\t\tfor (int i = 0; i < max; i++) {", "+\t\t\tint length = aRegion.getLength();", "+", "+\t\t\t// First look if the region starts or ends inside a comment", "+\t\t\tint index = getCommentIndex(commentIndex, offset);", "+\t\t\tint adaptedOffset = offset;", "+\t\t\tint adaptedLength = length;", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the offset of the region is inside a comment => restart the region from the comment start", "+\t\t\t\tadaptedOffset = this.commentPositions[index][0];", "+\t\t\t\tif (adaptedOffset < 0) adaptedOffset = -adaptedOffset;", "+\t\t\t\tadaptedLength = length + offset - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t\t// include also the indentation edit just before the comment if any", "+\t\t\t\tfor (int j=0; j<this.editsIndex; j++) {", "+\t\t\t\t\tint editOffset = this.edits[j].offset;", "+\t\t\t\t\tint editEnd = editOffset + this.edits[j].length;", "+\t\t\t\t\tif (editEnd == adaptedOffset) {", "+\t\t\t\t\t\tif (j > 0 && this.edits[j].replacement.trim().length() == 0) {", "+\t\t\t\t\t\t\tadaptedLength += adaptedOffset - this.edits[j].offset;", "+\t\t\t\t\t\t\tadaptedOffset = editOffset;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (editEnd > adaptedOffset) {", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tindex = getCommentIndex(commentIndex, offset+length-1);", "+\t\t\tif (index >= 0) {", "+\t\t\t\t// the region end is inside a comment => set the region end at the comment end", "+\t\t\t\tint commentEnd = this.commentPositions[index][1];", "+\t\t\t\tif (commentEnd < 0) commentEnd = -commentEnd;", "+\t\t\t\tadaptedLength = commentEnd - adaptedOffset;", "+\t\t\t\tcommentIndex = index;", "+\t\t\t}", "+\t\t\tif (adaptedLength != length) {", "+\t\t\t\t// adapt the region and jump to next one", "+\t\t\t\tthis.adaptedRegions[i] = new Region(adaptedOffset, adaptedLength);", "+\t\t\t\tcontinue;", "+\t\t\t}", "+", "-\t\t\t\tint length = aRegion.getLength();"]}], "num": 11203}