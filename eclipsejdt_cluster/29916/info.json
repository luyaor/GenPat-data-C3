{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d468b9141d6fc4a317cb7b85cf4b3b28", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c391bf28ae77f583ceafcd7d7692f92d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "677a462098c653b539c7de50745a6a31854b50b0", "commitAfterChange": "2c4668c00bd6d1643aa73fe0da8a62f6377994a9", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t\t \tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " \t\t \tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\tif (thrownExceptions != null) {", "-\t\t\tint thrownExceptionsLength = thrownExceptions.length;", "-\t\t\tfor (int i = 0; i < thrownExceptionsLength; i++) {", "-\t\t\t\tmethodDecl.thrownExceptions().add(convert(thrownExceptions[i]));", "-\t\t\t}", "+\t\tint methodHeaderEnd = methodDeclaration.sourceEnd;", "+\t\tint thrownExceptionsLength = thrownExceptions == null ? 0 : thrownExceptions.length;", "+\t\tif (thrownExceptionsLength > 0) {", "+\t\t\tName thrownException;", "+\t\t\tint i = 0;", "+\t\t\tdo {", "+\t\t\t\tthrownException = convert(thrownExceptions[i++]);", "+\t\t\t\tmethodDecl.thrownExceptions().add(thrownException);", "+\t\t\t} while (i < thrownExceptionsLength);", "+\t\t\tmethodHeaderEnd = thrownException.getStartPosition() + thrownException.getLength();", "-\t\tif (parameters != null) {", "-\t\t\tint parametersLength = parameters.length;", "-\t\t\tfor (int i = 0; i < parametersLength; i++) {", "-\t\t\t\tmethodDecl.parameters().add(convert(parameters[i]));", "+\t\tint parametersLength = parameters == null ? 0 : parameters.length;", "+\t\tif (parametersLength > 0) {", "+\t\t\tSingleVariableDeclaration parameter;", "+\t\t\tint i = 0;", "+\t\t\tdo {", "+\t\t\t\tparameter = convert(parameters[i++]);", "+\t\t\t\tmethodDecl.parameters().add(parameter);", "+\t\t\t} while (i < parametersLength);", "+\t\t\tif (thrownExceptionsLength == 0) {", "+\t\t\t\tmethodHeaderEnd = parameter.getStartPosition() + parameter.getLength();", "-\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "-\t\t\tend = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);", "+\t\t\tstart = retrieveStartBlockPosition(methodHeaderEnd, methodDeclaration.bodyStart);", "+\t\t\tif (start == -1) start = methodDeclaration.bodyStart; // use recovery position for body start", "+\t\t\tend = retrieveRightBrace(methodDeclaration.bodyEnd, methodDeclaration.declarationSourceEnd);", "-\t\t\t\tblock.setSourceRange(start, end - start + 1);", "+\t\t\t\tblock.setSourceRange(start, closingPosition - start + 1);", "-\t\t\t\tstart = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);", "+\t\t\t\tstart = retrieveStartBlockPosition(methodHeaderEnd, declarationSourceEnd);", "+\t\t\t\tif (start == -1) start = methodDeclaration.bodyStart; // use recovery position for body start"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f2cf62a9fb978bdf6f61f053025aee15", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java", "commitBeforeChange": "7064f5cf4e1b20562054db6ff22e27e2bfde4008", "commitAfterChange": "c020688b25edf08bbc7d8d68981663ad78d2a9d8", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal Map<AnnotationProcessorFactory, FactoryPath.Attributes> factories, \t\t\tfinal ProcessorEnvImpl processorEnv, \t\t\tfinal List<IFile> filesWithMissingType, \t\t\tfinal List<ICompilationUnit> unitsForFilesWithMissingType, \t\t\tfinal int round)", "signatureAfterChange": " \tprivate void runAPTInMixedMode( \t\t\tfinal Map<AnnotationProcessorFactory, FactoryPath.Attributes> factories, \t\t\tfinal Set<AnnotationProcessorFactory> currentRoundDispatchedBatchFactories, \t\t\tfinal ProcessorEnvImpl processorEnv, \t\t\tfinal List<IFile> filesWithMissingType, \t\t\tfinal List<ICompilationUnit> unitsForFilesWithMissingType, \t\t\tfinal int internalRound)", "diff": ["+\t\t\tfinal Set<AnnotationProcessorFactory> currentRoundDispatchedBatchFactories,", "-\t\t\tfinal int round)", "+\t\t\tfinal int internalRound)", "-\t\tif (annotationDecls.isEmpty())", "+\t\tif (annotationDecls.isEmpty() && _dispatchedBatchFactories.isEmpty() )", "+\t\tif( AptPlugin.DEBUG )", "+\t\t\ttrace( \"annotations found \" + annotationDecls.keySet(), processorEnv); //$NON-NLS-1$", "+", "-\t\t// within one round APT dispatch.", "-\t\tif( !batchFactory2Annos.isEmpty() && round == 0){", "+\t\t// within one round APT dispatch.\t\t", "+\t\tif( internalRound == 0 ){", "+\t\t\tif( !batchFactory2Annos.isEmpty()){", "+\t\t\t\tprocessorEnv.setBatchProcessing();", "+\t\t\t\t// Once we figure out which factory claims what annotation,", "+\t\t\t\t// the order of the factory doesn't matter.", "+\t\t\t\t// But in order to make things consists between runs, will ", "+\t\t\t\t// dispatch base on factory order.", "+\t\t\t\tfor(AnnotationProcessorFactory factory : factories.keySet() ){\t\t\t", "+\t\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);", "+\t\t\t\t\tif( annotationTypes == null ) continue;", "+\t\t\t\t\tfinal AnnotationProcessor processor = ", "+\t\t\t\t\t\tfactory.getProcessorFor(annotationTypes, processorEnv);", "+\t\t\t\t\tif( processor != null ){", "+\t\t\t\t\t\tif ( AptPlugin.DEBUG ) ", "+\t\t\t\t\t\t\ttrace( \"runAPT: invoking batch processor \" + processor.getClass().getName(), //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tprocessorEnv);", "+\t\t\t\t\t\tcurrentRoundDispatchedBatchFactories.add(factory);", "+\t\t\t\t\t\tprocessor.process();", "+\t\t\t\t\t}", "+\t\t\t\t}\t\t\t", "+\t\t\t}", "-\t\t\t// Once we figure out which factory claims what annotation,", "-\t\t\t// the order of the factory doesn't matter.", "-\t\t\t// But in order to make things consists between runs, will ", "-\t\t\t// dispatch base on factory order.", "-\t\t\tfor(AnnotationProcessorFactory factory : factories.keySet() ){\t\t\t", "-\t\t\t\tfinal Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);", "-\t\t\t\tif( annotationTypes == null ) continue;", "+\t\t\tfor( AnnotationProcessorFactory prevRoundFactory : _dispatchedBatchFactories ){", "+\t\t\t\tif(currentRoundDispatchedBatchFactories.contains(prevRoundFactory))", "+\t\t\t\t\tcontinue;", "-\t\t\t\t\tfactory.getProcessorFor(annotationTypes, processorEnv);", "+\t\t\t\t\tprevRoundFactory.getProcessorFor(Collections.<AnnotationTypeDeclaration>emptySet(), processorEnv);", "-\t\t\t\t\t\t\t\tprocessorEnv); ", "-                    processorEnv.setLatestProcessor(processor);", "+\t\t\t\t\t\t\t\tprocessorEnv);", "-\t\t                    processorEnv.setLatestProcessor(processor);"]}], "num": 29916}