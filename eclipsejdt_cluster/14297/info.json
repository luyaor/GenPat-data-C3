{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "323c998aad8e807227104795ed6ff34f", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "045de6254d24c796be80887c4e3a9caa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "eb4ff23c38228c4d00e0da694ac7e98ede6240d8", "commitAfterChange": "85fdee7dd19538da3ffbc3959a79cffbaddd43f9", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " int[] findOverriddenInheritedMethods(MethodBinding[] methods, int length)", "signatureAfterChange": " int[] findOverriddenInheritedMethods(MethodBinding[] methods, int length)", "diff": ["+\t// NOTE assumes length > 1", "-\tif (length > 1) {", "-\t\tnextMethod : for (int i = 0; i < length; i++) {", "-\t\t\tReferenceBinding declaringClass = methods[i].declaringClass;", "-\t\t\tif (declaringClass.isInterface()) {", "-\t\t\t\tif (toSkip != null && toSkip[i] == -1) continue nextMethod;", "-\t\t\t\tfor (int j = i + 1; j < length; j++) {", "-\t\t\t\t\tif (toSkip != null && toSkip[j] == -1) continue;", "-\t\t\t\t\tReferenceBinding declaringClass2 = methods[j].declaringClass;", "-\t\t\t\t\tif (declaringClass == declaringClass2) continue;", "-\t\t\t\t\tif (declaringClass.implementsInterface(declaringClass2, true)) {", "-\t\t\t\t\t\tif (toSkip == null)", "-\t\t\t\t\t\t\ttoSkip = new int[length];", "-\t\t\t\t\t\ttoSkip[j] = -1;", "-\t\t\t\t\t} else if (declaringClass2.implementsInterface(declaringClass, true)) {", "-\t\t\t\t\t\tif (toSkip == null)", "-\t\t\t\t\t\t\ttoSkip = new int[length];", "-\t\t\t\t\t\ttoSkip[i] = -1;", "-\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\t// only keep methods from the closest superclass, all others from higher superclasses can be skipped", "-\t\t\t\t// NOTE: methods were added in order by walking up the superclass hierarchy", "-\t\t\t\tfor (int j = i + 1; j < length; j++) {", "-\t\t\t\t\tReferenceBinding declaringClass2 = methods[j].declaringClass;", "-\t\t\t\t\tif (declaringClass == declaringClass2) continue;", "-\t\t\t\t\tif (declaringClass2.isInterface()) {", "-\t\t\t\t\t\ti = j - 1; // start the interface comparison with this method", "-\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (toSkip == null)", "-\t\t\t\t\t\t\ttoSkip = new int[length];", "-\t\t\t\t\t\ttoSkip[j] = -1;", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\tint i = 0;", "+\tReferenceBinding declaringClass = methods[i].declaringClass;", "+\tif (!declaringClass.isInterface()) {", "+\t\t// in the first pass, skip overridden methods from superclasses", "+\t\t// only keep methods from the closest superclass, all others from higher superclasses can be skipped", "+\t\t// NOTE: methods were added in order by walking up the superclass hierarchy", "+\t\tReferenceBinding declaringClass2 = methods[++i].declaringClass;", "+\t\twhile (declaringClass == declaringClass2) {", "+\t\t\tif (++i == length) return null;", "+\t\t\tdeclaringClass2 = methods[i].declaringClass;", "+\t\t}", "+\t\tif (!declaringClass2.isInterface()) {", "+\t\t\t// skip all methods from different superclasses", "+\t\t\ttoSkip = new int[length];", "+\t\t\tdo {", "+\t\t\t\ttoSkip[i] = -1;", "+\t\t\t\tif (++i == length) return toSkip;", "+\t\t\t\tdeclaringClass2 = methods[i].declaringClass;", "+\t\t\t} while (!declaringClass2.isInterface());", "+\t\t}", "+\t}", "+\t// in the second pass, skip overridden methods from superinterfaces", "+\t// NOTE: superinterfaces can appear in 'random' order", "+\tnextMethod : for (; i < length; i++) {", "+\t\tif (toSkip != null && toSkip[i] == -1) continue nextMethod;", "+\t\tdeclaringClass = methods[i].declaringClass;", "+\t\tfor (int j = i + 1; j < length; j++) {", "+\t\t\tif (toSkip != null && toSkip[j] == -1) continue;", "+\t\t\tReferenceBinding declaringClass2 = methods[j].declaringClass;", "+\t\t\tif (declaringClass == declaringClass2) continue;", "+\t\t\tif (declaringClass.implementsInterface(declaringClass2, true)) {", "+\t\t\t\tif (toSkip == null)", "+\t\t\t\t\ttoSkip = new int[length];", "+\t\t\t\ttoSkip[j] = -1;", "+\t\t\t} else if (declaringClass2.implementsInterface(declaringClass, true)) {", "+\t\t\t\tif (toSkip == null)", "+\t\t\t\t\ttoSkip = new int[length];", "+\t\t\t\ttoSkip[i] = -1;", "+\t\t\t\tcontinue nextMethod;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91a08e7644391df0cdf1b73652e2fe00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "6908063eba8a685f56d7ca33afe706e68d2c77b5", "commitAfterChange": "f78b6c4d80823115b2a0c851e53515d68cdcf5c5", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": " \tprivate Boolean moreSpecificMain(TypeBinding si, TypeBinding ti, Expression expri) throws InferenceFailureException", "signatureAfterChange": " \tprivate Boolean moreSpecificMain(TypeBinding si, TypeBinding ti, Expression expri) throws InferenceFailureException", "diff": ["-\t// null:  need the otherwise branch", "+\t// null:  need to create the si <: ti constraint", "-\t\tif (si.isFunctionalInterface(this.scope)) {", "-\t\t\tTypeBinding funcI = ti.original();", "-\t\t\tif (funcI.isFunctionalInterface(this.scope)) {", "-\t\t\t\t// \"... none of the following is true:\" ", "-\t\t\t\tif (siSuperI(si, funcI) || siSubI(si, funcI))", "-\t\t\t\t\treturn null;", "-\t\t\t\tif (si instanceof IntersectionTypeBinding18) {", "-\t\t\t\t\tTypeBinding[] elements = ((IntersectionTypeBinding18)si).intersectingTypes;", "-\t\t\t\t\tcheckSuper: {", "-\t\t\t\t\t\tfor (int i = 0; i < elements.length; i++)", "-\t\t\t\t\t\t\tif (!siSuperI(elements[i], funcI))", "-\t\t\t\t\t\t\t\tbreak checkSuper;", "-\t\t\t\t\t\treturn null; // each element of the intersection is a superinterface of I, or a parameterization of a superinterface of I.", "-\t\t\t\t\t}", "+\t\t// \"if Ti is not a functional interface type\" specifically requests the si <: ti constraint created by our caller", "+\t\tif (!ti.isFunctionalInterface(this.scope))", "+\t\t\treturn null;", "+", "+\t\tTypeBinding funcI = ti.original();", "+\t\t// \"It must be determined whether Si satisfies the following five conditions:\"", "+\t\t// (we negate each condition for early exit):", "+\t\tif (si.isFunctionalInterface(this.scope)) {\t\t\t// bullet 1", "+\t\t\tif (siSuperI(si, funcI) || siSubI(si, funcI))", "+\t\t\t\treturn null;\t\t\t\t\t\t\t\t// bullets 2 & 3", "+\t\t\tif (si instanceof IntersectionTypeBinding18) {", "+\t\t\t\tTypeBinding[] elements = ((IntersectionTypeBinding18)si).intersectingTypes;", "+\t\t\t\tcheckSuper: {", "-\t\t\t\t\t\tif (siSubI(elements[i], funcI))", "-\t\t\t\t\t\t\treturn null; // some element of the intersection is a subinterface of I, or a parameterization of a subinterface of I.\t", "+\t\t\t\t\t\tif (!siSuperI(elements[i], funcI))", "+\t\t\t\t\t\t\tbreak checkSuper;", "+\t\t\t\t\treturn null;\t\t\t\t\t\t\t// bullet 4 ", "+\t\t\t\t\t// each element of the intersection is a superinterface of I, or a parameterization of a superinterface of I.", "-\t\t\t\t// all passed, time to do some work:", "-\t\t\t\tTypeBinding siCapture = si.capture(this.scope, expri.sourceStart, expri.sourceEnd);", "-\t\t\t\tMethodBinding sam = siCapture.getSingleAbstractMethod(this.scope, false); // no wildcards should be left needing replacement", "-\t\t\t\tTypeBinding[] u = sam.parameters;", "-\t\t\t\tTypeBinding r1 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "-\t\t\t\tsam = ti.getSingleAbstractMethod(this.scope, true); // TODO", "-\t\t\t\tTypeBinding[] v = sam.parameters;", "-\t\t\t\tTypeBinding r2 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "-\t\t\t\treturn Boolean.valueOf(checkExpression(expri, u, r1, v, r2));", "+\t\t\t\tfor (int i = 0; i < elements.length; i++)", "+\t\t\t\t\tif (siSubI(elements[i], funcI))", "+\t\t\t\t\t\treturn null;\t\t\t\t\t\t// bullet 5", "+\t\t\t\t\t\t// some element of the intersection is a subinterface of I, or a parameterization of a subinterface of I.\t", "+\t\t\t// all passed, time to do some work:", "+\t\t\tTypeBinding siCapture = si.capture(this.scope, expri.sourceStart, expri.sourceEnd);", "+\t\t\tMethodBinding sam = siCapture.getSingleAbstractMethod(this.scope, false); // no wildcards should be left needing replacement", "+\t\t\tTypeBinding[] u = sam.parameters;", "+\t\t\tTypeBinding r1 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "+\t\t\tsam = ti.getSingleAbstractMethod(this.scope, true); // TODO", "+\t\t\tTypeBinding[] v = sam.parameters;", "+\t\t\tTypeBinding r2 = sam.isConstructor() ? sam.declaringClass : sam.returnType;", "+\t\t\treturn Boolean.valueOf(checkExpression(expri, u, r1, v, r2));"]}], "num": 14297}