{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f1d5ee332bc423554c039007d15ac19d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "170ef23de797c564bdfdb505c2553c3c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java", "commitBeforeChange": "48c062bdb9d6c67e0ab7ada621b2e78159b00da7", "commitAfterChange": "c33fa703a95df265770d385ad9292308f48aa3cc", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tString computeRootPath(String javaFilePath, char[] contents)", "signatureAfterChange": " \tprivate String computeRootPath(File directory)", "diff": ["+\t}", "+\tprivate String computeRootPath(File directory) {", "+\t\tFile[] files = directory.listFiles();", "+\t\tfor (int i = 0; i < files.length; i++) {", "+\t\t\tFile file = files[i];", "+\t\t\tif (file.isDirectory()) {", "+\t\t\t\tString rootPath = computeRootPath(file);", "+\t\t\t\tif (rootPath != null) return rootPath;", "+\t\t\t} else if (Util.isJavaFileName(file.getName())) {", "+\t\t\t\ttry {", "+\t\t\t\t\tchar[] contents = Util.getFileCharContent(file, this.encoding);", "+\t\t\t\t\tIPath fullPath = new Path(file.getPath());", "+\t\t\t\t\tIPath relativePath = fullPath.removeFirstSegments(this.sourcePath.segmentCount()).setDevice(null);", "+\t\t\t\t\tString rootPath = computeRootPath(relativePath.toString(), contents);", "+\t\t\t\t\tif (rootPath != null) return rootPath;", "+\t\t\t\t} catch (IOException e) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1bace1cebc39b777dc61fb88a0c81a1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java", "commitBeforeChange": "1df699e669c4e4f2a900614bdd75bf90200992be", "commitAfterChange": "0171a309cfa1d187647511afec0bb25c2eadf3cf", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "signatureAfterChange": " \tpublic static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite)", "diff": ["+\t\t", "+\t\t// first iteration, questionning widening cast", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)argument);", "+\t\t\t\t\tscope.problemReporter().unnecessaryCastForArgument((CastExpression)argument, binding.parameters[i]);", "-\t\tif (rawArgumentTypes == argumentTypes) return; // did not find any unnecessary cast candidate", "-\t", "-\t\tInvocationSite fakeInvocationSite = new InvocationSite(){\t", "-\t\t\tpublic boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }", "-\t\t\tpublic boolean isTypeAccess() { return invocationSite.isTypeAccess(); }", "-\t\t\tpublic void setActualReceiverType(ReferenceBinding actualReceiverType) {}", "-\t\t\tpublic void setDepth(int depth) {}", "-\t\t\tpublic void setFieldIndex(int depth){}", "-\t\t};\t", "-\t\tMethodBinding bindingIfNoCast;", "-\t\tif (binding.isConstructor()) {", "-\t\t\tbindingIfNoCast = scope.getConstructor(receiverType, rawArgumentTypes, fakeInvocationSite);", "-\t\t} else {", "-\t\t\tbindingIfNoCast = receiver.isImplicitThis()", "-\t\t\t\t? scope.getImplicitMethod(binding.selector, rawArgumentTypes, fakeInvocationSite)", "-\t\t\t\t: scope.getMethod(receiverType, binding.selector, rawArgumentTypes, fakeInvocationSite); \t", "+\t\t// did not find any unnecessary cast candidate", "+\t\tif (rawArgumentTypes != argumentTypes) {", "+\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);", "-\t\tif (bindingIfNoCast == binding) {", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tif (argumentTypes[i] != rawArgumentTypes[i]) {", "-\t\t\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)arguments[i]);", "+\t\t", "+\t\t// second attempt questionning narrowing cast", "+\t\trawArgumentTypes = argumentTypes;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression && (argument.bits & UnnecessaryCastMask) == 0) {", "+\t\t\t\tTypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;", "+\t\t\t\tif (rawArgumentTypes == argumentTypes) {", "+\t\t\t\t\tSystem.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);", "+\t\t\t\trawArgumentTypes[i] = castedExpressionType; ", "+\t\t}", "+\t\tif (rawArgumentTypes != argumentTypes) {", "+\t\t\tcheckAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);"]}], "num": 47269}