{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "344b22cac09fb199afbcdfcc06f9b68c", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "266a2bf17ef95de5cb9fc311dc62ac16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e6099120ee9021152f84e60105066d4964c2db21", "commitAfterChange": "82631a98caad8b28e9cefb217339d51e64ef47f9", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "signatureAfterChange": "\r \tpublic void locateMatches(\r \t\tString[] filePaths, \r \t\tIWorkspace workspace,\r \t\tIWorkingCopy[] workingCopies, \r \t\tIProgressMonitor progressMonitor)\r \t\tthrows JavaModelException", "diff": ["-\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "-\t\tif (this.handleFactory == null) {\r", "-\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t}\r", "-\t\t\r", "-\t\t// initialize locator with working copies\r", "-\t\tthis.workingCopies = workingCopies;\r", "-\t\t\r", "-\t\t// substitute compilation units with working copies\r", "-\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "-\t\tint wcLength;\r", "-\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "-\t\t\tString[] newPaths = new String[wcLength];\r", "-\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "-\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "-\t\t\t\ttry {\r", "-\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t\tString path = res.getFullPath().toString();\r", "-\t\t\t\t\twcPaths.put(path, workingCopy);\r", "-\t\t\t\t\tnewPaths[i] = path;\r", "-\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t// continue with next working copy\r", "-\t\t\t\t}\r", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();\r", "+\t\ttry {\r", "+\t\t\t// optimize access to zip files during search operation\r", "+\t\t\tmanager.cacheZipFiles();\r", "+\t\t\t\t\r", "+\t\t\t// initialize handle factory (used as a cache of handles so as to optimize space)\r", "+\t\t\tif (this.handleFactory == null) {\r", "+\t\t\t\tthis.handleFactory = new HandleFactory(workspace);\r", "-\t\t\tint filePathsLength = filePaths.length;\r", "-\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "-\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\t\t}\r", "-\t\t\r", "-\t\tint length = filePaths.length;\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\r", "-\t\t// sort file paths projects\r", "-\t\tUtil.sort(filePaths); \r", "-\t\t\r", "-\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "-\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "-\t\t\r", "-\t\tJavaProject previousJavaProject = null;\r", "-\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "-\t\t\t\tthrow new OperationCanceledException();\r", "-\t\t\t}\r", "-\t\t\tString pathString = filePaths[i];\r", "-\t\t\t// skip duplicate paths\r", "-\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t// initialize locator with working copies\r", "+\t\t\tthis.workingCopies = workingCopies;\r", "-\t\t\tOpenable openable;\r", "-\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "-\t\t\tif (workingCopy != null) {\r", "-\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t} else {\r", "-\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "-\t\t\t\tif (openable == null)\r", "-\t\t\t\t\tcontinue; // match is outside classpath\r", "-\t\t\t}\r", "-\r", "-\t\t\t// create new parser and lookup environment if this is a new project\r", "-\t\t\tIResource resource = null;\r", "-\t\t\tJavaProject javaProject = null;\r", "-\t\t\ttry {\r", "-\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "-\t\t\t\tif (workingCopy != null) {\r", "-\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "-\t\t\t\t\tresource = javaProject.getProject();\r", "-\t\t\t\t}\r", "-\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "-\t\t\t\t\t// locate matches in previous project\r", "-\t\t\t\t\tif (previousJavaProject != null) {\r", "-\t\t\t\t\t\ttry {\r", "-\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\t\t\t\tthrow e;\r", "-\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t// substitute compilation units with working copies\r", "+\t\t\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\t\t\tint wcLength;\r", "+\t\t\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\t\t\tString[] newPaths = new String[wcLength];\r", "+\t\t\t\tfor (int i = 0; i < wcLength; i++) {\r", "+\t\t\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tIResource res = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t\tString path = res.getFullPath().toString();\r", "+\t\t\t\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\t\t\t\tnewPaths[i] = path;\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t// continue with next working copy\r", "-\r", "-\t\t\t\t\t// create parser for this project\r", "-\t\t\t\t\tthis.createParser(javaProject);\r", "-\t\t\t\t\tpreviousJavaProject = javaProject;\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\t// file doesn't exist -> skip it\r", "-\t\t\t\tcontinue;\r", "+\t\t\t\tint filePathsLength = filePaths.length;\r", "+\t\t\t\tSystem.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);\r", "+\t\t\t\tSystem.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);\r", "-\r", "-\t\t\t// add matching openable\r", "-\t\t\tthis.addMatchingOpenable(resource, openable);\r", "-\r", "+\t\t\t\r", "+\t\t\tint length = filePaths.length;\r", "-\t\t\t\tprogressMonitor.worked(1);\r", "+\t\t\t\tprogressMonitor.beginTask(\"\", length * 3); // 1 for file path, 1 for binding creation, 1 for resolution //$NON-NLS-1$\r", "-\t\t}\r", "-\t\t\r", "-\t\t// last project\r", "-\t\tif (previousJavaProject != null) {\r", "-\t\t\ttry {\r", "-\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "-\t\t\t} catch (JavaModelException e) {\r", "-\t\t\t\tif (e.getException() instanceof CoreException) {\r", "-\t\t\t\t\tthrow e;\r", "+\t\r", "+\t\t\t// sort file paths projects\r", "+\t\t\tUtil.sort(filePaths); \r", "+\t\t\t\r", "+\t\t\t// initialize pattern for polymorphic search (ie. method reference pattern)\r", "+\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\tthis.pattern.initializePolymorphicSearch(this, progressMonitor);\r", "+\t\t\t\r", "+\t\t\tJavaProject previousJavaProject = null;\r", "+\t\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\t\tif (progressMonitor != null && progressMonitor.isCanceled()) {\r", "+\t\t\t\t\tthrow new OperationCanceledException();\r", "+\t\t\t\t}\r", "+\t\t\t\tString pathString = filePaths[i];\r", "+\t\t\t\t\r", "+\t\t\t\t// skip duplicate paths\r", "+\t\t\t\tif (i > 0 && pathString.equals(filePaths[i-1])) continue;\r", "+\t\t\t\t\r", "+\t\t\t\tOpenable openable;\r", "+\t\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);\r", "+\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\topenable = (Openable)workingCopy;\r", "-\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\topenable = this.handleFactory.createOpenable(pathString);\r", "+\t\t\t\t\tif (openable == null)\r", "+\t\t\t\t\t\tcontinue; // match is outside classpath\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// create new parser and lookup environment if this is a new project\r", "+\t\t\t\tIResource resource = null;\r", "+\t\t\t\tJavaProject javaProject = null;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tjavaProject = (JavaProject) openable.getJavaProject();\r", "+\t\t\t\t\tif (workingCopy != null) {\r", "+\t\t\t\t\t\tresource = workingCopy.getOriginalElement().getUnderlyingResource();\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tresource = openable.getUnderlyingResource();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (resource == null) { // case of a file in an external jar\r", "+\t\t\t\t\t\tresource = javaProject.getProject();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tif (!javaProject.equals(previousJavaProject)) {\r", "+\t\t\t\t\t\t// locate matches in previous project\r", "+\t\t\t\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\t\t\t\ttry {\r", "+\t\t\t\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t// problem with classpath in this project -> skip it\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t\t\t\t}\r", "+\t\r", "+\t\t\t\t\t\t// create parser for this project\r", "+\t\t\t\t\t\tthis.createParser(javaProject);\r", "+\t\t\t\t\t\tpreviousJavaProject = javaProject;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t// file doesn't exist -> skip it\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\r", "+\t\t\t\t// add matching openable\r", "+\t\t\t\tthis.addMatchingOpenable(resource, openable);\r", "+\t\r", "+\t\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\t\tprogressMonitor.worked(1);\r", "-\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "-\t\t} \r", "-\t\t\r", "-\t\tif (progressMonitor != null) {\r", "-\t\t\tprogressMonitor.done();\r", "-\t\t}\r", "-\r", "+\t\t\t\r", "+\t\t\t// last project\r", "+\t\t\tif (previousJavaProject != null) {\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tthis.locateMatches(previousJavaProject, progressMonitor);\r", "+\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\tif (e.getException() instanceof CoreException) {\r", "+\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t// problem with classpath in last project -> skip it\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tthis.matchingOpenables = new MatchingOpenableSet();\r", "+\t\t\t} \r", "+\t\t\t\r", "+\t\t\tif (progressMonitor != null) {\r", "+\t\t\t\tprogressMonitor.done();\r", "+\t\t\t}\r", "+\t\t} finally {\r", "+\t\t\tif (this.nameEnvironment != null) {\r", "+\t\t\t\tthis.nameEnvironment.cleanup();\r", "+\t\t\t}\r", "+\t\t\tthis.parsedUnits = null;\r", "+\t\t\tmanager.flushZipFiles();\r", "+\t\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bd670978f4773cb90a25056976caf251", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "64298556651d81e68f8405c1642b36744d7373dd", "commitAfterChange": "b92bafecd030777e0d6056677f8286cf640a489f", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic void complete(IType type, char[] snippet, int position, char[][] localVariableTypeNames, char[][] localVariableNames, int[] localVariableModifiers, boolean isStatic)", "signatureAfterChange": " \t \tpublic void complete(IType type, char[] snippet, int position, char[][] localVariableTypeNames, char[][] localVariableNames, int[] localVariableModifiers, boolean isStatic)", "diff": ["-", "+\t\tif(this.requestor != null){", "+\t\t\tthis.requestor.beginReporting();", "+\t\t}", "+\t\t", "-\t\t\t\t\tthis.requestor.acceptError(this.problem);", "+\t\t\t\t\tthis.requestor.completionFailure(this.problem);", "+\t\t\t\t\tif(DEBUG) {", "+\t\t\t\t\t\tthis.printDebug(this.problem);", "+\t\t\t\t\t}", "+\t\t}", "+\t\t", "+\t\tif(this.requestor != null){", "+\t\t\tthis.requestor.endReporting();"]}], "num": 36486}