{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "388223e102449e1c02fa4c33e2c73700", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "49134a2cff97eb9630661550acd0461e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "f39402d13165cb2a8baa9e8822f47cb5416f824f", "commitAfterChange": "c59f5d3873f087b004eace9b9fa6844d0400c666", "methodNumberBeforeChange": 63, "methodNumberAfterChange": 63, "signatureBeforeChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError) \t\tthrows JavaModelException", "signatureAfterChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tIClasspathEntry[] classpathEntries, \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError) \t\tthrows JavaModelException", "diff": ["-\t\t\tIMarker marker = null;", "-\t\t\tif (generateMarkerOnError) {", "-\t\t\t\tIJavaModelStatus status =", "-\t\t\t\t\tJavaConventions.validateClasspathEntry(this, rawEntry, false);", "-\t\t\t\tif (!status.isOK()) {", "-\t\t\t\t\tString incompleteCPOption = this.getOption(JavaCore.CORE_INCOMPLETE_CLASSPATH, true);", "-\t\t\t\t\tmarker = createClasspathProblemMarker(", "-\t\t\t\t\t\tstatus.getMessage(), ", "-\t\t\t\t\t\tJavaCore.ERROR.equals(incompleteCPOption) ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING,", "-\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\tfalse);", "-\t\t\t\t}", "+\t\t\tIJavaModelStatus status = null;", "+\t\t\tif (generateMarkerOnError || !ignoreUnresolvedEntry) {", "+\t\t\t\tstatus = JavaConventions.validateClasspathEntry(this, rawEntry, false);", "+\t\t\t\tif (generateMarkerOnError && !status.isOK()) createClasspathProblemMarker(status);", "-\t\t\t\t\t\tif (marker != null) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tmarker.setAttribute(IJavaModelMarker.UNBOUND_VARIABLE, rawEntry.getPath().segment(0));", "-\t\t\t\t\t\t\t} catch(CoreException e) {", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ignoreUnresolvedEntry) {", "-\t\t\t\t\t\t\tthrow new JavaModelException(", "-\t\t\t\t\t\t\t\tnew JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND,", "-\t\t\t\t\t\t\t\t\trawEntry.getPath().toString()));", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (!ignoreUnresolvedEntry) throw new JavaModelException(status);", "-\t\t\t\t\t\t// unbound container", "-\t\t\t\t\t\tif (marker != null) {", "-\t\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t\tmarker.setAttribute(IJavaModelMarker.UNBOUND_CONTAINER, rawEntry.getPath().makeRelative().toString());", "-\t\t\t\t\t\t\t} catch(CoreException e) {", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (!ignoreUnresolvedEntry) {", "-\t\t\t\t\t\t\tthrow new JavaModelException(", "-\t\t\t\t\t\t\t\tnew JavaModelStatus(", "-\t\t\t\t\t\t\t\t\tIJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND,", "-\t\t\t\t\t\t\t\t\trawEntry.getPath().toString()));", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (!ignoreUnresolvedEntry) throw new JavaModelException(status);", "-\t\t\t\t\t\tIClasspathEntry containerRawEntry = containerEntries[j];", "+\t\t\t\t\t\tIClasspathEntry cEntry = containerEntries[j];", "-\t\t\t\t\t\t\tIJavaModelStatus status =", "-\t\t\t\t\t\t\t\tJavaConventions.validateClasspathEntry(this, containerRawEntry, false);", "-\t\t\t\t\t\t\tif (!status.isOK()) {", "-\t\t\t\t\t\t\t\tString incompleteCPOption = this.getOption(JavaCore.CORE_INCOMPLETE_CLASSPATH, true);", "-\t\t\t\t\t\t\t\tcreateClasspathProblemMarker(", "-\t\t\t\t\t\t\t\t\tstatus.getMessage(), ", "-\t\t\t\t\t\t\t\t\tJavaCore.ERROR.equals(incompleteCPOption) ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING,", "-\t\t\t\t\t\t\t\t\tfalse,", "-\t\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tIJavaModelStatus containerStatus = JavaConventions.validateClasspathEntry(this, cEntry, false);", "+\t\t\t\t\t\t\tif (!containerStatus.isOK()) createClasspathProblemMarker(containerStatus);", "-\t\t\t\t\t\t\tcontainerRawEntry = new ClasspathEntry(", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getContentKind(),", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getEntryKind(), ", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getPath(),", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getExclusionPatterns(),", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getSourceAttachmentPath(),", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getSourceAttachmentRootPath(),", "-\t\t\t\t\t\t\t\tcontainerRawEntry.getOutputLocation(),", "+\t\t\t\t\t\t\tcEntry = new ClasspathEntry(cEntry.getContentKind(),", "+\t\t\t\t\t\t\t\tcEntry.getEntryKind(), cEntry.getPath(),", "+\t\t\t\t\t\t\t\tcEntry.getExclusionPatterns(), cEntry.getSourceAttachmentPath(),", "+\t\t\t\t\t\t\t\tcEntry.getSourceAttachmentRootPath(), cEntry.getOutputLocation(), ", "-\t\t\t\t\t\tresolvedEntries.add(containerRawEntry);", "+\t\t\t\t\t\tresolvedEntries.add(cEntry);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0256ae0a4ba6ff0143fb6edc36939ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "8e80deae1f046ae4551ba19254abdddd2b23044c", "commitAfterChange": "20ab4653c81b813fd48f74b27ae8af07488f3d49", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tConstant cst = this.condition.constant;", "-\t\tboolean isConditionTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionFalse = cst != NotAConstant && cst.booleanValue() == false;", "-", "-\t\tcst = this.condition.optimizedBooleanConstant();", "+\t\tConstant cst = this.condition.optimizedBooleanConstant();", "+\t\tint mode = flowInfo.reachMode();", "-", "-\t\tif (isConditionTrue) {", "-\t\t\t// TRUE ? left : right", "-\t\t\tFlowInfo resultInfo =", "-\t\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo.initsWhenTrue().unconditionalInits());", "-\t\t\t// analyse valueIfFalse, but do not take into account any of its infos", "-\t\t\tvalueIfFalse.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo.initsWhenFalse().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));", "-\t\t\tmergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(resultInfo);", "-\t\t\treturn resultInfo;", "-\t\t} else if (isConditionFalse) {", "-\t\t\t// FALSE ? left : right", "-\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t", "-\t\t\tvalueIfTrue.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo.initsWhenTrue().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));", "-\t\t\tFlowInfo mergeInfo =", "-\t\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo.initsWhenFalse().unconditionalInits());", "-\t\t\tmergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergeInfo);", "-\t\t\treturn mergeInfo;", "-\t\t}", "-", "-\t\t// propagate analysis", "-\t\tFlowInfo trueInfo = flowInfo.initsWhenTrue().copy();", "-\t\tint mode = trueInfo.reachMode();", "-\t\tif (isConditionOptimizedFalse) trueInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "-\t\tthenInitStateIndex = currentScope.methodScope().recordInitializationStates(trueInfo);", "-\t\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo);", "-\t\ttrueInfo.setReachMode(mode);", "-\t\tFlowInfo falseInfo = flowInfo.initsWhenFalse().copy();", "-\t\tmode = falseInfo.reachMode();", "-\t\tif (isConditionOptimizedTrue) falseInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "-\t\telseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseInfo);", "-\t\tfalseInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseInfo);", "-\t\tfalseInfo.setReachMode(mode);", "+\t\t// process the if-true part", "+\t\tFlowInfo trueFlowInfo = flowInfo.initsWhenTrue().copy();", "+\t\tif (isConditionOptimizedFalse) trueFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+\t\ttrueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);", "+\t\ttrueFlowInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);", "+\t\t// process the if-false part", "+\t\tFlowInfo falseFlowInfo = flowInfo.initsWhenFalse().copy();", "+\t\tif (isConditionOptimizedTrue) falseFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+\t\tfalseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseFlowInfo);", "+\t\tfalseFlowInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseFlowInfo);", "-\t\t// merge using a conditional info -  1GK2BLM", "-\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "-\t\tFlowInfo mergedInfo =", "-\t\t\tFlowInfo.conditional(", "-\t\t\t\ttrueInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "-\t\t\t\t\tfalseInfo.initsWhenTrue().copy().unconditionalInits()),", "-\t\t\t\ttrueInfo.initsWhenFalse().unconditionalInits().mergedWith(", "-\t\t\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));", "-", "-\t\t// store a copy of the merged info, so as to compute the local variable attributes afterwards", "+\t\t// merge if-true & if-false initializations", "+\t\tFlowInfo mergedInfo;", "+\t\tif (isConditionOptimizedTrue){", "+\t\t\tmergedInfo = trueFlowInfo;", "+\t\t} else if (isConditionOptimizedFalse) {", "+\t\t\tmergedInfo = falseFlowInfo;", "+\t\t} else {", "+\t\t\t// merge using a conditional info -  1GK2BLM", "+\t\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "+\t\t\tmergedInfo =", "+\t\t\t\tFlowInfo.conditional(", "+\t\t\t\t\ttrueFlowInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "+\t\t\t\t\t\tfalseFlowInfo.initsWhenTrue().copy().unconditionalInits()),", "+\t\t\t\t\ttrueFlowInfo.initsWhenFalse().unconditionalInits().mergedWith(", "+\t\t\t\t\t\tfalseFlowInfo.initsWhenFalse().unconditionalInits()));", "+\t\t}", "+\t\tmergedInfo.setReachMode(mode);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe7aee2170ca854174f01af532fffaef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java", "commitBeforeChange": "cbd955fb2a4598f2699dd195e39c5cb17dbd967e", "commitAfterChange": "4923f7bf4c07fe4ddafc97e39d6c8df65941fe37", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public boolean contains(IResource resource)", "signatureAfterChange": " public boolean contains(IResource resource)", "diff": ["+\tIJavaProject[] projects;", "-\t\tIPath path = resource.getFullPath();", "-\t\tIJavaProject[] projects = this.getJavaProjects();", "-\t\tfor (int i = 0, length = projects.length; i < length; i++) {", "-\t\t\tIJavaProject project = projects[i];", "-\t\t\tIClasspathEntry[] classpath = project.getResolvedClasspath(true);", "-\t\t\t", "-\t\t\tIPath output = project.getOutputLocation();", "-\t\t\tIPath innerMostOutput = output.isPrefixOf(path) ? output : null;", "-\t\t\tIClasspathEntry innerMostEntry = null;", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++) {", "-\t\t\t\tIClasspathEntry entry = classpath[j];", "-", "-\t\t\t\tIPath entryPath = entry.getPath();", "-\t\t\t\tif ((innerMostEntry == null || innerMostEntry.getPath().isPrefixOf(entryPath))", "-\t\t\t\t\t\t&& entryPath.isPrefixOf(path)) {", "-\t\t\t\t\tinnerMostEntry = entry;", "-\t\t\t\t}", "-\t\t\t\tIPath entryOutput = classpath[j].getOutputLocation();", "-\t\t\t\tif (entryOutput != null && entryOutput.isPrefixOf(path)) {", "-\t\t\t\t\tinnerMostOutput = entryOutput;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (innerMostEntry != null) {", "-\t\t\t\t// special case prj==src and nested output location", "-\t\t\t\tif (innerMostOutput != null && innerMostOutput.segmentCount() > 1 // output isn't project", "-\t\t\t\t\t\t&& innerMostEntry.getPath().segmentCount() == 1) { // 1 segment must be project name", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\tif  (resource instanceof IFolder) {", "-\t\t\t\t\t // folders are always included in src/lib entries", "-\t\t\t\t\t return true;", "-\t\t\t\t}", "-\t\t\t\tswitch (innerMostEntry.getEntryKind()) {", "-\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE:", "-\t\t\t\t\t\t// .class files are not visible in source folders ", "-\t\t\t\t\t\treturn !Util.isClassFileName(path.lastSegment());", "-\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY:", "-\t\t\t\t\t\t// .java files are not visible in library folders", "-\t\t\t\t\t\treturn !Util.isJavaFileName(path.lastSegment());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (innerMostOutput != null) {", "-\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\treturn true;", "+\t\tprojects = this.getJavaProjects();", "+\tfor (int i = 0, length = projects.length; i < length; i++) {", "+\t\tJavaProject project = (JavaProject)projects[i];", "+\t\tif (!project.contains(resource)) {", "+\t\t\treturn false;", "+\t\t}", "+\t}", "+\treturn true;"]}], "num": 56888}