{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "501cf3bc4e332d7e5e47c2134cc77c23", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6415ec6121a9d9963195fa938d966694", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "67766e5b27ea79987add5b8cee1657ec3cbfbedb", "commitAfterChange": "e6c002b5fc187b459093049d56b25a0df58b8d61", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0)", "+\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "-\t\t\telse if (!sourceType.isAnonymousType()){ // body of enum constant must implement any inherited abstract methods", "+\t\t\t} else if (!sourceType.isAnonymousType()) {", "+\t\t\t\t// body of enum constant must implement any inherited abstract methods", "-\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "-\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "-\t\t\t\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "-\t\t\t\t\tif (length == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "-\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\t\tint fieldsLength = fields == null ? 0 : fields.length;", "+\t\t\t\t\tif (fieldsLength == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "+\t\t\t\t\tAbstractMethodDeclaration[] methods = typeDeclaration.methods;", "+\t\t\t\t\tint methodsLength = methods == null ? 0 : methods.length;", "+\t\t\t\t\t// TODO (kent) cannot tell that the superinterfaces are empty or that their methods are implemented", "+\t\t\t\t\tboolean definesAbstractMethod = typeDeclaration.superInterfaces != null;", "+\t\t\t\t\tfor (int i = 0; i < methodsLength && !definesAbstractMethod; i++)", "+\t\t\t\t\t\tdefinesAbstractMethod = methods[i].isAbstract();", "+\t\t\t\t\tif (!definesAbstractMethod) break checkAbstractEnum; // all methods have bodies", "+\t\t\t\t\tfor (int i = 0; i < fieldsLength; i++) {", "+\t\t\tmodifiers |= AccFinal;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "986b1256e6a0ef2045f7b1a000ce0140", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "ad9419ce2b413384a1310dd9b222d0ccd125407d", "commitAfterChange": "7cd9da1e8a67c35ab511299ccf3966d49c713a3c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-", "-\t\t\t// what about inherited interface methods?", "-\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "-\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "-\t\t\t} else if (!sourceType.isAnonymousType()) {", "-\t\t\t\t// body of enum constant must implement any inherited abstract methods", "-\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "+\t\t\tif (!sourceType.isAnonymousType()) {", "+\t\t\t\t\t// does define abstract methods ?", "+\t\t\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "+\t\t\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "+\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t\t} \t\t\t\t\t", "+\t\t\t\t\t// body of enum constant must implement any inherited abstract methods", "+\t\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "-\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "-\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "-\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (fieldDecl.initialization instanceof QualifiedAllocationExpression) {", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t// final if no enum constant with anonymous body", "+\t\t\t\tcheckFinalEnum: {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\t\tif (fields != null) {", "+\t\t\t\t\t\tfor (int i = 0, fieldsLength = fields.length; i < fieldsLength; i++) {", "+\t\t\t\t\t\t\tFieldDeclaration fieldDecl = fields[i];", "+\t\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {", "+\t\t\t\t\t\t\t\tif (fieldDecl.initialization instanceof QualifiedAllocationExpression) {", "+\t\t\t\t\t\t\t\t\tbreak checkFinalEnum;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tmodifiers |= ClassFileConstants.AccFinal;", "+\t\t\t\t}\t\t\t", "-\t\t\tmodifiers |= ClassFileConstants.AccFinal;"]}], "num": 17815}