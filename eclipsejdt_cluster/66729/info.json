{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ac4b114be79c48f8617bc1cfabc59a15", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "119dbe6f5be18fa0f028f5ee6dec7ca4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "d5bfe063c252b2db98f4d11e1c90a755611d0a56", "commitAfterChange": "bc1023a3db35de5f11d5861f411b9a4de78ba0ab", "methodNumberBeforeChange": 33, "methodNumberAfterChange": 33, "signatureBeforeChange": " \tpublic synchronized int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "signatureAfterChange": " \tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "diff": ["-\tpublic synchronized int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException {", "+\tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException {", "+\t\t", "+\t\t// create the delta builder (this remembers the current content of the working copy)", "+\t\t// outside the perWorkingCopyInfos lock (see bug 50667)", "+\t\tJavaElementDeltaBuilder deltaBuilder = null;", "+\t\tif (workingCopy.isPrimary()) {", "+\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "+\t\t}", "+\t\tPerWorkingCopyInfo info = null;", "-\t\t\tPerWorkingCopyInfo info = (PerWorkingCopyInfo)workingCopyToInfos.get(workingCopy);", "+\t\t\tinfo = (PerWorkingCopyInfo)workingCopyToInfos.get(workingCopy);", "-\t\t\t\t// create the delta builder (this remembers the current content of the working copy)", "-\t\t\t\tJavaElementDeltaBuilder deltaBuilder = null;", "-\t\t\t\tif (workingCopy.isPrimary()) {", "-\t\t\t\t\tdeltaBuilder = new JavaElementDeltaBuilder(workingCopy);", "-\t\t\t\t}", "-", "-", "-\t\t\t\t// remove infos + close buffer (since no longer working copy)", "-\t\t\t\tremoveInfoAndChildren(workingCopy);", "-\t\t\t\tworkingCopy.closeBuffer();", "-", "-\t\t\t\t// compute the delta if needed and register it if there are changes", "-\t\t\t\tif (deltaBuilder != null) {", "-\t\t\t\t\tdeltaBuilder.buildDeltas();", "-\t\t\t\t\tif ((deltaBuilder.delta != null) && (deltaBuilder.delta.getAffectedChildren().length > 0)) {", "-\t\t\t\t\t\tgetDeltaProcessor().registerJavaModelDelta(deltaBuilder.delta);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\t", "-\t\t\treturn info.useCount;", "+\t\tif (info.useCount == 0) { // info cannot be null here (check was done above)", "+\t\t\t// remove infos + close buffer (since no longer working copy)", "+\t\t\t// outside the perWorkingCopyInfos lock (see bug 50667)", "+\t\t\tremoveInfoAndChildren(workingCopy);", "+\t\t\tworkingCopy.closeBuffer();", "+", "+\t\t\t// compute the delta if needed and register it if there are changes", "+\t\t\tif (deltaBuilder != null) {", "+\t\t\t\tdeltaBuilder.buildDeltas();", "+\t\t\t\tif ((deltaBuilder.delta != null) && (deltaBuilder.delta.getAffectedChildren().length > 0)) {", "+\t\t\t\t\tgetDeltaProcessor().registerJavaModelDelta(deltaBuilder.delta);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn info.useCount;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d769123a9aaf4b10e2e0174092c9540d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "6945031c95ca0d70ac3adb24efe812a06855be13", "commitAfterChange": "7a9726508a1cf4124fc56e814b6b230c72a37501", "methodNumberBeforeChange": 28, "methodNumberAfterChange": 29, "signatureBeforeChange": " \tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "signatureAfterChange": " \tpublic int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException", "diff": ["-\t\t\tPerWorkingCopyInfo info = (PerWorkingCopyInfo)perWorkingCopyInfos.get(workingCopy);", "-\t\t\tif (info != null) {", "-\t\t\t\tif (--info.useCount == 0) {", "-\t\t\t\t\tIJavaElement originalElement = workingCopy.getOriginalElement();", "+\t\t\tWorkingCopyOwner owner = workingCopy.owner;", "+\t\t\tMap pathToPerWorkingCopyInfos = (Map)this.perWorkingCopyInfos.get(owner);", "+\t\t\tif (pathToPerWorkingCopyInfos == null) return -1;", "+\t\t\t", "+\t\t\tIPath path = workingCopy.getPath();", "+\t\t\tPerWorkingCopyInfo info = (PerWorkingCopyInfo)pathToPerWorkingCopyInfos.get(path);", "+\t\t\tif (info == null) return -1;", "+\t\t\t", "+\t\t\tif (--info.useCount == 0) {", "+\t\t\t\tIJavaElement originalElement = workingCopy.getOriginalElement();", "-\t\t\t\t\t// remove per working copy info", "-\t\t\t\t\tperWorkingCopyInfos.remove(workingCopy);", "-", "-\t\t\t\t\t// remove infos + close buffer (since no longer working copy)", "-\t\t\t\t\tremoveInfoAndChildren(workingCopy);", "-\t\t\t\t\tworkingCopy.closeBuffer();", "-\t\t\t\t\t", "-\t\t\t\t\t// if original element is not on classpath flush it from the cache ", "-\t\t\t\t\tif (!workingCopy.getParent().exists()) {", "-\t\t\t\t\t\t((CompilationUnit)originalElement).close();", "-\t\t\t\t\t}", "-\t\t\t\t\t", "-\t\t\t\t\t// remove working copy from the shared working copy cache if needed", "-\t\t\t\t\t// In order to be shared, working copies have to denote the same compilation unit ", "-\t\t\t\t\t// AND use the same owner.", "-\t\t\t\t\t// Assuming there is a little set of buffer factories, then use a 2 level Map cache.", "-\t\t\t\t\tMap perFactoryWorkingCopies = (Map) this.sharedWorkingCopies.get(workingCopy.owner);", "-\t\t\t\t\tif (perFactoryWorkingCopies != null){", "-\t\t\t\t\t\tif (perFactoryWorkingCopies.remove(originalElement) != null", "-\t\t\t\t\t\t\t\t&& CompilationUnit.SHARED_WC_VERBOSE) {", "-\t\t\t\t\t\t\tSystem.out.println(\"Destroying shared working copy \" + workingCopy.toStringWithAncestors());//$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tif (perFactoryWorkingCopies.isEmpty()) {", "-\t\t\t\t\t\t\tthis.sharedWorkingCopies.remove(workingCopy.owner);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t\t// remove per working copy info", "+\t\t\t\tpathToPerWorkingCopyInfos.remove(path);", "+\t\t\t\tif (pathToPerWorkingCopyInfos.isEmpty()) {", "+\t\t\t\t\tthis.perWorkingCopyInfos.remove(owner);", "-\t\t\t\treturn info.useCount;", "-\t\t\t} else {", "-\t\t\t\treturn -1;", "-\t\t\t}\t", "+", "+\t\t\t\t// remove infos + close buffer (since no longer working copy)", "+\t\t\t\tremoveInfoAndChildren(workingCopy);", "+\t\t\t\tworkingCopy.closeBuffer();", "+\t\t\t\t", "+\t\t\t\t// if original element is not on classpath flush it from the cache ", "+\t\t\t\tif (!workingCopy.getParent().exists()) {", "+\t\t\t\t\t((CompilationUnit)originalElement).close();", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn info.useCount;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd496e1b6409d999325510c1fea122d4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/WorkingCopyOwnerTests.java", "commitBeforeChange": "844b891620178c0b92403d6108fad8dcdac272df", "commitAfterChange": "f4f81968c0fa49af0ebd2fc1f35fb9113776c823", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void testDiscardWorkingCopy3() throws CoreException", "signatureAfterChange": " \tpublic void testDiscardWorkingCopy3() throws CoreException", "diff": ["-\t\tICompilationUnit workingCopy = null;", "-\t\t\tworkingCopy = cu.getWorkingCopy(owner, null, null);", "-\t\t\tworkingCopy = cu.getWorkingCopy(owner, null, null);", "-\t\t\tworkingCopy = cu.getWorkingCopy(owner, null, null);", "-\t\t\tassertTrue(\"should be in working copy mode\", workingCopy.isWorkingCopy());", "-\t\t\tassertTrue(\"should be opened\", workingCopy.isOpen());", "-\t\t\tassertTrue(\"should exist\", workingCopy.exists());", "+\t\t\tthis.workingCopy = cu.getWorkingCopy(owner, null, null);", "+\t\t\tthis.workingCopy = cu.getWorkingCopy(owner, null, null);", "+\t\t\tthis.workingCopy = cu.getWorkingCopy(owner, null, null);", "+\t\t\tassertTrue(\"should be in working copy mode\", this.workingCopy.isWorkingCopy());", "+\t\t\tassertTrue(\"should be opened\", this.workingCopy.isOpen());", "+\t\t\tassertTrue(\"should exist\", this.workingCopy.exists());", "-\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t\tassertTrue(\"should still be in working copy mode (1)\", workingCopy.isWorkingCopy());", "-\t\t\tassertTrue(\"should still be opened\", workingCopy.isOpen());", "-\t\t\tassertTrue(\"should still exist\", workingCopy.exists());", "+\t\t\tthis.workingCopy.discardWorkingCopy();", "+\t\t\tassertTrue(\"should still be in working copy mode (1)\", this.workingCopy.isWorkingCopy());", "+\t\t\tassertTrue(\"should still be opened\", this.workingCopy.isOpen());", "+\t\t\tassertTrue(\"should still exist\", this.workingCopy.exists());", "-\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t\tworkingCopy.discardWorkingCopy();", "-\t\t\tassertTrue(\"should still be in working copy mode (2)\", workingCopy.isWorkingCopy());", "-\t\t\tassertTrue(\"should no longer be opened\", !workingCopy.isOpen());", "-\t\t\tassertTrue(\"should no longer exist\", !workingCopy.exists());", "+\t\t\tthis.workingCopy.discardWorkingCopy();", "+\t\t\tthis.workingCopy.discardWorkingCopy();", "+\t\t\tassertTrue(\"should still be in working copy mode (2)\", this.workingCopy.isWorkingCopy());", "+\t\t\tassertTrue(\"should no longer be opened\", !this.workingCopy.isOpen());", "+\t\t\tassertTrue(\"should no longer exist\", !this.workingCopy.exists());", "-\t\t\tif (workingCopy != null) {", "+\t\t\tif (this.workingCopy != null) {", "-\t\t\t\twhile (workingCopy.isWorkingCopy() && max-- > 0) {", "-\t\t\t\t\tworkingCopy.discardWorkingCopy();", "+\t\t\t\twhile (this.workingCopy.isWorkingCopy() && max-- > 0) {", "+\t\t\t\t\tthis.workingCopy.discardWorkingCopy();"]}], "num": 66729}