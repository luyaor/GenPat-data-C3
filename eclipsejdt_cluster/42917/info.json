{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9c8b2a1b086fec516e15ab2289fcb77c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f4b19b2af59e32e7b596f0666f5655c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "cee242bcb21b999953c5459d6b40de2d782355f3", "commitAfterChange": "de0ba5a5e09b42f4671d55cb69260aca34e3da86", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "signatureAfterChange": " \tprotected boolean parseReference(boolean plain) throws InvalidInputException", "diff": ["+\t\tint typeRefStartPosition = -1;", "-\t\t\t\tcase TerminalTokens.TokenNameStringLiteral :", "-\t\t\t\t\t// @see \"string\"", "+\t\t\t\tcase TerminalTokens.TokenNameStringLiteral : // @see \"string\"", "-\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\twhile (Character.isWhitespace(this.source[this.index])) {", "-\t\t\t\t\t\t\tif (this.source[this.index] == '\\r' || this.source[this.index] == '\\n') {", "-\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "-\t\t\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t\t\t\tpushText(previousPosition, this.index);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tthis.index++;", "-\t\t\t\t\t\t}", "+\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t}", "+\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\treturn true;", "-\t\t\t\tcase TerminalTokens.TokenNameLESS :", "-\t\t\t\t\t// @see \"<a href=\"URL#Value\">label</a>", "+\t\t\t\tcase TerminalTokens.TokenNameLESS : // @see \"<a href=\"URL#Value\">label</a>", "-\t\t\t\t\t\tif (typeRef == null) {", "-\t\t\t\t\t\t\tconsumeToken();", "-\t\t\t\t\t\t\twhile (Character.isWhitespace(this.source[this.index])) {", "-\t\t\t\t\t\t\t\tif (this.source[this.index] == '\\r' || this.source[this.index] == '\\n') {", "-\t\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "-\t\t\t\t\t\t\t\t\t\tparseTag();", "-\t\t\t\t\t\t\t\t\t\tpushText(previousPosition, this.index);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tthis.index++;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tconsumeToken();", "+\t\t\t\t\t\t// If typeRef != null we may raise a warning here to let user know there's an unused reference...", "+\t\t\t\t\t\t// Currently as javadoc 1.4.2 ignore it, we do the same (see bug 69302)", "+\t\t\t\t\t\tif (typeRef != null) {", "+\t\t\t\t\t\t\tstart = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\tpreviousPosition = start;", "+\t\t\t\t\t\t\ttypeRef = null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// verify end line (expecting empty or end comment)", "+\t\t\t\t\t\tif (verifyEndLine(previousPosition)) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\ttypeRefStartPosition = this.scanner.getCurrentTokenStartPosition();", "-\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "-\t\t// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "-\t\tint start = this.scanner.getCurrentTokenStartPosition();", "-\t\ttry {", "-\t\t\tint token = readToken();", "-\t\t\tif (token != TerminalTokens.TokenNameLPAREN) {", "-\t\t\t\t// Reset position: we want to rescan last token", "-\t\t\t\tif (this.currentTokenType != -1) {", "-\t\t\t\t\tthis.index = this.tokenPreviousPosition;", "-\t\t\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "-\t\t\t\t\tthis.currentTokenType = -1;", "-\t\t\t\t}", "-\t\t\t\treturn pushSeeRef(reference, plain);", "-\t\t\t}", "-\t\t} catch (InvalidInputException e) {", "-\t\t\t// Do nothing as we report an error after", "-\t\t}", "-\t\t// Reset position to avoid missing tokens when new line was encountered", "-\t\tthis.index = this.tokenPreviousPosition;", "-\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t// Reset position at the end of type reference", "+\t\tthis.index = this.lastIdentifierEndPosition+1;", "+\t\tthis.scanner.currentPosition = this.index;", "-\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidSeeReference(start, this.lineEnd);", "-\t\treturn false;", "+", "+\t\t// Verify that line end does not start with an open parenthese (which could be a constructor reference wrongly written...)", "+\t\t// See bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=47215", "+\t\tchar ch = peekChar();", "+\t\tif (ch == '(') {", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMissingHashCharacter(typeRefStartPosition, this.lineEnd, String.valueOf(this.source, typeRefStartPosition, this.lineEnd-typeRefStartPosition));", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// Verify that we get white space after reference", "+\t\tif (!verifySpaceOrEndComment()) {", "+\t\t\tthis.index = this.tokenPreviousPosition;", "+\t\t\tthis.scanner.currentPosition = this.tokenPreviousPosition;", "+\t\t\tthis.currentTokenType = -1;", "+\t\t\tint end = this.starPosition == -1 ? this.lineEnd : this.starPosition;", "+\t\t\tif (this.source[end]=='\\n') end--;", "+\t\t\tif (this.sourceParser != null) this.sourceParser.problemReporter().javadocMalformedSeeReference(typeRefStartPosition, end);", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Everything is OK, store reference", "+\t\treturn pushSeeRef(reference, plain);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a39170762c5982053d7079f5f12785d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "38f73e89bd4606189d7e6d499593d5aa49ab247d", "commitAfterChange": "83b83ec335a27590393034d86f94208edbfcc45a", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tfor (int level = 0; level <= VARARGS_COMPATIBLE; level++) {", "+\t\tfor (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {", "+\t\t\t\t\tmax = level; // do not examine further categories", "-\t\t\t\t\t} else if (method.isStatic()) {", "-\t\t\t\t\t\t// detect collision between static import methods from unconnected types", "-\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "-\t\t\t\t\t\t\tif (method.declaringClass.findSuperTypeWithSameErasure(method2.declaringClass) == null)", "+\t\t\t\t\t}", "+", "+\t\t\t\t\tif (method == method2) continue; // interfaces may be walked twice from different paths", "+", "+\t\t\t\t\t// see if method & method2 are duplicates due to the current substitution or multiple static imported methods", "+\t\t\t\t\tif (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {", "+\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "+\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "+", "+\t\t\t\t\t\tMethodBinding original = method.original();", "+\t\t\t\t\t\tif (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (superType == null) {", "+\t\t\t\t\t\t\t\t// accept concrete methods over abstract methods found due to the default abstract method walk", "+\t\t\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "+\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t} else if (!method.original().areTypeVariableErasuresEqual(method2.original())) {", "-\t\t\t\t\t\t// cannot override an inherited method if type variables are not compatible", "-\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t} else if (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract()) { // must both be abstract or concrete, not one of each", "-\t\t\t\t\t\tif (method.areParametersEqual(method2)) {", "-\t\t\t\t\t\t\t// its possible with 2 methods that one does not inherit from the other", "-\t\t\t\t\t\t\t// need to find their methods from the receiver type", "-\t\t\t\t\t\t\t// see cases in verify test #43", "-\t\t\t\t\t\t\tMethodBinding original = method.original();", "-\t\t\t\t\t\t\tMethodBinding original2 = method2.original();", "-\t\t\t\t\t\t\tif (original.areParameterErasuresEqual(original2)) continue;", "-\t\t\t\t\t\t\tReferenceBinding receiverType = (ReferenceBinding) ((MessageSend) invocationSite).actualReceiverType;", "-\t\t\t\t\t\t\tif (receiverType != method.declaringClass) {", "-\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeWithSameErasure(original.declaringClass);", "-\t\t\t\t\t\t\t\tif (superType != null) {", "-\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "-\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tMethodBinding inheritedMethod = method2;", "+\t\t\t\t\t\t\tMethodBinding inheritedOriginal = method2.original();", "+\t\t\t\t\t\t\tif (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == inheritedOriginal) {", "+\t\t\t\t\t\t\t\t\t\tinheritedMethod = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tif (receiverType != method2.declaringClass) {", "-\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeWithSameErasure(original2.declaringClass);", "-\t\t\t\t\t\t\t\tif (superType != null) {", "-\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "-\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (!original.areParametersEqual(original2))", "-\t\t\t\t\t\t\t\tcontinue nextVisible; // cannot be substituted from 2 different type variables", "+\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables)", "+\t\t\t\t\t\t\t\tinheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());", "+\t\t\t\t\t\t\tif (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))", "+\t\t\t\t\t\t\t\tbreak nextVisible; // dup thru substitution, not overridden... cannot find possible match", "+\t\t\t\t\t\t\t// method overrides method2, accept it", "+\t\t\t\t\t\t} else if (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (superType == null)", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // static methods from unrelated types"]}], "num": 42917}