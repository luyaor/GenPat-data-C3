{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e437720091c10487e822a2de7d5738d5", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44f672d2c60e915aebfec4461445feb8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "2414c381d9fba720a3b5b2375f506f068b4616ba", "commitAfterChange": "888d5cb313019c8c62b5cbd42b139e8dc64793b3", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " protected void consumeSingleTypeImportDeclarationName()", "signatureAfterChange": "  protected void consumeSingleTypeImportDeclarationName()", "diff": ["+", "-\tsuper.consumeSingleTypeImportDeclarationName();", "-\tImportReference impt = (ImportReference)astStack[astPtr];", "+\tImportReference impt;", "+\tint length;", "+\tchar[][] tokens = new char[length = this.identifierLengthStack[this.identifierLengthPtr--]][];", "+\tthis.identifierPtr -= length;", "+\tlong[] positions = new long[length];", "+\tSystem.arraycopy(this.identifierStack, this.identifierPtr + 1, tokens, 0, length);", "+\tSystem.arraycopy(this.identifierPositionStack, this.identifierPtr + 1, positions, 0, length);", "+\tpushOnAstStack(impt = newImportReference(tokens, positions, false, ClassFileConstants.AccDefault));", "+\t", "+\tif (this.currentToken == TokenNameSEMICOLON){", "+\t\timpt.declarationSourceEnd = this.scanner.currentPosition - 1;", "+\t} else {", "+\t\timpt.declarationSourceEnd = impt.sourceEnd;", "+\t}", "+\timpt.declarationEnd = impt.declarationSourceEnd;", "+\t//this.endPosition is just before the ;", "+\timpt.declarationSourceStart = this.intStack[this.intPtr--];", "+\t", "+\t// recovery", "+\tif (this.currentElement != null){", "+\t\tthis.lastCheckPoint = impt.declarationSourceEnd+1;", "+\t\tthis.currentElement = this.currentElement.add(impt, 0);", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.restartRecovery = true; // used to avoid branching back into the regular automaton\t\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c574e76f3296fa7dee4f1d6d85edd15", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 183, "methodNumberAfterChange": 258, "signatureBeforeChange": " protected void consumeTypeImportOnDemandDeclaration()", "signatureAfterChange": " protected void consumeStaticImportOnDemandDeclarationName()", "diff": ["+protected void consumeStaticImportOnDemandDeclarationName() {", "+\t// TypeImportOnDemandDeclarationName ::= 'import' 'static' Name '.' '*'", "+\t/* push an ImportRef build from the last name ", "+\tstored in the identifier stack. */", "+", "+\tImportReference impt;", "+\tint length;", "+\tchar[][] tokens = new char[length = this.identifierLengthStack[this.identifierLengthPtr--]][];", "+\tthis.identifierPtr -= length;", "+\tlong[] positions = new long[length];", "+\tSystem.arraycopy(this.identifierStack, this.identifierPtr + 1, tokens, 0, length);", "+\tSystem.arraycopy(this.identifierPositionStack, this.identifierPtr + 1, positions, 0, length);", "+\tpushOnAstStack(impt = new ImportReference(tokens, positions, true, AccStatic));", "+", "+\tthis.modifiers = AccDefault;", "+\tthis.modifiersSourceStart = -1; // <-- see comment into modifiersFlag(int)", "+\t", "+\tif (this.currentToken == TokenNameSEMICOLON){", "+\t\timpt.declarationSourceEnd = this.scanner.currentPosition - 1;", "+\t} else {", "+\t\timpt.declarationSourceEnd = impt.sourceEnd;", "+\t}", "+\timpt.declarationEnd = impt.declarationSourceEnd;", "+\t//this.endPosition is just before the ;", "+\timpt.declarationSourceStart = this.intStack[this.intPtr--];", "+", "+\tif(options.sourceLevel < ClassFileConstants.JDK1_5 &&", "+\t\t\tthis.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {", "+\t\tthis.problemReporter().invalidUsageOfStaticImports(impt);", "+\t}", "+\t", "+\t// recovery", "+\tif (this.currentElement != null){", "+\t\tthis.lastCheckPoint = impt.declarationSourceEnd+1;", "+\t\tthis.currentElement = this.currentElement.add(impt, 0);", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.restartRecovery = true; // used to avoid branching back into the regular automaton\t\t", "+\t}\t", "+}", "-}", "-protected void consumeTypeImportOnDemandDeclaration() {", "-\t// TypeImportOnDemandDeclaration ::= TypeImportOnDemandDeclarationName ';'", "-", "-\tImportReference impt = (ImportReference) this.astStack[this.astPtr];", "-\t// flush comments defined prior to import statements", "-\timpt.declarationEnd = this.endStatementPosition;", "-\timpt.declarationSourceEnd = ", "-\t\tthis.flushCommentsDefinedPriorTo(impt.declarationSourceEnd); ", "-", "-\t// recovery", "-\tif (this.currentElement != null) {", "-\t\tthis.lastCheckPoint = impt.declarationSourceEnd + 1;", "-\t\tthis.currentElement = this.currentElement.add(impt, 0);", "-\t\tthis.restartRecovery = true;", "-\t\tthis.lastIgnoredToken = -1;", "-\t\t// used to avoid branching back into the regular automaton", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d159b9690aa67089e6078c827855b1d1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "2414c381d9fba720a3b5b2375f506f068b4616ba", "commitAfterChange": "888d5cb313019c8c62b5cbd42b139e8dc64793b3", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": " protected void consumeTypeImportOnDemandDeclarationName()", "signatureAfterChange": " protected void consumeTypeImportOnDemandDeclarationName()", "diff": ["-\tsuper.consumeTypeImportOnDemandDeclarationName();", "-\tImportReference impt = (ImportReference)astStack[astPtr];", "+\tImportReference impt;", "+\tint length;", "+\tchar[][] tokens = new char[length = this.identifierLengthStack[this.identifierLengthPtr--]][];", "+\tthis.identifierPtr -= length;", "+\tlong[] positions = new long[length];", "+\tSystem.arraycopy(this.identifierStack, this.identifierPtr + 1, tokens, 0, length);", "+\tSystem.arraycopy(this.identifierPositionStack, this.identifierPtr + 1, positions, 0, length);", "+\tpushOnAstStack(impt = new ImportReference(tokens, positions, true, ClassFileConstants.AccDefault));", "+\t", "+\tif (this.currentToken == TokenNameSEMICOLON){", "+\t\timpt.declarationSourceEnd = this.scanner.currentPosition - 1;", "+\t} else {", "+\t\timpt.declarationSourceEnd = impt.sourceEnd;", "+\t}", "+\timpt.declarationEnd = impt.declarationSourceEnd;", "+\t//this.endPosition is just before the ;", "+\timpt.declarationSourceStart = this.intStack[this.intPtr--];", "+\t", "+\t// recovery", "+\tif (this.currentElement != null){", "+\t\tthis.lastCheckPoint = impt.declarationSourceEnd+1;", "+\t\tthis.currentElement = this.currentElement.add(impt, 0);", "+\t\tthis.lastIgnoredToken = -1;", "+\t\tthis.restartRecovery = true; // used to avoid branching back into the regular automaton\t\t", "+\t}"]}], "num": 25823}