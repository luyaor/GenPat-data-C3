{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c6ae8fd26b38a82638b5eb38a1d247e", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9692fa57dc75c7558e73c6bb7c80feda", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "aa717ce56e721f6ed4fc92594ba56da9f08c982e", "commitAfterChange": "5e93996c6b4562ee73fa5730afbd832d1574cd08", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " \tpublic void printComment()", "signatureAfterChange": " \tpublic void printComment()", "diff": ["+\t\t\tint count = 0;", "-\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "-\t\t\t\t\t\tint count = 0;", "+\t\t\t\t\t\tcount = 0;", "-\t\t\t\t\t\tif (count > 1) {", "-\t\t\t\t\t\t\tpreserveEmptyLines(count - 1);", "-\t\t\t\t\t\t} else if (count == 1) {", "-\t\t\t\t\t\t\tif (hasLineComment) {", "-\t\t\t\t\t\t\t\tpreserveEmptyLines(1);", "-\t\t\t\t\t\t\t} else if (hasComment || this.formatter.preferences.preserve_user_linebreaks) {", "-\t\t\t\t\t\t\t\tprintNewLine();", "+\t\t\t\t\t\tif (count == 0) {", "+\t\t\t\t\t\t\thasWhitespace = true;", "+\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\t\t\t} else if (hasComment) {", "+\t\t\t\t\t\t\tif (count == 1) {", "+\t\t\t\t\t\t\t\tthis.printNewLine(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\t\t\t} else if (this.formatter.preferences.preserve_user_linebreaks) {", "+\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "+\t\t\t\t\t\t\tif (count == 1) {", "+\t\t\t\t\t\t\t\tthis.printNewLine(this.scanner.getCurrentTokenEndPosition() + 1);", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenEndPosition() + 1);", "-\t\t\t\t\t\t\thasWhitespace = true;", "+\t\t\t\t\t\t\taddDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());", "-\t\t\t\t\t\tif (hasWhitespace) {", "+\t\t\t\t\t\tif (count >= 1) {", "+\t\t\t\t\t\t\tif (count > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (count == 1 || hasLineComment || hasComment || this.formatter.preferences.preserve_user_linebreaks) {", "+\t\t\t\t\t\t\t\tprintNewLine(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (hasWhitespace) {", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t} ", "-\t\t\t\t\t\tif (hasWhitespace) {", "+\t\t\t\t\t\tif (count >= 1) {", "+\t\t\t\t\t\t\tif (count > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (count == 1 && ((hasLineComment || hasComment || this.formatter.preferences.preserve_user_linebreaks))) {", "+\t\t\t\t\t\t\t\tprintNewLine(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (hasWhitespace) {", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t} ", "-\t\t\t\t\t\tif (hasWhitespace) {", "+\t\t\t\t\t\tif (count >= 1) {", "+\t\t\t\t\t\t\tif (count > 1) {", "+\t\t\t\t\t\t\t\tpreserveEmptyLines(count - 1, this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t} else if (count == 1 && ((hasLineComment || hasComment || this.formatter.preferences.preserve_user_linebreaks))) {", "+\t\t\t\t\t\t\t\tprintNewLine(this.scanner.getCurrentTokenStartPosition());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else if (hasWhitespace) {", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5c9a366a301c9000baa7e4c76b997f1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8bd987839355c299213c95f3874a2e3574283d9c", "commitAfterChange": "76b6723dbe61d0b9874754d0d6572d1a4d8c0cbc", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 70, "signatureBeforeChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "signatureAfterChange": "  \tprivate int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine)", "diff": ["-\t\tif (!isHtmlBreakTag) {", "+\t\tif (isHtmlBreakTag) {", "+\t\t\treturn 1;", "+\t\t}", "-\t\t\t// Iterate on text line separators", "-\t\t\tboolean isCode = htmlTagID == JAVADOC_CODE_TAGS_ID;", "-\t\t\tfor (int idx=0, ptr=0; idx<=max || (text.htmlNodesPtr != -1 && ptr <= text.htmlNodesPtr); idx++) {", "+\t\t// Iterate on text line separators", "+\t\tboolean isCode = htmlTagID == JAVADOC_CODE_TAGS_ID;", "+\t\tfor (int idx=0, ptr=0; idx<=max || (text.htmlNodesPtr != -1 && ptr <= text.htmlNodesPtr); idx++) {", "-\t\t\t\t// append text to buffer realigning with the line length", "-\t\t\t\tint end = (idx > max) ? text.sourceEnd : (int) (text.separators[idx] >>> 32);", "-\t\t\t\tint nodeKind = 0; // text break", "-\t\t\t\tif (text.htmlNodesPtr >= 0 && ptr <= text.htmlNodesPtr && end > text.htmlNodes[ptr].sourceStart) {", "-\t\t\t\t\tFormatJavadocNode node = text.htmlNodes[ptr];", "-\t\t\t\t\tFormatJavadocText htmlTag = node.isText() ? (FormatJavadocText) node : null;", "-\t\t\t\t\tint newLines = htmlTag == null ? 0 : htmlTag.linesBefore;", "-\t\t\t\t\tif (linesAfter > newLines) {", "-\t\t\t\t\t\tnewLines = linesAfter;", "-\t\t\t\t\t\tif (newLines > 1 && clearBlankLines) newLines = 1;", "+\t\t\t// append text to buffer realigning with the line length", "+\t\t\tint end = (idx > max) ? text.sourceEnd : (int) (text.separators[idx] >>> 32);", "+\t\t\tint nodeKind = 0; // text break", "+\t\t\tif (text.htmlNodesPtr >= 0 && ptr <= text.htmlNodesPtr && end > text.htmlNodes[ptr].sourceStart) {", "+\t\t\t\tFormatJavadocNode node = text.htmlNodes[ptr];", "+\t\t\t\tFormatJavadocText htmlTag = node.isText() ? (FormatJavadocText) node : null;", "+\t\t\t\tint newLines = htmlTag == null ? 0 : htmlTag.linesBefore;", "+\t\t\t\tif (linesAfter > newLines) {", "+\t\t\t\t\tnewLines = linesAfter;", "+\t\t\t\t\tif (newLines > 1 && clearBlankLines) {", "+\t\t\t\t\t\tif (idx < 2 || (text.htmlIndexes[idx-2] & JAVADOC_TAGS_ID_MASK) != JAVADOC_CODE_TAGS_ID) {", "+\t\t\t\t\t\t\tnewLines = 1;", "+\t\t\t\t\t\t}", "-\t\t\t\t\tif (textStart < previousEnd) {", "-\t\t\t\t\t\taddReplaceEdit(textStart, previousEnd, buffer.toString());", "-\t\t\t\t\t}", "-\t\t\t\t\tboolean immutable = htmlTag == null ? false : htmlTag.isImmutableHtmlTag();", "-\t\t\t\t\tboolean overEndLine = false;", "+\t\t\t\t}", "+\t\t\t\tif (textStart < previousEnd) {", "+\t\t\t\t\taddReplaceEdit(textStart, previousEnd, buffer.toString());", "+\t\t\t\t}", "+\t\t\t\tboolean immutable = htmlTag == null ? false : htmlTag.isImmutableHtmlTag();", "+\t\t\t\tif (newLines == 0) {", "+\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "+\t\t\t\t}", "+\t\t\t\tint nodeStart = node.sourceStart;", "+\t\t\t\tif (newLines > 0 || (idx > 1 && nodeStart > (previousEnd+1))) {", "+\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "+\t\t\t\t}", "+\t\t\t\tif (newLines > 0) textOnNewLine = true;", "+\t\t\t\tbuffer = new StringBuffer();", "+\t\t\t\tif (node.isText()) {", "-\t\t\t\t\t\toverEndLine = (this.column + getTextLength(block, htmlTag, false)) > (this.formatter.preferences.comment_line_length+1);", "-\t\t\t\t\t\tif (overEndLine) {", "-\t\t\t\t\t\t\tif (newLines < 1) newLines = 1;", "+\t\t\t\t\t\t// do not change immutable tags, just increment column", "+\t\t\t\t\t\tif (textOnNewLine && this.commentIndentation != null) {", "+\t\t\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t\t\t    \tthis.column += this.commentIndentation.length();", "-\t\t\t\t\t}", "-\t\t\t\t\tif (newLines == 0) {", "-\t\t\t\t\t\tnewLines = printJavadocBlockNodesNewLines(block, node, previousEnd);", "-\t\t\t\t\t}", "-\t\t\t\t\tint nodeStart = node.sourceStart;", "-\t\t\t\t\tif (newLines > 0 || (idx > 1 && nodeStart > (previousEnd+1))) {", "-\t\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (newLines > 0) textOnNewLine = true;", "-\t\t\t\t\tbuffer = new StringBuffer();", "-\t\t\t\t\tif (node.isText()) {", "-\t\t\t\t\t\tif (immutable) {", "-\t\t\t\t\t\t\t// do not change immutable tags, just increment column", "-\t\t\t\t\t\t\tint additionalLength = printJavadocHtmlImmutableTag(htmlTag, block, overEndLine);", "-\t\t\t\t\t\t\tthis.column += getTextLength(block, htmlTag, true) - additionalLength;", "-\t\t\t\t\t\t\tlinesAfter = 0;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tlinesAfter = printJavadocHtmlTag(htmlTag, block, textOnNewLine);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tnodeKind = 1; // text", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tprintJavadocBlock((FormatJavadocBlock)node);", "+\t\t\t\t\t\tprintJavadocHtmlImmutableTag(htmlTag, block, textOnNewLine);", "+\t\t\t\t\t\tthis.column += getTextLength(block, htmlTag);", "-\t\t\t\t\t\tnodeKind = 2; // block", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tlinesAfter = printJavadocHtmlTag(htmlTag, block, textOnNewLine);", "-\t\t\t\t\ttextStart = node.sourceEnd+1;", "-\t\t\t\t\tptr++;", "-\t\t\t\t\tif (idx > max)  {", "-\t\t\t\t\t\treturn linesAfter;", "-\t\t\t\t\t}", "+\t\t\t\t\tnodeKind = 1; // text", "-\t\t\t\t\tif (idx > 0 && linesAfter > 0) {", "-\t\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nextStart, linesAfter, clearBlankLines, false, buffer);", "-\t\t\t\t\t\ttextOnNewLine = true;", "+\t\t\t\t\tif (textOnNewLine && this.commentIndentation != null) {", "+\t\t\t\t    \taddInsertEdit(node.sourceStart, this.commentIndentation);", "+\t\t\t\t    \tthis.column += this.commentIndentation.length();", "-\t\t\t\t\tboolean needIndentation = textOnNewLine;", "-\t\t\t\t\tif (idx > 0) {", "-\t\t\t\t\t\tif (!needIndentation && text.isTextAfterHtmlSeparatorTag(idx-1)) {", "-\t\t\t\t\t\t\tneedIndentation = true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tboolean firstText = idx==1;", "-\t\t\t\t\tif (idx > 1 && (previousEnd+1) > (nextStart-1)) {", "-\t\t\t\t\t\t// There's no space between text and html tag or inline block => do not insert space a the beginning of the text", "-\t\t\t\t\t\tfirstText = true;", "-\t\t\t\t\t}", "-\t\t\t\t\tprintJavadocTextLine(buffer, nextStart, end, block, firstText, needIndentation, idx==0/* opening html tag?*/ || text.htmlIndexes[idx-1] != -1);", "+\t\t\t\t\tprintJavadocBlock((FormatJavadocBlock)node);", "-\t\t\t\t    if (idx==0) {", "-\t\t\t\t    \tif (isHtmlSeparatorTag) {", "-\t\t\t\t\t    \tlinesAfter = 1;", "-\t\t\t\t\t    }", "-\t\t\t\t\t} else if (text.htmlIndexes[idx-1] == JAVADOC_SINGLE_BREAK_TAG_ID) {", "+\t\t\t\t\tnodeKind = 2; // block", "+\t\t\t\t}", "+\t\t\t\ttextStart = node.sourceEnd+1;", "+\t\t\t\tptr++;", "+\t\t\t\tif (idx > max)  {", "+\t\t\t\t\treturn linesAfter;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif (idx > 0 && linesAfter > 0) {", "+\t\t\t\t\tprintJavadocGapLines(previousEnd+1, nextStart, linesAfter, clearBlankLines, false, buffer);", "+\t\t\t\t\ttextOnNewLine = true;", "+\t\t\t\t}", "+\t\t\t\tboolean needIndentation = textOnNewLine;", "+\t\t\t\tif (idx > 0) {", "+\t\t\t\t\tif (!needIndentation && text.isTextAfterHtmlSeparatorTag(idx-1)) {", "+\t\t\t\t\t\tneedIndentation = true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tthis.needSpace = idx > 1 && (previousEnd+1) < nextStart; // There's no space between text and html tag or inline block => do not insert space a the beginning of the text", "+\t\t\t\tprintJavadocTextLine(buffer, nextStart, end, block, idx==0, needIndentation, idx==0/* opening html tag?*/ || text.htmlIndexes[idx-1] != -1);", "+\t\t\t\tlinesAfter = 0;", "+\t\t\t    if (idx==0) {", "+\t\t\t    \tif (isHtmlSeparatorTag) {", "-\t\t\t\t}", "+\t\t\t\t} else if (text.htmlIndexes[idx-1] == JAVADOC_SINGLE_BREAK_TAG_ID) {", "+\t\t\t    \tlinesAfter = 1;", "+\t\t\t    }", "+\t\t\t}", "-\t\t\t\t// Replace with current buffer if there are several empty lines between text lines", "-\t\t\t\tnextStart = (int) text.separators[idx];", "-\t\t\t\tint endLine = Util.getLineNumber(end, this.lineEnds, startLine-1, this.maxLines);", "-\t\t\t\tstartLine = Util.getLineNumber(nextStart, this.lineEnds, endLine-1, this.maxLines);", "-\t\t\t\tint linesGap = startLine - endLine;", "-\t\t\t\tif (linesGap > 0) {", "-\t\t\t\t\tif (clearBlankLines && linesGap > 1) {", "-\t\t\t\t\t\t// keep previously computed lines after", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (idx==0 || (idx==max && ((text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID)) || (idx < max && nodeKind==1 && (text.htmlIndexes[idx-1] & JAVADOC_TAGS_ID_MASK) != JAVADOC_IMMUTABLE_TAGS_ID)) {", "-\t\t\t\t\t\t\tif (linesAfter < linesGap) {", "-\t\t\t\t\t\t\t\tlinesAfter = linesGap;", "-\t\t\t\t\t\t\t}", "+\t\t\t// Replace with current buffer if there are several empty lines between text lines", "+\t\t\tnextStart = (int) text.separators[idx];", "+\t\t\tint endLine = Util.getLineNumber(end, this.lineEnds, startLine-1, this.maxLines);", "+\t\t\tstartLine = Util.getLineNumber(nextStart, this.lineEnds, endLine-1, this.maxLines);", "+\t\t\tint linesGap = startLine - endLine;", "+\t\t\tif (linesGap > 0) {", "+\t\t\t\tif (clearBlankLines) {", "+\t\t\t\t\t// keep previously computed lines after", "+\t\t\t\t} else {", "+\t\t\t\t\tif (idx==0 || linesGap > 1 || (idx < max && nodeKind==1 && (text.htmlIndexes[idx-1] & JAVADOC_TAGS_ID_MASK) != JAVADOC_IMMUTABLE_TAGS_ID)) {", "+\t\t\t\t\t\tif (linesAfter < linesGap) {", "+\t\t\t\t\t\t\tlinesAfter = linesGap;", "-\t\t\t\ttextOnNewLine = linesAfter > 0;", "-", "-\t\t\t\t// print <pre> tag", "-\t\t\t\tif (isCode) {", "-\t    \t\t\tint codeEnd = (int) (text.separators[max] >>> 32);", "-\t    \t\t\tif (codeEnd > end) {", "-\t    \t\t\t\tif (this.formatter.preferences.comment_format_source) {", "-\t\t\t\t\t\t\tif (textStart < end) addReplaceEdit(textStart, end, buffer.toString());", "-\t\t\t    \t\t\tprintJavadocGapLines(end+1, nextStart-1, 1, false/* never clear blank lines inside <pre> tag*/, false, null);", "-\t\t\t\t\t\t\tprintCodeSnippet(nextStart, codeEnd);", "-\t\t\t\t\t\t\tnextStart = (int) text.separators[max];", "-\t\t    \t\t\t\tprintJavadocGapLines(codeEnd+1, nextStart-1, 1, false/* never clear blank lines inside <pre> tag*/, false, null);", "-\t\t    \t\t\t\treturn 2;", "-\t    \t\t\t\t}", "-\t    \t\t\t} else {", "-\t\t\t\t\t\tnextStart = (int) text.separators[max];", "-\t\t\t\t\t\tif ((nextStart-1) > (end+1)) {", "-\t\t\t\t\t\t\tint line1 = Util.getLineNumber(end+1, this.lineEnds, startLine-1, this.maxLines);", "-\t\t\t\t\t\t\tint line2 = Util.getLineNumber(nextStart-1, this.lineEnds, line1-1, this.maxLines);", "-\t\t    \t\t\t\tint gapLines = line2-line1-1;", "-\t\t\t\t\t\t\tprintJavadocGapLines(end+1, nextStart-1, gapLines, false/* never clear blank lines inside <pre> tag*/, false, null);", "-\t\t\t\t\t\t\tif (gapLines > 0) textOnNewLine = true;", "-\t\t\t\t\t\t}", "-\t    \t\t\t}", "-\t\t\t\t\treturn 1;", "-\t\t\t\t}", "-", "-\t\t\t\t// store previous end", "-\t\t\t\tpreviousEnd = end;", "-\t    }", "+\t\t\ttextOnNewLine = linesAfter > 0;", "+", "+\t\t\t// print <pre> tag", "+\t\t\tif (isCode) {", "+    \t\t\tint codeEnd = (int) (text.separators[max] >>> 32);", "+    \t\t\tif (codeEnd > end) {", "+    \t\t\t\tif (this.formatter.preferences.comment_format_source) {", "+\t\t\t\t\t\tif (textStart < end) addReplaceEdit(textStart, end, buffer.toString());", "+\t\t\t\t\t\t// Count the lines until the exact start position of the code", "+\t\t\t\t\t\tthis.scanner.resetTo(end+1, nextStart-1);", "+\t\t\t\t\t\tint newLines = 0;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tint token = this.scanner.getNextToken();", "+\t\t\t\t\t\t\tloop: while (true) {", "+\t\t\t\t\t\t\t\tswitch (token) {", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameWHITESPACE:", "+\t\t\t\t\t\t\t\t\t\tif (CharOperation.indexOf('\\n', this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition) < 0) {", "+\t\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\tnewLines++;", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tcase TerminalTokens.TokenNameMULTIPLY:", "+\t\t\t\t\t\t\t\t\t\tnextStart = this.scanner.currentPosition + 1;", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\t\t\tbreak loop;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\ttoken = this.scanner.getNextToken();", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcatch (InvalidInputException iie) {", "+\t\t\t\t\t\t\t// skip", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (newLines == 0) newLines=1;", "+\t\t    \t\t\tprintJavadocGapLines(end+1, nextStart-1, newLines, false/* clear first blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t\t\t\t\t\tprintCodeSnippet(nextStart, codeEnd);", "+\t\t\t\t\t\tnextStart = (int) text.separators[max];", "+\t    \t\t\t\tprintJavadocGapLines(codeEnd+1, nextStart-1, 1, false/* clear blank lines inside <pre> tag as done by old formatter */, false, null);", "+\t    \t\t\t\treturn 2;", "+    \t\t\t\t}", "+    \t\t\t} else {", "+\t\t\t\t\tnextStart = (int) text.separators[max];", "+\t\t\t\t\tif ((nextStart-1) > (end+1)) {", "+\t\t\t\t\t\tint line1 = Util.getLineNumber(end+1, this.lineEnds, startLine-1, this.maxLines);", "+\t\t\t\t\t\tint line2 = Util.getLineNumber(nextStart-1, this.lineEnds, line1-1, this.maxLines);", "+\t    \t\t\t\tint gapLines = line2-line1-1;", "+\t\t\t\t\t\tprintJavadocGapLines(end+1, nextStart-1, gapLines, false/* never clear blank lines inside <pre> tag*/, false, null);", "+\t\t\t\t\t\tif (gapLines > 0) textOnNewLine = true;", "+\t\t\t\t\t}", "+    \t\t\t}", "+\t\t\t\treturn 1;", "+\t\t\t}", "+", "+\t\t\t// store previous end", "+\t\t\tpreviousEnd = end;", "+\t\t}", "-\t\t\t\ttextOnNewLine = true;", "+\t\t\t\ttextOnNewLine = linesAfter > 0;", "-\t\tboolean firstText = max <= 0 // single tag (e.g. <br>)", "-\t\t\t|| (previousEnd+1) > (nextStart-1); // There's no space between text and html tag or inline block => do not insert space a the beginning of the text", "-\t\tprintJavadocTextLine(buffer, nextStart, text.sourceEnd, block, firstText, needIndentation, closingTag/* closing html tag*/);", "+\t\tthis.needSpace = !closingTag && max > 0 // not a single or not closed tag (e.g. <br>)", "+\t\t\t&& (previousEnd+1) < nextStart; // There's no space between text and html tag or inline block => do not insert space a the beginning of the text", "+\t\tprintJavadocTextLine(buffer, nextStart, text.sourceEnd, block, max <= 0, needIndentation, closingTag/* closing html tag*/);", "-\t\tneedSpace = false;", "+\t\tthis.needSpace = false;", "-    }"]}], "num": 28479}