{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "669a24117c2fedc3a0e5e64904260fe4", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04012057cc3c55907ff6285f1baf291d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "8e2ef31cf8fd6f75aa20407e8ef5b91a95949af6", "commitAfterChange": "7b76bd109981132b10232dab12b61206fb5d8435", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 28, "signatureBeforeChange": " \tprivate synchronized List<ICompilationUnit> calculateHiddenTypes(IFile parentFile, Set<IFile> newlyGeneratedFiles, \t\t\tCompilationUnitHelper cuHelper)", "signatureAfterChange": " \t\tprivate synchronized void computeObsoleteReconcileTypes( \t\t\t\tIFile parentFile, Set<IFile> newlyGeneratedFiles,  \t\t\t\tCompilationUnitHelper cuh, \t\t\t\tList<ICompilationUnit> toSetBlank, List<ICompilationUnit> toDiscard)", "diff": ["-\t */", "-\tprivate synchronized List<ICompilationUnit> calculateHiddenTypes(IFile parentFile, Set<IFile> newlyGeneratedFiles,", "-\t\t\tCompilationUnitHelper cuHelper)", "-\t{", "-\t\tIPackageFragmentRoot root = _generatedPackageFragmentRoot.get().root;", "-\t\tList<ICompilationUnit> toSetBlank = new ArrayList<ICompilationUnit>();", "-", "-\t\t// Hide types that were generated during build and thus exist on disk.", "-\t\t// Only hide them if they have no other parents.", "-\t\tSet<IFile> generatedFromBuild = _parentToGenFiles.getValues(parentFile);", "-\t\tfor (IFile generatedFile : generatedFromBuild) {", "-\t\t\t// spare types generated in the last round", "-\t\t\tif (!newlyGeneratedFiles.contains(generatedFile)) {", "-\t\t\t\tSet<IFile> parentsOfGeneratedFile = _parentToGenFiles.getKeys(generatedFile);", "-\t\t\t\tif (parentsOfGeneratedFile.size() == 1 && parentsOfGeneratedFile.contains(parentFile)) {", "-\t\t\t\t\tICompilationUnit workingCopy = _workingCopies.get(generatedFile);", "-\t\t\t\t\tif (null != workingCopy) {", "-\t\t\t\t\t\t// move existing WC from _workingCopies to _hidden", "-\t\t\t\t\t\t_workingCopies.remove(generatedFile);", "-\t\t\t\t\t\tboolean removed = _parentToGenWorkingCopies.remove(parentFile, workingCopy);", "-\t\t\t\t\t\tassert removed : \"Working copy found in list but not in dependency map: \" + workingCopy.getElementName(); //$NON-NLS-1$", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tif (AptPlugin.DEBUG_GFM) AptPlugin.trace( ", "-\t\t\t\t\t\t\t\t\"creating blank working copy to hide type: \" + generatedFile); //$NON-NLS-1$", "-\t\t\t\t\t\tString typeName = getTypeNameForDerivedFile(generatedFile);", "-\t\t\t\t\t\tworkingCopy = cuHelper.createWorkingCopy(typeName, root);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace(", "-\t\t\t\t\t\t\t\"adding working copy to hidden types list: \" + generatedFile); //$NON-NLS-1$", "-\t\t\t\t\tassert workingCopy.isWorkingCopy() : ", "-\t\t\t\t\t\t\"Attempted to add a non-working copy to hidden types list\"; //$NON-NLS-1$", "-\t\t\t\t\t_hiddenBuiltTypes.put(generatedFile, workingCopy);", "-", "-\t\t\t\t\tICompilationUnit wc = workingCopy;", "-\t\t\t\t\ttoSetBlank.add(wc);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassert checkIntegrity();", "-\t\treturn toSetBlank;", "-\t}", "+\t\t */", "+\t\tprivate synchronized void computeObsoleteReconcileTypes(", "+\t\t\t\tIFile parentFile, Set<IFile> newlyGeneratedFiles, ", "+\t\t\t\tCompilationUnitHelper cuh,", "+\t\t\t\tList<ICompilationUnit> toSetBlank, List<ICompilationUnit> toDiscard) ", "+\t\t{", "+\t\t\t// Get types previously but no longer generated during reconcile", "+\t\t\tSet<IFile> obsoleteFiles = _reconcileDeps.getValues(parentFile);", "+\t\t\tMap<IFile, ICompilationUnit> typesToDiscard = new HashMap<IFile, ICompilationUnit>();", "+\t\t\tobsoleteFiles.removeAll(newlyGeneratedFiles);", "+\t\t\tfor (IFile obsoleteFile : obsoleteFiles) {", "+\t\t\t\t_reconcileDeps.remove(parentFile, obsoleteFile);", "+\t\t\t\tif (_reconcileDeps.getKeys(obsoleteFile).isEmpty()) {", "+\t\t\t\t\tICompilationUnit wc = _reconcileGenTypes.remove(obsoleteFile);", "+\t\t\t\t\tassert wc != null : ", "+\t\t\t\t\t\t\"Value in reconcile deps missing from reconcile type list: \" + obsoleteFile; //$NON-NLS-1$", "+\t\t\t\t\ttypesToDiscard.put(obsoleteFile, wc);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tSet<IFile> builtChildren = _buildDeps.getValues(parentFile);", "+\t\t\tbuiltChildren.removeAll(newlyGeneratedFiles);", "+\t\t\tfor (IFile builtChild : builtChildren) {", "+\t\t\t\t_reconcileNonDeps.put(parentFile, builtChild);", "+\t\t\t\t// If it's on typesToDiscard there are no other reconcile-time parents.", "+\t\t\t\t// If there are no other parents that are not masked by a nonDep entry...", "+\t\t\t\tboolean foundOtherParent = false;", "+\t\t\t\tSet<IFile> parents = _buildDeps.getKeys(builtChild);", "+\t\t\t\tparents.remove(parentFile);", "+\t\t\t\tfor (IFile otherParent : parents) {", "+\t\t\t\t\tif (!_reconcileNonDeps.containsKeyValuePair(otherParent, builtChild)) {", "+\t\t\t\t\t\tfoundOtherParent = true;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (!foundOtherParent) {", "+\t\t\t\t\tICompilationUnit wc = typesToDiscard.remove(builtChild);", "+\t\t\t\t\tif (wc == null) {", "+\t\t\t\t\t\tIPackageFragmentRoot root = _generatedPackageFragmentRoot.get().root;", "+\t\t\t\t\t\tString typeName = getTypeNameForDerivedFile(builtChild);", "+\t\t\t\t\t\twc = cuh.getWorkingCopy(typeName, root);", "+\t\t\t\t\t}", "+\t\t\t\t\t_hiddenBuiltTypes.put(builtChild, wc);", "+\t\t\t\t\ttoSetBlank.add(wc);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t", "+\t\t\t// discard any working copies that we're not setting blank", "+\t\t\ttoDiscard.addAll(typesToDiscard.values());", "+\t\t\t", "+\t\t\tassert checkIntegrity();", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7beb92d008bd7e3ac5884dae5bcd67e8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "8e2ef31cf8fd6f75aa20407e8ef5b91a95949af6", "commitAfterChange": "7b76bd109981132b10232dab12b61206fb5d8435", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 22, "signatureBeforeChange": " \tprivate synchronized boolean checkIntegrity() throws IllegalStateException", "signatureAfterChange": " \tprivate synchronized boolean checkIntegrity() throws IllegalStateException", "diff": ["-\t\tif (ENABLE_INTEGRITY_CHECKS) {", "-\t\t\t// Every working copy in the working copy dependency map should be", "-\t\t\t// in the", "-\t\t\t// _workingCopies list and should not be in the _hiddenBuiltTypes", "-\t\t\t// list.", "-\t\t\tfor (ICompilationUnit wc : _parentToGenWorkingCopies.getValueSet()) {", "-\t\t\t\tif (!_workingCopies.containsValue(wc)) {", "-\t\t\t\t\tString s = \"Dependency map contains a working copy that is not in the regular list: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\twc.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "-\t\t\t\t}", "-\t\t\t\tif (_hiddenBuiltTypes.containsValue(wc)) {", "-\t\t\t\t\tString s = \"Dependency map contains a working copy that is on the hidden list: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\twc.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "-\t\t\t\t}", "+\t\tif (!ENABLE_INTEGRITY_CHECKS) {", "+\t\t\treturn true;", "+\t\t}", "+\t\t", "+\t\t// There is a 1:1 correspondence between values in _reconcileDeps and", "+\t\t// keys in _reconcileGenTypes.", "+\t\tSet<IFile> depChildren = _reconcileDeps.getValueSet(); // copy - safe to modify", "+\t\tSet<IFile> genTypes = _reconcileGenTypes.keySet(); // not a copy!", "+\t\tList<IFile> extraFiles = new ArrayList<IFile>(); ", "+\t\tfor (IFile f : genTypes) {", "+\t\t\tif (!depChildren.remove(f)) {", "+\t\t\t\textraFiles.add(f);", "-\t\t\t// Every entry in the hidden type list should be a working copy", "-\t\t\tfor (ICompilationUnit hidden : _hiddenBuiltTypes.values()) {", "-\t\t\t\tif (!hidden.isWorkingCopy()) {", "-\t\t\t\t\tString s = \"Hidden list contains a compilation unit that is not a working copy: \" + //$NON-NLS-1$", "-\t\t\t\t\t\t\thidden.getElementName();", "-\t\t\t\t\tAptPlugin.log(new IllegalStateException(s), s);", "+\t\t}", "+\t\tif (!extraFiles.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in reconcile-generated list but not in reconcile dependency map: \", //$NON-NLS-1$", "+\t\t\t\t\textraFiles);", "+\t\t}", "+\t\tif (!depChildren.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in reconcile dependency map but not in reconcile-generated list: \", //$NON-NLS-1$", "+\t\t\t\t\tdepChildren);", "+\t\t}", "+\t\t", "+\t\t// Every key in _hiddenBuiltTypes must be a value in _reconcileNonDeps.", "+\t\tList<IFile> extraHiddenTypes = new ArrayList<IFile>();", "+\t\tfor (IFile hidden : _hiddenBuiltTypes.keySet()) {", "+\t\t\tif (!_reconcileNonDeps.containsValue(hidden)) {", "+\t\t\t\textraHiddenTypes.add(hidden);", "+\t\t\t}", "+\t\t}", "+\t\tif (!extraHiddenTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"File(s) in hidden types list but not in reconcile-obsoleted list: \", //$NON-NLS-1$", "+\t\t\t\t\textraHiddenTypes);", "+\t\t}", "+\t\t", "+\t\t// There can be no parent/child pairs that exist in both _reconcileDeps", "+\t\t// and _reconcileNonDeps.", "+\t\tMap<IFile, IFile> reconcileOverlaps = new HashMap<IFile, IFile>();", "+\t\tfor (IFile parent : _reconcileNonDeps.getKeySet()) {", "+\t\t\tfor (IFile child : _reconcileNonDeps.getValues(parent)) {", "+\t\t\t\tif (_reconcileDeps.containsKeyValuePair(parent, child)) {", "+\t\t\t\t\treconcileOverlaps.put(parent, child);", "+\t\tif (!reconcileOverlaps.isEmpty()) {", "+\t\t\tlogExtraFilePairs(\"Entries exist in both reconcile map and reconcile-obsoleted maps: \",  //$NON-NLS-1$", "+\t\t\t\t\treconcileOverlaps);", "+\t\t}", "+\t\t", "+\t\t// Every parent/child pair in _reconcileNonDeps must have a matching", "+\t\t// parent/child pair in _buildDeps.", "+\t\tMap<IFile, IFile> extraNonDeps = new HashMap<IFile, IFile>();", "+\t\tfor (IFile parent : _reconcileNonDeps.getKeySet()) {", "+\t\t\tfor (IFile child : _reconcileNonDeps.getValues(parent)) {", "+\t\t\t\tif (!_buildDeps.containsKeyValuePair(parent, child)) {", "+\t\t\t\t\textraNonDeps.put(parent, child);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (!extraNonDeps.isEmpty()) {", "+\t\t\tlogExtraFilePairs(\"Entries exist in reconcile-obsoleted map but not in build map: \", //$NON-NLS-1$", "+\t\t\t\t\textraNonDeps);", "+\t\t}", "+\t\t", "+\t\t// Values in _hiddenBuiltTypes must not be null", "+\t\tList<IFile> nullHiddenTypes = new ArrayList<IFile>();", "+\t\tfor (Map.Entry<IFile, ICompilationUnit> entry : _hiddenBuiltTypes.entrySet()) {", "+\t\t\tif (entry.getValue() == null) {", "+\t\t\t\tnullHiddenTypes.add(entry.getKey());", "+\t\t\t}", "+\t\t}", "+\t\tif (!nullHiddenTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"Null entries in hidden type list: \", nullHiddenTypes); //$NON-NLS-1$", "+\t\t}", "+\t\t", "+\t\t// Values in _reconcileGenTypes must not be null", "+\t\tList<IFile> nullReconcileTypes = new ArrayList<IFile>();", "+\t\tfor (Map.Entry<IFile, ICompilationUnit> entry : _reconcileGenTypes.entrySet()) {", "+\t\t\tif (entry.getValue() == null) {", "+\t\t\t\tnullReconcileTypes.add(entry.getKey());", "+\t\t\t}", "+\t\t}", "+\t\tif (!nullReconcileTypes.isEmpty()) {", "+\t\t\tlogExtraFiles(\"Null entries in reconcile type list: \", nullReconcileTypes); //$NON-NLS-1$", "+\t\t}", "+\t\t\t"]}], "num": 34150}