{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a113c3441074b0cc41f7c14b7ff2dc30", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f169c44d4d4d685da7380f28c340be2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "b8b8ddf64dedf8c9c31f5a6a372768428e737f63", "commitAfterChange": "4889f3babd91783f30bca6f07ba58254cecf87d1", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["-\tImportBinding[] resolvedImports = new ImportBinding[numberOfImports];", "-\tresolvedImports[0] = getDefaultImports()[0];", "-\tint index = 1;", "-", "+\tthis.tempImports = new ImportBinding[numberOfImports];", "+\tthis.tempImports[0] = getDefaultImports()[0];", "+\tthis.importPtr = 1;", "+\t", "-\t\tfor (int j = 0; j < index; j++) {", "-\t\t\tImportBinding resolved = resolvedImports[j];", "+\t\tfor (int j = 0; j < this.importPtr; j++) {", "+\t\t\tImportBinding resolved = this.tempImports[j];", "-\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, true, importBinding, importReference);", "+\t\t\trecordImportBinding(new ImportBinding(compoundName, true, importBinding, importReference));", "-\t\t\tReferenceBinding conflictingType = null;", "-\t\t\tif (importBinding instanceof MethodBinding) {", "-\t\t\t\tconflictingType = (ReferenceBinding) getType(compoundName, compoundName.length);", "-\t\t\t\tif (!conflictingType.isValidBinding() || (importReference.isStatic() && !conflictingType.isStatic()))", "-\t\t\t\t\tconflictingType = null;", "-\t\t\t}", "-\t\t\t// collisions between an imported static field & a type should be checked according to spec... but currently not by javac", "-\t\t\tif (importBinding instanceof ReferenceBinding || conflictingType != null) {", "-\t\t\t\tReferenceBinding referenceBinding = conflictingType == null ? (ReferenceBinding) importBinding : conflictingType;", "-\t\t\t\tReferenceBinding typeToCheck = referenceBinding.problemId() == ProblemReasons.Ambiguous", "-\t\t\t\t\t? ((ProblemReferenceBinding) referenceBinding).closestMatch", "-\t\t\t\t\t: referenceBinding;", "-\t\t\t\tif (importReference.isTypeUseDeprecated(typeToCheck, this))", "-\t\t\t\t\tproblemReporter().deprecatedType(typeToCheck, importReference);", "-", "-\t\t\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "-\t\t\t\tif (existingType != null) {", "-\t\t\t\t\t// duplicate test above should have caught this case, but make sure", "-\t\t\t\t\tif (existingType == referenceBinding) {", "-\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=302865", "-\t\t\t\t\t\t// Check all resolved imports to see if this import qualifies as a duplicate", "-\t\t\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t\t\tif (resolved instanceof ImportConflictBinding) {", "-\t\t\t\t\t\t\t\tImportConflictBinding importConflictBinding = (ImportConflictBinding) resolved;", "-\t\t\t\t\t\t\t\tif (importConflictBinding.conflictingTypeBinding == referenceBinding) {", "-\t\t\t\t\t\t\t\t\tif (!importReference.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\t// resolved is implicitly static", "-\t\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (resolved.resolvedImport == referenceBinding) {", "-\t\t\t\t\t\t\t\tif (importReference.isStatic() != resolved.isStatic()) {", "-\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t}", "-\t\t\t\t\t// either the type collides with a top level type or another imported type", "-\t\t\t\t\tfor (int j = 0, length = this.topLevelTypes.length; j < length; j++) {", "-\t\t\t\t\t\tif (CharOperation.equals(this.topLevelTypes[j].sourceName, existingType.sourceName)) {", "-\t\t\t\t\t\t\tproblemReporter().conflictingImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t}", "-\t\t\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], referenceBinding);", "-\t\t\t} else if (importBinding instanceof FieldBinding) {", "-\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t// find other static fields with the same name", "-\t\t\t\t\tif (resolved.isStatic() && resolved.resolvedImport instanceof FieldBinding && importBinding != resolved.resolvedImport) {", "-\t\t\t\t\t\tif (CharOperation.equals(compoundName[compoundName.length - 1], resolved.compoundName[resolved.compoundName.length - 1])) {", "-\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t// all the code here which checks for valid bindings have been moved to the method ", "+\t\t\t// checkAndRecordImportBinding() since bug 361327", "+\t\t\tif(checkAndRecordImportBinding(importBinding, typesBySimpleNames, importReference, compoundName) == -1)", "+\t\t\t\tcontinue nextImport;", "+\t\t\tif (importReference.isStatic()) {", "+\t\t\t\t// look for more static bindings being imported by single static import(bug 361327).", "+\t\t\t\t// findSingleImport() finds fields first, followed by method and then type", "+\t\t\t\t// So if a type is found, no fields and methods are available anyway", "+\t\t\t\t// similarly when method is found, type may be available but no field available for sure", "+\t\t\t\tif (importBinding.kind() == Binding.FIELD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE | Binding.METHOD, importReference);\t\t", "+\t\t\t\t} else if (importBinding.kind() == Binding.METHOD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE, importReference);", "-\t\t\tresolvedImports[index++] = conflictingType == null", "-\t\t\t\t? new ImportBinding(compoundName, false, importBinding, importReference)", "-\t\t\t\t: new ImportConflictBinding(compoundName, importBinding, conflictingType, importReference);", "-\tif (resolvedImports.length > index)", "-\t\tSystem.arraycopy(resolvedImports, 0, resolvedImports = new ImportBinding[index], 0, index);", "-\tthis.imports = resolvedImports;", "-", "+\tif (this.tempImports.length > this.importPtr)", "+\t\tSystem.arraycopy(this.tempImports, 0, this.tempImports = new ImportBinding[this.importPtr], 0, this.importPtr);", "+\tthis.imports = this.tempImports;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddc5bf54454de86ac08ebf626e157376", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "80a36bf53ae731edac012c99749b4fd073634fd5", "commitAfterChange": "775667d78092a7c5a2c35b021921f25b4037d7f4", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["+\t// keep static imports with normal imports until there is a reason to split them up", "+\t// on demand imports continue to be packages & types. need to check on demand type imports for fields/methods", "+\t// single imports change from being just types to types or fields", "-\t\tfor (int j = 0; j < index; j++)", "-\t\t\tif (resolvedImports[j].onDemand == importReference.onDemand)", "+\t\tfor (int j = 0; j < index; j++) {", "+\t\t\tif (resolvedImports[j].onDemand == importReference.onDemand) {", "-\t\tif (importReference.onDemand == true)", "+\t\t\t}", "+\t\t}", "+\t\tif (importReference.onDemand) {", "-\t\tif (importReference.onDemand) {", "-\t\t\tBinding importBinding = findOnDemandImport(compoundName);", "+", "+\t\t\tBinding importBinding = findOnDemandImport(compoundName, importReference.isStatic());", "-\t\t\tBinding typeBinding = findSingleTypeImport(compoundName);", "-\t\t\tif (!typeBinding.isValidBinding()) {", "-\t\t\t\tproblemReporter().importProblem(importReference, typeBinding);", "+\t\t\tBinding importBinding = findSingleImport(compoundName, importReference.isStatic());", "+\t\t\tif (!importBinding.isValidBinding()) {", "+\t\t\t\tproblemReporter().importProblem(importReference, importBinding);", "-\t\t\tif (typeBinding instanceof PackageBinding) {", "+\t\t\tif (importBinding instanceof PackageBinding) {", "-\t\t\tif (typeBinding instanceof ReferenceBinding) {", "-\t\t\t\tReferenceBinding referenceBinding = (ReferenceBinding) typeBinding;", "-\t\t\t\tif (importReference.isTypeUseDeprecated(referenceBinding, this)) {", "-\t\t\t\t\tproblemReporter().deprecatedType((TypeBinding) typeBinding, importReference);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "-\t\t\tif (existingType != null) {", "-\t\t\t\t// duplicate test above should have caught this case, but make sure", "-\t\t\t\tif (existingType == typeBinding) {", "+\t\t\t// collisions between an imported static field & a type should be checked according to spec... but currently not by javac", "+\t\t\tif (importBinding instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding referenceBinding = (ReferenceBinding) importBinding;", "+\t\t\t\tif (importReference.isTypeUseDeprecated(referenceBinding, this))", "+\t\t\t\t\tproblemReporter().deprecatedType(referenceBinding, importReference);", "+", "+\t\t\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "+\t\t\t\tif (existingType != null) {", "+\t\t\t\t\t// duplicate test above should have caught this case, but make sure", "+\t\t\t\t\tif (existingType == referenceBinding)", "+\t\t\t\t\t\tcontinue nextImport;", "+\t\t\t\t\t// either the type collides with a top level type or another imported type", "+\t\t\t\t\tfor (int j = 0, length = topLevelTypes.length; j < length; j++) {", "+\t\t\t\t\t\tif (CharOperation.equals(topLevelTypes[j].sourceName, existingType.sourceName)) {", "+\t\t\t\t\t\t\tproblemReporter().conflictingImport(importReference);", "+\t\t\t\t\t\t\tcontinue nextImport;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t// either the type collides with a top level type or another imported type", "-\t\t\t\tfor (int j = 0, length = topLevelTypes.length; j < length; j++) {", "-\t\t\t\t\tif (CharOperation.equals(topLevelTypes[j].sourceName, existingType.sourceName)) {", "-\t\t\t\t\t\tproblemReporter().conflictingImport(importReference);", "-\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\tcontinue nextImport;", "+\t\t\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], referenceBinding);", "-\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, typeBinding, importReference);", "-\t\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], (ReferenceBinding) typeBinding);", "+\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\tif (!binding.onDemand)", "+\t\tif (!binding.onDemand && binding.resolvedImport instanceof ReferenceBinding)"]}], "num": 29506}