{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f14d5ca187ef95bad4fb8e9241e74106", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34a00c39319a769368a4988075485eff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "3fa398907bc325a632b9517a054fc223461325fb", "commitAfterChange": "4e3d522e86b4dbde916017a602e046903b89c502", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tprivate Set<InferenceVariable> getSmallestVariableSet(BoundSet bounds, InferenceVariable[] subSet)", "signatureAfterChange": " \tprivate Set<InferenceVariable> getSmallestVariableSet(BoundSet bounds, InferenceVariable[] subSet)", "diff": ["+\t\t// \"Given a set of inference variables to resolve, let V be the union of this set and", "+\t\t//  all variables upon which the resolution of at least one variable in this set depends.\" ", "+\t\tSet<InferenceVariable> v = new HashSet<InferenceVariable>();", "+\t\tMap<InferenceVariable,Set<InferenceVariable>> dependencies = new HashMap<>(); // compute only once, store for the final loop over 'v'.", "+\t\tfor (InferenceVariable iv : subSet) {", "+\t\t\tSet<InferenceVariable> tmp = new HashSet<>();", "+\t\t\taddDependencies(bounds, tmp, iv);", "+\t\t\tdependencies.put(iv, tmp);", "+\t\t\tv.addAll(tmp);", "+\t\t}", "+\t\t// \"If every variable in V has an instantiation, then resolution succeeds and this procedure terminates.\"", "+\t\t//  -> (implicit if result remains unassigned)", "+\t\t// \"Otherwise, let { \u03b11, ..., \u03b1n } be a non-empty subset of uninstantiated variables in V such that ...", "-\t\tfor (int i = 0; i < subSet.length; i++) {", "-\t\t\tInferenceVariable currentVariable = subSet[i];", "+\t\t// \"i) for all i (1 \u2264 i \u2264 n), ...\"", "+\t\tfor (InferenceVariable currentVariable : v) {", "-\t\t\t\tSet<InferenceVariable> set = new HashSet<InferenceVariable>();", "-\t\t\t\tif (!addDependencies(bounds, set, currentVariable, min))", "-\t\t\t\t\tcontinue;", "+\t\t\t\t// \"... if \u03b1i depends on the resolution of a variable \u03b2, then either \u03b2 has an instantiation or there is some j such that \u03b2 = \u03b1j; ...\"", "+\t\t\t\tSet<InferenceVariable> set = dependencies.get(currentVariable);", "+\t\t\t\tif (set == null) // not an element of the original subSet, still need to fetch this var's dependencies", "+\t\t\t\t\taddDependencies(bounds, set = new HashSet<>(), currentVariable);", "+\t\t\t\t//  \"... and ii) there exists no non-empty proper subset of { \u03b11, ..., \u03b1n } with this property.\""]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5758c1541ded61590ccafd4da40fe2ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "e447d89530bf9d3a43064d5916817ebccc4e6812", "commitAfterChange": "b9b3b8c1fedf5d6daa213336839897b001a3416e", "methodNumberBeforeChange": 46, "methodNumberAfterChange": 46, "signatureBeforeChange": "  \tprivate Set<ConstraintFormula> findBottomSet(Set<ConstraintFormula> constraints, Set<InferenceVariable> allOutputVariables)", "signatureAfterChange": "  \tprivate Set<ConstraintFormula> findBottomSet(Set<ConstraintFormula> constraints, Set<InferenceVariable> allOutputVariables)", "diff": ["-\t\t// 18.5.2 bullet 6.1", "-\t\t//  A subset of constraints is selected, satisfying the property", "-\t\t// that, for each constraint, no input variable depends on an", "-\t\t// output variable of another constraint in C ...", "+\t\t// 18.5.2 bullet 5.(1)", "+\t\t//  A subset of constraints is selected, satisfying the property that,", "+\t\t//  for each constraint, no input variable can influence an output variable of another constraint in C. ...", "+\t\t//  An inference variable \u03b1 can influence an inference variable \u03b2 if \u03b1 depends on the resolution of \u03b2 (\u00a718.4), or vice versa;", "+\t\t//  or if there exists a third inference variable \u03b3 such that \u03b1 can influence \u03b3 and \u03b3 can influence \u03b2.  ...", "+\t\t// TODO: is indirect influence respected?", "-\t\tIterator<ConstraintFormula> it = constraints.iterator();", "-\t\tconstraintLoop: while (it.hasNext()) {", "-\t\t\tConstraintFormula constraint = it.next();", "-\t\t\tIterator<InferenceVariable> inputIt = constraint.inputVariables(this).iterator();", "-\t\t\tIterator<InferenceVariable> outputIt = allOutputVariables.iterator();", "-\t\t\twhile (inputIt.hasNext()) {", "-\t\t\t\tInferenceVariable in = inputIt.next();", "-\t\t\t\tif (allOutputVariables.contains(in)) // not explicit in the spec, but let's assume any inference variable depends on itself", "-\t\t\t\t\tcontinue constraintLoop;", "-\t\t\t\twhile (outputIt.hasNext()) {", "-\t\t\t\t\tif (this.currentBounds.dependsOnResolutionOf(in, outputIt.next()))", "+\t  constraintLoop:", "+\t\tfor (ConstraintFormula constraint : constraints) {", "+\t\t\tfor (InferenceVariable in : constraint.inputVariables(this)) {", "+\t\t\t\tfor (InferenceVariable out : allOutputVariables) {", "+\t\t\t\t\tif (this.currentBounds.dependsOnResolutionOf(in, out) || this.currentBounds.dependsOnResolutionOf(out, in))"]}], "num": 15518}