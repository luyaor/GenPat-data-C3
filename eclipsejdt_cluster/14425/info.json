{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0af74510be72486e024fef5aa40e87be", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "651bf8e1c57144a22e21ad7004013073", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/AbstractImageBuilder.java", "commitBeforeChange": "4e88e1625bb1c2659a2ee4ba931e466f5126f9f4", "commitAfterChange": "075da32620f3ceb13a370a8be8550de2baf091f1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r \r public void acceptResult(CompilationResult result)", "signatureAfterChange": "\r \r public void acceptResult(CompilationResult result)", "diff": ["-\tString location = new String(result.getFileName()); // the full filesystem path 'd:/xyz/eclipse/Test/p1/p2/A.java'\r", "-\tif (!workQueue.isCompiled(location)) {\r", "+\t// only need to find resource for the sourceLocation when problems need to be reported against it\r", "+\tString sourceLocation = new String(result.getFileName()); // the full filesystem path \"d:/xyz/eclipse/src1/Test/p1/p2/A.java\"\r", "+\tif (!workQueue.isCompiled(sourceLocation)) {\r", "-\t\t\tworkQueue.finished(location);\r", "-\t\r", "+\t\t\tworkQueue.finished(sourceLocation);\r", "+\t\t\tupdateProblemsFor(sourceLocation, result); // record compilation problems before potentially adding duplicate errors\r", "+\r", "-\t\t\tArrayList otherTypeNames = new ArrayList(length);\r", "-\t\t\tchar[] mainTypeName = compilationUnit.getMainTypeName(); // may not match any produced class file\r", "+\t\t\tArrayList duplicateTypeNames = null;\r", "+\t\t\tArrayList definedTypeNames = new ArrayList(length);\r", "-\t\t\t\tif (CharOperation.equals(mainTypeName, typeName)) {\r", "-\t\t\t\t\twriteClassFile(classFile, false);\r", "+\t\t\t\tboolean isNestedType = CharOperation.contains('$', typeName);\r", "+\r", "+\t\t\t\t// Look for a possible collision, if one exists, report an error but do not write the class file\r", "+\t\t\t\tif (isNestedType) {\r", "+\t\t\t\t\tString qualifiedTypeName = new String(classFile.outerMostEnclosingClassFile().fileName());\r", "+\t\t\t\t\tif (newState.isDuplicateLocation(qualifiedTypeName, sourceLocation))\r", "+\t\t\t\t\t\tcontinue;\r", "-\t\t\t\t\tboolean isSecondaryType = !CharOperation.contains('$', typeName);\r", "-\t\t\t\t\totherTypeNames.add(writeClassFile(classFile, isSecondaryType));\r", "+\t\t\t\t\tString qualifiedTypeName = new String(classFile.fileName()); // the qualified type name \"p1/p2/A\"\r", "+\t\t\t\t\tif (newState.isDuplicateLocation(qualifiedTypeName, sourceLocation)) {\r", "+\t\t\t\t\t\tif (duplicateTypeNames == null)\r", "+\t\t\t\t\t\t\tduplicateTypeNames = new ArrayList();\r", "+\t\t\t\t\t\tduplicateTypeNames.add(compoundName);\r", "+\t\t\t\t\t\tcreateErrorFor(resourceForLocation(sourceLocation), Util.bind(\"build.duplicateClassFile\", new String(typeName)));\r", "+\t\t\t\t\t\tcontinue;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tnewState.locationForType(qualifiedTypeName, sourceLocation);\r", "+\t\t\t\tdefinedTypeNames.add(writeClassFile(classFile, !isNestedType));\r", "-\t\t\tupdateProblemsFor(result);\r", "-\t\t\tif (otherTypeNames.isEmpty()) {\r", "-\t\t\t\tfinishedWith(location, result, new char[0][]);\r", "-\t\t\t} else {\r", "-\t\t\t\tchar[][] additionalTypeNames = new char[otherTypeNames.size()][];\r", "-\t\t\t\totherTypeNames.toArray(additionalTypeNames);\r", "-\t\t\t\tfinishedWith(location, result, additionalTypeNames);\r", "-\t\t\t}\r", "+\r", "+\t\t\tfinishedWith(sourceLocation, result, compilationUnit.getMainTypeName(), definedTypeNames, duplicateTypeNames);\r", "-\t\t\ttry {\r", "-\t\t\t\t// add another problem to the compilation unit that its class file is inconsistent\r", "-\t\t\t\tIResource resource = javaBuilder.workspaceRoot.getFileForLocation(new Path(location));\r", "-\t\t\t\tIMarker marker = resource.createMarker(ProblemMarkerTag);\r", "-\t\t\t\tmarker.setAttribute(IMarker.MESSAGE, Util.bind(\"build.inconsistentClassFile\"));\r", "-\t\t\t\tmarker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);\r", "-\t\t\t} catch (CoreException ignore) {\r", "-\t\t\t\tthrow internalException(e);\r", "-\t\t\t}\r", "+\t\t\tcreateErrorFor(resourceForLocation(sourceLocation), Util.bind(\"build.inconsistentClassFile\"));\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d0c875b7c3ffd454f3319afe41d5a828", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "dbb21f9a082cc8b4fc9a756e4b7778384b3f408c", "commitAfterChange": "bbd2ac48b173a123c7419ce013244d878b152c22", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 17, "signatureBeforeChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator)", "signatureAfterChange": "  String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator)", "diff": ["-String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator) {", "-\tTextEdit edit = codeFormatter.format(kind, source, offset, length, indentationLevel, lineSeparator);//$NON-NLS-1$", "-\tif (edit == null) return null;", "-\tString result = org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);", "-\tif (COMPARE == null && length == source.length()) {", "-\t\tString previousResult = result;", "-\t\twhile (count++ < FORMAT_REPEAT) {", "-\t\t\tedit = codeFormatter.format(kind, result, 0, result.length(), indentationLevel, lineSeparator);//$NON-NLS-1$", "-\t\t\tif (edit == null) return null;", "-\t\t\tpreviousResult = result;", "-\t\t\tresult = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);", "+", "+String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator) {", "+\tTextEdit edit = codeFormatter.format(kind, source, offset, length, indentationLevel, lineSeparator);//$NON-NLS-1$", "+\ttry {", "+\t\tassertNotNull(\"Formatted source should not be null!\", edit);", "+\t}", "+\tcatch (ComparisonFailure cf) {", "+\t\tthis.failureIndex = NO_OUTPUT_FAILURE;", "+//\t\tFAILURES[NO_OUTPUT_FAILURE].failures.add(this.path);", "+\t\tthrow cf;", "+\t}", "+\tcatch (AssertionFailedError afe) {", "+\t\tthis.failureIndex = NO_OUTPUT_FAILURE;", "+//\t\tFAILURES[NO_OUTPUT_FAILURE].failures.add(this.path);", "+\t\tthrow afe;", "+\t}", "+\tString initialResult = org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);", "+", "+\tint count = 1;", "+\tString result = initialResult;", "+\tString previousResult = result;", "+\twhile (count++ < FORMAT_REPEAT) {", "+\t\tedit = codeFormatter.format(kind, result, 0, result.length(), indentationLevel, lineSeparator);//$NON-NLS-1$", "+\t\tif (edit == null) return null;", "+\t\tpreviousResult = result;", "+\t\tresult = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);", "+\t}", "+\tif (!previousResult.equals(result)) {", "+", "+\t\t// Try to compare without leading spaces", "+\t\tString trimmedExpected = ModelTestsUtil.trimLinesLeadingWhitespaces(previousResult);", "+\t\tString trimmedActual= ModelTestsUtil.trimLinesLeadingWhitespaces(result);", "+\t\tif (trimmedExpected.equals(trimmedActual)) {", "+\t\t\tthis.failureIndex = REFORMATTING_LEADING_FAILURE;", "+\t\t\tFAILURES[REFORMATTING_LEADING_FAILURE].failures.add(this.path);", "+\t\t\tthis.hasSpaceFailure = true;", "+\t\t\treturn initialResult;", "-\t\tif (!previousResult.equals(result)) {", "-\t\t\tswitch (IGNORE_SPACES) {", "-\t\t\t\tcase ALL_SPACES:", "-\t\t\t\t\tString trimmedExpected = ModelTestsUtil.removeWhiteSpace(previousResult);", "-\t\t\t\t\tString trimmedActual= ModelTestsUtil.removeWhiteSpace(result);", "-\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "-\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "-\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\treturn previousResult;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tcase LINES_LEADING_SPACES:", "-\t\t\t\t\ttrimmedExpected = ModelTestsUtil.trimLinesLeadingWhitespaces(previousResult);", "-\t\t\t\t\ttrimmedActual= ModelTestsUtil.trimLinesLeadingWhitespaces(result);", "-\t\t\t\t\tif (trimmedExpected.equals(trimmedActual)) {", "-\t\t\t\t\t\tthis.leadingWhitespacesFailures.add(this.path);", "-\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\treturn previousResult;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (ModelTestsUtil.removeWhiteSpace(previousResult).equals(ModelTestsUtil.removeWhiteSpace(result))) {", "-\t\t\t\t\t\tthis.whitespacesFailures.add(this.path);", "-\t\t\t\t\t\tthis.hasSpaceFailure = true;", "-\t\t\t\t\t\treturn previousResult;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "+\t\t", "+\t\t// Try to compare without spaces at all", "+\t\tif (ModelTestsUtil.removeWhiteSpace(previousResult).equals(ModelTestsUtil.removeWhiteSpace(result))) {", "+\t\t\tthis.failureIndex = REFORMATTING_WHITESPACES_FAILURE;", "+\t\t\tFAILURES[REFORMATTING_WHITESPACES_FAILURE].failures.add(this.path);", "+\t\t\tthis.hasSpaceFailure = true;", "+\t\t\treturn initialResult;", "+\t\t}", "+", "+\t\t/*", "+\t\t// Try to see if the formatting also fails without comments", "+\t\tif (!runFormatterWithoutComments(null, source, kind, indentationLevel, offset, length, lineSeparator)) {", "+\t\t\treturn initialResult;", "+\t\t}", "+", "+\t\t// format without comments is OK => there's a problem with comment formatting", "+\t\tString counterString = counterToString(count-1);", "+\t\tassertSourceEquals(counterString+\" formatting is different from first one!\", previousResult, result);", "+\t\t*/", "+\t\tif (!isExpectedFailure()) {", "+\t\t\tString counterString = counterToString(count-1);", "+\t\t\ttry {", "+\t\t\t\tassertSourceEquals(counterString+\" formatting is different from first one!\", previousResult, result);", "-\t\t\tif (!isExpectedFailure()) {", "-\t\t\t\tString counterString = counterToString(count-1);", "-\t\t\t\tassertSourceEquals(counterString+\" formatting is different from first one!\", Util.convertToIndependantLineDelimiter(previousResult), Util.convertToIndependantLineDelimiter(result));", "+\t\t\tcatch (ComparisonFailure cf) {", "+\t\t\t\tthis.failureIndex = REFORMATTING_FAILURE;", "+//\t\t\t\tFAILURES[REFORMATTING_FAILURE].failures.add(this.path);", "+\t\t\t\tthrow cf;", "-\t\t\tresult = previousResult;", "+\t\t\tcatch (AssertionFailedError afe) {", "+\t\t\t\tthis.failureIndex = REFORMATTING_FAILURE;", "+//\t\t\t\tFAILURES[REFORMATTING_FAILURE].failures.add(this.path);", "+\t\t\t\tthrow afe;", "+\t\t\t}", "-\treturn result;", "+\treturn initialResult;"]}], "num": 14425}