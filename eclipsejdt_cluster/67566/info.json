{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "92ccfdbd6e02db962206d0641e74657a", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2069e19665c3610ba9c3b8a5094f9375", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java", "commitBeforeChange": "7d879fb1ebcea4aeee6c7768254a09d17ebfe5f5", "commitAfterChange": "c2646812d22906feca88c2f52911ca7c4eae2299", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tprivate Properties readConfig(String filename)", "signatureAfterChange": " \tprivate Properties readConfig(String filename)", "diff": ["+\t\tFile configFile = new File(filename);", "-\t\t\tstream = new BufferedInputStream(new FileInputStream(new File(filename)));", "+\t\t\tstream = new BufferedInputStream(new FileInputStream(configFile));", "-\t\t\tUtil.log(e, Messages.bind(Messages.ConfigFileReadingError));", "+\t\t\tString canonicalPath = null;", "+\t\t\ttry {", "+\t\t\t\tcanonicalPath = configFile.getCanonicalPath();", "+\t\t\t} catch(IOException e2) {", "+\t\t\t\tcanonicalPath = configFile.getAbsolutePath();", "+\t\t\t}", "+\t\t\tString errorMessage;", "+\t\t\tif (!configFile.exists() && !configFile.isAbsolute()) {", "+\t\t\t\terrorMessage = Messages.bind(Messages.ConfigFileNotFoundErrorTryFullPath, new Object[] {", "+\t\t\t\t\tcanonicalPath,", "+\t\t\t\t\tSystem.getProperty(\"user.dir\") //$NON-NLS-1$", "+\t\t\t\t});", "+", "+\t\t\t} else {", "+\t\t\t\terrorMessage = Messages.bind(Messages.ConfigFileReadingError, canonicalPath);", "+\t\t\t}", "+\t\t\tUtil.log(e, errorMessage);", "+\t\t\tSystem.err.println(errorMessage);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d1c2d3d17346e6ac70d0b8da4ee7624", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/FilerImpl.java", "commitBeforeChange": "72643ddaac52d3ea6e2573fbe40b9af5d9586d1e", "commitAfterChange": "965ee55c83771df9f7f21b38b9a78903a86f630d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "signatureAfterChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "diff": ["-        throw new UnsupportedOperationException( \"Not Yet Implemented\");", "+\t\t// TODO: figure out what to do with the loc ", "+\t\t// Filer.Location.CLASS_TREE vs Filer.Location.SOURCE_TREE       ", "+\t\tFile f = new File(\".\");", "+", "+        if( pkg != null )", "+            f = new File( f, pkg.replace('.', File.separatorChar) );", "+", "+        f = new File( f, relPath.getPath() );", "+", "+        // REVIEW: for no apparent reason it is sometimes necessary to create the", "+        // parent dir, else an IOException occurs creating f..", "+        File p = f.getParentFile();", "+        FileSystemUtil.mkdirs( p );", "+        return charsetName == null ? new PrintWriter( f ) : new PrintWriter( f, charsetName );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5ba9b24e6d03f583b287cd2fdcfe93d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/FilerImpl.java", "commitBeforeChange": "fa2cb5bc47f7fe5d18ae109d09f3bf4ba668083f", "commitAfterChange": "3ba9d90cc0b0b979098ff6ad3236612052718a0b", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "signatureAfterChange": "     public PrintWriter createTextFile(Filer.Location loc, String pkg, File relPath, String charsetName)          throws IOException", "diff": ["-\t\t// TODO: figure out what to do with the loc ", "-\t\t// Filer.Location.CLASS_TREE vs Filer.Location.SOURCE_TREE       ", "-\t\tFile f = new File(\".\");", "+    \t// TODO - clean this up", "+    \tFile f = null;", "+    \tGeneratedFileManager gfm = GeneratedFileManager.getGeneratedFileManager( _env.getProject() );", "+    \tif ( loc == Filer.Location.CLASS_TREE )", "+    \t{", "+    \t\ttry ", "+    \t\t{", "+    \t\t\tf = gfm.getGeneratedOutputFile( _env.getJavaProject() );", "+    \t\t}", "+    \t\tcatch ( Exception e )", "+    \t\t{", "+    \t\t\t// TODO - stop throwing this exception", "+    \t\t\te.printStackTrace();", "+    \t\t\tthrow new IOException();", "+    \t\t}", "+    \t}", "+    \telse if ( loc == Filer.Location.SOURCE_TREE )", "+    \t\tf = gfm.getGeneratedSourceFolder().getRawLocation().toFile();", "+    \t\t\t", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77b6f1f39399b8ce5a3d173c9218182e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "ef0604aef9ae504bcfc77425341e6baf6891cd21", "commitAfterChange": "b16439228426b14cb0612ff6650bc46c3d9f2a61", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      public static ProcessorEnvImpl newProcessorEnvironmentForBuild( IFile file, IJavaProject javaProj )", "signatureAfterChange": "      public static ProcessorEnvImpl newProcessorEnvironmentForBuild( IFile file, IJavaProject javaProj )", "diff": ["-    \treturn new ProcessorEnvImpl( null /*ICompilationUnit*/, file, javaProj, Phase.BUILD );", "+    \tchar[] source = null;", "+\t\ttry{", "+\t\t\tsource = getFileContents( file );", "+\t\t}", "+\t\tcatch( Exception e ){", "+\t\t\t// TODO:  propagate these exceptions out of APTDispatch", "+\t\t\te.printStackTrace();", "+\t\t}\t\t", "+\t\tString unitName = file.getProjectRelativePath().toString();", "+\t\tASTNode node = createDietAST( unitName, javaProj, null, source );", "+    \treturn new ProcessorEnvImpl((org.eclipse.jdt.core.dom.CompilationUnit)node, ", "+    \t\t\t  \t\t\t\t\tnull /*ICompilationUnit*/, ", "+    \t\t\t\t\t\t\t    source, file, javaProj, Phase.BUILD );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888ee47ff2f8725975e9ac826a7f88dc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "372799d5bd955eabbf1069fe0bbf8aba8ea8af85", "commitAfterChange": "baf433f0226e8b9036b18a28d560e5a42cb8b949", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "      public static ProcessorEnvImpl newProcessorEnvironmentForBuild( IFile file, IJavaProject javaProj )", "signatureAfterChange": "             public static ProcessorEnvImpl newProcessorEnvironmentForBuild(IFile[] files, IJavaProject javaProj )", "diff": ["-", "-    public static ProcessorEnvImpl newProcessorEnvironmentForBuild( IFile file, IJavaProject javaProj )", "+    ", "+    public static ProcessorEnvImpl newProcessorEnvironmentForBuild(IFile[] files, IJavaProject javaProj )", "-    \tchar[] source = null;", "-\t\ttry{", "-\t\t\tsource = getFileContents( file );", "-\t\t}", "-\t\tcatch( Exception e ){", "-\t\t\t// TODO:  propagate these exceptions out of APTDispatch", "-\t\t\te.printStackTrace();", "-\t\t}\t\t", "-\t\tString unitName = file.getProjectRelativePath().toString();", "-\t\tASTNode node = createDietAST( unitName, javaProj, null, source );", "-    \treturn new ProcessorEnvImpl((org.eclipse.jdt.core.dom.CompilationUnit)node, ", "-    \t\t\t  \t\t\t\t\tnull /*ICompilationUnit*/, ", "-    \t\t\t\t\t\t\t    source, file, javaProj, Phase.BUILD );", "+    \tassert files != null : \"missing files\"; //$NON-NLS-1$    \t", "+    ", "+\t\t// note, we are not reading any files.", "+\t\treturn new ProcessorEnvImpl(files, javaProj, Phase.BUILD);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c5b0c26944c89e25a046098b785552ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "76b281521e0c88d7bc9fbeb2c963d7e6c8914ee3", "commitAfterChange": "e4873234bb7d47f3f866e994a2466da3b0ee585f", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method)", "signatureAfterChange": " MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method)", "diff": ["-\tpublic /*@NonNull*/ MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method) {", "+\t/*@NonNull*/ MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method) {", "-\t\tParameterizedGenericMethodBinding finalMethod = method;", "+\t\tParameterizedGenericMethodBinding finalMethod = null;", "-\t\t\tfinalMethod = getInvocationTypeInferenceSolution(method.originalMethod, invocation, targetType);", "+\t\t\tMethodBinding original = method.originalMethod;", "+\t\t\t// start over from a previous candidate but discard its type variable instantiations", "+\t\t\t// TODO: should we retain any instantiations of type variables not owned by the method? ", "+\t\t\tBoundSet result = null;", "+\t\t\ttry {", "+\t\t\t\tresult = inferInvocationType(this.currentBounds, targetType, invocation, original);", "+\t\t\t} catch (InferenceFailureException e) {", "+\t\t\t\t// no solution, but do more checks below", "+\t\t\t}", "+\t\t\tif (result != null) {", "+\t\t\t\tTypeBinding[] solutions = getSolutions(original.typeVariables(), invocation, result);", "+\t\t\t\tif (solutions != null) {", "+\t\t\t\t\tfinalMethod = this.environment.createParameterizedGenericMethod(original, solutions);", "+\t\t\t\t\tinvocation.registerInferenceContext(finalMethod, this);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfinalMethod = method;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d87cae2c6ea4676b9df82f3c8092fb28", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/FilerImpl.java", "commitBeforeChange": "64db8d36b73417ee83ea1a6d91baaefe7d3848b0", "commitAfterChange": "706bf7889f5a9b55b080bd919d03ab5ee97600fa", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "     public OutputStream createClassFile(String name) throws IOException", "signatureAfterChange": "     public OutputStream createClassFile(String name) throws IOException", "diff": ["-        throw new UnsupportedOperationException( \"Not Yet Implemented\" ); //$NON-NLS-1$", "+    \tGeneratedFileManager gfm = GeneratedFileManager.getGeneratedFileManager( _env.getProject() );", "+    \tFile f = null;", "+    \t", "+    \ttry ", "+    \t{", "+    \t\tf = gfm.getGeneratedSourceFolderOutputLocation();", "+    \t}", "+    \tcatch ( Exception e )", "+    \t{", "+    \t\t// TODO - stop throwing this exception", "+    \t\tAptPlugin.log(e, \"Failure getting the output file\"); //$NON-NLS-1$", "+    \t\tthrow new IOException();", "+    \t}", "+    \t", "+    \tf = new File( f, name.replace( '.', File.separatorChar ) + \".class\" ); //$NON-NLS-1$", "+  ", "+        // REVIEW: for no apparent reason it is sometimes necessary to create the", "+        // parent dir, else an IOException occurs creating f..", "+        File p = f.getParentFile();", "+        FileSystemUtil.mkdirs( p );", "+    \t", "+        return new FileOutputStream( f );"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e6625f830dfd4a069a1fc95f951d18b9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptUtil.java", "commitBeforeChange": "9378f12e46617b3c47a50827083b7b76b76aaf96", "commitAfterChange": "ecc05f0ca2665c6c46b18bc8153f342d2808fcb6", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic static boolean hasAnnotationInstance( IFile f )", "signatureAfterChange": " \tpublic static boolean hasAnnotationInstance( IFile f )", "diff": ["-\tpublic static boolean hasAnnotationInstance( IFile f )", "-\t{", "-\t\ttry", "-\t\t{", "-\t\t\tchar[] source = ProcessorEnvImpl.getFileContents( f );", "-\t\t\treturn hasAnnotationInstance( source );", "+\tpublic static boolean hasAnnotationInstance( IFile f ) {", "+\t\t", "+\t\tInputStreamReader reader = null;", "+\t\tInputStream input = null;", "+\t\ttry {", "+\t\t\tAnnotationScanner scanner;", "+\t\t\t// If this is a single byte encoding, we can deal directly ", "+\t\t\t// with the bytes, which is *much* faster", "+\t\t\tif (SINGLE_BYTE_ENCODINGS.contains(f.getCharset())) {", "+\t\t\t\tinput = ProcessorEnvImpl.getInputStream(f);", "+\t\t\t\tscanner = new InputStreamAnnotationScanner(input);", "+\t\t\t}", "+\t\t\telse {", "+\t\t\t\treader = ProcessorEnvImpl.getFileReader( f );", "+\t\t\t\tscanner = new ReaderAnnotationScanner(reader);", "+\t\t\t}", "+\t\t\treturn scanner.containsAnnotations();", "-\t\tcatch( Exception ioe )", "-\t\t{", "+\t\tcatch( Exception ioe ) {", "+\t\t}", "+\t\tfinally {", "+\t\t\tif (reader != null) { try {reader.close();} catch (IOException ioe) {} }", "+\t\t\tif (input != null) { try {input.close();} catch (IOException ioe) {} }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f076eaafcc5eedd9838c37f06d996eb6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java", "commitBeforeChange": "7d879fb1ebcea4aeee6c7768254a09d17ebfe5f5", "commitAfterChange": "c2646812d22906feca88c2f52911ca7c4eae2299", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tprivate File[] processCommandLine(String[] argsArray)", "signatureAfterChange": "  \tprivate File[] processCommandLine(String[] argsArray)", "diff": ["-\t\t\t\t\t\tdisplayHelp(Messages.bind(Messages.CommandLineErrorFile, currentArg));", "+\t\t\t\t\t\tString canonicalPath;", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tcanonicalPath = file.getCanonicalPath();", "+\t\t\t\t\t\t} catch(IOException e2) {", "+\t\t\t\t\t\t\tcanonicalPath = file.getAbsolutePath();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tString errorMsg = file.isAbsolute()?", "+\t\t\t\t\t\t\t\t\t\t  Messages.bind(Messages.CommandLineErrorFile, canonicalPath):", "+\t\t\t\t\t\t\t\t\t\t  Messages.bind(Messages.CommandLineErrorFileTryFullPath, canonicalPath);", "+\t\t\t\t\t\tdisplayHelp(errorMsg);"]}], "num": 67566}