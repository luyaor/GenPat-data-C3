{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f38e7751d1cd065757cb08cea8f29f83", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8bac8d78631f220ec6e61a9c4fddb7fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "bea7b508525f70d680963772996546f2bcf8018f", "commitAfterChange": "6612336f81825afdf894aa053e2e886c83842e87", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t\t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t\t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\t\t\tcopy.resolveType(this.enclosingScope);", "-", "+\t\t\t\tthis.hasIgnoredMandatoryErrors = false;", "+\t\t\t\tTypeBinding type = copy.resolveType(this.enclosingScope);", "-\t\t\t", "-\t\t\t\t\tif (!this.returnsVoid) {", "-\t\t\t\t\t\tthis.valueCompatible = copy.doesNotCompleteNormally();", "+\t\t\t\t\tif (this.returnsVoid) {", "+\t\t\t\t\t\tthis.shapeAnalysisComplete = true;", "+\t\t\t\t\tthis.shapeAnalysisComplete = true;", "-\t\t\t", "-\t\t\t} finally {", "+\t\t\t\t// Do not proceed with data/control flow analysis if resolve encountered errors.", "+\t\t\t\tif (type == null || !type.isValidBinding() || this.hasIgnoredMandatoryErrors) {", "+\t\t\t\t\tif (!isPertinentToApplicability(left))", "+\t\t\t\t\t\treturn true;", "+\t\t\t\t\treturn this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\t// value compatibility of block lambda's is the only open question.", "+\t\t\t\tif (!this.shapeAnalysisComplete)", "+\t\t\t\t\tthis.valueCompatible = copy.doesNotCompleteNormally();", "+\t\t\t\t", "+\t\t\t} finally {", "+\t\t\t\tthis.hasIgnoredMandatoryErrors = false;", "+\t\tif (!isPertinentToApplicability(left))", "+\t\t\treturn true;", "+\t", "-\t\tif (!isPertinentToApplicability())", "-\t\t\treturn true;", "-\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ae97b5a323217b7a9817f9857594bc00", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "a0e794820a3e45ac013c44e55b82e935802d5378", "commitAfterChange": "a06fd70a66cd192fe200df3baf9406d9e87b6313", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 32, "signatureBeforeChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "signatureAfterChange": " \t \tpublic boolean isCompatibleWith(final TypeBinding left, final Scope someScope)", "diff": ["-\t\t", "-\t\tfinal MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);", "-\t\t", "-\t\tif (sam == null || !sam.isValidBinding())", "+\t\tif (!(left instanceof ReferenceBinding))", "-\t\tif (sam.parameters.length != this.arguments.length)", "-\t\t\treturn false;", "-\t\t", "-\t\tif (!this.shapeAnalysisComplete) {", "+", "+\t\tshapeAnalysis: if (!this.shapeAnalysisComplete) {", "-\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "-\t\t\t\t\t\t\tif (!this.voidCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!this.valueCompatible)", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t}", "+// FIXME: we don't yet have the same, should we compute it here & now?", "+//\t\t\t\t\t\tif (sam.returnType.id == TypeIds.T_void) {", "+//\t\t\t\t\t\t\tif (!this.voidCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t} else {", "+//\t\t\t\t\t\t\tif (!this.valueCompatible)", "+//\t\t\t\t\t\t\t\treturn false;", "+//\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\treturn this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\tbreak shapeAnalysis;", "+\t\t\t\t\tif (this.arguments.length != 0) // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.", "+\t\t\t\t\t\treturn false;", "+\t\t\t\t\tbreak shapeAnalysis;", "+\t\tReferenceBinding groundTargetType = findGroundTargetType(this.enclosingScope, (ReferenceBinding) left, argumentsTypeElided());", "+\t\tif (groundTargetType == null)", "+\t\t\treturn false;", "+\t\t", "+\t\tMethodBinding sam = groundTargetType.getSingleAbstractMethod(this.enclosingScope, true);", "+\t\tif (sam == null || !sam.isValidBinding())", "+\t\t\treturn false;", "+\t\tif (sam.parameters.length != this.arguments.length)", "+\t\t\treturn false;", "+"]}], "num": 24565}