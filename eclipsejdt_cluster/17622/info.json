{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2bc048e9343d6201bd4aa8439c6387f9", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "390eb4aa2c1fb73608e7704db3e7b8f3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "f0baa4687c4b232261eab4264c1bc16ee1b49e9d", "commitAfterChange": "c3cfcbf3735a569bd82b9e06ea31c818736eb0c6", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tprivate boolean doesNotCompleteNormally()", "signatureAfterChange": "  \tprivate boolean doesNotCompleteNormally()", "diff": ["-\t\t\tthis.scope.problemReporter().lambdaShapeComputationError(this);", "-\t\t\treturn this.valueCompatible;", "+\t\t\t/* See https://bugs.eclipse.org/bugs/show_bug.cgi?id=432110 for an example of where the flow analysis can result in run time error.", "+\t\t\t   We can recover and do the right thing by falling back on the results of the structural analysis done already and be right 99.99%", "+\t\t\t   of the time. Strictly speaking void/value compatibility is not a structural property. { throw NPE(); } is value compatible despite", "+\t\t\t   structurally there not being a return statement. Likewise { if (x) return value; } is not value compatible despite there being a", "+\t\t\t   return statement. We will miss the former case, but that is mostly pedantic. We would misclassify the latter case *here*, but it", "+\t\t\t   would be caught elsewhere, so it should all wash out in the end. ", "+\t\t\t*/ ", "+\t\t\treturn this.original.valueCompatible;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "671b7ea813930570d0f90345e77120c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "72398fb1bfc9de8f8d1c235c08849e28d61cb9f4", "commitAfterChange": "a52f17f8883dd812875c341ff752527a9011d961", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tprivate boolean doesNotCompleteNormally()", "signatureAfterChange": "  \tprivate void analyzeExceptions()", "diff": ["-\tprivate boolean doesNotCompleteNormally() {", "+\tprivate void analyzeExceptions() {", "-\t\t\treturn this.body.analyseCode(this.scope, ", "+\t\t\tthis.body.analyseCode(this.scope, ", "-\t\t\t\t\t\t\t\t\t UnconditionalFlowInfo.fakeInitializedFlowInfo(this.scope.outerMostMethodScope().analysisIndex, this.scope.referenceType().maxFieldCount)) == FlowInfo.DEAD_END;", "-\t\t} catch (RuntimeException e) {", "-\t\t\t/* See https://bugs.eclipse.org/bugs/show_bug.cgi?id=432110 for an example of where the flow analysis can result in run time error.", "-\t\t\t   We can recover and do the right thing by falling back on the results of the structural analysis done already and be right 99.99%", "-\t\t\t   of the time. Strictly speaking void/value compatibility is not a structural property. { throw NPE(); } is value compatible despite", "-\t\t\t   structurally there not being a return statement. Likewise { if (x) return value; } is not value compatible despite there being a", "-\t\t\t   return statement. We will miss the former case, but that is mostly pedantic. We would misclassify the latter case *here*, but it", "-\t\t\t   would be caught elsewhere, so it should all wash out in the end. ", "-\t\t\t*/ ", "-\t\t\treturn this.valueCompatible;", "+\t\t\t\t\t\t\t\t\t UnconditionalFlowInfo.fakeInitializedFlowInfo(this.scope.outerMostMethodScope().analysisIndex, this.scope.referenceType().maxFieldCount));", "+\t\t} catch (Exception e) {", "+\t\t\t// drop silently."]}], "num": 17622}