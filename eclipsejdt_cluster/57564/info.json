{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4971272d53008293fe0860c25ac35eac", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2037cfeb32ada5604283176305383201", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "a02dc2635b15c289c546ca96a49f66d7180ade17", "commitAfterChange": "efe1773a267b3bdb803164d9b413b69c3685878f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 11, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tif (isDiamond && !diamondNeedsDeferring) {", "+\tResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, polyExpressionSeen, argumentTypes);", "+\tif (diamondNeedsDeferring) {", "+\t\tthis.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).", "+\t\treturn new PolyTypeBinding(this);", "+\t}", "+", "+\tif (!resolvePart2(state))", "+\t\treturn null;", "+\treturn resolvePart3(state);", "+}", "-\t\tTypeBinding [] inferredTypes = inferElidedTypes(genericType, genericType.enclosingType(), argumentTypes, scope);", "-\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "-\t\t\treturn this.resolvedType = null;", "-\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "-\tif (diamondNeedsDeferring) {", "-\t\t// in this preliminary mode use the raw receiver type for constructor lookup, to avoid spurious type errors", "-\t\treceiverType = (ReferenceBinding) receiverType.original();", "-\t\treceiverType = scope.environment().createRawType(receiverType, receiverType.enclosingType());", "-\t}", "-\t", "-\tthis.binding = findConstructorBinding(scope, this, receiverType, argumentTypes, polyExpressionSeen);", "-\t\tscope.problemReporter().invalidConstructor(this, this.binding);", "-\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "-\tif (isMethodUseDeprecated(this.binding, scope, true))", "-\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "-\tif (!diamondNeedsDeferring) { // don't check diamonds before we have the target type", "-\t\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {", "-\t\t\tthis.bits |= ASTNode.Unchecked;", "-\t\t}", "-\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);", "-\tif (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {", "- \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), argumentTypes, scope);", "-\t\tnew ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)", "-\t\t\t\t.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);", "-\tif (diamondNeedsDeferring)", "-\t\treturn new PolyTypeBinding(this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "77be66d9a0fa6c3cf85090d9c32a4900", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java", "commitBeforeChange": "a6c016e4b9174d429d2989715c74cf56e42ef6bb", "commitAfterChange": "c9f804b2e84f02e4cfe425f0463c67be2149642c", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope)", "diff": ["+\t    Binding binding = scope.getPackage(this.tokens);", "+\t    if (binding != null && !binding.isValidBinding()) {", "+\t    \tthis.resolvedType = (ReferenceBinding) binding;", "+\t\t\treportInvalidType(scope);", "+\t\t\treturn null;", "+\t\t}", "+", "+\t    PackageBinding packageBinding = binding == null ? null : (PackageBinding) binding;", "-\t\tfor (int i = 0, max = this.tokens.length; i < max; i++) {", "-\t\t    ReferenceBinding currentType;", "-\t\t    if (i == 0) {", "-\t\t        // isolate first fragment", "-\t\t\t\twhile (this.typeArguments[i] == null) i++;", "-\t\t\t\ttry {", "-\t\t\t\t\tthis.resolvedType = scope.getType(this.tokens, i+1);", "-\t\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t\te.updateContext(this, scope.referenceCompilationUnit().compilationResult);", "-\t\t\t\t\tthrow e;", "-\t\t\t\t}", "-\t\t\t\tif (!(this.resolvedType.isValidBinding())) {", "-\t\t\t\t\treportInvalidType(scope);", "-\t\t\t\t\treturn null;", "-\t\t\t\t}", "-\t\t\t\tcurrentType = (ReferenceBinding) this.resolvedType;", "-\t\t\t\tif (currentType.isMemberType()) { // check raw enclosing type", "-\t\t\t\t    ArrayList enclosingTypes = new ArrayList();", "-\t\t\t\t    boolean hasGenericEnclosing = false;", "-\t\t\t\t    for (ReferenceBinding enclosing = currentType.enclosingType(); enclosing != null; enclosing = enclosing.enclosingType()) {", "-\t\t\t\t        enclosingTypes.add(enclosing);", "-\t\t\t\t        if (enclosing.isGenericType()) hasGenericEnclosing = true;", "-\t\t\t\t    }", "-\t\t\t\t    if (hasGenericEnclosing) {", "-\t\t\t\t        for (int j = enclosingTypes.size() - 1; j >= 0; j--) {", "-\t\t\t\t            ReferenceBinding enclosing = (ReferenceBinding)enclosingTypes.get(j);", "-\t\t\t\t            if (enclosing.isGenericType()) {", "-\t\t\t\t\t            qualifiedType = scope.environment().createRawType(enclosing, qualifiedType); // raw type", "-\t\t\t\t            }", "-\t\t\t\t        }", "-\t\t\t\t    }", "-\t\t\t\t}", "-\t\t    } else {", "-\t\t\t    this.resolvedType = currentType = scope.getMemberType(this.tokens[i], (ReferenceBinding)qualifiedType.erasure());", "-\t\t\t\tif (!(this.resolvedType.isValidBinding())) {", "-\t\t\t\t\treportInvalidType(scope);", "-\t\t\t\t\treturn null;", "-\t\t\t\t}", "-\t\t    }", "-\t\t    // check generic and arity", "+\t\tfor (int i = packageBinding == null ? 0 : packageBinding.compoundName.length, max = this.tokens.length; i < max; i++) {", "+\t\t\tfindNextTypeBinding(i, scope, packageBinding);", "+\t\t\tif (!(this.resolvedType.isValidBinding())) {", "+\t\t\t\treportInvalidType(scope);", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tReferenceBinding currentType = (ReferenceBinding) this.resolvedType;", "+", "+\t\t\t// check generic and arity", "-\t\t\t\t}\t\t\t", "-\t\t\t\tParameterizedTypeBinding parameterizedType = scope.createParameterizedType(currentType, argTypes, qualifiedType);", "-\t\t\t\t// check argument type compatibility", "-\t\t\t\tfor (int j = 0; j < argLength; j++) {", "-\t\t\t\t    TypeBinding argType = argTypes[j];", "-\t\t\t\t    if (!typeVariables[j].boundCheck(parameterizedType, argType)) {", "-\t\t\t\t\t\tscope.problemReporter().typeMismatchError(argType, typeVariables[j], currentType, args[j]);", "-\t\t\t\t    }", "+\t\t\t\tParameterizedTypeBinding parameterizedType = scope.createParameterizedType(currentType, argTypes, qualifiedType);", "+\t\t\t\t// check argument type compatibility now if not a class scope", "+\t\t\t\tif (!isClassScope) // otherwise will do it in Scope.connectTypeVariables()", "+\t\t\t\t\tfor (int j = 0; j < argLength; j++)", "+\t\t\t\t\t    if (!typeVariables[j].boundCheck(parameterizedType, argTypes[j]))", "+\t\t\t\t\t\t\tscope.problemReporter().typeMismatchError(argTypes[j], typeVariables[j], currentType, args[j]);", "+", "-\t\tif (isTypeUseDeprecated(this.resolvedType, scope)) {", "+\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t}\t\t", "-\t\t\tif (dimensions > 255) {", "+\t\t\tif (dimensions > 255)", "-\t\t\t}"]}], "num": 57564}