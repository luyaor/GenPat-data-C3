{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "75dadab0e477e76e02d5696b57218bd2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7259ace44e5efbe227cd39cd1751889b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModifyingResourceTests.java", "commitBeforeChange": "12bbec9151d1b613c62f44289e9e604128f21de0", "commitAfterChange": "cfad6931331ca38f2461ad24853dd9b6dfa652de", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 26, "signatureBeforeChange": " protected IClasspathEntry[] createClasspath(String[] foldersAndPatterns, boolean hasInclusionPatterns, boolean hasExclusionPatterns)", "signatureAfterChange": " protected IClasspathEntry[] createClasspath(String projectName, String[] foldersAndPatterns)", "diff": ["-\treturn createClasspath(null, foldersAndPatterns, hasInclusionPatterns, hasExclusionPatterns);", "-}", "+ */", "+protected IClasspathEntry[] createClasspath(String projectName, String[] foldersAndPatterns) {", "+\tint length = foldersAndPatterns.length;", "+\tIClasspathEntry[] classpath = new IClasspathEntry[length/2];", "+\tfor (int i = 0; i < length; i+=2) {", "+\t\tString src = foldersAndPatterns[i];", "+\t\tString patterns = foldersAndPatterns[i+1];", "+\t\tStringTokenizer tokenizer = new StringTokenizer(patterns, \"|\");", "+\t\tint ruleCount =  tokenizer.countTokens();", "+\t\tIAccessRule[] accessRules = new IAccessRule[ruleCount];", "+\t\tint nonAccessibleRules = 0;", "+\t\tfor (int j = 0; j < ruleCount; j++) {", "+\t\t\tString rule = tokenizer.nextToken();", "+\t\t\tint kind;", "+\t\t\tif (rule.charAt(0) == '+') {", "+\t\t\t\tkind = IAccessRule.K_ACCESSIBLE;", "+\t\t\t} else {", "+\t\t\t\tkind = IAccessRule.K_NON_ACCESSIBLE;", "+\t\t\t\tnonAccessibleRules++;", "+\t\t\t}", "+\t\t\taccessRules[j] = JavaCore.newAccessRule(new Path(rule.substring(1)), kind);", "+\t\t}", "+", "+\t\tIPath folderPath = new Path(src);", "+\t\t\tclasspath[i/2] = JavaCore.newProjectEntry(folderPath, accessRules, true/*combine access restrictions*/, new IClasspathAttribute[0], false); ", "+\t\t\tIPath[] accessibleFiles = new IPath[ruleCount-nonAccessibleRules];", "+\t\t\tint accessibleIndex = 0;", "+\t\t\tIPath[] nonAccessibleFiles = new IPath[nonAccessibleRules];", "+\t\t\tint nonAccessibleIndex = 0;", "+\t\t\tfor (int j = 0; j < ruleCount; j++) {", "+\t\t\t\tIAccessRule accessRule = accessRules[i];", "+\t\t\t\tif (accessRule.getKind() == IAccessRule.K_ACCESSIBLE) ", "+\t\t\t\t\taccessibleFiles[accessibleIndex++] = accessRule.getPattern();", "+\t\t\t\telse", "+\t\t\t\t\tnonAccessibleFiles[nonAccessibleIndex++] = accessRule.getPattern();", "+\t\t\t}", "+\t\t\tclasspath[i/2] = JavaCore.newSourceEntry(folderPath, accessibleFiles, nonAccessibleFiles, null); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c88b4bc22f572c8a478b0ac739aacefb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "f8e06af2d64912de617f742baa744d8cff14ca39", "commitAfterChange": "799bcf90c7e5ed6ce45339b7f5c6f4ecccd1d29c", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 68, "signatureBeforeChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope)", "signatureAfterChange": " \tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards)", "diff": ["-\tpublic MethodBinding getSingleAbstractMethod(final Scope scope) {", "+\tpublic MethodBinding getSingleAbstractMethod(final Scope scope, boolean replaceWildcards) {", "-\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope);", "+\t\tMethodBinding theAbstractMethod = genericType.getSingleAbstractMethod(scope, true);", "-\t\t\tswitch (typeArgument.kind()) {", "-\t\t\t\tcase Binding.WILDCARD_TYPE :", "-\t\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "-\t\t\t\t\tswitch(wildcard.boundKind) {", "-\t    \t\t\t\tcase Wildcard.EXTENDS :", "-\t    \t\t\t\tcase Wildcard.SUPER :", "-\t    \t\t\t\t\ttypes[i] = wildcard.bound;", "-\t    \t\t\t\t\tbreak;", "-\t    \t\t\t\tcase Wildcard.UNBOUND :", "-\t    \t\t\t\t\t// if Pi has upper bound Bi that mentions none of P1...Pn, then Ti = Bi; otherwise, Ti = Object", "-\t    \t\t\t\t\tfinal TypeBinding upperBound = typeParameters[i].firstBound;", "-\t\t\t\t\t\t\tif (upperBound == null || typeParametersMentioned(upperBound)) {", "-\t    \t\t\t\t\t\ttypes[i] = scope.getJavaLangObject();", "-\t    \t\t\t\t\t} else {", "-\t    \t\t\t\t\t\ttypes[i] = upperBound;", "-\t    \t\t\t\t\t}", "-\t    \t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbreak;", "-\t\t\t\tdefault :", "-\t\t\t\t\ttypes[i] = typeArgument;", "-\t\t\t\t\tbreak;", "+\t\t\tif (replaceWildcards && typeArgument.kind() == Binding.WILDCARD_TYPE) {", "+\t\t\t\tif (typeParameters[i].mentionsAny(typeParameters, i))", "+\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t\t\tWildcardBinding wildcard = (WildcardBinding) typeArgument;", "+\t\t\t\tswitch(wildcard.boundKind) {", "+    \t\t\t\tcase Wildcard.EXTENDS :", "+    \t\t\t\t\t// If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi).", "+    \t\t\t\t\t// Note: neither Ui nor Bi is necessarily scalar -> need to collect all bounds", "+    \t\t\t\t\tTypeBinding[] otherUBounds = wildcard.otherBounds;", "+    \t\t\t\t\tTypeBinding[] otherBBounds = typeParameters[i].otherUpperBounds();", "+    \t\t\t\t\tint len = 2 + (otherUBounds != null ? otherUBounds.length : 0) + otherBBounds.length;", "+    \t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[len];", "+    \t\t\t\t\ttry {", "+    \t\t\t\t\t\tint idx = 0;", "+    \t\t\t\t\t\t// Ui", "+\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) wildcard.bound;", "+\t    \t\t\t\t\tif (otherUBounds != null)", "+\t    \t\t\t\t\t\tfor (int j = 0; j < otherUBounds.length; j++)", "+\t    \t\t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherUBounds[j];", "+\t    \t\t\t\t\t// Bi", "+\t    \t\t\t\t\tallBounds[idx++] = (ReferenceBinding) typeParameters[i].firstBound;", "+\t    \t\t\t\t\tfor (int j = 0; j < otherBBounds.length; j++)", "+\t    \t\t\t\t\t\tallBounds[idx++] = (ReferenceBinding) otherBBounds[j];", "+    \t\t\t\t\t} catch (ClassCastException cce) {", "+    \t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);\t\t    \t\t\t\t\t\t", "+    \t\t\t\t\t}", "+    \t\t\t\t\tReferenceBinding[] glb = Scope.greaterLowerBound(allBounds);", "+    \t\t\t\t\tif (glb == null || glb.length == 0) {", "+\t\t\t\t\t\t\treturn this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);", "+\t\t\t\t\t\t} else if (glb.length == 1) {", "+\t\t\t\t\t\t\ttypes[i] = glb[0];", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\ttypes[i] = new IntersectionCastTypeBinding(glb, this.environment);", "+\t\t\t\t\t\t}", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.SUPER :", "+    \t\t\t\t\t// If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.", "+    \t\t\t\t\ttypes[i] = wildcard.bound;", "+    \t\t\t\t\tbreak;", "+    \t\t\t\tcase Wildcard.UNBOUND :", "+    \t\t\t\t\t// If Ai is an unbound wildcard ?, then Ti = Bi.", "+    \t\t\t\t\ttypes[i] = typeParameters[i].firstBound;", "+    \t\t\t\t\tif (types[i] == null)", "+    \t\t\t\t\t\ttypes[i] = typeParameters[i].superclass; // assumably j.l.Object?", "+    \t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// If Ai is a type, then Ti = Ai.", "+\t\t\t\ttypes[i] = typeArgument;"]}], "num": 26653}