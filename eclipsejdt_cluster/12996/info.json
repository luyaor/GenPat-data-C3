{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ef0e48c6c70c56b36c7a5977a21f85e9", "detectedBy": ["DIFF_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2ef3cadc3ffd2e6d8fa02987d95186ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "74ceca813d8e9be557353622cfb1779e5fa562ad", "commitAfterChange": "2d7d544af40c78aee4e80de194acd385e8eab51a", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  void checkForNameClash(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " void checkForNameClash(MethodBinding currentMethod, MethodBinding inheritedMethod)", "diff": ["-", "-\t// AND", "-\t// AND", "+", "-\t// AND", "+", "+", "+\t//\t\tclass A<T extends Number> { void m(T t) {} }", "+\t//\t\tclass B<S extends Integer> extends A<S> { void m(S t) {}}", "+\t//\t\tclass D extends B<Integer> { void m(Number t) {}    void m(Integer t) {} }", "+", "+\t//\t\tinheritedMethods does not include I.test since A has a valid implementation", "+\t//\t\tinterface I<E extends Comparable<E>> { void test(E element); }", "+\t//\t\tclass A implements I<Integer> { public void test(Integer i) {} }", "+\t//\t\tclass B extends A { public void test(Comparable i) {} }", "-\t\tReferenceBinding superType = this.type.superclass;", "+\t\tReferenceBinding superType = inheritedMethod.declaringClass;", "+\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "+\t\t\tif (++lastPosition == interfacesToVisit.length)", "+\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "+\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t}", "+\t\tsuperType = superType.superclass(); // now start with its superclass", "-\t\t\t\tif (!areMethodsEqual(currentMethod, methods[m]) && detectNameClash(currentMethod, methods[m]))", "-\t\t\t\t\treturn;", "+\t\t\t\tif (currentMethod.parameters.length == methods[m].parameters.length)", "+\t\t\t\t\tif (!areMethodsEqual(currentMethod, methods[m]) && detectNameClash(currentMethod, methods[m]))", "+\t\t\t\t\t\treturn;", "-\t\t\t\t\t\tif (!areMethodsEqual(currentMethod, methods[m]) && detectNameClash(currentMethod, methods[m]))", "-\t\t\t\t\t\t\treturn;", "+\t\t\t\t\t\tif (currentMethod.parameters.length == methods[m].parameters.length)", "+\t\t\t\t\t\t\tif (!areMethodsEqual(currentMethod, methods[m]) && detectNameClash(currentMethod, methods[m]))", "+\t\t\t\t\t\t\t\treturn;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "315e7d313dad72b9efb973a4f3f5047d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java", "commitBeforeChange": "6be587f49a9f62a35713ce06be3fdf4f0c161640", "commitAfterChange": "894663e867a34e5217db27a8dfc161181560b6ca", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public ReferenceBinding findSuperTypeErasingTo(ReferenceBinding erasure)", "signatureAfterChange": " public ReferenceBinding findSuperTypeErasingTo(int erasureId, boolean erasureIsClass)", "diff": ["+ */", "+public ReferenceBinding findSuperTypeErasingTo(int erasureId, boolean erasureIsClass) {", "+    if (erasure().id == erasureId) return this;", "+    ReferenceBinding currentType = this;", "+    // iterate superclass to avoid recording interfaces if searched supertype is class", "+    if (erasureIsClass) {", "+\t\twhile ((currentType = currentType.superclass()) != null) { ", "+\t\t\tif (currentType.erasure().id == erasureId) return currentType;", "+\t\t}    ", "+\t\treturn null;", "+    }", "+\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];", "+\tint lastPosition = -1;", "+\tdo {", "+\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "+\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\tif (++lastPosition == interfacesToVisit.length)", "+\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "+\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t}", "+\t} while ((currentType = currentType.superclass()) != null);", "+\t\t\t", "+\tfor (int i = 0; i <= lastPosition; i++) {", "+\t\tReferenceBinding[] interfaces = interfacesToVisit[i];", "+\t\tfor (int j = 0, length = interfaces.length; j < length; j++) {", "+\t\t\tif ((currentType = interfaces[j]).erasure().id == erasureId)", "+\t\t\t\treturn currentType;", "+", "+\t\t\tReferenceBinding[] itsInterfaces = currentType.superInterfaces();", "+\t\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "+\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "+\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn null;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "690f0126855d2ddddc75b86d818c64e9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "eaf0108cc4594b9874621f7838e6b5fcab99f228", "commitAfterChange": "505b0db16406f11df3227a34e8e784faefbd6e90", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 9, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];", "-\tint lastPosition = 0;", "-\tinterfacesToVisit[lastPosition] = type.superInterfaces();", "+\tReferenceBinding[][] interfacesToVisit = new ReferenceBinding[3][];", "+\tint lastPosition = -1;", "+\tReferenceBinding[] itsInterfaces = type.superInterfaces();", "+\tif (itsInterfaces != NoSuperInterfaces)", "+\t\tinterfacesToVisit[++lastPosition] = itsInterfaces;", "-\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();", "-\t\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "-\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) { // look at all methods which are NOT private or constructors or default abstract", "+\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) {", "-\t\t\t\t\t\t\tif (areTypesEqual(method.returnType, nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\t\t\t\t&& CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "+\t\t\t\t\t\t\t\t&& areTypesEqual(method.returnType, nonVisibleDefaultMethods[i].returnType)", "-\t\t\t\t\tif (!(method.isDefault() && method.declaringClass.fPackage != type.fPackage)) { // ignore methods which have default visibility and are NOT defined in another package", "+\t\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\tReferenceBinding[] itsInterfaces = superType.superInterfaces();", "-\t\t\t\t\tif (itsInterfaces != NoSuperInterfaces) {", "+\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {"]}], "num": 12996}