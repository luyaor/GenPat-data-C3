{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "af16416c7068021936212b2c58c4deb5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a39170762c5982053d7079f5f12785d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "38f73e89bd4606189d7e6d499593d5aa49ab247d", "commitAfterChange": "83b83ec335a27590393034d86f94208edbfcc45a", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\tfor (int level = 0; level <= VARARGS_COMPATIBLE; level++) {", "+\t\tfor (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {", "+\t\t\t\t\tmax = level; // do not examine further categories", "-\t\t\t\t\t} else if (method.isStatic()) {", "-\t\t\t\t\t\t// detect collision between static import methods from unconnected types", "-\t\t\t\t\t\tif (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))", "-\t\t\t\t\t\t\tif (method.declaringClass.findSuperTypeWithSameErasure(method2.declaringClass) == null)", "+\t\t\t\t\t}", "+", "+\t\t\t\t\tif (method == method2) continue; // interfaces may be walked twice from different paths", "+", "+\t\t\t\t\t// see if method & method2 are duplicates due to the current substitution or multiple static imported methods", "+\t\t\t\t\tif (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {", "+\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "+\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "+", "+\t\t\t\t\t\tMethodBinding original = method.original();", "+\t\t\t\t\t\tif (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (superType == null) {", "+\t\t\t\t\t\t\t\t// accept concrete methods over abstract methods found due to the default abstract method walk", "+\t\t\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "+\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t} else if (!method.original().areTypeVariableErasuresEqual(method2.original())) {", "-\t\t\t\t\t\t// cannot override an inherited method if type variables are not compatible", "-\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t} else if (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract()) { // must both be abstract or concrete, not one of each", "-\t\t\t\t\t\tif (method.areParametersEqual(method2)) {", "-\t\t\t\t\t\t\t// its possible with 2 methods that one does not inherit from the other", "-\t\t\t\t\t\t\t// need to find their methods from the receiver type", "-\t\t\t\t\t\t\t// see cases in verify test #43", "-\t\t\t\t\t\t\tMethodBinding original = method.original();", "-\t\t\t\t\t\t\tMethodBinding original2 = method2.original();", "-\t\t\t\t\t\t\tif (original.areParameterErasuresEqual(original2)) continue;", "-\t\t\t\t\t\t\tReferenceBinding receiverType = (ReferenceBinding) ((MessageSend) invocationSite).actualReceiverType;", "-\t\t\t\t\t\t\tif (receiverType != method.declaringClass) {", "-\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeWithSameErasure(original.declaringClass);", "-\t\t\t\t\t\t\t\tif (superType != null) {", "-\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original.selector);", "-\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "-\t\t\t\t\t\t\t\t\t\t\toriginal = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tMethodBinding inheritedMethod = method2;", "+\t\t\t\t\t\t\tMethodBinding inheritedOriginal = method2.original();", "+\t\t\t\t\t\t\tif (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == inheritedOriginal) {", "+\t\t\t\t\t\t\t\t\t\tinheritedMethod = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\tif (receiverType != method2.declaringClass) {", "-\t\t\t\t\t\t\t\tReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeWithSameErasure(original2.declaringClass);", "-\t\t\t\t\t\t\t\tif (superType != null) {", "-\t\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(original2.selector);", "-\t\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "-\t\t\t\t\t\t\t\t\t\t\toriginal2 = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (!original.areParametersEqual(original2))", "-\t\t\t\t\t\t\t\tcontinue nextVisible; // cannot be substituted from 2 different type variables", "+\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables)", "+\t\t\t\t\t\t\t\tinheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());", "+\t\t\t\t\t\t\tif (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))", "+\t\t\t\t\t\t\t\tbreak nextVisible; // dup thru substitution, not overridden... cannot find possible match", "+\t\t\t\t\t\t\t// method overrides method2, accept it", "+\t\t\t\t\t\t} else if (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (superType == null)", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // static methods from unrelated types"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3094ae1ed229befa97e6528a441dc10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "cb102deeeb30ec755d64a8d266f5423000dc4f4e", "commitAfterChange": "f18746495477338a9b83fca4f673d973bc3b28e9", "methodNumberBeforeChange": 72, "methodNumberAfterChange": 73, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType)", "diff": ["-\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {", "+\tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {", "+\t\tbyte[] skipValues = new byte[visibleSize]; // tagged with -1 if method cannot be best match", "-\t\t\t\tif (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now", "-\t\t\t\tMethodBinding method = visible[i];", "-\t\t\t\tTypeBinding[] params = method.tiebreakMethod().parameters;", "+\t\t\t\tif (compatibilityLevels[i] != level || skipValues[i] == -1) continue nextVisible; // skip this method for now", "+\t\t\t\tMethodBinding original = visible[i].original();", "+\t\t\t\tMethodBinding method = visible[i].tiebreakMethod();", "-\t\t\t\t\tMethodBinding method2 = visible[j];", "-\t\t\t\t\t// tiebreak generic methods using variant where type params are substituted by their erasures", "-\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {", "-\t\t\t\t\t\tif (method.isVarargs() && method2.isVarargs()) {", "-\t\t\t\t\t\t\t// check the non-vararg parameters", "-\t\t\t\t\t\t\tint paramLength = params.length;", "-\t\t\t\t\t\t\tTypeBinding[] params2 = method2.tiebreakMethod().parameters;", "-\t\t\t\t\t\t\tif (paramLength != params2.length)", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\tfor (int p = paramLength - 2; p >= 0; p--)", "-\t\t\t\t\t\t\t\tif (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))", "-\t\t\t\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding original2 = visible[j].original();", "+\t\t\t\t\tif (original == original2)", "+\t\t\t\t\t\tcontinue; // parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\tif (params[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\tMethodBinding method2 = visible[j].tiebreakMethod();", "+\t\t\t\t\tif (!isMoreSpecificMethod(method, method2)) {", "+\t\t\t\t\t\tif (!isMoreSpecificMethod(method2, method))", "+\t\t\t\t\t\t\tskipValues[j] = -1; // no point checking method2 either", "+\t\t\t\t\t\tcontinue nextVisible; // method2 is a better match", "-\t\t\t\t\t// parameterized superclasses & interfaces may be walked twice from different paths", "-\t\t\t\t\tif (method.original() == method2.original()) continue;", "-", "-\t\t\t\t\t// see if method & method2 are duplicates due to the current substitution or multiple static imported methods", "-\t\t\t\t\tif (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {", "-\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "-\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "-", "-\t\t\t\t\t\tMethodBinding original = method.original();", "-\t\t\t\t\t\tif (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {", "-\t\t\t\t\t\t\tReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();", "-\t\t\t\t\t\t\tReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "-\t\t\t\t\t\t\tif (superType == null) {", "-\t\t\t\t\t\t\t\t// accept concrete methods over abstract methods found due to the default abstract method walk", "-\t\t\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\tcontinue nextVisible;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMethodBinding inheritedMethod = method2;", "-\t\t\t\t\t\t\tMethodBinding inheritedOriginal = method2.original();", "-\t\t\t\t\t\t\tif (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables", "-\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);", "-\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "-\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == inheritedOriginal) {", "-\t\t\t\t\t\t\t\t\t\tinheritedMethod = superMethods[m];", "-\t\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables)", "-\t\t\t\t\t\t\t\tinheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());", "-\t\t\t\t\t\t\tif (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))", "-\t\t\t\t\t\t\t\tbreak nextVisible; // dup thru substitution, not overridden... cannot find possible match", "-\t\t\t\t\t\t\t// method overrides method2, accept it", "-\t\t\t\t\t\t} else if (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\tif (method.areParametersEqual(method2)) {", "+\t\t\t\t\t\tif (method.isStatic() && method2.isStatic()) {", "+\t\t\t\t\t\t\t// if you knew that method overrode method2, it would help", "+\t\t\t\t\t\tif (original == method && original2 == method2)", "+\t\t\t\t\t\t\tcontinue; // no need to check further", "+\t\t\t\t\t\tif (!method.isAbstract() && method2.isAbstract())", "+\t\t\t\t\t\t\tcontinue; // 15.12.2, concrete method beats abstract method", "+\t\t\t\t\t\tif (method.declaringClass == method2.declaringClass)", "+\t\t\t\t\t\t\tcontinue nextVisible; // duplicates thru substitution", "+", "+\t\t\t\t\t\tif (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract() && receiverType != null) {", "+\t\t\t\t\t\t\t// class A<T> { void foo(T t) {} }", "+\t\t\t\t\t\t\t// class B<T, S> extends A<S> { void foo(T t) {} }", "+\t\t\t\t\t\t\treceiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();", "+\t\t\t\t\t\t\tReferenceBinding superType = receiverType.findSuperTypeWithSameErasure(method.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod = original;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original) {", "+\t\t\t\t\t\t\t\t\t\tmethod = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tsuperType = receiverType.findSuperTypeWithSameErasure(method2.declaringClass.erasure());", "+\t\t\t\t\t\t\tif (original2.declaringClass == superType || superType == null) {", "+\t\t\t\t\t\t\t\tmethod2 = original2;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t// must find inherited method with the same substituted variables", "+\t\t\t\t\t\t\t\tMethodBinding[] superMethods = superType.getMethods(method2.selector);", "+\t\t\t\t\t\t\t\tfor (int m = 0, l = superMethods.length; m < l; m++) {", "+\t\t\t\t\t\t\t\t\tif (superMethods[m].original() == original2) {", "+\t\t\t\t\t\t\t\t\t\tmethod2 = superMethods[m];", "+\t\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables)", "+\t\t\t\t\t\t\t\tmethod2 = method.computeSubstitutedMethod(method2, environment());", "+\t\t\t\t\t\t\tif (method2 == null || !method.areParametersEqual(method2)) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // dup thru substitution, not overridden... cannot find possible match", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// method overrides method2, accept it", "+\t\t\t\t\t\t} else if (!original.areTypeVariableErasuresEqual(original2)) {", "+\t\t\t\t\t\t\tif (original.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\t\tskipValues[j] = -1;", "+\t\t\t\t\t\t\t\tcontinue nextVisible; // method is not better since variables are not equal", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tcontinue nextVisible; // method2 is better match than method", "+\t\t\t\t\t\t}", "+\t\t\t\tmethod = visible[i]; // instead of the tieBreakMethod"]}], "num": 66712}