{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ba7f72662b942efa11802548f7f4977a", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "98ebd283382375524018c82f2ee54770", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "e283e45dcf10b8a279f599faf5a92449ec8c719c", "commitAfterChange": "8f130374b1740d04a2a1a32967cf4d9130b4bd12", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["+\t\t// this.maxFieldCount might already be set", "+\t\tint localMaxFieldCount = 0;", "-\t\t// field count from enclosing and supertypes should be included in maxFieldCount,", "-\t\t// to make field-ids unique among all fields in scope.", "-\t\t// 1.: enclosing:", "-\t\tTypeBinding original = sourceType.original();", "-\t\tint fieldAnalysisOffset = 0;", "-\t\tif (original instanceof NestedTypeBinding) {", "-\t\t\t// note: local types have no enclosingType in the AST but only in the binding:", "-\t\t\tfieldAnalysisOffset = ((NestedTypeBinding)original).enclosingType.cumulativeFieldCount;", "-\t\t}", "-\t\t// 2.: supers:", "-\t\tReferenceBinding superClassBinding = sourceType.superclass;", "-\t\twhile (superClassBinding != null) {", "-\t\t\tFieldBinding[] unResolvedFields = superClassBinding.unResolvedFields();", "-\t\t\tif (unResolvedFields != null) {", "-\t\t\t\tfor (int i=unResolvedFields.length-1; i>=0; i--) {", "- \t\t\t\t\t// if the field is an initializer we do not want to update the count ", "-\t\t\t\t\tswitch (unResolvedFields[i].kind()) {", "-\t\t\t\t\t\tcase AbstractVariableDeclaration.FIELD:", "-\t\t\t\t\t\tcase AbstractVariableDeclaration.ENUM_CONSTANT:", "-\t\t\t\t\t\t\tfieldAnalysisOffset++;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfieldAnalysisOffset += findFieldCountFromSuperInterfaces(superClassBinding.superInterfaces());", "-\t\t\tsuperClassBinding = superClassBinding.superclass();", "-\t\t}", "-\t\tReferenceBinding[] superInterfacesBinding = sourceType.superInterfaces;", "-\t\tfieldAnalysisOffset += findFieldCountFromSuperInterfaces(superInterfacesBinding);", "-\t\tsourceType.cumulativeFieldCount += fieldAnalysisOffset;", "-\t\tsourceType.fieldAnalysisOffset = fieldAnalysisOffset;", "-\t\tthis.maxFieldCount = sourceType.cumulativeFieldCount;", "-", "+\t\t\t\t\t\tlocalMaxFieldCount++;", "+\t\t}", "+\t\tif (this.maxFieldCount < localMaxFieldCount) {", "+\t\t\tthis.maxFieldCount = localMaxFieldCount;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a69dcc721a547fc7a9b0d55429dc277d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "99e06cdf0656ed0f6c3eb604300a8baae7ee3beb", "commitAfterChange": "d6c2a90130be430285c5f6a000090d250c310afd", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 32, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["-\t\t// this.maxFieldCount might already be set", "-\t\tint localMaxFieldCount = 0;", "+\t\t// field count from enclosing and supertypes should be included in maxFieldCount,", "+\t\t// to make field-ids unique among all fields in scope.", "+\t\t// 1.: enclosing:", "+\t\tTypeBinding original = sourceType.original();", "+\t\tint fieldAnalysisOffset = 0;", "+\t\tif (original instanceof NestedTypeBinding) {", "+\t\t\t// note: local types have no enclosingType in the AST but only in the binding:", "+\t\t\tfieldAnalysisOffset = ((NestedTypeBinding)original).enclosingType.cumulativeFieldCount;", "+\t\t}", "+\t\t// 2.: supers:", "+\t\tReferenceBinding superClassBinding = sourceType.superclass;", "+\t\twhile (superClassBinding != null) {", "+\t\t\tFieldBinding[] unResolvedFields = superClassBinding.unResolvedFields();", "+\t\t\tif (unResolvedFields != null) {", "+\t\t\t\tfor (int i=unResolvedFields.length-1; i>=0; i--) {", "+ \t\t\t\t\t// if the field is an initializer we do not want to update the count ", "+\t\t\t\t\tswitch (unResolvedFields[i].kind()) {", "+\t\t\t\t\t\tcase AbstractVariableDeclaration.FIELD:", "+\t\t\t\t\t\tcase AbstractVariableDeclaration.ENUM_CONSTANT:", "+\t\t\t\t\t\t\tfieldAnalysisOffset++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tfieldAnalysisOffset += findFieldCountFromSuperInterfaces(superClassBinding.superInterfaces());", "+\t\t\tsuperClassBinding = superClassBinding.superclass();", "+\t\t}", "+\t\tReferenceBinding[] superInterfacesBinding = sourceType.superInterfaces;", "+\t\tfieldAnalysisOffset += findFieldCountFromSuperInterfaces(superInterfacesBinding);", "+\t\tsourceType.cumulativeFieldCount += fieldAnalysisOffset;", "+\t\tsourceType.fieldAnalysisOffset = fieldAnalysisOffset;", "+\t\tthis.maxFieldCount = sourceType.cumulativeFieldCount;", "+", "-\t\t\t\t\t\tlocalMaxFieldCount++;", "-\t\t}", "-\t\tif (this.maxFieldCount < localMaxFieldCount) {", "-\t\t\tthis.maxFieldCount = localMaxFieldCount;", "+}"]}], "num": 45689}