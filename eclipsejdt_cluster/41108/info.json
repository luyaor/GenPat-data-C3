{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1f551467b10d9d315c5c66334297760a", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2f0597dad2b075d9051f70ab767c960e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java", "commitBeforeChange": "7c5e971605e3df9f80c39caf6a5dabceeb49148b", "commitAfterChange": "ffe39da04df0f3a3dcc2e15c0353857438ce8e35", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tprivate boolean checkAndTagAsMalformed(ASTNode node)", "signatureAfterChange": " \t \tprivate boolean markIncludedProblems(int start, int end)", "diff": ["-\tprivate boolean checkAndTagAsMalformed(ASTNode node) {", "-\t\tboolean tagWithErrors = false;", "-\t\tsearch: for (int i = 0, max = this.problems.length; i < max; i++) {", "+\t", "+\tprivate boolean markIncludedProblems(int start, int end) {", "+\t\tboolean foundProblems = false;", "+\t\tnext: for (int i = 0, max = this.problems.length; i < max; i++) {", "+\t\t\t", "+\t\t\tif(this.usedOrIrrelevantProblems[i]) continue next;", "+\t\t\t", "-\t\t\t\t\tcontinue search;", "+\t\t\t\t\tthis.usedOrIrrelevantProblems[i] = true;", "+\t\t\t\t\tcontinue next;", "+\t\t\t\t\t", "+\t\t\t", "-\t\t\tint start = node.getStartPosition();", "-\t\t\tint end = start + node.getLength();", "-\t\t\t\tnode.setFlags(node.getFlags() | ASTNode.RECOVERED);", "-\t\t\t\ttagWithErrors = true;", "+\t\t\t\tthis.usedOrIrrelevantProblems[i] = true;", "+\t\t\t\tfoundProblems = true;", "-\t\treturn tagWithErrors;", "+\t\treturn foundProblems;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d5115264284b4cd94ff7695cf714e10", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/OrPattern.java", "commitBeforeChange": "9037a5669c89fc0ae3f8548a99dce6fa5402fb31", "commitAfterChange": "e4e1e1935f0e7607d1265df332c7ce922de89c18", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public void findIndexMatches(IndexInput input, IIndexSearchRequestor requestor, int detailLevel, IProgressMonitor progressMonitor, IJavaSearchScope scope) throws IOException", "signatureAfterChange": " public void findIndexMatches(IndexInput input, IIndexSearchRequestor requestor, int detailLevel, IProgressMonitor progressMonitor, IJavaSearchScope scope) throws IOException", "diff": ["-", "-\tif (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();", "-", "-\tleftPattern.findIndexMatches(input, orCombiner, detailLevel, progressMonitor, scope);", "-\tif (progressMonitor != null && progressMonitor.isCanceled())", "-\t\tthrow new OperationCanceledException();", "-\trightPattern.findIndexMatches(input, orCombiner, detailLevel, progressMonitor, scope);", "+", "+\tfor (int i = 0, length = this.patterns.length; i < length; i++)", "+\t\tthis.patterns[i].findIndexMatches(input, orCombiner, detailLevel, progressMonitor, scope);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d4a739d7d6aa040c9c93cc8f737a2da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "  \tCollection<InferenceVariable> inputVariables(final InferenceContext18 context)", "signatureAfterChange": "  \tCollection<InferenceVariable> inputVariables(final InferenceContext18 context)", "diff": ["-\t\t\t\t\tStatement body = resolved != null ? resolved.body() : lambda.body();", "-\t\t\t\t\tif (body instanceof Expression) {", "-\t\t\t\t\t\tvariables.addAll(new ConstraintExpressionFormula((Expression) body, r, COMPATIBLE).inputVariables(context));", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// TODO: should I use LambdaExpression.resultExpressions? (is currently private).", "-\t\t\t\t\t\tbody.traverse(new ASTVisitor() {", "-\t\t\t\t\t\t\tpublic boolean visit(ReturnStatement returnStatement, BlockScope scope) {", "-\t\t\t\t\t\t\t\tvariables.addAll(new ConstraintExpressionFormula(returnStatement.expression, r, COMPATIBLE).inputVariables(context));", "-\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}, (BlockScope)null);", "+\t\t\t\t\tExpression[] resultExpressions = resolved != null ? resolved.resultExpressions() : null;", "+\t\t\t\t\tfor (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {", "+\t\t\t\t\t\tvariables.addAll(new ConstraintExpressionFormula(resultExpressions[i], r, COMPATIBLE).inputVariables(context));"]}], "num": 41108}