{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "32c52a5481e2fa02c6ad7ff1a87ac1ee", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "30ac8ccd443ce5035453d9d7f13debf3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "1b80cae94595518122618b458eed60915f76d171", "commitAfterChange": "92d6141bb346285ff13c588faa5a059cb9f83b3d", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tpreTryInitStateIndex =", "+\t\tthis.preTryInitStateIndex =", "-\t\tif (anyExceptionVariable != null) {", "-\t\t\tanyExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.anyExceptionVariable != null) {", "+\t\t\tthis.anyExceptionVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "-\t\t\treturnAddressVariable.useFlag = LocalVariableBinding.USED;", "+\t\tif (this.returnAddressVariable != null) { // TODO (philippe) if subroutine is escaping, unused", "+\t\t\tthis.returnAddressVariable.useFlag = LocalVariableBinding.USED;", "-\t\tif (subRoutineStartLabel == null) {", "+\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\t\tfinallyBlock", "+\t\t\t\tthis.finallyBlock", "-\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, finallyBlock),", "+\t\t\t\t\t\tfinallyContext = new FinallyFlowContext(flowContext, this.finallyBlock),", "-\t\t\t\tisSubRoutineEscaping = true;", "-\t\t\t\tscope.problemReporter().finallyMustCompleteNormally(finallyBlock);", "+\t\t\t\tthis.isSubRoutineEscaping = true;", "+\t\t\t\tthis.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);", "-\t\t\t\ttryBlock,", "-\t\t\t\tcaughtExceptionTypes,", "-\t\t\t\tscope,", "+\t\t\t\tthis.tryBlock,", "+\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\tthis.scope,", "-\t\tif (tryBlock.isEmptyBlock()) {", "+\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\ttryBlockExit = false;", "+\t\t\tthis.tryBlockExit = false;", "-\t\t\ttryInfo = tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\ttryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\thandlingContext.complainIfUnusedExceptionHandlers(scope, this);", "+\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-\t\tif (catchArguments != null) {", "+\t\tif (this.catchArguments != null) {", "-\t\t\tcatchExits = new boolean[catchCount = catchBlocks.length];", "+\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\t\t\t\t\t\tcaughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\tLocalVariableBinding catchArg = catchArguments[i].binding;", "+\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tif (tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\tcatchBlocks[i].analyseCode(", "+\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\tcatchExits[i] = ", "+\t\t\t\tthis.catchExits[i] = ", "-\t\tif (subRoutineStartLabel == null) {", "-\t\t\tmergedInitStateIndex =", "+\t\tif (this.subRoutineStartLabel == null) {", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex =", "-\t\t\tmergedInitStateIndex =", "+\t\t\tthis.mergedInitStateIndex ="]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a74e744d6098a7ca96c409413c6a36ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java", "commitBeforeChange": "f0cc0529135fe43e5b6252dca937651f0a04d49c", "commitAfterChange": "79c1182746ff2f44f9956aeaf2f61882a4911acb", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tpublic ExtendedAnnotation( \t\t\tbyte[] classFileBytes, \t\t\tIConstantPool constantPool, \t\t\tint offset) throws ClassFormatException", "signatureAfterChange": " \tpublic ExtendedAnnotation( \t\t\tbyte[] classFileBytes, \t\t\tIConstantPool constantPool, \t\t\tint offset) throws ClassFormatException", "diff": ["-\t\tint index = u2At(classFileBytes, 0, offset);", "+\t\t// Read target_type", "+\t\tint index = u1At(classFileBytes,0,offset);", "+\t\tthis.targetType = index;", "+\t\tthis.readOffset = 1;", "+\t\t", "+\t\treadTargetInfo(index, classFileBytes, constantPool, offset);", "+", "+\t\t// Read type_path", "+\t\tindex = u1At(classFileBytes, this.readOffset, offset);", "+\t\tthis.readOffset++;", "+\t\tint typePathEntryCount = index;", "+\t\tif (typePathEntryCount == 0) {", "+\t\t\tthis.typePath = NO_TYPEPATH;", "+\t\t} else {", "+\t\t\tthis.typePath = new int[typePathEntryCount][];", "+\t\t\tfor (int i = 0; i < typePathEntryCount; i++) {", "+\t\t\t\tint[] typePathEntry = (this.typePath[i] = new int[2]);", "+\t\t\t\ttypePathEntry[0] = u1At(classFileBytes, this.readOffset++, offset);", "+\t\t\t\ttypePathEntry[1] = u1At(classFileBytes, this.readOffset++, offset);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\t// Read annotation", "+\t\tindex = u2At(classFileBytes, this.readOffset, offset);", "+\t\tthis.readOffset+=2;", "-\t\tfinal int length = u2At(classFileBytes, 2, offset);", "+\t\tfinal int length = u2At(classFileBytes, this.readOffset, offset);", "-\t\tthis.readOffset = 4;", "+\t\tthis.readOffset+=2;", "-\t\tindex = u1At(classFileBytes, this.readOffset, offset);", "-\t\tthis.readOffset++;", "-\t\tthis.targetType = index;", "-\t\tswitch(index) {", "-\t\t\tcase IExtendedAnnotationConstants.WILDCARD_BOUND :", "-\t\t\t\tthis.wildcardLocationType = u1At(classFileBytes, this.readOffset, offset);", "-\t\t\t\tthis.readOffset++;", "-\t\t\t\tinternalDecoding(this.wildcardLocationType, classFileBytes, constantPool, offset);", "-\t\t\t\t// copy the location back into the wildcard location", "-\t\t\t\tint size = this.locations.length;", "-\t\t\t\tSystem.arraycopy(this.locations, 0, (this.wildcardLocations = new int[size]), 0, size);", "-\t\t\t\tthis.locations = null;", "-\t\t\t\tbreak;", "-\t\t\tcase IExtendedAnnotationConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY :", "-\t\t\t\tthis.wildcardLocationType = u1At(classFileBytes, this.readOffset, offset);", "-\t\t\t\tthis.readOffset++;", "-\t\t\t\tinternalDecoding(this.wildcardLocationType, classFileBytes, constantPool, offset);", "-\t\t\t\tsize = this.locations.length;", "-\t\t\t\tSystem.arraycopy(this.locations, 0, (this.wildcardLocations = new int[size]), 0, size);", "-\t\t\t\tint locationLength = u2At(classFileBytes, this.readOffset, offset);", "-\t\t\t\tthis.readOffset += 2;", "-\t\t\t\tthis.locations = new int[locationLength];", "-\t\t\t\tfor (int i = 0; i < locationLength; i++) {", "-\t\t\t\t\tthis.locations[i] = u1At(classFileBytes, this.readOffset, offset);", "-\t\t\t\t\tthis.readOffset++;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tdefault:", "-\t\t\t\tinternalDecoding(index, classFileBytes, constantPool, offset);", "-\t\t}"]}], "num": 10617}