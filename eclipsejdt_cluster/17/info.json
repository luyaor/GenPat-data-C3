{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "79389777cc012e1d3d6cd00d7ae1f503", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "530d8c5f10d27020294a1c8c46da5ce7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "82d58f9af854b98a92f7d694d40ac1e84e13013c", "commitAfterChange": "6d114aac1fbfd4c23041534efbb02c24c883ba25", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": "    public void resolve()", "signatureAfterChange": "    public void resolve()", "diff": ["-\t\tboolean hasEnumConstantsWithoutBody = false;", "+\t\tFieldDeclaration[] enumConstantsWithoutBody = null;", "-\t\t\t\t\t\tif (!(field.initialization instanceof QualifiedAllocationExpression))", "-\t\t\t\t\t\t\thasEnumConstantsWithoutBody = true;", "+\t\t\t\t\t\tif (!(field.initialization instanceof QualifiedAllocationExpression)) {", "+\t\t\t\t\t\t\tif (enumConstantsWithoutBody == null)", "+\t\t\t\t\t\t\t\tenumConstantsWithoutBody = new FieldDeclaration[count];", "+\t\t\t\t\t\t\tenumConstantsWithoutBody[i] = field;", "+\t\t\t\t\t\t}", "-\t\t\t\t\tif (!hasEnumConstants || hasEnumConstantsWithoutBody) {", "+\t\t\t\t\tif (!hasEnumConstants) {", "+\t\t\t\t\t\tfor (int i = 0, count = this.methods.length; i < count; i++) {", "+\t\t\t\t\t\t\tfinal AbstractMethodDeclaration methodDeclaration = this.methods[i];", "+\t\t\t\t\t\t\tif (methodDeclaration.isAbstract() && methodDeclaration.binding != null)", "+\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumAbstractMethodMustBeImplemented(methodDeclaration);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (enumConstantsWithoutBody != null) {", "-\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumAbstractMethodMustBeImplemented(methodDeclaration);", "+\t\t\t\t\t\t\t\tfor (int f = 0, l = enumConstantsWithoutBody.length; f < l; f++)", "+\t\t\t\t\t\t\t\t\tif (enumConstantsWithoutBody[f] != null)", "+\t\t\t\t\t\t\t\t\t\tthis.scope.problemReporter().enumConstantMustImplementAbstractMethod(methodDeclaration, enumConstantsWithoutBody[f]);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac890a57aa14e0fd752395f7bad90ffe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java", "commitBeforeChange": "833acf9fd171cc3b88beb3f35c58318abd7b1b7c", "commitAfterChange": "e83ae1e37e0f93b696a44a9888bf8d5e9425c659", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public ElementValuePair[] getElementValuePairs()", "signatureAfterChange": "  public ElementValuePair[] getElementValuePairs()", "diff": ["-\tif (this.env != null)", "-\t\tgetAnnotationType(); // resolve the annotation type & method bindings of each pair", "-", "+\tif (this.env != null) {", "+\t\tif (this.typeUnresolved) {", "+\t\t\tgetAnnotationType(); // resolve the annotation type", "+\t\t}", "+\t\t// resolve method binding and value type (if unresolved) for each pair", "+\t\tfor (int i = this.pairs.length; --i >= 0;) {", "+\t\t\tElementValuePair pair = this.pairs[i];", "+\t\t\tMethodBinding[] methods = this.type.getMethods(pair.getName());", "+\t\t\t// there should be exactly one since the type is an annotation type.", "+\t\t\tif (methods != null && methods.length == 1) {", "+\t\t\t\tpair.setMethodBinding(methods[0]);", "+\t\t\t} // else silently leave a null there", "+\t\t\tObject value = pair.getValue();", "+\t\t\tif (value instanceof UnresolvedReferenceBinding) {", "+\t\t\t\tpair.setValue(((UnresolvedReferenceBinding) value).", "+\t\t\t\t\t\tresolve(this.env, false));", "+\t\t\t\t\t\t\t// no parameterized types in annotation values", "+\t\t\t} // do nothing for UnresolvedAnnotationBinding-s, since their ", "+\t\t\t  // content is only accessed through get* methods", "+\t\t}", "+\t\tthis.env = null;", "+\t}"]}], "num": 17}