{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5de2150b3b24489feb13521119d712ab", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4d8c03fe9aea472e71ee19861f0cc2b5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 259, "methodNumberAfterChange": 259, "signatureBeforeChange": " public void test112()", "signatureAfterChange": " public void test112()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static abstract class Implementation<T> extends Super<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static abstract class Implementation<T> extends Super<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"should have two methods bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"should have two methods bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b3bfbac166c362477483ffbaf9129d16", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java", "commitBeforeChange": "cbbc77bad29ab0935f23d7976e8f3a83a2098569", "commitAfterChange": "218bf9e76765a0b6d9236837b12cba562b6c4513", "methodNumberBeforeChange": 258, "methodNumberAfterChange": 258, "signatureBeforeChange": " public void test111()", "signatureAfterChange": " public void test111()", "diff": ["-\tif (this.complianceLevel.compareTo(COMPLIANCE_1_5) >= 0) {", "-\t\tMap options = this.getCompilerOptions();", "-\t\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\"X.java\",", "-\t\t\t\t\"public class X {\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "-\t\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Implementation<T> extends Super<T> {\\n\" + ", "-\t\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "-\t\t\t\t\"\t\t\treturn null;\\n\" + ", "-\t\t\t\t\"\t\t}\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"\\n\" + ", "-\t\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "-\t\t\t\t\"\t\tnew Grandchild();\\n\" + ", "-\t\t\t\t\"\t}\\n\" + ", "-\t\t\t\t\"}\"", "-\t\t\t},", "-\t\t\t\"\",", "-\t\t\tnull,", "-\t\t\ttrue,", "-\t\t\tnull,", "-\t\t\toptions,", "-\t\t\tnull", "-\t\t);", "-\t\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "-\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "-\t\tboolean found = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "+\tMap options = this.getCompilerOptions();", "+\toptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\tthis.runConformTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"\tprivate interface ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate interface ReturnDerived extends ReturnBase {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Super<E> {\\n\" + ", "+\t\t\t\"\t\tReturnBase bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Implementation<T> extends Super<T> {\\n\" + ", "+\t\t\t\"\t\tpublic final ReturnDerived bar() {\\n\" + ", "+\t\t\t\"\t\t\treturn null;\\n\" + ", "+\t\t\t\"\t\t}\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Child<U> extends Implementation<U> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tprivate static class Grandchild<V> extends Child<V> {\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"\\n\" + ", "+\t\t\t\"\tpublic static void main(String[] args) {\\n\" + ", "+\t\t\t\"\t\tnew Grandchild();\\n\" + ", "+\t\t\t\"\t}\\n\" + ", "+\t\t\t\"}\"", "+\t\t},", "+\t\t\"\",", "+\t\tnull,", "+\t\ttrue,", "+\t\tnull,", "+\t\toptions,", "+\t\tnull", "+\t);", "+\tFile fileX = new File(OUTPUT_DIR + File.separator  +\"X$Child.class\");", "+\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tIMethodInfo[] methodInfos = reader.getMethodInfos();", "+\tboolean found = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "-\t\t\t\tfound = true;", "-\t\t\t\tbreak;", "-\t\t\t}", "-\t\t}", "-\t\tassertFalse(\"bar should not be there\", found);", "-\t\t", "-\t\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "-\t\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "-\t\tmethodInfos = reader.getMethodInfos();", "-\t\tint count = 0;", "-\t\tfound = false;", "-\t\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "-\t\t\tIMethodInfo methodInfo = methodInfos[i];", "-\t\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "-\t\t\t\tcount++;", "-\t\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "-\t\t\t\t\tfound = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tassertEquals(\"should have two methods bar\", 2, count);", "-\t\tassertTrue(\"should have one bridge method\", found);", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Grandchild.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tif (new String(methodInfos[i].getName()).equals(\"bar\")) {", "+\t\t\tfound = true;", "+\t\t\tbreak;", "+\t\t}", "+\t}", "+\tassertFalse(\"bar should not be there\", found);", "+\t", "+\tfileX = new File(OUTPUT_DIR + File.separator  +\"X$Implementation.class\");", "+\treader = ToolFactory.createDefaultClassFileReader(fileX.getAbsolutePath(), IClassFileReader.ALL_BUT_METHOD_BODIES);", "+\tmethodInfos = reader.getMethodInfos();", "+\tint count = 0;", "+\tfound = false;", "+\tfor (int i = 0, max = methodInfos.length; i < max; i++) {", "+\t\tIMethodInfo methodInfo = methodInfos[i];", "+\t\tif (new String(methodInfo.getName()).equals(\"bar\")) {", "+\t\t\tcount++;", "+\t\t\tif (Flags.isBridge(methodInfo.getAccessFlags())) {", "+\t\t\t\tfound = true;", "+\t\t\t}", "+\t\t}", "+\t}", "+\tassertEquals(\"should have two methods bar\", 2, count);", "+\tassertTrue(\"should have one bridge method\", found);"]}], "num": 65205}