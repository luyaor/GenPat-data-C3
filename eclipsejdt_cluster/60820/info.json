{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c997d7095b8d312a77ec03ccc7bd6d64", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "591370a8f08828df35b95fa1baf5e6cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetClassFile.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " public static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "signatureAfterChange": " public static void createProblemType(TypeDeclaration typeDeclaration, CompilationResult unitResult)", "diff": ["-\tFieldBinding[] fields = typeBinding.fields;", "+\tFieldBinding[] fields = typeBinding.fields();", "-\tMethodBinding[] methods = typeBinding.methods;", "-\tAbstractMethodDeclaration[] methodDeclarations = typeDeclaration.methods;", "-\tint maxMethodDecl = methodDeclarations == null ? 0 : methodDeclarations.length;", "-\tif (methods != null) {", "+\tAbstractMethodDeclaration[] methodDecls = typeDeclaration.methods;", "+\tif (methodDecls != null) {", "-\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\tMethodBinding methodBinding;", "-\t\t\t\tif ((methodBinding = methods[i]) != null) {", "-\t\t\t\t\t// find the corresponding method declaration", "-\t\t\t\t\tfor (int j = 0; j < maxMethodDecl; j++) {", "-\t\t\t\t\t\tif ((methodDeclarations[j] != null) && (methodDeclarations[j].binding == methods[i])) {", "-\t\t\t\t\t\t\tif (!methodBinding.isConstructor()) {", "-\t\t\t\t\t\t\t\tclassFile.addAbstractMethod(methodDeclarations[j], methodBinding);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}\t\t\t", "+\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\t\tif (method == null || method.isConstructor()) continue;", "+\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "+\t\t\t}\t\t", "-\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\tMethodBinding methodBinding;", "-\t\t\t\tif ((methodBinding = methods[i]) != null) {", "-\t\t\t\t\t// find the corresponding method declaration", "-\t\t\t\t\tfor (int j = 0; j < maxMethodDecl; j++) {", "-\t\t\t\t\t\tif ((methodDeclarations[j] != null) && (methodDeclarations[j].binding == methods[i])) {", "-\t\t\t\t\t\t\tAbstractMethodDeclaration methodDecl;", "-\t\t\t\t\t\t\tif ((methodDecl = methodDeclarations[j]).isConstructor()) {", "-\t\t\t\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, methodBinding, problemsCopy);", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tclassFile.addProblemMethod(methodDecl, methodBinding, problemsCopy);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\t\tif (method == null) continue;", "+\t\t\t\tif (method.isConstructor()) {", "+\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "+\t\t\t\t} else {", "+\t\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "998481c1f2a2b4bd315670d613bd0bf7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "7a675c0d33ffc1c59486552f5a80779f0f3d95d0", "commitAfterChange": "0580b12603e025516ea827d181150b0daae85b9b", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic static void createProblemType( \t\tTypeDeclaration typeDeclaration, \t\tCompilationResult unitResult)", "signatureAfterChange": " \tpublic static void createProblemType( \t\tTypeDeclaration typeDeclaration, \t\tCompilationResult unitResult)", "diff": ["-\t\tFieldBinding[] fields = typeBinding.fields;", "+\t\tFieldBinding[] fields = typeBinding.fields();", "-\t\tMethodBinding[] methods = typeBinding.methods;", "-\t\tAbstractMethodDeclaration[] methodDeclarations = typeDeclaration.methods;", "-\t\tint maxMethodDecl = methodDeclarations == null ? 0 : methodDeclarations.length;", "-\t\tif (methods != null) {", "+\t\t", "+\t\tAbstractMethodDeclaration[] methodDecls = typeDeclaration.methods;", "+\t\tif (methodDecls != null) {", "-\t\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\t\tMethodBinding methodBinding;", "-\t\t\t\t\tif ((methodBinding = methods[i]) != null) {", "-\t\t\t\t\t\t// find the corresponding method declaration", "-\t\t\t\t\t\tfor (int j = 0; j < maxMethodDecl; j++) {", "-\t\t\t\t\t\t\tif ((methodDeclarations[j] != null)", "-\t\t\t\t\t\t\t\t&& (methodDeclarations[j].binding == methods[i])) {", "-\t\t\t\t\t\t\t\tif (!methodBinding.isConstructor()) {", "-\t\t\t\t\t\t\t\t\tclassFile.addAbstractMethod(methodDeclarations[j], methodBinding);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\t\t\tif (method == null || method.isConstructor()) continue;", "+\t\t\t\t\tclassFile.addAbstractMethod(methodDecl, method);", "+\t\t\t\t}\t\t", "-\t\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\t\t\tMethodBinding methodBinding;", "-\t\t\t\t\tif ((methodBinding = methods[i]) != null) {", "-\t\t\t\t\t\t// find the corresponding method declaration", "-\t\t\t\t\t\tfor (int j = 0; j < maxMethodDecl; j++) {", "-\t\t\t\t\t\t\tif ((methodDeclarations[j] != null)", "-\t\t\t\t\t\t\t\t&& (methodDeclarations[j].binding == methods[i])) {", "-\t\t\t\t\t\t\t\tAbstractMethodDeclaration methodDecl;", "-\t\t\t\t\t\t\t\tif ((methodDecl = methodDeclarations[j]).isConstructor()) {", "-\t\t\t\t\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, methodBinding, problemsCopy);", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tclassFile.addProblemMethod(methodDecl, methodBinding, problemsCopy);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\tfor (int i = 0, length = methodDecls.length; i < length; i++) {", "+\t\t\t\t\tAbstractMethodDeclaration methodDecl = methodDecls[i];", "+\t\t\t\t\tMethodBinding method = methodDecl.binding;", "+\t\t\t\t\tif (method == null) continue;", "+\t\t\t\t\tif (method.isConstructor()) {", "+\t\t\t\t\t\tclassFile.addProblemConstructor(methodDecl, method, problemsCopy);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tclassFile.addProblemMethod(methodDecl, method, problemsCopy);", "-\t\t}", "+\t\t}\t\t", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1b28196f14a4ae010608d0cf0f72758", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticMethodBinding.java", "commitBeforeChange": "99a320ba218a453cde9430d003d516f8202cd4ca", "commitAfterChange": "bc5d9b450540dde0f4417c6b10a04ec18aa90f94", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic SyntheticMethodBinding(MethodBinding targetMethod, boolean isSuperAccess, ReferenceBinding receiverType)", "signatureAfterChange": "  \tpublic SyntheticMethodBinding(FieldBinding targetField, ReferenceBinding declaringClass, TypeBinding enumBinding, char[] selector)", "diff": ["+\tpublic SyntheticMethodBinding(FieldBinding targetField, ReferenceBinding declaringClass, TypeBinding enumBinding, char[] selector) {", "+\t\tthis.modifiers = AccDefault | AccStatic | AccSynthetic;", "+\t\tthis.tagBits |= TagBits.AnnotationResolved;", "+\t\tSourceTypeBinding declaringSourceType = (SourceTypeBinding) declaringClass;", "+\t\tSyntheticMethodBinding[] knownAccessMethods = declaringSourceType.syntheticMethods();", "+\t\tint methodId = knownAccessMethods == null ? 0 : knownAccessMethods.length;", "+\t\tthis.index = methodId;", "+\t\tthis.selector = selector;", "+\t\tthis.returnType = declaringSourceType.scope.createArrayType(BaseTypes.IntBinding, 1);", "+\t\tthis.parameters = NoParameters;", "+\t\tthis.targetReadField = targetField;", "+\t\tthis.targetEnumType = enumBinding;", "+\t\tthis.kind = SwitchTable;", "+\t\tthis.thrownExceptions = NoExceptions;", "+\t\tthis.declaringClass = declaringSourceType;", "+  ", "+\t\tif (declaringSourceType.isStrictfp()) {", "+\t\t\tthis.modifiers |= AccStrictfp;", "+\t\t}", "+\t\t// check for method collision", "+\t\tboolean needRename;", "+\t\tdo {", "+\t\t\tcheck : {", "+\t\t\t\tneedRename = false;", "+\t\t\t\t// check for collision with known methods", "+\t\t\t\tMethodBinding[] methods = declaringSourceType.methods;", "+\t\t\t\tfor (int i = 0, length = methods.length; i < length; i++) {", "+\t\t\t\t\tif (CharOperation.equals(this.selector, methods[i].selector) && this.areParametersEqual(methods[i])) {", "+\t\t\t\t\t\tneedRename = true;", "+\t\t\t\t\t\tbreak check;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// check for collision with synthetic accessors", "+\t\t\t\tif (knownAccessMethods != null) {", "+\t\t\t\t\tfor (int i = 0, length = knownAccessMethods.length; i < length; i++) {", "+\t\t\t\t\t\tif (knownAccessMethods[i] == null) continue;", "+\t\t\t\t\t\tif (CharOperation.equals(this.selector, knownAccessMethods[i].selector) && this.areParametersEqual(methods[i])) {", "+\t\t\t\t\t\t\tneedRename = true;", "+\t\t\t\t\t\t\tbreak check;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (needRename) { // retry with a selector postfixed by a growing methodId", "+\t\t\t\tthis.setSelector(CharOperation.concat(selector, String.valueOf(++methodId).toCharArray()));", "+\t\t\t}", "+\t\t} while (needRename);", "+", "+\t\t// We now at this point - per construction - it is for sure an enclosing instance, we are going to", "+\t\t// show the target field type declaration location.", "+\t\tthis.sourceStart = declaringSourceType.scope.referenceContext.sourceStart; // use the target declaring class name position instead", "+\t}"]}], "num": 60820}