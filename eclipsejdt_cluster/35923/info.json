{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e6692dcc577b6468a7497afbbbc8c6ce", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "368010b4d3ef5d1175131700ff658643", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "5e23ed7edfe961d34bd26ee29fb9ade957409733", "commitAfterChange": "28dd1050b46fae522d51f1c10cb06a79601770f3", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["+\t\tif (this.index >= this.scanner.eofPosition) {", "+\t\t\tthis.tagSourceStart = previousPosition;", "+\t\t\tthis.tagSourceEnd = this.tokenPreviousPosition;", "+\t\t\tif (this.reportProblems) this.sourceParser.problemReporter().javadocInvalidTag(this.tagSourceStart, this.tagSourceEnd);", "+\t\t\treturn false;", "+\t\t}", "+\t\t\t\tif (length == 0) break; // may happen for some parser (completion for example)", "-\t\t\t\t\t\t\tif (this.inlineTagStarted) {", "+\t\t\t\t\t\t\tif (this.inlineTagStarted || this.kind == COMPLETION_PARSER) {", "-\t\t\t\t\t\tif (this.jdk15 && CharOperation.equals(tag, TAG_VALUE)) {", "+\t\t\t\t\t\tif (this.sourceLevel >= ClassFileConstants.JDK1_5 && CharOperation.equals(tag, TAG_VALUE)) {", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "888225de8a9613032f4b955b183a24f9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/JavadocParser.java", "commitBeforeChange": "17b55cdea0f063b02f652f713cdfd5976899b16f", "commitAfterChange": "0a1cb06fbf8449ad01efa938f94781763845ef09", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "signatureAfterChange": "  \tprotected boolean parseTag(int previousPosition) throws InvalidInputException", "diff": ["-\t\t\t\t\t// inhibits inherited flag when tags have been already stored", "-\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606", "-\t\t\t\t\t// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag", "-\t\t\t\t\t// was encountered in comment. But it cannot be the case for COMPILER_PARSER", "-\t\t\t\t\t// and so is enough as it is only this parser which signals the missing tag warnings...", "-\t\t\t\t\tif (this.astPtr==-1) {", "-\t\t\t\t\t\tthis.inheritedPositions = (((long) this.tagSourceStart) << 32) + this.tagSourceEnd;", "+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=247037, @inheritDoc usage is illegal", "+\t\t\t\t\t// outside of few block tags and the main description.", "+\t\t\t\t\tswitch (this.lastBlockTagValue) {", "+\t\t\t\t\t\tcase TAG_RETURN_VALUE:", "+\t\t\t\t\t\tcase TAG_THROWS_VALUE:", "+\t\t\t\t\t\tcase TAG_EXCEPTION_VALUE:", "+\t\t\t\t\t\tcase TAG_PARAM_VALUE:", "+\t\t\t\t\t\tcase NO_TAG_VALUE:     // Still in main description", "+\t\t\t\t\t\t\tvalid = true;", "+\t\t\t\t\t\t\tif (this.reportProblems) {", "+\t\t\t\t\t\t\t\trecordInheritedPosition((((long) this.tagSourceStart) << 32) + this.tagSourceEnd);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tvalid = false;", "+\t\t\t\t\t\t\tif (this.reportProblems) {", "+\t\t\t\t\t\t\t\tthis.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart,", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tvalid = true;", "+\t\tif (this.tagValue != TAG_OTHERS_VALUE && !this.inlineTagStarted) {", "+\t\t\tthis.lastBlockTagValue = this.tagValue;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ddf98c4de6ae219d1152b5175b10b7ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "b7295bb19a68269f09e5fdceeecf4f4c701e7063", "commitAfterChange": "f74beb57e62e872a608b1d99069f6ffa51720699", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tthis.constant = Constant.NotAConstant;", "-\tif (this.type == null) {", "-\t\t// initialization of an enum constant", "-\t\tthis.resolvedType = scope.enclosingReceiverType();", "+\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "+\tfinal CompilerOptions compilerOptions = scope.compilerOptions();", "+\tif (this.constant != Constant.NotAConstant) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\tif (this.type == null) {", "+\t\t\t// initialization of an enum constant", "+\t\t\tthis.resolvedType = scope.enclosingReceiverType();", "+\t\t} else {", "+\t\t\tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {", "+\t\t\t\treturn this.resolvedType = new PolyTypeBinding(this);", "+\t\t\t}", "+\t\t}", "-\t\tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t\tthis.resolvedType = this.type.resolvedType;", "+\t}", "+", "+\tif (this.type != null) {", "-\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "-\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "+\t\tboolean argHasError = compilerOptions.sourceLevel < ClassFileConstants.JDK1_5;", "-\tfinal CompilerOptions compilerOptions = scope.compilerOptions();"]}], "num": 35923}