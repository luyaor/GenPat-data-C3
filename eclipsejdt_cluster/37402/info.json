{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "261b5fe3b43b9d1b675cccaee3160018", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cef72aba261508321563b44993303142", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f4780070139277b6fb55a752513ae8db", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "368e7b2744bb4a520a4dfc9ab8183508aa7c626d", "commitAfterChange": "93b70485a331557e06c4f378f7086f6e4f12616a", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": " \t \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes", "-\t\tchar[][] compoundName = typeReference.getTypeName();", "-\t\tcompilationUnitScope().recordQualifiedReference(compoundName);", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;", "-\t\tint size = compoundName.length;", "-\t\tint n = 1;", "-\t\tReferenceBinding superType;", "-", "-\t\t// resolve the first name of the compoundName", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {", "-\t\t\tsuperType = sourceType;", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes", "-\t\t} else {", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "-\t\t\t\treturn new ProblemReferenceBinding(", "-\t\t\t\t\tcompoundName[0],", "-\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "-", "-\t\t\tboolean checkVisibility = false;", "-\t\t\tfor (; n < size; n++) {", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))", "-\t\t\t\t\tbreak;", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);", "+\t\ttry {", "+\t\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes", "+\t\t\tchar[][] compoundName = typeReference.getTypeName();", "+\t\t\tcompilationUnitScope().recordQualifiedReference(compoundName);", "+\t\t\tSourceTypeBinding sourceType = referenceContext.binding;", "+\t\t\tint size = compoundName.length;", "+\t\t\tint n = 1;", "+\t\t\tReferenceBinding superType;", "+\t", "+\t\t\t// resolve the first name of the compoundName", "+\t\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {", "+\t\t\t\tsuperType = sourceType;", "+\t\t\t\t// match against the sourceType even though nested members cannot be supertypes", "+\t\t\t} else {", "+\t\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),", "+\t\t\t\t\t\tcompoundName[0],", "-\t\t\t\tcheckVisibility = true;", "+\t", "+\t\t\t\tboolean checkVisibility = false;", "+\t\t\t\tfor (; n < size; n++) {", "+\t\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;", "+\t\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);", "+\t\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())", "+\t\t\t\t\t\treturn new ProblemReferenceBinding(", "+\t\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),", "+\t\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());", "+\t\t\t\t\tcheckVisibility = true;", "+\t\t\t\t}", "+\t", "+\t\t\t\t// convert to a ReferenceBinding", "+\t\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName", "+\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "+\t\t\t\tsuperType = (ReferenceBinding) typeOrPackage;", "+\t\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "+\t", "+\t\t\t\tif (checkVisibility", "+\t\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility", "+\t\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))", "+\t\t\t\t\t\t// its a toplevel type so just check package access", "+\t\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), superType, NotVisible);", "+\t\t\t\t}", "-", "-\t\t\t// convert to a ReferenceBinding", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;", "-\t\t\tcompilationUnitScope().recordTypeReference(superType); // to record supertypes", "-", "-\t\t\tif (checkVisibility", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))", "-\t\t\t\t\t// its a toplevel type so just check package access", "-\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), superType, NotVisible);", "+\t\t\t// at this point we know we have a type but we have to look for cycles", "+\t\t\twhile (true) {", "+\t\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "+\t\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "+\t\t\t\tif (detectCycle(sourceType, superType, typeReference))", "+\t\t\t\t\treturn null; // cycle error was already reported", "+\t", "+\t\t\t\tif (n >= size)", "+\t\t\t\t\tbreak;", "+\t", "+\t\t\t\t// retrieve the next member type", "+\t\t\t\tchar[] typeName = compoundName[n++];", "+\t\t\t\tsuperType = findMemberType(typeName, superType);", "+\t\t\t\tif (superType == null)", "+\t\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "+\t\t\t\tif (!superType.isValidBinding()) {", "+\t\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);", "+\t\t\t\t\treturn superType;", "+\t\t\t\t}", "+\t\t\treturn superType;", "+\t\t} catch (AbortCompilation e) {", "+\t\t\te.updateContext(typeReference, referenceCompilationUnit().compilationResult);", "+\t\t\tthrow e;", "-\t\t// at this point we know we have a type but we have to look for cycles", "-\t\twhile (true) {", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))", "-\t\t\t\treturn null; // cycle error was already reported", "-", "-\t\t\tif (n >= size)", "-\t\t\t\tbreak;", "-", "-\t\t\t// retrieve the next member type", "-\t\t\tchar[] typeName = compoundName[n++];", "-\t\t\tsuperType = findMemberType(typeName, superType);", "-\t\t\tif (superType == null)", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);", "-\t\t\tif (!superType.isValidBinding()) {", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);", "-\t\t\t\treturn superType;", "-\t\t\t}", "-\t\t}", "-\t\treturn superType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc3bb1ba75108847ac0b72ecc0d285d9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r \tprivate ReferenceBinding findSupertype(TypeReference typeReference)", "signatureAfterChange": "\r private ReferenceBinding findSupertype(TypeReference typeReference)", "diff": ["-\t\r", "-\tprivate ReferenceBinding findSupertype(TypeReference typeReference) {\r", "-\t\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "-\t\tchar[][] compoundName = typeReference.getTypeName();\r", "-\t\tSourceTypeBinding sourceType = referenceContext.binding;\r", "-\t\tint size = compoundName.length;\r", "-\t\tint n = 1;\r", "-\t\tReferenceBinding superType;\r", "-\t\t// resolve the first name of the compoundName\r", "-\t\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "-\t\t\tsuperType = sourceType;\r", "-\t\t\t// match against the sourceType even though nested members cannot be supertypes\r", "-\t\t} else {\r", "-\t\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "-\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()) {\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));\r", "-\t\t\t\t// record package ref\r", "+}\r", "+private ReferenceBinding findSupertype(TypeReference typeReference) {\r", "+\ttypeReference.aboutToResolve(this); // allows us to trap completion & selection nodes\r", "+\tchar[][] compoundName = typeReference.getTypeName();\r", "+\tSourceTypeBinding sourceType = referenceContext.binding;\r", "+\tint size = compoundName.length;\r", "+\tint n = 1;\r", "+\tReferenceBinding superType;\r", "+\r", "+\t// resolve the first name of the compoundName\r", "+\tif (CharOperation.equals(compoundName[0], sourceType.sourceName)) {\r", "+\t\tsuperType = sourceType; // match against the sourceType even though nested members cannot be supertypes\r", "+\t} else {\r", "+\t\tBinding typeOrPackage = parent.getTypeOrPackage(compoundName[0], TYPE | PACKAGE);\r", "+\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding()){\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound)); // record package ref\r", "+\t\t\treturn new ProblemReferenceBinding(compoundName[0], typeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "+\t\t}\r", "+\t\tboolean checkVisibility = false;\r", "+\t\tfor (; n < size; n++) {\r", "+\t\t\tif (!(typeOrPackage instanceof PackageBinding)) break;\r", "+\r", "+\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "+\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "+\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "+\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\tcompoundName[0],\r", "+\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t}\r", "-\t\t\tboolean checkVisibility = false;\r", "-\t\t\tfor (; n < size; n++) {\r", "-\t\t\t\tif (!(typeOrPackage instanceof PackageBinding))\r", "-\t\t\t\t\tbreak;\r", "+\t\t\tcheckVisibility = true;\r", "+\t\t}\r", "-\t\t\t\tPackageBinding packageBinding = (PackageBinding) typeOrPackage;\r", "-\t\t\t\tcompilationUnitScope().addNamespaceReference(packageBinding);\r", "-\t\t\t\ttypeOrPackage = packageBinding.getTypeOrPackage(compoundName[n]);\r", "-\t\t\t\tif (typeOrPackage == null || !typeOrPackage.isValidBinding())\r", "-\t\t\t\t\treturn new ProblemReferenceBinding(\r", "-\t\t\t\t\t\tCharOperation.subarray(compoundName, 0, n + 1),\r", "-\t\t\t\t\t\ttypeOrPackage == null ? NotFound : typeOrPackage.problemId());\r", "-\t\t\t\tcheckVisibility = true;\r", "-\t\t\t}\r", "-\r", "-\t\t\t// convert to a ReferenceBinding\r", "-\t\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "-\t\t\tcompilationUnitScope().addTypeReference(superType);\r", "-\r", "-\t\t\tif (checkVisibility\r", "-\t\t\t\t&& n == size) { // if we're finished and know the final supertype then check visibility\r", "-\t\t\t\tif (!superType.canBeSeenBy(sourceType.fPackage))\r", "-\t\t\t\t\t// its a toplevel type so just check package access\r", "+\t\t// convert to a ReferenceBinding\r", "+\t\tif (typeOrPackage instanceof PackageBinding) // error, the compoundName is a packageName\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tsuperType = (ReferenceBinding) typeOrPackage;\r", "+\t\tcompilationUnitScope().addTypeReference(superType);\r", "+\t\t\r", "+\t\tif (checkVisibility && n == size) { // if we're finished and know the final superinterface then check visibility\r", "+\t\t\tSourceTypeBinding enclosingSourceType = enclosingSourceType();\r", "+\t\t\tif (enclosingSourceType == null\r", "+\t\t\t\t? !superType.canBeSeenBy(sourceType.fPackage)\r", "+\t\t\t\t: !superType.canBeSeenBy(sourceType, enclosingSourceType))\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\t// at this point we know we have a type but we have to look for cycles\r", "-\t\twhile (true) {\r", "-\t\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "-\t\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "-\t\t\tif (detectCycle(sourceType, superType, typeReference))\r", "-\t\t\t\treturn null; // cycle error was already reported\r", "-\r", "-\t\t\tif (n >= size)\r", "-\t\t\t\tbreak;\r", "-\r", "-\t\t\t// retrieve the next member type\r", "-\t\t\tchar[] typeName = compoundName[n++];\r", "-\t\t\tsuperType = findMemberType(typeName, superType);\r", "-\t\t\tif (superType == null)\r", "-\t\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "-\t\t\tif (!superType.isValidBinding()) {\r", "-\t\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "-\t\t\t\treturn superType;\r", "-\t\t\t}\r", "-\t\t}\r", "-\t\treturn superType;\r", "-\t}\r", "+\t// at this point we know we have a type but we have to look for cycles\r", "+\twhile (true) {\r", "+\t\t// must detect cycles & force connection up the hierarchy... also handle cycles with binary types.\r", "+\t\t// must be guaranteed that the superType knows its entire hierarchy\r", "+\t\tif (detectCycle(sourceType, superType, typeReference))\r", "+\t\t\treturn null; // cycle error was already reported\r", "+\r", "+\t\tif (n >= size)\r", "+\t\t\tbreak;\r", "+\r", "+\t\t// retrieve the next member type\r", "+\t\tchar[] typeName = compoundName[n++];\r", "+\t\tsuperType = findMemberType(typeName, superType);\r", "+\t\tif (superType == null)\r", "+\t\t\treturn new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, n), NotFound);\r", "+\t\tif (!superType.isValidBinding()) {\r", "+\t\t\tsuperType.compoundName = CharOperation.subarray(compoundName, 0, n);\r", "+\t\t\treturn superType;\r", "+\t\t}\r", "+\treturn superType;\r", "+}\r"]}], "num": 37402}