{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1c79dce322b3e9d01d53c23d4987e61b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "08afe55439e7b7684589b56997a1a7b0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/ProcessorEnvImpl.java", "commitBeforeChange": "74cd39cf6e739108d05e5fe68e013caacb550927", "commitAfterChange": "8d179b274180ed6b0408715a3052c776545ec578", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": "     void addMessage(IFile resource,         \t\t        int start,      \t\t\t\tint end,                     Severity severity,                      String msg,                      int line,                     String[] arguments)", "signatureAfterChange": "     void addMessage(IFile resource,         \t\t        int start,      \t\t\t\tint end,                     Severity severity,                      String msg,                      int line,                     String[] arguments)", "diff": ["-    \t\treturn;   ", "+    \t\treturn;", "+    \t", "+    \t// Eclipse doesn't support INFO-level IProblems, so we send them to the log instead.", "+    \tif ( _phase != Phase.RECONCILE && severity == Severity.INFO) {", "+    \t\tStringBuilder sb = new StringBuilder();", "+    \t\tsb.append(\"Informational message reported by annotation processor:\\n\"); //$NON-NLS-1$", "+    \t\tsb.append(msg);", "+    \t\tsb.append(\"\\n\"); //$NON-NLS-1$", "+    \t\tif (resource != null) {", "+    \t\t\tsb.append(\"Resource=\"); //$NON-NLS-1$", "+    \t\t\tsb.append(resource.getName());", "+    \t\t\tsb.append(\"; \"); //$NON-NLS-1$", "+    \t\t}", "+    \t\tsb.append(\"starting offset=\"); //$NON-NLS-1$", "+    \t\tsb.append(start);", "+    \t\tsb.append(\"; ending offset=\"); //$NON-NLS-1$", "+    \t\tsb.append(end);", "+    \t\tsb.append(\"; line=\"); //$NON-NLS-1$", "+    \t\tsb.append(line);", "+    \t\tif (arguments != null) {", "+    \t\t\tsb.append(\"; arguments:\"); //$NON-NLS-1$", "+    \t\t\tfor (String s : arguments) {", "+    \t\t\t\tsb.append(\"\\n\"); //$NON-NLS-1$", "+    \t\t\t\tsb.append(s);", "+    \t\t\t}", "+    \t\t}", "+    \t\telse {", "+    \t\t\tsb.append(\"\\n\"); //$NON-NLS-1$", "+    \t\t}", "+    \t\tIStatus status = AptPlugin.createInfoStatus(null, sb.toString());", "+    \t\tAptPlugin.log(status);", "+    \t\treturn;", "+    \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0b35b6e6b85584c26296c7a6884059c6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 37, "methodNumberAfterChange": 23, "signatureBeforeChange": " public boolean innersNeedUpdate()", "signatureAfterChange": "  public boolean isCompatibleWith(TypeBinding targetType, final Scope scope)", "diff": ["+", "+public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {", "+\tif (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)", "+\t\treturn false;", "+\tTypeBinding originalExpectedType = this.expectedType;", "+\ttry {", "+\t\tthis.expectedType = targetType;", "+\t\t// No need to tunnel through overload resolution. this.binding is the MSMB.", "+\t\tMethodBinding method = isPolyExpression() ? ParameterizedGenericMethodBinding.computeCompatibleMethod18(this.binding.shallowOriginal(), this.argumentTypes, scope, this) : this.binding;", "+\t\tTypeBinding returnType;", "+\t\tif (method == null || !method.isValidBinding() || (returnType = method.returnType) == null || !returnType.isValidBinding())", "+\t\t\treturn false;", "+\t\tif (method == scope.environment().arrayClone)", "+\t\t\treturnType = this.actualReceiverType;", "+\t\treturn returnType != null && returnType.capture(scope, this.sourceEnd).isCompatibleWith(targetType, scope);", "+\t} finally {", "+\t\tthis.expectedType = originalExpectedType;", "+\t}", "+}", "-}", "-public boolean innersNeedUpdate() {", "-\treturn this.innerInferenceHelper != null;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "160f6a37168a4454839135168279f0a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "03e37ed5506ed50fa30b9f5aa42ff423995a94bd", "commitAfterChange": "4111f058addae7e2d753cc95bd7546b1f787e4c8", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 37, "signatureBeforeChange": " public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "signatureAfterChange": " public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType)", "diff": ["-\treturn toCharArray(methodSignature, methodName, parameterNames, fullyQualifyTypeNames, includeReturnType, false, false);", "-}", "+\tint firstParen = CharOperation.indexOf(C_PARAM_START, methodSignature);", "+\tif (firstParen == -1) {", "+\t}", "+\t", "+\tStringBuffer buffer = new StringBuffer(methodSignature.length + 10);", "+\t", "+\t// return type", "+\tif (includeReturnType) {", "+\t\tchar[] rts = getReturnType(methodSignature);", "+\t\tappendTypeSignature(rts, 0 , fullyQualifyTypeNames, buffer);", "+\t\tbuffer.append(' ');", "+\t}", "+\t", "+\t// selector", "+\tif (methodName != null) {", "+\t\tbuffer.append(methodName);", "+\t}", "+\t", "+\t// parameters", "+\tbuffer.append('(');", "+\tchar[][] pts = getParameterTypes(methodSignature);", "+\tfor (int i = 0; i < pts.length; i++) {", "+\t\tappendTypeSignature(pts[i], 0 , fullyQualifyTypeNames, buffer);", "+\t\tif (parameterNames != null) {", "+\t\t\tbuffer.append(' ');", "+\t\t\tbuffer.append(parameterNames[i]);", "+\t\t}", "+\t\tif (i != pts.length - 1) {", "+\t\t\tbuffer.append(',');", "+\t\t\tbuffer.append(' ');", "+\t\t}", "+\t}", "+\tbuffer.append(')');", "+\tchar[] result = new char[buffer.length()];", "+\tbuffer.getChars(0, buffer.length(), result, 0);", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "280fbffad2e15cf697a9aa88c5fab03e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "873da75562da82ecc0139d0cf1669b990982ce9b", "commitAfterChange": "f40a702f47347181893c10c4b6f7ca67652d025d", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber)", "signatureAfterChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber)", "diff": ["-\t\t\tfor (int i = 0; i < lineAttributeLength; i++) {", "+\t\t\tfor (int i = 0; i < lineAttributeLength - 1; i++) {", "+\t\t\tbuffer", "+\t\t\t\t.append(Util.bind(\"classfileformat.linenumbertablefrom\")) //$NON-NLS-1$", "+\t\t\t\t.append(lineattributesEntries[lineAttributeLength - 1][0])", "+\t\t\t\t.append(Util.bind(\"classfileformat.linenumbertableto\")) //$NON-NLS-1$", "+\t\t\t\t.append(lineattributesEntries[lineAttributeLength - 1][1])", "+\t\t\t\t.append(Util.bind(\"classfileformat.linenumbertableclose\")); //$NON-NLS-1$", "-\t\t\tfor (int i = 0; i < localVariableAttributeLength; i++) {", "+\t\t\tfor (int i = 0; i < localVariableAttributeLength - 1; i++) {", "+\t\t\tILocalVariableTableEntry localVariableTableEntry = localVariableTableEntries[localVariableAttributeLength - 1];", "+\t\t\tint startPC = localVariableTableEntry.getStartPC();", "+\t\t\tint length  = localVariableTableEntry.getLength();", "+\t\t\tbuffer", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablefrom\")) //$NON-NLS-1$", "+\t\t\t\t.append(startPC)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletableto\")) //$NON-NLS-1$", "+\t\t\t\t.append(startPC + length)", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalname\")) //$NON-NLS-1$", "+\t\t\t\t.append(localVariableTableEntry.getName())", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocalindex\")) //$NON-NLS-1$", "+\t\t\t\t.append(localVariableTableEntry.getIndex())", "+\t\t\t\t.append(Util.bind(\"classfileformat.localvariabletablelocaltype\")) //$NON-NLS-1$", "+\t\t\t\t.append(Signature.toCharArray(localVariableTableEntry.getDescriptor()));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2c9f05157eb83feccfa51fda4b1fa3bb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java", "commitBeforeChange": "10ccd52b581b1d4c41dd3b53901299736343ea5d", "commitAfterChange": "97f3eec8c4b51a2e96520e6a724a68ec7b14f566", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 5, "signatureBeforeChange": "  public double openableFillingRatio()", "signatureAfterChange": " public String toStringFillingRation(String prefix)", "diff": ["-public double openableFillingRatio() {", "-\treturn this.openableCache.fillingRatio();", "-}", "+public String toStringFillingRation(String prefix) {", "+\tStringBuffer buffer = new StringBuffer();", "+\tbuffer.append(prefix);", "+\tbuffer.append(\"Project cache: \"); //$NON-NLS-1$", "+\tbuffer.append(NumberFormat.getInstance().format(this.projectCache.fillingRatio()));", "+\tbuffer.append(\"%\\n\"); //$NON-NLS-1$", "+\tbuffer.append(prefix);", "+\tbuffer.append(\"Root cache: \"); //$NON-NLS-1$", "+\tbuffer.append(NumberFormat.getInstance().format(this.rootCache.fillingRatio()));", "+\tbuffer.append(\"%\\n\"); //$NON-NLS-1$", "+\tbuffer.append(prefix);", "+\tbuffer.append(\"Package cache: \"); //$NON-NLS-1$", "+\tbuffer.append(NumberFormat.getInstance().format(this.pkgCache.fillingRatio()));", "+\tbuffer.append(\"%\\n\"); //$NON-NLS-1$", "+\tbuffer.append(prefix);", "+\tbuffer.append(\"Openable cache: \"); //$NON-NLS-1$", "+\tbuffer.append(NumberFormat.getInstance().format(this.openableCache.fillingRatio()));", "+\tbuffer.append(\"%\\n\"); //$NON-NLS-1$", "+\treturn buffer.toString();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "308c244a6926046797e8826ade8de770", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "c65657c3db5994a0f7c7d598e6c69a8e236f8125", "commitAfterChange": "4d22b6cee44bdb8aa24a4ca5266770881b141e50", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic static CompilationUnit parseCompilationUnit( \t\tIClassFile classFile, \t\tboolean resolveBindings)", "signatureAfterChange": " \tpublic static CompilationUnit parseCompilationUnit( \t\tIClassFile classFile, \t\tboolean resolveBindings)", "diff": ["-\t\t\tString source = null;", "+\t\t\tchar[] source = null;", "+\t\t\tString sourceString = null;", "-\t\t\t\tsource = classFile.getSource();", "+\t\t\t\tsourceString = classFile.getSource();", "-\t\t\tif (source == null) {", "+\t\t\tif (sourceString == null) {", "-\t\t\t\treturn AST.parseCompilationUnit(source.toCharArray());", "+\t\t\t\treturn AST.parseCompilationUnit(source);", "-\t\t\treturn AST.parseCompilationUnit(", "-\t\t\t\tsource.toCharArray(),", "-\t\t\t\tclassFile.getElementName(),", "-\t\t\t\tclassFile.getJavaProject());", "+\t\t\t", "+\t\t\tsource = sourceString.toCharArray();", "+\t\t\tStringBuffer buffer = new StringBuffer(\".java\"); //$NON-NLS-1$", "+\t\t\t", "+\t\t\tString classFileName = classFile.getElementName(); // this includes the trailing .class", "+\t\t\tbuffer.insert(0, classFileName.toCharArray(), 0, classFileName.indexOf('.'));", "+\t\t\tIJavaProject project = classFile.getJavaProject();", "+\t\t\ttry {", "+\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration =", "+\t\t\t\t\tCompilationUnitResolver.resolve(", "+\t\t\t\t\t\tsource,", "+\t\t\t\t\t\tCharOperation.splitOn('.', classFile.getType().getPackageFragment().getElementName().toCharArray()),", "+\t\t\t\t\t\tbuffer.toString(),", "+\t\t\t\t\t\tproject,", "+\t\t\t\t\t\tnew AbstractSyntaxTreeVisitorAdapter());", "+\t\t\t\tASTConverter converter = new ASTConverter(project.getOptions(true), true);", "+\t\t\t\tAST ast = new AST();", "+\t\t\t\tBindingResolver resolver = new DefaultBindingResolver(compilationUnitDeclaration.scope);", "+\t\t\t\tast.setBindingResolver(resolver);", "+\t\t\t\tconverter.setAST(ast);", "+\t\t\t", "+\t\t\t\tCompilationUnit cu = converter.convert(compilationUnitDeclaration, source);", "+\t\t\t\tcu.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);", "+\t\t\t\tresolver.storeModificationCount(ast.modificationCount());", "+\t\t\t\treturn cu;", "+\t\t\t} catch(JavaModelException e) {", "+\t\t\t\t/* if a JavaModelException is thrown trying to retrieve the name environment", "+\t\t\t\t * then we simply do a parsing without creating bindings.", "+\t\t\t\t * Therefore all binding resolution will return null.", "+\t\t\t\t */", "+\t\t\t\treturn parseCompilationUnit(source);\t\t\t", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "316970d7caa95ec4184408f572e6b5ad", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 40, "signatureBeforeChange": " \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess expression)", "signatureAfterChange": "  \tpublic EnumDeclaration convert(org.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDeclaration)", "diff": ["-\t}", "-\tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess expression) {", "-\t\tTypeLiteral typeLiteral = this.ast.newTypeLiteral();", "-\t\tif (this.resolveBindings) {", "-\t\t\tthis.recordNodes(typeLiteral, expression);", "-\t\t}", "-\t\ttypeLiteral.setSourceRange(expression.sourceStart, expression.sourceEnd - expression.sourceStart + 1);", "-\t\ttypeLiteral.setType(convertType(expression.type));", "-\t\treturn typeLiteral;", "-\t}", "+", "+\tpublic EnumDeclaration convert(org.eclipse.jdt.internal.compiler.ast.EnumDeclaration enumDeclaration) {", "+\t\tcheckCanceled();", "+\t\tEnumDeclaration enumDeclaration2 = this.ast.newEnumDeclaration();", "+\t\tint modifiers = enumDeclaration.modifiers;", "+\t\tmodifiers &= ~IConstants.AccInterface; // remove AccInterface flags", "+\t\tmodifiers &= CompilerModifiers.AccJustFlag;", "+\t\tif (modifiers != 0) {", "+\t\t\tsetModifiers(enumDeclaration2, enumDeclaration);", "+\t\t}", "+\t\tSimpleName typeName = this.ast.newSimpleName(new String(enumDeclaration.name));", "+\t\ttypeName.setSourceRange(enumDeclaration.sourceStart, enumDeclaration.sourceEnd - enumDeclaration.sourceStart + 1);", "+\t\tenumDeclaration2.setName(typeName);", "+\t\tenumDeclaration2.setSourceRange(enumDeclaration.declarationSourceStart, enumDeclaration.bodyEnd - enumDeclaration.declarationSourceStart + 1);", "+\t\t", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference[] superInterfaces = enumDeclaration.superInterfaces;", "+\t\tif (superInterfaces != null) {", "+\t\t\tfor (int index = 0, length = superInterfaces.length; index < length; index++) {", "+\t\t\t\tenumDeclaration2.superInterfaceTypes().add(convertType(superInterfaces[index]));", "+\t\t\t}\t\t\t\t\t", "+\t\t}", "+\t\tbuildBodyDeclarations(enumDeclaration, enumDeclaration2);", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(enumDeclaration2, enumDeclaration);", "+\t\t\trecordNodes(typeName, enumDeclaration);", "+\t\t\tenumDeclaration2.resolveBinding();", "+\t\t}", "+\t\treturn enumDeclaration2;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "34f2ae786591e20fca9e5c09c1752932", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java", "commitBeforeChange": "34b4972480c62fc99b17d4728db2648e98460b52", "commitAfterChange": "a234173ab4d645c8990c97cafa00ec82ce0a909f", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException", "signatureAfterChange": " protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException", "diff": ["-\tfor (int i = 0, l = problems.length; i < l; i++) {", "+\tproblems: for (int i = 0, l = problems.length; i < l; i++) {", "+\t\t\tif (id == IProblem.MissingNonNullByDefaultAnnotationOnPackage && !(CharOperation.equals(sourceFile.getMainTypeName(), TypeConstants.PACKAGE_INFO_NAME))) {", "+\t\t\t\t// for this kind of problem, marker needs to be created on the package instead of on the source file", "+\t\t\t\t// see bug 372012", "+\t\t\t\tchar[] fileName = sourceFile.getFileName();", "+\t\t\t\tint pkgEnd = CharOperation.lastIndexOf('/', fileName);", "+\t\t\t\tif (pkgEnd == -1)", "+\t\t\t\t\tpkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);", "+\t\t\t\tPackageFragment pkg = null;", "+\t\t\t\tif (pkgEnd != -1)", "+\t\t\t\t\tpkg = (PackageFragment) Util.getPackageFragment(sourceFile.getFileName(), pkgEnd, -1 /*no jar separator for java files*/);", "+\t\t\t\t", "+\t\t\t\tif (pkg != null) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tIMarker[] existingMarkers = pkg.resource().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_ZERO);", "+\t\t\t\t\t\tint len = existingMarkers.length;", "+\t\t\t\t\t\tfor (int j=0; j < len; j++) {", "+\t\t\t\t\t\t\tif (((Integer)existingMarkers[j].getAttribute(IJavaModelMarker.ID)).intValue() == IProblem.MissingNonNullByDefaultAnnotationOnPackage) {", "+\t\t\t\t\t\t\t\tcontinue problems; // marker already present", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\t// marker retrieval failed, cannot do much", "+\t\t\t\t\t\tif (JavaModelManager.VERBOSE) {", "+\t\t\t\t\t\t\te.printStackTrace();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tIResource tempRes = pkg.resource();", "+\t\t\t\t\tif (tempRes != null) {", "+\t\t\t\t\t\tresource = tempRes;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3515e37805a3824b4222393a012b6c87", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprivate void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, boolean isDeclaration)", "signatureAfterChange": "  \tprivate void selectFrom(Binding binding, CompilationUnitDeclaration parsedUnit, boolean isDeclaration)", "diff": ["-\t\tif (binding instanceof ReferenceBinding) {", "+\t\tif(binding instanceof TypeVariableBinding) {", "+\t\t\tTypeVariableBinding typeVariableBinding = (TypeVariableBinding) binding;", "+\t\t\tBinding enclosingElement = typeVariableBinding.declaringElement;", "+\t\t\tthis.noProposal = false;", "+\t\t\t", "+\t\t\tif(enclosingElement instanceof SourceTypeBinding) {", "+\t\t\t\tSourceTypeBinding enclosingType = (SourceTypeBinding) enclosingElement;", "+\t\t\t\tthis.requestor.acceptTypeParameter(", "+\t\t\t\t\tenclosingType.qualifiedPackageName(),", "+\t\t\t\t\tenclosingType.qualifiedSourceName(),", "+\t\t\t\t\ttypeVariableBinding.sourceName(),", "+\t\t\t\t\tfalse,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t} else if(enclosingElement instanceof MethodBinding) {", "+\t\t\t\tMethodBinding enclosingMethod = (MethodBinding) enclosingElement;", "+\t\t\t\t", "+\t\t\t\tTypeBinding[] parameterTypes = enclosingMethod.parameters;", "+\t\t\t\tint length = parameterTypes.length;", "+\t\t\t\tchar[][] parameterPackageNames = new char[length][];", "+\t\t\t\tchar[][] parameterTypeNames = new char[length][];", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tparameterPackageNames[i] = parameterTypes[i].qualifiedPackageName();", "+\t\t\t\t\tparameterTypeNames[i] = parameterTypes[i].qualifiedSourceName();", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.requestor.acceptMethodTypeParameter(", "+\t\t\t\t\tenclosingMethod.declaringClass.qualifiedPackageName(),", "+\t\t\t\t\tenclosingMethod.declaringClass.qualifiedSourceName(),", "+\t\t\t\t\tenclosingMethod.selector,", "+\t\t\t\t\tparameterPackageNames,", "+\t\t\t\t\tparameterTypeNames,", "+\t\t\t\t\tenclosingMethod.isConstructor(),", "+\t\t\t\t\ttypeVariableBinding.sourceName(),", "+\t\t\t\t\tfalse,", "+\t\t\t\t\tthis.actualSelectionStart,", "+\t\t\t\t\tthis.actualSelectionEnd);", "+\t\t\t}", "+\t\t\tthis.acceptedAnswer = true;", "+\t\t} else if (binding instanceof ReferenceBinding) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "37e4757cac4a2837448f90d7b5a3a8ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java", "commitBeforeChange": "9221731a3d20320a45d9e6a6337379d8a431c366", "commitAfterChange": "a209bfa947ecc1f9f7050d0d851a03f725813152", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t@Override \tpublic String getConstantExpression(Object value)", "signatureAfterChange": " \t@Override \tpublic String getConstantExpression(Object value)", "diff": ["-\t\t\treturn String.valueOf(value)+'f';", "+\t\t\tStringBuilder builder = new StringBuilder();", "+\t\t\tbuilder.append(value).append('f');", "+\t\t\treturn String.valueOf(builder);", "-\t\t\treturn String.valueOf(value)+'L';", "+\t\t\tStringBuilder builder = new StringBuilder();", "+\t\t\tbuilder.append(value).append('L');", "+\t\t\treturn String.valueOf(builder);", "+\t\t} else if (value instanceof Short) {", "+\t\t\tStringBuilder builder = new StringBuilder();", "+\t\t\tbuilder.append(\"(short)\").append(value); //$NON-NLS-1$", "+\t\t\treturn String.valueOf(builder);", "+\t\t} else if (value instanceof Byte) {", "+\t\t\tStringBuilder builder = new StringBuilder();", "+\t\t\tbuilder.append(\"(byte)0x\"); //$NON-NLS-1$", "+\t\t\tint intValue = ((Byte) value).byteValue();", "+\t\t\tString hexString = Integer.toHexString(intValue & 0xFF);", "+\t\t\tif (hexString.length() < 2) {", "+\t\t\t\tbuilder.append('0');", "+\t\t\t}", "+\t\t\tbuilder.append(hexString);", "+\t\t\treturn String.valueOf(builder);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3fff6fb5d8b7b8b684ae3931a9162eb2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "38faf3efd9d7a9e66ede29f2210a34a5031698a0", "commitAfterChange": "102c35a2a8562c276abba3a19ac61f3d18639af8", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tprivate JavaElement getUnresolvedJavaElement(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding )", "signatureAfterChange": " \tprivate JavaElement getUnresolvedJavaElement(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding )", "diff": ["-\t\tif (Util.isClassFileName(fileName)) {", "-\t\t\tClassFile classFile = (ClassFile) getClassFile(fileName);", "-\t\t\tif (classFile == null) return null;", "-\t\t\treturn (JavaElement) classFile.getType();", "-\t\t}", "+\t\t\tif (Util.isClassFileName(fileName)) {", "+\t\t\t\tint jarSeparator = CharOperation.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, fileName);", "+\t\t\t\tint lastSlash = CharOperation.lastIndexOf('/', fileName);", "+\t\t\t\tif (lastSlash == -1) ", "+\t\t\t\t\tlastSlash = CharOperation.lastIndexOf(File.separatorChar, fileName);", "+\t\t\t\tif (lastSlash <= jarSeparator) // if jarSeparator == -1 and there is no slash, lastSlash should be 0", "+\t\t\t\t\tlastSlash = jarSeparator+1;", "+\t\t\t\tIPackageFragment pkg = getPackageFragment(fileName, lastSlash, jarSeparator);", "+\t\t\t\tchar[] constantPoolName = referenceBinding.constantPoolName();", "+\t\t\t\tif (constantPoolName == null) {", "+\t\t\t\t\tClassFile classFile = (ClassFile) getClassFile(fileName);", "+\t\t\t\t\treturn classFile == null ? null : (JavaElement) classFile.getType();", "+\t\t\t\t}", "+\t\t\t\tlastSlash = CharOperation.lastIndexOf('/', constantPoolName);", "+\t\t\t\tchar[] classFileName = CharOperation.subarray(constantPoolName, lastSlash+1, constantPoolName.length);", "+\t\t\t\tClassFile classFile = (ClassFile) pkg.getClassFile(new String(classFileName) + SuffixConstants.SUFFIX_STRING_class);", "+\t\t\t\treturn (JavaElement) classFile.getType();", "+\t\t\t}", "+\t\t\t\tif (Util.isClassFileName(fileName)) {", "+\t\t\t\t\tClassFile classFile = (ClassFile) getClassFile(fileName);", "+\t\t\t\t\tif (classFile == null) return null;", "+\t\t\t\t\treturn (JavaElement) classFile.getType();", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "46a6a807d7345f461132bd2958692ada", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "66f0e8b8112bb13bbbf568db765302c9834a0001", "commitAfterChange": "8173bc34d19a76799af83a37be998ec65b3a1874", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \t \tprivate void disassemble(ICodeAttribute codeAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["+\t\tboolean isFirstAttribute = true;", "+\t\t\tisFirstAttribute = false;", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLineAttribute);", "+\t\t\t} else {", "+\t\t\t\tdumpTab(tabNumberForLineAttribute, buffer);", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t}", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\t} else {", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t\tdumpTab(tabNumberForLocalVariableAttribute, buffer);", "+\t\t\t}", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\tif (!isFirstAttribute) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumberForLocalVariableAttribute);", "+\t\t\t} else {", "+\t\t\t\tisFirstAttribute = false;", "+\t\t\t\tdumpTab(tabNumberForLocalVariableAttribute, buffer);", "+\t\t\t}", "-\t\t\t\t\tdisassemble((StackMapTableAttribute) attribute, buffer, lineSeparator, tabNumber + 1, mode);", "+\t\t\t\t\tIStackMapTableAttribute stackMapTableAttribute = (IStackMapTableAttribute) attribute;", "+\t\t\t\t\tif (!isFirstAttribute) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tisFirstAttribute = false;", "+\t\t\t\t\t\tdumpTab(tabNumber + 1, buffer);", "+\t\t\t\t\t}", "+\t\t\t\t\tint numberOfEntries = stackMapTableAttribute.getNumberOfEntries();", "+\t\t\t\t\tbuffer.append(Messages.bind(Messages.disassembler_stackmaptableattributeheader, Integer.toString(numberOfEntries)));", "+\t\t\t\t\tif (numberOfEntries != 0) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 3);", "+\t\t\t\t\t\tfinal IStackMapFrame[] stackMapFrames = stackMapTableAttribute.getStackMapFrame();", "+\t\t\t\t\t\tfor (int j = 0; j < numberOfEntries; j++) {", "+\t\t\t\t\t\t\tdisassemble(stackMapFrames[j], buffer, lineSeparator, tabNumber + 2, mode);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "-\t\t\t\t\tdisassemble(attribute, buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t\tif (!isFirstAttribute) {", "+\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 2);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tisFirstAttribute = false;", "+\t\t\t\t\t\tdumpTab(tabNumber + 1, buffer);", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(Messages.bind(Messages.disassembler_genericattributeheader,", "+\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\tnew String(attribute.getAttributeName()),", "+\t\t\t\t\t\t\tLong.toString(attribute.getAttributeLength())", "+\t\t\t\t\t\t}));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "48c261a6ec80d1fbd8f1f728e34ca497", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "signatureAfterChange": " \tpublic void resourceChanged(IResourceChangeEvent event)", "diff": ["+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate classpath change deltas", "+\t\t\t\t\t\t\t\tif (this.classpathChanges.size() > 0) {", "+\t\t\t\t\t\t\t\t\tboolean hasDelta = this.currentDelta != null;", "+\t\t\t\t\t\t\t\t\tJavaElementDelta javaDelta = currentDelta();", "+\t\t\t\t\t\t\t\t\tIterator changes = this.classpathChanges.values().iterator();", "+\t\t\t\t\t\t\t\t\twhile (changes.hasNext()) {", "+\t\t\t\t\t\t\t\t\t\tClasspathChange change = (ClasspathChange) changes.next();", "+\t\t\t\t\t\t\t\t\t\tif (change.generateDelta(javaDelta)) {", "+\t\t\t\t\t\t\t\t\t\t\thasDelta = true;", "+\t\t\t\t\t\t\t\t\t\t\tchange.requestIndexing();", "+\t\t\t\t\t\t\t\t\t\t\tthis.state.addClasspathValidation(change.project);", "+\t\t\t\t\t\t\t\t\t\t\tthis.state.addProjectReferenceChange(change.project, change.oldResolvedClasspath);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tthis.classpathChanges.clear();", "+\t\t\t\t\t\t\t\t\tif (!hasDelta)", "+\t\t\t\t\t\t\t\t\t\tthis.currentDelta = null;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate external archive change deltas", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t// generate Java deltas from resource changes", "-\t\t\t\t\t\t\tthis.removedRoots = null;", "+\t\t\t\t\t\t\tthis.oldRoots = null;", "-\t\t\t\t    DeltaProcessingState.ProjectUpdateInfo[] updates = this.state.removeAllProjectUpdates();", "-\t\t\t\t\tif (updates != null) {", "-\t\t\t\t\t    for (int i = 0, length = updates.length; i < length; i++) {", "+\t\t\t\t\tif(!isAffectedBy(delta))", "+\t\t\t\t\t\treturn; // avoid populating for SYNC or MARKER deltas", "+", "+\t\t\t\t\t// create classpath markers if necessary", "+\t\t\t\t\tvalidateClasspaths(delta);", "+\t\t\t\t\tClasspathValidation[] validations = this.state.removeClasspathValidations();", "+\t\t\t\t\tif (validations != null) {", "+\t\t\t\t\t\tfor (int i = 0, length = validations.length; i < length; i++) {", "+\t\t\t\t\t\t\tClasspathValidation validation = validations[i];", "+\t\t\t\t\t\t\tvalidation.validate();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// update all cycle markers since the classpath changes may have affected cycles", "+\t\t\t\t\t\ttry {", "+\t\t\t\t\t\t\tJavaProject.validateCycles(null);", "+\t\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t\t// a project no longer exist", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\t// update project references if necessary", "+\t\t\t\t    ProjectReferenceChange[] projectRefChanges = this.state.removeProjectReferenceChanges();", "+\t\t\t\t\tif (projectRefChanges != null) {", "+\t\t\t\t\t    for (int i = 0, length = projectRefChanges.length; i < length; i++) {", "-\t\t\t\t\t\t        updates[i].updateProjectReferencesIfNecessary();", "+\t\t\t\t\t\t        projectRefChanges[i].updateProjectReferencesIfNecessary();", "-\t\t\t\t\t            // do nothing", "+\t\t\t\t\t            // project doesn't exist any longer, continue with next one", "-\t\t\t\t\t// this.processPostChange = false;", "-\t\t\t\t\tif(isAffectedBy(delta)) { // avoid populating for SYNC or MARKER deltas", "-\t\t\t\t\t\tupdateClasspathMarkers(delta, updates);", "-\t\t\t\t\t\tJavaBuilder.buildStarting();", "-\t\t\t\t\t}", "+\t\t\t\t\t", "+\t\t\t\t\tJavaModel.flushExternalFileCache();", "+\t\t\t\t\tJavaBuilder.buildStarting();", "+\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4bdd2ec21767b4456a770d81574f8092", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java", "commitBeforeChange": "d752b26e3a6a22a0d2aea83eca1f4ca2bd2e36dd", "commitAfterChange": "24134b187b46ea16212a45107324227f46ba3e4a", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 54, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\treturn null;", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tbuffer.append(\"Recovered#\"); //$NON-NLS-1$", "+\t\tif (this.innerTypeBinding != null) {", "+\t\t\tbuffer.append(\"innerTypeBinding\") //$NON-NLS-1$", "+\t\t\t      .append(this.innerTypeBinding.getKey());", "+\t\t} else if (this.currentType != null) {", "+\t\t\tbuffer.append(\"currentType\") //$NON-NLS-1$", "+\t\t\t      .append(this.currentType.toString());", "+\t\t} else if (this.referenceBinding != null) {", "+\t\t\tbuffer.append(\"referenceBinding\") //$NON-NLS-1$", "+\t\t\t\t  .append(this.referenceBinding.computeUniqueKey());", "+\t\t} else if (variableDeclaration != null) {", "+\t\t\tbuffer", "+\t\t\t\t.append(\"variableDeclaration\") //$NON-NLS-1$", "+\t\t\t\t.append(this.variableDeclaration.getClass())", "+\t\t\t\t.append(this.variableDeclaration.getName().getIdentifier())", "+\t\t\t\t.append(this.variableDeclaration.getExtraDimensions());", "+\t\t}", "+\t\tbuffer.append(this.getDimensions());", "+\t\tif (this.typeArguments != null) {", "+\t\t\tbuffer.append('<');", "+\t\t\tfor (int i = 0, max = this.typeArguments.length; i < max; i++) {", "+\t\t\t\tif (i != 0) {", "+\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t}", "+\t\t\t\tbuffer.append(this.typeArguments[i].getKey());", "+\t\t\t}", "+\t\t\tbuffer.append('>');", "+\t\t}", "+\t\treturn String.valueOf(buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "52e356ff8801a927d941ce08f0238135", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java", "commitBeforeChange": "34746595229d52daf40c32629450d7fae4966422", "commitAfterChange": "88853c38c7298f1ea978b5ada5033a497eb024c5", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic boolean isStandardLabel()", "signatureAfterChange": " public String toString()", "diff": ["-\tpublic boolean isStandardLabel(){", "-", "-\t\treturn false;", "+}", "+public String toString() {", "+\tString basic = getClass().getName();", "+\tbasic = basic.substring(basic.lastIndexOf('.')+1);", "+\tStringBuffer buffer = new StringBuffer(basic); ", "+\tbuffer.append('@').append(Integer.toHexString(hashCode()));", "+\tbuffer.append(\"(type=\").append(this.exceptionType == null ? null : this.exceptionType.readableName()); //$NON-NLS-1$", "+\tbuffer.append(\", position=\").append(position); //$NON-NLS-1$", "+\tbuffer.append(\", ranges = \"); //$NON-NLS-1$", "+\tif (this.count == 0) {", "+\t\tbuffer.append(\"[]\"); //$NON-NLS-1$", "+\t} else {", "+\t\tfor (int i = 0; i < this.count; i++) {", "+\t\t\tif (i % 2 == 0) {", "+\t\t\t\tbuffer.append(\"[\").append(ranges[i]); //$NON-NLS-1$", "+\t\t\t} else { ", "+\t\t\t\tbuffer.append(\",\").append(ranges[i]).append(\"]\"); //$NON-NLS-1$ //$NON-NLS-2$", "+\t\t\t}", "+\t\t}", "+\t\tif (this.count % 2 == 1) {", "+\t\t\tbuffer.append(\",?]\"); //$NON-NLS-1$", "+\t\t}", "+\tbuffer.append(')'); //$NON-NLS-1$", "+\treturn buffer.toString();", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "594ac83e26fcff86ae6f516a0136d965", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java", "commitBeforeChange": "93ae272625cf7aea539e03a762b5190105386996", "commitAfterChange": "c6f78f890c1ca00b0157b632da091fae2c781833", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": "  \tprivate TextEdit probeFormatting(String source, int indentationLevel, String lineSeparator, int offset, int length)", "signatureAfterChange": "  \tprivate TextEdit probeFormatting(String source, int indentationLevel, String lineSeparator, int offset, int length)", "diff": ["-\t\t// TODO (olivier) add probing for comment formatting", "+\t\tif (ProbingScanner == null) {", "+\t\t\t// scanner use to check if the kind could be K_JAVA_DOC, K_MULTI_LINE_COMMENT or K_SINGLE_LINE_COMMENT ", "+\t\t\tProbingScanner = new Scanner(true, true, false/*nls*/, ClassFileConstants.JDK1_3, ClassFileConstants.JDK1_3, null/*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/);", "+\t\t}", "+\t\tProbingScanner.setSource(source.toCharArray());", "+\t\tProbingScanner.resetTo(offset, offset + length);", "+\t\ttry {", "+\t\t\tswitch(ProbingScanner.getNextToken()) {", "+\t\t\t\tcase ITerminalSymbols.TokenNameCOMMENT_BLOCK :", "+\t\t\t\t\tif (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {", "+\t\t\t\t\t\treturn formatComment(K_MULTI_LINE_COMMENT, source, indentationLevel, lineSeparator, offset, length);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase ITerminalSymbols.TokenNameCOMMENT_LINE :", "+\t\t\t\t\tif (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {", "+\t\t\t\t\t\treturn formatComment(K_SINGLE_LINE_COMMENT, source, indentationLevel, lineSeparator, offset, length);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase ITerminalSymbols.TokenNameCOMMENT_JAVADOC :", "+\t\t\t\t\tif (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {", "+\t\t\t\t\t\treturn formatComment(K_JAVA_DOC, source, indentationLevel, lineSeparator, offset, length);", "+\t\t\t\t\t}", "+\t\t\t}", "+\t\t} catch (InvalidInputException e) {", "+\t\t\t// ignore", "+\t\t}", "+\t\tProbingScanner.setSource((char[]) null);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5bec096efcc6d198f80e2939e6b24a3a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldDeclaration.java", "commitBeforeChange": "8c93d4e99b8a943865cb7391e781eba5bb83dfc9", "commitAfterChange": "bd0edd7688142c1743cb6b10766dfc576040f113", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo)", "diff": ["-public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo) {", "+public FlowInfo analyseCode(MethodScope initializationScope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo declaringClassFlowInfo, FlowInfo fieldResetInfo) {", "+\t// fieldResetInfo: in this info we collect all information required for UnconditionalFlowInfo.resetNullInfoForFields:", "+\t// - which fields should never reset their null status? (constants and @NonNull)", "+\t// - for other fields: to what status should it be reset at each MessageSend? (unknown or pot.null)", "+\tboolean isConstant = this.binding.isFinal() && this.binding.isStatic();", "+\tboolean includeFieldsInNullAnalysis = initializationScope.compilerOptions().includeFieldsInNullAnalysis;", "-\t\tif (this.binding.isFinal() && this.binding.isStatic()) {", "+\t\tif (isConstant && includeFieldsInNullAnalysis) {", "-//\t\t\tthis.binding.setNullStatusForStaticFinalField(nullStatus);", "+\t}", "+\tif (isConstant && includeFieldsInNullAnalysis) {", "+\t\t// never reset null status for constants", "+\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "+\t}", "+\tlong tagBits = this.binding.tagBits;", "+\tif ((tagBits & TagBits.AnnotationNonNull) != 0) {", "+\t\tif (this.initialization != null) {", "+\t\t\tint nullStatus = this.initialization.nullStatus(flowInfo);", "+\t\t\t// check against annotation @NonNull:", "+\t\t\tif (nullStatus != FlowInfo.NON_NULL) {", "+\t\t\t\tchar[][] annotationName = initializationScope.environment().getNonNullAnnotationName();", "+\t\t\t\tinitializationScope.problemReporter().nullityMismatch(this.initialization, this.binding.type, nullStatus, annotationName);", "+\t\t\t}", "+\t\t}", "+\t\t// record nonnull for use by methods:", "+\t\tdeclaringClassFlowInfo.markAsDefinitelyNonNull(this.binding);", "+", "+\t\t// tell resetNullInfoForFields not to update this field's status", "+\t\tfieldResetInfo.updateConstantFieldsMask(this.binding);", "+\t} else if ((tagBits & TagBits.AnnotationNullable) != 0) {", "+\t\t// record pot.null for use by methods:", "+\t\tdeclaringClassFlowInfo.resetNullInfo(this.binding);", "+\t\tdeclaringClassFlowInfo.markPotentiallyNullBit(this.binding);", "+", "+\t\t// tell resetNullInfoForFields to reset this field to pot.null:", "+\t\t// (note that this info is ineffective if the field is also constant)", "+\t\tfieldResetInfo.resetNullInfo(this.binding);", "+\t\tfieldResetInfo.markPotentiallyNullBit(this.binding);", "+\t} else if (!isConstant && includeFieldsInNullAnalysis) {", "+\t\t// tell resetNullInfoForFields to reset this field to def.unknown:", "+\t\tfieldResetInfo.markAsDefinitelyUnknown(this.binding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "603cb7d52f5206f2e3204566d7b80904", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "a253e12d0e5500dde78cb361a701e1e0a42cc195", "commitAfterChange": "e6906c72fd0737bba033cc849684f3e2192fc730", "methodNumberBeforeChange": 64, "methodNumberAfterChange": 64, "signatureBeforeChange": " public void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " public void configure(String[] argv) throws InvalidInputException", "diff": ["-\t\t\t\t\tif (this.destinationPath != null)", "+\t\t\t\t\tif (this.destinationPath != null) {", "+\t\t\t\t\t\tStringBuffer errorMessage = new StringBuffer();", "+\t\t\t\t\t\terrorMessage.append(currentArg);", "+\t\t\t\t\t\tif ((index + 1) < argCount) {", "+\t\t\t\t\t\t\terrorMessage.append(' ');", "+\t\t\t\t\t\t\terrorMessage.append(newCommandLineArgs[index + 1]);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMain.bind(\"configure.duplicateOutputPath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\tMain.bind(\"configure.duplicateOutputPath\", errorMessage.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "-\t\t\t\t\tif (bootclasspaths.size() > 0)", "+\t\t\t\t\tif (bootclasspaths.size() > 0) {", "+\t\t\t\t\t\tStringBuffer errorMessage = new StringBuffer();", "+\t\t\t\t\t\terrorMessage.append(currentArg);", "+\t\t\t\t\t\tif ((index + 1) < argCount) {", "+\t\t\t\t\t\t\terrorMessage.append(' ');", "+\t\t\t\t\t\t\terrorMessage.append(newCommandLineArgs[index + 1]);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMain.bind(\"configure.duplicateBootClasspath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\tMain.bind(\"configure.duplicateBootClasspath\", errorMessage.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "-\t\t\t\t\tif (sourcepathClasspaths.size() > 0)", "+\t\t\t\t\tif (sourcepathClasspaths.size() > 0) {", "+\t\t\t\t\t\tStringBuffer errorMessage = new StringBuffer();", "+\t\t\t\t\t\terrorMessage.append(currentArg);", "+\t\t\t\t\t\tif ((index + 1) < argCount) {", "+\t\t\t\t\t\t\terrorMessage.append(' ');", "+\t\t\t\t\t\t\terrorMessage.append(newCommandLineArgs[index + 1]);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMain.bind(\"configure.duplicateSourcepath\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\tMain.bind(\"configure.duplicateSourcepath\", errorMessage.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}", "-\t\t\t\t\tif (extdirsNames.size() > 0)", "+\t\t\t\t\tif (extdirsNames.size() > 0) {", "+\t\t\t\t\t\tStringBuffer errorMessage = new StringBuffer();", "+\t\t\t\t\t\terrorMessage.append(currentArg);", "+\t\t\t\t\t\tif ((index + 1) < argCount) {", "+\t\t\t\t\t\t\terrorMessage.append(' ');", "+\t\t\t\t\t\t\terrorMessage.append(newCommandLineArgs[index + 1]);", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tMain.bind(\"configure.duplicateExtdirs\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\tMain.bind(\"configure.duplicateExtdirs\", errorMessage.toString())); //$NON-NLS-1$", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "683ee9f7e7fb64eec2a541d4a0a2ecb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "4e300efc6879ebefc1e17424cda019b7c5ca9ad1", "commitAfterChange": "d836cbee8ecc949f19e7decf6adae6126ae2b267", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "\r public void add(IResource element)", "signatureAfterChange": "\r \r public void add(IJavaProject javaProject, boolean includesPrereqProjects, Hashtable visitedProjects) throws JavaModelException", "diff": ["- */\r", "-public void add(IResource element) {\r", "-\tthis.add(element, true);\r", "-}\r", "+public void add(IJavaProject javaProject, boolean includesPrereqProjects, Hashtable visitedProjects) throws JavaModelException {\r", "+\tIProject project = javaProject.getProject();\r", "+\tif (!project.isAccessible() || visitedProjects.get(project) != null) return;\r", "+\tthis.addEnclosingProjectOrJar(project.getFullPath());\r", "+\r", "+\tIWorkspaceRoot root = project.getWorkspace().getRoot();\r", "+\tIClasspathEntry[] entries = javaProject.getResolvedClasspath(true);\r", "+\tIJavaModel model = javaProject.getJavaModel();\r", "+\t\t\t\tthis.add(entry.getPath(), true);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6c30326cb8d870cd9820609f2e9607f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/MovePackageFragmentRootOperation.java", "commitBeforeChange": "7a0f7a0578e7db65e3230a9b47f63ddf8bbaf581", "commitAfterChange": "39ddd9d45288a92edcd3f72a719183c283bd2afb", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " \tprotected void renameEntryInClasspath(IPath rootPath, IJavaProject project) throws JavaModelException", "signatureAfterChange": " \tprotected void renameEntryInClasspath(IPath rootPath, IJavaProject project) throws JavaModelException", "diff": ["+\t\t\t} else if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {", "+\t\t\t\t// update exclusion/inclusion patterns", "+\t\t\t\tIPath projectRelativePath = rootPath.removeFirstSegments(1);", "+\t\t\t\tIPath[] newExclusionPatterns = renamePatterns(projectRelativePath, entry.getExclusionPatterns());", "+\t\t\t\tIPath[] newInclusionPatterns = renamePatterns(projectRelativePath, entry.getInclusionPatterns());", "+\t\t\t\tif (newExclusionPatterns != null || newInclusionPatterns != null) {", "+\t\t\t\t\tif (newClasspath == null) {", "+\t\t\t\t\t\tnewClasspath = new IClasspathEntry[cpLength];", "+\t\t\t\t\t\tSystem.arraycopy(classpath, 0, newClasspath, 0, i);", "+\t\t\t\t\t\tnewCPIndex = i;", "+\t\t\t\t\t}", "+\t\t\t\t\tnewClasspath[newCPIndex++] = ", "+\t\t\t\t\t\tJavaCore.newSourceEntry(", "+\t\t\t\t\t\t\tentry.getPath(), ", "+\t\t\t\t\t\t\tnewInclusionPatterns == null ? entry.getInclusionPatterns() : newInclusionPatterns, ", "+\t\t\t\t\t\t\tnewExclusionPatterns == null ? entry.getExclusionPatterns() : newExclusionPatterns, ", "+\t\t\t\t\t\t\tentry.getOutputLocation(), ", "+\t\t\t\t\t\t\tentry.getExtraAttributes());", "+\t\t\t\t} else if (newClasspath != null) {", "+\t\t\t\t\tnewClasspath[newCPIndex++] = entry;", "+\t\t\t\t}", "-\t\t\tproject.setRawClasspath(newClasspath, progressMonitor);", "+\t\t\tIJavaModelStatus status = JavaConventions.validateClasspath(project, newClasspath, project.getOutputLocation());", "+\t\t\tif (status.isOK())", "+\t\t\t\tproject.setRawClasspath(newClasspath, progressMonitor);", "+\t\t\t// don't update classpath if status is not ok to avoid JavaModelException (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=129991)"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6d301602587b4cf9b488f828e9a391f4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprotected final boolean areParametersAssignable(TypeBinding[] parameters, TypeBinding[] arguments)", "signatureAfterChange": " \tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite)", "diff": ["-\t// Internal use only", "-\tprotected final boolean areParametersAssignable(TypeBinding[] parameters, TypeBinding[] arguments) {", "-\t\tif (parameters == arguments)", "-\t\t\treturn true;", "-", "-\t\tint length = parameters.length;", "-\t\tif (length != arguments.length)", "-\t\t\treturn false;", "-", "-\t\tfor (int i = 0; i < length; i++)", "-\t\t\tif (parameters[i] != arguments[i])", "-\t\t\t\tif (!arguments[i].isCompatibleWith(parameters[i]))", "-\t\t\t\t\treturn false;", "-\t\treturn true;", "-\t}", "+\t */", "+\tprotected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite) {", "+", "+\t\tTypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();", "+\t\tTypeBinding[] parameters = method.parameters;", "+\t\tif (parameters == arguments ", "+\t\t\t\t&& (method.returnType.tagBits & HasTypeVariable) == 0 ", "+\t\t\t\t&& genericTypeArguments == null)", "+\t\t\treturn method;", "+", "+\t\tint argLength = arguments.length;", "+\t\tif (argLength != parameters.length)", "+\t\t\treturn null; // incompatible", "+", "+\t\tTypeVariableBinding[] typeVariables = method.typeVariables;", "+\t\tif (typeVariables != NoTypeVariables) { // generic method", "+\t\t\tmethod = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);", "+\t\t\tif (method == null) return null; // incompatible", "+\t\t\tif (!method.isValidBinding()) return method; // bound check issue is taking precedence", "+\t\t\tparameters = method.parameters; // reacquire them after type inference has performed", "+\t\t} else if (genericTypeArguments != null && !(method instanceof ParameterizedGenericMethodBinding)) {", "+\t\t\treturn new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeParameterArityMismatch);", "+\t\t}", "+\t\t", "+\t\targumentCompatibility: {", "+\t\t\tfor (int i = 0; i < argLength; i++)", "+\t\t\t\tif (parameters[i] != arguments[i] && !arguments[i].isCompatibleWith(parameters[i]))", "+\t\t\t\t\tbreak argumentCompatibility;", "+\t\t\treturn method; // compatible", "+\t\t}", "+\t\tif (genericTypeArguments != null) {", "+\t\t\treturn new ProblemMethodBinding(method, method.selector, arguments, ParameterizedMethodTypeMismatch);", "+\t\t}", "+\t\treturn null; // incompatible", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6e7744039f3cc09b0a16569eb0e8998a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "98c08ded096494364ca74f948e8f494b3f447e89", "commitAfterChange": "423cede7ef9cde15030dc54ef2266be4ddcc9112", "methodNumberBeforeChange": 86, "methodNumberAfterChange": 86, "signatureBeforeChange": " protected ArrayList handleClasspath(ArrayList classpaths, String customEncoding) throws InvalidInputException", "signatureAfterChange": " protected ArrayList handleClasspath(ArrayList classpaths, String customEncoding) throws InvalidInputException", "diff": ["-\treturn classpaths;", "+\tArrayList result = new ArrayList();", "+\tHashMap knownNames = new HashMap();", "+\tFileSystem.ClasspathSectionProblemReporter problemReporter =", "+\t\tnew FileSystem.ClasspathSectionProblemReporter() {", "+\t\t\tpublic void invalidClasspathSection(String jarFilePath) {", "+\t\t\t\taddPendingErrors(bind(\"configure.invalidClasspathSection\", jarFilePath)); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\tpublic void multipleClasspathSections(String jarFilePath) {", "+\t\t\t\taddPendingErrors(bind(\"configure.multipleClasspathSections\", jarFilePath)); //$NON-NLS-1$", "+\t\t\t}", "+\t\t};", "+\twhile (! classpaths.isEmpty()) {", "+\t\tClasspath current = (Classpath) classpaths.remove(0);", "+\t\tString currentPath = current.getPath();", "+\t\tif (knownNames.get(currentPath) == null) {", "+\t\t\tknownNames.put(currentPath, current);", "+\t\t\tresult.add(current);", "+\t\t\tList linkedJars = current.fetchLinkedJars(problemReporter);", "+\t\t\tif (linkedJars != null) {", "+\t\t\t\tclasspaths.addAll(0, linkedJars);", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "75088f455013e85aed46d7626b27c8a6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "43bf4677e87b76a460506f46871dac9cbe16b176", "commitAfterChange": "f13a740e3b814a194962fd0ef85df91efde745be", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 39, "signatureBeforeChange": " \tprivate void findMemberTypes( \t\tchar[] typeName, \t\tReferenceBinding[] memberTypes, \t\tObjectVector typesFound, \t\tReferenceBinding receiverType, \t\tSourceTypeBinding invocationType, \t\tboolean staticOnly)", "signatureAfterChange": " \tprivate void findMemberTypes( \t\tchar[] typeName, \t\tReferenceBinding[] memberTypes, \t\tObjectVector typesFound, \t\tReferenceBinding receiverType, \t\tSourceTypeBinding invocationType, \t\tboolean staticOnly, \t\tboolean fromStaticImport, \t\tboolean checkQualification)", "diff": ["-\t\tboolean staticOnly) {", "+\t\tboolean staticOnly,", "+\t\tboolean fromStaticImport,", "+\t\tboolean checkQualification) {", "+\t\t\tif(!this.insideQualifiedReference && PROPOSE_MEMBER_TYPES) {", "+\t\t\t\tif(this.assistNodeIsClass) {", "+\t\t\t\t\tif(!memberType.isClass()) continue next;", "+\t\t\t\t} else if(this.assistNodeIsInterface) {", "+\t\t\t\t\tif(!memberType.isInterface() && !memberType.isAnnotationType()) continue next;", "+\t\t\t\t} else if (this.assistNodeIsAnnotation) {", "+\t\t\t\t\tif(!memberType.isAnnotationType()) continue next;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tchar[] completionName = memberType.sourceName();", "+\t\t\t", "+\t\t\tboolean isQualified = false;", "+\t\t\tif(checkQualification && !fromStaticImport) {", "+\t\t\t\tchar[] memberPackageName = memberType.qualifiedPackageName();", "+\t\t\t\tchar[] memberTypeName = memberType.sourceName();", "+\t\t\t\tchar[] memberEnclosingTypeNames = memberType.enclosingType().qualifiedSourceName();", "+\t\t\t\tif (mustQualifyType(memberPackageName, memberTypeName, memberEnclosingTypeNames, memberType.modifiers)) {", "+\t\t\t\t\tif (memberPackageName == null || memberPackageName.length == 0)", "+\t\t\t\t\t\tif (this.unitScope != null && this.unitScope.fPackage.compoundName != CharOperation.NO_CHAR_CHAR)", "+\t\t\t\t\t\t\tbreak next; // ignore types from the default package from outside it", "+\t\t\t\t\tisQualified = true;", "+\t\t\t\t\tcompletionName =", "+\t\t\t\t\t\tCharOperation.concat(", "+\t\t\t\t\t\t\t\tmemberPackageName,", "+\t\t\t\t\t\t\t\tCharOperation.concat(", "+\t\t\t\t\t\t\t\t\t\tmemberEnclosingTypeNames,", "+\t\t\t\t\t\t\t\t\t\tmemberTypeName,", "+\t\t\t\t\t\t\t\t\t\t'.'),", "+\t\t\t\t\t\t\t\t'.');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\tif(!insideQualifiedReference) {", "+\t\t\t\trelevance += computeRelevanceForQualification(isQualified);", "+\t\t\t}", "-\t\t\t\tproposal.setCompletion(memberType.sourceName());", "+\t\t\t\tproposal.setCompletion(completionName);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7784dc96e8a0c1624bc5f46d1456af30", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeDeclarationPattern.java", "commitBeforeChange": "cbf4d8b0c602d0860355a0bb315f58708fa257d2", "commitAfterChange": "0d8c4f28f9db6373751aa6d7cffbf4e0fcb51948", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 7, "signatureBeforeChange": " protected char[] indexEntryPrefix()", "signatureAfterChange": " protected char[] indexEntryPrefix()", "diff": ["-protected char[] indexEntryPrefix(){", "-\treturn AbstractIndexer.bestTypeDeclarationPrefix(pkg, simpleName, classOrInterface, matchMode, isCaseSensitive);", "+protected char[] indexEntryPrefix() {", "+\tchar[] packageName = this.isCaseSensitive ? pkg : null;", "+\tswitch(this.classOrInterface) {", "+\t\tcase CLASS_SUFFIX :", "+\t\t\tif (packageName == null) return CLASS_DECL;", "+\t\t\tbreak;", "+\t\tcase INTERFACE_SUFFIX :", "+\t\t\tif (packageName == null) return INTERFACE_DECL;", "+\t\t\tbreak;", "+\t\tdefault :", "+\t\t\treturn TYPE_DECL; // cannot do better given encoding", "+\t}", "+", "+\tchar[] typeName = this.isCaseSensitive ? simpleName : null;", "+\tif (typeName != null && this.matchMode == PATTERN_MATCH) {", "+\t\tint starPos = CharOperation.indexOf('*', typeName);", "+\t\tswitch(starPos) {", "+\t\t\tcase -1 :", "+\t\t\t\tbreak;", "+\t\t\tcase 0 :", "+\t\t\t\ttypeName = null;", "+\t\t\t\tbreak;", "+\t\t\tdefault : ", "+\t\t\t\ttypeName = CharOperation.subarray(typeName, 0, starPos);", "+\t\t}", "+\t}", "+", "+\tint packageLength = packageName.length;", "+\tint typeLength = typeName == null ? 0 : typeName.length;", "+\tint pos = TYPE_DECL_LENGTH;", "+\tchar[] result = new char[pos + packageLength + typeLength + 3];", "+\tSystem.arraycopy(TYPE_DECL, 0, result, 0, pos);", "+\tresult[pos++] = classOrInterface;", "+\tresult[pos++] = SEPARATOR;", "+\tSystem.arraycopy(packageName, 0, result, pos, packageLength);", "+\tpos += packageLength;", "+\tresult[pos++] = SEPARATOR;", "+\tif (typeLength > 0)", "+\t\tSystem.arraycopy(typeName, 0, result, pos, typeName.length);", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "82c96e19d63567da3785fa69aa2c5c76", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/AbstractCommentParser.java", "commitBeforeChange": "b9495a9cef3d68a9dfd6b29b27e2e36ed75f4620", "commitAfterChange": "6897b6240cf6b9585a3dd2a75157f0669f6dd5c1", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "signatureAfterChange": " \tprotected boolean parseComment(int javadocStart, int javadocEnd)", "diff": ["-\t\t\t\t\t\t// Start tag parsing only if we are on line beginning or at inline tag beginning", "-\t\t\t\t\t\tif (!this.lineStarted || previousChar == '{') {", "+\t\t\t\t\t\t// Start tag parsing only if we have a java identifier start character and if we are on line beginning or at inline tag beginning", "+\t\t\t\t\t\tif (Character.isJavaIdentifierStart(peekChar()) && (!this.lineStarted || previousChar == '{')) {", "-\t\t\t\t\t\t\t\tint tk = readTokenAndConsume();", "-\t\t\t\t\t\t\t\tthis.tagSourceStart = this.kind == COMPIL_PARSER ? this.scanner.getCurrentTokenStartPosition() : previousPosition;", "+\t\t\t\t\t\t\t\tint token = readTokenAndConsume();", "+\t\t\t\t\t\t\t\tthis.tagSourceStart = this.scanner.getCurrentTokenStartPosition();", "-\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword", "+\t\t\t\t\t\t\t\tif (this.kind == DOM_PARSER) {", "+\t\t\t\t\t\t\t\t\t// For DOM parser, try to get tag name other than java identifier", "+\t\t\t\t\t\t\t\t\t// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)", "+\t\t\t\t\t\t\t\t\tint tk = token;", "+\t\t\t\t\t\t\t\t\tint le = this.lineEnd;", "+\t\t\t\t\t\t\t\t\tchar pc = peekChar();", "+\t\t\t\t\t\t\t\t\ttagNameToken: while (tk != TerminalTokens.TokenNameERROR && tk != TerminalTokens.TokenNameEOF) {", "+\t\t\t\t\t\t\t\t\t\tthis.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();", "+\t\t\t\t\t\t\t\t\t\ttoken = tk;", "+\t\t\t\t\t\t\t\t\t\t// !, \", #, %, &, ', -, :, <, >", "+\t\t\t\t\t\t\t\t\t\tif (Character.isWhitespace(pc)) break;", "+\t\t\t\t\t\t\t\t\t\tswitch (pc) {", "+\t\t\t\t\t\t\t\t\t\t\tcase '}':", "+\t\t\t\t\t\t\t\t\t\t\tcase '!':", "+\t\t\t\t\t\t\t\t\t\t\tcase '#':", "+\t\t\t\t\t\t\t\t\t\t\tcase '%':", "+\t\t\t\t\t\t\t\t\t\t\tcase '&':", "+\t\t\t\t\t\t\t\t\t\t\tcase '\\'':", "+\t\t\t\t\t\t\t\t\t\t\tcase '-':", "+\t\t\t\t\t\t\t\t\t\t\tcase '<' :", "+\t\t\t\t\t\t\t\t\t\t\tcase '>':", "+\t\t\t\t\t\t\t\t\t\t\t\tbreak tagNameToken;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\ttk = readTokenAndConsume();", "+\t\t\t\t\t\t\t\t\t\tpc = peekChar();", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tint length = this.tagSourceEnd-this.tagSourceStart+1;", "+\t\t\t\t\t\t\t\t\ttag = new char[length];", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.source, this.tagSourceStart, tag, 0, length);", "+\t\t\t\t\t\t\t\t\tthis.index = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.scanner.currentPosition = this.tagSourceEnd+1;", "+\t\t\t\t\t\t\t\t\tthis.tagSourceStart = previousPosition;", "+\t\t\t\t\t\t\t\t\tthis.lineEnd = le;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tswitch (token) {", "-\t\t\t\t\t\t\t\t\t\tchar[] tag = this.scanner.getCurrentIdentifierSource();", "-\t\t\t\t\t\t\t\t\t\t\tthis.inherited = true;", "+\t\t\t\t\t\t\t\t\t\t\t// inhibits inherited flag when tags have been already stored", "+\t\t\t\t\t\t\t\t\t\t\t// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606", "+\t\t\t\t\t\t\t\t\t\t\t// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag", "+\t\t\t\t\t\t\t\t\t\t\t// was encountered in comment. But it cannot be the case for COMPILER_PARSER", "+\t\t\t\t\t\t\t\t\t\t\t// and so is enough as it is only this parser which signals the missing tag warnings...", "+\t\t\t\t\t\t\t\t\t\t\tthis.inherited = this.astPtr==-1;", "-\t\t\t\t\t\t\t\t\t\t\tswitch (tk) {", "+\t\t\t\t\t\t\t\t\t\t\tswitch (token) {"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "895520750248bd3f527a2c25ae24e31b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "69b02d68015b1f30ee38d1576a843274517957c7", "commitAfterChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "  \tprivate void complete(AstNode astNode, AstNode astNodeParent, Binding qualifiedBinding, Scope scope)", "signatureAfterChange": "  \tprivate void complete(AstNode astNode, AstNode astNodeParent, Binding qualifiedBinding, Scope scope)", "diff": ["-", "-\t\t// defaults... some nodes will change these", "+\t\t", "-\t\t\t//\t\tfindKeywords(token, modifiers, scope); // could be the start of a field, method or member type", "+\t\t\t", "+\t\t\tfindKeywordsForMember(token, field.modifiers);", "-\t\t\t\t", "+\t\t\t\tfindKeywordsForMember(token, method.modifiers);", "+\t\t\t", "-\t", "-\t\t\t\t\ttoken = ((CompletionOnSingleNameReference) astNode).token;", "+\t\t\t\t\tCompletionOnSingleNameReference singleNameReference = (CompletionOnSingleNameReference) astNode;", "+\t\t\t\t\ttoken = singleNameReference.token;", "-\t", "+\t\t\t\t\tfindKeywords(token, singleNameReference.possibleKeywords);", "+\t\t\t\t\tif(singleNameReference.canBeExplicitConstructor){", "+\t\t\t\t\t\tif(CharOperation.prefixEquals(token, Keywords.THIS, false)) {", "+\t\t\t\t\t\t\tReferenceBinding ref = scope.enclosingSourceType();", "+\t\t\t\t\t\t\tfindExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);", "+\t\t\t\t\t\t} else if(CharOperation.prefixEquals(token, Keywords.SUPER, false)) {", "+\t\t\t\t\t\t\tReferenceBinding ref = scope.enclosingSourceType();", "+\t\t\t\t\t\t\tfindExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tMethodScope methodScope = null;", "+\t\t\t\t\t\t\t\t\tif((scope instanceof MethodScope && !((MethodScope)scope).isStatic)", "+\t\t\t\t\t\t\t\t\t\t|| ((methodScope = scope.enclosingMethodScope()) != null && !methodScope.isStatic)) {", "+\t\t\t\t\t\t\t\t\t\tfindKeywords(token, new char[][]{Keywords.THIS});", "+\t\t\t\t\t\t\t\t\t}", "-\t", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\tfindKeywords(token, new char[][]{Keywords.NEW});", "+\t\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(astNode instanceof CompletionOnKeyword) {", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tCompletionOnKeyword keyword = (CompletionOnKeyword)astNode;", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfindKeywords(keyword.getToken(), keyword.getPossibleKeywords());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b10b3ee6165f0a92331d20a67a3c30c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java", "commitBeforeChange": "98c08ded096494364ca74f948e8f494b3f447e89", "commitAfterChange": "423cede7ef9cde15030dc54ef2266be4ddcc9112", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 56, "signatureBeforeChange": " \tpublic void _test018()", "signatureAfterChange": " public void _test018b()", "diff": ["-// TODO (maxime) enforce working directory", "-\tpublic void _test018(){", "-\t\tthis.runConformTest(", "-\t\t\tnew String[] {", "-\t\t\t\t\t\"X.java\",", "-\t\t\t\t\t\"/** */\\n\" +", "-\t\t\t\t\t\"public class X {\\n\" +", "-\t\t\t\t\t\"\tOK1 ok1;\\n\" +", "-\t\t\t\t\t\"}\",", "-\t\t\t\t\t\"OK1.java\",", "-\t\t\t\t\t\"/** */\\n\" +", "-\t\t\t\t\t\"public class OK1 {\\n\" +", "-\t\t\t\t\t\"\t// empty\\n\" +", "-\t\t\t\t\t\"}\"", "-\t\t\t},", "-\t        \"\\\"\" + OUTPUT_DIR +  File.separator + \"X.java\\\"\"", "-\t        + \" -1.5 -g -preserveAllLocals\"", "-\t        + \" -verbose -proceedOnError -referenceInfo\"", "-\t        + \" -d \\\"\" + OUTPUT_DIR + \"\\\"\",", "-\t        \"[2 .class files generated]\\n\",", "-\t        \"\",", "-\t        true);", "+// empty sourcepath works with javac but not with ecj", "+public void _test018b(){", "+\tString currentWorkingDirectoryPath = System.getProperty(\"user.dir\");", "+\tif (currentWorkingDirectoryPath == null) {", "+\t\tSystem.err.println(\"BatchCompilerTest#18b could not access the current working directory \" + currentWorkingDirectoryPath);", "+\t} else if (!new File(currentWorkingDirectoryPath).isDirectory()) {", "+\t\tSystem.err.println(\"BatchCompilerTest#18b current working directory is not a directory \" + currentWorkingDirectoryPath);", "+\t} else {", "+\t\tString xPath = currentWorkingDirectoryPath + File.separator + \"X.java\";", "+\t\tString ok1Path = currentWorkingDirectoryPath + File.separator + \"OK1.java\";", "+\t\tPrintWriter sourceFileWriter;", "+\t\ttry {", "+\t\t\tFile file = new File(xPath);", "+\t\t\tsourceFileWriter = new PrintWriter(new FileOutputStream(file));", "+\t\t\tsourceFileWriter.write(", "+\t\t\t\t\"/** */\\n\" +", "+\t\t\t\t\"public class X {\\n\" +", "+\t\t\t\t\"\tOK1 ok1;\\n\" +", "+\t\t\t\t\"}\");", "+\t\t\tsourceFileWriter.close();", "+\t\t\tfile = new File(ok1Path);", "+\t\t\tsourceFileWriter = new PrintWriter(new FileOutputStream(file));", "+\t\t\tsourceFileWriter.write(", "+\t\t\t\t\"/** */\\n\" +", "+\t\t\t\t\"public class OK1 {\\n\" +", "+\t\t\t\t\"\t// empty\\n\" +", "+\t\t\t\t\"}\");", "+\t\t\tsourceFileWriter.close();", "+\t\t\tthis.runTest(", "+\t\t\t\ttrue,", "+\t\t\t\tnew String[] {", "+\t\t\t\t\t\"dummy.java\", // enforce output directory creation", "+\t\t\t\t\t\"\"", "+\t\t\t\t},", "+\t\t        \"X.java\"", "+\t\t        + \" -1.5 -g -preserveAllLocals\"", "+\t\t        + \" -verbose -proceedOnError\"", "+\t\t        + \" -d \\\"\" + OUTPUT_DIR + \"\\\"\",", "+\t\t        TWO_FILES_GENERATED_MATCHER,", "+\t\t        EMPTY_STRING_MATCHER,", "+\t\t        false);", "+\t\t} catch (FileNotFoundException e) {", "+\t\t\tSystem.err.println(\"BatchCompilerTest#18b could not write to current working directory \" + currentWorkingDirectoryPath);", "+\t\t} finally {", "+\t\t\tnew File(xPath).delete();", "+\t\t\tnew File(ok1Path).delete();", "+\t\t}", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f13daab31e1e4994c715fba82180447", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java", "commitBeforeChange": "5c930a2be2f56a634252cd32fd5425aacd603534", "commitAfterChange": "eb4f7811e5216181c33caa5f1f098b6e53cc8ce4", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 7, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\t\t\t((ReferenceBinding)this.recipient).tagBits |= tagBits;", "+\t\t\t\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) this.recipient;", "+\t\t\t\t\t\tsourceType.tagBits |= tagBits;", "+\t\t\t\t\t\tif ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {", "+\t\t\t\t\t\t\tClassScope recipientScope = sourceType.scope;", "+\t\t\t\t\t\t\t// construct custom compiler options with suppressed warnings", "+\t\t\t\t\t\t\tCompilerOptions customOptions = getCustomCompilerOptions(recipientScope);", "+\t\t\t\t\t\t\tif (customOptions != null) {", "+\t\t\t\t\t\t\t\tTypeDeclaration typeDeclaration = recipientScope.referenceContext;", "+\t\t\t\t\t\t\t\trecipientScope.options = customOptions;", "+\t\t\t\t\t\t\t\t// discard already generated warnings which got suppressed", "+\t\t\t\t\t\t\t\ttypeDeclaration.compilationResult().suppressRecordedWarnings(", "+\t\t\t\t\t\t\t\t\t\ttypeDeclaration.declarationSourceStart, ", "+\t\t\t\t\t\t\t\t\t\ttypeDeclaration.declarationSourceEnd, ", "+\t\t\t\t\t\t\t\t\t\trecipientScope.problemReporter());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "-\t\t\t\t\t\t((MethodBinding)this.recipient).tagBits |= tagBits;", "+\t\t\t\t\t\tMethodBinding sourceMethod = (MethodBinding) this.recipient;", "+\t\t\t\t\t\tsourceMethod.tagBits |= tagBits;", "+\t\t\t\t\t\tif ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {", "+\t\t\t\t\t\t\tAbstractMethodDeclaration methodDeclaration = ((SourceTypeBinding)sourceMethod.declaringClass).scope.referenceContext.declarationOf(sourceMethod);", "+\t\t\t\t\t\t\tMethodScope recipientScope = methodDeclaration.scope;", "+\t\t\t\t\t\t\t// construct custom compiler options with suppressed warnings", "+\t\t\t\t\t\t\tCompilerOptions customOptions = getCustomCompilerOptions(recipientScope);", "+\t\t\t\t\t\t\tif (customOptions != null) {", "+\t\t\t\t\t\t\t\trecipientScope.options = customOptions;", "+\t\t\t\t\t\t\t\t// discard already generated warnings which got suppressed", "+\t\t\t\t\t\t\t\tmethodDeclaration.compilationResult().suppressRecordedWarnings(", "+\t\t\t\t\t\t\t\t\t\tmethodDeclaration.declarationSourceStart, ", "+\t\t\t\t\t\t\t\t\t\tmethodDeclaration.declarationSourceEnd, ", "+\t\t\t\t\t\t\t\t\t\trecipientScope.problemReporter());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}\t\t\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "907fec3b2411f16918d888058bf9b79e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "02009b41ec945f5cfcf629234ac75cbc76ce6809", "commitAfterChange": "3e46d275b92d309fd1fe675f261b23afc851c7bf", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 76, "signatureBeforeChange": " public void configure(String[] argv)", "signatureAfterChange": " public void configure(String[] argv)", "diff": ["+\t\t\t\tif (currentArg.startsWith(\"-nowarn\")) { //$NON-NLS-1$", "+\t\t\t\t\tswitch (currentArg.length()) {", "+\t\t\t\t\t\tcase 7:", "+\t\t\t\t\t\t\tdisableAll(ProblemSeverities.Warning);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase 8:", "+\t\t\t\t\t\t\tthrow new IllegalArgumentException(this.bind(", "+\t\t\t\t\t\t\t\t\t\"configure.invalidNowarnOption\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\tint foldersStart = currentArg.indexOf('[') + 1;", "+\t\t\t\t\t\t\tint foldersEnd = currentArg.lastIndexOf(']');", "+\t\t\t\t\t\t\tif (foldersStart <= 8 || foldersEnd == -1 || foldersStart > foldersEnd", "+\t\t\t\t\t\t\t\t\t|| foldersEnd < currentArg.length() - 1) {", "+\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(this.bind(", "+\t\t\t\t\t\t\t\t\t\t\"configure.invalidNowarnOption\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tString folders = currentArg.substring(foldersStart, foldersEnd);", "+\t\t\t\t\t\t\tif (folders.length() > 0) {", "+\t\t\t\t\t\t\t\tchar[][] currentFolders = decodeIgnoreOptionalProblemsFromFolders(folders);", "+\t\t\t\t\t\t\t\tif (this.ignoreOptionalProblemsFromFolders != null) {", "+\t\t\t\t\t\t\t\t\tint length = this.ignoreOptionalProblemsFromFolders.length + currentFolders.length;", "+\t\t\t\t\t\t\t\t\tchar[][] tempFolders = new char[length][];", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(this.ignoreOptionalProblemsFromFolders, 0, tempFolders, 0, this.ignoreOptionalProblemsFromFolders.length);", "+\t\t\t\t\t\t\t\t\tSystem.arraycopy(currentFolders, 0, tempFolders, this.ignoreOptionalProblemsFromFolders.length, currentFolders.length);", "+\t\t\t\t\t\t\t\t\tthis.ignoreOptionalProblemsFromFolders = tempFolders;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tthis.ignoreOptionalProblemsFromFolders = currentFolders;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(this.bind(", "+\t\t\t\t\t\t\t\t\t\t\"configure.invalidNowarnOption\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tmode = DEFAULT;", "+\t\t\t\t\tcontinue;", "+\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (currentArg.startsWith(\"-nowarn\")) { //$NON-NLS-1$", "-\t\t\t\t\tdisableAll(ProblemSeverities.Warning);", "-\t\t\t\t\tmode = DEFAULT;", "-\t\t\t\t\tcontinue;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90abc4db0167047624bd0142a57d377b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "f2ff53b9c5467491559775afe1992655f55a63fe", "commitAfterChange": "b38f964c0abc42b760a66a064dc1b2f95aca317b", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 45, "signatureBeforeChange": " \t\tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event)", "signatureAfterChange": "         public void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event)", "diff": ["-\t\t */", "-\t\tpublic void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event) {", "-\t\t\tString propertyName = event.getKey();", "-\t\t\tif (propertyName.startsWith(CP_VARIABLE_PREFERENCES_PREFIX)) {", "-\t\t\t\tString varName = propertyName.substring(CP_VARIABLE_PREFERENCES_PREFIX.length());", "-\t\t\t\tJavaModelManager manager = getJavaModelManager();", "-\t\t\t\tif (manager.variablesWithInitializer.contains(varName)) {", "-\t\t\t\t\t// revert preference value as we will not apply it to JavaCore classpath variable", "-\t\t\t\t\tString oldValue = (String) event.getOldValue();", "-\t\t\t\t\tif (oldValue == null) {", "-\t\t\t\t\t\t// unexpected old value => remove variable from set", "-\t\t\t\t\t\tmanager.variablesWithInitializer.remove(varName);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tmanager.getInstancePreferences().put(varName, oldValue);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tString newValue = (String)event.getNewValue();", "-\t\t\t\t\tIPath newPath;", "-\t\t\t\t\tif (newValue != null && !(newValue = newValue.trim()).equals(CP_ENTRY_IGNORE)) {", "-\t\t\t\t\t\tnewPath = new Path(newValue);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tnewPath = null;", "-\t\t\t\t\t}", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\tSetVariablesOperation operation = new SetVariablesOperation(new String[] {varName}, new IPath[] {newPath}, false/*don't update preferences*/);", "-\t\t\t\t\t\toperation.runOperation(null/*no progress available*/);", "-\t\t\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t\t\tUtil.log(e, \"Could not set classpath variable \" + varName + \" to \" + newPath); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (propertyName.startsWith(CP_CONTAINER_PREFERENCES_PREFIX)) {", "-\t\t\t\trecreatePersistedContainer(propertyName, (String)event.getNewValue(), false);", "-\t\t\t}", "-\t\t}", "+         */", "+        public void preferenceChange(IEclipsePreferences.PreferenceChangeEvent event) {", "+        \tString propertyName = event.getKey();", "+        \tif (propertyName.startsWith(CP_VARIABLE_PREFERENCES_PREFIX)) {", "+        \t\tString varName = propertyName.substring(CP_VARIABLE_PREFERENCES_PREFIX.length());", "+        \t\tJavaModelManager manager = getJavaModelManager();", "+        \t\tif (manager.variablesWithInitializer.contains(varName)) {", "+        \t\t\t// revert preference value as we will not apply it to JavaCore classpath variable", "+        \t\t\tString oldValue = (String) event.getOldValue();", "+        \t\t\tif (oldValue == null) {", "+        \t\t\t\t// unexpected old value => remove variable from set", "+        \t\t\t\tmanager.variablesWithInitializer.remove(varName);", "+        \t\t\t} else {", "+        \t\t\t\tmanager.getInstancePreferences().put(varName, oldValue);", "+        \t\t\t}", "+        \t\t} else {", "+        \t\t\tString newValue = (String)event.getNewValue();", "+        \t\t\tIPath newPath;", "+        \t\t\tif (newValue != null && !(newValue = newValue.trim()).equals(CP_ENTRY_IGNORE)) {", "+        \t\t\t\tnewPath = new Path(newValue);", "+        \t\t\t} else {", "+        \t\t\t\tnewPath = null;", "+        \t\t\t}", "+        \t\t\ttry {", "+        \t\t\t\tSetVariablesOperation operation = new SetVariablesOperation(new String[] {varName}, new IPath[] {newPath}, false/*don't update preferences*/);", "+        \t\t\t\toperation.runOperation(null/*no progress available*/);", "+        \t\t\t} catch (JavaModelException e) {", "+        \t\t\t\tUtil.log(e, \"Could not set classpath variable \" + varName + \" to \" + newPath); //$NON-NLS-1$ //$NON-NLS-2$", "+        \t\t\t}", "+        \t\t}", "+        \t}", "+        \telse if (propertyName.startsWith(CP_CONTAINER_PREFERENCES_PREFIX)) {", "+        \t\trecreatePersistedContainer(propertyName, (String)event.getNewValue(), false);", "+        \t} else {", "+        \t\tint length = JavaCore.PLUGIN_ID.length() + 1;", "+        \t\tString key = event.getKey();", "+        \t\tStringTokenizer tokenizer = new StringTokenizer(key.substring(length));", "+        \t\tString token = tokenizer.nextToken();", "+        \t\tif (key.equals(JavaCore.CORE_JAVA_BUILD_CLEAN_OUTPUT_FOLDER) ||", "+        \t\t\ttoken.equals(\"builder\") || //$NON-NLS-1$", "+        \t\t\tkey.equals(JavaCore.CORE_INCOMPLETE_CLASSPATH) ||", "+        \t\t\tkey.equals(JavaCore.CORE_CIRCULAR_CLASSPATH) ||", "+        \t\t\tkey.equals(JavaCore.CORE_INCOMPATIBLE_JDK_LEVEL) ||", "+        \t\t\ttoken.equals(\"classpath\")) //$NON-NLS-1$", "+        \t\t{", "+        \t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+        \t\t\tIJavaModel model = manager.getJavaModel();", "+        \t\t\tIJavaProject[] projects;", "+        \t\t\ttry {", "+        \t\t\t\tprojects = model.getJavaProjects();", "+        \t\t\t\tfor (int i = 0, pl = projects.length; i < pl; i++) {", "+        \t\t\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "+\t    \t\t\t\t\tmanager.deltaState.addClasspathValidation(javaProject);", "+\t    \t\t\t\t\ttry {", "+\t    \t\t\t\t\t\t// need to touch the project to force validation by DeltaProcessor", "+\t                            javaProject.getProject().touch(null);", "+                            } catch (CoreException e) {", "+\t                            // skip", "+                            }", "+        \t\t\t\t}", "+        \t\t\t} catch (JavaModelException e) {", "+        \t\t\t\t// skip", "+        \t\t\t}", "+        \t\t}", "+        \t}", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93ed44cd5dacbf0c3c0d02e8de98a641", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "ca1c70fe619bd146613895fa764af2d040529e30", "commitAfterChange": "0ae44cb94fd5970ee99a6625f01c4e21cfef9943", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, IJavaProject project) throws JavaModelException", "signatureAfterChange": "\r private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, IJavaProject project) throws JavaModelException", "diff": ["-\t\t\t} else if (elementType == IJavaElement.JAVA_PROJECT\r", "-\t\t\t\t\t&& (flags & IResourceDelta.OPEN) != 0) {\r", "-\t\t\t\t// project has been opened or closed\r", "-\t\t\t\tIProject res = (IProject)delta.getResource();\r", "-\t\t\t\telement = this.createElement(res, elementType, project);\r", "-\t\t\t\tif (element == null) throw newInvalidElementType();\r", "-\t\t\t\tif (res.isOpen()) {\r", "-\t\t\t\t\tthis.elementOpened(element, delta);\r", "-\t\t\t\t} else {\r", "-\t\t\t\t\tthis.elementClosed(element, delta);\r", "+\t\t\t} else if (elementType == IJavaElement.JAVA_PROJECT) {\r", "+\t\t\t\tif ((flags & IResourceDelta.OPEN) != 0) {\r", "+\t\t\t\t\t// project has been opened or closed\r", "+\t\t\t\t\tIProject res = (IProject)delta.getResource();\r", "+\t\t\t\t\telement = this.createElement(res, elementType, project);\r", "+\t\t\t\t\tif (element == null) throw newInvalidElementType();\r", "+\t\t\t\t\tif (res.isOpen()) {\r", "+\t\t\t\t\t\tif (this.hasJavaNature(res)) {\r", "+\t\t\t\t\t\t\tthis.elementAdded(element, delta);\r", "+\t\t\t\t\t\t\tthis.indexManager.indexAll(res);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tJavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();\r", "+\t\t\t\t\t\tboolean wasJavaProject = javaModel.findJavaProject(res) != null;\r", "+\t\t\t\t\t\tif (wasJavaProject) {\r", "+\t\t\t\t\t\t\tthis.elementRemoved(element, delta);\r", "+\t\t\t\t\t\t\tthis.indexManager.removeIndex(res.getFullPath());\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\treturn false; // when a project is open/closed don't process children\r", "-\t\t\t\tthis.updateIndex(element, delta);\r", "-\t\t\t\treturn false; // when a project is open/closed don't process children\r", "+\t\t\t\tif ((flags & IResourceDelta.DESCRIPTION) != 0) {\r", "+\t\t\t\t\tIProject res = (IProject)delta.getResource();\r", "+\t\t\t\t\tJavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();\r", "+\t\t\t\t\tboolean wasJavaProject = javaModel.findJavaProject(res) != null;\r", "+\t\t\t\t\tboolean isJavaProject = this.hasJavaNature(res);\r", "+\t\t\t\t\tif (wasJavaProject != isJavaProject) {\r", "+\t\t\t\t\t\t// project's nature has been added or removed\r", "+\t\t\t\t\t\telement = this.createElement(res, elementType, project);\r", "+\t\t\t\t\t\tif (element == null) throw newInvalidElementType();\r", "+\t\t\t\t\t\tif (isJavaProject) {\r", "+\t\t\t\t\t\t\tthis.elementAdded(element, delta);\r", "+\t\t\t\t\t\t\tthis.indexManager.indexAll(res);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tthis.elementRemoved(element, delta);\r", "+\t\t\t\t\t\t\tthis.indexManager.removeIndex(res.getFullPath());\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\treturn false; // when a project's nature is added/removed don't process children\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b47b735f25348f7dd7600652e2e8101", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaConventions.java", "commitBeforeChange": "2a762b85f858691a63d4547af177cc649d7b1329", "commitAfterChange": "7675c409a4b3b1e15b1cc476a0a66b988b5fb4a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "signatureAfterChange": "\r public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation)", "diff": ["-\tIClasspathEntry[] originalClasspath = classpath;\r", "+\tArrayList resolvedEntries = new ArrayList();\r", "-\t\t// use resolved variable\r", "-\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_VARIABLE){\r", "-\t\t\tif (classpath == originalClasspath) System.arraycopy(originalClasspath, 0, classpath = new IClasspathEntry[length], 0, length);\r", "-\t\t\tclasspath[i] = JavaCore.getResolvedClasspathEntry(classpath[i]);\r", "-\t\t}\r", "-\t\tif (classpath[i] != null){\r", "-\t\t\tif (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "-\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "-\t\t\tif (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\tIClasspathEntry rawEntry = classpath[i];\r", "+\t\tswitch(rawEntry.getEntryKind()){\r", "+\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_VARIABLE :\r", "+\t\t\t\tIClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);\r", "+\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\r", "+\t\t\tcase IClasspathEntry.CPE_CONTAINER :\r", "+\t\t\t\tIClasspathEntry[] containerEntries = javaProject.getResolvedClasspathContainer(rawEntry.getPath());\r", "+\t\t\t\tif (containerEntries != null){\r", "+\t\t\t\t\tfor (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){\r", "+\t\t\t\t\t\t resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);\r", "+\t\t\t\t\t\tif (resolvedEntry != null){\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;\r", "+\t\t\t\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\t\t\t\tif (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\t\t\t\tresolvedEntries.add(resolvedEntry);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\t\t\r", "+\t\t\tcase IClasspathEntry.CPE_SOURCE :\r", "+\t\t\t\thasSource = true;\r", "+\t\t\tdefault :\r", "+\t\t\t\t// check if any source entries coincidates with binary output - in which case nesting inside output is legal\r", "+\t\t\t\tif (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;\r", "+\t\t\t\tresolvedEntries.add(rawEntry);\r", "+\t\t\t\tbreak;\r", "+\t\r", "+\tlength = resolvedEntries.size();\r", "+\tclasspath = new IClasspathEntry[length];\r", "+\tresolvedEntries.toArray(classpath);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c1b556b78410c2b0131273f5780372c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java", "commitBeforeChange": "ca289ff4e9317024e3c3a344a3b266fd883ffd1d", "commitAfterChange": "aacce274176303cc524a6360232ca1201922c452", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner workingCopyOwner)", "signatureAfterChange": " public IJavaElement getHandleFromMemento(String token, MementoTokenizer memento, WorkingCopyOwner workingCopyOwner)", "diff": ["+\t\tcase JEM_LAMBDA_EXPRESSION:", "+\t\t\tif (!memento.hasMoreTokens()) return this;", "+\t\t\tString name = memento.nextToken();", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.STRING)", "+\t\t\t\treturn this;", "+\t\t\tif (!memento.hasMoreTokens()) return this;", "+\t\t\tString interphase = memento.nextToken();", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) ", "+\t\t\t\treturn this;", "+\t\t\tint sourceStart = Integer.parseInt(memento.nextToken());", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) ", "+\t\t\t\treturn this;", "+\t\t\tint sourceEnd = Integer.parseInt(memento.nextToken());", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.COUNT) ", "+\t\t\t\treturn this;", "+\t\t\tint arrowPosition = Integer.parseInt(memento.nextToken());", "+\t\t\tif (!memento.hasMoreTokens() || memento.nextToken() != MementoTokenizer.LAMBDA_METHOD) ", "+\t\t\t\treturn this;", "+\t\t\tLambdaExpression expression = new LambdaExpression(this, name, interphase, sourceStart, sourceEnd, arrowPosition);", "+\t\t\treturn expression.getHandleFromMemento(token, memento, workingCopyOwner);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cd521bf2ea153ad8d3bffd2d03dc9eb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java", "commitBeforeChange": "1d91bb6095cf925ea7ef511c76b46befc586fea4", "commitAfterChange": "11e4e14c87ae9f5d3c387265b339332ab33728bd", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprivate String[] initPackageFragToTypes(HashtableOfArrayToObject packageFragToTypes, String entryName, int lastSeparator)", "signatureAfterChange": " \tprivate void initPackageFragToTypes(HashtableOfArrayToObject packageFragToTypes, String entryName, boolean isDirectory)", "diff": ["-\tprivate String[] initPackageFragToTypes(HashtableOfArrayToObject packageFragToTypes, String entryName, int lastSeparator) {", "+\tprivate void initPackageFragToTypes(HashtableOfArrayToObject packageFragToTypes, String entryName, boolean isDirectory) {", "+\t\tint lastSeparator = isDirectory ? entryName.length()-1 : entryName.lastIndexOf('/');", "-\t\t\tSystem.arraycopy(existing, 0, existing = new String[i+1], 0, i);", "-\t\t\texisting[i] = manager.intern(pkgName[i]);", "-\t\t\tpackageFragToTypes.put(existing, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\tif (Util.isValidFolderNameForPackage(pkgName[i])) {", "+\t\t\t\tSystem.arraycopy(existing, 0, existing = new String[i+1], 0, i);", "+\t\t\t\texisting[i] = manager.intern(pkgName[i]);", "+\t\t\t\tpackageFragToTypes.put(existing, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });", "+\t\t\t} else {", "+\t\t\t\t// non-Java esource folder", "+\t\t\t\tArrayList[] children = (ArrayList[]) packageFragToTypes.get(existing);", "+\t\t\t\tif (children[1/*NON_JAVA*/] == EMPTY_LIST) children[1/*NON_JAVA*/] = new ArrayList();", "+\t\t\t\tchildren[1/*NON_JAVA*/].add(entryName);", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+\t\tif (isDirectory)", "+\t\t\treturn;", "+\t\t", "+\t\t// add classfile info amongst children", "+\t\tString fileName = entryName.substring(lastSeparator + 1);", "+\t\tArrayList[] children = (ArrayList[]) packageFragToTypes.get(pkgName);", "+\t\tif (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(entryName)) {", "+\t\t\tif (children[0/*JAVA*/] == EMPTY_LIST) children[0/*JAVA*/] = new ArrayList();", "+\t\t\tchildren[0/*JAVA*/].add(fileName);", "+\t\t} else {", "+\t\t\tif (children[1/*NON_JAVA*/] == EMPTY_LIST) children[1/*NON_JAVA*/] = new ArrayList();", "+\t\t\tchildren[1/*NON_JAVA*/].add(fileName);", "-\t\treturn existing;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e9643972d7b987ddb99d356e7ca86c0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java", "commitBeforeChange": "06b4da04864008da88066d5a5e945f628c432313", "commitAfterChange": "6cb1a46319677820636b0fbe76d096b92fe1835a", "methodNumberBeforeChange": 141, "methodNumberAfterChange": 142, "signatureBeforeChange": " \tpublic boolean visit(SingleVariableDeclaration node)", "signatureAfterChange": " \tpublic boolean visit(SingleVariableDeclaration node)", "diff": ["+\t\t\t\tTextEditGroup editGroup = getEditGroup(node, SingleVariableDeclaration.VARARGS_PROPERTY);", "-\t\t\t\t\tdoTextInsert(pos, \"...\", getEditGroup(node, SingleVariableDeclaration.VARARGS_PROPERTY)); //$NON-NLS-1$", "+\t\t\t\t\tif (apiLevel >= AST.JLS8) {", "+\t\t\t\t\t\tpos= rewriteVarargsAnnotations(node, SingleVariableDeclaration.VARARGS_ANNOTATIONS_PROPERTY, pos);", "+\t\t\t\t\t}", "+\t\t\t\t\tint indent= getIndent(node.getStartPosition());", "+\t\t\t\t\tString prefix= this.formatter.VARARGS.getPrefix(indent);", "+\t\t\t\t\tdoTextInsert(pos, prefix, editGroup);", "+\t\t\t\t\tdoTextInsert(pos, \"...\", editGroup); //$NON-NLS-1$", "-\t\t\t\t\t\tint ellipsisEnd= getScanner().getNextEndOffset(pos, true);", "-\t\t\t\t\t\tdoTextRemove(pos, ellipsisEnd - pos, getEditGroup(node, SingleVariableDeclaration.VARARGS_PROPERTY));", "+\t\t\t\t\t\tint ellipsisEnd;", "+\t\t\t\t\t\tint noOfAnnotations = apiLevel >= AST.JLS8 ? node.varargsAnnotations().size() : 0;", "+\t\t\t\t\t\tif (noOfAnnotations > 0) {", "+\t\t\t\t\t\t\tAnnotation annotation= (Annotation) node.varargsAnnotations().get(noOfAnnotations - 1);", "+\t\t\t\t\t\t\tint annotationEndPosition= annotation.getStartPosition() + annotation.getLength();", "+\t\t\t\t\t\t\tellipsisEnd= getScanner().getNextEndOffset(annotationEndPosition, true);", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tellipsisEnd= getScanner().getNextEndOffset(pos, true);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tdoTextRemove(pos, ellipsisEnd - pos, editGroup);", "+\t\t\t} else {", "+\t\t\t\tif (apiLevel >= AST.JLS8 && node.isVarargs()) {", "+\t\t\t\t\tpos = rewriteVarargsAnnotations(node, SingleVariableDeclaration.VARARGS_ANNOTATIONS_PROPERTY, pos);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a346a56e0fb181278384ba3af84335e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java", "commitBeforeChange": "497b69b47b38f18098b3c3fae687e15309c6bbc5", "commitAfterChange": "d38bcf16d99693127114142320ebdb39140b8604", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public void complete(char[] codeSnippet, int completionPosition, SearchableEnvironment environment, CompletionRequestor requestor, Map options, IJavaProject project)", "signatureAfterChange": " public void complete(char[] codeSnippet, int completionPosition, SearchableEnvironment environment, CompletionRequestor requestor, Map options, IJavaProject project)", "diff": ["+\ttry {", "+\t\tIRequestor variableRequestor = new IRequestor() {", "+\t\t\tpublic boolean acceptClassFiles(ClassFile[] classFiles, char[] codeSnippetClassName) {", "+\t\t\t\t// Do nothing", "+\t\t\t\treturn true;", "+\t\t\t}", "+\t\t\tpublic void acceptProblem(CategorizedProblem problem, char[] fragmentSource, int fragmentKind) {", "+\t\t\t\t// Do nothing", "+\t\t\t}", "+\t\t};", "+\t\tthis.evaluateVariables(environment, options, variableRequestor, new DefaultProblemFactory(Locale.getDefault()));", "+\t} catch (InstallException e) {", "+\t\t// Do nothing", "+\t}", "+\t", "+\t", "+\tif (this.installedVars != null) {", "+\t\tIBinaryType binaryType = this.getRootCodeSnippetBinary();", "+\t\tif (binaryType != null) {", "+\t\t\tengine.lookupEnvironment.cacheBinaryType(binaryType, null /*no access restriction*/);", "+\t\t}", "+\t\t", "+\t\tClassFile[] classFiles = installedVars.classFiles;", "+\t\tfor (int i = 0; i < classFiles.length; i++) {", "+\t\t\tClassFile classFile = classFiles[i];", "+\t\t\tIBinaryType binary = null;", "+\t\t\ttry {", "+\t\t\t\tbinary = new ClassFileReader(classFile.getBytes(), null);", "+\t\t\t} catch (ClassFormatException e) {", "+\t\t\t\te.printStackTrace(); // Should never happen since we compiled this type", "+\t\t\t}", "+\t\t\tengine.lookupEnvironment.cacheBinaryType(binary, null /*no access restriction*/);", "+\t\t}", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a413f1aa6b5edb163cf212720a6aab70", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java", "commitBeforeChange": "600d3eda20c6510ad5218c514ac30249f7b449a9", "commitAfterChange": "f3c706bfa8df1589d5835736528d83fcc35878b8", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void round()", "signatureAfterChange": " \tpublic void round()", "diff": ["+\t\tif (null != _traceRounds) {", "+\t\t\tStringBuilder sbElements = new StringBuilder();", "+\t\t\tsbElements.append(\"\\tinput files: {\"); //$NON-NLS-1$", "+\t\t\tIterator<? extends Element> iElements = _roundEnv.getRootElements().iterator();", "+\t\t\tboolean hasNext = iElements.hasNext();", "+\t\t\twhile (hasNext) {", "+\t\t\t\tsbElements.append(iElements.next());", "+\t\t\t\thasNext = iElements.hasNext();", "+\t\t\t\tif (hasNext) {", "+\t\t\t\t\tsbElements.append(',');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tsbElements.append('}');", "+\t\t\t_traceRounds.println(sbElements.toString());", "+\t\t\t", "+\t\t\tStringBuilder sbAnnots = new StringBuilder();", "+\t\t\tsbAnnots.append(\"\\tannotations: [\"); //$NON-NLS-1$", "+\t\t\tIterator<TypeElement> iAnnots = _unclaimedAnnotations.iterator();", "+\t\t\thasNext = iAnnots.hasNext();", "+\t\t\twhile (hasNext) {", "+\t\t\t\tsbAnnots.append(iAnnots.next());", "+\t\t\t\thasNext = iAnnots.hasNext();", "+\t\t\t\tif (hasNext) {", "+\t\t\t\t\tsbAnnots.append(',');", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tsbAnnots.append(']');", "+\t\t\t_traceRounds.println(sbAnnots.toString());", "+\t\t\t", "+\t\t\t_traceRounds.println(\"\\tlast round: \" + _roundEnv.processingOver()); //$NON-NLS-1$", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a8628e04705fc4b8ab0926192765a8d7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "37d67ed9fa27dc85b6112e216c3af6d687e12530", "commitAfterChange": "8924c9453af0fcfcdde960b7165abadc76ad272e", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["+\t\tfinal boolean isVarArgs = (accessFlags & IModifierConstants.ACC_VARARGS) != 0;", "-\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, (accessFlags & IModifierConstants.ACC_VARARGS) != 0));", "+\t\t\tif (checkMode(mode, WORKING_COPY) && signatureAttribute != null) {", "+\t\t\t\tfinal char[] signature = signatureAttribute.getSignature();", "+\t\t\t\tCharOperation.replace(signature, '/', '.');", "+\t\t\t\tdisassembleGenericSignature(mode, buffer, signature);", "+\t\t\t\tbuffer.append(' ');", "+\t\t\t\tbuffer.append(Signature.toCharArray(signature, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs));", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs));", "+\t\t\t}", "-\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, (accessFlags & IModifierConstants.ACC_VARARGS) != 0));", "+\t\t\tif (checkMode(mode, WORKING_COPY) && signatureAttribute != null) {", "+\t\t\t\tfinal char[] signature = signatureAttribute.getSignature();", "+\t\t\t\tCharOperation.replace(signature, '/', '.');", "+\t\t\t\tdisassembleGenericSignature(mode, buffer, signature);", "+\t\t\t\tbuffer.append(' ');", "+\t\t\t\tbuffer.append(Signature.toCharArray(signature, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs));", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(Signature.toCharArray(methodDescriptor, methodInfo.getName(), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), true, isVarArgs));", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aec4cfecbdc70acb774d229eb7e6863a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java", "commitBeforeChange": "26bbc0f1d79a90c550f0bbb95cc6eeae2aa4e3bf", "commitAfterChange": "3b79f63e00cbebb1fe326313cd6905bd51bae92d", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 29, "signatureBeforeChange": " public void exitField(int initializationStart, int declarationEnd, int declarationSourceEnd)", "signatureAfterChange": " public void exitField(int initializationStart, int declarationEnd, int declarationSourceEnd)", "diff": ["-\tSourceFieldElementInfo info = (SourceFieldElementInfo) this.infoStack.pop();", "-\tinfo.setSourceRangeEnd(declarationSourceEnd);", "-\tsetChildren(info);", "+\tJavaElement handle = (JavaElement) this.handleStack.peek();", "+\tFieldInfo fieldInfo = (FieldInfo) this.infoStack.peek();", "+\tIJavaElement[] elements = getChildren(fieldInfo);", "+\tSourceFieldElementInfo info = elements.length == 0 ? new SourceFieldElementInfo() : new SourceFieldWithChildrenInfo(elements);", "+\tinfo.setNameSourceStart(fieldInfo.nameSourceStart);", "+\tinfo.setNameSourceEnd(fieldInfo.nameSourceEnd);", "+\tinfo.setSourceRangeStart(fieldInfo.declarationStart);", "+\tinfo.setFlags(fieldInfo.modifiers);", "+\tchar[] typeName = JavaModelManager.getJavaModelManager().intern(fieldInfo.type);", "+\tinfo.setTypeName(typeName);", "+\tthis.newElements.put(handle, info);", "+\tif (fieldInfo.annotations != null) {", "+\t\tint length = fieldInfo.annotations.length;", "+\t\tthis.unitInfo.annotationNumber += length;", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.Annotation annotation = fieldInfo.annotations[i];", "+\t\t\tacceptAnnotation(annotation, info, handle);", "+\t\t}", "+\t}", "+\tinfo.setSourceRangeEnd(declarationSourceEnd);", "+\tthis.handleStack.pop();", "+\tthis.infoStack.pop();", "+\t", "-\t\t\t\t|| ((typeInfo = this.infoStack.peek()) instanceof SourceTypeElementInfo", "-\t\t\t\t\t && (Flags.isInterface(((SourceTypeElementInfo)typeInfo).flags)))) {", "+\t\t\t\t|| ((typeInfo = this.infoStack.peek()) instanceof TypeInfo", "+\t\t\t\t\t && (Flags.isInterface(((TypeInfo)typeInfo).modifiers)))) {", "-\tthis.handleStack.pop();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c85cd6dbb7ab31215eb4464a6282682c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java", "commitBeforeChange": "8c4c03ed87f5ba92a46a042a6bd51df21862c6ec", "commitAfterChange": "660d4f80c0f997ffc360c52bab006ded2ce3e10f", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "signatureAfterChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "diff": ["+    \tMap<String,String> options;", "-    \t\treturn new HashMap<String, String>();", "+    \t\toptions = new HashMap<String, String>();", "-    \t\treturn op.parse();", "+    \t\toptions = op.parse();", "+    \t", "+    \t// Add sourcepath and classpath variables", "+    \ttry {", "+    \t\tIClasspathEntry[] classpathEntries = jproj.getResolvedClasspath(true);", "+    \t\tStringBuilder classpathSB = new StringBuilder();", "+    \t\tStringBuilder sourcepathSB = new StringBuilder();", "+    \t\tboolean firstCP = true;", "+    \t\tboolean firstSP = true;", "+    \t\tfor (IClasspathEntry entry : classpathEntries) {", "+    \t\t\tint kind = entry.getEntryKind();", "+    \t\t\tif (kind == IClasspathEntry.CPE_LIBRARY) {", "+\t    \t\t\tif (firstCP) {", "+\t    \t\t\t\tfirstCP = false;", "+\t    \t\t\t}", "+\t    \t\t\telse {", "+\t    \t\t\t\tclasspathSB.append(File.pathSeparatorChar);", "+\t    \t\t\t}", "+\t    \t\t\tclasspathSB.append(entry.getPath().toFile().getAbsolutePath());", "+    \t\t\t}", "+    \t\t\telse if (kind == IClasspathEntry.CPE_SOURCE) {", "+    \t\t\t\tif (firstSP) {", "+    \t\t\t\t\tfirstSP = false;", "+    \t\t\t\t}", "+    \t\t\t\telse {", "+    \t\t\t\t\tsourcepathSB.append(File.separatorChar);", "+    \t\t\t\t}", "+    \t\t\t\tsourcepathSB.append(entry.getPath().toFile().getAbsolutePath());", "+    \t\t\t}", "+    \t\t}", "+    \t\toptions.put(\"classpath\",classpathSB.toString());", "+    \t\toptions.put(\"sourcepath\", sourcepathSB.toString());", "+    \t}", "+    \tcatch (JavaModelException jme) {", "+    \t\tAptPlugin.log(jme, \"Could not get the classpath\");", "+    \t}", "+    \t", "+    \treturn options;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ca69da2847323d9356bcd6fcfed0d9a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java", "commitBeforeChange": "271be052e104f1beefee4cd78039eca6ee6adb4f", "commitAfterChange": "f21888ae6d4ceca17a4c2f2fe7153b358e68695f", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \t \tpublic String getContext()", "signatureAfterChange": " \t \tpublic String getContext()", "diff": ["+\t\t", "+\t\tif (this.computeEnclosingElement) {", "+\t\t\tbuffer.append('\\n');", "+\t\t\tbuffer.append(\"enclosingElement=\"); //$NON-NLS-1$", "+\t\t\tJavaElement enclosingElement = (JavaElement)this.context.getEnclosingElement();", "+\t\t\tif (enclosingElement == null) {", "+\t\t\t\tbuffer.append(\"null\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(enclosingElement.toStringWithAncestors(true /*show resolved info*/));", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tif (this.computeVisibleElements) {", "+\t\t\tbuffer.append('\\n');", "+\t\t\t", "+\t\t\tIJavaElement[] visibleElements = this.context.getVisibleElements(this.assignableType);", "+\t\t\tbuffer.append(\"visibleElements=\"); //$NON-NLS-1$", "+\t\t\tif (visibleElements == null) {", "+\t\t\t\tbuffer.append(\"null\"); //$NON-NLS-1$", "+\t\t\t} else if (visibleElements.length == 0) {", "+\t\t\t\tbuffer.append(\"{}\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tbuffer.append('{');", "+\t\t\t\tbuffer.append('\\n');", "+\t\t\t\tfor (int i = 0; i < visibleElements.length; i++) {", "+\t\t\t\t\tJavaElement element = (JavaElement) visibleElements[i];", "+\t\t\t\t\tbuffer.append('\\t');", "+\t\t\t\t\tbuffer.append(element.toStringWithAncestors(true /*show resolved info*/));", "+\t\t\t\t\tbuffer.append(\",\\n\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('}');", "+\t\t\t}", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9b3ecb6be880167f4c13538579d1967", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "ee762753cd61547b0946cb35fcfd8e6f1db999a1", "commitAfterChange": "23d0eb606afafd696f3233ebc12d98689422aa13", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " \tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": " \tpublic static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\t\t\t\t\"\tvalues: {\" //$NON-NLS-1$", "+\t\t\t\t\"\tvalues: {\\n\" //$NON-NLS-1$", "-\t\t\t\t\t\t\tpublic String displayString(Object o) { return ((IClasspathContainer) o).getDescription(); }", "+\t\t\t\t\t\t\tpublic String displayString(Object o) { ", "+\t\t\t\t\t\t\t\tStringBuffer buffer = new StringBuffer(\"\t\t\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tif (o == null) {", "+\t\t\t\t\t\t\t\t\tbuffer.append(\"<null>\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\treturn buffer.toString();", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tIClasspathContainer container = (IClasspathContainer) o;", "+\t\t\t\t\t\t\t\tbuffer.append(container.getDescription());", "+\t\t\t\t\t\t\t\tbuffer.append(\" {\\n\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tIClasspathEntry[] entries = container.getClasspathEntries();", "+\t\t\t\t\t\t\t\tif (entries != null){", "+\t\t\t\t\t\t\t\t\tfor (int i = 0; i < entries.length; i++){", "+\t\t\t\t\t\t\t\t\t\tbuffer.append(\" \t\t\t\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\t\tbuffer.append(entries[i]); ", "+\t\t\t\t\t\t\t\t\t\tbuffer.append('\\n'); ", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbuffer.append(\" \t\t}\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\treturn buffer.toString();", "+\t\t\t\t\t\t\t}", "-\t\t\t\t+ \"}\"); //$NON-NLS-1$", "+\t\t\t\t+ \"\\n\t}\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\tUtil.verbose(\"\tprevious value: \" + previousContainer.getDescription()); //$NON-NLS-1$", "+\t\t\t\t\t\t\tStringBuffer buffer = new StringBuffer(previousContainer.getDescription());", "+\t\t\t\t\t\t\tbuffer.append(\" {\\n\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tIClasspathEntry[] entries = previousContainer.getClasspathEntries();", "+\t\t\t\t\t\t\tif (entries != null){", "+\t\t\t\t\t\t\t\tfor (int j = 0; j < entries.length; j++){", "+\t\t\t\t\t\t\t\t\tbuffer.append(\" \t\t\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t\tbuffer.append(entries[j]); ", "+\t\t\t\t\t\t\t\t\tbuffer.append('\\n'); ", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbuffer.append(\" \t\t}\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\tUtil.verbose(\"\tprevious value: \" + buffer.toString()); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "db793e9248641e61eab3bd32b503b68e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "267a82506dfcd2b4938ade544a2160c1561cce40", "commitAfterChange": "e87e98cf60c0ad7673fccbc25120f5081987bb3d", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": " \tprivate void disassemble(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "diff": ["-\t\tbuffer.append(Messages.disassembler_endofmethodheader); ", "+\t\tif (checkMode(mode, WORKING_COPY)) {", "+\t\t\tif (((accessFlags & IModifierConstants.ACC_NATIVE) == 0)", "+\t\t\t\t\t&& ((accessFlags & IModifierConstants.ACC_ABSTRACT) == 0)) {", "+\t\t\t\tbuffer.append(\" {\"); //$NON-NLS-1$", "+\t\t\t\tfinal char[] returnType = Signature.getReturnType(methodDescriptor);", "+\t\t\t\tif (returnType.length == 1) {", "+\t\t\t\t\tswitch(returnType[0]) {", "+\t\t\t\t\t\tcase 'V' :", "+\t\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase 'I' :", "+\t\t\t\t\t\tcase 'B' :", "+\t\t\t\t\t\tcase 'J' :", "+\t\t\t\t\t\tcase 'D' :", "+\t\t\t\t\t\tcase 'F' :", "+\t\t\t\t\t\tcase 'S' :", "+\t\t\t\t\t\tcase 'C' :", "+\t\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t\t\t\tbuffer.append(\"return 0;\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\t// boolean", "+\t\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t\t\t\tbuffer.append(\"return false;\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);\t\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// object", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber + 1);", "+\t\t\t\t\tbuffer.append(\"return null;\"); //$NON-NLS-1$", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);\t\t\t\t\t\t\t", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('}');", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(';');", "+\t\t\t}\t", "+\t\t} else {", "+\t\t\tbuffer.append(Messages.disassembler_endofmethodheader);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc175dd09c85d288d19420277f9a2aa7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java", "commitBeforeChange": "ac894da9b0ea3c039ce6982330527517abe54897", "commitAfterChange": "e3d1a6cf758d351b80734729b068cc97373e684d", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tpublic boolean visit(ArrayCreation node)", "signatureAfterChange": " \tpublic boolean visit(ArrayCreation node)", "diff": ["+", "+\t\telementType.accept(this);", "+", "+\t\t// add \"<annotations> [ <dimension> ]\" for each dimension expression", "+\t\tType type= arrayType;", "-\t\tvisitArrayTypeWithExpression(arrayType, list, --dimensions);", "+\t\tfor (int i= 0; i < list.size(); i++) {", "+\t\t\tif (node.getAST().apiLevel() >= AST.JLS8 && type instanceof ArrayType) {", "+\t\t\t\tvisitList(type, ArrayType.ANNOTATIONS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));", "+\t\t\t\ttype = (Type) getChildNode(type, ArrayType.COMPONENT_TYPE_PROPERTY);", "+\t\t\t}", "+\t\t\tthis.result.append('[');", "+\t\t\t((ASTNode) list.get(i)).accept(this);", "+\t\t\tthis.result.append(']');", "+\t\t\tdimensions--;", "+\t\t}", "+", "+\t\t// add \"<annotations> []\" for each extra array dimension", "+\t\tfor (int i= 0; i < dimensions; i++) {", "+\t\t\tif (node.getAST().apiLevel() >= AST.JLS8 && type instanceof ArrayType) {", "+\t\t\t\tvisitList(type, ArrayType.ANNOTATIONS_PROPERTY, String.valueOf(' '), Util.EMPTY_STRING, String.valueOf(' '));", "+\t\t\t\ttype = (Type) getChildNode(type, ArrayType.COMPONENT_TYPE_PROPERTY);", "+\t\t\t}", "+\t\t\tthis.result.append(\"[]\"); //$NON-NLS-1$", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e09a1e53696f4136893b662746f48191", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "f174c5e3ec66ea2a46810b190cc3e9d57c0432d4", "commitAfterChange": "8bbacffbe712e7ac5a5d22a44809b44ff8a5e616", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tprotected void verifyComments(String sourceStr, char[] source, List unitComments)", "signatureAfterChange": " \t \tprotected void verifyComments(String fileName, char[] source)", "diff": ["+\t", "+\tprotected void verifyComments(String fileName, char[] source) {", "+", "+\t\t// Get comments infos from test file", "+\t\tsetSourceComment(source);", "+\t\t", "+\t\t// Verify comments either in unicode or not", "+\t\tchar[] testedSource = source;", "+\t\tif (unicode) {", "+\t\t\ttestedSource = getUnicodeSource(source);", "+\t\t}", "+//\t\tMap originalOptions = this.currentProject.getOptions(true);", "+//\t\ttry {", "+//\t\t\tthis.currentProject.setOption(JavaCore.COMPILER_PB_INVALID_JAVADOC, this.compilerOption);", "+//\t\t\tthis.currentProject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_TAGS, this.compilerOption);", "+//\t\t\tthis.currentProject.setOption(JavaCore.COMPILER_PB_MISSING_JAVADOC_COMMENTS, this.compilerOption);", "+//\t\t\tthis.currentProject.setOption(JavaCore.COMPILER_PB_METHOD_WITH_CONSTRUCTOR_NAME, JavaCore.IGNORE);", "+//\t\t\tthis.currentProject.setOption(JavaCore.COMPILER_DOC_COMMENT_SUPPORT, this.docCommentSupport);", "+\t\t\tCompilationUnit compilUnit = (CompilationUnit) runConversion(testedSource, fileName, this.currentProject);", "+//\t\t\tCompilationUnit compilUnit = (CompilationUnit) runConversion(this.sourceUnit, this.resolveBinding); // resolve bindings", "+//\t\t} finally {", "+//\t\t\tthis.currentProject.setOptions(originalOptions);", "+//\t\t}", "-\t */", "-\tprotected void verifyComments(String sourceStr, char[] source, List unitComments) {", "-\t\t// Get comments infos from test file", "-\t\tsetSourceComment(source);", "-\t\tassumeEquals(this.prefix+\"Wrong number of comments in source:\\n\"+sourceStr+\"\\n\", this.comments.size(), size);", "+\t\tassumeEquals(this.prefix+\"Wrong number of comments!\", this.comments.size(), size);", "+", "-\t\tfor (int i=0; i<size; i++) {", "-\t\t\tComment comment = (Comment) unitComments.get(i);", "-\t\t\tList tags = (List) allTags.get(i);", "-\t\t\t// Verify flattened content", "-\t\t\tString stringComment = (String) this.comments.get(i);", "-\t\t\tASTConverterJavadocFlattener printer = new ASTConverterJavadocFlattener(stringComment);", "-\t\t\tcomment.accept(printer);", "-\t\t\tString text = new String(source, comment.getStartPosition(), comment.getLength());", "-\t\t\tassumeEquals(this.prefix+\"Flattened comment does NOT match source!\", stringComment, text);", "-\t\t\t// Verify javdoc tags positions and bindings", "-\t\t\tif (comment.isDocComment()) {", "-\t\t\t\tJavadoc docComment = (Javadoc)comment;", "-\t\t\t\tassumeEquals(this.prefix+\"Invalid tags number in javadoc:\\n\"+docComment+\"\\n\", tags.size(), allTags(docComment));", "-\t\t\t\tverifyPositions(docComment, source);", "-\t\t\t\tif (this.resolveBinding) {", "-\t\t\t\t\tverifyBindings(docComment);", "+//\t\tif (this.comments.size() == size) {", "+\t\t\tfor (int i=0; i<size; i++) {", "+\t\t\t\tComment comment = (Comment) unitComments.get(i);", "+\t\t\t\tList tags = (List) allTags.get(i);", "+\t\t\t\t// Verify flattened content", "+\t\t\t\tString stringComment = (String) this.comments.get(i);", "+\t//\t\t\tASTConverterJavadocFlattener printer = new ASTConverterJavadocFlattener(stringComment);", "+\t//\t\t\tcomment.accept(printer);", "+\t\t\t\tString text = new String(testedSource, comment.getStartPosition(), comment.getLength());", "+\t\t\t\tassumeEquals(this.prefix+\"Flattened comment does NOT match source!\", stringComment, text);", "+\t\t\t\t// Verify javdoc tags positions and bindings", "+\t\t\t\tif (comment.isDocComment()) {", "+\t\t\t\t\tJavadoc docComment = (Javadoc)comment;", "+\t\t\t\t\tif (this.docCommentSupport.equals(JavaCore.ENABLED)) {", "+\t\t\t\t\t\tassumeEquals(this.prefix+\"Invalid tags number in javadoc:\\n\"+docComment+\"\\n\", tags.size(), allTags(docComment));", "+\t\t\t\t\t\tverifyPositions(docComment, testedSource);", "+\t\t\t\t\t\tif (this.resolveBinding) {", "+\t\t\t\t\t\t\tverifyBindings(docComment);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tassumeEquals(\"Javadoc should be flat!\", 0, docComment.tags().size());", "+\t\t\t\t\t}", "-\t\t}", "+//\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e138effe53656fd0a26ee98dbdf16795", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java", "commitBeforeChange": "1fa0b970f57a68665cdfde955081db2621c42276", "commitAfterChange": "be945f896dfe94a8d4114819ea1c2afbe987ee6b", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["+\t\t\t\t} else if (_returnType.isArray() && _returnType.getElementType().isTypeVariable()) {", "+\t\t\t\t\tint dimensions = _returnType.getDimensions();", "+\t\t\t\t\tbuffer.append(_returnType.getElementType().getQualifiedName());", "+\t\t\t\t\tfor (int i = 0; i < dimensions; i++) {", "+\t\t\t\t\t\tbuffer.append('[').append(']');", "+\t\t\t\t\t}", "+\t\t\t\t\t} else if (parameter.isArray() && parameter.getElementType().isTypeVariable()) {", "+\t\t\t\t\t\tint dimensions = parameter.getDimensions();", "+\t\t\t\t\t\tbuffer.append(parameter.getElementType().getQualifiedName());", "+\t\t\t\t\t\tfor (int j = 0; j < dimensions; j++) {", "+\t\t\t\t\t\t\tbuffer.append('[').append(']');", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (thrownException.isArray() && thrownException.getElementType().isTypeVariable()) {", "+\t\t\t\t\t\tint dimensions = thrownException.getDimensions();", "+\t\t\t\t\t\tbuffer.append(thrownException.getElementType().getQualifiedName());", "+\t\t\t\t\t\tfor (int j = 0; j < dimensions; j++) {", "+\t\t\t\t\t\t\tbuffer.append('[').append(']');", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e796f25e94597de527ebfade036cd12f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileWorkingCopy.java", "commitBeforeChange": "24ecdaaa88a3d3df53c6657b56b1c35a02f254d7", "commitAfterChange": "b77d2ea3108de5650fdc8f1f0c9f51bf7203159f", "methodNumberBeforeChange": 76, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner wcowner) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "diff": ["+ */", "+protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException {", "+\t// create buffer", "+\tIBuffer buffer = this.owner.createBuffer(this);", "+\tif (buffer == null) return null;", "+\t// set the buffer source", "+\tif (buffer.getCharacters() == null) {", "+\t\tIBuffer classFileBuffer = this.classFile.getBuffer();", "+\t\tif (classFileBuffer != null) {", "+\t\t\tbuffer.setContents(classFileBuffer.getCharacters());", "+\t\t} else {", "+\t\t\t// Disassemble", "+\t\t\tIClassFileReader reader = ToolFactory.createDefaultClassFileReader(this.classFile, IClassFileReader.ALL);", "+\t\t\tDisassembler disassembler = new Disassembler();", "+\t\t\tString contents = disassembler.disassemble(reader, Util.getLineSeparator(\"\", getJavaProject()), ClassFileBytesDisassembler.WORKING_COPY); //$NON-NLS-1$", "+\t\t\tbuffer.setContents(contents);", "+\t\t}", "+", "+\t// add buffer to buffer cache", "+\tBufferManager bufManager = getBufferManager();", "+\tbufManager.addBuffer(buffer);", "+\t\t\t", "+\t// listen to buffer changes", "+\tbuffer.addBufferChangedListener(this);", "+\treturn buffer;", "+}", "-\t */", "-\tpublic void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner wcowner) throws JavaModelException {", "-\t\tthrow new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e9006c2c87f90ea2bacd23038fe176a4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingStatementsTest.java", "commitBeforeChange": "bebbc656cd8c0b5b2b17917b50736d005533495d", "commitAfterChange": "53b5fe3415daa91888a4dcef6f73ef37da327c9d", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \t \tpublic void testAssertStatement() throws Exception", "signatureAfterChange": " \t \tpublic void testAssertStatement() throws Exception", "diff": ["+\t\tbuf.append(\"        assert/* comment*/true;\\n\");", "+\t\tbuf.append(\"        assert(true);\\n\");", "+\t\tbuf.append(\"        assert(true) : \\\"Hello\\\";\\n\");", "+\t\tbuf.append(\"        assert(true) : \\\"Hello\\\";\\n\");", "-\t\tassertTrue(\"Number of statements not 1\", statements.size() == 1);", "-\t\t{ // insert expression", "+\t\tassertTrue(\"Number of statements not 5\", statements.size() == 5);", "+\t\t{ // replace expression", "-\t\t}\t\t", "+\t\t}", "+\t\t{ // replace expression", "+\t\t\tAssertStatement statement= (AssertStatement) statements.get(1);", "+\t\t\t", "+\t\t\tSimpleName newExpression= ast.newSimpleName(\"x\");\t", "+\t\t\trewrite.set(statement, AssertStatement.EXPRESSION_PROPERTY, newExpression, null);", "+\t\t}", "+\t\t{ // insert message", "+\t\t\tAssertStatement statement= (AssertStatement) statements.get(2);", "+\t\t\t", "+\t\t\tSimpleName newExpression= ast.newSimpleName(\"x\");\t", "+\t\t\trewrite.set(statement, AssertStatement.MESSAGE_PROPERTY, newExpression, null);", "+\t\t}", "+\t\t{ // replace message", "+\t\t\tAssertStatement statement= (AssertStatement) statements.get(3);", "+\t\t\t", "+\t\t\tSimpleName newExpression= ast.newSimpleName(\"x\");\t", "+\t\t\trewrite.set(statement, AssertStatement.MESSAGE_PROPERTY, newExpression, null);", "+\t\t}", "+\t\t{ // remove message", "+\t\t\tAssertStatement statement= (AssertStatement) statements.get(4);", "+\t\t\t", "+\t\t\trewrite.set(statement, AssertStatement.MESSAGE_PROPERTY, null, null);", "+\t\t}\t", "+\t\tbuf.append(\"        assert x;\\n\");", "+\t\tbuf.append(\"        assert(true) : x;\\n\");", "+\t\tbuf.append(\"        assert(true) : x;\\n\");", "+\t\tbuf.append(\"        assert(true);\\n\");"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f79c4f2ca54953a183798ba423dcd2f4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceModelTests.java", "commitBeforeChange": "3916c67b0128c74e08a07f109332d68e11705964", "commitAfterChange": "db24d1d0025b319685ad3bf80253e7a07fb708a2", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " private void setUpBigProject() throws CoreException", "signatureAfterChange": " private void setUpBigProject() throws CoreException, IOException", "diff": ["-private void setUpBigProject() throws CoreException {", "+private void setUpBigProject() throws CoreException, IOException {", "+\t\tString targetWorkspacePath = workspaceRoot.getLocation().toFile().getCanonicalPath();", "-\t\tSystem.out.println(\"Create project \"+BIG_PROJECT_NAME+\" in \"+workspaceRoot.getLocation()+\":\");", "-", "-\t\t// setup projects with several source folders and several packages per source folder", "-\t\tSystem.out.println(\"\t- create \"+FOLDERS_COUNT+\" folders x \"+PACKAGES_COUNT+\" packages...\");", "-\t\tfinal String[] sourceFolders = new String[FOLDERS_COUNT];", "-\t\tfor (int i = 0; i < FOLDERS_COUNT; i++) {", "-\t\t\tsourceFolders[i] = \"src\" + i;", "-\t\t}", "-\t\tString path = workspaceRoot.getLocation().toString() + \"/BigProject/src\";", "-\t\tfor (int i = 0; i < FOLDERS_COUNT; i++) {", "-\t\t\tif (PRINT && i>0 && i%10==0) System.out.print(\"\t\t+ folder src\"+i+\"...\");", "-\t\t\tlong top = System.currentTimeMillis();", "-\t\t\tfor (int j = 0; j < PACKAGES_COUNT; j++) {", "-\t\t\t\tnew java.io.File(path + i + \"/org/eclipse/jdt/core/tests\" + i + \"/performance\" + j).mkdirs();", "+\t\tFile wkspDir = new File(targetWorkspacePath);", "+\t\tFile projectDir = new File(wkspDir, BIG_PROJECT_NAME);", "+\t\tif (projectDir.exists()) {", "+\t\t\tSystem.out.print(\"Add existing project \"+BIG_PROJECT_NAME+\" in \"+workspaceRoot.getLocation()+\" to workspace...\");", "+\t\t\tIProject bigProject = workspaceRoot.getProject(BIG_PROJECT_NAME);", "+\t\t\tif (bigProject.exists()) {", "+\t\t\t\tENV.addProject(bigProject);", "+\t\t\t} else {", "+\t\t\t\tENV.addProject(BIG_PROJECT_NAME);", "-\t\t\tif (PRINT && i>0 && i%10==0) System.out.println(\"(\"+(System.currentTimeMillis()-top)+\"ms)\");", "+\t\t\tBIG_PROJECT = (JavaProject) ENV.getJavaProject(BIG_PROJECT_NAME);", "+\t\t\tBIG_PROJECT.setRawClasspath(BIG_PROJECT.getRawClasspath(), null);", "+\t\t} else {", "+\t\t\tSystem.out.println(\"Create project \"+BIG_PROJECT_NAME+\" in \"+workspaceRoot.getLocation()+\":\");", "+\t", "+\t\t\t// setup projects with several source folders and several packages per source folder", "+\t\t\tSystem.out.println(\"\t- create \"+FOLDERS_COUNT+\" folders x \"+PACKAGES_COUNT+\" packages...\");", "+\t\t\tfinal String[] sourceFolders = new String[FOLDERS_COUNT];", "+\t\t\tfor (int i = 0; i < FOLDERS_COUNT; i++) {", "+\t\t\t\tsourceFolders[i] = \"src\" + i;", "+\t\t\t}", "+\t\t\tString path = workspaceRoot.getLocation().toString() + \"/BigProject/src\";", "+\t\t\tfor (int i = 0; i < FOLDERS_COUNT; i++) {", "+\t\t\t\tif (PRINT && i>0 && i%10==0) System.out.print(\"\t\t+ folder src\"+i+\"...\");", "+\t\t\t\tlong top = System.currentTimeMillis();", "+\t\t\t\tfor (int j = 0; j < PACKAGES_COUNT; j++) {", "+\t\t\t\t\tnew java.io.File(path + i + \"/org/eclipse/jdt/core/tests\" + i + \"/performance\" + j).mkdirs();", "+\t\t\t\t}", "+\t\t\t\tif (PRINT && i>0 && i%10==0) System.out.println(\"(\"+(System.currentTimeMillis()-top)+\"ms)\");", "+\t\t\t}", "+\t\t\tSystem.out.println(\"\t\t=> global time = \"+(System.currentTimeMillis()-start)/1000.0+\" seconds)\");", "+", "+\t\t\t// Add project to workspace", "+\t\t\tstart = System.currentTimeMillis();", "+\t\t\tSystem.out.print(\"\t- add project to full source workspace...\");", "+\t\t\tENV.addProject(BIG_PROJECT_NAME);", "+\t\t\tBIG_PROJECT = (JavaProject) createJavaProject(BIG_PROJECT_NAME, sourceFolders, \"bin\", \"1.4\");", "+\t\t\tBIG_PROJECT.setRawClasspath(BIG_PROJECT.getRawClasspath(), null);", "-", "-\t\t// Print for log in case of project creation troubles...", "-\t\tSystem.out.println(\"\t\t=> global time = \"+(System.currentTimeMillis()-start)/1000.0+\" seconds)\");", "-\t\tstart = System.currentTimeMillis();", "-\t\tSystem.out.print(\"\t- add project to full source workspace...\");", "-", "-\t\t// Add project to workspace", "-\t\tENV.addProject(BIG_PROJECT_NAME);", "-\t\tBIG_PROJECT = (JavaProject) createJavaProject(BIG_PROJECT_NAME, sourceFolders, \"bin\", \"1.4\");", "-\t\tBIG_PROJECT.setRawClasspath(BIG_PROJECT.getRawClasspath(), null);", "+\t\tSystem.out.println(\"(\"+(System.currentTimeMillis()-start)+\"ms)\");", "-\t\tString content = \"package org.eclipse.jdt.core.tests\" + (FOLDERS_COUNT-1) + \".performance\" + (PACKAGES_COUNT-1) + \";\\n\" +", "-\t\t\t\"public class TestBigProject {\\n\" +", "-\t\t\t\"\tclass Level1 {\\n\" +", "-\t\t\t\"\t\tclass Level2 {\\n\" +", "-\t\t\t\"\t\t\tclass Level3 {\\n\" +", "-\t\t\t\"\t\t\t\tclass Level4 {\\n\" +", "-\t\t\t\"\t\t\t\t\tclass Level5 {\\n\" +", "-\t\t\t\"\t\t\t\t\t\tclass Level6 {\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\tclass Level7 {\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t\tclass Level8 {\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t\t\tclass Level9 {\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t\t\t\tclass Level10 {}\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t\t}\\n\" +", "-\t\t\t\"\t\t\t}\\n\" +", "-\t\t\t\"\t\t}\\n\" +", "-\t\t\t\"\t}\\n\" +", "-\t\t\t\"}\\n\" +", "-\t\t\t\"class TestSecondary {}\\n\";", "-\t\tfile.create(new ByteArrayInputStream(content.getBytes()), true, null);", "+\t\tif (!file.exists()) {", "+\t\t\tString content = \"package org.eclipse.jdt.core.tests\" + (FOLDERS_COUNT-1) + \".performance\" + (PACKAGES_COUNT-1) + \";\\n\" +", "+\t\t\t\t\"public class TestBigProject {\\n\" +", "+\t\t\t\t\"\tclass Level1 {\\n\" +", "+\t\t\t\t\"\t\tclass Level2 {\\n\" +", "+\t\t\t\t\"\t\t\tclass Level3 {\\n\" +", "+\t\t\t\t\"\t\t\t\tclass Level4 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\tclass Level5 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\tclass Level6 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\tclass Level7 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t\tclass Level8 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t\t\tclass Level9 {\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t\t\t\tclass Level10 {}\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t\t}\\n\" +", "+\t\t\t\t\"\t\t}\\n\" +", "+\t\t\t\t\"\t}\\n\" +", "+\t\t\t\t\"}\\n\" +", "+\t\t\t\t\"class TestSecondary {}\\n\";", "+\t\t\tfile.create(new ByteArrayInputStream(content.getBytes()), true, null);", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ffd1eb7743df57937cf57e1ab1c424cb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "43910be7c5e7874a970515d1dbb3b63c454bc688", "commitAfterChange": "d7d4a2e6181a270380c8726d1367c8cd49a78b6b", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t\t \tprivate void buildContext(ASTNode astNode)", "signatureAfterChange": " \t\t \tprivate void buildContext( \t\t\tASTNode astNode, \t\t\tASTNode astNodeParent, \t\t\tBinding qualifiedBinding, \t\t\tScope scope)", "diff": ["-\tprivate void buildContext(ASTNode astNode) {", "+\tprivate void buildContext(", "+\t\t\tASTNode astNode,", "+\t\t\tASTNode astNodeParent,", "+\t\t\tBinding qualifiedBinding,", "+\t\t\tScope scope) {", "+\t\tcontext.setOffset(this.actualCompletionPosition + 1);", "+\t\t", "+\t\t}", "+\t\t", "+\t\tif (!(astNode instanceof CompletionOnJavadoc)) {", "+\t\t\tCompletionScanner scanner = (CompletionScanner)this.parser.scanner;", "+\t\t\tcontext.setToken(scanner.completionIdentifier);", "+\t\t\tcontext.setTokenRange(", "+\t\t\t\t\tscanner.completedIdentifierStart,", "+\t\t\t\t\tscanner.completedIdentifierEnd,", "+\t\t\t\t\tscanner.endOfEmptyToken);", "+\t\t} else if(astNode instanceof CompletionOnJavadocTag) {", "+\t\t\tCompletionOnJavadocTag javadocTag = (CompletionOnJavadocTag) astNode;", "+\t\t\tcontext.setToken(CharOperation.concat(new char[]{'@'}, javadocTag.token));", "+\t\t\tcontext.setTokenRange(", "+\t\t\t\t\tjavadocTag.tagSourceStart,", "+\t\t\t\t\tjavadocTag.tagSourceEnd,", "+\t\t\t\t\t((CompletionScanner)this.parser.javadocParser.scanner).endOfEmptyToken);", "+\t\t} else {", "+\t\t\tCompletionScanner scanner = (CompletionScanner)this.parser.javadocParser.scanner;", "+\t\t\tcontext.setToken(scanner.completionIdentifier);", "+\t\t\tcontext.setTokenRange(", "+\t\t\t\t\tscanner.completedIdentifierStart,", "+\t\t\t\t\tscanner.completedIdentifierEnd,", "+\t\t\t\t\tscanner.endOfEmptyToken);", "+\t\t}", "+\t\t", "+\t\t", "+\t\t//TODO add support for string literal", "+\t\tcontext.setTokenKind(CompletionContext.TOKEN_KIND_NAME);", "+\t\t", "+\t\tif(DEBUG) {", "+\t\t\tSystem.out.println(context.toString());"]}], "num": 61277}