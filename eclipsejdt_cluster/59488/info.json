{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7be011eb6df1b544a914decdb91f7ba1", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f337ce9604e16440979dd5362efea4f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "f908d0c09b5bf34a0f6e90dacd8d551c0f19870c", "commitAfterChange": "2d9e2019b5b59684e0488ab5bab1ae5850c1ca71", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "diff": ["-\t\t\t    returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t    this.returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\tboolean argAlreadyInferred = argument != originalVariable;", "-\t\t\t\t\tScope.substitute(this, originalVariable.firstBound) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\t// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)", "+\t\t\t\t\t//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "-\t\t\t\t\tScope.substitute(this, originalVariable.superInterfaces[j]) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a9eb3bb7c76f7e98c4b9a3edcab8bd03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " private void createMethods(IBinaryMethod[] iMethods, long sourceLevel)", "signatureAfterChange": " private void createMethods(IBinaryMethod[] iMethods, long sourceLevel)", "diff": ["+\tboolean isViewedAsDeprecated = isViewedAsDeprecated();", "-\t\tfor (int i = 0; i < initialTotal; i++)", "-\t\t\tthis.methods[i] = createMethod(iMethods[i], sourceLevel);", "+\t\tfor (int i = 0; i < initialTotal; i++) {", "+\t\t\tMethodBinding method = createMethod(iMethods[i], sourceLevel);", "+\t\t\tif (isViewedAsDeprecated && !method.isDeprecated()) {", "+\t\t\t\tmethod.modifiers |= AccDeprecatedImplicitly;", "+\t\t\t}\t\t", "+\t\t\tthis.methods[i] = method;", "+\t\t}", "-\t\t\tif (iClinit != i && (toSkip == null || toSkip[i] != -1))", "-\t\t\t\tthis.methods[index++] = createMethod(iMethods[i], sourceLevel);", "+\t\t\tif (iClinit != i && (toSkip == null || toSkip[i] != -1)) {", "+\t\t\t\tMethodBinding method = createMethod(iMethods[i], sourceLevel);", "+\t\t\t\tif (isViewedAsDeprecated && !method.isDeprecated()) {", "+\t\t\t\t\tmethod.modifiers |= AccDeprecatedImplicitly;", "+\t\t\t\t}\t\t", "+\t\t\t\tthis.methods[index++] = method;", "+\t\t\t}"]}], "num": 59488}