{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "fd650c0dd8cb24c5700764b3d379be38", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1451467d66ac9e953d37bad9e0781594", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "71df68ac6bbd7c5b4b673539241b9c1cc905574c", "commitAfterChange": "04c08732703d5f5e97b66e89468d2f87b7f84cff", "methodNumberBeforeChange": 110, "methodNumberAfterChange": 113, "signatureBeforeChange": " \tpublic void resetSecondaryTypesCache(String path)", "signatureAfterChange": " \tpublic void secondaryTypeAdding(String path, char[] key)", "diff": ["-\t */", "-\tpublic void resetSecondaryTypesCache(String path) {", "-\t\tif (VERBOSE) {", "-\t\t\tStringBuffer buffer = new StringBuffer(\"JavaModelManager.resetSecondaryTypePaths(\"); //$NON-NLS-1$", "-\t\t\tbuffer.append(path);", "-\t\t\tbuffer.append(')');", "-\t\t\tUtil.verbose(buffer.toString());", "-\t\t}", "-\t\tIWorkspaceRoot wRoot = ResourcesPlugin.getWorkspace().getRoot();", "-\t\tIResource resource = wRoot.findMember(path);", "-\t\tif (resource != null) {", "-\t\t\tPerProjectInfo projectInfo = getPerProjectInfo(resource.getProject(), false);", "-\t\t\tif (projectInfo != null) {", "-\t\t\t\tif (VERBOSE) {", "-\t\t\t\t\tUtil.verbose(\"-> reset cache for project: \"+resource.getProject().getName()); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tif (projectInfo.secondaryTypes != null) {", "-\t\t\t\t\tObject dirty = projectInfo.secondaryTypes.get(DIRTY_CACHE);", "-\t\t\t\t\tif (dirty == null) {", "-\t\t\t\t\t\tprojectInfo.secondaryTypes.put(DIRTY_CACHE, resource);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tHashSet resources = (dirty instanceof HashSet) ? (HashSet) dirty : new HashSet(3);", "-\t\t\t\t\t\tresources.add(resource);", "-\t\t\t\t\t\tprojectInfo.secondaryTypes.put(DIRTY_CACHE, resource);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "+\t */", "+\tpublic void secondaryTypeAdding(String path, char[] key) {", "+\t\tif (VERBOSE) {", "+\t\t\tStringBuffer buffer = new StringBuffer(\"JavaModelManager.addSecondaryType(\"); //$NON-NLS-1$", "+\t\t\tbuffer.append(path);", "+\t\t\tbuffer.append(',');", "+\t\t\tbuffer.append('[');", "+\t\t\tbuffer.append(new String(key));", "+\t\t\tbuffer.append(']');", "+\t\t\tbuffer.append(')');", "+\t\t\tUtil.verbose(buffer.toString());", "+\t\t}", "+\t\tIWorkspaceRoot wRoot = ResourcesPlugin.getWorkspace().getRoot();", "+\t\tIResource resource = wRoot.findMember(path);", "+\t\tif (resource != null) {", "+\t\t\tif (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(path) && resource.getType() == IResource.FILE) {", "+\t\t\t\tIProject project = resource.getProject();", "+\t\t\t\ttry {", "+\t\t\t\t\tPerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project);", "+\t\t\t\t\t// Get or create map to cache secondary types while indexing (can be not synchronized as indexing insure a non-concurrent usage)", "+\t\t\t\t\tHashMap indexedSecondaryTypes = null;", "+\t\t\t\t\tif (projectInfo.secondaryTypes == null) {", "+\t\t\t\t\t\tprojectInfo.secondaryTypes = new Hashtable(3);", "+\t\t\t\t\t\tindexedSecondaryTypes = new HashMap(3);", "+\t\t\t\t\t\tprojectInfo.secondaryTypes.put(INDEXED_SECONDARY_TYPES, indexedSecondaryTypes);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tindexedSecondaryTypes = (HashMap) projectInfo.secondaryTypes.get(INDEXED_SECONDARY_TYPES);", "+\t\t\t\t\t\tif (indexedSecondaryTypes == null) {", "+\t\t\t\t\t\t\tindexedSecondaryTypes = new HashMap(3);", "+\t\t\t\t\t\t\tprojectInfo.secondaryTypes.put(INDEXED_SECONDARY_TYPES, indexedSecondaryTypes);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\t// Store the secondary type in temporary cache (these are just handles => no problem to create it now...)", "+\t\t\t\t\tHashMap allTypes = (HashMap) indexedSecondaryTypes.get(resource);", "+\t\t\t\t\tif (allTypes == null) {", "+\t\t\t\t\t\tallTypes = new HashMap(3);", "+\t\t\t\t\t\tindexedSecondaryTypes.put(resource, allTypes);", "+\t\t\t\t\t}", "+\t\t\t\t\tICompilationUnit unit = JavaModelManager.createCompilationUnitFrom((IFile)resource, null);", "+\t\t\t\t\tif (unit != null) {", "+\t\t\t\t\t\tchar[][] names = CharOperation.splitOn('/', key);", "+\t\t\t\t\t\tString typeName = new String(names[0]);", "+\t\t\t\t\t\tString packName = new String(names[1]);", "+\t\t\t\t\t\tHashMap packageTypes = (HashMap) allTypes.get(packName);", "+\t\t\t\t\t\tif (packageTypes == null) {", "+\t\t\t\t\t\t\tpackageTypes = new HashMap(3);", "+\t\t\t\t\t\t\tallTypes.put(packName, packageTypes);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tpackageTypes.put(typeName, unit.getType(typeName));", "+\t\t\t\t\t}", "+\t\t\t\t\tif (VERBOSE) {", "+\t\t\t\t\t\tUtil.verbose(\"\t- indexing cache:\"); //$NON-NLS-1$", "+\t\t\t\t\t\tIterator keys = indexedSecondaryTypes.keySet().iterator();", "+\t\t\t\t\t\twhile (keys.hasNext()) {", "+\t\t\t\t\t\t\tIFile file = (IFile) keys.next();", "+\t\t\t\t\t\t\tUtil.verbose(\"\t\t+ \"+file.getFullPath()+':'+indexedSecondaryTypes.get(file) ); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tcatch (JavaModelException jme) {", "+\t\t\t\t\t// do nothing", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2a57cbb79b3facff2b624a77c9a3a0a9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "80a36bf53ae731edac012c99749b4fd073634fd5", "commitAfterChange": "775667d78092a7c5a2c35b021921f25b4037d7f4", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-\t\t\t", "+", "-\t", "+", "-\t\t\t\t\t\t\tFieldBinding fieldBinding =", "-\t\t\t\t\t\t\t\tclassScope.findField(enclosingType, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "-\t", "+", "-\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass", "-\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4){", "+\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t", "-\t\t\t\t\t\t\t\tif (foundField == null", "-\t\t\t\t\t\t\t\t\t|| (foundField.problemId() == NotVisible", "-\t\t\t\t\t\t\t\t\t\t&& fieldBinding.problemId() != NotVisible)) {", "+", "+\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "-\t", "+", "-\t\t\t\t\tif (foundField.isValidBinding()){", "-\t\t\t\t\t\tif (foundDepth > 0){", "+\t\t\t\t\tif (foundField.isValidBinding()) {", "+\t\t\t\t\t\tif (foundDepth > 0) {", "+", "+\t\t\t\tif (environment().options.complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t\t\t// at this point the scope is a compilation unit scope & need to check for imported static fields", "+\t\t\t\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "+\t\t\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\t\t\tif (imports != null) {", "+\t\t\t\t\t\t// check single static imports", "+\t\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\t\t\tif (importBinding.isStatic() && !importBinding.onDemand) {", "+\t\t\t\t\t\t\t\tif (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\t\t\tif (unitScope.resolveSingleImport(importBinding) != null && importBinding.resolvedImport instanceof FieldBinding) {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\treturn importBinding.resolvedImport; // already know its visible", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// check on demand imports", "+\t\t\t\t\t\tboolean foundInImport = false;", "+\t\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\t\t\tif (importBinding.isStatic() && importBinding.onDemand) {", "+\t\t\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t\t\t\t\t\tif (resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\t\t\tFieldBinding temp = findField((ReferenceBinding) resolvedImport, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\t\t\tif (!temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\t\tproblemField = temp;", "+\t\t\t\t\t\t\t\t\t\t} else if (temp.isStatic()) {", "+\t\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand packages.", "+\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "+\t\t\t\t\t\t\t\t\t\t\tfoundField = temp;", "+\t\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (foundField != null) return foundField;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d0a278ff47dd21004a1275aefb16e57", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "0e8ca24e8451f1d91ed53a269d184ea21d12301f", "commitAfterChange": "369ffd3db09511488e039ba2575df2eeea055320", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r \tprotected void elementAdded(Openable element, IResourceDelta delta)", "signatureAfterChange": "\r \tprotected void elementAdded(Openable element, IResourceDelta delta)", "diff": ["-\r", "-\t\tif (element.getElementType() == IJavaElement.JAVA_PROJECT) {\r", "+\t\tint elementType = element.getElementType();\r", "+\t\tif (elementType == IJavaElement.JAVA_PROJECT) {\r", "-\t\t\t\tbasicElementAdded(element, delta);\r", "+\t\t\t\taddToParentInfo(element);\r", "+\t\t\t\tfCurrentDelta.added(element);\r", "-\t\t\tbasicElementAdded(element, delta);\r", "+\t\t\taddToParentInfo(element);\r", "+\t\t\tfCurrentDelta.added(element);\r", "+\t\t\t\r", "+\t\t\tswitch (elementType) {\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT :\r", "+\t\t\t\t\t// when a root is added, and is on the classpath, the project must be updated\r", "+\t\t\t\t\tthis.projectsToUpdate.add(element.getJavaProject());\r", "+\t\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");//$NON-NLS-1$\r", "+\t\t\t\t\t// don't break as subpackages must be added too\r", "+\t\t\t\tcase IJavaElement.PACKAGE_FRAGMENT :\r", "+\t\t\t\t\t// get rid of namelookup since it holds onto obsolete cached info \r", "+\t\t\t\t\tJavaProject project = (JavaProject) element.getJavaProject();\r", "+\t\t\t\t\ttry {\r", "+\t\t\t\t\t\tproject.getJavaProjectElementInfo().setNameLookup(null);\r", "+\t\t\t\t\t} catch (JavaModelException e) {\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// add subpackages\r", "+\t\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "+\t\t\t\t\tString name = element.getElementName();\r", "+\t\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "+\t\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "+\t\t\t\t\t\tIResourceDelta child = children[i];\r", "+\t\t\t\t\t\tIResource resource = child.getResource();\r", "+\t\t\t\t\t\tif (resource instanceof IFolder) {\r", "+\t\t\t\t\t\t\tString subpkgName = \r", "+\t\t\t\t\t\t\t\tname.length() == 0 ? \r", "+\t\t\t\t\t\t\t\t\tresource.getName() : \r", "+\t\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "+\t\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "+\t\t\t\t\t\t\tthis.updateIndex(subpkg, child);\r", "+\t\t\t\t\t\t\tthis.elementAdded(subpkg, child);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3f3d68c1f9f859ac90bc0a9db993fea3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "0e8ca24e8451f1d91ed53a269d184ea21d12301f", "commitAfterChange": "369ffd3db09511488e039ba2575df2eeea055320", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \tprotected void elementRemoved(Openable element, IResourceDelta delta)", "signatureAfterChange": "\r \tprotected void elementRemoved(Openable element, IResourceDelta delta)", "diff": ["+\t\t\tcase IJavaElement.JAVA_MODEL :\r", "+\t\t\t\telement.getJavaModelManager().getIndexManager().reset();\r", "+\t\t\t\telement.getJavaModelManager().fModelInfo = null;\r", "+\t\t\t\tbreak;\r", "-\t\t\t\tbreak;\r", "+\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");//$NON-NLS-1$\r", "+\t\t\t\t// don't break so that subpackages are also removed\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.JAVA_MODEL :\r", "-\t\t\t\telement.getJavaModelManager().getIndexManager().reset();\r", "-\t\t\t\telement.getJavaModelManager().fModelInfo = null;\r", "+\t\t\t\t// remove subpackages\r", "+\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "+\t\t\t\tString name = element.getElementName();\r", "+\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "+\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "+\t\t\t\t\tIResourceDelta child = children[i];\r", "+\t\t\t\t\tIResource resource = child.getResource();\r", "+\t\t\t\t\tif (resource instanceof IFolder) {\r", "+\t\t\t\t\t\tString subpkgName = \r", "+\t\t\t\t\t\t\tname.length() == 0 ? \r", "+\t\t\t\t\t\t\t\tresource.getName() : \r", "+\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "+\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "+\t\t\t\t\t\tthis.updateIndex(subpkg, child);\r", "+\t\t\t\t\t\tthis.elementRemoved(subpkg, child);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "58c5d99f7103032cd3a6f65b6caf80cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/HierarchyScope.java", "commitBeforeChange": "7fb86fb96d585ee8957fc13764a67f220efdab28", "commitAfterChange": "ac9209adc3bf5bee5093a73bfc9f86fe5825e76d", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tprotected boolean encloses(IResource element)", "signatureAfterChange": " \tprivate IPath[] computeProjectsAndJars(IType type) throws JavaModelException", "diff": ["+\t * This is a super set of the project and jar paths once the hierarchy is computed.\r\t */", "+\tprivate IPath[] computeProjectsAndJars(IType type) throws JavaModelException {", "+\t\tHashSet set = new HashSet();", "+\t\tIPackageFragmentRoot root = (IPackageFragmentRoot)type.getPackageFragment().getParent();", "+\t\tif (root.isArchive()) {", "+\t\t\t// add the root", "+\t\t\tset.add(root.getPath());", "+\t\t\t// add all projects that reference this archive and their dependents", "+\t\t\tIPath rootPath = root.getPath();", "+\t\t\tIJavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "+\t\t\tIJavaProject[] projects = model.getJavaProjects();", "+\t\t\tHashSet visited = new HashSet();", "+\t\t\tfor (int i = 0; i < projects.length; i++) {", "+\t\t\t\tIJavaProject project = projects[i];", "+\t\t\t\tIClasspathEntry[] classpath = project.getResolvedClasspath(true);", "+\t\t\t\tfor (int j = 0; j < classpath.length; j++) {", "+\t\t\t\t\tif (rootPath.equals(classpath[j].getPath())) {", "+\t\t\t\t\t\t// add the project and its jar pkg fragment roots", "+\t\t\t\t\t\tIPackageFragmentRoot[] roots = project.getPackageFragmentRoots();", "+\t\t\t\t\t\tset.add(project.getPath());", "+\t\t\t\t\t\tfor (int k = 0; k < roots.length; k++) {", "+\t\t\t\t\t\t\tIPackageFragmentRoot pkgFragmentRoot = roots[k];", "+\t\t\t\t\t\t\tif (pkgFragmentRoot.isArchive()) {", "+\t\t\t\t\t\t\t\tset.add(pkgFragmentRoot.getPath());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// add the dependent projects", "+\t\t\t\t\t\tthis.computeDependents(project, set, visited);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// add all the project's pkg fragment roots", "+\t\t\tIJavaProject project = (IJavaProject)root.getParent();", "+\t\t\tIPackageFragmentRoot[] roots = project.getAllPackageFragmentRoots();", "+\t\t\tfor (int i = 0; i < roots.length; i++) {", "+\t\t\t\tIPackageFragmentRoot pkgFragmentRoot = roots[i];", "+\t\t\t\tif (pkgFragmentRoot.isArchive()) {", "+\t\t\t\t\tset.add(pkgFragmentRoot.getPath());", "+\t\t\t\t} else {", "+\t\t\t\t\tset.add(pkgFragmentRoot.getParent().getPath());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// add the dependent projects", "+\t\t\tthis.computeDependents(project, set, new HashSet());", "+\t\t}", "+\t\tIPath[] result = new IPath[set.size()];", "+\t\tset.toArray(result);", "+\t\treturn result;", "+\t}", "-\t */", "-\tprotected boolean encloses(IResource element) {", "-\t\tIPath elementPath = element.getFullPath();", "-\t\tfor (int i = 0; i < elementCount; i++) {", "-\t\t\tif (this.elements[i].getFullPath().isPrefixOf(elementPath)) {", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5b8004c56330448a125b42fbfaf91c86", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java", "commitBeforeChange": "f11400a6293169aae30e17b2e27f5adb8ea51511", "commitAfterChange": "f04e3f1ae3453f83dbe0aa3f6ea76c9c43c152ce", "methodNumberBeforeChange": 40, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \r \tpublic void loadVariables() throws CoreException", "signatureAfterChange": "\r \r \tpublic void loadVariables() throws CoreException", "diff": ["+\r", "+\t\t// backward compatibility, consider persistent property\t\r", "+\t\tQualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, \"variables\"); //$NON-NLS-1$\r", "+\t\tString xmlString = ResourcesPlugin.getWorkspace().getRoot().getPersistentProperty(qName);\r", "-\t\tString xmlString = ResourcesPlugin.getWorkspace().getRoot().getPersistentProperty(\r", "-\t\t\t\t\t\t\t\tnew QualifiedName(JavaCore.PLUGIN_ID, \"variables\")); //$NON-NLS-1$\r", "-\t\t\tif (xmlString != null) readVariables(xmlString);\r", "+\t\t\tif (xmlString != null){\r", "+\t\t\t\tStringReader reader = new StringReader(xmlString);\r", "+\t\t\t\tElement cpElement;\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r", "+\t\t\t\t\tcpElement = parser.parse(new InputSource(reader)).getDocumentElement();\r", "+\t\t\t\t} catch(SAXException e) {\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t} catch(ParserConfigurationException e){\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t} finally {\r", "+\t\t\t\t\treader.close();\r", "+\t\t\t\t}\r", "+\t\t\t\tif (cpElement == null) return;\r", "+\t\t\t\tif (!cpElement.getNodeName().equalsIgnoreCase(\"variables\")) { //$NON-NLS-1$\r", "+\t\t\t\t\treturn;\r", "+\t\t\t\t}\r", "+\t\t\t\tArrayList variableNamesList = new ArrayList();\r", "+\t\t\t\tArrayList variablePathsList = new ArrayList();\r", "+\t\t\t\t\r", "+\t\t\t\tNodeList list= cpElement.getChildNodes();\r", "+\t\t\t\tint length= list.getLength();\r", "+\t\t\t\tfor (int i= 0; i < length; ++i) {\r", "+\t\t\t\t\tNode node= list.item(i);\r", "+\t\t\t\t\tshort type= node.getNodeType();\r", "+\t\t\t\t\tif (type == Node.ELEMENT_NODE) {\r", "+\t\t\t\t\t\tElement element= (Element) node;\r", "+\t\t\t\t\t\tif (element.getNodeName().equalsIgnoreCase(\"variable\")) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\tvariablePut( \r", "+\t\t\t\t\t\t\t\telement.getAttribute(\"name\"), //$NON-NLS-1$\r", "+\t\t\t\t\t\t\t\tnew Path(element.getAttribute(\"path\"))); //$NON-NLS-1$\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "-\t\t\treturn;\r", "+\t\t} finally {\r", "+\t\t\tif (xmlString != null){\r", "+\t\t\t\tResourcesPlugin.getWorkspace().getRoot().setPersistentProperty(qName, null); // flush old one\r", "+\t\t\t}\r", "+\t\t\t\r", "+\t\t\r", "+\t\t// load variables from preferences into cache\r", "+\t\tPreferences preferences = JavaCore.getPlugin().getPluginPreferences();\r", "+\r", "+\t\t// only get variable from preferences not set to their default\r", "+\t\tString[] propertyNames = preferences.propertyNames();\r", "+\t\tint prefixLength = CP_VARIABLE_PREFERENCES_PREFIX.length();\r", "+\t\tfor (int i = 0; i < propertyNames.length; i++){\r", "+\t\t\tString propertyName = propertyNames[i];\r", "+\t\t\tif (propertyName.startsWith(CP_VARIABLE_PREFERENCES_PREFIX)){\r", "+\t\t\t\tString varName = propertyName.substring(prefixLength);\r", "+\t\t\t\tIPath varPath = new Path(preferences.getString(propertyName));\r", "+\t\t\t\tVariables.put(varName, varPath);\r", "+\t\t\t}\r", "+\t\t}\t\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6173c990f03483293402069c3206be7b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "1a18ae0a7f87984c327278bf2097db1fc176b8aa", "commitAfterChange": "16639d06fb7d968f56130bc74dcaf6bcb3941b64", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "\r \t\r private void updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta)", "signatureAfterChange": "\r private boolean updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta)", "diff": ["-private void updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta) {\r", "+ */\r", "+private boolean updateCurrentDeltaAndIndex(Openable element, IResourceDelta delta) {\r", "-\t\t\tbreak;\r", "+\t\t\tif (element instanceof IPackageFragmentRoot) {\r", "+\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");\r", "+\t\t\t}\r", "+\t\t\tif (element instanceof IPackageFragment) {\r", "+\t\t\t\t// add subpackages\r", "+\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "+\t\t\t\tString name = element.getElementName();\r", "+\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "+\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "+\t\t\t\t\tIResourceDelta child = children[i];\r", "+\t\t\t\t\tIResource resource = child.getResource();\r", "+\t\t\t\t\tif (resource instanceof IFolder) {", "+\t\t\t\t\t\tString subpkgName = \r", "+\t\t\t\t\t\t\tname.length() == 0 ? \r", "+\t\t\t\t\t\t\t\tresource.getName() : \r", "+\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "+\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "+\t\t\t\t\t\tthis.updateCurrentDeltaAndIndex(subpkg, child);\r", "+\t\t\t\t\t}", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\treturn false;\r", "-\t\t\tbreak;\r", "+\t\t\tif (element instanceof IPackageFragmentRoot) {\r", "+\t\t\t\telement = (Openable)((IPackageFragmentRoot)element).getPackageFragment(\"\");\r", "+\t\t\t}\r", "+\t\t\tif (element instanceof IPackageFragment) {\r", "+\t\t\t\t// remove subpackages\r", "+\t\t\t\tPackageFragmentRoot root = element.getPackageFragmentRoot();\r", "+\t\t\t\tString name = element.getElementName();\r", "+\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "+\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "+\t\t\t\t\tIResourceDelta child = children[i];\r", "+\t\t\t\t\tIResource resource = child.getResource();\r", "+\t\t\t\t\tif (resource instanceof IFolder) {\r", "+\t\t\t\t\t\tString subpkgName = \r", "+\t\t\t\t\t\t\tname.length() == 0 ? \r", "+\t\t\t\t\t\t\t\tresource.getName() : \r", "+\t\t\t\t\t\t\t\tname + \".\" + resource.getName(); //$NON-NLS-1$\r", "+\t\t\t\t\t\tOpenable subpkg = (Openable)root.getPackageFragment(subpkgName);\r", "+\t\t\t\t\t\tthis.updateCurrentDeltaAndIndex(subpkg, child);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\treturn false;\r", "+\t\t\t\treturn false; // when a project is open/closed don't process children\r", "-\t\t\tbreak;\r", "+\t\t\treturn true;\r", "+\treturn true;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b6cf260d6649c7a942ea349f427619ea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "1f4efb41a52f8c33e561047da4304f9fe9e90dc9", "commitAfterChange": "44b2c87051c4d9bbf37b4cf649be500c54102bf7", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic void elementEncode(XMLWriter writer, IPath projectPath, boolean indent, boolean newLine)", "signatureAfterChange": " \tpublic void elementEncode(XMLWriter writer, IPath projectPath, boolean indent, boolean newLine, Map unknownElements)", "diff": ["-\tpublic void elementEncode(XMLWriter writer, IPath projectPath, boolean indent, boolean newLine) {", "+\tpublic void elementEncode(XMLWriter writer, IPath projectPath, boolean indent, boolean newLine, Map unknownElements) {", "+\t\t// unknown attributes", "+\t\tUnknownXmlElements unknownXmlElements = unknownElements == null ? null : (UnknownXmlElements) unknownElements.get(this.path);", "+\t\tString[] unknownAttributes;", "+\t\tif (unknownXmlElements != null && (unknownAttributes = unknownXmlElements.attributes) != null)", "+\t\t\tfor (int i = 0, length = unknownAttributes.length; i < length; i+=2) {", "+\t\t\t\tString tagName = unknownAttributes[i];", "+\t\t\t\tString tagValue = unknownAttributes[i+1];", "+\t\t\t\tparameters.put(tagName, tagValue);", "+\t\t\t}", "+\t\t", "-\t\twriter.printTag(TAG_CLASSPATHENTRY, parameters, indent, newLine, !hasExtraAttributes && !hasRestrictions /*close tag if no extra attributes and no restriction*/);", "+\t\tArrayList unknownChildren = unknownXmlElements != null ? unknownXmlElements.children : null;", "+\t\tboolean hasUnknownChildren = unknownChildren != null;", "+\t\twriter.printTag(", "+\t\t\tTAG_CLASSPATHENTRY, ", "+\t\t\tparameters, ", "+\t\t\tindent, ", "+\t\t\tnewLine, ", "+\t\t\t!hasExtraAttributes && !hasRestrictions && !hasUnknownChildren/*close tag if no extra attributes, no restriction and no unknown children*/);", "+\t\t", "+\t\tif (hasUnknownChildren)", "+\t\t\tencodeUnknownChildren(writer, indent, newLine, unknownChildren);", "-\t\tif (hasExtraAttributes || hasRestrictions)", "-\t\t\twriter.endTag(TAG_CLASSPATHENTRY, indent);", "+\t\tif (hasExtraAttributes || hasRestrictions || hasUnknownChildren)", "+\t\t\twriter.endTag(TAG_CLASSPATHENTRY, indent, true/*insert new line*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c503b70d67998d3d004d893b6b6be389", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "80a36bf53ae731edac012c99749b4fd073634fd5", "commitAfterChange": "775667d78092a7c5a2c35b021921f25b4037d7f4", "methodNumberBeforeChange": 36, "methodNumberAfterChange": 36, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["-\t\t\t\t\t\t\t: classScope.findExactMethod( receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)){", "+\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\tif (foundMethod == null", "-\t\t\t\t\t\t\t|| (foundMethod.problemId() == NotVisible", "-\t\t\t\t\t\t\t\t&& methodBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\tif (depth > 0) {", "+", "+\t\tif (insideStaticContext && environment().options.complianceLevel >= ClassFileConstants.JDK1_5) {", "+\t\t\t// at this point the scope is a compilation unit scope & need to check for imported static methods", "+\t\t\tCompilationUnitScope unitScope = (CompilationUnitScope) scope;", "+\t\t\tImportBinding[] imports = unitScope.imports;", "+\t\t\tif (imports != null) {", "+\t\t\t\t// check on demand imports", "+\t\t\t\tboolean foundInImport = false;", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\tif (importBinding.isStatic() && importBinding.onDemand) {", "+\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t\t\t\tif (resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tMethodBinding temp = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\tif (temp != null) {", "+\t\t\t\t\t\t\t\tif (!temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (foundMethod == null)", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "+\t\t\t\t\t\t\t\t} else if (temp.isStatic()) {", "+\t\t\t\t\t\t\t\t\tif (temp.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\t\t\t\t// Answer error binding -- import on demand conflict; name found in two import on demand types.", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(temp, selector, temp.parameters, Ambiguous);", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = temp;", "+\t\t\t\t\t\t\t\t\t\tfoundInImport = true;", "+\t\t\t\t\t\t\t\t\t} else if (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tfoundMethod = new ProblemMethodBinding(temp, selector, temp.parameters, NotVisible);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (foundMethod != null)", "+\t\t\t\treturn foundMethod;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e083c1fd95cf20ddd58072fd6c1b0711", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "2d89f0516f5e5910bcd18015e8090ed0805dbb4e", "commitAfterChange": "817ed71692e2e331f7e0ac3a90af87bc08553ba4", "methodNumberBeforeChange": 59, "methodNumberAfterChange": 59, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "diff": ["-", "+\t\t\t// walk single static imports. A type found here will shadow types with same name in other CU's, or types coming", "+\t\t\t// from on-demand imports. JLS 7.5.3", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318401", "+\t\t\tif (imports != null) {", "+\t\t\t\tReferenceBinding type = null;", "+\t\t\t\tnextImport : for (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\tImportBinding importBinding = imports[i];", "+\t\t\t\t\tif (importBinding.isStatic()) {", "+\t\t\t\t\t\tReferenceBinding temp = null;", "+\t\t\t\t\t\tif (CharOperation.equals(importBinding.compoundName[importBinding.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t\t\t\t\tif (resolvedImport == null) continue nextImport;", "+\t\t\t\t\t\t\tif (resolvedImport instanceof MethodBinding || resolvedImport instanceof FieldBinding) {", "+\t\t\t\t\t\t\t\t// check to see if there are also member types with the same name", "+\t\t\t\t\t\t\t\t// must find the importRef's type again since the method/field can be from an inherited type", "+\t\t\t\t\t\t\t\t// see StaticImportTest#test084 for more clarity", "+\t\t\t\t\t\t\t\tchar[][] importName = importBinding.reference.tokens;", "+\t\t\t\t\t\t\t\tTypeBinding referencedType = getType(importName, importName.length - 1);", "+\t\t\t\t\t\t\t\tif (referencedType != null && referencedType instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\t\t\ttemp = findMemberType(name, (ReferenceBinding) referencedType);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (temp != null && temp.isStatic() && temp != type) {", "+\t\t\t\t\t\t\t\tif (temp.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (!temp.canBeSeenBy(unitScope.fPackage)) {", "+\t\t\t\t\t\t\t\t\t\t// Answer error binding - type is not visible", "+\t\t\t\t\t\t\t\t\t\tfoundType = new ProblemReferenceBinding(new char[][]{name}, type, ProblemReasons.NotVisible);", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tImportReference importReference = importBinding.reference;", "+\t\t\t\t\t\t\t\t\t\tif (importReference != null) {", "+\t\t\t\t\t\t\t\t\t\t\timportReference.bits |= ASTNode.Used;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\ttype = temp;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t} else if (foundType == null) {", "+\t\t\t\t\t\t\t\t\tfoundType = temp;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (type != null) {", "+\t\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, type);", "+\t\t\t\t\treturn type;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f3a521f57503136b170be01da2ac3c2d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "1a18ae0a7f87984c327278bf2097db1fc176b8aa", "commitAfterChange": "16639d06fb7d968f56130bc74dcaf6bcb3941b64", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": "\r \r \tprotected void updateIndex(Openable element, IResourceDelta delta)", "signatureAfterChange": "\r \r protected void updateIndex(Openable element, IResourceDelta delta)", "diff": ["-\tprotected void updateIndex(Openable element, IResourceDelta delta) {\r", "+protected void updateIndex(Openable element, IResourceDelta delta) {\r", "+\ttry {\t\t\r", "-\t\t\t\t\t\tindexManager.indexAll((IProject) delta.getResource());\r", "+\t\t\t\t\t\tindexManager.indexAll(element.getJavaProject().getProject());\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase IJavaElement.PACKAGE_FRAGMENT_ROOT :\r", "+\t\t\t\tswitch (delta.getKind()) {\r", "+\t\t\t\t\tcase IResourceDelta.ADDED:\r", "+\t\t\t\t\tcase IResourceDelta.CHANGED:\r", "+\t\t\t\t\t\tif (element instanceof JarPackageFragmentRoot) {\r", "+\t\t\t\t\t\t\tJarPackageFragmentRoot root = (JarPackageFragmentRoot)element;\r", "+\t\t\t\t\t\t\t// index jar file only once (if the root is in its declaring project)\r", "+\t\t\t\t\t\t\tif (root.getJavaProject().getProject().getFullPath().isPrefixOf(root.getPath())) {\r", "+\t\t\t\t\t\t\t\tindexManager.indexJarFile(root.getPath(), root.getJavaProject().getElementName());\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase IResourceDelta.REMOVED:\r", "+\t\t\t\t\t\t// keep index in case it is added back later in this session\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\t// don't break as packages of the package fragment root can be indexed below\r", "+\t\t\tcase IJavaElement.PACKAGE_FRAGMENT :\r", "+\t\t\t\tswitch (delta.getKind()) {", "+\t\t\t\t\tcase IResourceDelta.ADDED:\r", "+\t\t\t\t\tcase IResourceDelta.REMOVED:\r", "+\t\t\t\t\t\tIPackageFragment pkg = null;\r", "+\t\t\t\t\t\tif (element instanceof IPackageFragmentRoot) {\r", "+\t\t\t\t\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot)element;\r", "+\t\t\t\t\t\t\tpkg = root.getPackageFragment(\"\");\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tpkg = (IPackageFragment)element;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tString name = pkg.getElementName();\r", "+\t\t\t\t\t\tIResourceDelta[] children = delta.getAffectedChildren();\r", "+\t\t\t\t\t\tfor (int i = 0, length = children.length; i < length; i++) {\r", "+\t\t\t\t\t\t\tIResourceDelta child = children[i];\r", "+\t\t\t\t\t\t\tIResource resource = child.getResource();\r", "+\t\t\t\t\t\t\tif (resource instanceof IFile) {\r", "+\t\t\t\t\t\t\t\tString extension = resource.getFileExtension();\r", "+\t\t\t\t\t\t\t\tif (\"java\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\t\t\tOpenable cu = (Openable)pkg.getCompilationUnit(resource.getName());\r", "+\t\t\t\t\t\t\t\t\tthis.updateIndex(cu, child);\r", "+\t\t\t\t\t\t\t\t} else if (\"class\".equalsIgnoreCase(extension)) { //$NON-NLS-1$\r", "+\t\t\t\t\t\t\t\t\tOpenable classFile = (Openable)pkg.getClassFile(resource.getName());\r", "+\t\t\t\t\t\t\t\t\tthis.updateIndex(classFile, child);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "-\t\t\t\tIFile file = (IFile) delta.getResource();\r", "+\t\t\t\tIFile file = (IFile) element.getUnderlyingResource();\r", "+\t} catch (CoreException e) {\r", "+\t\t// ignore: index won't be updated\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fc6a921cae233b472c959d3d6ee39a97", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java", "commitBeforeChange": "56d15386ff3f6926c8a8ed7999b62e707baad4f8", "commitAfterChange": "8813bb7624a5282a5772eab0a6afafea0971ade6", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 8, "signatureBeforeChange": " \tNameLookup newNameLookup(JavaProject project, ICompilationUnit[] workingCopies)", "signatureAfterChange": " \tNameLookup newNameLookup(JavaProject project, ICompilationUnit[] workingCopies)", "diff": ["+\t\tHashtableOfArrayToObject allPkgFragmentsCache = cache.allPkgFragmentsCache;", "+\t\tif (allPkgFragmentsCache == null) {", "+\t\t\tHashMap rootInfos = JavaModelManager.getJavaModelManager().deltaState.roots;", "+\t\t\tIPackageFragmentRoot[] allRoots = cache.allPkgFragmentRootsCache;", "+\t\t\tint length = allRoots.length;", "+\t\t\tallPkgFragmentsCache = new HashtableOfArrayToObject();", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIPackageFragmentRoot root = allRoots[i];", "+\t\t\t\tDeltaProcessor.RootInfo rootInfo = (DeltaProcessor.RootInfo) rootInfos.get(root.getPath());", "+\t\t\t\tJavaProject rootProject = rootInfo == null ? project : rootInfo.project;", "+\t\t\t\tHashSetOfArray fragmentsCache;", "+\t\t\t\tif (rootProject.equals(project)) {", "+\t\t\t\t\t// retrieve package fragments cache from this project", "+\t\t\t\t\tfragmentsCache = (HashSetOfArray) cache.pkgFragmentsCaches.get(root);", "+\t\t\t\t} else {", "+\t\t\t\t\t// retrieve package fragments  cache from the root's project", "+\t\t\t\t\tProjectCache rootProjectCache;", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\trootProjectCache = rootProject.getProjectCache();", "+\t\t\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t\t\t// project doesn't exit", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tfragmentsCache = (HashSetOfArray) rootProjectCache.pkgFragmentsCaches.get(root);", "+\t\t\t\t}", "+\t\t\t\tObject[][] set = fragmentsCache.set;", "+\t\t\t\tfor (int j = 0, length2 = set.length; j < length2; j++) {", "+\t\t\t\t\tString[] pkgName = (String[]) set[j];", "+\t\t\t\t\tif (pkgName == null)", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tObject existing = allPkgFragmentsCache.get(pkgName);", "+\t\t\t\t\tif (existing == null || existing == NO_ROOTS) {", "+\t\t\t\t\t\tallPkgFragmentsCache.put(pkgName, root);", "+\t\t\t\t\t\t// ensure super packages (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=119161)", "+\t\t\t\t\t\t// are also in the map", "+\t\t\t\t\t\taddSuperPackageNames(pkgName, allPkgFragmentsCache);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (existing instanceof PackageFragmentRoot) {", "+\t\t\t\t\t\t\tallPkgFragmentsCache.put(pkgName, new IPackageFragmentRoot[] {(PackageFragmentRoot) existing, root});", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tIPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) existing;", "+\t\t\t\t\t\t\tint rootLength = roots.length;", "+\t\t\t\t\t\t\tSystem.arraycopy(roots, 0, roots = new IPackageFragmentRoot[rootLength+1], 0, rootLength);", "+\t\t\t\t\t\t\troots[rootLength] = root;", "+\t\t\t\t\t\t\tallPkgFragmentsCache.put(pkgName, roots);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tcache.allPkgFragmentsCache = allPkgFragmentsCache;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fca0af6d1a02fb02b7a58493ec57cce9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementDeltaBuilder.java", "commitBeforeChange": "ee7a9f184cb78c9a997b3d97c102d52d6cad8cc9", "commitAfterChange": "5ce130e25c355987e77b700c026948aca2c3cdd7", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 8, "signatureBeforeChange": " private void putElementInfo(IJavaElement element, JavaElementInfo info)", "signatureAfterChange": " private void findAnnotationChanges(IAnnotation[] oldAnnotations, IAnnotation[] newAnnotations, IJavaElement parent)", "diff": ["+private void findAnnotationChanges(IAnnotation[] oldAnnotations, IAnnotation[] newAnnotations, IJavaElement parent) {", "+\tArrayList annotationDeltas = null;", "+\tfor (int i = 0, length = newAnnotations.length; i < length; i++) {", "+\t\tIAnnotation newAnnotation = newAnnotations[i];", "+\t\tObject oldInfo = this.annotationInfos.remove(newAnnotation);", "+\t\tif (oldInfo == null) {", "+\t\t\tJavaElementDelta annotationDelta = new JavaElementDelta(newAnnotation);", "+\t\t\tannotationDelta.added();", "+\t\t\tif (annotationDeltas == null) annotationDeltas = new ArrayList();", "+\t\t\tannotationDeltas.add(annotationDelta);", "+\t\t\tcontinue;", "+\t\t} else {", "+\t\t\tAnnotationInfo newInfo = null;", "+\t\t\ttry { ", "+\t\t\t\tnewInfo = (AnnotationInfo) ((JavaElement) newAnnotation).getElementInfo();", "+\t\t\t} catch (JavaModelException npe) {", "+\t\t\t\treturn;", "+\t\t\t}", "+\t\t\tif (!Util.equalArraysOrNull(((AnnotationInfo) oldInfo).members, newInfo.members)) {", "+\t\t\t\tJavaElementDelta annotationDelta = new JavaElementDelta(newAnnotation);", "+\t\t\t\tannotationDelta.changed(IJavaElementDelta.F_CONTENT);", "+\t\t\t\tif (annotationDeltas == null) annotationDeltas = new ArrayList();", "+\t\t\t\tannotationDeltas.add(annotationDelta);", "+\t\t\t}\t\t", "+\t\t}", "+\t}", "+\tfor (int i = 0, length = oldAnnotations.length; i < length; i++) {", "+\t\tIAnnotation oldAnnotation = oldAnnotations[i];", "+\t\tif (this.annotationInfos.remove(oldAnnotation) != null) {", "+\t\t\tJavaElementDelta annotationDelta = new JavaElementDelta(oldAnnotation);", "+\t\t\tannotationDelta.removed();", "+\t\t\tif (annotationDeltas == null) annotationDeltas = new ArrayList();", "+\t\t\tannotationDeltas.add(annotationDelta);\t\t}", "+\t}", "+\tif (annotationDeltas == null)", "+\t\treturn;", "+\tint size = annotationDeltas.size();", "+\tif (size > 0) {", "+\t\tJavaElementDelta parentDelta = this.delta.changed(parent, IJavaElementDelta.F_ANNOTATIONS);", "+\t\tparentDelta.annotationDeltas = (IJavaElementDelta[]) annotationDeltas.toArray(new IJavaElementDelta[size]);", "+\t}", "+}", "-private void putElementInfo(IJavaElement element, JavaElementInfo info) {", "-\tthis.infos.put(element, info);", "-}"]}], "num": 4258}