{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7519ebf138a3329113dd9f475781d218", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4be5f04d0c8c5dc09014cc0c61e04821", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InnerEmulationTest.java", "commitBeforeChange": "b0e4bc3e5157dbec051001d4b36efba6d30a5b39", "commitAfterChange": "5a1b6ed1ac22ef15e82cc14b2b59be4383e1ddc7", "methodNumberBeforeChange": 79, "methodNumberAfterChange": 79, "signatureBeforeChange": " public void test078()", "signatureAfterChange": " public void test078()", "diff": ["-\tif (options.sourceLevel < ClassFileConstants.JDK1_5) {", "+\tif (options.sourceLevel <= ClassFileConstants.JDK1_3) {", "+\t\t\t\"\tvoid foo() { System.out.println(X.this);\t} \\n\" + ", "+\t\t\t\"\t                                ^^^^^^\\n\" + ", "+\t\t\t\"No enclosing instance of the type X is accessible in scope\\n\" + ", "+\t\t\t\"----------\\n\");", "+\t\treturn;", "+\t}", "+\tif (options.sourceLevel <= ClassFileConstants.JDK1_4) {", "+\t\tthis.runNegativeTest(", "+\t\t\tnew String[] {", "+\t\t\t\t\"X.java\",", "+\t\t\t\t\"public class X {\t\\n\"+", "+\t\t\t\t\"\tX(Object o){\t\\n\"+", "+\t\t\t\t\"\t\tclass A { \t\\n\"+", "+\t\t\t\t\"\t\t\tprivate A() {\t\\n\"+ // implicit enclosing instance in non-static context", "+\t\t\t\t\"\t\t\t}\t\\n\"+", "+\t\t\t\t\"\t\t}\t\\n\"+", "+\t\t\t\t\"\t\tclass B extends X {\t\\n\"+", "+\t\t\t\t\"\t\t\tB() {\t\\n\"+", "+\t\t\t\t\"\t\t\t\tsuper(new A(){\t\\n\"+", "+\t\t\t\t\"\t\t\t\t\tvoid foo() { System.out.println(X.this);\t} \\n\"+", "+\t\t\t\t\"\t\t\t\t});\t\\n\"+", "+\t\t\t\t\"\t\t\t}\t\\n\"+", "+\t\t\t\t\"\t\t}\t\\n\"+", "+\t\t\t\t\"\t}\t\\n\"+", "+\t\t\t\t\"} \t\\n\"", "+\t\t\t},", "+\t\t\t\"----------\\n\" + ", "+\t\t\t\"1. ERROR in X.java (at line 9)\\n\" + ", "+\t\t\t\"\tsuper(new A(){\t\\n\" + ", "+\t\t\t\"\t\t\t\t\tvoid foo() { System.out.println(X.this);\t} \\n\" + ", "+\t\t\t\"\t\t\t\t});\t\\n\" + ", "+\t\t\t\"\t      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\" + ", "+\t\t\t\"No enclosing instance of type X is available due to some intermediate constructor invocation\\n\" + ", "+\t\t\t\"----------\\n\" + ", "+\t\t\t\"2. WARNING in X.java (at line 10)\\n\" + ", "+\t\t\t\"\tvoid foo() { System.out.println(X.this);\t} \\n\" + ", "+\t\t\t\"\t     ^^^^^\\n\" + ", "+\t\t\t\"The method foo() from the type new A(){} is never used locally\\n\" + ", "+\t\t\t\"----------\\n\" + ", "+\t\t\t\"3. ERROR in X.java (at line 10)\\n\" + "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd0ef069d662541958fa3fd6204deea1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/VarargsTest.java", "commitBeforeChange": "4e8e5a98cf0190fbfa5945ebb361f51b261ba210", "commitAfterChange": "d245300e4e786a6fa7e5da9bef5c249b7208c09a", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic void _test010()", "signatureAfterChange": "  \tpublic void test010()", "diff": ["-\t// TODO (kent) cannot call computeCompatibleMethod to choose between 2 methods", "-\tpublic void _test010() {", "+\tpublic void test010() {", "+\t\t// according to spec this should find count(Object) since it should not consider count(Object...) until all fixed arity methods are dealt with", "+\t\t// but their current implementation picks the vararg method", "+\t\tthis.runConformTest(", "+\t\t\tnew String[] {", "+\t\t\t\t\"X.java\",", "+\t\t\t\t\"public class X {\\n\" +", "+\t\t\t\t\"\tpublic static void main(String[] s) {\\n\" +", "+\t\t\t\t\"\t\tSystem.out.print('<');\\n\" +", "+\t\t\t\t\"\t\tY.count((Object) new Integer(1));\\n\" +", "+//\t\t\t\t\"\t\tY.count(new Integer(1));\\n\" +", "+\t\t\t\t\"\t\tSystem.out.print('>');\\n\" +", "+\t\t\t\t\"\t}\\n\" +", "+\t\t\t\t\"}\\n\" +", "+\t\t\t\t\"class Y {\\n\" +", "+\t\t\t\t\"\tpublic static void count(Object values) { System.out.print('1'); }\\n\" +", "+\t\t\t\t\"\tpublic static void count(Object ... values) { System.out.print('2'); }\\n\" +", "+\t\t\t\t\"}\\n\",", "+\t\t\t},", "+\t\t\t\"<1>\");", "+\t\t// according to spec this should find count(Object[]) since it should not consider count(Object[]...) until all fixed arity methods are dealt with", "+\t\t// but their current implementation picks the vararg method", "+\t\tthis.runConformTest(", "+\t\t\tnew String[] {", "+\t\t\t\t\"X.java\",", "+\t\t\t\t\"public class X {\\n\" +", "+\t\t\t\t\"\tpublic static void main(String[] s) {\\n\" +", "+\t\t\t\t\"\t\tSystem.out.print('<');\\n\" +", "+\t\t\t\t\"\t\tY.count(new Object[] {new Integer(1)});\\n\" +", "+//\t\t\t\t\"\t\tY.count(new Integer[] {new Integer(1)});\\n\" +", "+\t\t\t\t\"\t\tSystem.out.print('>');\\n\" +", "+\t\t\t\t\"\t}\\n\" +", "+\t\t\t\t\"}\\n\" +", "+\t\t\t\t\"class Y {\\n\" +", "+\t\t\t\t\"\tpublic static void count(Object[] values) { System.out.print('1'); }\\n\" +", "+\t\t\t\t\"\tpublic static void count(Object[] ... values) { System.out.print('2'); }\\n\" +", "+\t\t\t\t\"}\\n\",", "+\t\t\t},", "+\t\t\t\"<1>\");", "+\t\t// according to spec this should find the fixed arity methods since it should not consider the others until all fixed arity methods are dealt with", "+\t\t// but their current implementation thinks they're ambiguous", "-\t\t\t\t\"\t\tY.count(null);\\n\" +", "+\t\t\t\t\"\t\tY.string(null);\\n\" +", "+\t\t\t\t\"\t\tY.string2(null);\\n\" +", "+\t\t\t\t\"\t\tY.int2(null);\\n\" +", "-\t\t\t\t\"\tpublic static void count(int[] values) {}\\n\" +", "-\t\t\t\t\"\tpublic static void count(int[] ... values) {}\\n\" +", "+\t\t\t\t\"\tpublic static void string(String values) { System.out.print('1'); }\\n\" +", "+\t\t\t\t\"\tpublic static void string(String ... values) { System.out.print('2'); }\\n\" +", "+\t\t\t\t\"\tpublic static void string2(String[] values) { System.out.print('1'); }\\n\" +", "+\t\t\t\t\"\tpublic static void string2(String[] ... values) { System.out.print('2'); }\\n\" +", "+\t\t\t\t\"\tpublic static void int2(int[] values) { System.out.print('1'); }\\n\" +", "+\t\t\t\t\"\tpublic static void int2(int[] ... values) { System.out.print('2'); }\\n\" +", "-\t\t\t},\t\t\t\"----------\\n\" + ", "+\t\t\t},", "+\t\t\t\"----------\\n\" + ", "-\t\t\t\"\tY.count(null);\\n\" + ", "-\t\t\t\"\t  ^^^^^\\n\" + ", "-\t\t\t\"The method count(int[]) is ambiguous for the type Y\\n\" + ", "+\t\t\t\"\tY.string(null);\\n\" + ", "+\t\t\t\"\t  ^^^^^^\\n\" + ", "+\t\t\t\"The method string(String) is ambiguous for the type Y\\n\" + ", "+\t\t\t\"----------\\n\" + ", "+\t\t\t\"2. ERROR in X.java (at line 4)\\n\" + ", "+\t\t\t\"\tY.string2(null);\\n\" + ", "+\t\t\t\"\t  ^^^^^^^\\n\" + ", "+\t\t\t\"The method string2(String[]) is ambiguous for the type Y\\n\" + ", "+\t\t\t\"----------\\n\" + ", "+\t\t\t\"3. ERROR in X.java (at line 5)\\n\" + ", "+\t\t\t\"\tY.int2(null);\\n\" + ", "+\t\t\t\"\t  ^^^^\\n\" + ", "+\t\t\t\"The method int2(int[]) is ambiguous for the type Y\\n\" + "]}], "num": 66990}