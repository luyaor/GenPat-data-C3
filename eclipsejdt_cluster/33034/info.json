{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b583a601994d6dd787d54d51272e3b64", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3889ac10c8df34a4758d289276b83050", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "afcefcc52a6e235f9ed640317727929d84135cf0", "commitAfterChange": "5ce294a787e58643d5e8115fe2ddfea119e53aa2", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": " public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["-\t */", "-\tpublic void generateCode(ClassScope classScope, ClassFile classFile) {", "-\t\tint problemResetPC = 0;", "-\t\tif (ignoreFurtherInvestigation) {", "-\t\t\tif (this.binding == null)", "-\t\t\t\treturn; // Handle methods with invalid signature or duplicates", "-\t\t\tint problemsLength;", "-\t\t\tCategorizedProblem[] problems =", "-\t\t\t\tscope.referenceCompilationUnit().compilationResult.getProblems();", "-\t\t\tCategorizedProblem[] problemsCopy = new CategorizedProblem[problemsLength = problems.length];", "-\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);", "-\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy);", "-\t\t\treturn;", "-\t\t}", "-\t\ttry {", "-\t\t\tproblemResetPC = classFile.contentsOffset;", "-\t\t\tthis.internalGenerateCode(classScope, classFile);", "-\t\t} catch (AbortMethod e) {", "-\t\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {", "-\t\t\t\t// a branch target required a goto_w, restart code gen in wide mode.", "-\t\t\t\ttry {", "-\t\t\t\t\tclassFile.contentsOffset = problemResetPC;", "-\t\t\t\t\tclassFile.methodCount--;", "-\t\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode ", "-\t\t\t\t\tthis.internalGenerateCode(classScope, classFile); // restart method generation", "-\t\t\t\t} catch (AbortMethod e2) {", "-\t\t\t\t\tint problemsLength;", "-\t\t\t\t\tCategorizedProblem[] problems =", "-\t\t\t\t\t\tscope.referenceCompilationUnit().compilationResult.getAllProblems();", "-\t\t\t\t\tCategorizedProblem[] problemsCopy = new CategorizedProblem[problemsLength = problems.length];", "-\t\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);", "-\t\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);", "-\t\t\t} else {", "+ */", "+public void generateCode(ClassScope classScope, ClassFile classFile) {", "+\tint problemResetPC = 0;", "+\tif (this.ignoreFurtherInvestigation) {", "+\t\tif (this.binding == null)", "+\t\t\treturn; // Handle methods with invalid signature or duplicates", "+\t\tint problemsLength;", "+\t\tCategorizedProblem[] problems =", "+\t\t\tthis.scope.referenceCompilationUnit().compilationResult.getProblems();", "+\t\tCategorizedProblem[] problemsCopy = new CategorizedProblem[problemsLength = problems.length];", "+\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);", "+\t\tclassFile.addProblemConstructor(this, this.binding, problemsCopy);", "+\t\treturn;", "+\t}", "+\ttry {", "+\t\tproblemResetPC = classFile.contentsOffset;", "+\t\tthis.internalGenerateCode(classScope, classFile);", "+\t} catch (AbortMethod e) {", "+\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {", "+\t\t\t// a branch target required a goto_w, restart code gen in wide mode.", "+\t\t\ttry {", "+\t\t\t\tclassFile.contentsOffset = problemResetPC;", "+\t\t\t\tclassFile.methodCount--;", "+\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode ", "+\t\t\t\tthis.internalGenerateCode(classScope, classFile); // restart method generation", "+\t\t\t} catch (AbortMethod e2) {", "-\t\t\t\t\tscope.referenceCompilationUnit().compilationResult.getAllProblems();", "+\t\t\t\t\tthis.scope.referenceCompilationUnit().compilationResult.getAllProblems();", "-\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);", "+\t\t\t\tclassFile.addProblemConstructor(this, this.binding, problemsCopy, problemResetPC);", "-\t\t}", "-\t}", "+\t\t\tint problemsLength;", "+\t\t\tCategorizedProblem[] problems =", "+\t\t\t\tthis.scope.referenceCompilationUnit().compilationResult.getAllProblems();", "+\t\t\tCategorizedProblem[] problemsCopy = new CategorizedProblem[problemsLength = problems.length];", "+\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);", "+\t\t\tclassFile.addProblemConstructor(this, this.binding, problemsCopy, problemResetPC);", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bbb38e322c721bc7c253c6e8bfbfe1e6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java", "commitBeforeChange": "c9050a3a9594b7d361850fa9a3880d65c49e6aec", "commitAfterChange": "861f1162953e56602b4d7507e52e1f13733854c4", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["+\t// for each method we start the code generate with wideMode equals to false\r", "+\t// in the code Stream.\r", "+\tclassFile.codeStream.wideMode = false;\r", "-\t\tclassFile.generateMethodInfoHeader(binding);\r", "-\t\tint methodAttributeOffset = classFile.contentsOffset;\r", "-\t\tint attributeNumber = classFile.generateMethodInfoAttribute(binding);\r", "-\t\tif ((!binding.isNative()) && (!binding.isAbstract())) {\r", "-\t\t\tint codeAttributeOffset = classFile.contentsOffset;\r", "-\t\t\tclassFile.generateCodeAttributeHeader();\r", "-\t\t\tCodeStream codeStream = classFile.codeStream;\r", "-\t\t\tcodeStream.reset(this, classFile);\r", "-\t\t\t// initialize local positions\r", "-\t\t\tscope.computeLocalVariablePositions(binding.isStatic() ? 0 : 1, codeStream);\r", "-\r", "-\t\t\t// arguments initialization for local variable debug attributes\r", "-\t\t\tif (arguments != null) {\r", "-\t\t\t\tfor (int i = 0, max = arguments.length; i < max; i++) {\r", "-\t\t\t\t\tLocalVariableBinding argBinding;\r", "-\t\t\t\t\tcodeStream.addVisibleLocalVariable(argBinding = arguments[i].binding);\r", "-\t\t\t\t\targBinding.recordInitializationStartPC(0);\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\tif (statements != null) {\r", "-\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "-\t\t\t\t\tstatements[i].generateCode(scope, codeStream);\r", "-\t\t\t}\r", "-\t\t\tif (needFreeReturn) {\r", "-\t\t\t\tcodeStream.return_();\r", "-\t\t\t}\r", "-\t\t\t// local variable attributes\r", "-\t\t\tcodeStream.exitUserScope(scope);\r", "-\t\t\tcodeStream.recordPositionsFrom(0, this);\r", "-\t\t\tclassFile.completeCodeAttribute(codeAttributeOffset);\r", "-\t\t\tattributeNumber++;\r", "-\t\t}\r", "-\t\tclassFile.completeMethodInfo(methodAttributeOffset, attributeNumber);\r", "-\r", "-\t\t// if a problem got reported during code gen, then trigger problem method creation\r", "-\t\tif (ignoreFurtherInvestigation){\r", "-\t\t\tthrow new AbortMethod(scope.referenceCompilationUnit().compilationResult);\r", "-\t\t}\r", "+\t\tthis.internalGenerateCode(classScope, classFile);\r", "-\t\tint problemsLength;\r", "-\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "-\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "-\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "-\t\tclassFile.addProblemMethod(this, binding, problemsCopy, problemResetPC);\r", "+\t\tif (e.compilationResult == null) {\r", "+\t\t\ttry {\r", "+\t\t\t\tif (statements != null) {\r", "+\t\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "+\t\t\t\t\t\tstatements[i].resetStateForCodeGeneration();\r", "+\t\t\t\t}\r", "+\t\t\t\tclassFile.contentsOffset = problemResetPC;\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\tclassFile.codeStream.wideMode = true;\r", "+\t\t\t\tproblemResetPC = classFile.contentsOffset;\r", "+\t\t\t\tthis.internalGenerateCode(classScope, classFile);\r", "+\t\t\t} catch(AbortMethod e2) {\r", "+\t\t\t\tint problemsLength;\r", "+\t\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\t\tclassFile.addProblemMethod(this, binding, problemsCopy, problemResetPC);\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\tint problemsLength;\r", "+\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\tclassFile.addProblemMethod(this, binding, problemsCopy, problemResetPC);\r", "+\t\t}\r", "+\t}\r", "+}\r"]}], "num": 33034}