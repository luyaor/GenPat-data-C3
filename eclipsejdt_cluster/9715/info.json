{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ddddff4d578702f9c46842c604878b92", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "344bcb5b5095f5fa2ffb324aaa70d205", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/MultiOperation.java", "commitBeforeChange": "8bea847412c36874664a80a329bfe627deff5fa9", "commitAfterChange": "c4145c80a504c8681f4571ff2bd214b778e87107", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tprotected void processElements() throws JavaModelException", "signatureAfterChange": " \tprotected void processElements() throws JavaModelException", "diff": ["-\t\tbeginTask(getMainTaskName(), this.elementsToProcess.length);", "-\t\tIJavaModelStatus[] errors = new IJavaModelStatus[3];", "-\t\tint errorsCounter = 0;", "-\t\tfor (int i = 0; i < this.elementsToProcess.length; i++) {", "-\t\t\ttry {", "-\t\t\t\tverify(this.elementsToProcess[i]);", "-\t\t\t\tprocessElement(this.elementsToProcess[i]);", "-\t\t\t} catch (JavaModelException jme) {", "-\t\t\t\tif (errorsCounter == errors.length) {", "-\t\t\t\t\t// resize", "-\t\t\t\t\tSystem.arraycopy(errors, 0, (errors = new IJavaModelStatus[errorsCounter*2]), 0, errorsCounter);", "+\t\ttry {", "+\t\t\tbeginTask(getMainTaskName(), this.elementsToProcess.length);", "+\t\t\tIJavaModelStatus[] errors = new IJavaModelStatus[3];", "+\t\t\tint errorsCounter = 0;", "+\t\t\tfor (int i = 0; i < this.elementsToProcess.length; i++) {", "+\t\t\t\ttry {", "+\t\t\t\t\tverify(this.elementsToProcess[i]);", "+\t\t\t\t\tprocessElement(this.elementsToProcess[i]);", "+\t\t\t\t} catch (JavaModelException jme) {", "+\t\t\t\t\tif (errorsCounter == errors.length) {", "+\t\t\t\t\t\t// resize", "+\t\t\t\t\t\tSystem.arraycopy(errors, 0, (errors = new IJavaModelStatus[errorsCounter*2]), 0, errorsCounter);", "+\t\t\t\t\t}", "+\t\t\t\t\terrors[errorsCounter++] = jme.getJavaModelStatus();", "+\t\t\t\t} finally {", "+\t\t\t\t\tworked(1);", "-\t\t\t\terrors[errorsCounter++] = jme.getJavaModelStatus();", "-\t\t\t} finally {", "-\t\t\t\tworked(1);", "-\t\t}", "-\t\tdone();", "-\t\tif (errorsCounter == 1) {", "-\t\t\tthrow new JavaModelException(errors[0]);", "-\t\t} else if (errorsCounter > 1) {", "-\t\t\tif (errorsCounter != errors.length) {", "-\t\t\t\t// resize", "-\t\t\t\tSystem.arraycopy(errors, 0, (errors = new IJavaModelStatus[errorsCounter]), 0, errorsCounter);", "+\t\t\tif (errorsCounter == 1) {", "+\t\t\t\tthrow new JavaModelException(errors[0]);", "+\t\t\t} else if (errorsCounter > 1) {", "+\t\t\t\tif (errorsCounter != errors.length) {", "+\t\t\t\t\t// resize", "+\t\t\t\t\tSystem.arraycopy(errors, 0, (errors = new IJavaModelStatus[errorsCounter]), 0, errorsCounter);", "+\t\t\t\t}", "+\t\t\t\tthrow new JavaModelException(JavaModelStatus.newMultiStatus(errors));", "-\t\t\tthrow new JavaModelException(JavaModelStatus.newMultiStatus(errors));", "+\t\t} finally {", "+\t\t\tdone();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5e7018623002c3029c09b85961ef69fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "1cdb6c1b0fb5ba08d4e282b871474685ab8baf3f", "commitAfterChange": "c3fe3a5d67fbf0c540d6fc63f233f6806516af9c", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] otherInheritedMethods)", "signatureAfterChange": " void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] otherInheritedMethods)", "diff": ["+\t\tif (isAnnotationMember) { // annotation cannot override any method", "+\t\t\tproblemReporter().annotationCannotOverrideMethod(currentMethod, inheritedMethod);", "+\t\t\treturn; // do not repoort against subsequent inherited methods", "+\t\t}", "+\t\t\tcontinue nextMethod;", "+\t\t}", "+\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "+\t\t\tproblemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\tif (isAnnotationMember) {", "-\t\t\t// annotation cannot override any method", "-\t\t\tproblemReporter().annotationCannotOverrideMethod(currentMethod, inheritedMethod);", "-\t\t\treturn; // do not repoort against subsequent inherited methods", "-\t\t}\t\t", "-\t\tif (!areReturnTypesEqual(currentMethod, inheritedMethod)) {", "-\t\t\tproblemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);", "-\t\t} else {", "-\t\t\tif (currentMethod.thrownExceptions != NoExceptions)", "-\t\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "-\t\t\tif (inheritedMethod.isFinal())", "-\t\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "-\t\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "-\t\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "-\t\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "-\t\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "-\t\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "-\t\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "-\t\t\t\t\tif (declaringClass.isInterface())", "-\t\t\t\t\t\tfor (int j = length; --j >= 0;)", "-\t\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\tif (currentMethod.thrownExceptions != NoExceptions)", "+\t\t\tcheckExceptions(currentMethod, inheritedMethod);", "+\t\tif (inheritedMethod.isFinal())", "+\t\t\tproblemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);", "+\t\tif (!isAsVisible(currentMethod, inheritedMethod))", "+\t\t\tproblemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);", "+\t\tif (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {", "+\t\t\tif (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {", "+\t\t\t\t// check against the other inherited methods to see if they hide this inheritedMethod", "+\t\t\t\tReferenceBinding declaringClass = inheritedMethod.declaringClass;", "+\t\t\t\tif (declaringClass.isInterface())", "+\t\t\t\t\tfor (int j = length; --j >= 0;)", "+\t\t\t\t\t\tif (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\t\t}", "+\t\t\t\tproblemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);", "-\t\t\tcheckForBridgeMethod(currentMethod, inheritedMethod, otherInheritedMethods);", "+\t\tcheckForBridgeMethod(currentMethod, inheritedMethod, otherInheritedMethods);"]}], "num": 9715}