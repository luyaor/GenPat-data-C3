{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "02c9cc11578432de4c8842b79207623c", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0db621fe268263bddb94cffe9842c8d6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9fff7ba189be037b4cf4f61956b7e287259b8f6d", "commitAfterChange": "8f52c3e814b7d9e86327e186704f1c7e2be78c75", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tint[] sortedIndexes = new int[caseCount];", "-\t\tint[] localKeysCopy;", "-\t\tif ((bits & IsReachableMASK) == 0) {", "-\t\t\treturn;", "-\t\t}", "-\t\tint pc = codeStream.position;", "-", "-\t\t// prepare the labels and constants", "-\t\tbreakLabel.codeStream = codeStream;", "-\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "-\t\tint[] constants = new int[caseCount];", "-\t\tboolean needSwitch = caseCount != 0;", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "-\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "-\t\t}", "-", "-\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "-\t\tfor (int i = 0; i < caseCount; i++) {", "-\t\t\tsortedIndexes[i] = i;", "-\t\t}", "-\t\tSystem.arraycopy(", "-\t\t\tconstants,", "-\t\t\t0,", "-\t\t\t(localKeysCopy = new int[caseCount]),", "-\t\t\t0,", "-\t\t\tcaseCount);", "-\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "-\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "-\t\tif (defaultCase != null) {", "-\t\t\tdefaultCase.targetLabel = defaultLabel;", "-\t\t}", "-\t\t// generate expression testes", "-\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "-", "-\t\t// generate the appropriate switch table/lookup bytecode", "-\t\tif (needSwitch) {", "-\t\t\tint max = localKeysCopy[caseCount - 1];", "-\t\t\tint min = localKeysCopy[0];", "-\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "-\t\t\t\t", "-\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "-\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "-\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "-\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "-", "-\t\t\t\t} else {", "-\t\t\t\t\tcodeStream.tableswitch(", "-\t\t\t\t\t\tdefaultLabel,", "-\t\t\t\t\t\tmin,", "-\t\t\t\t\t\tmax,", "-\t\t\t\t\t\tconstants,", "-\t\t\t\t\t\tsortedIndexes,", "-\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t    try {", "+\t\t\tint[] sortedIndexes = new int[caseCount];", "+\t\t\tint[] localKeysCopy;", "+\t\t\tif ((bits & IsReachableMASK) == 0) {", "+\t\t\t\treturn;", "-\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "-\t\t}", "-\t\t", "-\t\t// generate the switch block statements", "-\t\tint caseIndex = 0;", "-\t\tif (statements != null) {", "-\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "-\t\t\t\tStatement statement = statements[i];", "-\t\t\t\tif ((caseIndex < caseCount)", "-\t\t\t\t\t&& (statement == cases[caseIndex])) { // statements[i] is a case", "-\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "-\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "-\t\t\t\t\t\tcaseIndex++;", "+\t\t\tint pc = codeStream.position;", "+\t", "+\t\t\t// prepare the labels and constants", "+\t\t\tbreakLabel.codeStream = codeStream;", "+\t\t\tCaseLabel[] caseLabels = new CaseLabel[caseCount];", "+\t\t\tint[] constants = new int[caseCount];", "+\t\t\tboolean needSwitch = caseCount != 0;", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tconstants[i] = cases[i].constantExpression.constant.intValue();", "+\t\t\t\tcases[i].targetLabel = (caseLabels[i] = new CaseLabel(codeStream));", "+\t\t\t}", "+\t", "+\t\t\t// we sort the keys to be able to generate the code for tableswitch or lookupswitch", "+\t\t\tfor (int i = 0; i < caseCount; i++) {", "+\t\t\t\tsortedIndexes[i] = i;", "+\t\t\t}", "+\t\t\tSystem.arraycopy(", "+\t\t\t\tconstants,", "+\t\t\t\t0,", "+\t\t\t\t(localKeysCopy = new int[caseCount]),", "+\t\t\t\t0,", "+\t\t\t\tcaseCount);", "+\t\t\tCodeStream.sort(localKeysCopy, 0, caseCount - 1, sortedIndexes);", "+\t\t\tCaseLabel defaultLabel = new CaseLabel(codeStream);", "+\t\t\tif (defaultCase != null) {", "+\t\t\t\tdefaultCase.targetLabel = defaultLabel;", "+\t\t\t}", "+\t\t\t// generate expression testes", "+\t\t\texpression.generateCode(currentScope, codeStream, needSwitch);", "+\t", "+\t\t\t// generate the appropriate switch table/lookup bytecode", "+\t\t\tif (needSwitch) {", "+\t\t\t\tint max = localKeysCopy[caseCount - 1];", "+\t\t\t\tint min = localKeysCopy[0];", "+\t\t\t\tif ((long) (caseCount * 2.5) > ((long) max - (long) min)) {", "+\t\t\t\t\t", "+\t\t\t\t\t// work-around 1.3 VM bug, if max>0x7FFF0000, must use lookup bytecode", "+\t\t\t\t\t// see http://dev.eclipse.org/bugs/show_bug.cgi?id=21557", "+\t\t\t\t\tif (max > 0x7FFF0000 && currentScope.environment().options.complianceLevel < ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tcodeStream.tableswitch(", "+\t\t\t\t\t\t\tdefaultLabel,", "+\t\t\t\t\t\t\tmin,", "+\t\t\t\t\t\t\tmax,", "+\t\t\t\t\t\t\tconstants,", "+\t\t\t\t\t\t\tsortedIndexes,", "+\t\t\t\t\t\t\tcaseLabels);", "-\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\tcodeStream.lookupswitch(defaultLabel, constants, sortedIndexes, caseLabels);", "+\t\t\t\t}", "+\t\t\t\tcodeStream.updateLastRecordedEndPC(codeStream.position);", "+\t\t\t}", "+\t\t\t", "+\t\t\t// generate the switch block statements", "+\t\t\tint caseIndex = 0;", "+\t\t\tif (statements != null) {", "+\t\t\t\tfor (int i = 0, maxCases = statements.length; i < maxCases; i++) {", "+\t\t\t\t\tStatement statement = statements[i];", "+\t\t\t\t\tif ((caseIndex < caseCount) && (statement == cases[caseIndex])) { // statements[i] is a case", "+\t\t\t\t\t\tthis.scope.switchCase = cases[caseIndex]; // record entering in a switch case block", "+\t\t\t\t\t\tcaseIndex++;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tif (statement == defaultCase) { // statements[i] is a case or a default case", "+\t\t\t\t\t\t\tthis.scope.switchCase = defaultCase; // record entering in a switch case block", "+\t\t\t\t\t\t\tif (preSwitchInitStateIndex != -1) {", "+\t\t\t\t\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\t\t\tpreSwitchInitStateIndex);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t\t\tstatement.generateCode(scope, codeStream);", "-\t\t}", "-\t\t// place the trailing labels (for break and default case)", "-\t\tbreakLabel.place();", "-\t\tif (defaultCase == null) {", "-\t\t\tdefaultLabel.place();", "-\t\t}", "-\t\t// May loose some local variable initializations : affecting the local variable attributes", "-\t\tif (mergedInitStateIndex != -1) {", "-\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tmergedInitStateIndex);", "-\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "-\t\t}", "-\t\tif (scope != currentScope) {", "-\t\t\tcodeStream.exitUserScope(scope);", "-\t\t}", "-\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t\t\t// place the trailing labels (for break and default case)", "+\t\t\tbreakLabel.place();", "+\t\t\tif (defaultCase == null) {", "+\t\t\t\tdefaultLabel.place();", "+\t\t\t}", "+\t\t\t// May loose some local variable initializations : affecting the local variable attributes", "+\t\t\tif (mergedInitStateIndex != -1) {", "+\t\t\t\tcodeStream.removeNotDefinitelyAssignedVariables(", "+\t\t\t\t\tcurrentScope,", "+\t\t\t\t\tmergedInitStateIndex);", "+\t\t\t\tcodeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);", "+\t\t\t}", "+\t\t\tif (scope != currentScope) {", "+\t\t\t\tcodeStream.exitUserScope(scope);", "+\t\t\t}", "+\t\t\tcodeStream.recordPositionsFrom(pc, this.sourceStart);", "+\t    } finally {", "+\t        if (this.scope != null) this.scope.switchCase = null; // no longer inside switch case block", "+\t    }\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd959afb1e34adfc786d2261b715dff4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java", "commitBeforeChange": "c30613b3c1eac52834666cb07a38e3f9077e1829", "commitAfterChange": "cbaf155d59bae1aee7ec473c177014431f794c16", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": "  public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "signatureAfterChange": "  public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope)", "diff": ["+", "+public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope) {", "+\t// LIGHT-VERSION OF THE EQUIVALENT WITH AN ARRAY OF EXCEPTIONS", "+\t// check that all the argument exception types are handled", "+\t// JDK Compatible implementation - when an exception type is thrown, ", "+\t// all related catch blocks are marked as reachable... instead of those only", "+\t// until the point where it is safely handled (Smarter - see comment at the end)", "+\tFlowContext traversedContext = this;", "+\twhile (traversedContext != null) {", "+\t\tSubRoutineStatement sub;", "+\t\tif (((sub = traversedContext.subroutine()) != null) && sub.isSubRoutineEscaping()) {", "+\t\t\t// traversing a non-returning subroutine means that all unhandled ", "+\t\t\t// exceptions will actually never get sent...", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\t// filter exceptions that are locally caught from the innermost enclosing ", "+\t\t// try statement to the outermost ones.", "+\t\tif (traversedContext instanceof ExceptionHandlingFlowContext) {", "+\t\t\tExceptionHandlingFlowContext exceptionContext =", "+\t\t\t\t(ExceptionHandlingFlowContext) traversedContext;", "+\t\t\tReferenceBinding[] caughtExceptions;", "+\t\t\tif ((caughtExceptions = exceptionContext.handledExceptions) != Binding.NO_EXCEPTIONS) {", "+\t\t\t\tboolean definitelyCaught = false;", "+\t\t\t\tfor (int caughtIndex = 0, caughtCount = caughtExceptions.length;", "+\t\t\t\t\tcaughtIndex < caughtCount;", "+\t\t\t\t\tcaughtIndex++) {", "+\t\t\t\t\tReferenceBinding caughtException = caughtExceptions[caughtIndex];", "+\t\t\t\t    int state = caughtException == null ", "+\t\t\t\t    \t? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */", "+\t\t\t\t        : Scope.compareTypes(raisedException, caughtException);\t\t\t\t\t\t", "+\t\t\t\t\tswitch (state) {", "+\t\t\t\t\t\tcase Scope.EQUAL_OR_MORE_SPECIFIC :", "+\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "+\t\t\t\t\t\t\t\tcaughtException,", "+\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "+\t\t\t\t\t\t\t\traisedException,", "+\t\t\t\t\t\t\t\tlocation,", "+\t\t\t\t\t\t\t\tdefinitelyCaught);", "+\t\t\t\t\t\t\t// was it already definitely caught ?", "+\t\t\t\t\t\t\tdefinitelyCaught = true;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase Scope.MORE_GENERIC :", "+\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "+\t\t\t\t\t\t\t\tcaughtException,", "+\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "+\t\t\t\t\t\t\t\traisedException,", "+\t\t\t\t\t\t\t\tlocation,", "+\t\t\t\t\t\t\t\tfalse);", "+\t\t\t\t\t\t\t// was not caught already per construction", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (definitelyCaught)", "+\t\t\t\t\treturn;", "+\t\t\t}", "+\t\t\t// method treatment for unchecked exceptions", "+\t\t\tif (exceptionContext.isMethodContext) {", "+\t\t\t\tif (raisedException.isUncheckedException(false))", "+\t\t\t\t\treturn;", "+\t\t\t\t\t", "+\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions", "+\t\t\t\t// clause will be fixed up later as per JLS 8.6).", "+\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){", "+\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;", "+\t\t\t\t\tif (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);", "+\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak; // not handled anywhere, thus jump to error handling", "+\t\t\t}", "+\t\t}", "+", "+\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "+\t\t", "+\t\tif (traversedContext instanceof InsideSubRoutineFlowContext) {", "+\t\t\tASTNode node = traversedContext.associatedNode;", "+\t\t\tif (node instanceof TryStatement) {", "+\t\t\t\tTryStatement tryStatement = (TryStatement) node;", "+\t\t\t\tflowInfo.addInitializationsFrom(tryStatement.subRoutineInits); // collect inits\t\t\t", "+\t\t\t}", "+\t\t}", "+\t\ttraversedContext = traversedContext.parent;", "+\t}", "+\t// if reaches this point, then there are some remaining unhandled exception types.", "+\tscope.problemReporter().unhandledException(raisedException, location);", "-", "-public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location, FlowInfo flowInfo, BlockScope scope) {", "-\t// LIGHT-VERSION OF THE EQUIVALENT WITH AN ARRAY OF EXCEPTIONS", "-\t// check that all the argument exception types are handled", "-\t// JDK Compatible implementation - when an exception type is thrown, ", "-\t// all related catch blocks are marked as reachable... instead of those only", "-\t// until the point where it is safely handled (Smarter - see comment at the end)", "-\tFlowContext traversedContext = this;", "-\twhile (traversedContext != null) {", "-\t\tSubRoutineStatement sub;", "-\t\tif (((sub = traversedContext.subRoutine()) != null) && sub.isSubRoutineEscaping()) {", "-\t\t\t// traversing a non-returning subroutine means that all unhandled ", "-\t\t\t// exceptions will actually never get sent...", "-\t\t\treturn;", "-\t\t}", "-\t\t", "-\t\t// filter exceptions that are locally caught from the innermost enclosing ", "-\t\t// try statement to the outermost ones.", "-\t\tif (traversedContext instanceof ExceptionHandlingFlowContext) {", "-\t\t\tExceptionHandlingFlowContext exceptionContext =", "-\t\t\t\t(ExceptionHandlingFlowContext) traversedContext;", "-\t\t\tReferenceBinding[] caughtExceptions;", "-\t\t\tif ((caughtExceptions = exceptionContext.handledExceptions) != Binding.NO_EXCEPTIONS) {", "-\t\t\t\tboolean definitelyCaught = false;", "-\t\t\t\tfor (int caughtIndex = 0, caughtCount = caughtExceptions.length;", "-\t\t\t\t\tcaughtIndex < caughtCount;", "-\t\t\t\t\tcaughtIndex++) {", "-\t\t\t\t\tReferenceBinding caughtException = caughtExceptions[caughtIndex];", "-\t\t\t\t    int state = caughtException == null ", "-\t\t\t\t    \t? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */", "-\t\t\t\t        : Scope.compareTypes(raisedException, caughtException);\t\t\t\t\t\t", "-\t\t\t\t\tswitch (state) {", "-\t\t\t\t\t\tcase Scope.EQUAL_OR_MORE_SPECIFIC :", "-\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "-\t\t\t\t\t\t\t\tcaughtException,", "-\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "-\t\t\t\t\t\t\t\traisedException,", "-\t\t\t\t\t\t\t\tlocation,", "-\t\t\t\t\t\t\t\tdefinitelyCaught);", "-\t\t\t\t\t\t\t// was it already definitely caught ?", "-\t\t\t\t\t\t\tdefinitelyCaught = true;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Scope.MORE_GENERIC :", "-\t\t\t\t\t\t\texceptionContext.recordHandlingException(", "-\t\t\t\t\t\t\t\tcaughtException,", "-\t\t\t\t\t\t\t\tflowInfo.unconditionalInits(),", "-\t\t\t\t\t\t\t\traisedException,", "-\t\t\t\t\t\t\t\tlocation,", "-\t\t\t\t\t\t\t\tfalse);", "-\t\t\t\t\t\t\t// was not caught already per construction", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (definitelyCaught)", "-\t\t\t\t\treturn;", "-\t\t\t}", "-\t\t\t// method treatment for unchecked exceptions", "-\t\t\tif (exceptionContext.isMethodContext) {", "-\t\t\t\tif (raisedException.isUncheckedException(false))", "-\t\t\t\t\treturn;", "-\t\t\t\t\t", "-\t\t\t\t// anonymous constructors are allowed to throw any exceptions (their thrown exceptions", "-\t\t\t\t// clause will be fixed up later as per JLS 8.6).", "-\t\t\t\tif (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){", "-\t\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;", "-\t\t\t\t\tif (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){", "-\t\t\t\t\t\t\t\t", "-\t\t\t\t\t\texceptionContext.mergeUnhandledException(raisedException);", "-\t\t\t\t\t\treturn; // no need to complain, will fix up constructor exceptions\t\t\t\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tbreak; // not handled anywhere, thus jump to error handling", "-\t\t\t}", "-\t\t}", "-", "-\t\ttraversedContext.recordReturnFrom(flowInfo.unconditionalInits());", "-\t\tif (traversedContext.associatedNode instanceof TryStatement){", "-\t\t\tTryStatement tryStatement = (TryStatement) traversedContext.associatedNode;", "-\t\t\t\tflowInfo = flowInfo.addInitializationsFrom(tryStatement.subRoutineInits);", "-\t\t}", "-\t\ttraversedContext = traversedContext.parent;", "-\t}", "-\t// if reaches this point, then there are some remaining unhandled exception types.", "-\tscope.problemReporter().unhandledException(raisedException, location);"]}], "num": 40111}