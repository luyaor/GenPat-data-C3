{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ececd8f844514bd69af7198af996f777", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0aa71d631236c45102a547b3fb854eba", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java", "commitBeforeChange": "80a779f7e5954c8d87d2d9d39f82f45cac16ecf1", "commitAfterChange": "e6d1c8eac73b65997182b9feaba7e190099afd1a", "methodNumberBeforeChange": 41, "methodNumberAfterChange": 41, "signatureBeforeChange": "  public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "signatureAfterChange": "  public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["-\tTypeBinding expressionType = this.resolvedType;", "-\tif (expressionType == null || !expressionType.isValidBinding()) // Shouldn't get here, just to play it safe", "-\t\treturn false; // trigger ambiguity.", "-\tif (s.isBaseType() && t.isBaseType())", "-\t\treturn s.isCompatibleWith(t);", "-\treturn s.findSuperTypeOriginatingFrom(t) != null;", "+\treturn s.isCompatibleWith(t);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6d82d088775c4f01aa20f756960527b5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AddJarFileToIndex.java", "commitBeforeChange": "4d4c077960caad3dac6f1440a1eec3349b581bc3", "commitAfterChange": "84e94fe061dc975da80dda85572c99f5b95d09f2", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-\t\t\t\tFile file = null;", "-\t\t\t\t\tfile = location.toFile();", "-\t\t\t\t\tzip = new ZipFile(file);", "+\t\t\t\t\tzip = new ZipFile(location.toFile());", "-\t\t\t\t\tfile = this.indexPath.toFile();", "-\t\t\t\t\tzip = new ZipFile(file);", "+\t\t\t\t\tzip = new ZipFile(this.indexPath.toFile());", "-\t\t\t\t}", "-\t\t\t\tif (!file.exists()) {", "-\t\t\t\t\tmanager.removeIndex(this.indexPath);", "-\t\t\t\t\treturn false;", "-\t\t\t\tif (index != null) // index already existed: recreate it so that we forget about previous entries", "-\t\t\t\t\tindex = manager.recreateIndex(this.indexPath);", "+\t\t\t\t// index already existed: recreate it so that we forget about previous entries", "+\t\t\t\tindex = manager.recreateIndex(this.indexPath);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "89c246320bc789704af81c932d3db5fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 43, "methodNumberAfterChange": 40, "signatureBeforeChange": "\t \t \tpublic MethodBinding findMethod0(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite, boolean inStaticContext)", "signatureAfterChange": "\t \t \tpublic MethodBinding findMethod0(ReferenceBinding receiverType, char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite, boolean inStaticContext)", "diff": ["-\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, APPLICABILITY);", "+\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-// ==== 1.8: Finalize type inference of generic methods: ====", "-\t\t\t\t\t\t\tMethodBinding improved = inferInvocationType(invocationSite, compatibleMethod, argumentTypes);", "-\t\t\t\t\t\t\tif (improved != null && improved.isValidBinding()) {", "-\t\t\t\t\t\t\t\tcompatibleMethod = improved;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tproblemMethod = improved;", "-\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-// ==== 1.8 ====", "-\t\t\t\t// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):", "-\t\t\t\tcandidate = inferInvocationType(invocationSite, candidates[0], argumentTypes);", "+\t\t\t\tcandidate = candidates[0];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90f40dce1c49b436f8650fbe517c361c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java", "commitBeforeChange": "52aadf84ad4c79f64e59f07a05239268e15539c0", "commitAfterChange": "edc37e94c3a8ff30574beb9cdf0696d92f661cd3", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "   protected void buildStructure(OpenableElementInfo info, IProgressMonitor monitor) throws JavaModelException", "signatureAfterChange": "   protected void buildStructure(OpenableElementInfo info, IProgressMonitor monitor) throws JavaModelException", "diff": ["-", "-\tIProblemRequestor problemRequestor = this.getProblemRequestor();", "-\tif (problemRequestor != null && problemRequestor.isActive()){", "-\t\tproblemRequestor.beginReporting();", "-\t\tCompilationUnitProblemFinder.process(this, problemRequestor, monitor); // TODO: is the JavaModel lock taken here ? Can run client code", "-\t\tproblemRequestor.endReporting();", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "97ea41818bdb5678ade268ef665ab089", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java", "commitBeforeChange": "86284f2db6c7ac41b63c1766c9b7b3a016d95a9a", "commitAfterChange": "c8d8bdad35a9dc8d924116cabb6dd00986cff218", "methodNumberBeforeChange": 73, "methodNumberAfterChange": 73, "signatureBeforeChange": " \tprotected Goal parse(Goal goal, Goal alternateGoal)", "signatureAfterChange": " \tprotected boolean parse(Goal goal)", "diff": ["-\tprotected Goal parse(Goal goal, Goal alternateGoal) {", "+\tprotected boolean parse(Goal goal) {", "-\t\t\t\t\treturn Goal.FailedGoal;", "+\t\t\t\t\treturn FAILURE;", "-\t\t\t\t    return Goal.FailedGoal; // accept - we should never reach this state, we accept at reduce with a right member of follow set below.", "+\t\t\t\t    return FAILURE; // accept - we should never reach this state, we accept at reduce with a right member of follow set below.", "-\t\t\t\t\t\treturn goal;", "-\t\t\t\t\tif (alternateGoal != null && alternateGoal.hasBeenReached(act,  this.currentToken))", "-\t\t\t\t\t\treturn alternateGoal;", "+\t\t\t\t\t\treturn SUCCESS;", "-\t\t\treturn Goal.FailedGoal;", "+\t\t\treturn FAILURE;"]}], "num": 19222}