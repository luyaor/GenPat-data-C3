{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2c21bcc22e429639ee40dcdcfa783405", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "09097489857d8d4ef78785a93fbaa03f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java", "commitBeforeChange": "2fd2027f1bd96549ae174a672a3e75a3fbef9f00", "commitAfterChange": "bbdc67ca80e8d3933fe67f2dadba11598c084b7c", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r \tpublic IJavaElementDelta processExternalJarChanges()", "signatureAfterChange": "\r \tpublic void checkExternalJarChanges(IProgressMonitor monitor)", "diff": ["+\t */\r", "+\tpublic void checkExternalJarChanges(IProgressMonitor monitor) {\r", "+\r", "+\t\ttry {\r", "+\t\t\tHashMap externalJARsStatus = new HashMap();\r", "+\t\t\t\r", "+\t\t\tJavaModel model = manager.getJavaModel();\t\t\t\r", "+\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "+\t\t\tboolean hasDelta = false;\r", "+\t\t\t\r", "+\t\t\tIJavaProject[] projects =model.getOldJavaProjectsList();\r", "+\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "+\t\t\t\tIJavaProject project = projects[i];\r", "+\t\t\t\tIClasspathEntry[] entries = project.getResolvedClasspath(true);\r", "+\t\t\t\tfor (int j = 0; j < entries.length; j++){\r", "+\t\t\t\t\tif (entries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY) {\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tIPath entryPath = entries[j].getPath();\r", "+\t\t\t\t\t\tString status = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\tif (status == null){\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t// compute shared status\r", "+\t\t\t\t\t\t\tObject targetLibrary = JavaModel.getTarget(project.getProject(), entryPath, true);\r", "+\r", "+\t\t\t\t\t\t\tif (targetLibrary == null){ // missing JAR\r", "+\t\t\t\t\t\t\t\tif (this.externalTimeStamps.containsKey(entryPath)){\r", "+\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.remove(entryPath);\r", "+\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\t// the jar was physically removed: remove the index\r", "+\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\t\t\t\t\t\t\t\t}\r", "+\r", "+\t\t\t\t\t\t\t} else if (targetLibrary instanceof File){ // external JAR\r", "+\r", "+\t\t\t\t\t\t\t\tFile externalFile = (File)targetLibrary;\r", "+\t\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\t\t\t// check timestamp to figure if JAR has changed in some way\r", "+\t\t\t\t\t\t\t\tLong oldTimestamp =(Long) this.externalTimeStamps.get(entryPath);\r", "+\t\t\t\t\t\t\t\tlong newTimeStamp = getTimeStamp(externalFile);\r", "+\t\t\t\t\t\t\t\tif (oldTimestamp != null){\r", "+\r", "+\t\t\t\t\t\t\t\t\tif (newTimeStamp == 0){ // file doesn't exist\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.remove(entryPath);\r", "+\t\t\t\t\t\t\t\t\t\t// remove the index\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\r", "+\t\t\t\t\t\t\t\t\t} else if (oldTimestamp.longValue() != newTimeStamp){\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_CHANGED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.put(entryPath, new Long(newTimeStamp));\r", "+\t\t\t\t\t\t\t\t\t\t// first remove the index so that it is forced to be re-indexed\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.removeIndex(entryPath);\r", "+\t\t\t\t\t\t\t\t\t\t// then index the jar\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.indexLibrary(entryPath, project.getProject());\r", "+\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\tif (newTimeStamp == 0){ // jar still doesn't exist\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);\r", "+\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, EXTERNAL_JAR_ADDED);\r", "+\t\t\t\t\t\t\t\t\t\tthis.externalTimeStamps.put(entryPath, new Long(newTimeStamp));\r", "+\t\t\t\t\t\t\t\t\t\t// index the new jar\r", "+\t\t\t\t\t\t\t\t\t\tindexManager.indexLibrary(entryPath, project.getProject());\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t} else { // internal JAR\r", "+\t\t\t\t\t\t\t\texternalJARsStatus.put(entryPath, INTERNAL_JAR_IGNORE);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t// according to computed status, generate a delta\r", "+\t\t\t\t\t\tstatus = (String)externalJARsStatus.get(entryPath); \r", "+\t\t\t\t\t\tif (status != null){\r", "+\t\t\t\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());\r", "+\t\t\t\t\t\t\tif (status == EXTERNAL_JAR_ADDED){\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR ADDED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t} \r", "+\t\t\t\t\t\t\t\telementAdded(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t} else if (status == EXTERNAL_JAR_CHANGED) {\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR CHANGED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\tcontentChanged(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t} else if (status == EXTERNAL_JAR_REMOVED) {\r", "+\t\t\t\t\t\t\t\tif (VERBOSE){\r", "+\t\t\t\t\t\t\t\t\tSystem.out.println(\"- External JAR REMOVED, affecting root: \"+root.getElementName());\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\telementRemoved(root, null);\r", "+\t\t\t\t\t\t\t\thasDelta = true;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tif (hasDelta){\r", "+\t\t\t\tthis.manager.fire(fCurrentDelta, JavaModelManager.DEFAULT_CHANGE_EVENT);\t\t\t\r", "+\t\t\t}\r", "+\t\t} catch (JavaModelException e) { // nothing can be done\r", "+\t\t} finally {\r", "+\t\t\tfCurrentDelta = null;\r", "+\t\t}\r", "+\t}\r", "-\t */\r", "-\tpublic IJavaElementDelta processExternalJarChanges() {\r", "-\t\t\r", "-\t\t// did any external JAR change ?\r", "-\t\tif (this.externalJarPathsToUpdate.isEmpty()) return null;\r", "-\t\ttry {\r", "-\t\t\tJavaModel model = manager.getJavaModel();\r", "-\t\t\tfCurrentDelta = new JavaElementDelta(model);\r", "-\t\t\tIJavaProject[] projects =model.getOldJavaProjectsList();\r", "-\t\t\tfor (int i = 0, length = projects.length; i < length; i++) {\r", "-\t\t\t\tIJavaProject project = projects[i];\r", "-\t\t\t\tIPackageFragmentRoot[] roots = project.getPackageFragmentRoots();\r", "-\t\t\t\tfor (int j = 0; j < roots.length; j++){\r", "-\t\t\t\t\tif (this.externalJarPathsToUpdate.contains(roots[j].getPath())){\r", "-\t\t\t\t\t\tif (VERBOSE){\r", "-\t\t\t\t\t\t\tSystem.out.println(\"External JAR changed, affecting root: \"+roots[j].getElementName());\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tcontentChanged((Openable)roots[j], null);\r", "-\t\t\t\t\t}\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t\treturn fCurrentDelta;\r", "-\t\t} catch (JavaModelException e) { // nothing can be done\r", "-\t\t} finally {\r", "-\t\t\tthis.externalJarPathsToUpdate.clear();\r", "-\t\t}\r", "-\t\treturn null;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e404f4c4720f8d223d280e5ccd610f4c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java", "commitBeforeChange": "b25ed407ef1d09375524d9c9e824c1c1084b119b", "commitAfterChange": "0bd9f6472768db6e5f0062ffcfd17bd3adede039", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options, IProgressMonitor monitor)", "signatureAfterChange": " \t \tprivate static void rootNodeToCompilationUnit(AST ast, ASTConverter converter, ASTNode node)", "diff": ["-\t */", "-\tpublic static ASTNode parse(int kind, char[] source, int offset, int length, Map options, IProgressMonitor monitor) {", "-\t\tif (options == null) {", "-\t\t\toptions = JavaCore.getOptions();", "-\t\t}", "-\t\tASTConverter converter = new ASTConverter(options, false, monitor);", "-\t\tconverter.compilationUnitSource = source;", "-\t\tconverter.scanner.setSource(source);", "-\t\t", "-\t\tAST ast = new AST();", "-\t\tast.setBindingResolver(new BindingResolver());", "-\t\tconverter.setAST(ast);", "-\t\tCodeSnippetParsingUtil codeSnippetParsingUtil = new CodeSnippetParsingUtil();", "-\t\tswitch(kind) {", "-\t\t\tcase K_STATEMENTS :", "-\t\t\t\tConstructorDeclaration constructorDeclaration = codeSnippetParsingUtil.parseStatements(source, offset, length, options);", "-\t\t\t\tif (constructorDeclaration != null) {", "-\t\t\t\t\tBlock block = ast.newBlock();", "-\t\t\t\t\tStatement[] statements = constructorDeclaration.statements;", "-\t\t\t\t\tif (statements != null) {", "-\t\t\t\t\t\tint statementsLength = statements.length;", "-\t\t\t\t\t\tfor (int i = 0; i < statementsLength; i++) {", "-\t\t\t\t\t\t\tblock.statements().add(converter.convert(statements[i]));", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn block;", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_EXPRESSION :", "-\t\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression expression = codeSnippetParsingUtil.parseExpression(source, offset, length, options);", "-\t\t\t\tif (expression != null) {", "-\t\t\t\t\treturn converter.convert(expression);", "-\t\t\t\t}", "-\t\t\t\tbreak;", "-\t\t\tcase K_CLASS_BODY_DECLARATIONS :", "-\t\t\t\tfinal org.eclipse.jdt.internal.compiler.ast.ASTNode[] nodes = codeSnippetParsingUtil.parseClassBodyDeclarations(source, offset, length, options);", "-\t\t\t\tif (nodes != null) {", "-\t\t\t\t\treturn converter.convert(nodes);", "-\t\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t", "+\tprivate static void rootNodeToCompilationUnit(AST ast, ASTConverter converter, ASTNode node) {", "+\t\t// TODO record the comments information", "+\t\tCompilationUnit compilationUnit = ast.newCompilationUnit();", "+\t\tCompilationResult compilationResult = CodeSnippetParsingUtil.RecordedCompilationResult;", "+\t\tfinal int problemsCount = compilationResult.problemCount;", "+\t\tswitch(node.getNodeType()) {", "+\t\t\tcase ASTNode.BLOCK :", "+\t\t\t\t{", "+\t\t\t\t\tBlock block = (Block) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfor (int i = 0, max = block.statements().size(); i < max; i++) {", "+\t\t\t\t\t\t\tconverter.propagateErrors((ASTNode) block.statements().get(i), resizedProblems);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tTypeDeclaration typeDeclaration = ast.newTypeDeclaration();", "+\t\t\t\t\tInitializer initializer = ast.newInitializer();", "+\t\t\t\t\tinitializer.setBody(block);", "+\t\t\t\t\ttypeDeclaration.bodyDeclarations().add(initializer);", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tcase ASTNode.TYPE_DECLARATION :", "+\t\t\t\t{", "+\t\t\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tfor (int i = 0, max = typeDeclaration.bodyDeclarations().size(); i < max; i++) {", "+\t\t\t\t\t\t\tconverter.propagateErrors((ASTNode) typeDeclaration.bodyDeclarations().get(i), resizedProblems);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\tif (node instanceof Expression) {", "+\t\t\t\t\tExpression expression = (Expression) node;", "+\t\t\t\t\tif (problemsCount != 0) {", "+\t\t\t\t\t\t// propagate and record problems", "+\t\t\t\t\t\tIProblem[] resizedProblems = null;", "+\t\t\t\t\t\tfinal IProblem[] problems = compilationResult.problems;", "+\t\t\t\t\t\tif (problems.length == problemsCount) {", "+\t\t\t\t\t\t\tresizedProblems = problems;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tSystem.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tconverter.propagateErrors(expression, resizedProblems);", "+\t\t\t\t\t\tcompilationUnit.setProblems(resizedProblems);", "+\t\t\t\t\t}", "+\t\t\t\t\tExpressionStatement expressionStatement = ast.newExpressionStatement(expression);", "+\t\t\t\t\tBlock block = ast.newBlock();", "+\t\t\t\t\tblock.statements().add(expressionStatement);", "+\t\t\t\t\tInitializer initializer = ast.newInitializer();", "+\t\t\t\t\tinitializer.setBody(block);", "+\t\t\t\t\tTypeDeclaration typeDeclaration = ast.newTypeDeclaration();", "+\t\t\t\t\ttypeDeclaration.bodyDeclarations().add(initializer);", "+\t\t\t\t\tcompilationUnit.types().add(typeDeclaration);", "+\t\t\t\t}", "+\t\t}", "+\t\tcompilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);", "+\t\tCodeSnippetParsingUtil.reset();", "+\t}"]}], "num": 349}