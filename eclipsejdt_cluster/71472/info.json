{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8cdd323910e51e4388a958f256659946", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "38b3e0ae3d13fa7f7d8fb91231aa60fb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "424434f0bc8f5f118b22e054c33acbc180d3cbd4", "commitAfterChange": "64b84380d0460c14fe634e03cccf1a33ab7ee879", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \tpublic MethodBinding findMethod(\r \t\tReferenceBinding receiverType,\r \t\tchar[] selector,\r \t\tTypeBinding[] argumentTypes,\r \t\tInvocationSite invocationSite)", "diff": ["-\t\t// abstract superclass superinterface lookup (since maybe missing default\r", "-\t\t// abstract methods)\r", "-\t\tif (hierarchyContainsAbstractClasses){\r", "-\t\t\tcurrentType = classHierarchyStart;\r", "-\t\t\twhile (currentType != null){\r", "-\t\t\t\tif (currentType.isAbstract()){\r", "-\t\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "-\t\t\t\t}\r", "-\t\t\t\tcurrentType = currentType.superclass();\r", "+\t\tint foundSize = found.size;\r", "+\t\tif (foundSize == 0) {\r", "+\t\t\tif (matchingMethod == null && hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\t}\r", "+\t\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\t\tint candidatesCount = 0;\r", "+\r", "+\t\t// argument type compatibility check\r", "+\t\tfor (int i = 0; i < foundSize; i++) {\r", "+\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\tif (areParametersAssignable(methodBinding.parameters, argumentTypes))\r", "+\t\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "+\t\t}\r", "+\t\tif (candidatesCount == 1)\r", "+\t\t\treturn candidates[0]; // have not checked visibility\r", "+\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\tint argLength = argumentTypes.length;\r", "+\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {\r", "+\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\t\tTypeBinding[] params = methodBinding.parameters;\r", "+\t\t\t\tint paramLength = params.length;\r", "+\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {\r", "+\t\t\t\t\tTypeBinding arg = argumentTypes[a];\r", "+\t\t\t\t\tfor (int p = 0; p < paramLength; p++)\r", "+\t\t\t\t\t\tif (params[p] == arg)\r", "+\t\t\t\t\t\t\tcontinue nextArg;\r", "+\t\t\t\t\tcontinue nextMethod;\r", "+\t\t\t\t}\r", "+\t\t\t\treturn methodBinding;\r", "+\t\t\t}\r", "+\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found\r", "-\t\tint foundSize = found.size;\r", "-\t\tif (foundSize == 0)\r", "-\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\t// visibility check\r", "+\t\tint visiblesCount = 0;\r", "+\t\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\t\tif (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {\r", "+\t\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t\t}\r", "+\t\t\t\tvisiblesCount++;\r", "+\t\t\t}\r", "+\t\t}\r", "+\t\tif (visiblesCount == 1) {\r", "+\t\t\tcompilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\t\treturn candidates[0];\r", "+\t\t}\r", "+\t\tif (visiblesCount == 0) {\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\treturn new ProblemMethodBinding(\r", "+\t\t\t\tcandidates[0].selector,\r", "+\t\t\t\targumentTypes,\r", "+\t\t\t\tcandidates[0].declaringClass,\r", "+\t\t\t\tNotVisible);\r", "+\t\t}\t\r", "+\t\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t\t} else {\r", "+\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t\t}\r", "+\t}\r", "-\t\tif (candidates[0].declaringClass.isClass()) {\r", "-\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "-\t\t} else {\r", "-\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "431d243fd4fcf220eda86da1a5625dc5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java", "commitBeforeChange": "fbe6068a056e0c84ef6c205002f1a940414a157a", "commitAfterChange": "c6eaf8522a1a36af9ad6ac5cdc9ead859016f6c5", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": "\r public MethodBinding findMethod(\r \tReferenceBinding receiverType,\r \tchar[] selector,\r \tTypeBinding[] argumentTypes,\r \tInvocationSite invocationSite)", "signatureAfterChange": "\r public MethodBinding findMethod(\r \tReferenceBinding receiverType,\r \tchar[] selector,\r \tTypeBinding[] argumentTypes,\r \tInvocationSite invocationSite)", "diff": ["-\tReferenceBinding currentType = receiverType;\r", "-\tMethodBinding matchingMethod = null;\r", "-\tObjectVector found = new ObjectVector();\r", "+\t\tReferenceBinding currentType = receiverType;\r", "+\t\tMethodBinding matchingMethod = null;\r", "+\t\tObjectVector found = new ObjectVector();\r", "-\t//compilationUnitScope().recordTypeReference(receiverType);\r", "-\t//compilationUnitScope().recordTypeReferences(argumentTypes);\r", "+\t\t//compilationUnitScope().recordTypeReference(receiverType);\r", "+\t\t//compilationUnitScope().recordTypeReferences(argumentTypes);\r", "-\tif (currentType.isInterface()) {\r", "-\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);\r", "-\t\tint currentLength = currentMethods.length;\r", "-\t\tif (currentLength == 1) {\r", "-\t\t\tmatchingMethod = currentMethods[0];\r", "-\t\t} else if (currentLength > 1) {\r", "-\t\t\tfor (int f = 0; f < currentLength; f++)\r", "-\t\t\t\tfound.add(currentMethods[f]);\r", "-\t\t}\r", "-\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "-\t\tcurrentType = getJavaLangObject();\r", "-\t}\r", "-\r", "-\t// superclass lookup\r", "-\tboolean hierarchyContainsAbstractClasses = false;\r", "-\tReferenceBinding classHierarchyStart = currentType;\r", "-\t\r", "-\twhile (currentType != null) {\r", "-\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);\r", "-\t\tint currentLength = currentMethods.length;\r", "-\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {\r", "-\t\t\tmatchingMethod = currentMethods[0];\r", "-\t\t} else if (currentLength > 0) {\r", "-\t\t\tif (found.size == 0 && matchingMethod != null)\r", "-\t\t\t\tfound.add(matchingMethod);\r", "-\t\t\tfor (int f = 0; f < currentLength; f++)\r", "-\t\t\t\tfound.add(currentMethods[f]);\r", "-\t\t}\r", "-\t\tif (currentType.isAbstract()) hierarchyContainsAbstractClasses = true;\r", "-\t\tcurrentType = currentType.superclass();\r", "-\t}\r", "-\r", "-\t// abstract superclass superinterface lookup (since maybe missing default\r", "-\t// abstract methods)\r", "-\tif (hierarchyContainsAbstractClasses){\r", "-\t\tcurrentType = classHierarchyStart;\r", "-\t\twhile (currentType != null){\r", "-\t\t\tif (currentType.isAbstract()){\r", "-\t\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\tif (currentType.isInterface()) {\r", "+\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);\r", "+\t\t\tint currentLength = currentMethods.length;\r", "+\t\t\tif (currentLength == 1) {\r", "+\t\t\t\tmatchingMethod = currentMethods[0];\r", "+\t\t\t} else if (currentLength > 1) {\r", "+\t\t\t\tfor (int f = 0; f < currentLength; f++)\r", "+\t\t\t\t\tfound.add(currentMethods[f]);\r", "+\t\t\tmatchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);\r", "+\t\t\tcurrentType = getJavaLangObject();\r", "+\t\t}\r", "+\r", "+\t\t// superclass lookup\r", "+\t\tboolean hierarchyContainsAbstractClasses = false;\r", "+\t\tReferenceBinding classHierarchyStart = currentType;\r", "+\t\t\r", "+\t\twhile (currentType != null) {\r", "+\t\t\tMethodBinding[] currentMethods = currentType.getMethods(selector);\r", "+\t\t\tint currentLength = currentMethods.length;\r", "+\t\t\tif (currentLength == 1 && matchingMethod == null && found.size == 0) {\r", "+\t\t\t\tmatchingMethod = currentMethods[0];\r", "+\t\t\t} else if (currentLength > 0) {\r", "+\t\t\t\tif (found.size == 0 && matchingMethod != null)\r", "+\t\t\t\t\tfound.add(matchingMethod);\r", "+\t\t\t\tfor (int f = 0; f < currentLength; f++)\r", "+\t\t\t\t\tfound.add(currentMethods[f]);\r", "+\t\t\t}\r", "+\t\t\tif (currentType.isAbstract()) hierarchyContainsAbstractClasses = true;\r", "-\t}\r", "-\tint foundSize = found.size;\r", "-\tif (foundSize == 0)\r", "-\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\tint foundSize = found.size;\r", "+\t\tif (foundSize == 0) {\r", "+\t\t\tif (matchingMethod == null && hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\treturn matchingMethod; // may be null - have not checked arg types or visibility\r", "+\t\t}\r", "+\t\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "+\t\tint candidatesCount = 0;\r", "-\tMethodBinding[] candidates = new MethodBinding[foundSize];\r", "-\tint candidatesCount = 0;\r", "-\r", "-\t// argument type compatibility check\r", "-\tfor (int i = 0; i < foundSize; i++) {\r", "-\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "-\t\tif (areParametersAssignable(methodBinding.parameters, argumentTypes))\r", "-\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "-\t}\r", "-\tif (candidatesCount == 1)\r", "-\t\treturn candidates[0]; // have not checked visibility\r", "-\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "-\t\tint argLength = argumentTypes.length;\r", "-\t\tnextMethod : for (int i = 0; i < foundSize; i++) {\r", "+\t\t// argument type compatibility check\r", "+\t\tfor (int i = 0; i < foundSize; i++) {\r", "-\t\t\tTypeBinding[] params = methodBinding.parameters;\r", "-\t\t\tint paramLength = params.length;\r", "-\t\t\tnextArg: for (int a = 0; a < argLength; a++) {\r", "-\t\t\t\tTypeBinding arg = argumentTypes[a];\r", "-\t\t\t\tfor (int p = 0; p < paramLength; p++)\r", "-\t\t\t\t\tif (params[p] == arg)\r", "-\t\t\t\t\t\tcontinue nextArg;\r", "-\t\t\t\tcontinue nextMethod;\r", "-\t\t\t}\r", "-\t\t\treturn methodBinding;\r", "+\t\t\tif (areParametersAssignable(methodBinding.parameters, argumentTypes))\r", "+\t\t\t\tcandidates[candidatesCount++] = methodBinding;\r", "-\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found\r", "-\t}\r", "+\t\tif (candidatesCount == 1)\r", "+\t\t\treturn candidates[0]; // have not checked visibility\r", "+\t\tif (candidatesCount == 0) { // try to find a close match when the parameter order is wrong or missing some parameters\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\tint argLength = argumentTypes.length;\r", "+\t\t\tnextMethod : for (int i = 0; i < foundSize; i++) {\r", "+\t\t\t\tMethodBinding methodBinding = (MethodBinding) found.elementAt(i);\r", "+\t\t\t\tTypeBinding[] params = methodBinding.parameters;\r", "+\t\t\t\tint paramLength = params.length;\r", "+\t\t\t\tnextArg: for (int a = 0; a < argLength; a++) {\r", "+\t\t\t\t\tTypeBinding arg = argumentTypes[a];\r", "+\t\t\t\t\tfor (int p = 0; p < paramLength; p++)\r", "+\t\t\t\t\t\tif (params[p] == arg)\r", "+\t\t\t\t\t\t\tcontinue nextArg;\r", "+\t\t\t\t\tcontinue nextMethod;\r", "+\t\t\t\t}\r", "+\t\t\t\treturn methodBinding;\r", "+\t\t\t}\r", "+\t\t\treturn (MethodBinding) found.elementAt(0); // no good match so just use the first one found\r", "+\t\t}\r", "-\t// visibility check\r", "-\tint visiblesCount = 0;\r", "-\tfor (int i = 0; i < candidatesCount; i++) {\r", "-\t\tMethodBinding methodBinding = candidates[i];\r", "-\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)){\r", "-\t\t\tif (visiblesCount != i) {\r", "-\t\t\t\tcandidates[i] = null;\r", "-\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t// visibility check\r", "+\t\tint visiblesCount = 0;\r", "+\t\tfor (int i = 0; i < candidatesCount; i++) {\r", "+\t\t\tMethodBinding methodBinding = candidates[i];\r", "+\t\t\tif (canBeSeenByForCodeSnippet(methodBinding, receiverType, invocationSite, this)) {\r", "+\t\t\t\tif (visiblesCount != i) {\r", "+\t\t\t\t\tcandidates[i] = null;\r", "+\t\t\t\t\tcandidates[visiblesCount] = methodBinding;\r", "+\t\t\t\t}\r", "+\t\t\t\tvisiblesCount++;\r", "-\t\t\tvisiblesCount++;\r", "-\t}\r", "-\tif (visiblesCount == 1) {\r", "-\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "-\t\treturn candidates[0];\r", "-\t}\r", "-\tif (visiblesCount == 0){\r", "-\t\treturn new ProblemMethodBinding(\r", "-\t\t\tcandidates[0].selector,\r", "-\t\t\targumentTypes,\r", "-\t\t\tcandidates[0].declaringClass,\r", "-\t\t\tNotVisible);\r", "-\t}\r", "-\tif (candidates[0].declaringClass.isClass()) {\r", "-\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "-\t} else {\r", "-\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "-\t}\r", "+\t\tif (visiblesCount == 1) {\r", "+\t\t\t//compilationUnitScope().recordTypeReferences(candidates[0].thrownExceptions);\r", "+\t\t\treturn candidates[0];\r", "+\t\t}\r", "+\t\tif (visiblesCount == 0) {\r", "+\t\t\tif (hierarchyContainsAbstractClasses){\r", "+\t\t\t\treturn findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, matchingMethod, found);\r", "+\t\t\t}\r", "+\t\t\treturn new ProblemMethodBinding(\r", "+\t\t\t\tcandidates[0].selector,\r", "+\t\t\t\targumentTypes,\r", "+\t\t\t\tcandidates[0].declaringClass,\r", "+\t\t\t\tNotVisible);\r", "+\t\t}\t\r", "+\t\tif (candidates[0].declaringClass.isClass()) {\r", "+\t\t\treturn mostSpecificClassMethodBinding(candidates, visiblesCount);\r", "+\t\t} else {\r", "+\t\t\treturn mostSpecificInterfaceMethodBinding(candidates, visiblesCount);\r", "+\t\t}\r"]}], "num": 71472}