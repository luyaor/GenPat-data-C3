{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d345162c87e2fd85da47169bfebc7265", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0555ecec20616a91b68b744fd774a0d0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetQualifiedNameReference.java", "commitBeforeChange": "5dd0de42e39b5ae6b6ed70261ede6298820c064c", "commitAfterChange": "2d1b668da982fab23d85fda225f2e9df3073c2e1", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 3, "signatureBeforeChange": " public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "signatureAfterChange": "  public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired)", "diff": ["-public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired) {", "-", "-\tFieldBinding lastFieldBinding = generateReadSequence(currentScope, codeStream);", "-\tif (lastFieldBinding.canBeSeenBy(getReceiverType(currentScope), this, currentScope)) {", "-\t\tif (lastFieldBinding.isStatic()){", "-\t\t\tcodeStream.getstatic(lastFieldBinding);", "-\t\t} else {", "-\t\t\tcodeStream.dup();", "-\t\t\tcodeStream.getfield(lastFieldBinding);", "-\t\t}", "-\t\t// the last field access is a write access", "-\t\t// perform the actual compound operation", "-\t\tint operationTypeID;", "-\t\tswitch(operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) {", "-\t\t\tcase T_JavaLangString :", "-\t\t\tcase T_JavaLangObject :", "-\t\t\tcase T_undefined :", "-\t\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t\t\t// promote the array reference to the suitable operation type", "-\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);", "-\t\t\t\t} else {", "-\t\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t\t}", "-\t\t\t\t// perform the operation", "-\t\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t\t// cast the value back to the array reference type", "-\t\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "-\t\t}", "-\t\t// actual assignment", "-\t\tfieldStore(codeStream, lastFieldBinding, null, valueRequired);", "-\t} else {", "-\t\tif (lastFieldBinding.isStatic()){", "-\t\t\tcodeStream.generateEmulationForField(lastFieldBinding);", "-\t\t\tcodeStream.swap();", "-\t\t\tcodeStream.aconst_null();", "-\t\t\tcodeStream.swap();", "-", "-\t\t\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "-\t\t} else {", "-\t\t\tcodeStream.generateEmulationForField(lastFieldBinding);", "-\t\t\tcodeStream.swap();", "-\t\t\tcodeStream.dup();", "-", "-\t\t\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "-\t\t}", "-\t\t// the last field access is a write access", "-\t\t// perform the actual compound operation", "-\t\tint operationTypeID;", "-\t\tif ((operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "-\t\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "-\t\t} else {", "-\t\t\t// promote the array reference to the suitable operation type", "-\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t// generate the increment value (will by itself  be promoted to the operation value)", "-\t\t\tif (expression == IntLiteral.One){ // prefix operation", "-\t\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);", "-\t\t\t} else {", "-\t\t\t\texpression.generateCode(currentScope, codeStream, true);", "-\t\t\t}", "-\t\t\t// perform the operation", "-\t\t\tcodeStream.sendOperator(operator, operationTypeID);", "-\t\t\t// cast the value back to the array reference type", "-\t\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "-\t\t}", "-\t\t// actual assignment", "-", "-\t\t// current stack is:", "-\t\t// field receiver value", "-\t\tif (valueRequired) {", "-\t\t\tif ((lastFieldBinding.type == TypeBinding.LONG) || (lastFieldBinding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\tcodeStream.dup2_x2();", "-\t\t\t} else {", "-\t\t\t}", "-\t\t}", "-\t\t// current stack is:", "-\t\t// value field receiver value", "-\t\tcodeStream.generateEmulatedWriteAccessForField(lastFieldBinding);", "+", "+public void generateCompoundAssignment(BlockScope currentScope, CodeStream codeStream, Expression expression, int operator, int assignmentImplicitConversion, boolean valueRequired) {", "+    FieldBinding lastFieldBinding = this.otherBindings == null ? (FieldBinding) this.binding : this.otherBindings[this.otherBindings.length-1];", "+\tif (lastFieldBinding.canBeSeenBy(getFinalReceiverType(), this, currentScope)) {", "+\t\tsuper.generateCompoundAssignment(currentScope, codeStream, expression, operator, assignmentImplicitConversion, valueRequired);", "+\t\treturn;", "+\t}", "+\tlastFieldBinding = generateReadSequence(currentScope, codeStream);", "+\tif (lastFieldBinding.isStatic()){", "+\t\tcodeStream.generateEmulationForField(lastFieldBinding);", "+\t\tcodeStream.swap();", "+\t\tcodeStream.aconst_null();", "+\t\tcodeStream.swap();", "+\t\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "+\t} else {", "+\t\tcodeStream.generateEmulationForField(lastFieldBinding);", "+\t\tcodeStream.swap();", "+\t\tcodeStream.dup();", "+", "+\t\tcodeStream.generateEmulatedReadAccessForField(lastFieldBinding);", "+\t}", "+\t// the last field access is a write access", "+\t// perform the actual compound operation", "+\tint operationTypeID;", "+\tif ((operationTypeID = (this.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_JavaLangString) {", "+\t\tcodeStream.generateStringConcatenationAppend(currentScope, null, expression);", "+\t} else {", "+\t\t// promote the array reference to the suitable operation type", "+\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t// generate the increment value (will by itself  be promoted to the operation value)", "+\t\tif (expression == IntLiteral.One){ // prefix operation", "+\t\t\tcodeStream.generateConstant(expression.constant, this.implicitConversion);", "+\t\t} else {", "+\t\t\texpression.generateCode(currentScope, codeStream, true);", "+\t\t}", "+\t\t// perform the operation", "+\t\tcodeStream.sendOperator(operator, operationTypeID);", "+\t\t// cast the value back to the array reference type", "+\t\tcodeStream.generateImplicitConversion(assignmentImplicitConversion);", "+\t}", "+\t// actual assignment", "+", "+\t// current stack is:", "+\t// field receiver value", "+\tif (valueRequired) {", "+\t\tswitch (lastFieldBinding.type.id) {", "+\t\t\tcase TypeIds.T_long :", "+\t\t\tcase TypeIds.T_double :", "+\t\t\t\tcodeStream.dup2_x2();", "+\t\t\t\tbreak;", "+\t\t\tdefault :", "+\t\t\t\tcodeStream.dup_x2();", "+\t\t\tbreak;\t", "+\t\t}", "+\t}", "+\t// current stack is:", "+\t// value field receiver value", "+\tcodeStream.generateEmulatedWriteAccessForField(lastFieldBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "752ad85c990dfebcd58a6a1f40f04598", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "ae43a440915bd6d7962491f9c0ab4d02295e6d83", "commitAfterChange": "9bf79c7ef87f9bb276696a699c24ee7886d82109", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "signatureAfterChange": " \tpublic void generateCode( \t\tBlockScope currentScope, \t\tCodeStream codeStream, \t\tboolean valueRequired)", "diff": ["-\t\t\t\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);", "-\t\t\t\t\t\tif ((this.implicitConversion & BOXING) != 0) {", "-\t\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "-\t\t\t\t\t\t\tcodeStream.areturn();", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tcodeStream.ireturn();", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\tcodeStream.generateImplicitConversion(this.implicitConversion);", "+\t\t\t\t\t\tcodeStream.generateReturnBytecode(this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ed68550382f43f59f4eca0087b2ce0b1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java", "commitBeforeChange": "34ee213dde08a7453eec3b2a2a0e314e1d2814a6", "commitAfterChange": "7350d2407528c733101203f94e4081cd258cb05c", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "signatureAfterChange": " \tpublic void generateCode(BlockScope currentScope, CodeStream codeStream)", "diff": ["-\t\tConstant inlinedValue;", "-\t\tif (initialization != null) {", "-\t\t\t// initialize to constant value?", "-\t\t\tif ((inlinedValue = initialization.constant) != Constant.NotAConstant) {", "-\t\t\t\t// forget initializing unused or final locals set to constant value (final ones are inlined)", "-\t\t\t\tif (binding.resolvedPosition != -1) { // may need to preserve variable", "-\t\t\t\t\tint initPC = codeStream.position;", "-\t\t\t\t\tcodeStream.generateConstant(inlinedValue, initialization.implicitConversion);", "-\t\t\t\t\tcodeStream.recordPositionsFrom(initPC, initialization.sourceStart);", "-\t\t\t\t\tcodeStream.store(binding, false);", "-\t\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t\t//\t\t\t\tcodeStream.lastInitStateIndexWhenRemovingInits = -2; // reinitialize remove index ", "-\t\t\t\t\t//\t\t\t\tcodeStream.lastInitStateIndexWhenAddingInits = -2; // reinitialize add index\t\t", "-\t\t\t\t}", "-\t\t\t} else { // initializing to non-constant value", "-\t\t\t\tinitialization.generateCode(currentScope, codeStream, true);", "+\t\tgenerateInit: {", "+\t\t\tif (this.initialization == null) ", "+\t\t\t\tbreak generateInit;", "+\t\t\t// forget initializing unused or final locals set to constant value (final ones are inlined)", "+\t\t\tif (binding.resolvedPosition < 0) {", "+\t\t\t\tif (initialization.constant != Constant.NotAConstant) ", "+\t\t\t\t\tbreak generateInit;", "-\t\t\t\tif (binding.resolvedPosition != -1) {", "-\t\t\t\t\t// 26903, need extra cast to store null in array local var\t", "-\t\t\t\t\tif (binding.type.isArrayType() ", "-\t\t\t\t\t\t&& (initialization.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "-\t\t\t\t\t\t\t|| ((initialization instanceof CastExpression)\t// arrayLoc = (type[])null", "-\t\t\t\t\t\t\t\t&& (((CastExpression)initialization).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "-\t\t\t\t\t\tcodeStream.checkcast(binding.type); ", "-\t\t\t\t\t}\t\t\t\t\t", "-\t\t\t\t\tcodeStream.store(binding, false);", "-\t\t\t\t\tif (binding.initializationCount == 0) {", "-\t\t\t\t\t\t/* Variable may have been initialized during the code initializing it", "-\t\t\t\t\t\t\te.g. int i = (i = 1);", "-\t\t\t\t\t\t*/", "-\t\t\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);", "-\t\t\t\t\t\t//\t\t\t\t\tcodeStream.lastInitStateIndexWhenRemovingInits = -2; // reinitialize remove index ", "-\t\t\t\t\t\t//\t\t\t\t\tcodeStream.lastInitStateIndexWhenAddingInits = -2; // reinitialize add index ", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tif ((binding.type == TypeBinding.LONG) || (binding.type == TypeBinding.DOUBLE)) {", "-\t\t\t\t\t\tcodeStream.pop2();", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tcodeStream.pop();", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\tinitialization.generateCode(currentScope, codeStream, false);", "+\t\t\t\tbreak generateInit;", "+\t\t\t}\t\t\t", "+\t\t\tinitialization.generateCode(currentScope, codeStream, true);", "+\t\t\t// 26903, need extra cast to store null in array local var\t", "+\t\t\tif (binding.type.isArrayType() ", "+\t\t\t\t&& (initialization.resolvedType == TypeBinding.NULL\t// arrayLoc = null", "+\t\t\t\t\t|| ((initialization instanceof CastExpression)\t// arrayLoc = (type[])null", "+\t\t\t\t\t\t&& (((CastExpression)initialization).innermostCastedExpression().resolvedType == TypeBinding.NULL)))){", "+\t\t\t\tcodeStream.checkcast(binding.type); ", "+\t\t\t}\t\t\t\t\t", "+\t\t\tcodeStream.store(binding, false);", "+\t\t\tif ((this.bits & ASTNode.FirstAssignmentToLocal) != 0) {", "+\t\t\t\t/* Variable may have been initialized during the code initializing it", "+\t\t\t\t\te.g. int i = (i = 1);", "+\t\t\t\t*/", "+\t\t\t\tbinding.recordInitializationStartPC(codeStream.position);"]}], "num": 72976}