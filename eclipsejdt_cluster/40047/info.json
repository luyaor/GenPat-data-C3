{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "3179df5bb4d3592e3cbdd49ad00c8a97", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d80bf985d482553b15aaac6a1c01844", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "85d82ef92c86e257cfcb71c0ec95b6b64432a5cb", "commitAfterChange": "db5b57ec76798735e1deba7d6189161973304788", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["+        if (scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled) {", "+        \tint len = this.descriptor.parameters.length;", "+    \t\tfor (int i = 0; i < len; i++) {", "+    \t\t\tBoolean declared = this.descriptor.parameterNonNullness == null ? null : this.descriptor.parameterNonNullness[i];", "+    \t\t\tBoolean implemented = this.binding.parameterNonNullness == null ? null : this.binding.parameterNonNullness[i];", "+    \t\t\tif (declared == Boolean.FALSE) { // promise to accept null", "+    \t\t\t\tif (implemented != Boolean.FALSE) {", "+    \t\t\t\t\tchar[][] requiredAnnot = implemented == null ? null : scope.environment().getNonNullAnnotationName();", "+    \t\t\t\t\tscope.problemReporter().parameterLackingNullableAnnotation(this, this.descriptor, i, ", "+    \t\t\t\t\t\t\tscope.environment().getNullableAnnotationName(),", "+    \t\t\t\t\t\t\trequiredAnnot, this.binding.parameters[i]);", "+    \t\t\t\t}", "+    \t\t\t} else if (declared == null) {", "+    \t\t\t\tif (implemented == Boolean.TRUE) {", "+    \t\t\t\t\tscope.problemReporter().parameterRequiresNonnull(this, this.descriptor, i,", "+    \t\t\t\t\t\t\tscope.environment().getNonNullAnnotationName(), this.binding.parameters[i]);", "+    \t\t\t\t}", "+    \t\t\t}", "+    \t\t}", "+        \tif ((this.descriptor.tagBits & TagBits.AnnotationNonNull) != 0) {", "+        \t\tif ((this.binding.tagBits & TagBits.AnnotationNonNull) == 0) {", "+        \t\t\tchar[][] providedAnnotationName = ((this.binding.tagBits & TagBits.AnnotationNullable) != 0) ?", "+        \t\t\t\t\tscope.environment().getNullableAnnotationName() : null;", "+        \t\t\tscope.problemReporter().illegalReturnRedefinition(this, this.descriptor,", "+        \t\t\t\t\tscope.environment().getNonNullAnnotationName(),", "+        \t\t\t\t\tprovidedAnnotationName, this.binding.returnType);", "+        \t\t}", "+        \t}", "+        }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c37ea218d9612f6a3e3129a7a8a48325", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "-\t\tfor (int a = argsLength; --a >= 0;)", "-\t\t\tthis.arguments[a].resolveType(scope);", "+\t\tint length = this.arguments.length;", "+\t\targumentTypes = new TypeBinding[length];", "+\t\tfor (int a = argsLength; --a >= 0;) {", "+\t\t\targumentTypes[a] = this.arguments[a].resolveType(scope);", "+\t\t}", "-", "+\tfinal boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;", "+\t\tif (enclosingType == null) {", "+\t\t\t// try to propose something even if enclosing type cannot be resolved.", "+\t\t\t// Eg.: new Test<>().new Test<>(#cursor#", "+\t\t\tif (this.enclosingInstance instanceof AllocationExpression) {", "+\t\t\t\tTypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;", "+\t\t\t\tif (enclosingInstanceType != null) {", "+\t\t\t\t\tenclosingType = enclosingInstanceType.resolvedType;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}", "-\t\tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tthis.resolvedType = this.type.resolveType(scope, true /* check bounds*/);", "+\t \tif (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(((ParameterizedTypeBinding) this.resolvedType).genericType(), null, argumentTypes, scope);", "+\t\t\tif (inferredTypes != null) {", "+\t\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\t} else {", "+\t\t\t\t// inference failed. Resolved type will be of the form Test<>", "+\t\t\t\tthis.bits |= ASTNode.IsDiamond;", "+\t\t\t}", "+\t \t}"]}], "num": 40047}