{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4d1b086b660df6684d4917ea137c49ca", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "058425fa0edd4d92b84deb986f1947ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "f5476e05b46ec9b70e1bb26b071f29e4868379b5", "commitAfterChange": "3907c5580e4b5fc2088d110e0990a0137b3282f9", "methodNumberBeforeChange": 74, "methodNumberAfterChange": 74, "signatureBeforeChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": "  \tprotected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\t\t\tTypeBinding[] params = method.tiebreakMethod().parameters;", "-\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters)) {", "+\t\t\t\t\tif (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {", "-\t\t\t\t\t\t\tint paramLength = method.parameters.length;", "-\t\t\t\t\t\t\tif (paramLength == method2.parameters.length && paramLength == argumentTypes.length + 1) {", "-\t\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) method2.parameters[paramLength - 1]).elementsType();", "-\t\t\t\t\t\t\t\tif (method.parameters[paramLength - 1].isCompatibleWith(elementsType))", "-\t\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// check the non-vararg parameters", "+\t\t\t\t\t\t\tint paramLength = params.length;", "+\t\t\t\t\t\t\tTypeBinding[] params2 = method2.tiebreakMethod().parameters;", "+\t\t\t\t\t\t\tif (paramLength != params2.length)", "+\t\t\t\t\t\t\t\tcontinue nextVisible;", "+\t\t\t\t\t\t\tfor (int p = paramLength - 2; p >= 0; p--)", "+\t\t\t\t\t\t\t\tif (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))", "+\t\t\t\t\t\t\t\t\tcontinue nextVisible;", "+", "+\t\t\t\t\t\t\tTypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();", "+\t\t\t\t\t\t\tif (params[paramLength - 1].isCompatibleWith(elementsType))", "+\t\t\t\t\t\t\t\tcontinue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d64f859a91f3a060c9d743de73b12b4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "bacbe6f6e994ffc49a94960691c76bff97cb04d5", "commitAfterChange": "719705b20dc5e72fab3b2b50b669f9dfc58049aa", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "signatureAfterChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["-\t\t/* 15.12.2.5 s is more specific than t iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "-\t\t   but have been left in for completeness/documentation sakes. These should be cheap anyways. ", "-\t\t*/", "-\t\t// Both t and s are functional interface types ... ", "+\t\t// 15.12.2.5 ", "+\t\t", "+\t\tif (TypeBinding.equalsEquals(s,  t))", "+\t\t\treturn true;", "+\t\t", "+\t\tif (argumentsTypeElided() || t.findSuperTypeOriginatingFrom(s) != null)", "+\t\t\treturn false;", "+\t\t", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tTypeBinding r1 = sSam.returnType;", "+\t\tTypeBinding r2 = tSam.returnType;", "-\t\t// t should neither be a subinterface nor a superinterface of s", "-\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\t\treturn false;", "-", "-\t\t// If the lambda expression's parameters have inferred types, then the descriptor parameter types of t are the same as the descriptor parameter types of s.", "-\t\tif (argumentsTypeElided()) {", "-\t\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\t\t\treturn false;", "-\t\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "-\t\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\t\t\t\treturn false;", "-\t\t\t}", "-\t\t}", "-\t\t", "-\t\t// either the descriptor return type of s is void or ...", "-\t\tif (tSam.returnType.id == TypeIds.T_void)", "+\t\tif (r2.id == TypeIds.T_void)", "-\t\t/* ... or for all result expressions in the lambda body (or for the body itself if the body is an expression), ", "-           the descriptor return type of the capture of T is more specific than the descriptor return type of S.", "-\t\t*/", "+\t\tif (r1.id == TypeIds.T_void)", "+\t\t\treturn false;", "+\t\t", "+\t\tif (r1.findSuperTypeOriginatingFrom(r2) != null)", "+\t\t\treturn true;", "+\t\t", "-\t\tif (returnExpressionsLength == 0)", "-\t\t\treturn true; // as good as or as bad as false.", "-\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\t// r1 is a primitive type, r2 is a reference type, and each result expression is a standalone expression (15.2) of a primitive type", "+\t\tif (r1.isBaseType() && !r2.isBaseType()) {", "+\t\t\tfor (int i = 0; i < returnExpressionsLength; i++) {", "+\t\t\t\tif (returnExpressions[i].isPolyExpression() || !returnExpressions[i].resolvedType.isBaseType())", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\treturn true;", "+\t\t}", "+\t\tif (returnExpressionsLength == 0)", "+\t\t\treturn false;", "+\t\t", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ab71f92d4f24ca808f31818274846082", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/State.java", "commitBeforeChange": "4aa9bc6aa2cb666fb0721f9b95f7c7e969829a0c", "commitAfterChange": "39745a85705361f7e5b8ca890f80a07d85799adc", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r \r void copyFrom(State lastState)", "signatureAfterChange": "\r \r void copyFrom(State lastState)", "diff": ["-\t\tthis.additionalTypeNames = (HashtableOfObject) lastState.additionalTypeNames.clone();\r", "-\t\tthis.additionalTypeNames = lastState.additionalTypeNames;\r", "-\t\tthis.references = lastState.references;\r", "+\t\tthis.references = new HashtableOfObject(31);\r", "+\r", "+\t\tchar[][] keyTable = lastState.references.keyTable;\r", "+\t\tObject[] valueTable = lastState.references.valueTable;\r", "+\t\tfor (int i = 0, l = keyTable.length; i < l; i++)\r", "+\t\t\tif (keyTable[i] != null)\r", "+\t\t\t\tthis.references.put(keyTable[i], valueTable[i]);\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b35c23781e96031a681e219dc8e0c987", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java", "commitBeforeChange": "3aabc067e22084d59ef0ea59b0d58e1085dede4c", "commitAfterChange": "b7295bb19a68269f09e5fdceeecf4f4c701e7063", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "signatureAfterChange": " \t \tpublic boolean sIsMoreSpecific(TypeBinding s, TypeBinding t)", "diff": ["+\t", "-\t\t/* 15.12.2.5 t is more specific than s iff ... Some of the checks here are redundant by the very fact of control reaching here, ", "-\t\t   but have been left in for completeness/documentation sakes. These should be cheap anyways. ", "-\t\t*/", "-\t\t// Both t and s are functional interface types ... ", "+\t\tif (TypeBinding.equalsEquals(s, t))", "+\t\t\treturn true;", "+\t\t", "+\t\tif (this.exactMethodBinding == null)", "+\t\t\treturn false;", "+\t\t", "+\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "+\t\tTypeBinding r1 = sSam.returnType;", "+\t\t", "+\t\tTypeBinding r2 = tSam.returnType;", "-\t\t// t should neither be a subinterface nor a superinterface of s", "-\t\tif (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)", "-\t\t\treturn false;", "-", "-\t\t// The descriptor parameter types of t are the same as the descriptor parameter types of s.", "-\t\tif (sSam.parameters.length != tSam.parameters.length)", "-\t\t\treturn false;", "-\t\tfor (int i = 0, length = sSam.parameters.length; i < length; i++) {", "-\t\t\tif (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))", "-\t\t\t\treturn false;", "-\t\t}", "-\t\t", "-\t\t// Either the descriptor return type of s is void or ...", "-\t\tif (tSam.returnType.id == TypeIds.T_void)", "+\t\tif (r2.id == TypeIds.T_void)", "+\t\tif (r1.id == TypeIds.T_void)", "+\t\t\treturn false;", "-\t\treturn true;", "+\t\tif (r1.findSuperTypeOriginatingFrom(r2) != null)", "+\t\t\treturn true;", "+\t\tif (r2.findSuperTypeOriginatingFrom(r1) != null)", "+\t\t\treturn false;", "-\t\t/* ... or the descriptor return type of the capture of T is more specific than the descriptor return type of S for ", "-\t\t   an invocation expression of the same form as the method reference..", "-\t\t*/", "-\t//\tExpression resultExpression = (Expression) this.resultExpressions.get(s); // should be same as for s", "-\t\t", "-//\t\ts = s.capture(this.enclosingScope, this.sourceEnd);", "-//\t\tsSam = s.getSingleAbstractMethod(this.enclosingScope);", "-//\t\treturn resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType);", "+\t\treturn r1.isBaseType() != r2.isBaseType() && r1.isBaseType() == this.exactMethodBinding.returnType.isBaseType();"]}], "num": 57659}