{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "71702a103df475ba5a9483066c117f1f", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "60782119c3f7a1365c03cba5ff585d04", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "673b7eda95cd26449992e862f0c63f2c612903a0", "commitAfterChange": "b04602938404af4f8569a399fb36a5018768a262", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": "\r \r \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "\r public TypeBinding resolveType(BlockScope scope)", "diff": ["+}\r", "+public TypeBinding resolveType(BlockScope scope) {\r", "+\t// Answer the signature type of the field.\r", "+\t// constants are propaged when the field is final\r", "+\t// and initialized with a (compile time) constant \r", "+\r", "+\t// regular receiver reference \r", "+\tthis.receiverType = receiver.resolveType(scope);\r", "+\tif (this.receiverType == null){\r", "+\t\tconstant = NotAConstant;\r", "+\t\treturn null;\r", "+\t}\r", "+\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "+\tbinding = scope.getField(this.receiverType, token, this);\r", "+\tif (!binding.isValidBinding()) {\r", "+\t\tconstant = NotAConstant;\r", "+\t\tscope.problemReporter().invalidField(this, this.receiverType);\r", "+\t\treturn null;\r", "+\tif (isFieldUseDeprecated(binding, scope))\r", "+\t\tscope.problemReporter().deprecatedField(binding, this);\r", "+\t// check for this.x in static is done in the resolution of the receiver\r", "+\tconstant = FieldReference.getConstantFor(binding, receiver == ThisReference.ThisImplicit, this, 0);\r", "+\tif (!receiver.isThis())\r", "+\t\tconstant = NotAConstant;\r", "+\r", "+\t// if the binding declaring class is not visible, need special action\r", "+\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "+\tif (binding.declaringClass != this.receiverType\r", "+\t\t&& binding.declaringClass != null // array.length\r", "+\t\t&& binding.constant == NotAConstant\r", "+\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "+\t\t\tbinding = new FieldBinding(binding, (ReferenceBinding) this.receiverType);\r", "+\treturn binding.type;\r", "+}\r", "-\r", "-\tpublic TypeBinding resolveType(BlockScope scope) {\r", "-\t\t// Answer the signature type of the field.\r", "-\t\t// constants are propaged when the field is final\r", "-\t\t// and initialized with a (compile time) constant \r", "-\r", "-\t\t// regular receiver reference \r", "-\t\tTypeBinding receiverType = receiver.resolveType(scope);\r", "-\t\tif (receiverType == null) {\r", "-\t\t\tconstant = NotAConstant;\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\t\t// the case receiverType.isArrayType and token = 'length' is handled by the scope API\r", "-\t\tbinding = scope.getField(receiverType, token, this);\r", "-\t\tif (!binding.isValidBinding()) {\r", "-\t\t\tconstant = NotAConstant;\r", "-\t\t\tscope.problemReporter().invalidField(this, receiverType);\r", "-\t\t\treturn null;\r", "-\t\t}\r", "-\r", "-\t\tif (isFieldUseDeprecated(binding, scope))\r", "-\t\t\tscope.problemReporter().deprecatedField(binding, this);\r", "-\r", "-\t\t// check for this.x in static is done in the resolution of the receiver\r", "-\t\tconstant =\r", "-\t\t\tFieldReference.getConstantFor(\r", "-\t\t\t\tbinding,\r", "-\t\t\t\treceiver == ThisReference.ThisImplicit,\r", "-\t\t\t\tthis,\r", "-\t\t\t\t0);\r", "-\t\tif (!receiver.isThis())\r", "-\t\t\tconstant = NotAConstant;\r", "-\r", "-\t\t// if the binding declaring class is not visible, need special action\r", "-\t\t// for runtime compatibility on 1.2 VMs : change the declaring class of the binding\r", "-\t\tif (binding.declaringClass != receiverType\r", "-\t\t\t&& binding.declaringClass != null // array.length\r", "-\t\t\t&& binding.constant == NotAConstant\r", "-\t\t\t&& !binding.declaringClass.canBeSeenBy(scope))\r", "-\t\t\tbinding = new FieldBinding(binding, (ReferenceBinding) receiverType);\r", "-\t\treturn binding.type;\r", "-\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c245912fe8aa035ab608133cd5330d6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java", "commitBeforeChange": "4e0e44e12d531b0f9a299237d2e668d6176cd234", "commitAfterChange": "2156fedddc9b679afe1f45ef1e9d318ac4df4d9a", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tTypeBinding[] argumentTypes = Binding.NO_PARAMETERS;", "+\tthis.argumentTypes = Binding.NO_PARAMETERS;", "-\t\targumentTypes = new TypeBinding[length];", "+\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\t\targumentTypes[a] = this.arguments[a].resolveType(scope);", "+\t\t\tthis.argumentTypes[a] = this.arguments[a].resolveType(scope);", "-\t\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);", "-\t\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);"]}], "num": 44208}