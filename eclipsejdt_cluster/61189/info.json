{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c29e5e71c182239022bfe065806fdbb1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "72f8251232f144c2bd321d09d55abe56", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 82, "methodNumberAfterChange": 82, "signatureBeforeChange": "  \tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope)", "signatureAfterChange": "  \tprivate void computeExpectedTypes(ASTNode parent, ASTNode node, Scope scope)", "diff": ["-\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "-\t\t\tint length = ref.typeArguments == null ? 0 : ref.typeArguments.length;", "-\t\t\tif(typeVariables != null && typeVariables.length >= length) {", "-\t\t\t\tint index = length - 1;", "-\t\t\t\twhile(index > -1 && ref.typeArguments[index] != node) index--;", "-", "-\t\t\t\tTypeBinding bound = typeVariables[index].firstBound;", "-\t\t\t\taddExpectedType(bound == null ? scope.getJavaLangObject() : bound, scope);", "+\t\t\tTypeBinding expected = null;", "+\t\t\tif (this.parser.enclosingNode instanceof AbstractVariableDeclaration ||", "+\t\t\t\t\tthis.parser.enclosingNode instanceof ReturnStatement) {", "+\t\t\t\t// completing inside the diamond", "+\t\t\t\tif (this.parser.enclosingNode instanceof AbstractVariableDeclaration) {", "+\t\t\t\t\tAbstractVariableDeclaration abstractVariableDeclaration = (AbstractVariableDeclaration) this.parser.enclosingNode;", "+\t\t\t\t\texpected = abstractVariableDeclaration.initialization != null ? abstractVariableDeclaration.initialization.expectedType() : null;\t\t\t\t\t", "+\t\t\t\t} else {", "+\t\t\t\t\tReturnStatement returnStatement = (ReturnStatement) this.parser.enclosingNode;", "+\t\t\t\t\tif (returnStatement.expression != null) {", "+\t\t\t\t\t\texpected = returnStatement.expression.expectedType();", "+\t\t\t\t\t}", "+\t\t\t\t}\t", "+\t\t\t\taddExpectedType(expected, scope);", "+\t\t\t} else {", "+\t\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "+\t\t\t\tint length = ref.typeArguments == null ? 0 : ref.typeArguments.length;", "+\t\t\t\tif(typeVariables != null && typeVariables.length >= length) {", "+\t\t\t\t\tint index = length - 1;", "+\t\t\t\t\twhile(index > -1 && ref.typeArguments[index] != node) index--;", "+\t", "+\t\t\t\t\tTypeBinding bound = typeVariables[index].firstBound;", "+\t\t\t\t\taddExpectedType(bound == null ? scope.getJavaLangObject() : bound, scope);", "+\t\t\t\t}", "-\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "-\t\t\tif(typeVariables != null) {", "-\t\t\t\tint iLength = arguments == null ? 0 : arguments.length;", "-\t\t\t\tdone: for (int i = 0; i < iLength; i++) {", "-\t\t\t\t\tint jLength = arguments[i] == null ? 0 : arguments[i].length;", "-\t\t\t\t\tfor (int j = 0; j < jLength; j++) {", "-\t\t\t\t\t\tif(arguments[i][j] == node && typeVariables.length > j) {", "-\t\t\t\t\t\t\tTypeBinding bound = typeVariables[j].firstBound;", "-\t\t\t\t\t\t\taddExpectedType(bound == null ? scope.getJavaLangObject() : bound, scope);", "-\t\t\t\t\t\t\tbreak done;", "+\t\t\tTypeBinding expected = null;", "+\t\t\tif (this.parser.enclosingNode instanceof AbstractVariableDeclaration ||", "+\t\t\t\t\tthis.parser.enclosingNode instanceof ReturnStatement) {", "+\t\t\t\t// completing inside the diamond", "+\t\t\t\tif (this.parser.enclosingNode instanceof AbstractVariableDeclaration) {", "+\t\t\t\t\tAbstractVariableDeclaration abstractVariableDeclaration = (AbstractVariableDeclaration) this.parser.enclosingNode;", "+\t\t\t\t\texpected = abstractVariableDeclaration.initialization != null ? abstractVariableDeclaration.initialization.expectedType() : null;", "+\t\t\t\t} else {", "+\t\t\t\t\tReturnStatement returnStatement = (ReturnStatement) this.parser.enclosingNode;", "+\t\t\t\t\tif (returnStatement.expression != null) {", "+\t\t\t\t\t\texpected = returnStatement.expression.expectedType();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\taddExpectedType(expected, scope);", "+\t\t\t} else {", "+\t\t\t\tTypeVariableBinding[] typeVariables = ((ReferenceBinding)ref.resolvedType).typeVariables();", "+\t\t\t\tif(typeVariables != null) {", "+\t\t\t\t\tint iLength = arguments == null ? 0 : arguments.length;", "+\t\t\t\t\tdone: for (int i = 0; i < iLength; i++) {", "+\t\t\t\t\t\tint jLength = arguments[i] == null ? 0 : arguments[i].length;", "+\t\t\t\t\t\tfor (int j = 0; j < jLength; j++) {", "+\t\t\t\t\t\t\tif(arguments[i][j] == node && typeVariables.length > j) {", "+\t\t\t\t\t\t\t\tTypeBinding bound = typeVariables[j].firstBound;", "+\t\t\t\t\t\t\t\taddExpectedType(bound == null ? scope.getJavaLangObject() : bound, scope);", "+\t\t\t\t\t\t\t\tbreak done;", "+\t\t\t\t\t\t\t}", "-\t\t\t\tReferenceBinding[] bindings = thrownExceptionFinder.find((TryStatement) parent, (BlockScope)scope);", "+\t\t\t\tthrownExceptionFinder.processThrownExceptions((TryStatement) parent, (BlockScope)scope);", "+\t\t\t\tReferenceBinding[] bindings = thrownExceptionFinder.getThrownUncaughtExceptions();", "+\t\t\t\tReferenceBinding[] alreadyCaughtExceptions = thrownExceptionFinder.getAlreadyCaughtExceptions();", "+\t\t\t\tReferenceBinding[] discouragedExceptions = thrownExceptionFinder.getDiscouragedExceptions();", "+\t\t\t\t}", "+\t\t\t\tif (alreadyCaughtExceptions != null && alreadyCaughtExceptions.length > 0) {", "+\t\t\t\t\tfor (int i = 0; i < alreadyCaughtExceptions.length; i++) {", "+\t\t\t\t\t\taddForbiddenBindings(alreadyCaughtExceptions[i]);", "+\t\t\t\t\t\tthis.knownTypes.put(CharOperation.concat(alreadyCaughtExceptions[i].qualifiedPackageName(), alreadyCaughtExceptions[i].qualifiedSourceName(), '.'), KNOWN_TYPE_WITH_KNOWN_CONSTRUCTORS);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (discouragedExceptions != null && discouragedExceptions.length > 0) {", "+\t\t\t\t\tfor (int i = 0; i < discouragedExceptions.length; i++) {", "+\t\t\t\t\t\taddUninterestingBindings(discouragedExceptions[i]);", "+\t\t\t\t\t\t// do not insert into known types. We do need these types to come from", "+\t\t\t\t\t\t// searchAllTypes(..) albeit with lower relevance", "+\t\t\t\t\t}", "+\t\t\t\tif (this.assistNodeIsInsideCase &&", "+\t\t\t\t\t\tswitchStatement.expression.resolvedType.id == TypeIds.T_JavaLangString &&", "+\t\t\t\t\t\tthis.compilerOptions.complianceLevel >= ClassFileConstants.JDK1_7) {", "+\t\t\t\t\t// set the field to true even though the expected types array will contain String as", "+\t\t\t\t\t// expected type to avoid traversing the array in every case later on.", "+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=343476", "+\t\t\t\t\tthis.assistNodeIsString = true;", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fe702d9e1f81101e60136f97ad23a949", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java", "commitBeforeChange": "31c45831879fb9d166146101d8c06704e7b03918", "commitAfterChange": "4cbee9c4edfca3748d4063d8a7e10ad2054f1b8a", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public void checkComment()", "signatureAfterChange": " public void checkComment()", "diff": ["-\t\tint length = paramReferences == null ? 0 : paramReferences.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tthis.patternLocator.match(paramReferences[i], this.nodeSet);", "+\t\tif (paramReferences != null) {", "+\t\t\tfor (int i=0, length=paramReferences.length; i < length; i++) {", "+\t\t\t\tthis.patternLocator.match(paramReferences[i], this.nodeSet);", "+\t\t\t}", "-\t\tlength = paramTypeParameters == null ? 0 : paramTypeParameters.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tthis.patternLocator.match(paramTypeParameters[i], this.nodeSet);", "+\t\tif (paramTypeParameters != null) {", "+\t\t\tfor (int i=0, length=paramTypeParameters.length; i < length; i++) {", "+\t\t\t\tthis.patternLocator.match(paramTypeParameters[i], this.nodeSet);", "+\t\t\t}", "-\t\tlength = thrownExceptions == null ? 0 : thrownExceptions.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tthis.patternLocator.match(thrownExceptions[i], this.nodeSet);", "+\t\tif (thrownExceptions != null) {", "+\t\t\tfor (int i=0, length=thrownExceptions.length; i < length; i++) {", "+\t\t\t\tthis.patternLocator.match(thrownExceptions[i], this.nodeSet);", "+\t\t\t}", "-\t\tlength = references == null ? 0 : references.length;", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression reference = references[i];", "-\t\t\tif (reference instanceof TypeReference) {", "-\t\t\t\tTypeReference typeRef = (TypeReference) reference;", "-\t\t\t\tthis.patternLocator.match(typeRef, this.nodeSet);", "-\t\t\t} else if (reference instanceof JavadocFieldReference) {", "-\t\t\t\tJavadocFieldReference fieldRef = (JavadocFieldReference) reference;", "-\t\t\t\tthis.patternLocator.match(fieldRef, this.nodeSet);", "-\t\t\t\tif (fieldRef.receiver instanceof TypeReference && !fieldRef.receiver.isThis()) {", "-\t\t\t\t\tTypeReference typeRef = (TypeReference) fieldRef.receiver;", "+\t\tif (references != null) {", "+\t\t\tfor (int i=0, length=references.length; i < length; i++) {", "+\t\t\t\tExpression reference = references[i];", "+\t\t\t\tif (reference instanceof TypeReference) {", "+\t\t\t\t\tTypeReference typeRef = (TypeReference) reference;", "-\t\t\t\t}", "-\t\t\t} else if (reference instanceof JavadocMessageSend) {", "-\t\t\t\tJavadocMessageSend messageSend = (JavadocMessageSend) reference;", "-\t\t\t\tthis.patternLocator.match(messageSend, this.nodeSet);", "-\t\t\t\tif (messageSend.receiver instanceof TypeReference && !messageSend.receiver.isThis()) {", "-\t\t\t\t\tTypeReference typeRef = (TypeReference) messageSend.receiver;", "-\t\t\t\t\tthis.patternLocator.match(typeRef, this.nodeSet);", "-\t\t\t\t}", "-\t\t\t\tif (messageSend.arguments != null) {", "-\t\t\t\t\tfor (int a=0,al=messageSend.arguments.length; a<al; a++) {", "-\t\t\t\t\t\tJavadocArgumentExpression argument = (JavadocArgumentExpression) messageSend.arguments[a];", "-\t\t\t\t\t\tif (argument.argument != null && argument.argument.type != null) {", "-\t\t\t\t\t\t\tthis.patternLocator.match(argument.argument.type, this.nodeSet);", "+\t\t\t\t} else if (reference instanceof JavadocFieldReference) {", "+\t\t\t\t\tJavadocFieldReference fieldRef = (JavadocFieldReference) reference;", "+\t\t\t\t\tthis.patternLocator.match(fieldRef, this.nodeSet);", "+\t\t\t\t\tif (fieldRef.receiver instanceof TypeReference && !fieldRef.receiver.isThis()) {", "+\t\t\t\t\t\tTypeReference typeRef = (TypeReference) fieldRef.receiver;", "+\t\t\t\t\t\tthis.patternLocator.match(typeRef, this.nodeSet);", "+\t\t\t\t\t}", "+\t\t\t\t} else if (reference instanceof JavadocMessageSend) {", "+\t\t\t\t\tJavadocMessageSend messageSend = (JavadocMessageSend) reference;", "+\t\t\t\t\tthis.patternLocator.match(messageSend, this.nodeSet);", "+\t\t\t\t\tif (messageSend.receiver instanceof TypeReference && !messageSend.receiver.isThis()) {", "+\t\t\t\t\t\tTypeReference typeRef = (TypeReference) messageSend.receiver;", "+\t\t\t\t\t\tthis.patternLocator.match(typeRef, this.nodeSet);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (messageSend.arguments != null) {", "+\t\t\t\t\t\tfor (int a=0,al=messageSend.arguments.length; a<al; a++) {", "+\t\t\t\t\t\t\tJavadocArgumentExpression argument = (JavadocArgumentExpression) messageSend.arguments[a];", "+\t\t\t\t\t\t\tif (argument.argument != null && argument.argument.type != null) {", "+\t\t\t\t\t\t\t\tthis.patternLocator.match(argument.argument.type, this.nodeSet);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else if (reference instanceof JavadocAllocationExpression) {", "-\t\t\t\tJavadocAllocationExpression constructor = (JavadocAllocationExpression) reference;", "-\t\t\t\tthis.patternLocator.match(constructor, this.nodeSet);", "-\t\t\t\tif (constructor.type != null && !constructor.type.isThis()) {", "-\t\t\t\t\tthis.patternLocator.match(constructor.type, this.nodeSet);", "-\t\t\t\t}", "-\t\t\t\tif (constructor.arguments != null) {", "-\t\t\t\t\tfor (int a=0,al=constructor.arguments.length; a<al; a++) {", "-\t\t\t\t\t\tthis.patternLocator.match(constructor.arguments[a], this.nodeSet);", "-\t\t\t\t\t\tJavadocArgumentExpression argument = (JavadocArgumentExpression) constructor.arguments[a];", "-\t\t\t\t\t\tif (argument.argument != null && argument.argument.type != null) {", "-\t\t\t\t\t\t\tthis.patternLocator.match(argument.argument.type, this.nodeSet);", "+\t\t\t\t} else if (reference instanceof JavadocAllocationExpression) {", "+\t\t\t\t\tJavadocAllocationExpression constructor = (JavadocAllocationExpression) reference;", "+\t\t\t\t\tthis.patternLocator.match(constructor, this.nodeSet);", "+\t\t\t\t\tif (constructor.type != null && !constructor.type.isThis()) {", "+\t\t\t\t\t\tthis.patternLocator.match(constructor.type, this.nodeSet);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (constructor.arguments != null) {", "+\t\t\t\t\t\tfor (int a=0,al=constructor.arguments.length; a<al; a++) {", "+\t\t\t\t\t\t\tthis.patternLocator.match(constructor.arguments[a], this.nodeSet);", "+\t\t\t\t\t\t\tJavadocArgumentExpression argument = (JavadocArgumentExpression) constructor.arguments[a];", "+\t\t\t\t\t\t\tif (argument.argument != null && argument.argument.type != null) {", "+\t\t\t\t\t\t\t\tthis.patternLocator.match(argument.argument.type, this.nodeSet);", "+\t\t\t\t\t\t\t}"]}], "num": 61189}