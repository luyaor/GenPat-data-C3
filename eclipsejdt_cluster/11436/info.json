{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "d8d4df07ab1df3b5f5f2d2c2467a2528", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9127ae059a53ff5fad78769bc48fd310", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/CharOperation.java", "commitBeforeChange": "e90133bc2bb6238e9bed10f9407b68636afe0cf9", "commitAfterChange": "aa3e581727ecbd82f62d5775da80f0c298f9ec87", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "signatureAfterChange": " public static final boolean pathMatch(char[] pattern, char[] filepath, boolean isCaseSensitive, char pathSeparator)", "diff": ["-public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator) {", "+public static final boolean pathMatch(char[] pattern, char[] filepath, boolean isCaseSensitive, char pathSeparator) {", "-\tif (path == null) return false; // null name cannot match", "+\tif (filepath == null) return false; // null name cannot match", "-\tint iPattern = 0, patternLength = pattern.length;", "-\tint patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);", "-\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t// offsets inside pattern", "+\tint pSegmentStart = 0, pLength = pattern.length;", "+\tint pSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);", "+\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\tint iPath = 0, pathLength = path.length;", "-\tint pathSegmentEnd = CharOperation.indexOf(pathSeparator, path);", "-\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "+\t// offsets inside filepath", "+\tint fSegmentStart = 0, fLength = filepath.length;", "+\tint fSegmentEnd = CharOperation.indexOf(pathSeparator, filepath);", "+\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "-\tboolean freeSuffixDoubleStar = pattern[patternLength-1] == pathSeparator;", "+\tboolean freeSuffixDoubleStar = pattern[pLength-1] == pathSeparator;", "-\twhile (iPattern < patternLength", "+\twhile (pSegmentStart < pLength", "-\t\t\t\t&& !(patternSegmentEnd == iPattern+2", "-\t\t\t\t\t&& pattern[iPattern] == '*' ", "-\t\t\t\t\t&& pattern[iPattern+1] == '*')) {", "+\t\t\t\t&& !(pSegmentEnd == pSegmentStart+2", "+\t\t\t\t\t&& pattern[pSegmentStart] == '*' ", "+\t\t\t\t\t&& pattern[pSegmentStart+1] == '*')) {", "-\t\tif (iPath >= pathLength) return false;", "-\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+\t\tif (fSegmentStart >= fLength) return false;", "+\t\tif (!CharOperation.match(pattern, pSegmentStart, pSegmentEnd, filepath, fSegmentStart, fSegmentEnd, isCaseSensitive)) {", "-\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "-\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\tpSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentEnd+1); // skip separator", "+\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "-\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "+\t\tfSegmentEnd = CharOperation.indexOf(pathSeparator, filepath, fSegmentStart = fSegmentEnd+1); // skip separator", "+\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "-\tint segmentStart;", "-\tif (patternSegmentEnd == iPattern+2", "-\t\t\t\t&& pattern[iPattern] == '*' ", "-\t\t\t\t&& pattern[iPattern+1] == '*'){", "-\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "-\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "-\t\tsegmentStart = iPattern;", "+\tint pSegmentRestart;", "+\tif (pSegmentEnd == pSegmentStart+2", "+\t\t\t\t&& pattern[pSegmentStart] == '*' ", "+\t\t\t\t&& pattern[pSegmentStart+1] == '*'){", "+\t\tpSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentEnd+1); // skip separator", "+\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "+\t\tpSegmentRestart = pSegmentStart;", "-\t\tsegmentStart = 0; // force iPath check", "+\t\tpSegmentRestart = 0; // force fSegmentStart check", "-\tint prefixStart = iPath;", "-\tcheckSegment: while (iPath < pathLength && iPattern < patternLength){", "+\tint fSegmentRestart = fSegmentStart;", "+\tcheckSegment: while (fSegmentStart < fLength && pSegmentStart < pLength){", "-\t\tif (patternSegmentEnd == iPattern+2", "-\t\t\t\t\t&& pattern[iPattern] == '*' ", "-\t\t\t\t\t&& pattern[iPattern+1] == '*') {", "-\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "-\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "-\t\t\tsegmentStart = iPattern;", "-\t\t\tprefixStart = iPath;", "+\t\tif (pSegmentEnd == pSegmentStart+2", "+\t\t\t\t\t&& pattern[pSegmentStart] == '*' ", "+\t\t\t\t\t&& pattern[pSegmentStart+1] == '*') {", "+\t\t\tpSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentEnd+1); // skip separator", "+\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "+\t\t\tpSegmentRestart = pSegmentStart;", "+\t\t\tfSegmentRestart = fSegmentStart;", "-\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+\t\tif (!CharOperation.match(pattern, pSegmentStart, pSegmentEnd, filepath, fSegmentStart, fSegmentEnd, isCaseSensitive)) {", "-\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = segmentStart);", "-\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\t\tpSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentRestart);", "+\t\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\t\t\tprefixStart = CharOperation.indexOf(pathSeparator, path, prefixStart+1); // skip separator", "-\t\t\tif (prefixStart < 0) {", "-\t\t\t\tprefixStart = pathLength;", "+\t\t\tfSegmentRestart = CharOperation.indexOf(pathSeparator, filepath, fSegmentRestart+1); // skip separator", "+\t\t\tif (fSegmentRestart < 0) {", "+\t\t\t\tfSegmentRestart = fLength;", "-\t\t\t\tprefixStart++;", "+\t\t\t\tfSegmentRestart++;", "-\t\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = prefixStart);", "-\t\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "+\t\t\tfSegmentEnd = CharOperation.indexOf(pathSeparator, filepath, fSegmentStart = fSegmentRestart);", "+\t\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "-\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "-\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\tpSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, pSegmentStart = pSegmentEnd+1); // skip separator", "+\t\tif (pSegmentEnd < 0) pSegmentEnd = pLength;", "-\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "-\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "+\t\tfSegmentEnd = CharOperation.indexOf(pathSeparator, filepath, fSegmentStart = fSegmentEnd+1); // skip separator", "+\t\tif (fSegmentEnd < 0) fSegmentEnd = fLength;", "-\treturn (segmentStart >= patternSegmentEnd)", "-\t\t\t\t|| (iPath >= pathLength && iPattern >= patternLength)\t", "-\t\t\t\t|| (iPattern == patternLength - 2 && pattern[iPattern] == '*' && pattern[iPattern+1] == '*')", "-\t\t\t\t|| (iPattern == patternLength &&  freeSuffixDoubleStar); ", "+\treturn (pSegmentRestart >= pSegmentEnd)", "+\t\t\t\t|| (fSegmentStart >= fLength && pSegmentStart >= pLength)\t", "+\t\t\t\t|| (pSegmentStart == pLength - 2 && pattern[pSegmentStart] == '*' && pattern[pSegmentStart+1] == '*')", "+\t\t\t\t|| (pSegmentStart == pLength &&  freeSuffixDoubleStar); "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c170a221543c6e0856e705f930b10e0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/CharOperation.java", "commitBeforeChange": "b8a20093bfb53c812e4e5b346e3aa791a4136ca4", "commitAfterChange": "44731467d9fdac9a7d80b255708d1b40800e1d02", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "signatureAfterChange": " public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator)", "diff": ["-\t", "-\tchar[][] patternSegments = splitOn(pathSeparator, pattern);", "-\tchar[][] pathSegments = splitOn(pathSeparator, path);", "-\tchar[] patternSegment = null;", "-\t", "-\tint iPatternSegment = 0, patternSegmentLength = patternSegments.length;", "-\tint iPathSegment = 0, pathSegmentLength = pathSegments.length;", "-\t", "-\tfinal char[] doubleStar = new char[] { '*', '*' };", "-\tfor (int i = 0; i < patternSegmentLength; i++) {", "-\t\tif (patternSegments[i].length == 2 && patternSegments[i][0] == '*' && patternSegments[i][1] == '*') {", "-\t\t\tpatternSegments[i] = doubleStar;", "-\t\t}", "-\t}", "+", "+\tint iPattern = 0, patternLength = pattern.length;", "+\tint patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);", "+\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+", "+\tint iPath = 0, pathLength = path.length;", "+\tint pathSegmentEnd = CharOperation.indexOf(pathSeparator, path);", "+\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\twhile (iPatternSegment < patternSegmentLength && (patternSegment = patternSegments[iPatternSegment]) != doubleStar) {", "-\t\tif (iPathSegment == pathSegmentLength) return false;", "-\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "+\twhile (iPattern < patternLength", "+\t\t\t\t&& !(patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*')) {", "+\t\t\t\t\t", "+\t\tif (iPath >= pathLength) return false;", "+\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+", "+\t\t// jump to next segment\t\t", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "-\t\tiPatternSegment++;", "-\t\tiPathSegment++;", "+\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "+\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\tif (patternSegment == doubleStar){", "-\t\tsegmentStart = ++iPatternSegment; // skip star", "+\tif (patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*'){", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\tsegmentStart = iPattern;", "-\t\tsegmentStart = 0; // force iName check", "+\t\tsegmentStart = 0; // force iPath check", "-\tint prefixStart = iPathSegment;", "-\tcheckSegment: while (iPathSegment < pathSegmentLength && iPatternSegment < patternSegmentLength){", "+\tint prefixStart = iPath;", "+\tcheckSegment: while (iPath < pathLength && iPattern < patternLength){", "-\t\tif ((patternSegment = patternSegments[iPatternSegment]) == doubleStar){", "-\t\t\tsegmentStart = ++iPatternSegment; // skip start", "-\t\t\tprefixStart = iPathSegment;", "+\t\tif (patternSegmentEnd == iPattern+2", "+\t\t\t\t\t&& pattern[iPattern] == '*' ", "+\t\t\t\t\t&& pattern[iPattern+1] == '*') {", "+\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\t\tsegmentStart = iPattern;", "+\t\t\tprefixStart = iPath;", "-\t\tif (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {", "-\t\t\tiPatternSegment = segmentStart; // mismatch - restart current segment", "-\t\t\tiPathSegment = ++prefixStart;", "+\t\tif (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {", "+\t\t\t// mismatch - restart current segment", "+\t\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = segmentStart);", "+\t\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+", "+\t\t\tprefixStart = CharOperation.indexOf(pathSeparator, path, prefixStart+1); // skip separator", "+\t\t\tif (prefixStart < 0) {", "+\t\t\t\tprefixStart = pathLength;", "+\t\t\t} else {", "+\t\t\t\tprefixStart++;", "+\t\t\t}", "+\t\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = prefixStart);", "+\t\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\t\tiPathSegment++;", "-\t\tiPatternSegment++;", "+\t\t// jump to next segment\t\t", "+\t\tpatternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator", "+\t\tif (patternSegmentEnd < 0) patternSegmentEnd = patternLength;", "+\t\t", "+\t\tpathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator", "+\t\tif (pathSegmentEnd < 0) pathSegmentEnd = pathLength;", "-\treturn (segmentStart == patternSegmentLength)", "-\t\t\t|| (iPathSegment == pathSegmentLength && iPatternSegment == patternSegmentLength)\t", "-\t\t\t|| (iPatternSegment == patternSegmentLength - 1 && patternSegments[iPatternSegment] == doubleStar); ", "+\treturn (segmentStart >= patternSegmentEnd)", "+\t\t\t|| (iPath >= pathLength && iPattern >= patternLength)\t", "+\t\t\t|| (iPattern == patternLength - 2 && pattern[iPattern] == '*' && pattern[iPattern+1] == '*'); "]}], "num": 11436}