{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "4dddad8fbc7a6d9bc2df486ae52504b0", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4dbb69c1f3830d0740c375394ebddaa8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/CharOperation.java", "commitBeforeChange": "0f549220f498cda7c86a65324f594a6b8e8c2616", "commitAfterChange": "17fcd420e0756889bcaffeff4cf983b2cff84a3e", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd)", "diff": ["+", "-\tint iPattern = patternStart+1;", "-\tint iName = nameStart+1;", "-\tnextPatternChar: while (iPattern < patternEnd) {", "-\t\t// check patternChar, keep camelCasing only if uppercase", "-\t\tif ((patternChar = pattern[iPattern]) < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "-\t\t\t\t// end of camelCase part of pattern", "-\t\t\t\tbreak nextPatternChar;", "-\t\t\t}", "-\t\t\t// still uppercase", "-\t\t} else if (ScannerHelper.isJavaIdentifierPart(patternChar) ", "-\t\t\t\t\t\t&& !ScannerHelper.isUpperCase(patternChar)) {", "-\t\t\t// end of camelCase part of pattern", "-\t\t\tbreak nextPatternChar;", "-\t\t}", "-\t\tnextNameChar: while (iName < nameEnd) {", "-\t\t\tif ((nameChar = name[iName]) != patternChar) {", "-\t\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL | ScannerHelper.C_DIGIT)) != 0) {", "-\t\t\t\t\t\t// lowercase/digit char is ignored", "-\t\t\t\t\t\tiName++;", "-\t\t\t\t\t\tcontinue nextNameChar;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (ScannerHelper.isJavaIdentifierPart(nameChar) ", "-\t\t\t\t\t\t\t\t&& !ScannerHelper.isUpperCase(nameChar)) {", "-\t\t\t\t\t// lowercase name char is ignored", "-\t\t\t\t\tiName++;", "-\t\t\t\t\tcontinue nextNameChar;", "-\t\t\t\t}", "-\t\t\t\t// mismatch, either uppercase in name or non case char ('/' etc)--> reject", "-\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\t// pattern char == name char (uppercase)", "-\t\t\t\tiName++;", "-\t\t\t\tiPattern++;", "-\t\t\t\tcontinue nextPatternChar;", "-\t\t\t}\t", "-\t\t}", "-\t\tif (iPattern == patternEnd) return true;", "-\t\tif (iName == nameEnd) return false;", "-\t\tcontinue nextPatternChar;", "-\t}", "-\t\t", "-\t// check trailing part in case sensitive way", "-\twhile (iPattern < patternEnd && iName < nameEnd) {", "-\t\tif (pattern[iPattern] != name[iName]) {", "-\t\t\treturn false;", "-\t\t}", "+\tint iPattern = patternStart;", "+\tint iName = nameStart;", "+", "+\t// Main loop is on pattern characters", "+\twhile (true) {", "+", "+", "+\t\tif (iPattern == patternEnd) {", "+\t\t\t// We have exhausted pattern, so it's a match", "+\t\t\treturn true;", "+\t\t}", "+", "+\t\tif (iName == nameEnd){", "+\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// For as long as we're exactly matching, bring it on (even if it's a lower case character)", "+\t\tif ((patternChar = pattern[iPattern]) == name[iName]) {", "+\t\t\tcontinue;", "+\t\t}", "+", "+\t\t// If characters are not equals, then it's not a match if patternChar is lowercase", "+\t\tif (patternChar < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar)) {", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// patternChar is uppercase, so let's find the next uppercase in name", "+\t\twhile (true) {", "+\t\t\tif (iName == nameEnd){", "+\t            //\tWe have exhausted name (and not pattern), so it's not a match", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\tnameChar = name[iName];", "+\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL | ScannerHelper.C_DIGIT)) != 0) {", "+\t\t\t\t\t// nameChar is lowercase    ", "+\t\t\t\t\tiName++;", "+\t\t\t\t// nameChar is uppercase...", "+\t\t\t\t} else  if (patternChar != nameChar) {", "+\t\t\t\t\t//.. and it does not match patternChar, so it's not a match", "+\t\t\t\t\treturn false;", "+\t\t\t\t} else {", "+\t\t\t\t\t//.. and it matched patternChar. Back to the big loop", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (Character.isJavaIdentifierPart(nameChar) && !Character.isUpperCase(nameChar)) {", "+\t\t\t\t// nameChar is lowercase    ", "+\t\t\t\tiName++;", "+\t\t\t// nameChar is uppercase...", "+\t\t\t} else  if (patternChar != nameChar) {", "+\t\t\t\t//.. and it does not match patternChar, so it's not a match", "+\t\t\t\treturn false;", "+\t\t\t} else {", "+\t\t\t\t//.. and it matched patternChar. Back to the big loop", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\t// At this point, either name has been exhausted, or it is at an uppercase letter.", "+\t\t// Since pattern is also at an uppercase letter", "-\treturn iPattern == patternEnd;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "de2f6d9f423e08a738f2e2a81da8d075", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchPattern.java", "commitBeforeChange": "0f549220f498cda7c86a65324f594a6b8e8c2616", "commitAfterChange": "17fcd420e0756889bcaffeff4cf983b2cff84a3e", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "signatureAfterChange": " public static final boolean camelCaseMatch(String pattern, int patternStart, int patternEnd, String name, int nameStart, int nameEnd)", "diff": ["+", "-\tint iPattern = patternStart+1;", "-\tint iName = nameStart+1;", "-\tnextPatternChar: while (iPattern < patternEnd) {", "-\t\t// check patternChar, keep camelCasing only if uppercase", "-\t\tif ((patternChar = pattern.charAt(iPattern)) < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "-\t\t\t\t// end of camelCase part of pattern", "-\t\t\t\tbreak nextPatternChar;", "-\t\t\t}", "-\t\t\t// still uppercase", "-\t\t} else if (ScannerHelper.isJavaIdentifierPart(patternChar) ", "-\t\t\t\t\t\t&& !ScannerHelper.isUpperCase(patternChar)) {", "-\t\t\t// end of camelCase part of pattern", "-\t\t\tbreak nextPatternChar;", "-\t\t}", "-\t\tnextNameChar: while (iName < nameEnd) {", "-\t\t\tif ((nameChar = name.charAt(iName)) != patternChar) {", "-\t\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "-\t\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER|ScannerHelper.C_SPECIAL |ScannerHelper.C_DIGIT)) != 0) {", "-\t\t\t\t\t\t// lowercase/digit char is ignored", "-\t\t\t\t\t\tiName++;", "-\t\t\t\t\t\tcontinue nextNameChar;", "-\t\t\t\t\t}", "-\t\t\t\t} else if (ScannerHelper.isJavaIdentifierPart(nameChar) ", "-\t\t\t\t\t\t\t\t&& !ScannerHelper.isUpperCase(nameChar)) {", "-\t\t\t\t\t// lowercase name char is ignored", "-\t\t\t\t\tiName++;", "-\t\t\t\t\tcontinue nextNameChar;", "-\t\t\t\t}", "-\t\t\t\t// mismatch, either uppercase in name or non case char ('/' etc)--> reject", "-\t\t\t\treturn false;", "-\t\t\t} else {", "-\t\t\t\t// pattern char == name char (uppercase)", "-\t\t\t\tiName++;", "-\t\t\t\tiPattern++;", "-\t\t\t\tcontinue nextPatternChar;", "-\t\t\t}\t", "-\t\t}", "-\t\tif (iPattern == patternEnd) return true;", "-\t\tif (iName == nameEnd) return false;", "-\t\tcontinue nextPatternChar;", "-\t}", "-\t\t", "-\t// check trailing part in case sensitive way", "-\twhile (iPattern < patternEnd && iName < nameEnd) {", "-\t\tif (pattern.charAt(iPattern) != name.charAt(iName)) {", "-\t\t\treturn false;", "-\t\t}", "+\tint iPattern = patternStart;", "+\tint iName = nameStart;", "+", "+\t// Main loop is on pattern characters", "+\twhile (true) {", "+", "+", "+\t\tif (iPattern == patternEnd) {", "+\t\t\t// We have exhausted pattern, so it's a match", "+\t\t\treturn true;", "+\t\t}", "+", "+\t\tif (iName == nameEnd){", "+\t\t\t// We have exhausted name (and not pattern), so it's not a match ", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// For as long as we're exactly matching, bring it on (even if it's a lower case character)", "+\t\tif ((patternChar = pattern.charAt(iPattern)) == name.charAt(iName)) {", "+\t\t\tcontinue;", "+\t\t}", "+", "+\t\t// If characters are not equals, then it's not a match if patternChar is lowercase", "+\t\tif (patternChar < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[patternChar] & ScannerHelper.C_UPPER_LETTER) == 0) {", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t}", "+\t\telse if (Character.isJavaIdentifierPart(patternChar) && !Character.isUpperCase(patternChar)) {", "+\t\t\treturn false;", "+\t\t}", "+", "+\t\t// patternChar is uppercase, so let's find the next uppercase in name", "+\t\twhile (true) {", "+\t\t\tif (iName == nameEnd){", "+\t            //\tWe have exhausted name (and not pattern), so it's not a match", "+\t\t\t\treturn false;", "+\t\t\t}", "+", "+\t\t\tnameChar = name.charAt(iName);", "+", "+\t\t\tif (nameChar < ScannerHelper.MAX_OBVIOUS) {", "+\t\t\t\tif ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[nameChar] & (ScannerHelper.C_LOWER_LETTER | ScannerHelper.C_SPECIAL | ScannerHelper.C_DIGIT)) != 0) {", "+\t\t\t\t\t// nameChar is lowercase    ", "+\t\t\t\t\tiName++;", "+\t\t\t\t// nameChar is uppercase...", "+\t\t\t\t} else  if (patternChar != nameChar) {", "+\t\t\t\t\t//.. and it does not match patternChar, so it's not a match", "+\t\t\t\t\treturn false;", "+\t\t\t\t} else {", "+\t\t\t\t\t//.. and it matched patternChar. Back to the big loop", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\telse if (Character.isJavaIdentifierPart(nameChar) && !Character.isUpperCase(nameChar)) {", "+\t\t\t\t// nameChar is lowercase    ", "+\t\t\t\tiName++;", "+\t\t\t// nameChar is uppercase...", "+\t\t\t} else  if (patternChar != nameChar) {", "+\t\t\t\t//.. and it does not match patternChar, so it's not a match", "+\t\t\t\treturn false;", "+\t\t\t} else {", "+\t\t\t\t//.. and it matched patternChar. Back to the big loop", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\t// At this point, either name has been exhausted, or it is at an uppercase letter.", "+\t\t// Since pattern is also at an uppercase letter", "-\treturn iPattern == patternEnd;"]}], "num": 37176}