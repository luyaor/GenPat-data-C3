{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5aeb2bd6f75c74a81b3906888ff3d4c4", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36335d2f0b2e8bca672f049eb0ff0c9f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3e74f4ef73845fee74b0867380da94913c5a23bb", "commitAfterChange": "9b26565edd8f00a28f01564be0384c99bbdfa335", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (left instanceof CastExpression) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\tboolean argsContainCast = false;", "+\t\tif (left instanceof CastExpression) {", "+\t\t\tleft.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\targsContainCast = true;", "+\t\t}", "-\t\tif (right instanceof CastExpression) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\tif (right instanceof CastExpression) {", "+\t\t\tright.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\targsContainCast = true;", "+\t\t}", "-\t\tint leftId = leftType.id;", "-\t\tint rightId = rightType.id;", "-\t\tif (leftId > 15", "-\t\t\t|| rightId > 15) { // must convert String + Object || Object + String", "-\t\t\tif (leftId == T_String) {", "-\t\t\t\trightId = T_Object;", "-\t\t\t} else if (rightId == T_String) {", "-\t\t\t\tleftId = T_Object;", "+\t\tint leftTypeId = leftType.id;", "+\t\tint rightTypeId = rightType.id;", "+\t\tif (leftTypeId > 15", "+\t\t\t|| rightTypeId > 15) { // must convert String + Object || Object + String", "+\t\t\tif (leftTypeId == T_String) {", "+\t\t\t\trightTypeId = T_Object;", "+\t\t\t} else if (rightTypeId == T_String) {", "+\t\t\t\tleftTypeId = T_Object;", "-\t\t\tif (leftId == T_String", "+\t\t\tif (leftTypeId == T_String", "-\t\t\t\t\t} else if (rightId == T_String", "+\t\t\t\t\t} else if (rightTypeId == T_String", "-\t\tint result = ResolveTypeTables[operator][(leftId << 4) + rightId];", "-\t\tleft.implicitConversion = result >>> 12;", "-\t\tright.implicitConversion = (result >>> 4) & 0x000FF;", "+\t\tint operatorSignature = ResolveTypeTables[operator][(leftTypeId << 4) + rightTypeId];", "+\t\tleft.implicitConversion = operatorSignature >>> 12;", "+\t\tright.implicitConversion = (operatorSignature >>> 4) & 0x000FF;", "-\t\tbits |= result & 0xF;", "-\t\tswitch (result & 0xF) { // record the current ReturnTypeID", "+\t\tbits |= operatorSignature & 0xF;", "+\t\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "-\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "-\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "-\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "-\t\t\tint alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftId;", "-\t\t\tint alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightId;", "-\t\t\tint alternateResult = ResolveTypeTables[operator][(alternateLeftId << 4) + alternateRightId];", "-\t\t\t// (cast)  left   Op (cast)  right --> result", "-\t\t\t//  1111   0000       1111   0000     1111", "-\t\t\t//  <<16   <<12       <<8    <<4       <<0", "-\t\t\tfinal int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types", "-\t\t\tif ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result", "-\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "-\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "-\t\t\t}", "+\t\tif (argsContainCast) {", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeId, right, rightTypeId);", "-\t\tcomputeConstant(scope, leftId, rightId);", "+\t\tcomputeConstant(scope, leftTypeId, rightTypeId);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f54ea91389a4ae2d098d6c877d2c0e21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "3e74f4ef73845fee74b0867380da94913c5a23bb", "commitAfterChange": "9b26565edd8f00a28f01564be0384c99bbdfa335", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tif (left instanceof CastExpression) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\tTypeBinding leftType = left.resolveType(scope);", "+\t\tboolean argsContainCast = false;", "+\t\tif (left instanceof CastExpression) {", "+\t\t\tleft.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\targsContainCast = true;", "+\t\t}", "+\t\tTypeBinding leftType = left.resolveType(scope);", "-\tif (right instanceof CastExpression) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\tTypeBinding rightType = right.resolveType(scope);", "+\t\tif (right instanceof CastExpression) {", "+\t\t\tright.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\targsContainCast = true;", "+\t\t}", "+\t\tTypeBinding rightType = right.resolveType(scope);", "-\t\tint result = ResolveTypeTables[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];", "-\t\tleft.implicitConversion = result >>> 12;", "-\t\tright.implicitConversion = (result >>> 4) & 0x000FF;", "-\t\tbits |= result & 0xF;\t\t", "-\t\tif ((result & 0x0000F) == T_undefined) {", "+\t\tint operatorSignature = ResolveTypeTables[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];", "+\t\tleft.implicitConversion = operatorSignature >>> 12;", "+\t\tright.implicitConversion = (operatorSignature >>> 4) & 0x000FF;", "+\t\tbits |= operatorSignature & 0xF;\t\t", "+\t\tif ((operatorSignature & 0x0000F) == T_undefined) {", "-\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "-\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "-\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "-\t\t\tint alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftType.id;", "-\t\t\tint alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightType.id;", "-\t\t\tint alternateResult = ResolveTypeTables[EQUAL_EQUAL][(alternateLeftId << 4) + alternateRightId];", "-\t\t\t// (cast)  left   Op (cast)  right --> result", "-\t\t\t//  1111   0000       1111   0000     1111", "-\t\t\t//  <<16   <<12       <<8    <<4       <<0", "-\t\t\tfinal int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types", "-\t\t\tif ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result", "-\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "-\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "-\t\t\t}", "-\t\t}\t\t", "+\t\tif (argsContainCast) {", "+\t\t\tCastExpression.checkNeedForArgumentCasts(scope, EQUAL_EQUAL, operatorSignature, left, leftType.id, right, rightType.id);", "+\t\t}\t"]}], "num": 35024}