{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "924e0b9ed38a8d108ea4f7070a76bb89", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0fe5fd9363dc6c8c9612388c237b9a4a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchScope.java", "commitBeforeChange": "079f1f525d3cbb0b2570dd4fe3bd959b7a33dc49", "commitAfterChange": "b21cadb5eae53d9f84dce9f073b5350a267b6ad6", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 3, "signatureBeforeChange": "  public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException", "signatureAfterChange": " void add(JavaProject javaProject, IPath pathToAdd, int includeMask, HashSet visitedProjects, IClasspathEntry referringEntry) throws JavaModelException", "diff": ["-public void add(JavaProject javaProject, int includeMask, HashSet visitedProjects) throws JavaModelException {", "+ */", "+void add(JavaProject javaProject, IPath pathToAdd, int includeMask, HashSet visitedProjects, IClasspathEntry referringEntry) throws JavaModelException {", "+\tJavaModelManager.PerProjectInfo perProjectInfo = javaProject.getPerProjectInfo();", "+\t\tIClasspathEntry rawEntry = null;", "+\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "+\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "+\t\t}", "+\t\tif (rawEntry == null) continue;", "+\t\tAccessRestriction access = null;", "+\t\tClasspathEntry cpEntry = null;", "+\t\tif (rawEntry instanceof ClasspathEntry) {", "+\t\t\tcpEntry = (ClasspathEntry) rawEntry;", "+\t\t\tif (referringEntry != null) {", "+\t\t\t\tcpEntry = cpEntry.combineWith(referringEntry);", "+//\t\t\t\tcpEntry = ((ClasspathEntry)referringEntry).combineWith(cpEntry);", "+\t\t\t}", "+\t\t\taccess = cpEntry.getImportRestriction();", "+\t\t}", "-\t\t\t\tIClasspathEntry rawEntry = null;", "-\t\t\t\tJavaModelManager.PerProjectInfo perProjectInfo = javaProject.getPerProjectInfo();", "-\t\t\t\tif (perProjectInfo != null && perProjectInfo.resolvedPathToRawEntries != null) {", "-\t\t\t\t\trawEntry = (IClasspathEntry) perProjectInfo.resolvedPathToRawEntries.get(entry.getPath());", "-\t\t\t\t}", "-\t\t\t\tif (rawEntry == null) break;", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\t\t\tadd(path, true, access);", "+\t\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tadd(path, true);", "-\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\t\t\tadd(path, true, access);", "+\t\t\t\t\t\t\t\taddEnclosingProjectOrJar(path);", "+\t\t\t\t\t\t\t}", "-\t\t\t\t\tadd((JavaProject) model.getJavaProject(entry.getPath().lastSegment()), includeMask, visitedProjects);", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\tadd((JavaProject) model.getJavaProject(entry.getPath().lastSegment()), null, includeMask, visitedProjects, cpEntry);", "+\t\t\t\t\t}", "-\t\t\t\t\tadd(entry.getPath(), true);", "+\t\t\t\t\tIPath path = entry.getPath();", "+\t\t\t\t\tif (pathToAdd == null || pathToAdd.equals(path)) {", "+\t\t\t\t\t\tadd(entry.getPath(), true, access);", "+\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6764e08f046f6503fc3f2a92537c9fea", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java", "commitBeforeChange": "61e83b56b3e206ca02d211f1803679e0adee4981", "commitAfterChange": "b39f3a5a9fadba74f50d9dc16813d561f779e994", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tprivate void initialize() throws IOException", "signatureAfterChange": " \t \tprivate void initialize(String typeName) throws IOException", "diff": ["-\tprivate void initialize() throws IOException {", "-\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.annotationSource)));", "+\tprivate void initialize(String typeName) throws IOException {", "+\t\tLineNumberReader reader = new LineNumberReader(new InputStreamReader(new FileInputStream(this.annotationSource)));", "+\t\t\tif (!line.endsWith(typeName))", "+\t\t\t\tthrow new IOException(\"mismatching class name in annotation file, expected \"+typeName+\", but header said \"+line); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\tint pos=line.indexOf('=');", "-\t\t\t\tif (pos == -1) throw new IOException(\"Illegal format for annotation file, missing '='\"); //$NON-NLS-1$", "-\t\t\t\tthis.methodAnnotationSources.put(line.substring(0, pos), line.substring(pos+1));", "+\t\t\t\tString rawSig = null, annotSig = null;", "+\t\t\t\t// selector:", "+\t\t\t\tString selector = line;", "+\t\t\t\tint errLine = -1;", "+\t\t\t\ttry {", "+\t\t\t\t\t// raw signature:", "+\t\t\t\t\tline = reader.readLine();", "+\t\t\t\t\tif (line.charAt(0) == ' ')", "+\t\t\t\t\t\trawSig = line.substring(1);", "+\t\t\t\t\telse", "+\t\t\t\t\t\terrLine = reader.getLineNumber();", "+\t\t\t\t\t// annotated signature:", "+\t\t\t\t\tline = reader.readLine();", "+\t\t\t\t\tif (line.charAt(0) == ' ')", "+\t\t\t\t\t\tannotSig = line.substring(1);", "+\t\t\t\t} catch (Exception ex) {", "+\t\t\t\t\t// continue to escalate below", "+\t\t\t\t}", "+\t\t\t\tif (rawSig == null || annotSig == null) {", "+\t\t\t\t\tif (errLine == -1) errLine = reader.getLineNumber();", "+\t\t\t\t\tthrow new IOException(\"Illegal format for annotation file at line \"+errLine); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tthis.methodAnnotationSources.put(selector+rawSig, annotSig);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d70c177a64b15ab3ba0a92f8005ef08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java", "commitBeforeChange": "08a27bd42ab478e28ef52da212e8300b848a1dc3", "commitAfterChange": "ecf9bc726d142bbbe5f2d33b27c86a8428bd87ef", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "      \tpublic PackageDeclaration getPackage(String name)", "signatureAfterChange": "      \tpublic PackageDeclaration getPackage(String name)", "diff": ["-    {", "+\t{", "-        IPackageFragment[] pkgFrags = PackageUtil.getPackageFragments(name, this);", "+\t\tIPackageFragment[] pkgFrags = PackageUtil.getPackageFragments(name, this);", "-\t\t// If there are no source or class files, we'll need to return", "-\t\t// a special implementation of the package decl that expects", "-\t\t// no declarations inside it", "-\t\tboolean containsNoJavaResources = true;", "-\t\tfor (IPackageFragment pkg : pkgFrags) {", "-\t\t\ttry {", "+\t\ttry {", "+\t\t\t// If there are no source or class files, we'll need to return", "+\t\t\t// a special implementation of the package decl that expects", "+\t\t\t// no declarations inside it", "+\t\t\tboolean containsNoJavaResources = true;", "+\t\t\tfor (IPackageFragment pkg : pkgFrags) {", "-\t\t\tcatch (JavaModelException e) {}", "-\t\t}", "-\t\tif (containsNoJavaResources)", "-\t\t\treturn new PackageDeclarationImplNoBinding(pkgFrags);", "+\t\t\tif (containsNoJavaResources)", "+\t\t\t\treturn new PackageDeclarationImplNoBinding(pkgFrags);", "-\t\t// We should be able to create a class or", "-\t\t// source file from one of the packages.", "-\t\tICompilationUnit compUnit = null;", "-\t\tIClassFile classFile = null;", "-", "-\t\tOUTER:", "-\t\tfor (IPackageFragment pkg : pkgFrags) {", "-\t\t\ttry {", "-\t\t\t\tICompilationUnit[] compUnits = pkg.getCompilationUnits();", "-\t\t\t\tif (compUnits.length > 0) {", "-\t\t\t\t\tcompUnit = compUnits[0];", "-\t\t\t\t\tbreak;", "-\t\t\t\t}", "-\t\t\t\tIClassFile[] classFiles = pkg.getClassFiles();", "-\t\t\t\tif (classFiles.length > 0) {", "-\t\t\t\t\t// Need to grab the first one that's not an inner class,", "-\t\t\t\t\t// as eclipse has trouble parsing inner class files", "-\t\t\t\t\tfor (IClassFile tempClassFile : classFiles) {", "-\t\t\t\t\t\tif (tempClassFile.getElementName().indexOf(\"$\") < 0) { //$NON-NLS-1$", "-\t\t\t\t\t\t\tclassFile = tempClassFile;", "-\t\t\t\t\t\t\tbreak OUTER;", "+\t\t\t// We should be able to create a class or", "+\t\t\t// source file from one of the packages.", "+\t\t\t// If we find package-info, don't use it, but set ", "+\t\t\t// it aside in case it's all we can find.", "+\t\t\tICompilationUnit compUnit = null;", "+\t\t\tIClassFile classFile = null;", "+\t\t\tICompilationUnit pkgInfoUnit = null;", "+\t\t\tIClassFile pkgInfoClassFile = null;", "+\t\t\tOUTER:", "+\t\t\t\tfor (IPackageFragment frag : pkgFrags) {", "+\t\t\t\t\tif (frag.getKind() == IPackageFragmentRoot.K_SOURCE) {", "+\t\t\t\t\t\tfor (ICompilationUnit unit : frag.getCompilationUnits()) {", "+\t\t\t\t\t\t\tif (\"package-info.java\".equals(unit.getElementName())) { //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tpkgInfoUnit = unit;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\telse {", "+\t\t\t\t\t\t\t\tcompUnit = unit;", "+\t\t\t\t\t\t\t\tbreak OUTER;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\telse { // K_BINARY", "+\t\t\t\t\t\tfor (IClassFile file : frag.getClassFiles()) {", "+\t\t\t\t\t\t\tString cfName = file.getElementName();", "+\t\t\t\t\t\t\tif (\"package-info.class\".equals(cfName)) { //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tpkgInfoClassFile = file;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\telse if (file.getElementName().indexOf(\"$\") < 0) { //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tclassFile = file;", "+\t\t\t\t\t\t\t\tbreak OUTER;", "+\t\t\t\t\t\t\t}", "-\t\t\t}", "-\t\t\tcatch (JavaModelException e) {}", "-\t\t}", "-\t\tIType type = null;", "-\t\tif (compUnit != null) {", "-\t\t\ttry {", "-\t\t\t\tIType[] types = compUnit.getAllTypes();", "-\t\t\t\tif (types.length > 0) {", "-\t\t\t\t\ttype = types[0];", "+\t\t\tIType type = null;", "+\t\t\tif (compUnit != null) {", "+\t\t\t\ttry {", "+\t\t\t\t\tIType[] types = compUnit.getAllTypes();", "+\t\t\t\t\tif (types.length > 0) {", "+\t\t\t\t\t\ttype = types[0];", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tcatch (JavaModelException e) {}", "+\t\t\t}", "+\t\t\tif (type == null && classFile != null) {", "+\t\t\t\ttype = classFile.getType();", "+\t\t\t}", "+", "+\t\t\t// Given a type, we can construct a package declaration impl from it,", "+\t\t\t// but we must hide the fact that it came from a real declaration,", "+\t\t\t// as the client requested it without that context", "+\t\t\tif (type != null) {", "+\t\t\t\tTypeDeclarationImpl typeDecl = (TypeDeclarationImpl)getTypeDeclaration(type);", "+\t\t\t\tITypeBinding binding = typeDecl.getDeclarationBinding();", "+\t\t\t\treturn new PackageDeclarationImpl(binding.getPackage(), typeDecl, this, true, pkgFrags);", "+\t\t\t}", "+", "+\t\t\t// No classes or source files found.  Do we have a package-info we can use?", "+\t\t\tif (pkgInfoUnit != null) {", "+\t\t\t\tIPackageDeclaration[] decls = pkgInfoUnit.getPackageDeclarations();", "+\t\t\t\tif (decls.length > 0) {", "+\t\t\t\t\t// TODO: here we would like to return a PackageDeclarationImpl based on package-info.java.", "-\t\t\tcatch (JavaModelException e) {}", "+\t\t\tif (pkgInfoClassFile != null) {", "+\t\t\t\t// TODO: how can we access the annotations on a package-info.class?", "+\t\t\t\t// Hopefully this will be a rare situation: a binary package containing only a package-info.", "+\t\t\t}", "-\t\telse if (classFile != null) {", "-\t\t\ttype = classFile.getType();", "+\t\tcatch (JavaModelException e) {", "+\t\t\t// Probably bad code; treat as if no types were found", "-\t\t// Given a type, we can construct a package declaration impl from it,", "-\t\t// but we must hide the fact that it came from a real declaration,", "-\t\t// as the client requested it without that context", "-\t\tif (type != null) {", "-\t\t\tTypeDeclarationImpl typeDecl = (TypeDeclarationImpl)getTypeDeclaration(type);", "-\t\t\tITypeBinding binding = typeDecl.getDeclarationBinding();", "-\t\t\treturn new PackageDeclarationImpl(binding.getPackage(), typeDecl, this, true, pkgFrags);", "-\t\t}", "-", "-\t\t// No classes or source files found", "+\t\t// This package is empty: no types and no package-info.", "-    }", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ac9bca8cfd8f4ade5c287f7234902ccf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java", "commitBeforeChange": "e749248b2d171474b4cec0b274f15c474b2172fa", "commitAfterChange": "49bbfb9368cdcf7ee010de91440ff4d54ad31533", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic Object[] getCompatibleEmulationPath(ReferenceBinding targetEnclosingType)", "signatureAfterChange": " \tpublic Object[] getEmulationPath( \t\t\tReferenceBinding targetEnclosingType,  \t\t\tboolean onlyExactMatch, \t\t\tboolean ignoreEnclosingArgInConstructorCall)", "diff": ["-\t */", "-\tpublic Object[] getCompatibleEmulationPath(ReferenceBinding targetEnclosingType) {", "-", "-\t\tMethodScope currentMethodScope = this.methodScope();", "-\t\tSourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();", "-", "-\t\t// identity check", "-\t\tif (!currentMethodScope.isStatic ", "-\t\t\t&& !currentMethodScope.isConstructorCall", "-\t\t\t&& (sourceType == targetEnclosingType", "-\t\t\t\t|| targetEnclosingType.isSuperclassOf(sourceType))) {", "-\t\t\treturn EmulationPathToImplicitThis; // implicit this is good enough", "-\t\t}", "-\t\tif (!sourceType.isNestedType()", "-\t\t\t|| sourceType.isStatic()) { // no emulation from within non-inner types", "-\t\t\treturn null;", "-\t\t}", "-\t\tboolean insideConstructor =", "-\t\t\tcurrentMethodScope.isInsideInitializerOrConstructor();", "-\t\t// use synthetic constructor arguments if possible", "-\t\tif (insideConstructor) {", "-\t\t\tSyntheticArgumentBinding syntheticArg;", "-\t\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, this, false)) != null) {", "-\t\t\t\treturn new Object[] { syntheticArg };", "-\t\t\t}", "-\t\t}", "-", "-\t\t// use a direct synthetic field then", "-\t\tif (!currentMethodScope.isStatic) {", "-\t\t\tFieldBinding syntheticField;", "-\t\t\tif ((syntheticField = sourceType.getSyntheticField(targetEnclosingType, this, false)) != null) {", "-\t\t\t\treturn new Object[] { syntheticField };", "-\t\t\t}", "-\t\t\t// could be reached through a sequence of enclosing instance link (nested members)", "-\t\t\tObject[] path = new Object[2]; // probably at least 2 of them", "-\t\t\tReferenceBinding currentType = sourceType.enclosingType();", "-\t\t\tif (insideConstructor) {", "-\t\t\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument((SourceTypeBinding) currentType, this, false);", "-\t\t\t} else {", "-\t\t\t\tpath[0] =", "-\t\t\t\t\tsourceType.getSyntheticField((SourceTypeBinding) currentType, this, false);", "-\t\t\t}", "-\t\t\tif (path[0] != null) { // keep accumulating", "-\t\t\t\tint count = 1;", "-\t\t\t\tReferenceBinding currentEnclosingType;", "-\t\t\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "-\t\t\t\t\t//done?", "-\t\t\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentType))", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField((SourceTypeBinding) currentEnclosingType, this, false);", "-\t\t\t\t\tif (syntheticField == null)", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t// append inside the path", "-\t\t\t\t\tif (count == path.length) {", "-\t\t\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "-\t\t\t\t\t}", "-\t\t\t\t\t// private access emulation is necessary since synthetic field is private", "-\t\t\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "-\t\t\t\t\tcurrentType = currentEnclosingType;", "-\t\t\t\t}", "-\t\t\t\tif (currentType == targetEnclosingType", "-\t\t\t\t\t|| targetEnclosingType.isSuperclassOf(currentType)) {", "-\t\t\t\t\treturn path;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\treturn null;", "-\t}", "+\tpublic Object[] getEmulationPath(", "+\t\t\tReferenceBinding targetEnclosingType, ", "+\t\t\tboolean onlyExactMatch,", "+\t\t\tboolean ignoreEnclosingArgInConstructorCall) {", "+\t\t//TODO: (philippe) investigate why exactly test76 fails if ignoreEnclosingArgInConstructorCall is always false", "+\t\t\t&& (!currentMethodScope.isConstructorCall || ignoreEnclosingArgInConstructorCall)", "+\t\t\t&& (sourceType == targetEnclosingType", "+\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType)))) {", "+\t\t\tif (currentMethodScope.isConstructorCall) {", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t}", "+\t\t\tif (currentMethodScope.isStatic){", "+\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t}", "+\t\tif (!sourceType.isNestedType() || sourceType.isStatic()) { // no emulation from within non-inner types", "+\t\t\tif (currentMethodScope.isConstructorCall) {", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t}", "+\t\t\t\tif (currentMethodScope.isStatic){", "+\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t\t}", "+\t\tboolean insideConstructor = currentMethodScope.isInsideInitializerOrConstructor();", "+\t\t\tif ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, onlyExactMatch)) != null) {", "+", "+\t\tif (currentMethodScope.isStatic) {", "+\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t}", "+\t\tFieldBinding syntheticField = sourceType.getSyntheticField(targetEnclosingType, onlyExactMatch);", "+\t\tif (syntheticField != null) {", "+\t\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\treturn new Object[] { syntheticField };", "+\t\t}", "+\t\t// could be reached through a sequence of enclosing instance link (nested members)", "+\t\tObject[] path = new Object[2]; // probably at least 2 of them", "+\t\tReferenceBinding currentType = sourceType.enclosingType();", "+\t\tif (insideConstructor) {", "+\t\t\tpath[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument((SourceTypeBinding) currentType, onlyExactMatch);", "+\t\t} else {", "+\t\t\tif (currentMethodScope.isConstructorCall){", "+\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\tpath[0] = sourceType.getSyntheticField((SourceTypeBinding) currentType, onlyExactMatch);", "+\t\t}", "+\t\tif (path[0] != null) { // keep accumulating", "+\t\t\t", "+\t\t\tint count = 1;", "+\t\t\tReferenceBinding currentEnclosingType;", "+\t\t\twhile ((currentEnclosingType = currentType.enclosingType()) != null) {", "+", "+\t\t\t\t//done?", "+\t\t\t\tif (currentType == targetEnclosingType", "+\t\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType)))\tbreak;", "+", "+\t\t\t\tif (currentMethodScope != null) {", "+\t\t\t\t\tcurrentMethodScope = currentMethodScope.enclosingMethodScope();", "+\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isConstructorCall){", "+\t\t\t\t\t\treturn NoEnclosingInstanceInConstructorCall;", "+\t\t\t\t\tif (currentMethodScope != null && currentMethodScope.isStatic){", "+\t\t\t\t\t\treturn NoEnclosingInstanceInStaticContext;", "+\t\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tsyntheticField = ((NestedTypeBinding) currentType).getSyntheticField((SourceTypeBinding) currentEnclosingType, onlyExactMatch);", "+\t\t\t\tif (syntheticField == null) break;", "+", "+\t\t\t\t// append inside the path", "+\t\t\t\tif (count == path.length) {", "+\t\t\t\t\tSystem.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);", "+\t\t\t\t// private access emulation is necessary since synthetic field is private", "+\t\t\t\tpath[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);", "+\t\t\t\tcurrentType = currentEnclosingType;", "+\t\t\t}", "+\t\t\tif (currentType == targetEnclosingType", "+\t\t\t\t|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType))) {", "+\t\t\t\treturn path;"]}], "num": 37203}