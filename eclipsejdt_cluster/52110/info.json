{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f479e43b8a8cc2578c5334a574ce2d7e", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26c2b47e25bf7bc58f709b201bb4e7bd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java", "commitBeforeChange": "2b658a2e19b9466b65c78bf38bae4989bbb6fce3", "commitAfterChange": "52ad2d5b0def2732a36b65b6310c1844772d18ed", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "signatureAfterChange": " \tpublic boolean execute(IProgressMonitor progressMonitor)", "diff": ["-\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)) ", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE)", "-\t\t\t\t// nothing to index but want to save empty index file", "-// TODO (kent) how should empty projects be saved? if no rebuild job is issued then we would be ok", "-//\t\t\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "-//\t\t\t\tif (index != null)", "-//\t\t\t\t\tthis.manager.saveIndex(index);", "-\t\t\t\t// also the project might be a library folder (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89815)", "+\t\t\t\tIPath projectPath = javaProject.getPath();", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && entry.getPath().equals(projectPath))", "+\t\t\t\t\t\treturn true; // the project is also a library folder (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89815)", "+\t\t\t\t}", "+", "+\t\t\t\t// nothing to index but want to save an empty index file so its not 'rebuilt' when part of a search request", "+\t\t\t\tIndex index = this.manager.getIndexForUpdate(this.containerPath, true, /*reuse index file*/ true /*create if none*/);", "+\t\t\t\tif (index != null)", "+\t\t\t\t\tthis.manager.saveIndex(index);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "847f54bd00f247ed1851a1bf6f62b9f1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "99b584120d57fd9f2c2a7464785e4049acdac490", "commitAfterChange": "62bb0df3439a3337bf19f66c0d56ac16589e94ca", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  \tpublic Alignment createAlignment(String name, int mode, int tieBreakRule, int count, int sourceRestart, int continuationIndent, boolean adjust)", "signatureAfterChange": "  \tpublic Alignment createAlignment(String name, int mode, int tieBreakRule, int count, int sourceRestart, int continuationIndent, boolean adjust)", "diff": ["-\t\t\t\t\talignment.breakIndentationLevel = this.indentationLevel + continuationIndent * (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\tif ((mode & Alignment.M_INDENT_BY_ONE) != 0) {", "+\t\t\t\t\t\talignment.breakIndentationLevel = this.indentationLevel + (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\talignment.breakIndentationLevel = this.indentationLevel + (continuationIndent * (this.useTab ? 1 : this.tabSize));", "+\t\t\t\t\t}", "+\t\t\t\t\talignment.update();", "-\t\t\t\t\talignment.breakIndentationLevel = current.originalIndentationLevel + continuationIndent * (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\tif ((mode & Alignment.M_INDENT_BY_ONE) != 0) {", "+\t\t\t\t\t\talignment.breakIndentationLevel = current.originalIndentationLevel + (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\talignment.breakIndentationLevel = current.originalIndentationLevel + (continuationIndent * (this.useTab ? 1 : this.tabSize));", "+\t\t\t\t\t}", "+\t\t\t\t\talignment.update();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "94a9e801294b4bde0094b7a1e170455a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "ed1175e5f3196c1368a9a2b98678b1f4969f4620", "commitAfterChange": "cdead094a9813fdba5ccda0ce2f9f48a99552dbc", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tprivate void resolveParamTags(MethodScope methScope, boolean reportMissing)", "signatureAfterChange": " \tprivate void resolveParamTags(MethodScope methScope, boolean reportMissing)", "diff": ["-\t\tint paramTagsSize = parameters == null ? 0 : parameters.length;", "-\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;", "+\t\tint paramTagsSize = this.parameters == null ? 0 : this.parameters.length;", "+\t\t// If no referenced method (field initializer for example) then report a problem for each param tag", "+\t\tif (md == null) {", "+\t\t\tfor (int i = 0; i < paramTagsSize; i++) {", "+\t\t\t\tJavadocSingleNameReference param = this.parameters[i];", "+\t\t\t\tmethScope.problemReporter().javadocUnexpectedTag(param.tagSourceStart, param.tagSourceEnd);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\tint argumentsSize = md.arguments == null ? 0 : md.arguments.length;", "-\t\t\t\t\tmethScope.problemReporter().javadocMissingParamTag(arg);", "+\t\t\t\t\tmethScope.problemReporter().javadocMissingParamTag(arg, md.binding.modifiers);", "-\t\t\t\tJavadocSingleNameReference param = parameters[i];", "+\t\t\t\tJavadocSingleNameReference param = this.parameters[i];", "-\t\t\t\t\t\t\tmethScope.problemReporter().javadocInvalidParamName(param, true);", "+\t\t\t\t\t\t\tmethScope.problemReporter().javadocDuplicatedParamTag(param, md.binding.modifiers);", "-\t\t\t\t\t\tmethScope.problemReporter().javadocMissingParamTag(arg);", "+\t\t\t\t\t\tmethScope.problemReporter().javadocMissingParamTag(arg, md.binding.modifiers);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "99e2c4b7bc886889cb64d6c5e1c96843", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "8d903d0ba6af519462e797d9a7ec8393e31c70b2", "commitAfterChange": "7784cb2e8f17bfa5f33db4c9a4c52ad92916d78e", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t \tpublic Alignment createAlignment(String name, int mode, int tieBreakRule, int count, int sourceRestart)", "signatureAfterChange": " \t \tpublic Alignment createAlignment(String name, int mode, int tieBreakRule, int count, int sourceRestart)", "diff": ["+\t\t// adjust break indentation", "+\t\tif (this.currentAlignment != null) {", "+\t\t\tAlignment current = this.currentAlignment;", "+\t\t\twhile (current.enclosing != null) {", "+\t\t\t\tcurrent = current.enclosing;", "+\t\t\t}", "+\t\t\tswitch(current.chunkKind) {", "+\t\t\t\tcase Alignment.CHUNK_METHOD :", "+\t\t\t\tcase Alignment.CHUNK_TYPE :", "+\t\t\t\t\talignment.breakIndentationLevel = this.indentationLevel + (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Alignment.CHUNK_FIELD :", "+\t\t\t\t\talignment.breakIndentationLevel = current.originalIndentationLevel + (this.useTab ? 1 : this.tabSize);", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cf9b484084ac8c364185cd777ba40335", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/KeyToSignature.java", "commitBeforeChange": "9f0ebc31be56acb3fbfdaeae5760bc6493eb0026", "commitAfterChange": "d5f7602600be2e39f513d08d9350d4d6dfba6305", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate void substitute(char[] parameter, char[][] typeParameterSigs, int typeParametersLength)", "signatureAfterChange": " \tprivate void substitute(char[] parameter, char[][] typeParameterSigs, int typeParametersLength)", "diff": ["-\t\t\tthis.signature.append(parameter);", "+\t\t\t// handle array, wildcard and capture", "+\t\t\tint index = 0;", "+\t\t\tint length = parameter.length;", "+\t\t\tloop: while (index < length) {", "+\t\t\t\tchar current = parameter[index];", "+\t\t\t\tswitch (current) {", "+\t\t\t\t\tcase Signature.C_CAPTURE:", "+\t\t\t\t\tcase Signature.C_EXTENDS:", "+\t\t\t\t\tcase Signature.C_SUPER:", "+\t\t\t\t\tcase Signature.C_ARRAY:", "+\t\t\t\t\t\tthis.signature.append(current);", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tdefault:", "+\t\t\t\t\t\tbreak loop;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (index > 0) ", "+\t\t\t\tsubstitute(CharOperation.subarray(parameter, index, length), typeParameterSigs, typeParametersLength);", "+\t\t\telse", "+\t\t\t\tthis.signature.append(parameter);"]}], "num": 52110}