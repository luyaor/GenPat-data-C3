{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c0d12e0396f7bdec6772a4ad98f3beb5", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cdc14e9e61a4edd1514791e960996a03", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  static State read(DataInputStream in) throws IOException", "signatureAfterChange": "  static State read(IProject project, DataInputStream in) throws IOException", "diff": ["-static State read(DataInputStream in) throws IOException {", "+static State read(IProject project, DataInputStream in) throws IOException {", "+\tif (!project.getName().equals(newState.javaProjectName)) {", "+\t\tif (JavaBuilder.DEBUG)", "+\t\t\tSystem.out.println(\"Project's name does not match... answered null\"); //$NON-NLS-1$", "+\t\treturn null;", "+\t}", "-\tnewState.outputLocationString = in.readUTF();", "-\tnewState.classpathLocations = new ClasspathLocation[length];", "-\tString encoding = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot().getProject(newState.javaProjectName)).getOption(JavaCore.CORE_ENCODING, true);", "-\tfor (int i = 0; i < length; ++i) {", "+\tnewState.sourceLocations = new ClasspathMultiDirectory[length];", "+\tfor (int i = 0; i < length; i++) {", "+\t\tIContainer sourceFolder = project, outputFolder = project;", "+\t\tString folderName;", "+\t\tif ((folderName = in.readUTF()).length() > 0) sourceFolder = project.getFolder(folderName);", "+\t\tif ((folderName = in.readUTF()).length() > 0) outputFolder = project.getFolder(folderName);", "+\t\tClasspathMultiDirectory md =", "+\t\t\t(ClasspathMultiDirectory) ClasspathLocation.forSourceFolder(sourceFolder, outputFolder, readNames(in));", "+\t\tif (in.readBoolean())", "+\t\t\tmd.hasIndependentOutputFolder = true;", "+\t\tnewState.sourceLocations[i] = md;", "+\t}", "+", "+\tlength = in.readInt();", "+\tnewState.binaryLocations = new ClasspathLocation[length];", "+\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forSourceFolder(in.readUTF(), in.readUTF(), encoding);", "+\t\t\t\tnewState.binaryLocations[i] = newState.sourceLocations[in.readInt()];", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forBinaryFolder(in.readUTF());", "+\t\t\t\tIContainer outputFolder = project;", "+\t\t\t\tString folderName = in.readUTF();", "+\t\t\t\tif (folderName.length() > 0) outputFolder = project.getFolder(folderName);", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean());", "-\t\t\t\tnewState.classpathLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(project.getFile(in.readUTF()));", "+\t\t\t\tbreak;", "+\t\t\tcase 4 :", "+\t\t\t\tnewState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF());", "-\tString[] internedLocations = new String[length = in.readInt()];", "+\tString[] internedTypeLocators = new String[length = in.readInt()];", "-\t\tinternedLocations[i] = in.readUTF();", "+\t\tinternedTypeLocators[i] = in.readUTF();", "-\tnewState.typeLocations = new SimpleLookupTable(length = in.readInt());", "+\tnewState.typeLocators = new SimpleLookupTable(length = in.readInt());", "-\t\tnewState.typeLocations.put(in.readUTF(), internedLocations[in.readInt()]);", "+\t\tnewState.typeLocators.put(in.readUTF(), internedTypeLocators[in.readInt()]);", "-\t\tString location = internedLocations[in.readInt()];", "+\t\tString typeLocator = internedTypeLocators[in.readInt()];", "-\t\t\t\tfor (int j = 0, qLength = qualifiedNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qualifiedNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = simpleNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = simpleNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, qLength = qNames.length; j < qLength; j++)", "+\t\t\t\tfor (int j = 0, m = qNames.length; j < m; j++)", "-\t\t\t\tfor (int j = 0, sLength = sNames.length; j < sLength; j++)", "+\t\t\t\tfor (int j = 0, m = sNames.length; j < m; j++)", "-\t\tnewState.references.put(location, collection);", "+\t\tnewState.references.put(typeLocator, collection);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e1763198b5150de8cc4d0a44960f5c21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java", "commitBeforeChange": "1146476ca138da09c36a16ea64250a150f60b014", "commitAfterChange": "e3d3c02cc33fd5166184422215f4903c5a405e0f", "methodNumberBeforeChange": 18, "methodNumberAfterChange": 18, "signatureBeforeChange": "  void write(DataOutputStream out) throws IOException", "signatureAfterChange": "  void write(DataOutputStream out) throws IOException", "diff": ["- * String\t\toutput location", "-\tout.writeUTF(outputLocationString);", "- * Class path locations[]", "+ * ClasspathMultiDirectory[]", "- * ", "- * NOTE: Cannot have portable build states while classpath directories are full filesystem paths", "-\tout.writeInt(length = classpathLocations.length);", "-\tfor (int i = 0; i < length; ++i) {", "-\t\tClasspathLocation c = classpathLocations[i];", "+\tout.writeInt(length = sourceLocations.length);", "+\tfor (int i = 0; i < length; i++) {", "+\t\tClasspathMultiDirectory md = sourceLocations[i];", "+\t\tout.writeUTF(md.sourceFolder.getProjectRelativePath().toString());", "+\t\tout.writeUTF(md.binaryFolder.getProjectRelativePath().toString());", "+\t\twriteNames(md.exclusionPatterns, out);", "+\t\tout.writeBoolean(md.hasIndependentOutputFolder);", "+\t}", "+", "+/*", "+ * ClasspathLocation[]", "+ * int\t\t\t\tid", "+ * String\t\tpath(s)", "+*/", "+\tout.writeInt(length = binaryLocations.length);", "+\tnext : for (int i = 0; i < length; i++) {", "+\t\tClasspathLocation c = binaryLocations[i];", "-\t\t\tClasspathMultiDirectory md = (ClasspathMultiDirectory) c;", "-\t\t\tout.writeUTF(md.sourcePath);", "-\t\t\tout.writeUTF(md.binaryPath);", "+\t\t\tfor (int j = 0, m = sourceLocations.length; j < m; j++) {", "+\t\t\t\tif (sourceLocations[j] == c) {", "+\t\t\t\t\tout.writeInt(j);", "+\t\t\t\t\tcontinue next;", "+\t\t\t\t}", "+\t\t\t}", "-\t\t\tout.writeUTF(((ClasspathDirectory) c).binaryPath);", "-\t\t} else if (c instanceof ClasspathJar) {", "-\t\t\tout.writeByte(3);", "-\t\t\tout.writeUTF(((ClasspathJar) c).zipFilename);", "+\t\t\tClasspathDirectory cd = (ClasspathDirectory) c;", "+\t\t\tout.writeUTF(cd.binaryFolder.getProjectRelativePath().toString());", "+\t\t\tout.writeBoolean(cd.isOutputFolder);", "+\t\t} else {", "+\t\t\tClasspathJar jar = (ClasspathJar) c;", "+\t\t\tif (jar.zipFilename.equals(jar.relativePathname)) {", "+\t\t\t\tout.writeByte(3);", "+\t\t\t\tout.writeUTF(jar.relativePathname);", "+\t\t\t} else {", "+\t\t\t\tout.writeByte(4);", "+\t\t\t\tout.writeUTF(jar.zipFilename);", "+\t\t\t}", "- * String[]\t\tInterned locations", "+ * String[]\t\tInterned type locators", "-\tArrayList internedLocations = new ArrayList(length);", "+\tArrayList internedTypeLocators = new ArrayList(length);", "-\t\t\t\tinternedLocations.add(key);", "+\t\t\t\tinternedTypeLocators.add(key);", "- * Type locations table", "+ * Type locators table", "- * int\t\t\t\tinterned location id", "+ * int\t\t\t\tinterned locator id", "-\tout.writeInt(length = typeLocations.elementSize);", "+\tout.writeInt(length = typeLocators.elementSize);", "-\t\tkeyTable = typeLocations.keyTable;", "-\t\tvalueTable = typeLocations.valueTable;", "+\t\tkeyTable = typeLocators.keyTable;", "+\t\tvalueTable = typeLocators.valueTable;", "-\t\t\t\tout.writeInt(internedLocations.indexOf((String) valueTable[i]));", "+\t\t\t\tout.writeInt(internedTypeLocators.indexOf((String) valueTable[i]));", "-\t\t\tSystem.out.println(\"typeLocations table is inconsistent\"); //$NON-NLS-1$", "+\t\t\tSystem.out.println(\"typeLocators table is inconsistent\"); //$NON-NLS-1$", "-\t\t\tfor (int j = 0, qLength = qNames.length; j < qLength; j++) {", "+\t\t\tfor (int j = 0, m = qNames.length; j < m; j++) {", "-\t\t\t\t\tfor (int k = 0, sLength = qName.length; k < sLength; k++) {", "+\t\t\t\t\tfor (int k = 0, n = qName.length; k < n; k++) {", "-\t\t\tfor (int j = 0, sLength = sNames.length; j < sLength; j++) {", "+\t\t\tfor (int j = 0, m = sNames.length; j < m; j++) {", "- * int\t\t\tinterned location id", "+ * int\t\t\tinterned locator id", "-\t\t\t\tout.writeInt(internedLocations.indexOf((String) keyTable[i]));", "+\t\t\t\tout.writeInt(internedTypeLocators.indexOf((String) keyTable[i]));"]}], "num": 39468}