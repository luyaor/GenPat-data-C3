{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "547c50785f0393e721b576e1547f41bc", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "00c8029f34b7aac5fd0ecaea8013808b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "signatureAfterChange": " \tpublic Binding getBinding(char[] name, int mask, InvocationSite invocationSite, boolean needResolve)", "diff": ["-", "+\t\t\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t", "+\t\t\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "+\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "-\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "-\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "-\t\t\t\t\t\t\t", "-\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "-\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "-\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\t\t\tFieldBinding fieldBinding = classScope.findField(enclosingType, name, invocationSite, needResolve);", "+\t\t\t\t\t\t\t\t// Use next line instead if willing to enable protected access accross inner types", "+\t\t\t\t\t\t\t\t// FieldBinding fieldBinding = findField(enclosingType, name, invocationSite);", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\t\tif (fieldBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\t\tif (foundField == null || foundField.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\t\treturn fieldBinding;", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the field, likely wants the first inherited field (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "-\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t", "+\t\t\t\t\t\t\t\t\tProblemFieldBinding insideProblem = null;", "+\t\t\t\t\t\t\t\t\tif (fieldBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tif (!fieldBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfieldBinding.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "-\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "-\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "-\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "-\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\tif (enclosingType == fieldBinding.declaringClass || environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t\t// found a valid field in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField == null) {", "+\t\t\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(enclosingType);", "+\t\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\t\t// return the fieldBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\treturn insideProblem == null ? fieldBinding : insideProblem;", "+\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t\tif (foundField.isValidBinding())", "+\t\t\t\t\t\t\t\t\t\t\t\t// if a valid field was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t\t\t\tif (foundField.declaringClass != fieldBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t\t\t\t// ie. have we found the same field - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\t\t\t\treturn new ProblemFieldBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tfoundField.declaringClass,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tname,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "-\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "-\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "-\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t", "+\t\t\t\t\t\t\t\t\tif (foundField == null || (foundField.problemId() == NotVisible && fieldBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t\t\t// only remember the fieldBinding if its the first one found or the previous one was not visible & fieldBinding is...", "+\t\t\t\t\t\t\t\t\t\tfoundDepth = depth;", "+\t\t\t\t\t\t\t\t\t\tfoundActualReceiverType = enclosingType;", "+\t\t\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\t\t\tfoundField = fieldBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tinsideTypeAnnotation = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3cb4391c4433e24360a251c41f3938ce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "diff": ["+\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "-\t\t\t\t\t\t// 6.5.5.1 - member types have precedence over top-level type in same unit", "-\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "-\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "-\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t\treturn memberType;", "-\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "-\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "-\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "-\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "-\t\t\t\t\t\t\t\t\tif (foundType == null)", "-\t\t\t\t\t\t\t\t\t\treturn memberType; ", "-\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "-\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding() && foundType != memberType)", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\t\t// 6.5.5.1 - member types have precedence over top-level type in same unit", "+\t\t\t\t\t\t\tReferenceBinding memberType = findMemberType(name, sourceType);", "+\t\t\t\t\t\t\tif (memberType != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\t\tif (memberType.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\t\tif (foundType == null || foundType.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "+\t\t\t\t\t\t\t\t\t\treturn memberType;", "+\t\t\t\t\t\t\t\t\t// make the user qualify the type, likely wants the first inherited type", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\tif (memberType.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\tif (sourceType == memberType.enclosingType()", "+\t\t\t\t\t\t\t\t\t\t\t|| environment().options.complianceLevel >= ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\t\t\t\t\t// found a valid type in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited shadows enclosing)", "+\t\t\t\t\t\t\t\t\t\tif (foundType == null)", "+\t\t\t\t\t\t\t\t\t\t\treturn memberType; ", "+\t\t\t\t\t\t\t\t\t\t// if a valid type was found, complain when another is found in an 'immediate' enclosing type (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t\tif (foundType.isValidBinding() && foundType != memberType)", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "+\t\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "+\t\t\t\t\t\t\t\t\tfoundType = memberType;", "-\t\t\t\t\t\t\tif (foundType == null || (foundType.problemId() == NotVisible && memberType.problemId() != NotVisible))", "-\t\t\t\t\t\t\t\t// only remember the memberType if its the first one found or the previous one was not visible & memberType is...", "-\t\t\t\t\t\t\t\tfoundType = memberType;", "+\t\t\t\t\t\tinsideTypeAnnotation = false;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4274b91a705ededd16adb67f4a0618ab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "5dcefdb7b6dc4ca118d352248744f6f6f0cfd53e", "commitAfterChange": "6568a2476b22c2b9915b48b3eb9ea4ea62f741d4", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 35, "signatureBeforeChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "signatureAfterChange": " \tpublic MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite)", "diff": ["+\t\tboolean insideTypeAnnotation = false;", "+\t\t\t\t\tinsideTypeAnnotation = methodScope.insideTypeAnnotation;", "-\t\t\t\t\tboolean isExactMatch = true;", "-\t\t\t\t\t// retrieve an exact visible match (if possible)", "-\t\t\t\t\t// compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type", "-\t\t\t\t\tMethodBinding methodBinding =", "-\t\t\t\t\t\t(foundMethod == null)", "-\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "-\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "-\t\t\t\t\tif (methodBinding == null) {", "-\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "-\t\t\t\t\t\tisExactMatch = false;", "-\t\t\t\t\t\tmethodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t}", "-\t\t\t\t\tif (methodBinding != null) { // skip it if we did not find anything", "-\t\t\t\t\t\tif (methodBinding.problemId() == Ambiguous) {", "-\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible) {", "-\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\treturn methodBinding;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\tselector,", "-\t\t\t\t\t\t\t\targumentTypes,", "-\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\tif (!insideTypeAnnotation) {", "+\t\t\t\t\t\tboolean isExactMatch = true;", "+\t\t\t\t\t\t// retrieve an exact visible match (if possible)", "+\t\t\t\t\t\t// compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type", "+\t\t\t\t\t\tMethodBinding methodBinding =", "+\t\t\t\t\t\t\t(foundMethod == null)", "+\t\t\t\t\t\t\t\t? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)", "+\t\t\t\t\t\t\t\t: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);", "+\t\t\t\t\t\tif (methodBinding == null) {", "+\t\t\t\t\t\t\t// answers closest approximation, may not check argumentTypes or visibility", "+\t\t\t\t\t\t\tisExactMatch = false;", "+\t\t\t\t\t\t\tmethodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t// methodBinding = findMethod(receiverType, selector, argumentTypes, invocationSite);", "-\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "-\t\t\t\t\t\tMethodBinding insideProblem = null;", "-\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "-\t\t\t\t\t\t\tif (!isExactMatch) {", "-\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "-\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "-\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible)", "-\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "-\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, NotFound);", "-\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "-\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "-\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "-\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "-\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "-\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "-\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "-\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "-\t\t\t\t\t\t\t\t\tinsideProblem =", "-\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "-\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != NoMethods", "-\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "-\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "-\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "-\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "-\t\t\t\t\t\t\t\tif (foundMethod == null) {", "-\t\t\t\t\t\t\t\t\tif (depth > 0){", "-\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "-\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "-\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "-\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "-\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\tif (methodBinding != null) { // skip it if we did not find anything", "+\t\t\t\t\t\t\tif (methodBinding.problemId() == Ambiguous) {", "+\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible) {", "+\t\t\t\t\t\t\t\t\t// supercedes any potential InheritedNameHidesEnclosingName problem", "-\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "-\t\t\t\t\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "-\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "-\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "-\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "-\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "-\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "-\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\tselector,", "+\t\t\t\t\t\t\t\t\targumentTypes,", "+\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t}", "-", "-\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "-\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "-\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "-\t\t\t\t\t\t\tif (depth > 0) {", "-\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "-\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\tMethodBinding fuzzyProblem = null;", "+\t\t\t\t\t\t\tMethodBinding insideProblem = null;", "+\t\t\t\t\t\t\tif (methodBinding.isValidBinding()) {", "+\t\t\t\t\t\t\t\tif (!isExactMatch) {", "+\t\t\t\t\t\t\t\t\tMethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);", "+\t\t\t\t\t\t\t\t\tif (compatibleMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tif (foundMethod == null || foundMethod.problemId() == NotVisible)", "+\t\t\t\t\t\t\t\t\t\t\t// inherited mismatch is reported directly, not looking at enclosing matches", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(methodBinding, selector, argumentTypes, NotFound);", "+\t\t\t\t\t\t\t\t\t\t// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)", "+\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t} else if (!compatibleMethod.isValidBinding()) {", "+\t\t\t\t\t\t\t\t\t\tfuzzyProblem = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tmethodBinding = compatibleMethod;", "+\t\t\t\t\t\t\t\t\t\tif (!methodBinding.canBeSeenBy(receiverType, invocationSite, classScope)) {", "+\t\t\t\t\t\t\t\t\t\t\t// using <classScope> instead of <this> for visibility check does grant all access to innerclass", "+\t\t\t\t\t\t\t\t\t\t\tfuzzyProblem = new ProblemMethodBinding(methodBinding, selector, methodBinding.parameters, NotVisible);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tif (fuzzyProblem == null && !methodBinding.isStatic()) {", "+\t\t\t\t\t\t\t\t\tif (insideConstructorCall) {", "+\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInConstructorInvocation);", "+\t\t\t\t\t\t\t\t\t} else if (insideStaticContext) {", "+\t\t\t\t\t\t\t\t\t\tinsideProblem =", "+\t\t\t\t\t\t\t\t\t\t\tnew ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\t\tNonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t}", "+\t", "+\t\t\t\t\t\t\t\tif (receiverType == methodBinding.declaringClass", "+\t\t\t\t\t\t\t\t\t|| (receiverType.getMethods(selector)) != NoMethods", "+\t\t\t\t\t\t\t\t\t|| ((fuzzyProblem == null || fuzzyProblem.problemId() != NotVisible) && environment().options.complianceLevel >= ClassFileConstants.JDK1_4)) {", "+\t\t\t\t\t\t\t\t\t// found a valid method in the 'immediate' scope (ie. not inherited)", "+\t\t\t\t\t\t\t\t\t// OR the receiverType implemented a method with the correct name", "+\t\t\t\t\t\t\t\t\t// OR in 1.4 mode (inherited visible shadows enclosing)", "+\t\t\t\t\t\t\t\t\tif (foundMethod == null) {", "+\t\t\t\t\t\t\t\t\t\tif (depth > 0){", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t\t// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)", "+\t\t\t\t\t\t\t\t\t\tif (fuzzyProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\treturn fuzzyProblem;", "+\t\t\t\t\t\t\t\t\t\tif (insideProblem != null)", "+\t\t\t\t\t\t\t\t\t\t\treturn insideProblem;", "+\t\t\t\t\t\t\t\t\t\treturn methodBinding;", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)", "+\t\t\t\t\t\t\t\t\t// NOTE: Unlike fields, a non visible method hides a visible method", "+\t\t\t\t\t\t\t\t\tif (foundMethod.declaringClass != methodBinding.declaringClass)", "+\t\t\t\t\t\t\t\t\t\t// ie. have we found the same method - do not trust field identity yet", "+\t\t\t\t\t\t\t\t\t\treturn new ProblemMethodBinding(", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding, // closest match", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.selector,", "+\t\t\t\t\t\t\t\t\t\t\tmethodBinding.parameters,", "+\t\t\t\t\t\t\t\t\t\t\tInheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "-\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "-\t\t\t\t\t\t\tif (fuzzyProblem == null)", "-\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "+\t", "+\t\t\t\t\t\t\tif (foundMethod == null || (foundMethod.problemId() == NotVisible && methodBinding.problemId() != NotVisible)) {", "+\t\t\t\t\t\t\t\t// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...", "+\t\t\t\t\t\t\t\t// remember that private methods are visible if defined directly by an enclosing class", "+\t\t\t\t\t\t\t\tif (depth > 0) {", "+\t\t\t\t\t\t\t\t\tinvocationSite.setDepth(depth);", "+\t\t\t\t\t\t\t\t\tinvocationSite.setActualReceiverType(receiverType);", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tfoundFuzzyProblem = fuzzyProblem;", "+\t\t\t\t\t\t\t\tfoundInsideProblem = insideProblem;", "+\t\t\t\t\t\t\t\tif (fuzzyProblem == null)", "+\t\t\t\t\t\t\t\t\tfoundMethod = methodBinding; // only keep it if no error was found", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\tinsideTypeAnnotation = false;"]}], "num": 34817}