{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e8e6232e634893df47e7b2954355cc39", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "078542e07bd377a113f628c3a5c0205b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java", "commitBeforeChange": "653b549b2ec915800fe34bbb2ab9809b71ca66a5", "commitAfterChange": "2caa59d033a9b6c8ec71aab586472ad7fe749893", "methodNumberBeforeChange": 51, "methodNumberAfterChange": 51, "signatureBeforeChange": "  protected void resolveAnnotations(Scope scope)", "signatureAfterChange": "  protected void resolveAnnotations(Scope scope)", "diff": ["+\t\t\tlong[] tagBitsPerDimension = null;", "+\t\t\tint dimensions = this.dimensions();", "+\t\t\tboolean shouldAnalyzeArrayNullAnnotations = scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled && this instanceof ArrayTypeReference;", "-\t\t\t\t\tif (this.annotations[i] != null) {", "-\t\t\t\t\t\tresolveAnnotations(resolutionScope, this.annotations[i], new Annotation.TypeUseBinding(isWildcard() ? Binding.TYPE_PARAMETER : Binding.TYPE_USE));", "+\t\t\t\t\tAnnotation[] currentAnnotations = this.annotations[i];", "+\t\t\t\t\tif (currentAnnotations != null) {", "+\t\t\t\t\t\tresolveAnnotations(resolutionScope, currentAnnotations, new Annotation.TypeUseBinding(isWildcard() ? Binding.TYPE_PARAMETER : Binding.TYPE_USE));", "+\t\t\t\t\t\tif (shouldAnalyzeArrayNullAnnotations) {", "+\t\t\t\t\t\t\tint len = currentAnnotations.length;", "+\t\t\t\t\t\t\tfor (int j=0; j<len; j++) {", "+\t\t\t\t\t\t\t\tBinding recipient = currentAnnotations[j].recipient;", "+\t\t\t\t\t\t\t\tif (recipient instanceof Annotation.TypeUseBinding) {", "+\t\t\t\t\t\t\t\t\tif (tagBitsPerDimension == null)", "+\t\t\t\t\t\t\t\t\t\ttagBitsPerDimension = new long[dimensions+1]; // each dimension plus leaf component type at last position", "+\t\t\t\t\t\t\t\t\t// @NonNull Foo [][][] means the leaf component type is @NonNull:", "+\t\t\t\t\t\t\t\t\ttagBitsPerDimension[dimensions] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (shouldAnalyzeArrayNullAnnotations) {", "+\t\t\t\t\t\t\tint len = dimensionAnnotations.length;", "+\t\t\t\t\t\t\tfor (int j=0; j<len; j++) {", "+\t\t\t\t\t\t\t\tBinding recipient = dimensionAnnotations[j].recipient;", "+\t\t\t\t\t\t\t\tif (recipient instanceof Annotation.TypeUseBinding) {", "+\t\t\t\t\t\t\t\t\tif (tagBitsPerDimension == null)", "+\t\t\t\t\t\t\t\t\t\ttagBitsPerDimension = new long[dimensions+1];", "+\t\t\t\t\t\t\t\t\ttagBitsPerDimension[i] = ((Annotation.TypeUseBinding)recipient).tagBits & TagBits.AnnotationNullMASK;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\tif (tagBitsPerDimension != null && this.resolvedType.isValidBinding()) {", "+\t\t\t\t// TODO(stephan): wouldn't it be more efficient to store the array bindings inside the type binding rather than the environment?", "+\t\t\t\t// cf. LocalTypeBinding.createArrayType()", "+\t\t\t\tthis.resolvedType = scope.environment().createArrayType(this.resolvedType.leafComponentType(), dimensions, tagBitsPerDimension);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8d9592a516812a06f1f4d01f1ad56e5b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "acb688302e3cacbdc42738d6941f0a71f5b00f9c", "commitAfterChange": "37562c5a562cc71ff03559ef16cdaf50168f2116", "methodNumberBeforeChange": 32, "methodNumberAfterChange": 30, "signatureBeforeChange": "  \tpublic Expression convert(QualifiedAllocationExpression expression)", "signatureAfterChange": "  \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression allocation)", "diff": ["-\tpublic Expression convert(QualifiedAllocationExpression expression) {", "-\t\tif (expression.anonymousType != null) {", "-\t\t\treturn convert(expression.anonymousType);", "+\tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression allocation) {", "+\t\tif (allocation.anonymousType != null) {", "+\t\t\tClassInstanceCreation classInstanceCreation = this.ast.newClassInstanceCreation();", "+\t\t\tclassInstanceCreation.setName(convert(allocation.type));", "+\t\t\tif (allocation.enclosingInstance != null) {", "+\t\t\t\tclassInstanceCreation.setExpression(convert(allocation.enclosingInstance));", "+\t\t\t}", "+\t\t\tint declarationSourceStart = allocation.sourceStart;", "+\t\t\tclassInstanceCreation.setSourceRange(declarationSourceStart, allocation.anonymousType.bodyEnd - declarationSourceStart + 1);", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression[] arguments = allocation.arguments;", "+\t\t\tif (arguments != null) {", "+\t\t\t\tint length = arguments.length;", "+\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\tclassInstanceCreation.arguments().add(convert(arguments[i]));", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tAnonymousClassDeclaration anonymousClassDeclaration = this.ast.newAnonymousClassDeclaration();", "+\t\t\tint start = retrieveStartBlockPosition(declarationSourceStart, allocation.anonymousType.bodyEnd);", "+\t\t\tanonymousClassDeclaration.setSourceRange(start, allocation.anonymousType.bodyEnd - start + 1);", "+\t\t\tclassInstanceCreation.setAnonymousClassDeclaration(anonymousClassDeclaration);", "+\t\t\tbuildBodyDeclarations(allocation.anonymousType, anonymousClassDeclaration);", "+\t\t\tif (this.resolveBindings) {", "+\t\t\t\trecordNodes(classInstanceCreation, allocation.anonymousType);", "+\t\t\t\trecordNodes(anonymousClassDeclaration, allocation.anonymousType);", "+\t\t\t\tanonymousClassDeclaration.resolveBinding();", "+\t\t\t}", "+\t\t\treturn classInstanceCreation;\t\t\t", "-\t\t\tclassInstanceCreation.setExpression(convert(expression.enclosingInstance));", "-\t\t\tclassInstanceCreation.setName(convert(expression.type));", "-\t\t\tclassInstanceCreation.setSourceRange(expression.sourceStart, expression.sourceEnd - expression.sourceStart + 1);", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression[] arguments = expression.arguments;", "+\t\t\tclassInstanceCreation.setExpression(convert(allocation.enclosingInstance));", "+\t\t\tclassInstanceCreation.setName(convert(allocation.type));", "+\t\t\tclassInstanceCreation.setSourceRange(allocation.sourceStart, allocation.sourceEnd - allocation.sourceStart + 1);", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.Expression[] arguments = allocation.arguments;", "-\t\t\t\trecordNodes(classInstanceCreation, expression);", "+\t\t\t\trecordNodes(classInstanceCreation, allocation);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aed343c6a0f315fe05b669f772533c74", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \t \tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ThisReference reference)", "signatureAfterChange": " \t \tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AnnotationTypeMemberDeclaration annotationTypeMemberDeclaration)", "diff": ["-\t", "-\tpublic Expression convert(org.eclipse.jdt.internal.compiler.ast.ThisReference reference) {", "-\t\tif (reference.isImplicitThis()) {", "-\t\t\t// There is no source associated with an implicit this", "-\t\t\treturn null;", "-\t\t} else if (reference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference) {", "-\t\t\treturn convert((org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference) reference);", "-\t\t} else if (reference instanceof org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference) {", "-\t\t\treturn convert((org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference) reference);", "-\t\t}  else {", "-\t\t\tThisExpression thisExpression = this.ast.newThisExpression();", "-\t\t\tthisExpression.setSourceRange(reference.sourceStart, reference.sourceEnd - reference.sourceStart + 1);", "-\t\t\tif (this.resolveBindings) {", "-\t\t\t\trecordNodes(thisExpression, reference);", "-\t\t\t\trecordPendingThisExpressionScopeResolution(thisExpression);", "-\t\t\t}", "-\t\t\treturn thisExpression;", "-\t\t}", "-\t}", "+\t", "+\tpublic ASTNode convert(org.eclipse.jdt.internal.compiler.ast.AnnotationTypeMemberDeclaration annotationTypeMemberDeclaration) {", "+\t\tcheckCanceled();", "+\t\tif (this.ast.apiLevel == AST.JLS2) {", "+\t\t\treturn null;", "+\t\t}", "+\t\tAnnotationTypeMemberDeclaration annotationTypeMemberDeclaration2 = this.ast.newAnnotationTypeMemberDeclaration();", "+\t\tif ((annotationTypeMemberDeclaration.modifiers & CompilerModifiers.AccJustFlag) != 0) {", "+\t\t\tsetModifiers(annotationTypeMemberDeclaration2, annotationTypeMemberDeclaration);", "+\t\t}", "+\t\tSimpleName methodName = this.ast.newSimpleName(new String(annotationTypeMemberDeclaration.selector));", "+\t\tint start = annotationTypeMemberDeclaration.sourceStart;", "+\t\tint end = retrieveIdentifierEndPosition(start, annotationTypeMemberDeclaration.sourceEnd);", "+\t\tmethodName.setSourceRange(start, end - start + 1);", "+\t\tannotationTypeMemberDeclaration2.setName(methodName);", "+\t\torg.eclipse.jdt.internal.compiler.ast.TypeReference typeReference = annotationTypeMemberDeclaration.returnType;", "+\t\tif (typeReference != null) {", "+\t\t\tType returnType = convertType(typeReference);", "+\t\t\tsetTypeForMethodDeclaration(annotationTypeMemberDeclaration2, returnType, 0);", "+\t\t}", "+\t\tint declarationSourceStart = annotationTypeMemberDeclaration.declarationSourceStart;", "+\t\tint declarationSourceEnd = annotationTypeMemberDeclaration.bodyEnd;", "+\t\tannotationTypeMemberDeclaration2.setSourceRange(declarationSourceStart, declarationSourceEnd - declarationSourceStart + 1);", "+\t\t// The javadoc comment is now got from list store in compilation unit declaration", "+\t\tconvert(annotationTypeMemberDeclaration.javadoc, annotationTypeMemberDeclaration2);", "+\t\torg.eclipse.jdt.internal.compiler.ast.Expression memberValue = annotationTypeMemberDeclaration.memberValue;", "+\t\tif (memberValue != null) {", "+\t\t\tannotationTypeMemberDeclaration2.setDefault(convert(memberValue));", "+\t\t}", "+\t\tif (this.resolveBindings) {", "+\t\t\trecordNodes(annotationTypeMemberDeclaration2, annotationTypeMemberDeclaration);", "+\t\t\trecordNodes(methodName, annotationTypeMemberDeclaration);", "+\t\t\tannotationTypeMemberDeclaration2.resolveBinding();", "+\t\t}", "+\t\treturn annotationTypeMemberDeclaration2;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbaaa38b5c37b8b7a65844c6c178dce6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "7bf89e29c34a348a2ed388f7cdb6c1016941cf61", "commitAfterChange": "cd5adcef3921beea7df4f6703ab58225bdb4ec39", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tpublic boolean visit(AnnotationTypeDeclaration annotationTypeDeclaration, \t\t\tClassScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\tArrayAllocationExpression arrayAllocationExpression, \t\tBlockScope scope)", "diff": ["-\t}", "-\tpublic boolean visit(AnnotationTypeDeclaration annotationTypeDeclaration,", "-\t\t\tClassScope scope) {", "-\t\tformat(annotationTypeDeclaration);", "-\t\treturn false;", "-\t}"]}], "num": 64007}