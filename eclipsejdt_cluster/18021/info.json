{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "909739cbf78e122affc073b9a8c3edb2", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "517d1a8f36d3071e0652549249ece7fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java", "commitBeforeChange": "6cb413dbd992ad73f847d7b4e14e78f1406fa2fc", "commitAfterChange": "8659b871eae5c2008485cfb120ce2c8f8ecbfe04", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 12, "signatureBeforeChange": " \tpublic FileGenerationResult generateFileDuringBuild( \t\t\tIFile parentFile, \t\t\tString typeName,  \t\t\tString contents,  \t\t\tIProgressMonitor progressMonitor) \tthrows CoreException", "signatureAfterChange": " \tpublic FileGenerationResult generateFileDuringBuild(IFile parentFile, String typeName, String contents, \t\t\tIProgressMonitor progressMonitor) throws CoreException", "diff": ["-\tpublic FileGenerationResult generateFileDuringBuild(", "-\t\t\tIFile parentFile,", "-\t\t\tString typeName, ", "-\t\t\tString contents, ", "-\t\t\tIProgressMonitor progressMonitor)", "-\tthrows CoreException", "+\tpublic FileGenerationResult generateFileDuringBuild(IFile parentFile, String typeName, String contents,", "+\t\t\tIProgressMonitor progressMonitor) throws CoreException", "-\t\tif( _skipTypeGeneration ) return null;", "-\t\t// If the generated package fragment root wasn't set,", "-\t\t// then our classpath is incorrect. Add a marker and return", "-\t\telse if( _generatedPackageFragmentRoot == null ){\t\t\t", "-\t\t\tString message = Messages.bind(", "-\t\t\t\t\tMessages.GeneratedFileManager_missing_classpath_entry, ", "-\t\t\t\t\tnew String[] {_snapshotFolderName});", "+\t\tif (_skipTypeGeneration)", "+\t\t\treturn null;", "+\t\t", "+\t\tGeneratedPackageFragmentRoot.NameAndRoot gpfr = _generatedPackageFragmentRoot.get();", "+\t\tIPackageFragmentRoot root = gpfr.root;", "+\t\tif (root == null) {", "+\t\t\t// If the generated package fragment root wasn't set, then our classpath ", "+\t\t\t// is incorrect. Add a marker and return.  We do this here, rather than in", "+\t\t\t// the set() method, because if they're not going to generate any types", "+\t\t\t// then it doesn't matter that the classpath is wrong.", "+\t\t\tString message = Messages.bind(Messages.GeneratedFileManager_missing_classpath_entry,", "+\t\t\t\t\tnew String[] { gpfr.name });", "-\t\t\tmarker.setAttributes(", "-\t\t\t\t\tnew String[] {", "-\t\t\t\t\t\tIMarker.MESSAGE, ", "-\t\t\t\t\t\tIMarker.SEVERITY", "-\t\t\t\t\t},", "-\t\t\t\t\tnew Object[] {", "-\t\t\t\t\t\tmessage,", "-\t\t\t\t\t\tIMarker.SEVERITY_ERROR", "-\t\t\t\t\t}", "-\t\t\t\t);", "+\t\t\tmarker.setAttributes(new String[] { IMarker.MESSAGE, IMarker.SEVERITY }, new Object[] { message,", "+\t\t\t\t\tIMarker.SEVERITY_ERROR });", "-\t\t", "-\t\ttry{", "-\t\t\t", "-\t\t\tif( typeName.indexOf('/') != -1 )", "-\t\t\t\ttypeName = typeName.replace('/', '.');", "-\t\t\tint separatorIndex = typeName.lastIndexOf('.');\t\t\t", "-\t\t\tfinal String typeSimpleName;", "-\t\t\tfinal String pkgName;", "-\t\t\tif( separatorIndex == -1 ){", "-\t\t\t\tpkgName = \"\"; //$NON-NLS-1$", "-\t\t\t\ttypeSimpleName = typeName;", "-\t\t\t}", "-\t\t\telse{", "-\t\t\t\tpkgName = typeName.substring(0, separatorIndex);", "-\t\t\t\ttypeSimpleName = typeName.substring(separatorIndex + 1, typeName.length());", "-\t\t\t}", "-\t\t\t", "-\t\t\t// NOTE: Do NOT ever create any type of resource (files, folders) through the", "-\t\t\t// resource API. The resource change event will not go out until the build", "-\t\t\t// is completed. Instead always go through the JavaModel. -theodora", "-\t\t\tIFolder genSrcFolder = (IFolder)_generatedPackageFragmentRoot.getResource();", "-\t\t\tfinal Set<IContainer> newFolders = getNewPackageFolders(pkgName, genSrcFolder);", "-\t\t\tIPackageFragment pkgFrag = _generatedPackageFragmentRoot.createPackageFragment(pkgName, true, progressMonitor);", "-\t\t\tif( pkgFrag == null ){", "-\t\t\t\tfinal Exception e = new IllegalStateException(\"failed to locate package '\" + pkgName + \"'\");  //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\te.printStackTrace();", "-\t\t\t\tthrow e;", "-\t\t\t}\t\t\t", "-\t\t\t// mark all newly create folders as derived.\t\t\t", "-\t\t\tmarkNewFoldersAsDerived((IContainer)pkgFrag.getResource(), newFolders);", "-\t\t\t", "-\t\t\tfinal String cuName = typeSimpleName + \".java\"; //$NON-NLS-1$", "-\t\t\t", "-\t\t\tICompilationUnit unit = pkgFrag.getCompilationUnit(cuName);", "-\t\t\tIFile file = (IFile)unit.getResource();", "-\t\t\tboolean contentsDiffer = true;", "-\t\t\tif (unit.exists()) {", "-\t\t\t\tInputStream oldData = null;", "-\t\t\t\tInputStream is = null;", "-\t\t\t\ttry {", "-\t\t\t\t\tis = new ByteArrayInputStream( contents.getBytes() );", "-\t\t\t\t\toldData = new BufferedInputStream( ((IFile)unit.getResource()).getContents());", "-\t\t\t\t\tcontentsDiffer = !FileSystemUtil.compareStreams(oldData, is);", "-\t\t\t\t}", "-\t\t\t\tcatch (CoreException ce) {", "-\t\t\t\t\t// Do nothing. Assume the new content is different", "-\t\t\t\t}", "-\t\t\t\tfinally {", "-\t\t\t\t\tif (oldData != null) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\toldData.close();", "-\t\t\t\t\t\t} ", "-\t\t\t\t\t\tcatch (IOException ioe) ", "-\t\t\t\t\t\t{}", "-\t\t\t\t\t}", "-\t\t\t\t\tif (is != null) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\tis.close();", "-\t\t\t\t\t\t} ", "-\t\t\t\t\t\tcatch (IOException ioe) ", "-\t\t\t\t\t\t{}", "+\t\t// Do the new contents differ from what is already on disk?", "+\t\t// We need to know so we can tell the caller whether this is a modification.", "+\t\tIFile file = getIFileForTypeName(typeName);", "+\t\tboolean contentsDiffer = compareFileContents(contents, file);", "+", "+\t\ttry {", "+\t\t\tif (contentsDiffer) {", "+\t\t\t\tfinal String[] names = parseTypeName(typeName);", "+\t\t\t\tfinal String pkgName = names[0];", "+\t\t\t\tfinal String cuName = names[1];", "+\t\t\t\t", "+\t\t\t\t// Get a list of the folders that will have to be created for this package to exist", "+\t\t\t\tIFolder genSrcFolder = (IFolder) root.getResource();", "+\t\t\t\tfinal Set<IFolder> newFolders = computeNewPackageFolders(pkgName, genSrcFolder);", "+\t", "+\t\t\t\t// Create the package fragment in the Java Model.  This creates all needed parent folders.", "+\t\t\t\tIPackageFragment pkgFrag = _CUHELPER.createPackageFragment(pkgName, root, progressMonitor);", "+\t", "+\t\t\t\t// Mark all newly created folders (but not pre-existing ones) as derived.  ", "+\t\t\t\tfor (IContainer folder : newFolders) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\tfolder.setDerived(true);", "+\t\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\t\tAptPlugin.logWarning(e, \"Unable to mark generated type folder as derived: \" + folder.getName()); //$NON-NLS-1$", "+\t\t\t\t\t\tbreak;", "-\t\t\t}\t", "-\t\t\t", "-\t\t\tif( contentsDiffer ){", "-\t\t\t\tif( unit.exists() && unit.isOpen() ){", "-\t\t\t\t\t// directly modify the content of the working copy", "-\t\t\t\t\t// so that UI will pick up the change.", "-\t\t\t\t\tIBuffer buffer = unit.getBuffer();", "-\t\t\t\t\tif (buffer == null){", "-\t\t\t\t\t\tthrow new IllegalStateException(\"Unable to update unit for \" + cuName); //$NON-NLS-1$", "-\t\t\t\t\t\t", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.setContents(contents.toCharArray());", "-\t\t\t\t\tbuffer.save(progressMonitor, true);", "-\t\t\t\t}", "-\t\t\t\telse{", "-\t\t\t\t\tICompilationUnit newUnit = null;", "-\t\t\t\t\tnewUnit = pkgFrag.createCompilationUnit(cuName, contents, true,", "-\t\t\t\t\t\t\tprogressMonitor);", "-\t\t\t\t\tif( newUnit == null ) {\t\t\t\t", "-\t\t\t\t\t\tthrow new IllegalStateException(\"Unable to create unit for \" + cuName); //$NON-NLS-1$", "-\t\t\t\t\t}", "-\t\t\t\t\tif( AptPlugin.DEBUG )", "-\t\t\t\t\t\tAptPlugin.trace(\"generated \" + typeName ); //$NON-NLS-1$", "-\t\t\t\t\tnewUnit.save(progressMonitor, true);", "-\t\t\t\t}", "+\t", "+\t\t\t\t// Save the compilation unit to disk.  How this is done depends on current state.", "+\t\t\t\tsaveCompilationUnit(pkgFrag, cuName, contents, progressMonitor);", "-\t\t\t", "+", "+\t\t\t// during a batch build, parentFile will be null.", "+\t\t\t// Only keep track of ownership in iterative builds", "+\t\t\tif (parentFile != null) {", "+\t\t\t\taddBuiltFileToMaps(parentFile, file);", "+\t\t\t}", "+", "-\t\t\t// deleted this file before we get here, so if the file doesn't exist,", "-\t\t\t// marking it derived throws a ResourceException", "+\t\t\t// deleted this file before we get here, so if the file doesn't", "+\t\t\t// exist, marking it derived throws a ResourceException.", "-\t\t\t", "-\t\t\t// during a batch build, parentFile will be null.", "-\t\t\t// Only keep track of ownership in iterative builds", "-\t\t\tif( parentFile != null ) {", "-\t\t\t\taddEntryToFileMaps( parentFile, file );", "-\t\t\t}", "+", "+\t\t\tassert checkIntegrity();", "+", "+\t\t} catch (CoreException e) {", "+\t\t\tAptPlugin.log(e, \"Unable to generate type \" + typeName); //$NON-NLS-1$", "+\t\t\treturn null;", "-\t\tcatch(Throwable e){", "-\t\t\tAptPlugin.log(e, \"(2)failed to generate type \" + typeName); //$NON-NLS-1$", "-\t\t\te.printStackTrace();", "-\t\t}", "-\t\treturn null; // something failed. The catch block have already logged the error.", "-\t}\t", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "54f7df3c6c3e76047c200137e481b2fc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope)", "signatureAfterChange": " \tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope)", "diff": ["-\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope) {", "-\t\tif (!invocation.innersNeedUpdate())", "+\tpublic static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope) {", "+\t\tMethodBinding candidateMethod = method.isValidBinding() ? method : method instanceof ProblemMethodBinding ? ((ProblemMethodBinding) method).closestMatch : null;", "+\t\tif (candidateMethod == null)", "-\t\tint problemReason = 0;", "-\t\tMethodBinding candidateMethod;", "-\t\tif (methodBinding.isValidBinding()) {", "-\t\t\tcandidateMethod = methodBinding;", "-\t\t} else if (methodBinding instanceof ProblemMethodBinding) {", "-\t\t\tproblemReason = methodBinding.problemId();", "-\t\t\tcandidateMethod = ((ProblemMethodBinding) methodBinding).closestMatch;", "-\t\t} else {", "-\t\t\tcandidateMethod = null;", "-\t\t}", "-\t\tif (candidateMethod != null) {", "-\t\t\tboolean variableArity = candidateMethod.isVarargs();", "-\t\t\tInferenceContext18 infCtx = null;", "-\t\t\tif (candidateMethod instanceof ParameterizedMethodBinding) {", "-\t\t\t\tinfCtx = invocation.getInferenceContext((ParameterizedMethodBinding) candidateMethod);", "-\t\t\t\tif (infCtx != null) {", "-\t\t\t\t\tif (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {", "-\t\t\t\t\t\t// only work in the exact state of TYPE_INFERRED", "-\t\t\t\t\t\t// - below we're not yet ready", "-\t\t\t\t\t\t// - above we're already done-done", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t}", "-\t\t\t\t\tvariableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?", "-\t\t\t\t}", "-\t\t\t} else if (invocation instanceof AllocationExpression) {", "-\t\t\t\tif (((AllocationExpression)invocation).suspendedResolutionState != null)", "-\t\t\t\t\treturn; // not yet ready", "-\t\t\t}", "-\t\t\t", "-\t\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "-\t\t\tExpression[] innerArguments = invocation.arguments();", "-\t\t\tExpression [] arguments = innerArguments;", "-\t\t\tif (infCtx == null && variableArity && arguments != null && parameters.length == arguments.length) { // re-check", "-\t\t\t\tTypeBinding lastParam = parameters[parameters.length-1];", "-\t\t\t\tExpression lastArg = arguments[arguments.length-1];", "-\t\t\t\tif (lastArg.isCompatibleWith(lastParam, null)) {", "-\t\t\t\t\tvariableArity = false;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "-\t\t\t\tExpression argument = arguments[i];", "-\t\t\t\tTypeBinding updatedArgumentType = null;", "-\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "-\t\t\t\tif (parameterType == null && problemReason != ProblemReasons.NoError)", "-\t\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "-", "-\t\t\t\tif (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())", "-\t\t\t\t\tcontinue; // don't update if inner poly has errors", "-", "-\t\t\t\tif (argument instanceof Invocation) {", "-\t\t\t\t\tInvocation innerInvocation = (Invocation)argument;", "-\t\t\t\t\tMethodBinding binding = innerInvocation.binding(parameterType, true, scope);", "-\t\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "-\t\t\t\t\t\tParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;", "-\t\t\t\t\t\tInferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);", "-\t\t\t\t\t\tif (innerContext != null) {", "-\t\t\t\t\t\t\tif (!innerContext.hasResultFor(parameterType)) {", "-\t\t\t\t\t\t\t\targument.setExpectedType(parameterType);", "-\t\t\t\t\t\t\t\tMethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);", "-\t\t\t\t\t\t\t\tif (!improvedBinding.isValidBinding()) {", "-\t\t\t\t\t\t\t\t\tinnerContext.reportInvalidInvocation(innerInvocation, improvedBinding);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\tif (innerInvocation.updateBindings(improvedBinding, parameterType)) {", "-\t\t\t\t\t\t\t\t\tresolvePolyExpressionArguments(innerInvocation, improvedBinding, scope);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {", "-\t\t\t\t\t\t\t\tinnerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue; // otherwise these have been dealt with during inner method lookup", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\tif (argument.isPolyExpression()) {", "-\t\t\t\t\t// poly expressions in an invocation context may need to be resolved now:", "-\t\t\t\t\tif (infCtx != null && infCtx.stepCompleted == InferenceContext18.BINDINGS_UPDATED)", "-\t\t\t\t\t\tupdatedArgumentType = argument.resolvedType; // in this case argument was already resolved via InferenceContext18.acceptPendingPolyArguments()", "-\t\t\t\t\telse", "-\t\t\t\t\t\tupdatedArgumentType = argument.checkAgainstFinalTargetType(parameterType, scope);", "-", "-\t\t\t\t\tif (problemReason == ProblemReasons.NoError // preserve errors", "-\t\t\t\t\t\t\t&& updatedArgumentType != null\t\t\t\t\t// do we have a relevant update? ...", "-\t\t\t\t\t\t\t&& !(updatedArgumentType instanceof PolyTypeBinding))", "-\t\t\t\t\t{", "-\t\t\t\t\t\t// update the argumentTypes array (supposed to be owned by the calling method)", "-\t\t\t\t\t\t// in order to give better information for subsequent checks", "-\t\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\tboolean variableArity = candidateMethod.isVarargs();", "+\t\tfinal TypeBinding[] parameters = candidateMethod.parameters;", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tif (variableArity && arguments != null && parameters.length == arguments.length) {", "+\t\t\tif (arguments[arguments.length-1].isCompatibleWith(parameters[parameters.length-1], scope)) {", "+\t\t\t\tvariableArity = false;", "-\t\tinvocation.innerUpdateDone();", "-\t}", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\tif (parameterType == null)", "+\t\t\t\tcontinue; // not much we can do without a target type, assume it only happens after some resolve error", "+\t\t\tif (argumentTypes[i].isPolyType()) {", "+\t\t\t\targument.setExpectedType(parameterType);", "+\t\t\t\tTypeBinding updatedArgumentType = argument.resolveType(scope); ", "+\t\t\t\tif (argument instanceof LambdaExpression) {", "+\t\t\t\t\t// LE.resolveType may return a valid binding because resolve does not detect structural errors at this point.", "+\t\t\t\t\tLambdaExpression lambda = (LambdaExpression) argument;", "+\t\t\t\t\tif (!lambda.isCompatibleWith(parameterType, scope) || lambda.hasErrors())", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t}", "+\t\t\t\tif (updatedArgumentType != null && updatedArgumentType.kind() != Binding.POLY_TYPE)", "+\t\t\t\t\targumentTypes[i] = updatedArgumentType;", "+\t\t\t}"]}], "num": 18021}