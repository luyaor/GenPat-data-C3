{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8ecbe8e3c5a2f16aec755d033553aa2a", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2144577cc3b334545f5ecb4bd442ca7f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "9ee78f50bb7fb9d70095ea7ff2d9f2e27d840c37", "commitAfterChange": "b6410432af18704990f18fa69a09dd7a76e8fb04", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " protected int refineAccuracy(int accuracy, TypeBinding[] argumentsBinding, MatchLocator locator, char[][] patternArguments, boolean hasTypeParameters)", "signatureAfterChange": " protected void updateMatch(TypeBinding[] argumentsBinding, MatchLocator locator, char[][] patternArguments, boolean hasTypeParameters)", "diff": ["-protected int refineAccuracy(int accuracy, TypeBinding[] argumentsBinding, MatchLocator locator, char[][] patternArguments, boolean hasTypeParameters) {", "-\t// We can only refine if locator has an unit scope.", "-\tif (locator.unitScope == null) return accuracy;", "+ */", "+protected void updateMatch(TypeBinding[] argumentsBinding, MatchLocator locator, char[][] patternArguments, boolean hasTypeParameters) {", "+\t// Only possible if locator has an unit scope.", "+\tif (locator.unitScope == null) return;", "-\tint refinedAccuracy =  accuracy;", "+", "+\t// Initialize match rule", "+\tint matchRule = match.getRule();", "+\tif (match.isRaw()) {", "+\t\tif (patternTypeArgsLength != 0) {", "+\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "+\t\t}", "+\t}", "+\tif (hasTypeParameters) {", "+\t\tmatchRule = SearchPattern.R_ERASURE_MATCH;", "+\t}", "+\t", "+\t// Compare arguments lengthes", "-\t\tif (patternTypeArgsLength == 0) {", "-\t\t\tif (hasTypeParameters) { // raw source type pattern is always compatible erasure...", "-\t\t\t\tif (refinedAccuracy <= SearchMatch.A_INACCURATE) // ...except if accuracy has been already refined", "-\t\t\t\t\trefinedAccuracy |= RAW_MASK;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tif (hasTypeParameters) {", "-\t\t\t\t// parameterized source type pattern is always an incompatible erasure match", "-\t\t\t\trefinedAccuracy |= SearchPattern.R_ERASURE_MATCH;", "-\t\t\t\trefinedAccuracy &= ~SearchPattern.R_EQUIVALENT_MATCH;", "-\t\t\t}", "+\t\tif (!match.isRaw() && hasTypeParameters) {", "+\t\t\t// generic patterns are always not compatible match", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+\t\t\treturn;", "-\t\tif (patternTypeArgsLength==0) { // raw pattern", "-\t\t\t// if valid type arguments, then it is always compatible erasure except if accuracy has been already refined", "-\t\t\tif (refinedAccuracy <= SearchMatch.A_INACCURATE) {", "-\t\t\t\trefinedAccuracy |= RAW_MASK;", "+\t\tif (patternTypeArgsLength==0) {", "+\t\t\tif (!match.isRaw() || hasTypeParameters) {", "+\t\t\t\tmatch.setRule(matchRule & ~SearchPattern.R_FULL_MATCH);", "-\t\t\treturn refinedAccuracy;", "-\t\t} else  if (typeArgumentsLength==0) { // raw binding", "-\t\t\t// then it is always compatible erasure except if accuracy has been already refined", "-\t\t\tif (refinedAccuracy <= SearchMatch.A_INACCURATE)", "-\t\t\t\trefinedAccuracy |= RAW_MASK;", "-\t\t\treturn refinedAccuracy;", "+\t\t} else  if (typeArgumentsLength==0) {", "+\t\t\t// raw binding is always compatible", "+\t\t\tmatch.setRule(matchRule & ~SearchPattern.R_FULL_MATCH);", "+\t\t} else {", "+\t\t\tmatch.setRule(0); // impossible match", "-\t\treturn -1;", "+\t\treturn;", "-\tif (!hasTypeParameters) {", "+\tif (!hasTypeParameters && !match.isRaw() && (match.isEquivalent() || match.isExact())) {", "-\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\trefinedAccuracy |= SearchPattern.R_ERASURE_MATCH;", "+\t\t\t\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+\t\t\t\t\t\treturn;", "-\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\t\t\t\t\t\tif (refinedAccuracy < SearchPattern.R_ERASURE_MATCH) refinedAccuracy |= SearchPattern.R_EQUIVALENT_MATCH;", "+\t\t\t\t\t\t\t\tmatchRule &= ~SearchPattern.R_FULL_MATCH;", "-\t\t\treturn SearchPattern.R_ERASURE_MATCH;", "+\t\t\tmatch.setRule(SearchPattern.R_ERASURE_MATCH);", "+\t\t\treturn;", "-\t// Return refined accuracy", "-\treturn refinedAccuracy;", "+\t// Set match rule", "+\tmatch.setRule(matchRule);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bae7287180ceae0f8c008641b3a2fbc1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java", "commitBeforeChange": "b9853bf41cff827b9d9db35c185e2e1a189aee4a", "commitAfterChange": "35e826e1adf840e339aa800d2a004ceb418099b6", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": "\r public Object getWrappedConstantValue() throws ClassFormatException", "signatureAfterChange": "\r public Object getWrappedConstantValue() throws ClassFormatException", "diff": ["-\tint attributesCount = u2At(6);\r", "-\tint readOffset = 8;\r", "-\tfor (int i = 0; i < attributesCount; i++) {\r", "-\t\tint utf8Offset = constantPoolOffsets[u2At(8)] - structOffset;\r", "-\t\tchar[] attributeName = utf8At(utf8Offset + 3, u2At(utf8Offset + 1));\r", "-\t\tif (CharOperation\r", "-\t\t\t.equals(attributeName, ConstantValueName)) {\r", "-\t\t\t// read the right constant\r", "-\t\t\tint relativeOffset = constantPoolOffsets[u2At(14)] - structOffset;\r", "-\t\t\tswitch (u1At(relativeOffset)) {\r", "-\t\t\t\tcase IntegerTag :\r", "-\t\t\t\t\treturn new Integer(i4At(relativeOffset + 1));\r", "-\t\t\t\tcase FloatTag :\r", "-\t\t\t\t\treturn new Float(floatAt(relativeOffset + 1));\r", "-\t\t\t\tcase DoubleTag :\r", "-\t\t\t\t\treturn new Double(doubleAt(relativeOffset + 1));\r", "-\t\t\t\tcase LongTag :\r", "-\t\t\t\t\treturn new Long(i8At(relativeOffset + 1));\r", "-\t\t\t\tcase StringTag :\r", "-\t\t\t\t\tutf8Offset = constantPoolOffsets[u2At(relativeOffset + 1)] - structOffset;\r", "-\t\t\t\t\treturn String.valueOf(utf8At(utf8Offset + 3, u2At(utf8Offset + 1)));\r", "+\tif (this.wrappedConstantValue == null) {\r", "+\t\tif (hasConstant()) {\r", "+\t\t\tConstant constant = getConstant();\r", "+\t\t\tswitch (constant.typeID()) {\r", "+\t\t\t\tcase T_int :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Integer(constant.intValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_byte :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Byte(constant.byteValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_short :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Short(constant.shortValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_char :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Character(constant.charValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_float :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Float(constant.floatValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_double :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Double(constant.doubleValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_boolean :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Boolean(constant.booleanValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_long :\r", "+\t\t\t\t\tthis.wrappedConstantValue = new Long(constant.longValue());\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\tcase T_String :\r", "+\t\t\t\t\tthis.wrappedConstantValue = constant.stringValue();\r", "-\t\treadOffset += (6 + u4At(readOffset + 2));\r", "-\treturn null;\r", "+\treturn this.wrappedConstantValue;\r"]}], "num": 17558}