{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7021a82959850d998d6c859535ff80c6", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2d4dd3813e7ac2568eebdafbef3be5d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/CompilationResult.java", "commitBeforeChange": "1924cfa5e4209a8742be0104afe1beaad86d0922", "commitAfterChange": "dfe897878a3115c90160783084107f96dcd301be", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 3, "signatureBeforeChange": " \t \tpublic void suppressRecordedWarnings(int sourceStart, int sourceEnd, ProblemReporter problemReporter)", "signatureAfterChange": "  \tpublic void discardSuppressedWarnings()", "diff": ["+\tpublic void discardSuppressedWarnings() {", "+", "+\t\tif (this.suppressWarningsCount == 0) return;", "+\t\tint removed = 0;", "+\t\tnextProblem: for (int i = 0, length = this.problemCount; i < length; i++) {", "+\t\t\tIProblem problem = this.problems[i];", "+\t\t\tif (!problem.isWarning()) ", "+\t\t\t\tcontinue nextProblem;", "+\t\t\tint start = problem.getSourceStart();", "+\t\t\tint end = problem.getSourceEnd();", "+\t\t\tint problemID = problem.getID();", "+\t\t\tnextSuppress: for (int j = 0, max = this.suppressWarningsCount; j < max; j++) {", "+\t\t\t\tlong position = this.suppressWarningPositions[j];", "+\t\t\t\tint startSuppress = (int) (position >>> 32);", "+\t\t\t\tint endSuppress = (int) position;", "+\t\t\t\tif (start < startSuppress) continue nextSuppress;", "+\t\t\t\tif (end > endSuppress) continue nextSuppress;", "+\t\t\t\tif ((ProblemReporter.getIrritant(problemID) & this.suppressWarningIrritants[j]) == 0)", "+\t\t\t\t\tcontinue nextSuppress;", "+\t\t\t\t// discard suppressed warning", "+\t\t\t\tremoved++;", "+\t\t\t\tproblems[i] = null;", "+\t\t\t\tif (problemsMap != null) problemsMap.remove(problem);", "+\t\t\t\tcontinue nextProblem;", "+\t\t\t}", "+\t\t}", "+\t\tif (removed > 0) {", "+\t\t\tfor (int i = 0, index = 0; i < this.problemCount; i++) {", "+\t\t\t\tIProblem problem;", "+\t\t\t\tif ((problem = this.problems[i]) != null) {", "+\t\t\t\t\tif (i > index) {", "+\t\t\t\t\t\tthis.problems[index++] = problem;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tindex++;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.problemCount -= removed;", "+\t\t}", "+\t}", "-\t", "-\tpublic void suppressRecordedWarnings(int sourceStart, int sourceEnd, ProblemReporter problemReporter) {", "-\t\tint removed = 0;", "-\t\tint index = 0;", "-\t\tfor (int i = 0, length = this.problemCount; i < length; i++) {", "-\t\t\tIProblem problem = this.problems[i];", "-\t\t\tif (problem.isWarning() && problem.getSourceStart() >= sourceStart && problem.getSourceEnd() <= sourceEnd) {", "-\t\t\t\tif (problemReporter.computeSeverity(problem.getID()) == ProblemSeverities.Ignore) {", "-\t\t\t\t\tremoved++;", "-\t\t\t\t\tproblems[i] = null;", "-\t\t\t\t\tproblemsMap.remove(problem);", "-\t\t\t\t}", "-\t\t\t} else if (i > index) {", "-\t\t\t\tproblems[index++] = problem;", "-\t\t\t} else {", "-\t\t\t\tindex++;", "-\t\t\t}", "-\t\t}", "-\t\tthis.problemCount -= removed;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc8f4e45bed9363b663dc877c722d2f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "78c62e3a4157070f714848f4de312a55f14f5144", "commitAfterChange": "fb48e11da0ebe84c63fab7b3cb5afd39c0ba6101", "methodNumberBeforeChange": 68, "methodNumberAfterChange": 69, "signatureBeforeChange": " \tprivate TypeBinding minimalErasedCandidate(TypeBinding[] types, List invocations)", "signatureAfterChange": " \tprivate TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations)", "diff": ["-\tprivate TypeBinding minimalErasedCandidate(TypeBinding[] types, List invocations) {", "-\t\tMap allInvocations = new HashMap(2);", "+\tprivate TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations) {", "-\t\t\tcase 0: return VoidBinding;", "-\t\t\tcase 1: return types[indexOfFirst];", "+\t\t\tcase 0: return NoTypes;", "+\t\t\tcase 1: return types;", "-\t\t\tsuperTypes = new TypeBinding[] {", "+\t\t\tsuperTypes = new TypeBinding[] { // inject well-known array supertypes", "-\t\t\t\tArrayList someInvocations = new ArrayList(1);", "+\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "+\t\t\t\t// inject super interfaces prior to superclass", "-\t\t\t\t\t\t\tArrayList someInvocations = new ArrayList(1);", "+\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "+\t\t\t\tTypeBinding itsSuperclass = currentType.superclass();", "-\t\t\t\t\t\t\tArrayList someInvocations = new ArrayList(1);", "+\t\t\t\t\t\t\tSet someInvocations = new HashSet(1);", "-\t\t", "+\t\t// intersecting first type supertypes with other types' ones, nullifying non matching supertypes", "-\t\t\tif (otherType == null)", "-\t\t\t\tcontinue nextOtherType;", "-\t\t\telse if (otherType.isArrayType()) {", "+\t\t\tif (otherType == null) continue nextOtherType;", "+\t\t\tif (otherType.isArrayType()) {", "-\t\t\t\tif (otherRefType.erasure().isCompatibleWith(superType)) {", "-\t\t\t\t\tTypeBinding match = otherRefType.findSuperTypeErasingTo((ReferenceBinding)superType);", "-\t\t\t\t\t\tif (match != null && match.erasure() != match) { // match can be null: interface.findSuperTypeErasingTo(Object)", "-\t\t\t\t\t\t\tArrayList someInvocations = (ArrayList) allInvocations.get(superType);", "-\t\t\t\t\t\t\tif (someInvocations == null) someInvocations = new ArrayList(1);", "-\t\t\t\t\t\t\tsomeInvocations.add(match);", "-\t\t\t\t\t\t\tallInvocations.put(superType, someInvocations);", "-\t\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t\tbreak nextSuperType;", "+\t\t\t\tTypeBinding match;", "+\t\t\t\tif (superType == otherType || superType.id == T_JavaLangObject && otherType.isInterface()) {", "+\t\t\t\t\tmatch = superType;", "-\t\t\t\t\tsuperTypes[j] = null;", "-\t\t\t\t\tif (--remaining == 0) return null;", "+\t\t\t\t\tif (superType.isArrayType()) {", "+\t\t\t\t\t\tmatch = null;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tmatch = otherRefType.findSuperTypeErasingTo((ReferenceBinding)superType);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (match == null) { // incompatible super type", "+\t\t\t\t\t\tsuperTypes[j] = null;", "+\t\t\t\t\t\tif (--remaining == 0) return null;", "+\t\t\t\t\t\tcontinue nextSuperType;", "+\t\t\t\t\t}", "+\t\t\t\t// record invocation", "+\t\t\t\tSet someInvocations = (Set) allInvocations.get(superType);", "+\t\t\t\tif (someInvocations == null) someInvocations = new HashSet(1);", "+\t\t\t\tsomeInvocations.add(match);", "+\t\t\t\tallInvocations.put(superType, someInvocations);", "-\t\t// per construction, first non-null supertype is most specific common supertype", "-\t\tfor (int i = 0; i < superLength; i++) {", "-\t\t\tTypeBinding superType = superTypes[i];", "-\t\t\tif (superType != null) {", "-\t\t\t\tList matchingInvocations = (List)allInvocations.get(superType);", "-\t\t\t\tif (matchingInvocations != null) invocations.addAll(matchingInvocations);", "-\t\t\t\treturn superType;", "+\t\t// eliminate non minimal super types", "+\t\tif (remaining > 1) {", "+\t\t\tnextType: for (int i = 0; i < superLength; i++) {", "+\t\t\t\tReferenceBinding superType = (ReferenceBinding)superTypes[i];", "+\t\t\t\tif (superType == null) continue nextType;", "+\t\t\t\tnextOtherType: for (int j = 0; j < superLength; j++) {", "+\t\t\t\t\tif (i == j) continue nextOtherType;", "+\t\t\t\t\tReferenceBinding otherType = (ReferenceBinding)superTypes[j];", "+\t\t\t\t\tif (otherType == null) continue nextOtherType;", "+\t\t\t\t\tif (otherType.id == T_JavaLangObject && superType.isInterface()) continue nextOtherType;", "+\t\t\t\t\tif (superType.findSuperTypeErasingTo(otherType) != null) {", "+\t\t\t\t\t\tsuperTypes[j] = null; // discard non minimal supertype", "+\t\t\t\t\t\tremaining--;", "+\t\t\t\t\t}", "+\t\t\t\t}", "-\t\treturn null;", "+\t\treturn superTypes;"]}], "num": 6387}