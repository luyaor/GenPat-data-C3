{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2db50210cfcf97bd1534bbb80aeb81c1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f9b5f3e60c0ed3ed8238ff3c650d58d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b1909bb0c4bbb70fecea5345c2e954fa4204b1dd", "commitAfterChange": "1ef42230a28632657bfac5df1d197b6d35dcc83d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tprivate static TypeBinding[] resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, TypeBinding[] substitutes, boolean considerEXTENDSConstraints, Map collectedSubstitutes)", "signatureAfterChange": " \t \tprivate static boolean resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, InferenceContext inferenceContext, boolean considerEXTENDSConstraints)", "diff": ["-\tprivate static TypeBinding[] resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, TypeBinding[] substitutes, boolean considerEXTENDSConstraints, Map collectedSubstitutes) {", "-\t\tif (collectedSubstitutes.isEmpty()) {", "-\t\t\t// raw generic method inferred", "-\t\t\treturn Binding.NO_TYPES; // empty array", "-\t\t}", "+\tprivate static boolean resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, InferenceContext inferenceContext, boolean considerEXTENDSConstraints) {", "+\t\tTypeBinding[] substitutes = inferenceContext.substitutes;", "-\t\t", "-\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\tTypeBinding [] equalSubstitutes = variableSubstitutes[CONSTRAINT_EQUAL];", "+\t\t\t\tTypeBinding [] equalSubstitutes = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_EQUAL);", "-\t\tif (hasUnresolvedTypeArgument(substitutes)) {", "+\t\tif (inferenceContext.hasUnresolvedTypeArgument()) {", "-\t\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\t\tTypeBinding [] bounds = variableSubstitutes[CONSTRAINT_SUPER];", "+\t\t\t\t\tTypeBinding [] bounds = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\tif (mostSpecificSubstitute == null)", "-\t\t\t\t\t\treturn null; // incompatible", "+\t\t\t\t\tif (mostSpecificSubstitute == null) {", "+\t\t\t\t\t\treturn false; // incompatible", "+\t\t\t\t\t}", "-\t\tif (considerEXTENDSConstraints && hasUnresolvedTypeArgument(substitutes)) {", "+\t\tif (considerEXTENDSConstraints && inferenceContext.hasUnresolvedTypeArgument()) {", "-\t\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\t\tTypeBinding [] bounds = variableSubstitutes[CONSTRAINT_EXTENDS];", "+\t\t\t\t\tTypeBinding [] bounds = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\treturn substitutes;", "+\t\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f337ce9604e16440979dd5362efea4f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "f908d0c09b5bf34a0f6e90dacd8d551c0f19870c", "commitAfterChange": "2d9e2019b5b59684e0488ab5bab1ae5850c1ca71", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "signatureAfterChange": " \tprivate ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes)", "diff": ["-\t\t\t    returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t    this.returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\tboolean argAlreadyInferred = argument != originalVariable;", "-\t\t\t\t\tScope.substitute(this, originalVariable.firstBound) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\t// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)", "+\t\t\t\t\t//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "-\t\t\t\t\tScope.substitute(this, originalVariable.superInterfaces[j]) // substitue original bound with resolved variables", "-\t\t\t\t\t\t.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);", "+\t\t\t\t\tTypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);", "+\t\t\t\t\targument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);", "+\t\t\t\t\t// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference", "+\t\t\t\t\tif (argAlreadyInferred)", "+\t\t\t\t\t\tsubstitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);"]}], "num": 41406}