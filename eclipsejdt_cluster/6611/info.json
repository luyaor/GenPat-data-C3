{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "25bce9e1b6807cb0e6dbdb78b5d3764d", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cb096b25f92d852193578720d6144596", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "diff": ["-\r", "-\tprivate void findMethods(\r", "-\t\tchar[] methodName,\r", "-\t\tTypeBinding[] argTypes,\r", "-\t\tMethodBinding[] methods,\r", "-\t\tScope scope,\r", "-\t\tObjectVector methodsFound,\r", "-\t//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\t\tboolean exactMatch,\r", "-\t\tTypeBinding receiverType,\r", "-\t\tInvocationSite invocationSite) {\r", "-\r", "-\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint methodLength = methodName.length;\r", "-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding method = methods[f];\r", "-\t\t\tif (method.isConstructor())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (exactMatch) {\r", "-\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t} else {\r", "-\t\t\t\tif (methodLength > method.selector.length)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "-\t\t\t\t\t/* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t}\r", "-\t\t\tif (minArgLength > method.parameters.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\t\tif (method == otherMethod)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "-\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (method\r", "-\t\t\t\t\t\t\t.declaringClass\r", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tmethodsFound.add(method);\r", "-\t\t\tint length = method.parameters.length;\r", "-\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (!exactMatch) {\r", "-\t\t\t\tif (source != null\r", "-\t\t\t\t\t&& source.length > endPosition\r", "-\t\t\t\t\t&& source[endPosition] == '(')\r", "-\t\t\t\t\tcompletion = method.selector;\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "-\t\t\t}\r", "-\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\tmethod.selector,\r", "-\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\t\tmethod.modifiers,\r", "+\r", "+private void findMethods(\r", "+\tchar[] methodName,\r", "+\tTypeBinding[] argTypes,\r", "+\tMethodBinding[] methods,\r", "+\tScope scope,\r", "+\tObjectVector methodsFound,\r", "+//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\tboolean exactMatch) {\r", "+\r", "+\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint methodLength = methodName.length;\r", "+\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\tMethodBinding method = methods[f];\r", "+\t\tif (method.isConstructor()) continue next;\r", "+//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "+\t\tif (exactMatch) {\r", "+\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t} else {\r", "+\t\t\tif (methodLength > method.selector.length) continue next;\r", "+\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t}\r", "+\t\tif (minArgLength > method.parameters.length) continue next;\r", "+\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "+\r", "+\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\tif (method == otherMethod) continue next;\r", "+\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "+\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tmethodsFound.add(method);\r", "+\t\tint length = method.parameters.length;\r", "+\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t}\r", "+\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\tif (!exactMatch) {\r", "+\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "+\t\t\t\tcompletion = method.selector;\r", "+\t\t\telse\r", "+\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "+\t\t}\r", "+\t\trequestor.acceptMethod(\r", "+\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\tmethod.selector,\r", "+\t\t\tparameterPackageNames,\r", "+\t\t\tparameterTypeNames,\r", "+\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\tcompletion,\r", "+\t\t\tmethod.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d0647d1e913255eeea26b6a77ff10c2d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "diff": ["-\r", "-\tprivate void findMethods(\r", "-\t\tchar[] methodName,\r", "-\t\tTypeBinding[] argTypes,\r", "-\t\tMethodBinding[] methods,\r", "-\t\tScope scope,\r", "-\t\tObjectVector methodsFound,\r", "-\t//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\t\tboolean exactMatch,\r", "-\t\tTypeBinding receiverType,\r", "-\t\tInvocationSite invocationSite) {\r", "-\r", "-\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint methodLength = methodName.length;\r", "-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding method = methods[f];\r", "-\t\t\tif (method.isConstructor())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (exactMatch) {\r", "-\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t} else {\r", "-\t\t\t\tif (methodLength > method.selector.length)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "-\t\t\t\t\t/* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t}\r", "-\t\t\tif (minArgLength > method.parameters.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\t\tif (method == otherMethod)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "-\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (method\r", "-\t\t\t\t\t\t\t.declaringClass\r", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tmethodsFound.add(method);\r", "-\t\t\tint length = method.parameters.length;\r", "-\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (!exactMatch) {\r", "-\t\t\t\tif (source != null\r", "-\t\t\t\t\t&& source.length > endPosition\r", "-\t\t\t\t\t&& source[endPosition] == '(')\r", "-\t\t\t\t\tcompletion = method.selector;\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "-\t\t\t}\r", "-\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\tmethod.selector,\r", "-\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\t\tmethod.modifiers,\r", "+\r", "+private void findMethods(\r", "+\tchar[] methodName,\r", "+\tTypeBinding[] argTypes,\r", "+\tMethodBinding[] methods,\r", "+\tScope scope,\r", "+\tObjectVector methodsFound,\r", "+//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\tboolean exactMatch) {\r", "+\r", "+\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint methodLength = methodName.length;\r", "+\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\tMethodBinding method = methods[f];\r", "+\t\tif (method.isConstructor()) continue next;\r", "+//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "+\t\tif (exactMatch) {\r", "+\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t} else {\r", "+\t\t\tif (methodLength > method.selector.length) continue next;\r", "+\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t}\r", "+\t\tif (minArgLength > method.parameters.length) continue next;\r", "+\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "+\r", "+\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\tif (method == otherMethod) continue next;\r", "+\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "+\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tmethodsFound.add(method);\r", "+\t\tint length = method.parameters.length;\r", "+\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t}\r", "+\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\tif (!exactMatch) {\r", "+\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "+\t\t\t\tcompletion = method.selector;\r", "+\t\t\telse\r", "+\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "+\t\t}\r", "+\t\trequestor.acceptMethod(\r", "+\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\tmethod.selector,\r", "+\t\t\tparameterPackageNames,\r", "+\t\t\tparameterTypeNames,\r", "+\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\tcompletion,\r", "+\t\t\tmethod.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "da43cc05a268bba741759483476cebca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "diff": ["-\r", "-\tprivate void findMethods(\r", "-\t\tchar[] methodName,\r", "-\t\tTypeBinding[] argTypes,\r", "-\t\tMethodBinding[] methods,\r", "-\t\tScope scope,\r", "-\t\tObjectVector methodsFound,\r", "-\t//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\t\tboolean exactMatch,\r", "-\t\tTypeBinding receiverType,\r", "-\t\tInvocationSite invocationSite) {\r", "-\r", "-\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint methodLength = methodName.length;\r", "-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding method = methods[f];\r", "-\t\t\tif (method.isConstructor())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (exactMatch) {\r", "-\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t} else {\r", "-\t\t\t\tif (methodLength > method.selector.length)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "-\t\t\t\t\t/* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t}\r", "-\t\t\tif (minArgLength > method.parameters.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\t\tif (method == otherMethod)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "-\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (method\r", "-\t\t\t\t\t\t\t.declaringClass\r", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tmethodsFound.add(method);\r", "-\t\t\tint length = method.parameters.length;\r", "-\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (!exactMatch) {\r", "-\t\t\t\tif (source != null\r", "-\t\t\t\t\t&& source.length > endPosition\r", "-\t\t\t\t\t&& source[endPosition] == '(')\r", "-\t\t\t\t\tcompletion = method.selector;\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "-\t\t\t}\r", "-\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\tmethod.selector,\r", "-\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\t\tmethod.modifiers,\r", "+\r", "+private void findMethods(\r", "+\tchar[] methodName,\r", "+\tTypeBinding[] argTypes,\r", "+\tMethodBinding[] methods,\r", "+\tScope scope,\r", "+\tObjectVector methodsFound,\r", "+//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\tboolean exactMatch) {\r", "+\r", "+\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint methodLength = methodName.length;\r", "+\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\tMethodBinding method = methods[f];\r", "+\t\tif (method.isConstructor()) continue next;\r", "+//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "+\t\tif (exactMatch) {\r", "+\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t} else {\r", "+\t\t\tif (methodLength > method.selector.length) continue next;\r", "+\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t}\r", "+\t\tif (minArgLength > method.parameters.length) continue next;\r", "+\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "+\r", "+\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\tif (method == otherMethod) continue next;\r", "+\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "+\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tmethodsFound.add(method);\r", "+\t\tint length = method.parameters.length;\r", "+\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t}\r", "+\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\tif (!exactMatch) {\r", "+\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "+\t\t\t\tcompletion = method.selector;\r", "+\t\t\telse\r", "+\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "+\t\t}\r", "+\t\trequestor.acceptMethod(\r", "+\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\tmethod.selector,\r", "+\t\t\tparameterPackageNames,\r", "+\t\t\tparameterTypeNames,\r", "+\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\tcompletion,\r", "+\t\t\tmethod.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dc75109c0ca9f7c7a8d0a7e272fb01f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": "\r \r \tprivate void findMethods(\r \t\tchar[] methodName,\r \t\tTypeBinding[] argTypes,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType,\r \t\tInvocationSite invocationSite)", "signatureAfterChange": "\r \r private void findMethods(\r \tchar[] methodName,\r \tTypeBinding[] argTypes,\r \tMethodBinding[] methods,\r \tScope scope,\r \tObjectVector methodsFound,\r \tboolean onlyStaticMethods,\r \tboolean exactMatch)", "diff": ["-\r", "-\tprivate void findMethods(\r", "-\t\tchar[] methodName,\r", "-\t\tTypeBinding[] argTypes,\r", "-\t\tMethodBinding[] methods,\r", "-\t\tScope scope,\r", "-\t\tObjectVector methodsFound,\r", "-\t//\tboolean noVoidReturnType, how do you know?\r", "-\tboolean onlyStaticMethods,\r", "-\t\tboolean exactMatch,\r", "-\t\tTypeBinding receiverType,\r", "-\t\tInvocationSite invocationSite) {\r", "-\r", "-\t\t// Inherited methods which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint methodLength = methodName.length;\r", "-\t\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "-\t\tnext : for (int f = methods.length; --f >= 0;) {\r", "-\t\t\tMethodBinding method = methods[f];\r", "-\t\t\tif (method.isConstructor())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "-\t\t\tif (onlyStaticMethods && !method.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !method.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (exactMatch) {\r", "-\t\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t} else {\r", "-\t\t\t\tif (methodLength > method.selector.length)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false\r", "-\t\t\t\t\t/* ignore case */\r", "-\t\t\t\t\t))\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t}\r", "-\t\t\tif (minArgLength > method.parameters.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a]))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "-\t\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "-\t\t\t\tif (method == otherMethod)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true)\r", "-\t\t\t\t\t&& method.areParametersEqual(otherMethod)) {\r", "-\t\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (method\r", "-\t\t\t\t\t\t\t.declaringClass\r", "-\t\t\t\t\t\t\t.implementsInterface(otherMethod.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tmethodsFound.add(method);\r", "-\t\t\tint length = method.parameters.length;\r", "-\t\t\tchar[][] parameterPackageNames = new char[length][];\r", "-\t\t\tchar[][] parameterTypeNames = new char[length][];\r", "-\t\t\tfor (int i = 0; i < length; i++) {\r", "-\t\t\t\tTypeBinding type = method.parameters[i];\r", "-\t\t\tchar[] completion = TypeConstants.NoChar;\r", "-\t\t\t// nothing to insert - do not want to replace the existing selector & arguments\r", "-\t\t\tif (!exactMatch) {\r", "-\t\t\t\tif (source != null\r", "-\t\t\t\t\t&& source.length > endPosition\r", "-\t\t\t\t\t&& source[endPosition] == '(')\r", "-\t\t\t\t\tcompletion = method.selector;\r", "-\t\t\t\telse\r", "-\t\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] { '(', ')' });\r", "-\t\t\t}\r", "-\t\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\tmethod.selector,\r", "-\t\t\t\tmethod.returnType.qualifiedPackageName(),\r", "-\t\t\t\tmethod.returnType.qualifiedSourceName(),\r", "-\t\t\t\tmethod.modifiers,\r", "+\r", "+private void findMethods(\r", "+\tchar[] methodName,\r", "+\tTypeBinding[] argTypes,\r", "+\tMethodBinding[] methods,\r", "+\tScope scope,\r", "+\tObjectVector methodsFound,\r", "+//\tboolean noVoidReturnType, how do you know?\r", "+\tboolean onlyStaticMethods,\r", "+\tboolean exactMatch) {\r", "+\r", "+\t// Inherited methods which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint methodLength = methodName.length;\r", "+\tint minArgLength = argTypes == null ? 0 : argTypes.length;\r", "+\tnext : for (int f = methods.length; --f >= 0;) {\r", "+\t\tMethodBinding method = methods[f];\r", "+\t\tif (method.isConstructor()) continue next;\r", "+//\t\tif (noVoidReturnType && method.returnType == BaseTypes.VoidBinding) continue next;\r", "+\t\tif (onlyStaticMethods && !method.isStatic()) continue next;\r", "+\t\tif (exactMatch) {\r", "+\t\t\tif (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t} else {\r", "+\t\t\tif (methodLength > method.selector.length) continue next;\r", "+\t\t\tif (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)) continue next;\r", "+\t\t}\r", "+\t\tif (minArgLength > method.parameters.length) continue next;\r", "+\t\tfor (int a = minArgLength; --a >= 0;)\r", "+\t\t\tif (argTypes[a] != null) // can be null if it could not be resolved properly\r", "+\t\t\t\tif (!scope.areTypesCompatible(argTypes[a], method.parameters[a])) continue next;\r", "+\r", "+\t\tfor (int i = methodsFound.size; --i >= 0;) {\r", "+\t\t\tMethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);\r", "+\t\t\tif (method == otherMethod) continue next;\r", "+\t\t\tif (CharOperation.equals(method.selector, otherMethod.selector, true) && method.areParametersEqual(otherMethod)) {\r", "+\t\t\t\tif (method.declaringClass.isSuperclassOf(otherMethod.declaringClass)) continue next;\r", "+\t\t\t\tif (otherMethod.declaringClass.isInterface())\r", "+\t\t\t\t\tif (method.declaringClass.implementsInterface(otherMethod.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tmethodsFound.add(method);\r", "+\t\tint length = method.parameters.length;\r", "+\t\tchar[][] parameterPackageNames = new char[length][];\r", "+\t\tchar[][] parameterTypeNames = new char[length][];\r", "+\t\tfor (int i = 0; i < length; i++) {\r", "+\t\t\tTypeBinding type = method.parameters[i];\r", "+\t\t\tparameterPackageNames[i] = type.qualifiedPackageName();\r", "+\t\t\tparameterTypeNames[i] = type.qualifiedSourceName();\r", "+\t\t}\r", "+\t\tchar[] completion = TypeConstants.NoChar; // nothing to insert - do not want to replace the existing selector & arguments\r", "+\t\tif (!exactMatch) {\r", "+\t\t\tif (source != null && source.length > endPosition && source[endPosition] == '(')\r", "+\t\t\t\tcompletion = method.selector;\r", "+\t\t\telse\r", "+\t\t\t\tcompletion = CharOperation.concat(method.selector, new char[] {'(', ')'});\r", "+\t\t}\r", "+\t\trequestor.acceptMethod(\r", "+\t\t\tmethod.declaringClass.qualifiedPackageName(),\r", "+\t\t\tmethod.declaringClass.qualifiedSourceName(),\r", "+\t\t\tmethod.selector,\r", "+\t\t\tparameterPackageNames,\r", "+\t\t\tparameterTypeNames,\r", "+\t\t\tmethod.returnType.qualifiedPackageName(),\r", "+\t\t\tmethod.returnType.qualifiedSourceName(),\r", "+\t\t\tcompletion,\r", "+\t\t\tmethod.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}], "num": 6611}