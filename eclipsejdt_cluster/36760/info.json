{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cefe7f63ea73063c287988f621cac2a1", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0021469beda484e6a8ee7b9378976103", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java", "commitBeforeChange": "0241b6a034ef8fa4f27f3bd260b936d3f2c0aea7", "commitAfterChange": "99074098c6405e18b1f1a04aabe7c2838c777448", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\tthis.preAssertInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);", "+", "+\tConstant cst = this.assertExpression.optimizedBooleanConstant();", "+\tboolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+", "+\tFlowInfo conditionFlowInfo = this.assertExpression.analyseCode(currentScope, flowContext, flowInfo.copy());", "+\tUnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();", "+\tFlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();", "+\tif (isOptimizedTrueAssertion) {", "+\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\tif (this.exceptionArgument != null) {", "+\t\t// only gets evaluated when escaping - results are not taken into account", "+\t\tFlowInfo exceptionInfo = this.exceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy());", "-", "-\tpublic FlowInfo analyseCode(", "-\t\tBlockScope currentScope,", "-\t\tFlowContext flowContext,", "-\t\tFlowInfo flowInfo) {", "-", "-\t\tthis.preAssertInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);", "-", "-\t\tConstant cst = this.assertExpression.optimizedBooleanConstant();", "-\t\tboolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-", "-\t\tFlowInfo assertRawInfo = this.assertExpression.", "-\t\t\tanalyseCode(currentScope, flowContext, flowInfo.copy());", "-\t\tUnconditionalFlowInfo assertWhenTrueInfo = assertRawInfo.initsWhenTrue().", "-\t\t\tunconditionalInits();", "-\t\tUnconditionalFlowInfo assertInfo = assertRawInfo.unconditionalCopy();", "-\t\tif (isOptimizedTrueAssertion) {", "-\t\t\tassertInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-", "-\t\tif (this.exceptionArgument != null) {", "-\t\t\t// only gets evaluated when escaping - results are not taken into account", "-\t\t\tFlowInfo exceptionInfo = this.exceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy());", "-", "-\t\t\tif (isOptimizedTrueAssertion){", "-\t\t\t\tcurrentScope.problemReporter().fakeReachable(this.exceptionArgument);", "-\t\t\t} else {", "-\t\t\t\tflowContext.checkExceptionHandlers(", "-\t\t\t\t\tcurrentScope.getJavaLangAssertionError(),", "-\t\t\t\t\tthis,", "-\t\t\t\t\texceptionInfo,", "-\t\t\t\t\tcurrentScope);", "-\t\t\t}", "-\t\t}", "-", "-\t\tif (!isOptimizedTrueAssertion){", "-\t\t\t// add the assert support in the clinit", "-\t\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo);", "-\t\t}", "-\t\tif (isOptimizedFalseAssertion) {", "-\t\t\treturn flowInfo; // if assertions are enabled, the following code will be unreachable", "-\t\t\t// change this if we need to carry null analysis results of the assert", "-\t\t\t// expression downstream", "+\t\tif (isOptimizedTrueAssertion){", "+\t\t\tcurrentScope.problemReporter().fakeReachable(this.exceptionArgument);", "-\t\t\treturn flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "-\t\t\t\taddInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());", "-\t\t\t// keep the merge from the initial code for the definite assignment", "-\t\t\t// analysis, tweak the null part to influence nulls downstream", "+\t\t\tflowContext.checkExceptionHandlers(", "+\t\t\t\tcurrentScope.getJavaLangAssertionError(),", "+\t\t\t\tthis,", "+\t\t\t\texceptionInfo,", "+\t\t\t\tcurrentScope);", "+\tif (!isOptimizedTrueAssertion){", "+\t\t// add the assert support in the clinit", "+\t\tmanageSyntheticAccessIfNecessary(currentScope, flowInfo);", "+\tif (isOptimizedFalseAssertion) {", "+\t\treturn flowInfo; // if assertions are enabled, the following code will be unreachable", "+\t\t// change this if we need to carry null analysis results of the assert", "+\t\t// expression downstream", "+\t} else {", "+\t\treturn flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).", "+\t\t\taddInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());", "+\t\t// keep the merge from the initial code for the definite assignment", "+\t\t// analysis, tweak the null part to influence nulls downstream", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0256ae0a4ba6ff0143fb6edc36939ff", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "8e80deae1f046ae4551ba19254abdddd2b23044c", "commitAfterChange": "20ab4653c81b813fd48f74b27ae8af07488f3d49", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tConstant cst = this.condition.constant;", "-\t\tboolean isConditionTrue = cst != NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionFalse = cst != NotAConstant && cst.booleanValue() == false;", "-", "-\t\tcst = this.condition.optimizedBooleanConstant();", "+\t\tConstant cst = this.condition.optimizedBooleanConstant();", "+\t\tint mode = flowInfo.reachMode();", "-", "-\t\tif (isConditionTrue) {", "-\t\t\t// TRUE ? left : right", "-\t\t\tFlowInfo resultInfo =", "-\t\t\t\tvalueIfTrue.analyseCode(currentScope, flowContext, flowInfo.initsWhenTrue().unconditionalInits());", "-\t\t\t// analyse valueIfFalse, but do not take into account any of its infos", "-\t\t\tvalueIfFalse.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo.initsWhenFalse().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));", "-\t\t\tmergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(resultInfo);", "-\t\t\treturn resultInfo;", "-\t\t} else if (isConditionFalse) {", "-\t\t\t// FALSE ? left : right", "-\t\t\t// analyse valueIfTrue, but do not take into account any of its infos\t\t\t", "-\t\t\tvalueIfTrue.analyseCode(", "-\t\t\t\tcurrentScope,", "-\t\t\t\tflowContext,", "-\t\t\t\tflowInfo.initsWhenTrue().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));", "-\t\t\tFlowInfo mergeInfo =", "-\t\t\t\tvalueIfFalse.analyseCode(currentScope, flowContext, flowInfo.initsWhenFalse().unconditionalInits());", "-\t\t\tmergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergeInfo);", "-\t\t\treturn mergeInfo;", "-\t\t}", "-", "-\t\t// propagate analysis", "-\t\tFlowInfo trueInfo = flowInfo.initsWhenTrue().copy();", "-\t\tint mode = trueInfo.reachMode();", "-\t\tif (isConditionOptimizedFalse) trueInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "-\t\tthenInitStateIndex = currentScope.methodScope().recordInitializationStates(trueInfo);", "-\t\ttrueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo);", "-\t\ttrueInfo.setReachMode(mode);", "-\t\tFlowInfo falseInfo = flowInfo.initsWhenFalse().copy();", "-\t\tmode = falseInfo.reachMode();", "-\t\tif (isConditionOptimizedTrue) falseInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "-\t\telseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseInfo);", "-\t\tfalseInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseInfo);", "-\t\tfalseInfo.setReachMode(mode);", "+\t\t// process the if-true part", "+\t\tFlowInfo trueFlowInfo = flowInfo.initsWhenTrue().copy();", "+\t\tif (isConditionOptimizedFalse) trueFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+\t\ttrueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);", "+\t\ttrueFlowInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueFlowInfo);", "+\t\t// process the if-false part", "+\t\tFlowInfo falseFlowInfo = flowInfo.initsWhenFalse().copy();", "+\t\tif (isConditionOptimizedTrue) falseFlowInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);", "+\t\tfalseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseFlowInfo);", "+\t\tfalseFlowInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseFlowInfo);", "-\t\t// merge using a conditional info -  1GK2BLM", "-\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "-\t\tFlowInfo mergedInfo =", "-\t\t\tFlowInfo.conditional(", "-\t\t\t\ttrueInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "-\t\t\t\t\tfalseInfo.initsWhenTrue().copy().unconditionalInits()),", "-\t\t\t\ttrueInfo.initsWhenFalse().unconditionalInits().mergedWith(", "-\t\t\t\t\tfalseInfo.initsWhenFalse().unconditionalInits()));", "-", "-\t\t// store a copy of the merged info, so as to compute the local variable attributes afterwards", "+\t\t// merge if-true & if-false initializations", "+\t\tFlowInfo mergedInfo;", "+\t\tif (isConditionOptimizedTrue){", "+\t\t\tmergedInfo = trueFlowInfo;", "+\t\t} else if (isConditionOptimizedFalse) {", "+\t\t\tmergedInfo = falseFlowInfo;", "+\t\t} else {", "+\t\t\t// merge using a conditional info -  1GK2BLM", "+\t\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "+\t\t\tmergedInfo =", "+\t\t\t\tFlowInfo.conditional(", "+\t\t\t\t\ttrueFlowInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...", "+\t\t\t\t\t\tfalseFlowInfo.initsWhenTrue().copy().unconditionalInits()),", "+\t\t\t\t\ttrueFlowInfo.initsWhenFalse().unconditionalInits().mergedWith(", "+\t\t\t\t\t\tfalseFlowInfo.initsWhenFalse().unconditionalInits()));", "+\t\t}", "+\t\tmergedInfo.setReachMode(mode);"]}], "num": 36760}