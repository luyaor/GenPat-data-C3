{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "00b557d9cde577997a8d77c62e6d17fb", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4a5e422254ba7e0e66d008b3d18dc721", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java", "commitBeforeChange": "1585d95aacd546d0fef8e25ddee2f5a6f64f7c62", "commitAfterChange": "bcf6d39cea27ed7bf3bf85709bd7e60dc5605058", "methodNumberBeforeChange": 92, "methodNumberAfterChange": 92, "signatureBeforeChange": " public void generateConstant(Constant constant, int implicitConversionCode)", "signatureAfterChange": " public void generateConstant(Constant constant, int implicitConversionCode)", "diff": ["-\tint targetTypeID = implicitConversionCode >> 4;", "-\tswitch (targetTypeID) {", "-\t\tcase T_boolean :", "-\t\t\tgenerateInlinedValue(constant.booleanValue());", "-\t\t\tbreak;", "-\t\tcase T_char :", "-\t\t\tgenerateInlinedValue(constant.charValue());", "-\t\t\tbreak;", "-\t\tcase T_byte :", "-\t\t\tgenerateInlinedValue(constant.byteValue());", "-\t\t\tbreak;", "-\t\tcase T_short :", "-\t\t\tgenerateInlinedValue(constant.shortValue());", "-\t\t\tbreak;", "-\t\tcase T_int :", "-\t\t\tgenerateInlinedValue(constant.intValue());", "-\t\t\tbreak;", "-\t\tcase T_long :", "-\t\t\tgenerateInlinedValue(constant.longValue());", "-\t\t\tbreak;", "-\t\tcase T_float :", "-\t\t\tgenerateInlinedValue(constant.floatValue());", "-\t\t\tbreak;", "-\t\tcase T_double :", "-\t\t\tgenerateInlinedValue(constant.doubleValue());", "-\t\t\tbreak;", "-\t\tdefault : //String or Object", "-\t\t\tldc(constant.stringValue());", "+\tif ((implicitConversionCode & BOXING) != 0) {", "+\t\t// need to box the constant", "+\t\tfinal int typeId = implicitConversionCode & IMPLICIT_CONVERSION_MASK;", "+\t\tswitch (typeId) {", "+\t\t\tcase T_JavaLangBoolean :", "+\t\t\t\tgenerateInlinedValue(constant.booleanValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangCharacter :", "+\t\t\t\tgenerateInlinedValue(constant.charValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangByte :", "+\t\t\t\tgenerateInlinedValue(constant.byteValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangShort :", "+\t\t\t\tgenerateInlinedValue(constant.shortValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangInteger :", "+\t\t\t\tgenerateInlinedValue(constant.intValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangLong :", "+\t\t\t\tgenerateInlinedValue(constant.longValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangFloat :", "+\t\t\t\tgenerateInlinedValue(constant.floatValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_JavaLangDouble :", "+\t\t\t\tgenerateInlinedValue(constant.doubleValue());", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t// need boxing", "+\t\tgenerateBoxingConversion(typeId);", "+\t\treturn;", "+\t}", "+\t", "+\t// FIXME (olivier) how can this ever occur ? unboxing a primitive type constant ?!?", "+\tif ((implicitConversionCode & UNBOXING) != 0) {", "+\t\t// need to unbox the constant", "+\t\tfinal int typeId = implicitConversionCode & COMPILE_TYPE_MASK;", "+\t\tswitch (typeId) {", "+\t\t\tcase T_boolean :", "+\t\t\t\tgenerateInlinedValue(constant.booleanValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_char :", "+\t\t\t\tgenerateInlinedValue(constant.charValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_byte :", "+\t\t\t\tgenerateInlinedValue(constant.byteValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_short :", "+\t\t\t\tgenerateInlinedValue(constant.shortValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_int :", "+\t\t\t\tgenerateInlinedValue(constant.intValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_long :", "+\t\t\t\tgenerateInlinedValue(constant.longValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_float :", "+\t\t\t\tgenerateInlinedValue(constant.floatValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_double :", "+\t\t\t\tgenerateInlinedValue(constant.doubleValue());", "+\t\t\t\tbreak;", "+\t\t}", "+\t\t// need unboxing", "+\t\tgenerateUnboxingConversion(typeId);", "+\t}", "+\tint targetTypeID = (implicitConversionCode & IMPLICIT_CONVERSION_MASK) >> 4;", "+\tif (targetTypeID != 0) {", "+\t\tswitch (targetTypeID) {", "+\t\t\tcase T_boolean :", "+\t\t\t\tgenerateInlinedValue(constant.booleanValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_char :", "+\t\t\t\tgenerateInlinedValue(constant.charValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_byte :", "+\t\t\t\tgenerateInlinedValue(constant.byteValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_short :", "+\t\t\t\tgenerateInlinedValue(constant.shortValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_int :", "+\t\t\t\tgenerateInlinedValue(constant.intValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_long :", "+\t\t\t\tgenerateInlinedValue(constant.longValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_float :", "+\t\t\t\tgenerateInlinedValue(constant.floatValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_double :", "+\t\t\t\tgenerateInlinedValue(constant.doubleValue());", "+\t\t\t\tbreak;", "+\t\t\tcase T_String :", "+\t\t\t\tldc(constant.stringValue());", "+\t\t}", "+\t} else {", "+\t\tldc(constant.stringValue());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b31362f77165bdd5a158e00454e9796a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/Signature.java", "commitBeforeChange": "3b5e3bffb50578beec025e97315d017361527518", "commitAfterChange": "5c86bd5e83cfca7ff5f98996f0b172644cacbee7", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 26, "signatureBeforeChange": "\r public static char[] toCharArray(char[] signature) throws IllegalArgumentException", "signatureAfterChange": "\r public static char[] toCharArray(char[] signature) throws IllegalArgumentException", "diff": ["-\treturn toString(new String(signature)).toCharArray();\r", "+\ttry {\r", "+\t\tint sigLength = signature.length;\r", "+\r", "+\t\tif (sigLength == 0 || signature[0] == C_PARAM_START) {\r", "+\t\t\treturn toCharArray(signature, NO_CHAR, null, true, true);\r", "+\t\t}\r", "+\t\t\r", "+\t\t// compute result length\r", "+\t\tint resultLength = 0;\r", "+\t\tint index = -1;\r", "+\t\twhile (signature[++index] == C_ARRAY) {\r", "+\t\t\tresultLength += 2; // []\r", "+\t\t}\r", "+\t\tswitch (signature[index]) {\r", "+\t\t\tcase C_BOOLEAN :\r", "+\t\t\t\tresultLength += BOOLEAN.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_BYTE :\r", "+\t\t\t\tresultLength += BYTE.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_CHAR :\r", "+\t\t\t\tresultLength += CHAR.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_DOUBLE :\r", "+\t\t\t\tresultLength += DOUBLE.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_FLOAT :\r", "+\t\t\t\tresultLength += FLOAT.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_INT :\r", "+\t\t\t\tresultLength += INT.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_LONG :\r", "+\t\t\t\tresultLength += LONG.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_SHORT :\r", "+\t\t\t\tresultLength += SHORT.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_VOID :\r", "+\t\t\t\tresultLength += VOID.length;\r", "+\t\t\t\tbreak;\r", "+\t\t\tcase C_RESOLVED :\r", "+\t\t\tcase C_UNRESOLVED :\r", "+\t\t\t\tint end = CharOperation.indexOf(C_SEMICOLON, signature, index);\r", "+\t\t\t\tif (end == -1) throw new IllegalArgumentException();\r", "+\t\t\t\tint start = index + 1;\r", "+\t\t\t\tresultLength += end-start;\r", "+\t\t\t\tbreak;\r", "+\t\t\tdefault :\r", "+\t\t\t\tthrow new IllegalArgumentException();\r", "+\t\t}\r", "+\t\t\r", "+\t\tchar[] result = new char[resultLength];\r", "+\t\tcopyType(signature, 0, result, 0, true);\r", "+\r", "+\t\t/**\r", "+\t\t * Converts '$' separated type signatures into '.' separated type signature.\r", "+\t\t * NOTE: This assumes that the type signature is an inner type signature.\r", "+\t\t *       This is true in most cases, but someone can define a non-inner type \r", "+\t\t *       name containing a '$'. However to tell the difference, we would have\r", "+\t\t *       to resolve the signature, which cannot be done at this point.\r", "+\t\t */\r", "+\t\tCharOperation.replace(result, C_DOLLAR, C_DOT);\r", "+\r", "+\t\treturn result;\r", "+\t} catch (ArrayIndexOutOfBoundsException e) {\r", "+\t\tthrow new IllegalArgumentException();\r", "+\t}\t\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fb6b3245523cbab87f962447cbe1fccb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "69b02d68015b1f30ee38d1576a843274517957c7", "commitAfterChange": "c7a9edf536467451ba659d7e03ac6c483c5c0cfe", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 61, "signatureBeforeChange": " protected void consumeToken(int token)", "signatureAfterChange": " protected void consumeToken(int token)", "diff": ["+\t}", "+\tif(canBeExplicitConstructor == NEXTTOKEN) {", "+\t\tcanBeExplicitConstructor = YES;", "+\t} else {", "+\t\tcanBeExplicitConstructor = NO;", "-\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER);", "+\t\t\t\t\tswitch(previous) {", "+\t\t\t\t\t\tcase TokenNameRPAREN :", "+\t\t\t\t\t\t\tswitch(previousKind) {", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_IF_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, IF);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_CATCH_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, CATCH);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_WHILE_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, WHILE);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_SWITCH_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, SWITCH);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_FOR_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, FOR);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tcase K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, SYNCHRONIZED);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER);", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TokenNametry :", "+\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, TRY);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase TokenNamedo:", "+\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER, DO);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\tpushOnElementStack(K_BLOCK_DELIMITER);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "-\t\t\t\tpopElement(K_BETWEEN_CATCH_AND_RIGHT_PAREN);", "+\t\t\t\tswitch(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER)) {", "+\t\t\t\t\tcase K_BETWEEN_CATCH_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tpopElement(K_BETWEEN_CATCH_AND_RIGHT_PAREN);", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_BETWEEN_IF_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_BETWEEN_IF_AND_RIGHT_PAREN);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_BETWEEN_WHILE_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_BETWEEN_WHILE_AND_RIGHT_PAREN);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_BETWEEN_FOR_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_BETWEEN_FOR_AND_RIGHT_PAREN);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_BETWEEN_SWITCH_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_BETWEEN_SWITCH_AND_RIGHT_PAREN);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t}", "-\t\t\t\tif(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_INSIDE_THROW_STATEMENT", "-\t\t\t\t\t&& topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == this.bracketDepth) {", "-\t\t\t\t\tpopElement(K_INSIDE_THROW_STATEMENT);", "-\t\t\t\t} else if (topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_INSIDE_RETURN_STATEMENT", "-\t\t\t\t\t&& topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == this.bracketDepth){", "-\t\t\t\t\tpopElement(K_INSIDE_RETURN_STATEMENT);", "+\t\t\t\tswitch(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER)) {", "+\t\t\t\t\tcase K_INSIDE_THROW_STATEMENT :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == this.bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_INSIDE_THROW_STATEMENT);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_INSIDE_RETURN_STATEMENT :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == this.bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_INSIDE_RETURN_STATEMENT);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tcase K_INSIDE_ASSERT_STATEMENT :", "+\t\t\t\t\t\tif(topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER) == this.bracketDepth) {", "+\t\t\t\t\t\t\tpopElement(K_INSIDE_ASSERT_STATEMENT);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "-\t\t\t", "+\t\t\tcase TokenNameif:", "+\t\t\t\tpushOnElementStack(K_BETWEEN_IF_AND_RIGHT_PAREN, bracketDepth);", "+\t\t\t\tbreak;", "+\t\t\tcase TokenNamewhile:", "+\t\t\t\tpushOnElementStack(K_BETWEEN_WHILE_AND_RIGHT_PAREN, bracketDepth);", "+\t\t\t\tbreak;", "+\t\t\tcase TokenNamefor:", "+\t\t\t\tpushOnElementStack(K_BETWEEN_FOR_AND_RIGHT_PAREN, bracketDepth);", "+\t\t\t\tbreak;", "+\t\t\tcase TokenNameswitch:", "+\t\t\t\tpushOnElementStack(K_BETWEEN_SWITCH_AND_RIGHT_PAREN, bracketDepth);", "+\t\t\t\tbreak;", "+\t\t\tcase TokenNamesynchronized:", "+\t\t\t\tpushOnElementStack(K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN, bracketDepth);", "+\t\t\t\tbreak;", "+\t\t\tcase TokenNameassert:", "+\t\t\t\tpushOnElementStack(K_INSIDE_ASSERT_STATEMENT, this.bracketDepth);", "+\t\t\t\tbreak;"]}], "num": 40518}