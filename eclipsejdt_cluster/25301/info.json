{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2f2bdbe85aec1c9fc010f1f6fca1ed2c", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25ab6125d23148a76cf009b584635609", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "3256aef43e2296affdbf86e21f8cafdaa866161a", "commitAfterChange": "f357f309273e0bfe8345ff708d18fa83c6a34931", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tboolean diamondNeedsDeferring = false;", "-\t\t\tif (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && sourceLevel >= ClassFileConstants.JDK1_8) {", "-\t\t\t\tif (this.resolvedType != null && this.resolvedType.isValidBinding())", "-\t\t\t\t\tdiamondNeedsDeferring = true;", "-\t\t\t}", "-\t} else {", "-\t\tthis.resolvedType = this.type.resolvedType;", "-\t}", "-", "-\tif (this.type != null) {", "-\t\tcheckIllegalNullAnnotation(scope, this.resolvedType);", "-\t\tcheckParameterizedAllocation: {", "-\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "-\t\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "-\t\t\t\tif (currentType == null) return currentType;", "-\t\t\t\tdo {", "-\t\t\t\t\t// isStatic() is answering true for toplevel types", "-\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "-\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "-\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "-\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "-\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "-\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "-\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "-\t\t\t\t\t\tbreak;", "+\t\tif (this.type != null) {", "+\t\t\tcheckIllegalNullAnnotation(scope, this.resolvedType);", "+\t\t\tcheckParameterizedAllocation: {", "+\t\t\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "+\t\t\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "+\t\t\t\t\tif (currentType == null) return currentType;", "+\t\t\t\t\tdo {", "+\t\t\t\t\t\t// isStatic() is answering true for toplevel types", "+\t\t\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "+\t\t\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "+\t\t\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "+\t\t\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "+\t\t\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "+\t\t\t\t\t\tif (qRef.typeArguments[i] != null) {", "+\t\t\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "-\t}", "-\t// will check for null after args are resolved", "+\t\t// will check for null after args are resolved", "-\t// resolve type arguments (for generic constructor call)", "-\tif (this.typeArguments != null) {", "-\t\tint length = this.typeArguments.length;", "-\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "-\t\tthis.genericTypeArguments = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tTypeReference typeReference = this.typeArguments[i];", "-\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "-\t\t\t\tthis.argumentsHaveErrors = true;", "-\t\t\t}", "-\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "-\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\t}", "-\t\t}", "-\t\tif (isDiamond) {", "-\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "-\t\t\treturn null;", "-\t\t}", "-\t\tif (this.argumentsHaveErrors) {", "-\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "-\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "-\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t// resolve type arguments (for generic constructor call)", "+\t\tif (this.typeArguments != null) {", "+\t\t\tint length = this.typeArguments.length;", "+\t\t\tthis.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;", "+\t\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\t\tthis.argumentsHaveErrors = true;", "+\t\t\t\t}", "+\t\t\t\tif (this.argumentsHaveErrors && typeReference instanceof Wildcard) {", "+\t\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "-\t\t\treturn null;", "+\t\t\tif (isDiamond) {", "+\t\t\t\tscope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tif (this.argumentsHaveErrors) {", "+\t\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn null;", "+\t\t\t}", "-\t}", "-\t// buffering the arguments' types", "-\tboolean argsContainCast = false;", "-\tif (this.arguments != null) {", "-\t\tthis.argumentsHaveErrors = false;", "-\t\tint length = this.arguments.length;", "-\t\tthis.argumentTypes = new TypeBinding[length];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tExpression argument = this.arguments[i];", "-\t\t\tif (argument instanceof CastExpression) {", "-\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\t\t\targsContainCast = true;", "+\t\t// buffering the arguments' types", "+\t\tif (this.arguments != null) {", "+\t\t\tthis.argumentsHaveErrors = false;", "+\t\t\tint length = this.arguments.length;", "+\t\t\tthis.argumentTypes = new TypeBinding[length];", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tExpression argument = this.arguments[i];", "+\t\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\t\targument.bits |= DisableUnnecessaryCastCheck; // will check later on", "+\t\t\t\t\tthis.argsContainCast = true;", "+\t\t\t\t}", "+\t\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "+\t\t\t\tif (this.arguments[i].resolvedType != null) ", "+\t\t\t\t\tscope.problemReporter().genericInferenceError(\"Argument was unexpectedly found resolved\", this); //$NON-NLS-1$", "+\t\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {", "+\t\t\t\t\tthis.argumentsHaveErrors = true;", "+\t\t\t\t}", "-\t\t\targument.setExpressionContext(INVOCATION_CONTEXT);", "-\t\t\tif (this.arguments[i].resolvedType != null) ", "-\t\t\t\tscope.problemReporter().genericInferenceError(\"Argument was unexpectedly found resolved\", this); //$NON-NLS-1$", "-\t\t\tif ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {", "-\t\t\t\tthis.argumentsHaveErrors = true;", "-\t\t\t}", "-\t\t\tif (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || ((argument instanceof Invocation) && ((Invocation) argument).usesInference()))) {", "-\t\t\t\tif (this.innerInferenceHelper == null)", "-\t\t\t\t\tthis.innerInferenceHelper = new InnerInferenceHelper();", "-\t\t\t}", "-\t\t}", "-\t\tif (this.argumentsHaveErrors) {", "-\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "+\t\t\tif (this.argumentsHaveErrors) {", "+\t\t\t\t/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.", "-\t\t\t */", "-\t\t\tif (isDiamond) {", "-\t\t\t\treturn null; // not the partially cooked this.resolvedType", "-\t\t\t}", "-\t\t\tif (this.resolvedType instanceof ReferenceBinding) {", "-\t\t\t\t// record a best guess, for clients who need hint about possible constructor match", "-\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "-\t\t\t\tfor (int i = length; --i >= 0;) {", "-\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t */", "+\t\t\t\tif (isDiamond) {", "+\t\t\t\t\treturn null; // not the partially cooked this.resolvedType", "-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);", "-\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "-\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "-\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "-\t\t\t\t\tif (closestMatch != null) {", "-\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "-\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "-\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tthis.binding = closestMatch;", "-\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "-\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "-\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "-\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\tif (this.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\t\t// record a best guess, for clients who need hint about possible constructor match", "+\t\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\tpseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);", "+\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\tif (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t}", "+\t\t\t\treturn this.resolvedType;", "+\t\t}", "+\t\tif (this.resolvedType == null || !this.resolvedType.isValidBinding()) {", "+\t\t\treturn null;", "+\t\t}", "+", "+\t\t// null type denotes fake allocation for enum constant inits", "+\t\tif (this.type != null && !this.resolvedType.canBeInstantiated()) {", "+\t\t\tscope.problemReporter().cannotInstantiate(this.type, this.resolvedType);", "-\t}", "-\tif (this.resolvedType == null || !this.resolvedType.isValidBinding()) {", "-\t\treturn null;", "-\t}", "-", "-\t// null type denotes fake allocation for enum constant inits", "-\tif (this.type != null && !this.resolvedType.canBeInstantiated()) {", "-\t\tscope.problemReporter().cannotInstantiate(this.type, this.resolvedType);", "-\t\treturn this.resolvedType;", "-\t}", "-\tResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, this.argumentTypes);", "-\tif (diamondNeedsDeferring) {", "-\t\tthis.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).", "-\t\treturn new PolyTypeBinding(this);", "-\t}", "-", "-\tif (!resolvePart2(state))", "-\t\treturn null;", "-\treturn resolvePart3(state);", "-}", "+\t\tif (isDiamond) {", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tif (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {", "+\t\t\t\tthis.binding = inferConstructorOfElidedParameterizedType(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\t\tif (this.binding == null) {", "+\t\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\t\treturn this.resolvedType = null;", "+\t\t\t\t}", "+\t\t\t\treturn new PolyTypeBinding(this);", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null) {", "+\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\treturn this.resolvedType = null;", "+\t\t\t}", "+\t\t\tReferenceBinding allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t\tthis.resolvedType = this.type.resolvedType = allocationType; ", "+\t} else {", "+\t\tif (isDiamond) {", "+\t\t\tReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();", "+\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());", "+\t\t\tTypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\t\tif (inferredTypes == null) {", "+\t\t\t\tscope.problemReporter().cannotInferElidedTypes(this);", "+\t\t\t\treturn this.resolvedType = null;", "+\t\t\t}", "+\t\t\tthis.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());", "+\t\t}", "+\t", "+\tthis.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);", "+\t\t", "+\t\tscope.problemReporter().invalidConstructor(this, this.binding);", "+\t\tscope.problemReporter().missingTypeInConstructor(this, this.binding);", "+\tif (isMethodUseDeprecated(this.binding, scope, true)) {", "+\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\tif (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {", "+\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);", "+\tif (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {", "+ \t\tcheckTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);", "+\t\tnew ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)", "+\t\t\t\t.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);", "+\trecordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "26ef7f55a7a892d3d9e1463817f62cc1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "diff": ["+\t\tboolean didSpecifySource = false;", "+\t\t\tif (currentArg.equals(\"-1.5\")) { //$NON-NLS-1$", "+\t\t\t\tif (didSpecifyCompliance) {", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateCompliance\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tdidSpecifyCompliance = true;", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}\t\t\t", "+\t\t\t\t\t} else if (token.equals(\"unsafe\")) {//$NON-NLS-1$ ", "+\t\t\t\t\t\tthis.options.put(", "+\t\t\t\t\t\t\tCompilerOptions.OPTION_ReportUnsafeTypeOperation,", "+\t\t\t\t\t\t\tisEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);", "+\t\t\t\t\t} else if (token.equals(\"finalBound\")) {//$NON-NLS-1$ ", "+\t\t\t\t\t\tthis.options.put(", "+\t\t\t\t\t\t\tCompilerOptions.OPTION_ReportFinalParameterBound,", "+\t\t\t\t\t\t\tisEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);", "-\t\t\t\t\t} else if (token.equals(\"javadoc\")) {//$NON-NLS-1$", "+\t\t\t\t\t} else if (token.equals(\"javadoc\")) {//$NON-NLS-1$ ", "+\t\t\t\tif (didSpecifyTarget) {", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateTarget\", currentArg));//$NON-NLS-1$", "+\t\t\t\t}\t\t\t\t", "-\t\t\t\t\tif (didSpecifyCompliance && CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) <= ClassFileConstants.JDK1_3) {", "-\t\t\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget14\", (String)this.options.get(CompilerOptions.OPTION_Compliance))); //$NON-NLS-1$", "+\t\t\t\t\tif (didSpecifyCompliance && CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_4) {", "+\t\t\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$", "+\t\t\t\t} else if (currentArg.equals(\"1.5\")) { //$NON-NLS-1$", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t\t\tif (didSpecifyCompliance && CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_5) {", "+\t\t\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "+\t\t\t\tif (didSpecifySource) {", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateSource\", currentArg));//$NON-NLS-1$", "+\t\t\t\t}\t\t\t\t", "+\t\t\t\tdidSpecifySource = true;", "+\t\t\t\t} else if (currentArg.equals(\"1.5\")) { //$NON-NLS-1$", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);", "-", "-\t\t// target must be 1.4 if source is 1.4", "-\t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Source)) >= ClassFileConstants.JDK1_4", "-\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform)) < ClassFileConstants.JDK1_4", "-\t\t\t\t&& didSpecifyTarget){ ", "-\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleTargetForSource14\", (String)this.options.get(CompilerOptions.OPTION_TargetPlatform))); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t// target cannot be 1.4 if compliance is 1.3", "-\t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_4", "-\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform)) >= ClassFileConstants.JDK1_4", "-\t\t\t\t&& didSpecifyTarget){ ", "-\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget14\", (String)this.options.get(CompilerOptions.OPTION_Compliance))); //$NON-NLS-1$", "-\t\t}", "-\t\t// check and set compliance/source/target compatibilities", "-\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)){", "-\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);", "-\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\tif (didSpecifyCompliance) {", "+\t\t\tObject version = this.options.get(CompilerOptions.OPTION_Compliance);", "+\t\t\tif (CompilerOptions.VERSION_1_3.equals(version)) {", "+\t\t\t\t\tif (!didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);", "+\t\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_1);", "+\t\t\t} else if (CompilerOptions.VERSION_1_4.equals(version)) {", "+\t\t\t\t\tif (!didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);", "+\t\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(version)) {", "+\t\t\t\t\tif (!didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);", "+\t\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t}", "-\t\t// compliance must be 1.4 if source is 1.4", "-\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)", "-\t\t\t\t&& !this.options.get(CompilerOptions.OPTION_Compliance).equals(CompilerOptions.VERSION_1_4)){ ", "-\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource14\", (String)this.options.get(CompilerOptions.OPTION_Compliance))); //$NON-NLS-1$", "+\t\tif (didSpecifySource) {", "+\t\t\tObject version = this.options.get(CompilerOptions.OPTION_Source);", "+\t\t\t if (CompilerOptions.VERSION_1_4.equals(version)) {", "+\t\t\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);", "+\t\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t} else if (CompilerOptions.VERSION_1_5.equals(version)) {", "+\t\t\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "+\t\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t}", "+\t\t// check and set compliance/source/target compatibilities", "+\t\tif (didSpecifyTarget) {", "+\t\t\t// target must be 1.5 if source is 1.5", "+\t\t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Source)) >= ClassFileConstants.JDK1_5", "+\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform)) < ClassFileConstants.JDK1_5){ ", "+\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleTargetForSource\", (String)this.options.get(CompilerOptions.OPTION_TargetPlatform), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$", "+\t\t\t}", "+\t   \t\t // target must be 1.4 if source is 1.4", "+\t   \t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Source)) >= ClassFileConstants.JDK1_4", "+\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform)) < ClassFileConstants.JDK1_4){ ", "+\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleTargetForSource\", (String)this.options.get(CompilerOptions.OPTION_TargetPlatform), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$", "+\t   \t\t}", "+\t\t\t// target cannot be greater than compliance level", "+\t\t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform))){ ", "+\t\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget\", (String)this.options.get(CompilerOptions.OPTION_Compliance), (String)this.options.get(CompilerOptions.OPTION_TargetPlatform))); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+", "+\t\t// compliance must be 1.5 if source is 1.5", "+\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_5)", "+\t\t\t\t&& !this.options.get(CompilerOptions.OPTION_Compliance).equals(CompilerOptions.VERSION_1_5)){", "+\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$", "+\t\t} else ", "+\t\t\t// compliance must be 1.4 if source is 1.4", "+\t\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)", "+\t\t\t\t&& !this.options.get(CompilerOptions.OPTION_Compliance).equals(CompilerOptions.VERSION_1_4)){ ", "+\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$", "+\t\t}", "+\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Compliance).equals(CompilerOptions.VERSION_1_5)) {", "+\t\t\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_3)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_5)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "39afbcd105f8bdb8cbbf0abf95132a65", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java", "commitBeforeChange": "f09e5b387a9b27a1161db6587b5598aa2acd37a0", "commitAfterChange": "11f5a7cc7c9c65b20b52b279ac1ac913311b9b45", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " public void testWarningAssert()", "signatureAfterChange": " public void testWarningTokens()", "diff": ["-public void testWarningAssert() {", "+public void testWarningTokens() {", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedConstructor));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.OverridingDeprecatedMethod));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedType));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedMethod));", "+\tassertEquals(\"wrong token\", \"deprecation\", CorrectionEngine.getWarningToken(IProblem.UsingDeprecatedField));", "+\tassertEquals(\"wrong token\", \"boxing\", CorrectionEngine.getWarningToken(IProblem.BoxingConversion));", "+\tassertEquals(\"wrong token\", \"boxing\", CorrectionEngine.getWarningToken(IProblem.UnboxingConversion));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.FieldMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.MethodMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"dep-ann\", CorrectionEngine.getWarningToken(IProblem.TypeMissingDeprecatedAnnotation));", "+\tassertEquals(\"wrong token\", \"finally\", CorrectionEngine.getWarningToken(IProblem.FinallyMustCompleteNormally));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.FieldHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.FieldHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.LocalVariableHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.LocalVariableHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.ArgumentHidingLocalVariable));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.ArgumentHidingField));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.MaskedCatch));", "+\tassertEquals(\"wrong token\", \"hiding\", CorrectionEngine.getWarningToken(IProblem.TypeParameterHidingType));", "+\tassertEquals(\"wrong token\", \"nls\", CorrectionEngine.getWarningToken(IProblem.NonExternalizedStringLiteral));", "+\tassertEquals(\"wrong token\", \"incomplete-switch\", CorrectionEngine.getWarningToken(IProblem.MissingEnumConstantCase));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedImport));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.LocalVariableIsNeverUsed));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.ArgumentIsNeverUsed));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateConstructor));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateMethod));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateField));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedPrivateType));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedMethodDeclaredThrownException));", "+\tassertEquals(\"wrong token\", \"unused\", CorrectionEngine.getWarningToken(IProblem.UnusedConstructorDeclaredThrownException));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticMethod));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticField));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.IndirectAccessToStaticType));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.NonStaticAccessToStaticMethod));", "+\tassertEquals(\"wrong token\", \"static-access\", CorrectionEngine.getWarningToken(IProblem.NonStaticAccessToStaticField));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateFieldReadAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateFieldWriteAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateMethodAccess));", "+\tassertEquals(\"wrong token\", \"synthetic-access\", CorrectionEngine.getWarningToken(IProblem.NeedToEmulateConstructorAccess));", "+\tassertEquals(\"wrong token\", \"unqualified-field-access\", CorrectionEngine.getWarningToken(IProblem.UnqualifiedFieldAccess));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawConstructorInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawMethodInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeTypeConversion));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawFieldAssignment));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeGenericCast));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeReturnTypeOverride));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawGenericMethodInvocation));", "+\tassertEquals(\"wrong token\", \"unchecked\", CorrectionEngine.getWarningToken(IProblem.UnsafeRawGenericConstructorInvocation));", "+\tassertEquals(\"wrong token\", \"serial\", CorrectionEngine.getWarningToken(IProblem.MissingSerialVersion));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c559ddf077df1659a6c195e4939eacd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java", "commitBeforeChange": "0692ba5ff15b98317f2a4290688c2b50bed5ba7f", "commitAfterChange": "c1e0d163b88855506518c675888a22f1264cd248", "methodNumberBeforeChange": 60, "methodNumberAfterChange": 60, "signatureBeforeChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "signatureAfterChange": " \tpublic void configure(String[] argv) throws InvalidInputException", "diff": ["-\t\t\t}\t\t\t", "+\t\t\t}", "+\t\t\tif (currentArg.equals(\"-1.6\") || currentArg.equals(\"-6\") || currentArg.equals(\"-6.0\")) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$", "+\t\t\t\tif (didSpecifyCompliance) {", "+\t\t\t\t\tthrow new InvalidInputException(", "+\t\t\t\t\t\tMain.bind(\"configure.duplicateCompliance\", currentArg)); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tdidSpecifyCompliance = true;", "+\t\t\t\tthis.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);", "+\t\t\t\tmode = Default;", "+\t\t\t\tcontinue;", "+\t\t\t}", "+\t\t\t\t} else if (currentArg.equals(\"1.6\") || currentArg.equals(\"6\") || currentArg.equals(\"6.0\")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t\tif (didSpecifyCompliance && CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_6) {", "+\t\t\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForTarget\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);", "+\t\t\t\t} else if (currentArg.equals(\"1.6\") || currentArg.equals(\"6\") || currentArg.equals(\"6.0\")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);", "+\t\t\t} else if (CompilerOptions.VERSION_1_6.equals(version)) {", "+\t\t\t\tif (!didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);", "+\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t} else if (CompilerOptions.VERSION_1_6.equals(version)) {", "+\t\t\t\tif (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);", "+\t\t\t\tif (!didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t// target must be 1.6 if source is 1.6", "+\t\t\tif (CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Source)) >= ClassFileConstants.JDK1_6", "+\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_TargetPlatform)) < ClassFileConstants.JDK1_6){ ", "+\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleTargetForSource\", (String)this.options.get(CompilerOptions.OPTION_TargetPlatform), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$", "+\t\t\t}", "-\t\t// compliance must be 1.5 if source is 1.5", "-\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_5)", "+\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_6)", "+\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_6) {", "+\t\t\t// compliance must be 1.6 if source is 1.6", "+\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$", "+\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_5)", "+\t\t\t// compliance must be 1.5 if source is 1.5", "-\t\t} else ", "+\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)", "+\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_4) {", "-\t\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)", "-\t\t\t\t\t&& CompilerOptions.versionToJdkLevel(this.options.get(CompilerOptions.OPTION_Compliance)) < ClassFileConstants.JDK1_4) { ", "-\t\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$", "+\t\t\tthrow new InvalidInputException(Main.bind(\"configure.incompatibleComplianceForSource\", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$", "+\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Compliance).equals(CompilerOptions.VERSION_1_6)) {", "+\t\t\t\tif (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_3)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_4)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_5)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t\t} else if (this.options.get(CompilerOptions.OPTION_Source).equals(CompilerOptions.VERSION_1_6)) {", "+\t\t\t\t\tthis.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c75790116c0bd29214b7a774f1b906fe", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java", "commitBeforeChange": "d1246b4aff159c8bec10d39c7616aa371724fb25", "commitAfterChange": "3aaa02433bee6eae022db09efeb9fd0aba7da6a0", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 14, "signatureBeforeChange": "  \tprivate void findHeader()", "signatureAfterChange": "  \tprivate void setDefaultCompilerOptions()", "diff": ["-", "-\tprivate void findHeader() {", "-\t\tif (this.astRoot instanceof CompilationUnit) {", "-\t\t\tList<TypeDeclaration> types = ((CompilationUnit) this.astRoot).types();", "-\t\t\tif (!types.isEmpty()) {", "-\t\t\t\tint headerEndIndex = this.tokenManager.firstIndexIn(types.get(0), -1);", "-\t\t\t\tthis.tokenManager.setHeaderEndIndex(headerEndIndex);", "-\t\t\t}", "-\t\t}", "-\t}", "+", "+\tprivate void setDefaultCompilerOptions() {", "+\t\tif (this.defaultCompilerOptions ==  null) {", "+\t\t\tMap optionsMap = new HashMap(30);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_SourceFileAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_MethodParametersAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.PRESERVE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_DocCommentSupport, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportOverridingMethodWithoutSuperInvocation, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedObjectAllocation, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedParameter, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedImport, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportNoEffectAssignment, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportNonExternalizedStringLiteral, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportNoImplicitStringConversion, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportIncompatibleNonInheritedInterfaceMethod, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportLocalVariableHiding, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportFieldHiding, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportPossibleAccidentalBooleanAssignment, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportEmptyStatement, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportAssertIdentifier, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportEnumIdentifier, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUndocumentedEmptyBlock, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportInvalidJavadoc, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportInvalidJavadocTagsVisibility, CompilerOptions.PUBLIC);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportInvalidJavadocTags, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocTagDescription, CompilerOptions.RETURN_TAG);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportInvalidJavadocTagsDeprecatedRef, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportInvalidJavadocTagsNotVisibleRef, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocTags, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility, CompilerOptions.PUBLIC);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocTagsOverriding, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocComments, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocCommentsVisibility, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMissingJavadocCommentsOverriding, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportFinallyBlockNotCompletingNormally, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedDeclaredThrownException, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedDeclaredThrownExceptionWhenOverriding, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnqualifiedFieldAccess, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_TaskTags, Util.EMPTY_STRING);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_TaskPriorities, Util.EMPTY_STRING);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_TaskCaseSensitive, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedParameterWhenImplementingAbstract, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedParameterWhenOverridingConcrete, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportSpecialParameterHidingField, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnavoidableGenericTypeProblems, CompilerOptions.ENABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_MaxProblemPerUnit, String.valueOf(100));", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_InlineJsr, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ShareCommonFinallyBlocks, CompilerOptions.DISABLED);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMethodCanBeStatic, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportMethodCanBePotentiallyStatic, CompilerOptions.IGNORE);", "+\t\t\toptionsMap.put(CompilerOptions.OPTION_ReportUnusedTypeParameter, CompilerOptions.IGNORE);", "+\t\t\tthis.defaultCompilerOptions = optionsMap;", "+\t\t}", "+\t\tObject sourceOption = this.options.get(CompilerOptions.OPTION_Source);", "+\t\tif (sourceOption != null) {", "+\t\t\tthis.defaultCompilerOptions.put(CompilerOptions.OPTION_Source, sourceOption);", "+\t\t} else {", "+\t\t\tthis.defaultCompilerOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d367b8e2b78e89d63450c13a24338e8e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "c7494793aa1ed6a2f75240b5a076591b5a3e9bf6", "commitAfterChange": "54e21838d5d72a577ad5b83bd2ddcc9c60b93259", "methodNumberBeforeChange": 75, "methodNumberAfterChange": 81, "signatureBeforeChange": " \tpublic String loadClasspath() throws JavaModelException", "signatureAfterChange": " \tprotected IClasspathEntry[] readClasspathFile(boolean createMarker, boolean logProblems)", "diff": ["-\t */", "-\tpublic String loadClasspath() throws JavaModelException {", "-\t\ttry {", "-\t\t\treturn getSharedProperty(CLASSPATH_FILENAME);", "-\t\t} catch (CoreException e) {", "-\t\t\tthrow new JavaModelException(e);", "-\t\t}", "-\t}", "+\tprotected IClasspathEntry[] readClasspathFile(boolean createMarker, boolean logProblems) {", "+\t\ttry {", "+\t\t\tString xmlClasspath = getSharedProperty(CLASSPATH_FILENAME);", "+\t\t\tif (xmlClasspath == null) return null;", "+\t\t\tStringReader reader = new StringReader(xmlClasspath);", "+\t\t\tElement cpElement;", "+\t", "+\t\t\ttry {", "+\t\t\t\tDocumentBuilder parser =", "+\t\t\t\t\tDocumentBuilderFactory.newInstance().newDocumentBuilder();", "+\t\t\t\tcpElement = parser.parse(new InputSource(reader)).getDocumentElement();", "+\t\t\t} catch (SAXException e) {", "+\t\t\t\tthrow new IOException(Util.bind(\"file.badFormat\")); //$NON-NLS-1$", "+\t\t\t} catch (ParserConfigurationException e) {", "+\t\t\t\treader.close();", "+\t\t\t\tthrow new IOException(Util.bind(\"file.badFormat\")); //$NON-NLS-1$", "+\t\t\t} finally {", "+\t\t\t\treader.close();", "+\t\t\t}", "+\t", "+\t\t\tif (!cpElement.getNodeName().equalsIgnoreCase(\"classpath\")) { //$NON-NLS-1$", "+\t\t\t\tthrow new IOException(Util.bind(\"file.badFormat\")); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\tIPath projectPath = getProject().getFullPath();", "+\t\t\tNodeList list = cpElement.getChildNodes();", "+\t\t\tint length = list.getLength();", "+\t", "+\t\t\tfor (int i = 0; i < length; ++i) {", "+\t\t\t\tNode node = list.item(i);", "+\t\t\t\tshort type = node.getNodeType();", "+\t\t\t\tif (type == Node.ELEMENT_NODE) {", "+\t\t\t\t\tElement cpeElement = (Element) node;", "+\t", "+\t\t\t\t\tif (cpeElement.getNodeName().equalsIgnoreCase(\"classpathentry\")) { //$NON-NLS-1$", "+\t\t\t\t\t\tString cpeElementKind = cpeElement.getAttribute(\"kind\"); //$NON-NLS-1$", "+\t\t\t\t\t\tString pathStr = cpeElement.getAttribute(\"path\"); //$NON-NLS-1$", "+\t\t\t\t\t\t// ensure path is absolute", "+\t\t\t\t\t\tIPath path = new Path(pathStr);", "+\t\t\t\t\t\tint kind = kindFromString(cpeElementKind);", "+\t\t\t\t\t\tif (kind != IClasspathEntry.CPE_VARIABLE && kind != IClasspathEntry.CPE_CONTAINER && !path.isAbsolute()) {", "+\t\t\t\t\t\t\tpath = projectPath.append(path);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// source attachment info (optional)", "+\t\t\t\t\t\tString sourceAttachmentPathStr = cpeElement.getAttribute(\"sourcepath\");\t//$NON-NLS-1$", "+\t\t\t\t\t\tIPath sourceAttachmentPath =", "+\t\t\t\t\t\t\tsourceAttachmentPathStr.equals(\"\") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$", "+\t\t\t\t\t\tString sourceAttachmentRootPathStr = cpeElement.getAttribute(\"rootpath\"); //$NON-NLS-1$", "+\t\t\t\t\t\tIPath sourceAttachmentRootPath =", "+\t\t\t\t\t\t\tsourceAttachmentRootPathStr.equals(\"\") //$NON-NLS-1$", "+\t\t\t\t\t\t\t\t? null", "+\t\t\t\t\t\t\t\t: new Path(sourceAttachmentRootPathStr);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\t// exported flag", "+\t\t\t\t\t\tboolean isExported = cpeElement.getAttribute(\"exported\").equals(\"true\"); //$NON-NLS-1$ //$NON-NLS-2$", "+\t", "+\t\t\t\t\t\t// recreate the CP entry", "+\t\t\t\t\t\tswitch (kind) {", "+\t\t\t\t", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_PROJECT :", "+\t\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_LIBRARY :", "+\t\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;", "+\t\t\t\t\t\t\t\tpaths.add(JavaCore.newLibraryEntry(", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceAttachmentPath,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceAttachmentRootPath,", "+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisExported));", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_SOURCE :", "+\t\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;", "+\t\t\t\t\t\t\t\t// must be an entry in this project or specify another project", "+\t\t\t\t\t\t\t\tString projSegment = path.segment(0);", "+\t\t\t\t\t\t\t\tif (projSegment != null && projSegment.equals(getElementName())) {", "+\t\t\t\t\t\t\t\t\t// this project", "+\t\t\t\t\t\t\t\t\tpaths.add(JavaCore.newSourceEntry(path));", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t// another project", "+\t\t\t\t\t\t\t\t\tpaths.add(JavaCore.newProjectEntry(path, isExported));", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_VARIABLE :", "+\t\t\t\t\t\t\t\tpaths.add(JavaCore.newVariableEntry(", "+\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\tsourceAttachmentPath,", "+\t\t\t\t\t\t\t\t\t\tsourceAttachmentRootPath, ", "+\t\t\t\t\t\t\t\t\t\tisExported));", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tcase IClasspathEntry.CPE_CONTAINER :", "+\t\t\t\t\t\t\t\tpaths.add(JavaCore.newContainerEntry(", "+\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\tisExported));", "+\t\t\t\t\t\t\t\tbreak;", "+\t", "+\t\t\t\t\t\t\tcase ClasspathEntry.K_OUTPUT :", "+\t\t\t\t\t\t\t\tif (!path.isAbsolute()) return null;", "+\t\t\t\t\t\t\t\tpaths.add(new ClasspathEntry(", "+\t\t\t\t\t\t\t\t\t\tClasspathEntry.K_OUTPUT,", "+\t\t\t\t\t\t\t\t\t\tIClasspathEntry.CPE_LIBRARY,", "+\t\t\t\t\t\t\t\t\t\tpath,", "+\t\t\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\t\t\tnull,", "+\t\t\t\t\t\t\t\t\t\tfalse));", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tdefault:", "+\t\t\t\t\t\t\t\tthrow new Assert.AssertionFailedException(Util.bind(\"classpath.unknownKind\", cpeElementKind)); //$NON-NLS-1$", "+\t\t\t\t\t\t}", "+\t\t} catch(CoreException e) {", "+\t\t\t// file does not exist (or not accessible)", "+\t\t\tif (createMarker && this.getProject().isAccessible()) {", "+\t\t\t\tthis.createClasspathProblemMarker(", "+\t\t\t\t\tUtil.bind(\"classpath.cannotReadClasspathFile\", this.getElementName()), //$NON-NLS-1$", "+\t\t\t\t\tIMarker.SEVERITY_ERROR,", "+\t\t\t\t\tfalse,\t//  cycle error", "+\t\t\t\t\ttrue);\t//\tfile format error", "+\t\t\t}", "+\t\t\tif (logProblems) {", "+\t\t\t\tUtil.log(e, ", "+\t\t\t\t\t\"Exception while retrieving \"+ this.getPath() //$NON-NLS-1$", "+\t\t\t\t\t+\"/.classpath, will revert to default classpath\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} catch (IOException e) {", "+\t\t\t// bad format", "+\t\t\tif (createMarker && this.getProject().isAccessible()) {", "+\t\t\t\tthis.createClasspathProblemMarker(", "+\t\t\t\t\tUtil.bind(\"classpath.cannotReadClasspathFile\", this.getElementName()), //$NON-NLS-1$", "+\t\t\t\t\tIMarker.SEVERITY_ERROR,", "+\t\t\t\t\tfalse,\t//  cycle error", "+\t\t\t\t\ttrue);\t//\tfile format error", "+\t\t\t}", "+\t\t\tif (logProblems) {", "+\t\t\t\tUtil.log(e, ", "+\t\t\t\t\t\"Exception while retrieving \"+ this.getPath() //$NON-NLS-1$", "+\t\t\t\t\t+\"/.classpath, will revert to default classpath\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\treturn INVALID_CLASSPATH;", "+\t\t} catch (Assert.AssertionFailedException e) { ", "+\t\t\t// failed creating CP entries from file", "+\t\t\tif (createMarker && this.getProject().isAccessible()) {", "+\t\t\t\tthis.createClasspathProblemMarker(", "+\t\t\t\t\tUtil.bind(\"classpath.illegalEntryInClasspathFile\", this.getElementName(), e.getMessage()), //$NON-NLS-1$", "+\t\t\t\t\tIMarker.SEVERITY_ERROR,", "+\t\t\t\t\tfalse,\t//  cycle error", "+\t\t\t\t\ttrue);\t//\tfile format error", "+\t\t\t}", "+\t\t\tif (logProblems) {", "+\t\t\t\tUtil.log(e, ", "+\t\t\t\t\t\"Exception while retrieving \"+ this.getPath() //$NON-NLS-1$", "+\t\t\t\t\t+\"/.classpath, will mark classpath as invalid\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t\treturn INVALID_CLASSPATH;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e7151e08a0f18b06071649d66541a8ed", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/antadapter/org/eclipse/jdt/core/JDTCompilerAdapter.java", "commitBeforeChange": "09c3ccccb89d804a9183abefd56185d0d7837bc3", "commitAfterChange": "6c8a21e16cbda0092cdd37cfe45b5e7adb8a3039", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \t \tprotected Commandline setupJavacCommand() throws BuildException", "signatureAfterChange": " \t \t \tprotected Commandline setupJavacCommand() throws BuildException", "diff": ["+\t\tthis.customDefaultOptions = new HashMap();", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_SourceFileAttribute , CompilerOptions.DO_NOT_GENERATE);", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_SourceFileAttribute , CompilerOptions.DO_NOT_GENERATE);", "+\t\t\t\t\tif (debugLevel.indexOf(\"vars\") != -1) {//$NON-NLS-1$", "+\t\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.GENERATE);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (debugLevel.indexOf(\"lines\") != -1) {//$NON-NLS-1$", "+\t\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.GENERATE);", "+\t\t\t\t\t}", "+\t\t\t\t\tif (debugLevel.indexOf(\"source\") != -1) {//$NON-NLS-1$", "+\t\t\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_SourceFileAttribute , CompilerOptions.GENERATE);", "+\t\t\t\t\t}", "-\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.GENERATE);", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.GENERATE);", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_SourceFileAttribute , CompilerOptions.GENERATE);", "-            cmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.DO_NOT_GENERATE);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_SourceFileAttribute , CompilerOptions.DO_NOT_GENERATE);", "-\t   \tif (compilerArgs == null) {", "-\t\t\t/*", "-\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t\t */", "-\t\t\tif (this.attributes.getNowarn()) {", "-\t\t\t\tif (this.deprecation) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else if (this.deprecation) {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+        // disable all warnings by default", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, CompilerOptions.DISABLED); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, CompilerOptions.DISABLED); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedParameter, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedImport, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNoEffectAssignment, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNonExternalizedStringLiteral, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNoImplicitStringConversion, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportIncompatibleNonInheritedInterfaceMethod, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportLocalVariableHiding, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportFieldHiding, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportPossibleAccidentalBooleanAssignment, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportEmptyStatement, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportAssertIdentifier, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUndocumentedEmptyBlock, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnnecessaryElse, CompilerOptions.IGNORE); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportInvalidJavadoc, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportInvalidJavadocTagsVisibility, CompilerOptions.PUBLIC);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportInvalidJavadocTags, CompilerOptions.DISABLED);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocTags, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility, CompilerOptions.PUBLIC);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocTagsOverriding, CompilerOptions.DISABLED);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocComments, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocCommentsVisibility, CompilerOptions.PUBLIC);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingJavadocCommentsOverriding, CompilerOptions.DISABLED);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportFinallyBlockNotCompletingNormally, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedDeclaredThrownException, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedDeclaredThrownExceptionWhenOverriding, CompilerOptions.DISABLED); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnqualifiedFieldAccess, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnsafeTypeOperation, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportFinalParameterBound, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMissingSerialVersion, CompilerOptions.IGNORE);", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedParameterWhenImplementingAbstract, CompilerOptions.DISABLED); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedParameterWhenOverridingConcrete, CompilerOptions.DISABLED); ", "+\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportSpecialParameterHidingField, CompilerOptions.DISABLED); ", "+", "+\t\t/*", "+\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t */", "+\t\tif (this.attributes.getNowarn()) {", "+\t\t\tif (this.deprecation) {", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.WARNING); ", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, CompilerOptions.ENABLED); ", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, CompilerOptions.ENABLED); ", "-    \t} else {", "-\t\t\t/*", "-\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t\t */", "-\t\t\tif (this.attributes.getNowarn()) {", "-\t\t\t\tif (this.deprecation) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tif (this.deprecation) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:+allDeprecation\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:-allDeprecation,deprecation\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t\tif (compilerArgs.length == 0) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-warn:+constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t}", "-\t        /*", "-\t\t\t * Add extra argument on the command line", "-\t\t\t */", "-\t\t\tif (compilerArgs.length != 0) {", "-\t\t        cmd.addArguments(compilerArgs);", "-\t\t\t}", "-\t   \t}", "+\t\t\t// no warnings", "+\t\t} else if (this.deprecation) {", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.WARNING); ", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, CompilerOptions.ENABLED); ", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, CompilerOptions.ENABLED); ", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedImport, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, CompilerOptions.WARNING);", "+\t\t} else {", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportUnusedImport, CompilerOptions.WARNING);", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, CompilerOptions.WARNING);", "+\t\t}", "-\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(this.target);", "+\t\t\tif (this.target.equals(\"1.1\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_1);", "+\t\t\t} else if (this.target.equals(\"1.2\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);", "+\t\t\t} else if (this.target.equals(\"1.3\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_3);", "+\t\t\t} else if (this.target.equals(\"1.4\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);", "+\t\t\t} else if (this.target.equals(\"1.5\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);", "+\t\t\t} else {", "+\t            this.attributes.log(AntAdapterMessages.getString(\"ant.jdtadapter.info.unknownTarget\", this.target), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t}", "-            cmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "-            cmd.createArgument().setValue(source);", "+        \tif (source.equals(\"1.3\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);", "+\t\t\t} else if (source.equals(\"1.4\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);", "+\t\t\t} else if (source.equals(\"1.5\")) { //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);", "+\t\t\t} else {", "+\t            this.attributes.log(AntAdapterMessages.getString(\"ant.jdtadapter.info.unknownSource\", source), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t}", "-\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1)", "-\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_2)", "-\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_3)) {", "-\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1)", "+\t\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_2)", "+\t\t\t\t|| JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_3)) {", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_3);", "-\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_3);", "-\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "+\t\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);", "-\t\t\tcmd.createArgument().setValue(\"-1.5\"); //$NON-NLS-1$", "+\t\t\tthis.customDefaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);", "-            this.attributes.log(AntAdapterMessages.getString(\"ant.jdtadapter.info.unknownVrsion\"), Project.MSG_WARN); //$NON-NLS-1$", "+            this.attributes.log(AntAdapterMessages.getString(\"ant.jdtadapter.info.unknownVmVersion\", JavaEnvUtils.getJavaVersion()), Project.MSG_WARN); //$NON-NLS-1$", "+\t\tif (compilerArgs != null) {", "+\t        /*", "+\t\t\t * Add extra argument on the command line", "+\t\t\t */", "+\t\t\tif (compilerArgs.length != 0) {", "+\t\t        cmd.addArguments(compilerArgs);", "+\t\t\t}", "+\t   \t}"]}], "num": 25301}