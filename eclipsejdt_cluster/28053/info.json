{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c09a1558a61bbcb70ae0a2a679d54b51", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "15709a9a2db4cbc2addfec64ff4571cc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java", "commitBeforeChange": "91f3edc5382142e13f8351418b65563536c6670f", "commitAfterChange": "8beb6c014c6d79a132720a5abe8725a7bc30bf83", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": "  \tpublic void testTypeAnnotations7()", "signatureAfterChange": "  \tpublic void testTypeAnnotations7()", "diff": ["+", "+\t\t// public <T> Z(@Type T t){}", "+\t\tList<? extends Element> members = _elementUtils.getAllMembers(typeZ);", "+\t\tfor (ExecutableElement method : ElementFilter.constructorsIn(members)) {", "+\t\t\tExecutableType executabletype = (ExecutableType) method.asType();", "+\t\t\tList<? extends TypeMirror> list = executabletype.getParameterTypes();", "+\t\t\tList<? extends VariableElement> list1 = method.getParameters();", "+\t\t\tfor(int i = 0; i < list1.size(); i++) {", "+\t\t\t\tVariableElement variableelement = list1.get(i);", "+\t\t\t\tif (method.getSimpleName().toString().equals(\"<init>\")) {", "+\t\t\t\t\tassertEquals(\"Trouble!\", list.get(i), variableelement.asType());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3ece70b568c84cffe0aa5d04d15eba3b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java", "commitBeforeChange": "d644fbac5b6fa9c32824a6e9c1731fdea560370f", "commitAfterChange": "a2ea211548ddb7d816d913062440866fd92fd6cc", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic int generateDelta(JavaElementDelta delta, boolean addClasspathChange)", "signatureAfterChange": " \tpublic int generateDelta(JavaElementDelta delta, boolean addClasspathChange)", "diff": ["-\t\t\t\tPackageFragmentRoot[] pkgFragmentRoots = null;", "+\t\t\t\tIPackageFragmentRoot[] pkgFragmentRoots = null;", "+\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335986", "+\t\t\t\t\t\t// When a package fragment's corresponding resource is removed from the project, ", "+\t\t\t\t\t\t// IJavaProject#computePackageFragmentRoots() doesn't include that entry. Hence ", "+\t\t\t\t\t\t// the cache become necessary in such cases. Add the cache to the accumulatedRoots ", "+\t\t\t\t\t\t// only when it's not already present.", "+\t\t\t\t\t\tRootInfo rootInfo = (RootInfo) state.oldRoots.get(this.oldResolvedClasspath[i].getPath());", "+\t\t\t\t\t\tif (rootInfo != null && rootInfo.cache != null) {", "+\t\t\t\t\t\t\tIPackageFragmentRoot oldRoot = rootInfo.cache;", "+\t\t\t\t\t\t\tboolean found = false;", "+\t\t\t\t\t\t\tfor (int j = 0; j < accumulatedRoots.size(); j++) {", "+\t\t\t\t\t\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) accumulatedRoots.elementAt(j);", "+\t\t\t\t\t\t\t\tif (!root.getPath().equals(oldRoot.getPath())) {", "+\t\t\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tif (!found)", "+\t\t\t\t\t\t\t\taccumulatedRoots.add(oldRoot);", "+\t\t\t\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c685a4e63213d69f41d4c2a747751227", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests2.java", "commitBeforeChange": "a790cc2a1fe344908ce312351c9762d437d04475", "commitAfterChange": "96135df97393d0f8f1ee1a690487357a43849eda", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t\t\tpublic IClasspathEntry[] getClasspathEntries()", "signatureAfterChange": " \t\t\tpublic IClasspathEntry[] getClasspathEntries()", "diff": ["+\t\t", "+\t\t\t\t    IAccessRule[] accessRules;", "+\t\t\t\t    if(forbiddenReferences != null && forbiddenReferences[j]!= null && forbiddenReferences[j].length() != 0) {", "+\t\t\t\t\t    StringTokenizer tokenizer = new StringTokenizer(forbiddenReferences[j], \";\");", "+\t\t\t\t\t    int count = tokenizer.countTokens();", "+\t\t\t\t\t    accessRules = new IAccessRule[count];", "+\t\t\t\t\t    String token = null;", "+\t\t\t\t\t    for (int i = 0; i < count; i++) {", "+\t\t\t\t\t    \ttoken = tokenizer.nextToken();", "+\t\t\t\t\t\t\taccessRules[i] = JavaCore.newAccessRule(new Path(token), IAccessRule.K_NON_ACCESSIBLE);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\taccessRules = new IAccessRule[0];", "+\t\t\t\t\t}", "-\t\t\t\t        entries[j] = JavaCore.newProjectEntry(path, isExported);", "+\t\t\t\t        entries[j] = JavaCore.newProjectEntry(path, accessRules, true, null, isExported);", "-\t\t\t\t\t\tentries[j] = JavaCore.newLibraryEntry(path, null, null, isExported);", "+\t\t\t\t\t\tentries[j] = JavaCore.newLibraryEntry(path, null, null, accessRules, null, isExported);"]}], "num": 28053}