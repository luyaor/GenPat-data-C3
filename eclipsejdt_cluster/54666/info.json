{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b5db0cd83b974c491ddbcb2a15d83391", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN", "AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1ef4aff4c94083fb1639f2661a7520c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java", "commitBeforeChange": "dd7a18d099a9b8a557ed1fb7fc46e76ea5cfac10", "commitAfterChange": "61620cc52bd94ec88d2d4d64acf040dcf8022b0a", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, ReferenceBinding enclosingType, boolean checkBounds)", "diff": ["-\t\t\tif (enclosingType != null) {", "+\t\t\tif (enclosingType != null && enclosingType.isGenericType()) {", "-\t\t\t\tif (currentType.isStatic() ", "-\t\t\t\t\t\t|| (enclosingType.isGenericType() ", "-\t\t\t\t\t\t\t\t&& enclosingType.outermostEnclosingType() != scope.outerMostClassScope().referenceContext.binding)) {", "-\t\t\t\t\tenclosingType = (ReferenceBinding) scope.environment().convertToRawType(enclosingType);", "-\t\t\t\t}", "+\t\t\t\tenclosingType = currentType.isStatic()", "+\t\t\t\t? (ReferenceBinding) scope.environment().convertToRawType(enclosingType)", "+\t\t\t\t: scope.environment().convertToParameterizedType(enclosingType);", "-\t\t// if generic type X<T> is referred to as parameterized X<T>, then answer itself", "-\t\tboolean isIdentical = true; //this.resolvedType instanceof SourceTypeBinding;", "-\t\tif (isIdentical) {", "-\t\t    for (int i = 0; i < argLength; i++) {", "-\t\t\t\tif (typeVariables[i] != argTypes[i]) {", "-\t\t\t\t\tisIdentical = false;", "-\t\t\t\t    break;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}\t\t", "-\t    if (!isIdentical) {", "-\t    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "-\t\t\t// check argument type compatibility", "-\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "-\t\t\t\tparameterizedType.boundCheck(scope, this.typeArguments);", "-\t", "-\t\t\tthis.resolvedType = parameterizedType;", "-\t\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "-\t\t\t\treportDeprecatedType(scope);", "-\t\t} else {", "-\t\t\tthis.resolvedType = this.resolvedType.erasure();", "-\t\t}", "+    \tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, enclosingType);", "+\t\t// check argument type compatibility", "+\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "+\t\t\tparameterizedType.boundCheck(scope, this.typeArguments);", "+", "+\t\tthis.resolvedType = parameterizedType;", "+\t\tif (isTypeUseDeprecated(this.resolvedType, scope))", "+\t\t\treportDeprecatedType(scope);", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad5390a97ce2044ab992706f811c12bc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java", "commitBeforeChange": "dd7a18d099a9b8a557ed1fb7fc46e76ea5cfac10", "commitAfterChange": "61620cc52bd94ec88d2d4d64acf040dcf8022b0a", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "signatureAfterChange": " \tprivate TypeBinding internalResolveType(Scope scope, boolean checkBounds)", "diff": ["-\t\t\t\tif (qualifiedType != null && currentType.isStatic() && (qualifiedType.isGenericType() || qualifiedType.isParameterizedType())) {", "-\t\t\t\t\tqualifiedType = scope.environment().createRawType((ReferenceBinding)qualifiedType.erasure(), qualifiedType.enclosingType());", "+\t\t\t\tif (qualifiedType != null && qualifiedType.isGenericType()) {", "+\t\t\t\t\tqualifiedType = currentType.isStatic()", "+\t\t\t\t\t\t? (ReferenceBinding) scope.environment().convertToRawType(qualifiedType)", "+\t\t\t\t\t\t: scope.environment().convertToParameterizedType(qualifiedType);", "-\t\t\t\t// if generic type X<T> is referred to as parameterized X<T>, then answer itself", "-\t\t\t\tboolean isIdentical = (qualifiedType == null) || (qualifiedType instanceof SourceTypeBinding);", "-\t\t\t\tif (isIdentical) {", "-\t\t\t\t    for (int j = 0; j < argLength; j++) {", "-\t\t\t\t\t\tif (typeVariables[j] != argTypes[j]) {", "-\t\t\t\t\t\t\tisIdentical = false;", "-\t\t\t\t\t\t    break;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t    if (isIdentical) {", "-\t\t\t    \tqualifiedType = (ReferenceBinding) currentType.erasure();", "-\t\t\t    } else {", "-\t\t\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, qualifiedType);", "-\t\t\t\t\t// check argument type compatibility", "-\t\t\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "-\t\t\t\t\t\tparameterizedType.boundCheck(scope, args);", "-\t\t\t\t\tqualifiedType = parameterizedType;", "-\t\t\t    }", "+\t\t\t\tParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), argTypes, qualifiedType);", "+\t\t\t\t// check argument type compatibility", "+\t\t\t\tif (checkBounds) // otherwise will do it in Scope.connectTypeVariables() or generic method resolution", "+\t\t\t\t\tparameterizedType.boundCheck(scope, args);", "+\t\t\t\tqualifiedType = parameterizedType;"]}], "num": 54666}