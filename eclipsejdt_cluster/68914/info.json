{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "5125ff73449f8ad0bf528c0f4157c1d7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36b472a508a244a17d5e2eb828a4d92a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "e5d472ae376881b61d2a17c3e23cd62b7ed964f0", "commitAfterChange": "447de272007f97647787cc473ca78784fcaddeeb", "methodNumberBeforeChange": 30, "methodNumberAfterChange": 30, "signatureBeforeChange": " \tpublic IPackageFragment findPackageFragment(IPath path) \t\tthrows JavaModelException", "signatureAfterChange": "  \tpublic IJavaElement findPackageFragment(String packageName) \t\t\tthrows JavaModelException", "diff": ["+\tpublic IJavaElement findPackageFragment(String packageName)", "+\t\t\tthrows JavaModelException {", "+\t\tNameLookup lookup = newNameLookup((WorkingCopyOwner)null/*no need to look at working copies for pkgs*/);", "+\t\tIPackageFragment[] pkgFragments = lookup.findPackageFragments(packageName, false);", "+\t\tif (pkgFragments == null) {", "+\t\t\treturn null;", "+", "+\t\t} else {", "+\t\t\t// try to return one that is a child of this project", "+\t\t\tfor (int i = 0, length = pkgFragments.length; i < length; i++) {", "+", "+\t\t\t\tIPackageFragment pkgFragment = pkgFragments[i];", "+\t\t\t\tif (this.equals(pkgFragment.getParent().getParent())) {", "+\t\t\t\t\treturn pkgFragment;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// default to the first one", "+\t\t\treturn pkgFragments[0];", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f814fac754e4ea22a4d4cfce033cd1c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/BindingKeyResolver.java", "commitBeforeChange": "19de0bf25a38cb3c78ae5b1452a4badcf6ffab4c", "commitAfterChange": "d45a6d72ecac1399ae839b8bb0faf0b4626c38b4", "methodNumberBeforeChange": 31, "methodNumberAfterChange": 31, "signatureBeforeChange": " \t \tpublic void consumeTypeVariable(char[] typeVariableName)", "signatureAfterChange": " \t \tpublic void consumeTypeVariable(char[] position, char[] typeVariableName)", "diff": ["-\tpublic void consumeTypeVariable(char[] typeVariableName) {", "+\tpublic void consumeTypeVariable(char[] position, char[] typeVariableName) {", "+\t\tif (position.length > 0) {", "+\t\t\tint sourceStart = Integer.parseInt(new String(position));", "+\t\t\tMethodBinding[] methods = ((ReferenceBinding) this.typeBinding).methods();", "+\t\t\tif (methods != null) {", "+\t\t\t\tfor (int i = 0, length = methods.length; i < length; i++) {", "+\t\t\t\t\tMethodBinding binding = methods[i];", "+\t\t\t\t\tif (sourceStart == binding.sourceStart()) {", "+\t\t\t\t\t\tthis.methodBinding = binding;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "986b1256e6a0ef2045f7b1a000ce0140", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "ad9419ce2b413384a1310dd9b222d0ccd125407d", "commitAfterChange": "7cd9da1e8a67c35ab511299ccf3966d49c713a3c", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-", "-\t\t\t// what about inherited interface methods?", "-\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "-\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "-\t\t\t} else if (!sourceType.isAnonymousType()) {", "-\t\t\t\t// body of enum constant must implement any inherited abstract methods", "-\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "+\t\t\tif (!sourceType.isAnonymousType()) {", "+\t\t\t\t\t// does define abstract methods ?", "+\t\t\t\t\tif ((referenceContext.bits & ASTNode.HasAbstractMethods) != 0) {", "+\t\t\t\t\t\tmodifiers |= ClassFileConstants.AccAbstract;", "+\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t\t} \t\t\t\t\t", "+\t\t\t\t\t// body of enum constant must implement any inherited abstract methods", "+\t\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "-\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "-\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "-\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (fieldDecl.initialization instanceof QualifiedAllocationExpression) {", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t// final if no enum constant with anonymous body", "+\t\t\t\tcheckFinalEnum: {", "+\t\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\t\tif (fields != null) {", "+\t\t\t\t\t\tfor (int i = 0, fieldsLength = fields.length; i < fieldsLength; i++) {", "+\t\t\t\t\t\t\tFieldDeclaration fieldDecl = fields[i];", "+\t\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {", "+\t\t\t\t\t\t\t\tif (fieldDecl.initialization instanceof QualifiedAllocationExpression) {", "+\t\t\t\t\t\t\t\t\tbreak checkFinalEnum;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tmodifiers |= ClassFileConstants.AccFinal;", "+\t\t\t\t}\t\t\t", "-\t\t\tmodifiers |= ClassFileConstants.AccFinal;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a4df9a3ed6e27c1e9c28a6deaeeee40c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "85347e368b14c5176f4730552f6a19854120569d", "commitAfterChange": "04236443ccc286f293c5d09b3a540f768ce12f8d", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " boolean detectNameClash(MethodBinding current, MethodBinding inherited)", "signatureAfterChange": " boolean detectNameClash(MethodBinding current, MethodBinding inherited, boolean treatAsSynthetic)", "diff": ["-boolean detectNameClash(MethodBinding current, MethodBinding inherited) {", "-\tMethodBinding original = inherited.original(); // can be the same as inherited", "+boolean detectNameClash(MethodBinding current, MethodBinding inherited, boolean treatAsSynthetic) {", "+\tMethodBinding methodToCheck = inherited;", "+\tif (!treatAsSynthetic) {", "+\t\t// For a user method, see if current class overrides the inherited method. If it does,", "+\t\t// then any grievance we may have ought to be against the current class's method and", "+\t\t// NOT against any super implementations. https://bugs.eclipse.org/bugs/show_bug.cgi?id=293615", "+\t\tMethodBinding[] currentNamesakes = (MethodBinding[]) this.currentMethods.get(inherited.selector);", "+\t\tif (currentNamesakes.length > 1) { // we know it ought to at least one and that current is NOT the override", "+\t\t\tfor (int i = 0, length = currentNamesakes.length; i < length; i++) {", "+\t\t\t\tMethodBinding currentMethod = currentNamesakes[i];", "+\t\t\t\tif (currentMethod != current && doesMethodOverride(currentMethod, inherited)) {", "+\t\t\t\t\tmethodToCheck = currentMethod;", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\tMethodBinding original = methodToCheck.original(); // can be the same as inherited", "-", "+\toriginal = inherited.original();  // For error reporting use, inherited.original()"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "af1ea5952737d5ba9831f2732f20a3fd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "85347e368b14c5176f4730552f6a19854120569d", "commitAfterChange": "04236443ccc286f293c5d09b3a540f768ce12f8d", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods)", "diff": ["-\tif (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod.original()) != null) {", "+\tMethodBinding bridge = this.type.addSyntheticBridgeMethod(originalInherited, currentMethod.original());", "+\tif (bridge != null) {", "+\t\t}", "+\t\t// See if the new bridge clashes with any of the user methods of the class. For this check", "+\t\t// we should check for \"method descriptor clash\" and not just \"method signature clash\". Really", "+\t\t// what we are checking is whether there is a contention for the method dispatch table slot.", "+\t\t// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=293615.", "+\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(bridge.selector);", "+\t\tfor (int i = current.length - 1; i >= 0; --i) {", "+\t\t\tfinal MethodBinding thisMethod = current[i];", "+\t\t\tif (thisMethod.areParameterErasuresEqual(bridge) && thisMethod.returnType.erasure() == bridge.returnType.erasure()) {", "+\t\t\t\t// use inherited method for problem reporting.", "+\t\t\t\tproblemReporter(thisMethod).methodNameClash(thisMethod, inheritedMethod.declaringClass.isRawType() ? inheritedMethod : inheritedMethod.original());", "+\t\t\t\treturn;\t", "+\t\t\t}"]}], "num": 68914}