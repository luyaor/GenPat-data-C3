{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "08c97646a138eff28c9276c4da378521", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "451a36b4fdac4e72f9540eb45b5cd3f2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java", "commitBeforeChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "commitAfterChange": "1d2291282dfdfb671d68594ce3e1d0da5450a9d0", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": "  \tprivate void handleHtml(TagElement node)", "signatureAfterChange": "  \tprivate void handleHtml(TagElement node)", "diff": ["+\t\t\t\tif (TagElement.TAG_PARAM.equals(node.getTagName())", "+\t\t\t\t\t\t&& this.ctm.findIndex(startPos, -1, false) == 1 + this.ctm.firstIndexIn(node, -1)) {", "+\t\t\t\t\tcontinue; // it's a generic class parameter name, not an HTML tag", "+\t\t\t\t}", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bde408279d7a3157803ade0909165c82", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java", "commitBeforeChange": "76c9d02e981a720920f3a98e40e7da666cb7f2a1", "commitAfterChange": "bd9b00bcf9923b9da6ff38651a157fa6bc3f2dc8", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, \t\t\tFlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, \t\t\tFlowInfo flowInfo)", "diff": ["+\t\t\tthis.nullStatus = this.valueIfTrue.nullStatus(trueFlowInfo);", "+\t\t\tthis.nullStatus = this.valueIfFalse.nullStatus(falseFlowInfo);", "-\t\t\t// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok", "+\t\t\t// this block must meet two conflicting requirements (see https://bugs.eclipse.org/324178):", "+\t\t\t// (1) For null analysis of \"Object o2 = (o1 != null) ? o1 : new Object();\" we need to distinguish", "+\t\t\t//     the paths *originating* from the evaluation of the condition to true/false respectively.", "+\t\t\t//     This is used to determine the possible null status of the entire conditional expression.", "+\t\t\t// (2) For definite assignment analysis (JLS 16.1.5) of boolean conditional expressions of the form", "+\t\t\t//     \"if (c1 ? expr1 : expr2) use(v);\" we need to check whether any variable v will be definitely", "+\t\t\t//     assigned whenever the entire conditional expression evaluates to true (to reach the then branch).", "+\t\t\t//     I.e., we need to collect flowInfo *towards* the overall outcome true/false ", "+\t\t\t//     (regardless of the evaluation of the condition).", "+\t\t\t", "+\t\t\t// to support (1) use the infos of both branches originating from the condition for computing the nullStatus:", "+\t\t\tcomputeNullStatus(trueFlowInfo, falseFlowInfo);", "+\t\t\t", "+\t\t\t// to support (2) we split the true/false branches according to their inner structure. Consider this:", "+\t\t\t// if (b ? false : (true && (v = false))) return v; -- ok", "+\t\t\t// - expr1 (\"false\") has no path towards true (mark as unreachable)", "+\t\t\t// - expr2 (\"(true && (v = false))\") has a branch towards true on which v is assigned.", "+\t\t\t//   -> merging these two branches yields: v is assigned", "+\t\t\t// - the paths towards false are irrelevant since the enclosing if has no else.", "-\t\t\tUnconditionalFlowInfo trueInfoWhenTrue = trueFlowInfo.initsWhenTrue().unconditionalCopy();", "-\t\t\tUnconditionalFlowInfo falseInfoWhenTrue = falseFlowInfo.initsWhenTrue().unconditionalCopy();", "-\t\t\tUnconditionalFlowInfo trueInfoWhenFalse = trueFlowInfo.initsWhenFalse().unconditionalInits();", "-\t\t\tUnconditionalFlowInfo falseInfoWhenFalse = falseFlowInfo.initsWhenFalse().unconditionalInits();", "+\t\t\tUnconditionalFlowInfo trueFlowTowardsTrue = trueFlowInfo.initsWhenTrue().unconditionalCopy();", "+\t\t\tUnconditionalFlowInfo falseFlowTowardsTrue = falseFlowInfo.initsWhenTrue().unconditionalCopy();", "+\t\t\tUnconditionalFlowInfo trueFlowTowardsFalse = trueFlowInfo.initsWhenFalse().unconditionalInits();", "+\t\t\tUnconditionalFlowInfo falseFlowTowardsFalse = falseFlowInfo.initsWhenFalse().unconditionalInits();", "-\t\t\t\ttrueInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t\t\t\t", "+\t\t\t\ttrueFlowTowardsTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t\t\t\t", "-\t\t\t\tfalseInfoWhenTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\tfalseFlowTowardsTrue.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\ttrueInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\ttrueFlowTowardsFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\tfalseInfoWhenFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "+\t\t\t\tfalseFlowTowardsFalse.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);\t", "-\t\t\t\t\ttrueInfoWhenTrue.mergedWith(falseInfoWhenTrue),", "-\t\t\t\t\ttrueInfoWhenFalse.mergedWith(falseInfoWhenFalse));", "+\t\t\t\t\ttrueFlowTowardsTrue.mergedWith(falseFlowTowardsTrue),", "+\t\t\t\t\ttrueFlowTowardsFalse.mergedWith(falseFlowTowardsFalse));", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d6d257e94916e11cf7d44312a0ea3573", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "ea5c9cc312f4b4f8b75e3a6a2f95be1c2b2c1422", "commitAfterChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 28, "signatureBeforeChange": "  \t@Override \tpublic boolean visit(ConditionalExpression node)", "signatureAfterChange": "  \t@Override \tpublic boolean visit(ConditionalExpression node)", "diff": ["+\t\tthis.secondaryWrapIndexes.add(this.tm.firstIndexIn(node.getThenExpression(), -1));", "+\t\tthis.secondaryWrapIndexes.add(this.tm.firstIndexIn(node.getElseExpression(), -1));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f33f500e25c5352c11bfed50c5f1d77b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "ea5c9cc312f4b4f8b75e3a6a2f95be1c2b2c1422", "commitAfterChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 32, "signatureBeforeChange": "  \t@Override \tpublic boolean visit(IfStatement node)", "signatureAfterChange": "  \t@Override \tpublic boolean visit(IfStatement node)", "diff": ["-\t\t\tif (this.tm.get(thenIndex).getLineBreaksBefore() == 0)", "+\t\t\tif (this.tm.get(thenIndex).getLineBreaksBefore() == 0) {", "+\t\t\t\tthis.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);", "+\t\t\t\tthis.wrapGroupEnd = this.tm.lastIndexIn(node.getThenStatement(), -1);", "+\t\t\t\thandleWrap(this.options.alignment_for_compact_if, node);", "+\t\t\t}", "-\t\t\tif (this.tm.get(elseIndex).getLineBreaksBefore() == 0)", "+\t\t\tif (this.tm.get(elseIndex).getLineBreaksBefore() == 0) {", "-\t\t}", "-\t\tif (!this.wrapIndexes.isEmpty()) {", "-\t\t\tthis.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);", "-\t\t\tthis.wrapGroupEnd = this.tm.lastIndexIn(node, -1);", "-\t\t\thandleWrap(this.options.alignment_for_compact_if, node);", "+\t\t\t\tthis.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);", "+\t\t\t\tthis.wrapGroupEnd = this.tm.lastIndexIn(elseStatement, -1);", "+\t\t\t\thandleWrap(this.options.alignment_for_compact_if, node);", "+\t\t\t}"]}], "num": 26403}