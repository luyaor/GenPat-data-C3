{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dce9e48f4f5f48fb8e75b52279472f81", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "960511711b92936ea925e41588bcf0fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java", "commitBeforeChange": "01d995488d5e309c6b243da146c63894a6df881d", "commitAfterChange": "13bbdd97c6c86aba0f70693f850c3de86bece79b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "signatureAfterChange": "     public static Map<String, String> getProcessorOptions(IJavaProject jproj)", "diff": ["-    \t\tStringBuilder classpathSB = new StringBuilder();", "-    \t\tStringBuilder sourcepathSB = new StringBuilder();", "-    \t\tboolean firstCP = true;", "-    \t\tboolean firstSP = true;", "+    \t\tSet<String> classpath = new LinkedHashSet<String>();", "+    \t\tSet<String> sourcepath = new LinkedHashSet<String>();", "+    \t\t", "+    \t\t// For projects on the classpath, loops can exist; need to make sure we ", "+    \t\t// don't loop forever", "+    \t\tSet<IJavaProject> projectsProcessed = new HashSet<IJavaProject>();", "+    \t\tprojectsProcessed.add(jproj);", "-\t    \t\t\tif (firstCP) {", "-\t    \t\t\t\tfirstCP = false;", "-\t    \t\t\t}", "-\t    \t\t\telse {", "-\t    \t\t\t\tclasspathSB.append(File.pathSeparatorChar);", "-\t    \t\t\t}", "-\t    \t\t\t\tclasspathSB.append(cpPath.toOSString());", "+\t    \t\t\t\tclasspath.add(cpPath.toOSString());", "-\t    \t\t\t\tclasspathSB.append(res.getLocation().toOSString());", "+\t    \t\t\t\tclasspath.add(res.getLocation().toOSString());", "-    \t\t\t\tif (firstSP) {", "-    \t\t\t\t\tfirstSP = false;", "-    \t\t\t\t}", "-    \t\t\t\telse {", "-    \t\t\t\t\tsourcepathSB.append(File.pathSeparatorChar);", "-    \t\t\t\t}", "+    \t\t\t\tsourcepath.add(srcPath.toOSString());", "+    \t\t\t}", "+    \t\t\telse if (kind == IClasspathEntry.CPE_PROJECT) {", "+    \t\t\t\t// Add the dependent project's build path and classpath to ours", "+    \t\t\t\tIPath otherProjectPath = entry.getPath();", "+    \t\t\t\tIProject otherProject = root.getProject(otherProjectPath.segment(0));", "-    \t\t\t\tsourcepathSB.append(srcPath.toOSString());", "+    \t\t\t\t// Note: JavaCore.create() is safe, even if the project is null -- ", "+    \t\t\t\t// in that case, we get null back", "+    \t\t\t\tIJavaProject otherJavaProject = JavaCore.create(otherProject);", "+    \t\t\t\t", "+    \t\t\t\t// If it doesn't exist, ignore it", "+    \t\t\t\tif (otherJavaProject != null) {", "+    \t\t\t\t\taddProjectClasspath(root, otherJavaProject, projectsProcessed, classpath);", "+    \t\t\t\t}", "-    \t\toptions.put(\"-classpath\",classpathSB.toString()); //$NON-NLS-1$    \t\t", "-    \t\toptions.put(\"-sourcepath\", sourcepathSB.toString()); //$NON-NLS-1$", "+    \t\toptions.put(\"-classpath\",convertPathCollectionToString(classpath)); //$NON-NLS-1$    \t\t", "+    \t\toptions.put(\"-sourcepath\", convertPathCollectionToString(sourcepath)); //$NON-NLS-1$"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ad4774de477738c441e95d71dbc38bf5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java", "commitBeforeChange": "ad30422de59b5093c5225e2a4599516c056303dc", "commitAfterChange": "c1c045ff9c256acaa6d98530fa4640b4cd80b7c6", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb)", "signatureAfterChange": "  \tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType)", "diff": ["-\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb) {", "+\tpublic TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedType) {", "-\t\t\tTypeBinding leafComponentType = expectedTb.leafComponentType();", "+\t\t\tTypeBinding leafComponentType = expectedType.leafComponentType();", "-\t\tif (expectedTb.isArrayType()) {", "-\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedTb;", "-\t\t\tif (expressions == null)", "-\t\t\t\treturn binding;", "-\t\t\tTypeBinding expectedElementsTb = binding.elementsType();", "-\t\t\tif (expectedElementsTb.isBaseType()) {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "-\t\t\t\t\tExpression expression = expressions[i];", "-\t\t\t\t\tTypeBinding expressionTb =", "-\t\t\t\t\t\t(expression instanceof ArrayInitializer)", "-\t\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, expectedElementsTb)", "-\t\t\t\t\t\t\t: expression.resolveType(scope);", "-\t\t\t\t\tif (expressionTb == null)", "-\t\t\t\t\t\treturn null;", "-\t", "-\t\t\t\t\t// Compile-time conversion required?", "-\t\t\t\t\tif (expectedElementsTb != expressionTb) // must call before computeConversion() and typeMismatchError()", "-\t\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(expectedElementsTb, expressionTb);", "-\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionTb, expectedElementsTb)", "-\t\t\t\t\t\t|| BaseTypeBinding.isWidening(expectedElementsTb.id, expressionTb.id)", "-\t\t\t\t\t\t|| scope.isBoxingCompatibleWith(expressionTb, expectedElementsTb)) {", "-\t\t\t\t\t\t\texpression.computeConversion(scope, expectedElementsTb, expressionTb);", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tscope.problemReporter().typeMismatchError(expressionTb, expectedElementsTb, expression);", "-\t\t\t\t\t\treturn null;", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tfor (int i = 0, length = expressions.length; i < length; i++)", "-\t\t\t\t\tif (expressions[i].resolveTypeExpecting(scope, expectedElementsTb) == null)", "-\t\t\t\t\t\treturn null;", "+\t\tif (expectedType.isArrayType()) {", "+\t\t\tthis.resolvedType = this.binding = (ArrayBinding) expectedType;", "+\t\t\tif (this.expressions == null)", "+\t\t\t\treturn this.binding;", "+\t\t\tTypeBinding elementType = this.binding.elementsType();", "+\t\t\tfor (int i = 0, length = expressions.length; i < length; i++) {", "+\t\t\t\tExpression expression = expressions[i];", "+\t\t\t\tTypeBinding exprType = expression instanceof ArrayInitializer", "+\t\t\t\t\t\t? expression.resolveTypeExpecting(scope, elementType)", "+\t\t\t\t\t\t: expression.resolveType(scope);", "+\t\t\t\tif (exprType == null)", "+\t\t\t\t\treturn null;", "+", "+\t\t\t\t// Compile-time conversion required?", "+\t\t\t\tif (elementType != exprType) // must call before computeConversion() and typeMismatchError()", "+\t\t\t\t\tscope.compilationUnitScope().recordTypeConversion(elementType, exprType);", "+", "+\t\t\t\tif ((expression.isConstantValueOfTypeAssignableToType(exprType, elementType)", "+\t\t\t\t\t\t|| (elementType.isBaseType() && BaseTypeBinding.isWidening(elementType.id, exprType.id)))", "+\t\t\t\t\t\t|| exprType.isCompatibleWith(elementType)) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else if (scope.isBoxingCompatibleWith(exprType, elementType) ", "+\t\t\t\t\t\t\t\t\t|| (exprType.isBaseType()  // narrowing then boxing ?", "+\t\t\t\t\t\t\t\t\t\t\t&& !elementType.isBaseType()", "+\t\t\t\t\t\t\t\t\t\t\t&& expression.isConstantValueOfTypeAssignableToType(exprType, scope.environment().computeBoxingType(elementType)))) {", "+\t\t\t\t\texpression.computeConversion(scope, elementType, exprType);", "+\t\t\t\t} else {", "+\t\t\t\t\tscope.problemReporter().typeMismatchError(exprType, elementType, expression);", "+\t\t\t\t\treturn null;", "+\t\t\t\t} \t\t\t\t", "-\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedTb, this);", "+\t\t\tscope.problemReporter().typeMismatchError(probableTb, expectedType, this);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bfb0ddea07b074d29f88e4f764b4cccf", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java", "commitBeforeChange": "af73ce6125bda1c56ea682bc25396c8af7246489", "commitAfterChange": "be3076081a68f52e55442746b375d20d2f473b0c", "methodNumberBeforeChange": 102, "methodNumberAfterChange": 102, "signatureBeforeChange": " \tprotected IJavaProject setUpJavaProject(final String projectName, String compliance) throws CoreException, IOException", "signatureAfterChange": " \tprotected IJavaProject setUpJavaProject(final String projectName, String compliance) throws CoreException, IOException", "diff": ["-\t\tif (JavaCore.getClasspathVariable(\"JCL_LIB\") == null) {", "-\t\t\tif (\"1.5\".equals(compliance)) {", "-\t\t\t\tJavaCore.setClasspathVariables(", "-\t\t\t\t\tnew String[] {\"JCL_LIB\", \"JCL_SRC\", \"JCL_SRCROOT\"},", "-\t\t\t\t\tnew IPath[] {getExternalJCLPath(compliance), getExternalJCLSourcePath(compliance), getExternalJCLRootSourcePath()},", "-\t\t\t\t\tnull);", "-\t\t\t} else {", "-\t\t\t\tJavaCore.setClasspathVariables(", "-\t\t\t\t\tnew String[] {\"JCL_LIB\", \"JCL_SRC\", \"JCL_SRCROOT\"},", "-\t\t\t\t\tnew IPath[] {getExternalJCLPath(), getExternalJCLSourcePath(), getExternalJCLRootSourcePath()},", "-\t\t\t\t\tnull);", "-\t\t\t}", "-\t\t}", "+\t\tsetUpJCLClasspathVariables(compliance);", "+\t\t\t// set options", "+\t\t\t", "+\t\t\t// replace JCL_LIB with JCL15_LIB, and JCL_SRC with JCL15_SRC", "+\t\t\tIClasspathEntry[] classpath = javaProject.getRawClasspath();", "+\t\t\tIPath jclLib = new Path(\"JCL_LIB\");", "+\t\t\tfor (int i = 0, length = classpath.length; i < length; i++) {", "+\t\t\t\tIClasspathEntry entry = classpath[i];", "+\t\t\t\tif (entry.getPath().equals(jclLib)) {", "+\t\t\t\t\tclasspath[i] = JavaCore.newVariableEntry(new Path(\"JCL15_LIB\"), new Path(\"JCL15_SRC\"), entry.getSourceAttachmentRootPath(), entry.getInclusionPatterns(), entry.getExclusionPatterns(), entry.isExported());", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tjavaProject.setRawClasspath(classpath, null);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eda183b4deabbd2bd089118767f831a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "49c7e567a30e3d9cc1c4880ba35031661d2a5415", "commitAfterChange": "c9d2c7d4276b8b0f65a3b8bbfa4009e8632940f9", "methodNumberBeforeChange": 70, "methodNumberAfterChange": 71, "signatureBeforeChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "signatureAfterChange": " \tprivate void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag)", "diff": ["-\t\tStringBuffer textBuffer = isHtmlTag ? new StringBuffer() : buffer;", "+\t\tStringBuffer tokensBuffer = new StringBuffer();", "-\t\t\t\tprintIndentationIfNecessary(textBuffer);", "+\t\t\t\tprintIndentationIfNecessary(buffer);", "-\t\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\ttokensBuffer.append(' ');", "-\t\t\t\t\t\tbuffer.append('\\'');", "-\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\ttokensBuffer.append('\\'');", "-\t\t\t\t\t\t\t\tbuffer.append(' ');", "-\t\t\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\t\t\ttokensBuffer.append(' ');", "-\t\t\t\t\t\tbuffer.append('\"');", "-\t\t\t\t\t\tthis.column++;", "+\t\t\t\t\t\ttokensBuffer.append('\"');", "+\t\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\t\tthis.column += tokensBuffer.length();", "+\t\t\t\t\ttokensBuffer.setLength(0);", "-\t\t\t\tthis.column += tokenLength;", "-\t    \t\tif (insertSpace) this.column++;", "-\t    \t\tint col = column; ", "+\t    \t\tint lastColumn = this.column + tokensBuffer.length() + tokenLength;", "+\t    \t\tif (insertSpace) lastColumn++;", "-\t    \t\t\tif (col > maxColumn)  {", "-\t    \t\t\t\tcol--; // new line gives an extra character", "+\t    \t\t\tif (lastColumn > maxColumn)  {", "+\t    \t\t\t\tlastColumn--; // new line gives an extra character", "-\t\t\t\tif (col > maxColumn) {", "+\t\t\t\tif (lastColumn > maxColumn) {", "-\t\t\t\t\tif (col == this.column) this.lastNumberOfNewLines++;", "+\t\t\t\t\tif (lastColumn == this.column) this.lastNumberOfNewLines++;", "-\t\t\t\t\tif (isHtmlTag && buffer != textBuffer) {", "-\t\t\t\t\t\tbuffer.append(textBuffer);", "-\t\t\t\t\t\ttextBuffer = buffer;", "-\t\t\t\t\t}", "-\t\t\t\t\ttextBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t\t    \tif (tokensBuffer.length() > 0) {", "+\t\t\t    \t\tString tokensString = tokensBuffer.toString().trim();", "+\t\t\t\t\t\tbuffer.append(tokensString);", "+\t\t\t\t\t\tthis.column += tokensString.length();", "+\t\t\t\t\t\ttokensBuffer.setLength(0);", "+\t\t\t    \t}", "+\t\t\t\t\tbuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\t\t\tif (insertSpace)  {", "-\t\t    \t\t\ttextBuffer.append(' ');", "-\t\t\t\t\t}", "-\t\t\t\t\ttextBuffer.append(this.scanner.source, tokenStart, tokenLength);", "+\t\t    \t\tif (insertSpace) {", "+\t\t    \t\t\ttokensBuffer.append(' ');", "+\t\t    \t\t}", "+\t\t\t\t\ttokensBuffer.append(this.scanner.source, tokenStart, tokenLength);", "-\t\t\tif (isHtmlTag && buffer != textBuffer) {", "-\t\t\t\tbuffer.append(textBuffer);", "+\t\t\t// Add remaining buffered tokens", "+\t\t\tif (tokensBuffer.length() > 0) {", "+\t\t\t\tbuffer.append(tokensBuffer);", "+\t\t\t\tthis.column += tokensBuffer.length();"]}], "num": 69414}