{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "dc024922e3447342bc89e3b0237ac0e1", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6bdc1bc86c3e5bf6903dbdb22184046e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "890be42f32773e7ca5496c222c424ace19ee53bc", "commitAfterChange": "56f6c261cdbb79871bca6b1da5ab32712debf654", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tprivate void checkAndSetModifiers()", "signatureAfterChange": " \t \tprivate void checkAndSetModifiers()", "diff": ["-// what about inherited interface methods?", "+\t\t\t// what about inherited interface methods?", "+\t\t\telse if (!sourceType.isAnonymousType()){ // body of enum constant must implement any inherited abstract methods", "+\t\t\t\t// enum type needs to implement abstract methods if one of its constants does not supply a body", "+\t\t\t\tTypeDeclaration typeDeclaration = this.referenceContext;", "+\t\t\t\tFieldDeclaration[] fields = typeDeclaration.fields;", "+\t\t\t\tint length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;", "+\t\t\t\tcheckAbstractEnum: {", "+\t\t\t\t\tif (length == 0) break checkAbstractEnum; // has no constants so must implement the method itself", "+\t\t\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\t\tFieldDeclaration fieldDecl = fields[i];", "+\t\t\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT)", "+\t\t\t\t\t\t\tif (!(fieldDecl.initialization instanceof QualifiedAllocationExpression))", "+\t\t\t\t\t\t\t\tbreak checkAbstractEnum;", "+\t\t\t\t\t}", "+\t\t\t\t\t// tag this enum as abstract since an abstract method must be implemented AND all enum constants define an anonymous body", "+\t\t\t\t\t// as a result, each of its anonymous constants will see it as abstract and must implement each inherited abstract method\t\t\t\t\t", "+\t\t\t\t\tmodifiers |= AccAbstract;", "+\t\t\t\t}", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c68868ee14a5523028c3e81f4f1e8156", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "8816a21753c2d607b8868597ac43f18ef7dd2d50", "commitAfterChange": "3af20c8fa9116cf8e52dcf498c1b4eea06f21754", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 12, "signatureBeforeChange": " void checkMethods()", "signatureAfterChange": " void checkMethods()", "diff": ["+\tif (mustImplementAbstractMethods && this.type.isEnum() && !this.type.isAnonymousType()) {", "+\t\t// enum type only needs to implement abstract methods if any of its constants does not supply a body", "+\t\tcheckEnumConstantBodies: {", "+\t\t\tTypeDeclaration typeDeclaration = this.type.scope.referenceContext;", "+\t\t\tfor (int i = 0, length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length; i < length; i++) {", "+\t\t\t\tFieldDeclaration fieldDecl = typeDeclaration.fields[i];", "+\t\t\t\tif (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT && !(fieldDecl.initialization instanceof QualifiedAllocationExpression)) {", "+\t\t\t\t\tbreak checkEnumConstantBodies; // leave mustImplementAbstractMethods flag on ", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tmustImplementAbstractMethods = false; // since all enum constants define an anonymous body", "+\t\t}", "+\t}"]}], "num": 7520}