{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2e745f671dba4ce10699e9327affc361", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "91d74d894a514bbe523dd574ba50bbb4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/junit/extension/TestCase.java", "commitBeforeChange": "afe8e7c03c9e057a9ab6bf025b43a423a4494448", "commitAfterChange": "10cca24df480719d1a06391159cf8b7088d76566", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "  public static List buildTestsList(Class evaluationTestClass, int inheritedDepth)", "signatureAfterChange": "  public static List buildTestsList(Class evaluationTestClass, int inheritedDepth)", "diff": ["-\t\t\tif (ONLY_SUFFIX != null && methName.endsWith(ONLY_SUFFIX)) {", "-\t\t\t\tif (!onlyNames.contains(methName)) {", "-\t\t\t\t\tonlyNames.add(methName);", "+\t\t\tif (methName.startsWith(METHOD_PREFIX)) {", "+", "+\t\t\t\t// look if this is a run only method", "+\t\t\t\tboolean isOnly = RUN_ONLY_ID != null && methName.substring(methodPrefixLength).startsWith(RUN_ONLY_ID);", "+\t\t\t\tif (isOnly) {", "+\t\t\t\t\tif (!onlyNames.contains(methName)) {", "+\t\t\t\t\t\tonlyNames.add(methName);", "+\t\t\t\t\t}", "+\t\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\telse if (methName.startsWith(METHOD_PREFIX)) {", "+", "+"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dd6641f72997060080b83bd1f7116638", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatch.java", "commitBeforeChange": "b4304f5a0ae3fd0a899e4f86a55dafea7f0ca4a1", "commitAfterChange": "38faf3efd9d7a9e66ede29f2210a34a5031698a0", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t\t \tprivate static APTResult runAPT(final List<AnnotationProcessorFactory> factories, \t\t\tIJavaProject javaProj, \t\t\tIFile[] files, \t\t\tICompilationUnit compilationUnit, \t\t\tboolean isFullBuild)", "signatureAfterChange": " \tprivate static APTResult runAPT(final List<AnnotationProcessorFactory> factories, \t\t\tIJavaProject javaProj, \t\t\tIFile[] files, \t\t\tICompilationUnit compilationUnit, \t\t\tboolean isFullBuild)", "diff": ["+\t */", "+\t\t       ", "+\t\tboolean building = files != null;", "-\t\tif ( files != null )", "+\t\tif ( building )", "+\t\t\t// If we're building, types can be generated, so we", "+\t\t\t// want to run this as an atomic workspace operation", "+\t\t\t IWorkspace workspace = ResourcesPlugin.getWorkspace();", "+\t\t\t try {", "+\t\t\t\t workspace.run(runnable, schedulingRule, IWorkspace.AVOID_UPDATE, null);", "+\t\t\t }", "+\t\t\t catch (CoreException ce) {", "+\t\t\t\t AptPlugin.log(ce, \"Could not run APT\"); //$NON-NLS-1$", "+\t\t\t }", "+\t\t\t// Reconciling, so we do not want to run this as an atomic workspace", "+\t\t\t// operation. If we do, it is easy to have locking issues when someone", "+\t\t\t// calls a reconcile from within a workspace lock", "-\t\t\tschedulingRule = null;", "-\t\t}", "-\t\t", "-\t\ttry", "-\t\t{", "-\t\t\tIWorkspace w = ResourcesPlugin.getWorkspace();", "-\t\t\tw.run( runnable, schedulingRule, IWorkspace.AVOID_UPDATE, null );", "-\t\t}", "-\t\tcatch( CoreException ce )", "-\t\t{", "-\t\t\tAptPlugin.log(ce, \"Could not run APT\"); //$NON-NLS-1$", "+\t\t\trunnable.run(null);"]}], "num": 58685}