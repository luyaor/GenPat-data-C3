{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "30b751578cba1b5ddd923549ec6b3733", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "698a02f729339aee219f49266345c96f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java", "commitBeforeChange": "b28c3b6098b6901bf11ac9535bc5b0ea277defa0", "commitAfterChange": "928aec179e1479276b2375bc65b872f33f20053c", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tpublic void run(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic void run(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\t\t// close the parents of the created elements and reset their project's cache (in case we are in an ", "+\t\t\t\t// IWorkspaceRunnable and the clients wants to use the created element's parent)", "+\t\t\t\t// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=83646", "+\t\t\t\tfor (int i = 0, length = this.resultElements.length; i < length; i++) {", "+\t\t\t\t\tIJavaElement element = this.resultElements[i];", "+\t\t\t\t\tOpenable openable = (Openable) element.getOpenable();", "+\t\t\t\t\tif (!(openable instanceof CompilationUnit) || !((CompilationUnit) openable).isWorkingCopy()) { // a working copy must remain a child of its parent even after a move", "+\t\t\t\t\t\t((JavaElement) openable.getParent()).close();", "+\t\t\t\t\t}", "+\t\t\t\t\t((JavaProject) element.getJavaProject()).resetCaches();", "+\t\t\t\t}", "+\t\t\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "78f658fe2dcc4a0b218c5e435131ec24", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "d3d92e370789aaaed8a46c804d74e3cb2b4bb167", "commitAfterChange": "07061c09a4baa11ac0a53e425e478493f3662bd4", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 17, "signatureBeforeChange": " \tpublic void addSpecialMethods()", "signatureAfterChange": " \tpublic void addSpecialMethods()", "diff": ["-\t\tLambdaExpression [] lambdas = this.referenceBinding.getLambdaMethods();", "-\t\tfor (int i = 0, length = lambdas == null ? 0 : lambdas.length; i < length; i++) {", "-\t\t\tlambdas[i].generateCode(this.referenceBinding.scope, this);", "-\t\t}", "+\t\tboolean doneGeneratingLambdas = false;", "+\t\tint currentLambda = 0;", "+\t\tdo {", "+\t\t\tLambdaExpression [] lambdas = this.referenceBinding.getLambdaMethods();  // refresh as a lambda code generation could schedule nested lambdas for code generation.", "+\t\t\tint lambdaCount = lambdas == null ? 0 : lambdas.length;", "+\t\t\tif (lambdaCount > currentLambda) {", "+\t\t\t\tlambdas[currentLambda++].generateCode(this.referenceBinding.scope, this);", "+\t\t\t} else {", "+\t\t\t\tdoneGeneratingLambdas = true;", "+\t\t\t}", "+\t\t} while (!doneGeneratingLambdas);", "+\t\t"]}], "num": 68136}