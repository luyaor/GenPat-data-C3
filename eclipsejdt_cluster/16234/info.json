{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8a4695d7d01c07a4b5862e280d591ef2", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13981ef5a4b0026912c18a896ce345de", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java", "commitBeforeChange": "1740233a8dca1d707aa9811c9f07a7ace8f5d808", "commitAfterChange": "36542264af3396595138a00ba7efc11cead3cfc1", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "signatureAfterChange": "\r private void buildFromPotentialSubtypes(String[] allPotentialSubTypes)", "diff": ["+\t// substitute compilation units with working copies\r", "+\tHashMap wcPaths = new HashMap(); // a map from path to working copies\r", "+\tint wcLength;\r", "+\tIWorkingCopy[] workingCopies = this.getWokingCopies();\r", "+\tif (workingCopies != null && (wcLength = workingCopies.length) > 0) {\r", "+\t\tString[] newPaths = new String[wcLength];\r", "+\t\tfor (int i = 0; i < wcLength; i++) {\r", "+\t\t\tIWorkingCopy workingCopy = workingCopies[i];\r", "+\t\t\tString path = workingCopy.getOriginalElement().getPath().toString();\r", "+\t\t\twcPaths.put(path, workingCopy);\r", "+\t\t\tnewPaths[i] = path;\r", "+\t\t}\r", "+\t\tint potentialSubtypesLength = allPotentialSubTypes.length;\r", "+\t\tSystem.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[potentialSubtypesLength+wcLength], 0, potentialSubtypesLength);\r", "+\t\tSystem.arraycopy(newPaths, 0, allPotentialSubTypes, potentialSubtypesLength, wcLength);\r", "+\t}\r", "+\t\t\t\r", "-\t\t\tOpenable handle = \r", "-\t\t\t\tresourcePath.equals(focusPath) ? \r", "-\t\t\t\t\tfocusCU :\r", "-\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "-\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\tOpenable handle;\r", "+\t\t\tIWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(resourcePath);\r", "+\t\t\tif (workingCopy != null) {\r", "+\t\t\t\thandle = (Openable)workingCopy;\r", "+\t\t\t} else {\r", "+\t\t\t\thandle = \r", "+\t\t\t\t\tresourcePath.equals(focusPath) ? \r", "+\t\t\t\t\t\tfocusCU :\r", "+\t\t\t\t\t\tfactory.createOpenable(resourcePath);\r", "+\t\t\t\tif (handle == null) continue; // match is outside classpath\r", "+\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1b32f340f87543d3bdb13139d650d17d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "599efd6b939e7ff91594afd42beb33c22058dc64", "commitAfterChange": "99e5fba4ffda5dc66ee6b0a6664d2454e7652e64", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " private IType[] findSuperInterfaces(IGenericType type, ReferenceBinding typeBinding)", "signatureAfterChange": " private IType[] findSuperInterfaces(IGenericType type, ReferenceBinding typeBinding)", "diff": ["-\tReferenceBinding[] interfaceBindings = typeBinding.superInterfaces();", "-\t", "-\t// check if bindings were removed while resolving (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=136095)", "-\tClassScope scope;", "-\tif (typeBinding instanceof SourceTypeBinding && (scope = ((SourceTypeBinding) typeBinding).scope) != null) {", "-\t\tTypeDeclaration typeDeclaration = scope.referenceContext;", "-\t\tTypeReference[] superInterfaces = typeDeclaration == null ? null : typeDeclaration.superInterfaces;", "-\t\tint length;", "-\t\tif (superInterfaces != null && (length = superInterfaces.length) > (interfaceBindings == null ? 0 : interfaceBindings.length)) { // check for interfaceBindings being null (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=139689)", "-\t\t\t", "-\t\t\tinterfaceBindings = new ReferenceBinding[length];", "-\t\t\tint index = 0;", "-\t\t\tfor (int i = 0; i < length; i++) {", "-\t\t\t\tReferenceBinding superInterface = (ReferenceBinding) superInterfaces[i].resolvedType;", "-\t\t\t\tif (superInterface instanceof ProblemReferenceBinding)", "-\t\t\t\t\tsuperInterface = ((ProblemReferenceBinding) superInterface).closestMatch;", "-\t\t\t\tif (superInterface != null)", "-\t\t\t\t\tinterfaceBindings[index++] = superInterface;", "-\t\t\t}", "-\t\t\tif (index < length)", "-\t\t\t\tSystem.arraycopy(interfaceBindings, 0, interfaceBindings = new ReferenceBinding[index], 0 , index);", "-\t\t\t((SourceTypeBinding) typeBinding).superInterfaces = interfaceBindings;", "-\t\t}", "-\t}", "-\t", "+\tReferenceBinding[] interfaceBindings = typeBinding.superInterfaces();\t", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a2bc78feb2384e5839d1f042071ce8ec", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java", "commitBeforeChange": "eec9d6fb9b9702bf6b5887305a5d1f257bb85855", "commitAfterChange": "1dd82f6bbffd48141341af6c82022cbdf8ab1cf5", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " private IType[] findSuperInterfaces(IGenericType type, ReferenceBinding typeBinding)", "signatureAfterChange": " private IType[] findSuperInterfaces(IGenericType type, ReferenceBinding typeBinding)", "diff": ["+\t", "+\t// check if bindings were removed while resolving (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=136095)", "+\tClassScope scope;", "+\tif (typeBinding instanceof SourceTypeBinding && (scope = ((SourceTypeBinding) typeBinding).scope) != null) {", "+\t\tTypeDeclaration typeDeclaration = scope.referenceContext;", "+\t\tTypeReference[] superInterfaces = typeDeclaration == null ? null : typeDeclaration.superInterfaces;", "+\t\tint length;", "+\t\tif (superInterfaces != null && (length = superInterfaces.length) > interfaceBindings.length) {", "+\t\t\t", "+\t\t\tinterfaceBindings = new ReferenceBinding[length];", "+\t\t\tint index = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tReferenceBinding superInterface = (ReferenceBinding) superInterfaces[i].resolvedType;", "+\t\t\t\tif (superInterface instanceof ProblemReferenceBinding)", "+\t\t\t\t\tsuperInterface = ((ProblemReferenceBinding) superInterface).closestMatch;", "+\t\t\t\tif (superInterface != null)", "+\t\t\t\t\tinterfaceBindings[index++] = superInterface;", "+\t\t\t}", "+\t\t\tif (index < length)", "+\t\t\t\tSystem.arraycopy(interfaceBindings, 0, interfaceBindings = new ReferenceBinding[index], 0 , index);", "+\t\t\t((SourceTypeBinding) typeBinding).superInterfaces = interfaceBindings;", "+\t\t}", "+\t}", "+\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f307213468c59cfc06821c2d546f5be2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java", "commitBeforeChange": "5cd024d52141117881e2f62e4aa34624606418cf", "commitAfterChange": "a75f0756b3cdda16ae0347da0cb2609171946934", "methodNumberBeforeChange": 19, "methodNumberAfterChange": 19, "signatureBeforeChange": " \tpublic static void copySE8AnnotationsToType(BlockScope scope, Binding recipient, Annotation[] annotations)", "signatureAfterChange": " \tpublic static void copySE8AnnotationsToType(BlockScope scope, Binding recipient, Annotation[] annotations)", "diff": ["-\t*/", "+\t// When SE8 annotations feature in SE7 locations, they get attributed to the declared entity. Copy/move these to the type of the declared entity (field, local, argument etc.)", "-\t\tif (annotations != null && recipient.kind() != Binding.TYPE_USE) {", "-\t\t\tAnnotationBinding [] se8Annotations = null;", "-\t\t\tint se8count = 0;", "-\t\t\tlong se8nullBits = 0;", "-\t\t\tAnnotation se8NullAnnotation = null;", "-\t\t\tfor (int i = 0, length = annotations.length; i < length; i++) {", "-\t\t\t\tAnnotationBinding annotation = annotations[i].getCompilerAnnotation();", "-\t\t\t\tif (annotation == null) continue;", "-\t\t\t\tfinal ReferenceBinding annotationType = annotation.getAnnotationType();", "-\t\t\t\tlong metaTagBits = annotationType.getAnnotationTagBits();", "-\t\t\t\tif ((metaTagBits & TagBits.AnnotationForTypeUse) != 0) {", "-\t\t\t\t\tif (se8Annotations == null) {", "-\t\t\t\t\t\tse8Annotations = new AnnotationBinding[] { annotation };", "-\t\t\t\t\t\tse8count = 1;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tSystem.arraycopy(se8Annotations, 0, se8Annotations = new AnnotationBinding[se8count + 1], 0, se8count);", "-\t\t\t\t\t\tse8Annotations[se8count++] = annotation;", "-\t\t\t\t\t}", "-\t\t\t\t\tif (annotationType.id == TypeIds.T_ConfiguredAnnotationNonNull) {", "-\t\t\t\t\t\tse8nullBits = TagBits.AnnotationNonNull;", "-\t\t\t\t\t\tse8NullAnnotation = annotations[i];", "-\t\t\t\t\t} else if (annotationType.id == TypeIds.T_ConfiguredAnnotationNullable) {", "-\t\t\t\t\t\tse8nullBits = TagBits.AnnotationNullable;", "-\t\t\t\t\t\tse8NullAnnotation = annotations[i];", "-\t\t\t\t\t}", "+\t\t", "+\t\tif (annotations == null || annotations.length == 0 || recipient == null)", "+\t\t\treturn;", "+\t\t", "+\t\tlong recipientTargetMask = 0;", "+\t\tswitch (recipient.kind()) {", "+\t\t\tcase Binding.LOCAL:", "+\t\t\t\trecipientTargetMask = recipient.isParameter() ? TagBits.AnnotationForParameter : TagBits.AnnotationForLocalVariable;", "+\t\t\t\tbreak;", "+\t\t\tcase Binding.FIELD:", "+\t\t\t\trecipientTargetMask = TagBits.AnnotationForField;", "+\t\t\t\tbreak;", "+\t\t\tcase Binding.METHOD:", "+\t\t\t\trecipientTargetMask = TagBits.AnnotationForMethod;", "+\t\t\t\tbreak;", "+\t\t\tdefault:", "+\t\t\t\treturn;", "+\t\t}", "+\t\t", "+\t\tAnnotationBinding [] se8Annotations = null;", "+\t\tint se8count = 0;", "+\t\tlong se8nullBits = 0;", "+\t\tAnnotation se8NullAnnotation = null;", "+\t\tfor (int i = 0, length = annotations.length; i < length; i++) {", "+\t\t\tAnnotationBinding annotation = annotations[i].getCompilerAnnotation();", "+\t\t\tif (annotation == null) continue;", "+\t\t\tfinal ReferenceBinding annotationType = annotation.getAnnotationType();", "+\t\t\tlong metaTagBits = annotationType.getAnnotationTagBits();", "+\t\t\tif ((metaTagBits & TagBits.AnnotationForTypeUse) != 0) {", "+\t\t\t\tif (se8Annotations == null) {", "+\t\t\t\t\tse8Annotations = new AnnotationBinding[] { annotation };", "+\t\t\t\t\tse8count = 1;", "+\t\t\t\t} else {", "+\t\t\t\t\tSystem.arraycopy(se8Annotations, 0, se8Annotations = new AnnotationBinding[se8count + 1], 0, se8count);", "+\t\t\t\t\tse8Annotations[se8count++] = annotation;", "+\t\t\t\t}", "+\t\t\t\tif (annotationType.id == TypeIds.T_ConfiguredAnnotationNonNull) {", "+\t\t\t\t\tse8nullBits = TagBits.AnnotationNonNull;", "+\t\t\t\t\tse8NullAnnotation = annotations[i];", "+\t\t\t\t} else if (annotationType.id == TypeIds.T_ConfiguredAnnotationNullable) {", "+\t\t\t\t\tse8nullBits = TagBits.AnnotationNullable;", "+\t\t\t\t\tse8NullAnnotation = annotations[i];", "-\t\t\tif (se8Annotations != null) {", "-\t\t\t\tswitch (recipient.kind()) {", "-\t\t\t\t\tcase Binding.LOCAL:", "-\t\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) recipient;", "-\t\t\t\t\t\tTypeReference typeRef = local.declaration.type;", "-\t\t\t\t\t\tif (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on package qualified types.", "-\t\t\t\t\t\t\tlocal.declaration.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\ttypeRef.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\tlocal.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, typeRef, local.type);", "+\t\t}", "+\t\tif (se8Annotations != null) {", "+\t\t\tswitch (recipient.kind()) {", "+\t\t\t\tcase Binding.LOCAL:", "+\t\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) recipient;", "+\t\t\t\t\tTypeReference typeRef = local.declaration.type;", "+\t\t\t\t\tif (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on package qualified types.", "+\t\t\t\t\t\tlocal.declaration.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\ttypeRef.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\tlocal.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, typeRef, local.type);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Binding.FIELD:", "+\t\t\t\t\tFieldBinding field = (FieldBinding) recipient;", "+\t\t\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) field.declaringClass;", "+\t\t\t\t\tFieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);", "+\t\t\t\t\tif (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.", "+\t\t\t\t\t\tfieldDeclaration.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\tfieldDeclaration.type.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\tfield.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, fieldDeclaration.type, field.type);", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Binding.METHOD:", "+\t\t\t\t\tMethodBinding method = (MethodBinding) recipient;", "+\t\t\t\t\tif (!method.isConstructor()) {", "+\t\t\t\t\t\tsourceType = (SourceTypeBinding) method.declaringClass;", "+\t\t\t\t\t\tMethodDeclaration methodDecl = (MethodDeclaration) sourceType.scope.referenceContext.declarationOf(method);", "+\t\t\t\t\t\tif (Annotation.isTypeUseCompatible(methodDecl.returnType, scope)) {", "+\t\t\t\t\t\t\tmethodDecl.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\t\tmethodDecl.returnType.bits |= HasTypeAnnotations;", "+\t\t\t\t\t\t\tmethod.returnType = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, methodDecl.returnType, method.returnType);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase Binding.FIELD:", "-\t\t\t\t\t\tFieldBinding field = (FieldBinding) recipient;", "-\t\t\t\t\t\tSourceTypeBinding sourceType = (SourceTypeBinding) field.declaringClass;", "-\t\t\t\t\t\tFieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);", "-\t\t\t\t\t\tif (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.", "-\t\t\t\t\t\t\tfieldDeclaration.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\tfieldDeclaration.type.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\tfield.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, fieldDeclaration.type, field.type);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase Binding.METHOD:", "-\t\t\t\t\t\tMethodBinding method = (MethodBinding) recipient;", "-\t\t\t\t\t\tif (!method.isConstructor()) {", "-\t\t\t\t\t\t\tsourceType = (SourceTypeBinding) method.declaringClass;", "-\t\t\t\t\t\t\tMethodDeclaration methodDecl = (MethodDeclaration) sourceType.scope.referenceContext.declarationOf(method);", "-\t\t\t\t\t\t\tif (Annotation.isTypeUseCompatible(methodDecl.returnType, scope)) {", "-\t\t\t\t\t\t\t\tmethodDecl.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\t\tmethodDecl.returnType.bits |= HasTypeAnnotations;", "-\t\t\t\t\t\t\t\tmethod.returnType = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, methodDecl.returnType, method.returnType);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t}", "+\t\t\tAnnotationBinding [] recipientAnnotations = recipient.getAnnotations();", "+\t\t\tint length = recipientAnnotations == null ? 0 : recipientAnnotations.length;", "+\t\t\tint newLength = 0;", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tlong annotationTargetMask = recipientAnnotations[i].getAnnotationType().getAnnotationTagBits() & TagBits.AnnotationTargetMASK;", "+\t\t\t\tif (annotationTargetMask == 0 || (annotationTargetMask & recipientTargetMask) != 0)", "+\t\t\t\t\trecipientAnnotations[newLength++] = recipientAnnotations[i];", "+\t\t\t}", "+\t\t\tif (newLength != length) {", "+\t\t\t\tSystem.arraycopy(recipientAnnotations, 0, recipientAnnotations = new AnnotationBinding[newLength],  0, newLength);", "+\t\t\t\trecipient.setAnnotations(recipientAnnotations, scope);"]}], "num": 16234}