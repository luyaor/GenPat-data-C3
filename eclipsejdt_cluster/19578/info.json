{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "43a98e6b8d8f3adaf4b91151c8f27164", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "4225b33b7f1859d84c4bb41aa5254aeb", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "a6181d6802b5a324cb95e89162694a938fb478d8", "commitAfterChange": "8abd75076e932cee4c42294e09e5c3451d79df9f", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " private void computeInheritedMethods()", "signatureAfterChange": " private void computeInheritedMethods()", "diff": ["-\tMethodBinding[] nonVisibleDefaultMethods = null; // TODO (kent) should make this a lookup table keyed by selector", "-\tint nonVisibleCount = 0;", "+\tHashtableOfObject nonVisibleDefaultMethods = new HashtableOfObject(3); // maps method selectors to an array of methods", "+\tboolean allSuperclassesAreAbstract = true;", "-\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "-\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t    if (allSuperclassesAreAbstract) {", "+\t\t\t    if (superType.isAbstract()) {", "+\t\t\t\t\t// only need to include superinterfaces if immediate superclasses are abstract", "+\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "+\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "+\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "+\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t    allSuperclassesAreAbstract = false;", "+\t\t\t\t}", "-\t\t\t\tif (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) {", "-\t\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "-\t\t\t\t\tif (existingMethods != null) {", "-\t\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "-\t\t\t\t\t\t\tif (areReturnTypeErasuresEqual(method, existingMethods[i]) && areParameterErasuresEqual(method, existingMethods[i])) {", "-\t\t\t\t\t\t\t\tif (method.isDefault() && method.isAbstract() && method.declaringClass.fPackage != type.fPackage)", "-\t\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(method);", "-\t\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t\t}", "+\t\t\t\tif (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())", "+\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);", "+\t\t\t\tif (existingMethods != null) {", "+\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "+\t\t\t\t\t\tif (areReturnTypeErasuresEqual(method, existingMethods[i]) && areParameterErasuresEqual(method, existingMethods[i])) {", "+\t\t\t\t\t\t\tif (method.isDefault() && method.isAbstract() && method.declaringClass.fPackage != type.fPackage)", "+\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(method);", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\tif (nonVisibleDefaultMethods != null)", "-\t\t\t\t\t\tfor (int i = 0; i < nonVisibleCount; i++)", "-\t\t\t\t\t\t\tif (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)", "-\t\t\t\t\t\t\t\t&& areReturnTypeErasuresEqual(method, nonVisibleDefaultMethods[i])", "-\t\t\t\t\t\t\t\t&& areParameterErasuresEqual(method, nonVisibleDefaultMethods[i])) ", "-\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t}", "+\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(method.selector);", "+\t\t\t\tif (nonVisible != null)", "+\t\t\t\t\tfor (int i = 0, l = nonVisible.length; i < l; i++)", "+\t\t\t\t\t\tif (areReturnTypeErasuresEqual(method, nonVisible[i]) && areParameterErasuresEqual(method, nonVisible[i])) ", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\t\tif (existingMethods == null)", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,", "-\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);", "-\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;", "-\t\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\tif (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {", "+\t\t\t\t\tif (existingMethods == null) {", "+\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "-\t\t\t\t\t\tif (nonVisibleDefaultMethods == null)", "-\t\t\t\t\t\t\tnonVisibleDefaultMethods = new MethodBinding[10];", "-\t\t\t\t\t\telse if (nonVisibleCount == nonVisibleDefaultMethods.length)", "-\t\t\t\t\t\t\tSystem.arraycopy(nonVisibleDefaultMethods, 0,", "-\t\t\t\t\t\t\t\t(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]), 0, nonVisibleCount);", "-\t\t\t\t\t\tnonVisibleDefaultMethods[nonVisibleCount++] = method;", "+\t\t\t\t\t\tint length = existingMethods.length;", "+\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t}", "+\t\t\t\t\tthis.inheritedMethods.put(method.selector, existingMethods);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (nonVisible == null) {", "+\t\t\t\t\t\tnonVisible = new MethodBinding[] {method};", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint length = nonVisible.length;", "+\t\t\t\t\t\tSystem.arraycopy(nonVisible, 0, nonVisible = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\t\tnonVisible[length] = method;", "+\t\t\t\t\t}", "+\t\t\t\t\tnonVisibleDefaultMethods.put(method.selector, nonVisible);", "-\t\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "-\t\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);", "+\t\t\t\t\tif (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, method);", "-\t\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);", "-\t\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued", "-\t\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {", "-\t\t\t\t\t\t\t\tif (areReturnTypeErasuresEqual(method, current[i]) && areParameterErasuresEqual(method, current[i])) {", "-\t\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "-\t\t\t\t\t\t\t\t\tbreak foundMatch;", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);", "+\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued", "+\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {", "+\t\t\t\t\t\t\tif (areReturnTypeErasuresEqual(method, current[i]) && areParameterErasuresEqual(method, current[i])) {", "+\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], method);", "+\t\t\t\t\t\t\t\tbreak foundMatch;", "-\t\tfor (int j = 0, length = interfaces.length; j < length; j++) {", "+\t\tfor (int j = 0, l = interfaces.length; j < l; j++) {", "-\t\t\t\t\tfor (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "+\t\t\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public", "-\t\t\t\t\t\tif (existingMethods == null)", "-\t\t\t\t\t\t\texistingMethods = new MethodBinding[1];", "-\t\t\t\t\t\telse", "-\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0,", "-\t\t\t\t\t\t\t\t(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);", "-\t\t\t\t\t\texistingMethods[existingMethods.length - 1] = method;", "+\t\t\t\t\t\tif (existingMethods == null) {", "+\t\t\t\t\t\t\texistingMethods = new MethodBinding[] {method};", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tint length = existingMethods.length;", "+\t\t\t\t\t\t\tfor (int e = 0; e < length; e++) {", "+\t\t\t\t\t\t\t\tMethodBinding existing = existingMethods[e];", "+\t\t\t\t\t\t\t\tif (areParameterErasuresEqual(method, existing) && existing.declaringClass.implementsInterface(superType, true))", "+\t\t\t\t\t\t\t\t\tcontinue nextMethod; // skip interface method with the same signature if visible to its declaringClass", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\t\t\texistingMethods[length] = method;", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a71bec0c8584c8770001e1c3589feb6a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "875cc8d42787c90738d8dc077a25eb401e9e38f9", "commitAfterChange": "adfd584faf146517cb3e86f9f2b585f2851a3630", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 12, "signatureBeforeChange": " void computeInheritedMethods()", "signatureAfterChange": " void computeInheritedMethods()", "diff": ["-\twhile (superType != null) {", "-\t\tif (superType.isValidBinding()) {", "-\t\t    if (allSuperclassesAreAbstract) {", "-\t\t\t    if (superType.isAbstract()) {", "-\t\t\t\t\t// only need to include superinterfaces if immediate superclasses are abstract", "-\t\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "-\t\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "-\t\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "-\t\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t    allSuperclassesAreAbstract = false;", "+\twhile (superType != null && superType.isValidBinding()) {", "+\t    if (allSuperclassesAreAbstract) {", "+\t\t    if (superType.isAbstract()) {", "+\t\t\t\t// only need to include superinterfaces if immediate superclasses are abstract", "+\t\t\t\tif ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {", "+\t\t\t\t\tif (++lastPosition == interfacesToVisit.length)", "+\t\t\t\t\t\tSystem.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);", "+\t\t\t\t\tinterfacesToVisit[lastPosition] = itsInterfaces;", "+\t\t\t} else {", "+\t\t\t    allSuperclassesAreAbstract = false;", "-", "-\t\t\tMethodBinding[] methods = superType.unResolvedMethods();", "-\t\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "-\t\t\t\tMethodBinding inheritedMethod = methods[m];", "-\t\t\t\tif (inheritedMethod.isPrivate() || inheritedMethod.isConstructor() || inheritedMethod.isDefaultAbstract())", "-\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "-\t\t\t\tif (existingMethods != null) {", "-\t\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "-\t\t\t\t\t\tif (doesMethodOverride(existingMethods[i], inheritedMethod)) {", "-\t\t\t\t\t\t\tif (inheritedMethod.isDefault() && inheritedMethod.isAbstract())", "-\t\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(inheritedMethod);", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(inheritedMethod.selector);", "-\t\t\t\tif (nonVisible != null)", "-\t\t\t\t\tfor (int i = 0, l = nonVisible.length; i < l; i++)", "-\t\t\t\t\t\tif (doesMethodOverride(nonVisible[i], inheritedMethod))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-", "-\t\t\t\tif (!inheritedMethod.isDefault() || inheritedMethod.declaringClass.fPackage == type.fPackage) {", "-\t\t\t\t\tif (existingMethods == null) {", "-\t\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tint length = existingMethods.length;", "-\t\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "-\t\t\t\t\t\texistingMethods[length] = inheritedMethod;", "-\t\t\t\t\t}", "-\t\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "-\t\t\t\t} else {", "-\t\t\t\t\tif (nonVisible == null) {", "-\t\t\t\t\t\tnonVisible = new MethodBinding[] {inheritedMethod};", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tint length = nonVisible.length;", "-\t\t\t\t\t\tSystem.arraycopy(nonVisible, 0, nonVisible = new MethodBinding[length + 1], 0, length);", "-\t\t\t\t\t\tnonVisible[length] = inheritedMethod;", "-\t\t\t\t\t}", "-\t\t\t\t\tnonVisibleDefaultMethods.put(inheritedMethod.selector, nonVisible);", "-", "-\t\t\t\t\tif (inheritedMethod.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "-\t\t\t\t\t\tthis.problemReporter().abstractMethodCannotBeOverridden(this.type, inheritedMethod);", "-", "-\t\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(inheritedMethod.selector);", "-\t\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued", "-\t\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {", "-\t\t\t\t\t\t\tif (doesMethodOverride(current[i], inheritedMethod)) {", "-\t\t\t\t\t\t\t\tthis.problemReporter().overridesPackageDefaultMethod(current[i], inheritedMethod);", "-\t\t\t\t\t\t\t\tbreak foundMatch;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tsuperType = superType.superclass();", "+", "+\t\tMethodBinding[] methods = superType.unResolvedMethods();", "+\t\tnextMethod : for (int m = methods.length; --m >= 0;) {", "+\t\t\tMethodBinding inheritedMethod = methods[m];", "+\t\t\tif (inheritedMethod.isPrivate() || inheritedMethod.isConstructor() || inheritedMethod.isDefaultAbstract())", "+\t\t\t\tcontinue nextMethod;", "+\t\t\tMethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);", "+\t\t\tif (existingMethods != null) {", "+\t\t\t\tfor (int i = 0, length = existingMethods.length; i < length; i++) {", "+\t\t\t\t\tif (doesMethodOverride(existingMethods[i], inheritedMethod)) {", "+\t\t\t\t\t\tif (inheritedMethod.isDefault() && inheritedMethod.isAbstract())", "+\t\t\t\t\t\t\tcheckPackagePrivateAbstractMethod(inheritedMethod);", "+\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tMethodBinding[] nonVisible = (MethodBinding[]) nonVisibleDefaultMethods.get(inheritedMethod.selector);", "+\t\t\tif (nonVisible != null)", "+\t\t\t\tfor (int i = 0, l = nonVisible.length; i < l; i++)", "+\t\t\t\t\tif (doesMethodOverride(nonVisible[i], inheritedMethod))", "+\t\t\t\t\t\tcontinue nextMethod;", "+", "+\t\t\tif (!inheritedMethod.isDefault() || inheritedMethod.declaringClass.fPackage == type.fPackage) {", "+\t\t\t\tif (existingMethods == null) {", "+\t\t\t\t\texistingMethods = new MethodBinding[] {inheritedMethod};", "+\t\t\t\t} else {", "+\t\t\t\t\tint length = existingMethods.length;", "+\t\t\t\t\tSystem.arraycopy(existingMethods, 0, existingMethods = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\texistingMethods[length] = inheritedMethod;", "+\t\t\t\t}", "+\t\t\t\tthis.inheritedMethods.put(inheritedMethod.selector, existingMethods);", "+\t\t\t} else {", "+\t\t\t\tif (nonVisible == null) {", "+\t\t\t\t\tnonVisible = new MethodBinding[] {inheritedMethod};", "+\t\t\t\t} else {", "+\t\t\t\t\tint length = nonVisible.length;", "+\t\t\t\t\tSystem.arraycopy(nonVisible, 0, nonVisible = new MethodBinding[length + 1], 0, length);", "+\t\t\t\t\tnonVisible[length] = inheritedMethod;", "+\t\t\t\t}", "+\t\t\t\tnonVisibleDefaultMethods.put(inheritedMethod.selector, nonVisible);", "+", "+\t\t\t\tif (inheritedMethod.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract", "+\t\t\t\t\tproblemReporter().abstractMethodCannotBeOverridden(this.type, inheritedMethod);", "+", "+\t\t\t\tMethodBinding[] current = (MethodBinding[]) this.currentMethods.get(inheritedMethod.selector);", "+\t\t\t\tif (current != null) { // non visible methods cannot be overridden so a warning is issued", "+\t\t\t\t\tfoundMatch : for (int i = 0, length = current.length; i < length; i++) {", "+\t\t\t\t\t\tif (doesMethodOverride(current[i], inheritedMethod)) {", "+\t\t\t\t\t\t\tproblemReporter().overridesPackageDefaultMethod(current[i], inheritedMethod);", "+\t\t\t\t\t\t\tbreak foundMatch;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\tsuperType = superType.superclass();", "-\t\t\t\t\t\t\tfor (int e = 0; e < length; e++) {", "-\t\t\t\t\t\t\t\tMethodBinding existing = existingMethods[e];", "-\t\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "-\t\t\t\t\t\t\t\tif (areParametersEqual(existing, inheritedMethod) && existing.declaringClass.implementsInterface(superType, true))", "-// so if the implemented method is abstract & has a different return type then did it get a bridge method?", "+\t\t\t\t\t\t\t// look to see if any of the existingMethods implement this inheritedMethod", "+\t\t\t\t\t\t\tfor (int e = 0; e < length; e++)", "+\t\t\t\t\t\t\t\tif (isInterfaceMethodImplemented(inheritedMethod, existingMethods[e], superType))", "-\t\t\t\t\t\t\t}"]}], "num": 19578}