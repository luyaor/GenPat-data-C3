{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "15ef7ca226f640a3faf4ae668b7b6b47", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "912a22b6a70f2eb50b25be2ab4db2e49", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatter.java", "commitBeforeChange": "d2d42dc68198e20f3f5cc7326a07cced2c751eb5", "commitAfterChange": "add5c6babb13b20df1267306ec710a4efca88a4d", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 6, "signatureBeforeChange": "\r private void format()", "signatureAfterChange": "\r \tprivate void format()", "diff": ["- */\r", "-private void format() {\r", "- int token = 0;\r", "- int previousToken = 0;\r", "- int previousCompilableToken = 0;\r", "- int indentationOffset = 0;\r", "- int newLinesInWhitespace = 0;\r", "- // number of new lines in the previous whitespace token\r", "- // (used to leave blank lines before comments)\r", "- int pendingNewLines = 0;\r", "- boolean expectingOpenBrace = false;\r", "- boolean clearNonBlockIndents = false;\r", "- // true if all indentations till the 1st { (usefull after } or ;)\r", "- boolean pendingSpace = true;\r", "- boolean pendingNewlineAfterParen = false;\r", "- // true when a cr is to be put after a ) (in conditional statements)\r", "- boolean inAssignment = false;\r", "- boolean inArrayAssignment = false;\r", "- boolean inThrowsClause = false;\r", "- boolean inClassOrInterfaceHeader = false;\r", "- // openBracketCount is used to count the number of open brackets not closed yet.\r", "- int openBracketCount = 0;\r", "- \r", "-  int unarySignModifier = 0;\r", "- // openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "- // (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "- int openParenthesisCount = 1;\r", "- int[] openParenthesis = new int[10];\r", "- // tokenBeforeColon is used to know what token goes along with the current :\r", "- // it can be case or ?\r", "- int tokenBeforeColonCount = 0;\r", "- int[] tokenBeforeColon = new int[10];\r", "- constructionsCount = 0; // initializes the constructions count.\r", "- // contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "- int nlicsToken = 0;\r", "- // fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "- boolean specialElse = false;\r", "- // OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "- currentLineIndentationLevel += constructionsCount;\r", "- \r", "- // An InvalidInputException exception might cause the termination of this loop.\r", "- try {\r", "-  while (true) {\r", "-   // Get the next token.  Catch invalid input and output it\r", "-   // with minimal formatting, also catch end of input and\r", "-   // exit the loop.\r", "-   try {\r", "-    token = scanner.getNextToken();\r", "-   } catch (InvalidInputException e) {\r", "-    if (!handleInvalidToken(e)) {\r", "-     throw e;\r", "-    }\r", "-    token = 0;\r", "-   }\r", "-   if (token == Scanner.TokenNameEOF)\r", "-    break;\r", "-   /* ## MODIFYING the indentation level before generating new lines\r", "-   and indentation in the output string\r", "-   */\r", "-   // Removes all the indentations made by statements not followed by a block\r", "-   // except if the current token is ELSE, CATCH or if we are in a switch/case\r", "-   if (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "-    switch (token) {\r", "-     case TokenNameelse :\r", "-      if (constructionsCount > 0 && constructions[constructionsCount-1] == TokenNameelse){\r", "-       pendingNewLines = 1;\r", "-       specialElse = true;\r", "-      }\r", "-      indentationLevel += popInclusiveUntil(TokenNameif);\r", "-      break;\r", "-     case TokenNamecatch :\r", "-      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-      break;\r", "-     case TokenNamefinally :\r", "-      indentationLevel += popInclusiveUntil(TokenNamecatch);\r", "-      break;\r", "-     case TokenNamewhile :\r", "-      if (nlicsToken == TokenNamedo) {\r", "-       indentationLevel += pop(TokenNamedo);\r", "-       break;\r", "-      }\r", "-     default :\r", "-      indentationLevel += popExclusiveUntilBlockOrCase();\r", "-      // clear until a CASE, DEFAULT or BLOCK is encountered.\r", "-      // Thus, the indentationLevel is correctly cleared either\r", "-      // in a switch/case statement or in any other situation.\r", "-    }\r", "-    clearNonBlockIndents = false;\r", "-   }\r", "+\t */\r", "+\tprivate void format() {\r", "+\t\tint token = 0;\r", "+\t\tint previousToken = 0;\r", "+\t\tint previousCompilableToken = 0;\r", "+\t\tint indentationOffset = 0;\r", "+\t\tint newLinesInWhitespace = 0;\r", "-   // returns to the indentation level created by the SWITCH keyword\r", "-   // if the current token is a CASE or a DEFAULT\r", "+\t\t// number of new lines in the previous whitespace token\r", "+\t\t// (used to leave blank lines before comments)\r", "+\t\tint pendingNewLines = 0;\r", "+\t\tboolean expectingOpenBrace = false;\r", "+\t\tboolean clearNonBlockIndents = false;\r", "+\t\t// true if all indentations till the 1st { (usefull after } or ;)\r", "+\t\tboolean pendingSpace = true;\r", "+\t\tboolean pendingNewlineAfterParen = false;\r", "+\t\t// true when a cr is to be put after a ) (in conditional statements)\r", "+\t\tboolean inAssignment = false;\r", "+\t\tboolean inArrayAssignment = false;\r", "+\t\tboolean inThrowsClause = false;\r", "+\t\tboolean inClassOrInterfaceHeader = false;\r", "-   if (token == TokenNamecase || token == TokenNamedefault) {\r", "-    indentationLevel += pop(TokenNamecase);\r", "-   }\r", "+\t\t// openBracketCount is used to count the number of open brackets not closed yet.\r", "+\t\tint openBracketCount = 0;\r", "+\t\tint unarySignModifier = 0;\r", "-   if (token == Scanner.TokenNamethrows) {\r", "-    inThrowsClause = true;\r", "-   }\r", "+\t\t// openParenthesis[0] is used to count the parenthesis not belonging to a condition\r", "+\t\t// (eg foo();). parenthesis in for (...) are count elsewhere in the array.\r", "+\t\tint openParenthesisCount = 1;\r", "+\t\tint[] openParenthesis = new int[10];\r", "-   if (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "-    inClassOrInterfaceHeader = true;\r", "-   }\r", "-   /* ## APPEND newlines and indentations to the output string\r", "-   */\r", "+\t\t// tokenBeforeColon is used to know what token goes along with the current :\r", "+\t\t// it can be case or ?\r", "+\t\tint tokenBeforeColonCount = 0;\r", "+\t\tint[] tokenBeforeColon = new int[10];\r", "-   // Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "-   // Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "-   if (pendingNewlineAfterParen && previousCompilableToken == TokenNameelse && token == TokenNameif && options.compactElseIfMode){\r", "-    pendingNewlineAfterParen = false;\r", "-    pendingNewLines = 0;\r", "-    indentationLevel += pop(TokenNameelse);\r", "-    // because else if is now one single statement,\r", "-    // the indentation level after it is increased by one and not by 2\r", "-    // (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "-   }\r", "-   \r", "-   // Add a newline & indent to the formatted source string if\r", "-   // a for/if-else/while statement was scanned and there is no block\r", "-   // following it.\r", "-   \r", "-   pendingNewlineAfterParen = pendingNewlineAfterParen || (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "-   if (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "-    pendingNewlineAfterParen = false;\r", "+\t\tconstructionsCount = 0; // initializes the constructions count.\r", "-    // Do to add a newline & indent sequence if the current token is an\r", "-    // open brace or a period or if the current token is a semi-colon and the\r", "-    // previous token is a close paren.\r", "-    // add a new line if a parenthesis belonging to a for() statement\r", "-    // has been closed and the current token is not an opening brace\r", "+\t\t// contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.\r", "+\t\tint nlicsToken = 0;\r", "-    if (token != TokenNameLBRACE && !isComment(token)\r", "-    // to avoid adding new line between else and a comment\r", "-      && token != TokenNameDOT\r", "-      && ! (previousCompilableToken == TokenNameRPAREN\r", "-       && token == TokenNameSEMICOLON)) {\r", "-     newLine(1);\r", "-     currentLineIndentationLevel = indentationLevel;\r", "-     pendingNewLines = 0;\r", "-     pendingSpace = false;\r", "-    } else {\r", "-     if (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "-      newLine(1);\r", "-      if (constructionsCount > 0\r", "-       && constructions[constructionsCount - 1] != BLOCK\r", "-       && constructions[constructionsCount - 1] != NONINDENT_BLOCK) {\r", "-       currentLineIndentationLevel = indentationLevel - 1;\r", "-      } else {\r", "-       currentLineIndentationLevel = indentationLevel;\r", "-      }\r", "-      pendingNewLines = 0;\r", "-      pendingSpace = false;\r", "-     }\r", "-    }\r", "-   }\r", "+\t\t// fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else \r", "+\t\tboolean specialElse = false;\r", "-   if (token == TokenNameLBRACE\r", "-    && options.newLineBeforeOpeningBraceMode\r", "-    && constructionsCount > 0\r", "-    && constructions[constructionsCount - 1] == TokenNamedo) {\r", "-    newLine(1);\r", "-    currentLineIndentationLevel = indentationLevel - 1;\r", "-    pendingNewLines = 0;\r", "-    pendingSpace = false;\r", "-   }\r", "+\t\t// OPTION (IndentationLevel): initial indentation level may be non-zero.\r", "+\t\tcurrentLineIndentationLevel += constructionsCount;\r", "-   // see PR 1G5G8EC\r", "-   if (token == TokenNameLBRACE && inThrowsClause) {\r", "-    inThrowsClause = false;      \r", "-    if (options.newLineBeforeOpeningBraceMode) {\r", "-     newLine(1);\r", "-     currentLineIndentationLevel = indentationLevel;\r", "-     pendingNewLines = 0;\r", "-     pendingSpace = false;\r", "-    }\r", "-   }\r", "-   \r", "-   // see PR 1G5G82G\r", "-   if (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "-    inClassOrInterfaceHeader = false;\r", "-    if (options.newLineBeforeOpeningBraceMode) {\r", "-     newLine(1);\r", "-     currentLineIndentationLevel = indentationLevel;\r", "-     pendingNewLines = 0;\r", "-     pendingSpace = false;\r", "-    }\r", "-   }            \r", "-   // Add pending new lines to the formatted source string.\r", "-   // Note: pending new lines are not added if the current token\r", "-   // is a single line comment or whitespace.\r", "-   // if the comment is between parenthesis, there is no blank line preservation\r", "-   // (if it's a one-line comment, a blank line is added after it).\r", "+\t\t// An InvalidInputException exception might cause the termination of this loop.\r", "+\t\ttry {\r", "+\t\t\twhile (true) {\r", "+\t\t\t\t// Get the next token.  Catch invalid input and output it\r", "+\t\t\t\t// with minimal formatting, also catch end of input and\r", "+\t\t\t\t// exit the loop.\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\ttoken = scanner.getNextToken();\r", "+\t\t\t\t} catch (InvalidInputException e) {\r", "+\t\t\t\t\tif (!handleInvalidToken(e)) {\r", "+\t\t\t\t\t\tthrow e;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\ttoken = 0;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (token == Scanner.TokenNameEOF)\r", "+\t\t\t\t\tbreak;\r", "-   if (((pendingNewLines > 0 && (!isComment(token)))\r", "-     || (newLinesInWhitespace > 0\r", "-       && (openParenthesisCount <= 1 && isComment(token)))\r", "-     || (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "-    && token != Scanner.TokenNameWHITESPACE) {\r", "+\t\t\t\t/* ## MODIFYING the indentation level before generating new lines\r", "+\t\t\t\tand indentation in the output string\r", "+\t\t\t\t*/\r", "-    // Do not add newline & indent between an adjoining close brace and\r", "-    // close paren.  Anonymous inner classes may use this form.\r", "+\t\t\t\t// Removes all the indentations made by statements not followed by a block\r", "+\t\t\t\t// except if the current token is ELSE, CATCH or if we are in a switch/case\r", "+\t\t\t\tif (clearNonBlockIndents && (token != Scanner.TokenNameWHITESPACE)) {\r", "+\t\t\t\t\tswitch (token) {\r", "+\t\t\t\t\t\tcase TokenNameelse :\r", "+\t\t\t\t\t\t\tif (constructionsCount > 0\r", "+\t\t\t\t\t\t\t\t&& constructions[constructionsCount - 1] == TokenNameelse) {\r", "+\t\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\t\tspecialElse = true;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNameif);\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\tcase TokenNamecatch :\r", "+\t\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\tcase TokenNamefinally :\r", "+\t\t\t\t\t\t\tindentationLevel += popInclusiveUntil(TokenNamecatch);\r", "+\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\tcase TokenNamewhile :\r", "+\t\t\t\t\t\t\tif (nlicsToken == TokenNamedo) {\r", "+\t\t\t\t\t\t\t\tindentationLevel += pop(TokenNamedo);\r", "+\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tdefault :\r", "+\t\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlockOrCase();\r", "+\t\t\t\t\t\t\t// clear until a CASE, DEFAULT or BLOCK is encountered.\r", "+\t\t\t\t\t\t\t// Thus, the indentationLevel is correctly cleared either\r", "+\t\t\t\t\t\t\t// in a switch/case statement or in any other situation.\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tclearNonBlockIndents = false;\r", "+\t\t\t\t}\r", "+\t\t\t\t// returns to the indentation level created by the SWITCH keyword\r", "+\t\t\t\t// if the current token is a CASE or a DEFAULT\r", "+\t\t\t\tif (token == TokenNamecase || token == TokenNamedefault) {\r", "+\t\t\t\t\tindentationLevel += pop(TokenNamecase);\r", "+\t\t\t\t}\r", "+\t\t\t\tif (token == Scanner.TokenNamethrows) {\r", "+\t\t\t\t\tinThrowsClause = true;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (token == Scanner.TokenNameclass || token == Scanner.TokenNameinterface) {\r", "+\t\t\t\t\tinClassOrInterfaceHeader = true;\r", "+\t\t\t\t}\r", "+\t\t\t\t/* ## APPEND newlines and indentations to the output string\r", "+\t\t\t\t*/\r", "+\t\t\t\t// Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.\r", "+\t\t\t\t// Fix for 1ETLWPZ: IVJCOM:ALL - incorrect \"else if\" formatting\r", "+\t\t\t\tif (pendingNewlineAfterParen\r", "+\t\t\t\t\t&& previousCompilableToken == TokenNameelse\r", "+\t\t\t\t\t&& token == TokenNameif\r", "+\t\t\t\t\t&& options.compactElseIfMode) {\r", "+\t\t\t\t\tpendingNewlineAfterParen = false;\r", "+\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\tindentationLevel += pop(TokenNameelse);\r", "+\t\t\t\t\t// because else if is now one single statement,\r", "+\t\t\t\t\t// the indentation level after it is increased by one and not by 2\r", "+\t\t\t\t\t// (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).\r", "+\t\t\t\t}\r", "+\t\t\t\t// Add a newline & indent to the formatted source string if\r", "+\t\t\t\t// a for/if-else/while statement was scanned and there is no block\r", "+\t\t\t\t// following it.\r", "+\t\t\t\tpendingNewlineAfterParen =\r", "+\t\t\t\t\tpendingNewlineAfterParen\r", "+\t\t\t\t\t\t|| (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);\r", "+\t\t\t\tif (pendingNewlineAfterParen && token != Scanner.TokenNameWHITESPACE) {\r", "+\t\t\t\t\tpendingNewlineAfterParen = false;\r", "-    boolean closeBraceAndCloseParen = \r", "-      previousToken == TokenNameRBRACE && token == TokenNameRPAREN; \r", "+\t\t\t\t\t// Do to add a newline & indent sequence if the current token is an\r", "+\t\t\t\t\t// open brace or a period or if the current token is a semi-colon and the\r", "+\t\t\t\t\t// previous token is a close paren.\r", "+\t\t\t\t\t// add a new line if a parenthesis belonging to a for() statement\r", "+\t\t\t\t\t// has been closed and the current token is not an opening brace\r", "+\t\t\t\t\tif (token != TokenNameLBRACE\r", "+\t\t\t\t\t\t&& !isComment(token) // to avoid adding new line between else and a comment\r", "+\t\t\t\t\t\t&& token != TokenNameDOT\r", "+\t\t\t\t\t\t&& !(previousCompilableToken == TokenNameRPAREN && token == TokenNameSEMICOLON)) {\r", "+\t\t\t\t\t\tnewLine(1);\r", "+\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "+\t\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tif (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {\r", "+\t\t\t\t\t\t\tnewLine(1);\r", "+\t\t\t\t\t\t\tif (constructionsCount > 0\r", "+\t\t\t\t\t\t\t\t&& constructions[constructionsCount - 1] != BLOCK\r", "+\t\t\t\t\t\t\t\t&& constructions[constructionsCount - 1] != NONINDENT_BLOCK) {\r", "+\t\t\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel - 1;\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tif (token == TokenNameLBRACE\r", "+\t\t\t\t\t&& options.newLineBeforeOpeningBraceMode\r", "+\t\t\t\t\t&& constructionsCount > 0\r", "+\t\t\t\t\t&& constructions[constructionsCount - 1] == TokenNamedo) {\r", "+\t\t\t\t\tnewLine(1);\r", "+\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel - 1;\r", "+\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t}\r", "+\t\t\t\t// see PR 1G5G8EC\r", "+\t\t\t\tif (token == TokenNameLBRACE && inThrowsClause) {\r", "+\t\t\t\t\tinThrowsClause = false;\r", "+\t\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "+\t\t\t\t\t\tnewLine(1);\r", "+\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "+\t\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\t// see PR 1G5G82G\r", "+\t\t\t\tif (token == TokenNameLBRACE && inClassOrInterfaceHeader) {\r", "+\t\t\t\t\tinClassOrInterfaceHeader = false;\r", "+\t\t\t\t\tif (options.newLineBeforeOpeningBraceMode) {\r", "+\t\t\t\t\t\tnewLine(1);\r", "+\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel;\r", "+\t\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\t// Add pending new lines to the formatted source string.\r", "+\t\t\t\t// Note: pending new lines are not added if the current token\r", "+\t\t\t\t// is a single line comment or whitespace.\r", "+\t\t\t\t// if the comment is between parenthesis, there is no blank line preservation\r", "+\t\t\t\t// (if it's a one-line comment, a blank line is added after it).\r", "+\t\t\t\tif (((pendingNewLines > 0 && (!isComment(token)))\r", "+\t\t\t\t\t|| (newLinesInWhitespace > 0 && (openParenthesisCount <= 1 && isComment(token)))\r", "+\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))\r", "+\t\t\t\t\t&& token != Scanner.TokenNameWHITESPACE) {\r", "-    // OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "-    // between close brace and else, (do) while, catch, and finally if\r", "-    // newlineInCompoundStatement is true.\r", "+\t\t\t\t\t// Do not add newline & indent between an adjoining close brace and\r", "+\t\t\t\t\t// close paren.  Anonymous inner classes may use this form.\r", "+\t\t\t\t\tboolean closeBraceAndCloseParen =\r", "+\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameRPAREN;\r", "+\t\t\t\t\t// OPTION (NewLineInCompoundStatement): do not add newline & indent\r", "+\t\t\t\t\t// between close brace and else, (do) while, catch, and finally if\r", "+\t\t\t\t\t// newlineInCompoundStatement is true.\r", "+\t\t\t\t\tboolean nlicsOption =\r", "+\t\t\t\t\t\tpreviousToken == TokenNameRBRACE\r", "+\t\t\t\t\t\t\t&& !options.newlineInControlStatementMode\r", "+\t\t\t\t\t\t\t&& (token == TokenNameelse\r", "+\t\t\t\t\t\t\t\t|| (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "+\t\t\t\t\t\t\t\t|| token == TokenNamecatch\r", "+\t\t\t\t\t\t\t\t|| token == TokenNamefinally);\r", "-    boolean nlicsOption = \r", "-      previousToken == TokenNameRBRACE\r", "-       && !options.newlineInControlStatementMode\r", "-       && (token == TokenNameelse\r", "-        || (token == TokenNamewhile && nlicsToken == TokenNamedo)\r", "-        || token == TokenNamecatch\r", "-        || token == TokenNamefinally);\r", "+\t\t\t\t\t// Do not add a newline & indent between a close brace and semi-colon.\r", "+\t\t\t\t\tboolean semiColonAndCloseBrace =\r", "+\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameSEMICOLON;\r", "-    // Do not add a newline & indent between a close brace and semi-colon.\r", "+\t\t\t\t\t// Do not add a new line & indent between a multiline comment and a opening brace\r", "+\t\t\t\t\tboolean commentAndOpenBrace =\r", "+\t\t\t\t\t\tpreviousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "-    boolean semiColonAndCloseBrace = \r", "-      previousToken == TokenNameRBRACE && token == TokenNameSEMICOLON; \r", "+\t\t\t\t\t// Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "+\t\t\t\t\tboolean commaAndCloseBrace =\r", "+\t\t\t\t\t\tpreviousToken == TokenNameRBRACE && token == TokenNameCOMMA;\r", "-    // Do not add a new line & indent between a multiline comment and a opening brace\r", "+\t\t\t\t\t// Add a newline and indent, if appropriate.\r", "+\t\t\t\t\tif (specialElse\r", "+\t\t\t\t\t\t|| (!commentAndOpenBrace\r", "+\t\t\t\t\t\t\t&& !closeBraceAndCloseParen\r", "+\t\t\t\t\t\t\t&& !nlicsOption\r", "+\t\t\t\t\t\t\t&& !semiColonAndCloseBrace\r", "+\t\t\t\t\t\t\t&& !commaAndCloseBrace)) {\r", "-    boolean commentAndOpenBrace = previousToken == Scanner.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;\r", "-    \r", "-    // Do not add a newline & indent between a close brace and a colon (in array assignments, for example).\r", "-    \r", "-    boolean commaAndCloseBrace =\r", "-      previousToken == TokenNameRBRACE && token == TokenNameCOMMA; \r", "+\t\t\t\t\t\t// if clearAllBlankLinesMode=false, leaves the blank lines\r", "+\t\t\t\t\t\t// inserted by the user\r", "+\t\t\t\t\t\t// if clearAllBlankLinesMode=true, removes all of then\r", "+\t\t\t\t\t\t// and insert only blank lines required by the formatting.\r", "+\t\t\t\t\t\tif (!options.clearAllBlankLinesMode) {\r", "+\t\t\t\t\t\t\t//  (isComment(token))\r", "+\t\t\t\t\t\t\tpendingNewLines =\r", "+\t\t\t\t\t\t\t\t(pendingNewLines < newLinesInWhitespace)\r", "+\t\t\t\t\t\t\t\t\t? newLinesInWhitespace\r", "+\t\t\t\t\t\t\t\t\t: pendingNewLines;\r", "+\t\t\t\t\t\t\tpendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "+\t\t\t\t\t\t\tcontainsOpenCloseBraces = true;\r", "+\t\t\t\t\t\t\tindentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "+\t\t\t\t\t\t\tif (isComment(previousToken)) {\r", "+\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t/*  if (!(constructionsCount > 1\r", "+\t\t\t\t\t\t\t\t        && constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "+\t\t\t\t\t\t\t\t        && (constructions[constructionsCount-2] == TokenNamefor \r", "+\t\t\t\t\t\t\t\t         || constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "+\t\t\t\t\t\t\t\tif (options.newLineInEmptyBlockMode) {\r", "+\t\t\t\t\t\t\t\t\tif (inArrayAssignment) {\r", "+\t\t\t\t\t\t\t\t\t\tnewLine(1); // array assigment with an empty block\r", "+\t\t\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "+\t\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\t// }\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t// see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "+\t\t\t\t\t\t\tif (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK\r", "+\t\t\t\t\t\t\t\t|| previousToken == Scanner.TokenNameCOMMENT_JAVADOC)\r", "+\t\t\t\t\t\t\t\t&& token == TokenNameSEMICOLON)) {\r", "+\t\t\t\t\t\t\t\tnewLine(pendingNewLines);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (((previousCompilableToken == TokenNameSEMICOLON)\r", "+\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameLBRACE)\r", "+\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameRBRACE)\r", "+\t\t\t\t\t\t\t|| (isComment(previousToken)))\r", "+\t\t\t\t\t\t\t&& (token == TokenNameRBRACE)) {\r", "+\t\t\t\t\t\t\tindentationOffset = -1;\r", "+\t\t\t\t\t\t\tindentationLevel += popExclusiveUntilBlock();\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "+\t\t\t\t\t\t\t// PR 1FI5IPO\r", "+\t\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tcurrentLineIndentationLevel = indentationLevel + indentationOffset;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tindentationOffset = 0;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\tnewLinesInWhitespace = 0;\r", "+\t\t\t\t\tspecialElse = false;\r", "-    // Add a newline and indent, if appropriate.\r", "+\t\t\t\t\tif (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "+\t\t\t\t\t\tnlicsToken = 0;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t\tswitch (token) {\r", "+\t\t\t\t\tcase TokenNameelse :\r", "+\t\t\t\t\tcase TokenNamefinally :\r", "+\t\t\t\t\t\texpectingOpenBrace = true;\r", "+\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "+\t\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNamecase :\r", "+\t\t\t\t\tcase TokenNamedefault :\r", "+\t\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+\t\t\t\t\t\t\tSystem.arraycopy(\r", "+\t\t\t\t\t\t\t\ttokenBeforeColon,\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]),\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\ttokenBeforeColonCount);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "+\t\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecase);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameQUESTION :\r", "+\t\t\t\t\t\tif (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "+\t\t\t\t\t\t\tSystem.arraycopy(\r", "+\t\t\t\t\t\t\t\ttokenBeforeColon,\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\t(tokenBeforeColon = new int[tokenBeforeColonCount * 2]),\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\ttokenBeforeColonCount);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\ttokenBeforeColon[tokenBeforeColonCount++] = token;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameswitch :\r", "+\t\t\t\t\tcase TokenNamefor :\r", "+\t\t\t\t\tcase TokenNameif :\r", "+\t\t\t\t\tcase TokenNamewhile :\r", "+\t\t\t\t\t\tif (openParenthesisCount == openParenthesis.length) {\r", "+\t\t\t\t\t\t\tSystem.arraycopy(\r", "+\t\t\t\t\t\t\t\topenParenthesis,\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\t(openParenthesis = new int[openParenthesisCount * 2]),\r", "+\t\t\t\t\t\t\t\t0,\r", "+\t\t\t\t\t\t\t\topenParenthesisCount);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\topenParenthesis[openParenthesisCount++] = 0;\r", "+\t\t\t\t\t\texpectingOpenBrace = true;\r", "-    if (specialElse || (!commentAndOpenBrace && !closeBraceAndCloseParen && !nlicsOption && !semiColonAndCloseBrace && !commaAndCloseBrace)) {\r", "-     // if clearAllBlankLinesMode=false, leaves the blank lines\r", "-     // inserted by the user\r", "-     // if clearAllBlankLinesMode=true, removes all of then\r", "-     // and insert only blank lines required by the formatting.\r", "-     if (!options.clearAllBlankLinesMode) {\r", "-      pendingNewLines = \r", "-        (pendingNewLines < newLinesInWhitespace)\r", "-//                              (isComment(token))\r", "-         ? newLinesInWhitespace \r", "-         : pendingNewLines;\r", "-      pendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;\r", "-     }\r", "+\t\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNametry :\r", "+\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "+\t\t\t\t\tcase TokenNamecatch :\r", "+\t\t\t\t\t\t// several CATCH statements can be contiguous.\r", "+\t\t\t\t\t\t// a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "+\t\t\t\t\t\t// as CATCH and TRY are the same token in the stack).\r", "+\t\t\t\t\t\texpectingOpenBrace = true;\r", "+\t\t\t\t\t\tindentationLevel += pushControlStatement(TokenNamecatch);\r", "+\t\t\t\t\t\tbreak;\r", "-     if (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {\r", "-      containsOpenCloseBraces = true;\r", "-      indentationLevelForOpenCloseBraces = currentLineIndentationLevel;\r", "-      if (isComment(previousToken)) {\r", "-       newLine(pendingNewLines);\r", "-      } else {\r", "-/*                          if (!(constructionsCount > 1\r", "-        && constructions[constructionsCount-1] == NONINDENT_BLOCK\r", "-        && (constructions[constructionsCount-2] == TokenNamefor \r", "-         || constructions[constructionsCount-2] == TokenNamewhile))) {*/\r", "-       if (options.newLineInEmptyBlockMode) {\r", "-        if (inArrayAssignment) {\r", "-         newLine(1); // array assigment with an empty block\r", "-        } else {\r", "-         newLine(pendingNewLines);\r", "-        }\r", "-       }\r", "-//                          }\r", "-      }\r", "-     } else {\r", "-      // see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'\r", "-      if (!((previousToken == Scanner.TokenNameCOMMENT_BLOCK || previousToken == Scanner.TokenNameCOMMENT_JAVADOC) && token == TokenNameSEMICOLON)) {\r", "-       newLine(pendingNewLines);                       \r", "-      }\r", "-     }\r", "-     if (((previousCompilableToken == TokenNameSEMICOLON)\r", "-       || (previousCompilableToken == TokenNameLBRACE)\r", "-       || (previousCompilableToken == TokenNameRBRACE)\r", "-       || (isComment(previousToken)))\r", "-      && (token == TokenNameRBRACE)) {\r", "-      indentationOffset = -1;\r", "-      indentationLevel += popExclusiveUntilBlock();\r", "-     }\r", "+\t\t\t\t\tcase TokenNamedo :\r", "+\t\t\t\t\t\texpectingOpenBrace = true;\r", "+\t\t\t\t\t\tindentationLevel += pushControlStatement(token);\r", "+\t\t\t\t\t\tnlicsToken = token;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNamenew :\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameLPAREN :\r", "-     if (previousToken == Scanner.TokenNameCOMMENT_LINE && inAssignment) {\r", "-      // PR 1FI5IPO\r", "-      currentLineIndentationLevel++;\r", "-     } else {\r", "-      currentLineIndentationLevel = indentationLevel + indentationOffset;\r", "-     }\r", "+\t\t\t\t\t\t// Put a space between the previous and current token if the\r", "+\t\t\t\t\t\t// previous token was not a keyword, open paren, logical\r", "+\t\t\t\t\t\t// compliment (eg: !), semi-colon, open brace, close brace,\r", "+\t\t\t\t\t\t// super, or this.\r", "+\t\t\t\t\t\tif (previousCompilableToken != TokenNameLBRACKET\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "+\t\t\t\t\t\t\t&& previousToken != 0\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameNOT\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameLPAREN\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameTWIDDLE\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameSEMICOLON\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameLBRACE\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameRBRACE\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNamesuper\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNamethis) {\r", "+\t\t\t\t\t\t\tspace();\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t// If in a for/if/while statement, increase the parenthesis count\r", "+\t\t\t\t\t\t// for the current openParenthesisCount\r", "+\t\t\t\t\t\t// else increase the count for stand alone parenthesis.\r", "+\t\t\t\t\t\tif (openParenthesisCount > 0)\r", "+\t\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]++;\r", "+\t\t\t\t\t\telse\r", "+\t\t\t\t\t\t\topenParenthesis[0]++;\r", "-     pendingSpace = false;\r", "-     indentationOffset = 0;\r", "-    }\r", "-    pendingNewLines = 0;\r", "-    newLinesInWhitespace = 0;\r", "-    specialElse = false;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameRPAREN :\r", "-    if (nlicsToken == TokenNamedo && token == TokenNamewhile) {\r", "-     nlicsToken = 0;\r", "-    }\r", "-   }\r", "+\t\t\t\t\t\t// Decrease the parenthesis count\r", "+\t\t\t\t\t\t// if there is no more unclosed parenthesis,\r", "+\t\t\t\t\t\t// a new line and indent may be append (depending on the next token).\r", "+\t\t\t\t\t\tif ((openParenthesisCount > 1)\r", "+\t\t\t\t\t\t\t&& (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "+\t\t\t\t\t\t\topenParenthesis[openParenthesisCount - 1]--;\r", "+\t\t\t\t\t\t\tif (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "+\t\t\t\t\t\t\t\tpendingNewlineAfterParen = true;\r", "+\t\t\t\t\t\t\t\tinAssignment = false;\r", "+\t\t\t\t\t\t\t\topenParenthesisCount--;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\topenParenthesis[0]--;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameLBRACE :\r", "+\t\t\t\t\t\tif ((previousCompilableToken == TokenNameRBRACKET)\r", "+\t\t\t\t\t\t\t|| (previousCompilableToken == TokenNameEQUAL)) {\r", "+\t\t\t\t\t\t\t//                  if (previousCompilableToken == TokenNameRBRACKET) {\r", "+\t\t\t\t\t\t\tinArrayAssignment = true;\r", "+\t\t\t\t\t\t\tinAssignment = false;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (inArrayAssignment) {\r", "+\t\t\t\t\t\t\tindentationLevel += pushBlock();\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t// Add new line and increase indentation level after open brace.\r", "+\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\tindentationLevel += pushBlock();\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameRBRACE :\r", "+\t\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN) {\r", "+\t\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tif (inArrayAssignment) {\r", "+\t\t\t\t\t\t\tinArrayAssignment = false;\r", "+\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\tindentationLevel += popInclusiveUntilBlock();\r", "-   switch (token) {\r", "-    case TokenNameelse :\r", "-    case TokenNamefinally :\r", "-     expectingOpenBrace = true;\r", "-     pendingNewlineAfterParen = true;\r", "-     indentationLevel += pushControlStatement(token);\r", "-     break;\r", "-    case TokenNamecase :\r", "-    case TokenNamedefault :\r", "-     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-      System.arraycopy(\r", "-        tokenBeforeColon, \r", "-        0, \r", "-        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-        0, \r", "-        tokenBeforeColonCount); \r", "-     }\r", "-     tokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;\r", "-     indentationLevel += pushControlStatement(TokenNamecase);\r", "-     break;\r", "-    case TokenNameQUESTION :\r", "-     if (tokenBeforeColonCount == tokenBeforeColon.length) {\r", "-      System.arraycopy(\r", "-        tokenBeforeColon, \r", "-        0, \r", "-        (tokenBeforeColon = new int[tokenBeforeColonCount * 2]), \r", "-        0, \r", "-        tokenBeforeColonCount); \r", "-     }\r", "-     tokenBeforeColon[tokenBeforeColonCount++] = token;\r", "-     break;\r", "-    case TokenNameswitch :\r", "-    case TokenNamefor :\r", "-    case TokenNameif :\r", "-    case TokenNamewhile :\r", "-     if (openParenthesisCount == openParenthesis.length) {\r", "-      System.arraycopy(\r", "-        openParenthesis, \r", "-        0, \r", "-        (openParenthesis = new int[openParenthesisCount * 2]), \r", "-        0, \r", "-        openParenthesisCount); \r", "-     }\r", "-     openParenthesis[openParenthesisCount++] = 0;\r", "-     expectingOpenBrace = true;\r", "-     \r", "-     indentationLevel += pushControlStatement(token);\r", "-     break;\r", "-    case TokenNametry :\r", "-     pendingNewlineAfterParen = true;\r", "-    case TokenNamecatch :\r", "-     // several CATCH statements can be contiguous.\r", "-     // a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,\r", "-     // as CATCH and TRY are the same token in the stack).\r", "-     expectingOpenBrace = true;\r", "-     indentationLevel += pushControlStatement(TokenNamecatch);\r", "-     break;\r", "+\t\t\t\t\t\t\tif (previousCompilableToken == TokenNameRPAREN) {\r", "+\t\t\t\t\t\t\t\t// fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "+\t\t\t\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "+\t\t\t\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tif (constructionsCount > 0) {\r", "+\t\t\t\t\t\t\t\tswitch (constructions[constructionsCount - 1]) {\r", "+\t\t\t\t\t\t\t\t\tcase TokenNamefor :\r", "+\t\t\t\t\t\t\t\t\t\t//indentationLevel += popExclusiveUntilBlock();\r", "+\t\t\t\t\t\t\t\t\t\t//break;\r", "+\t\t\t\t\t\t\t\t\tcase TokenNameswitch :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNameif :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNameelse :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNametry :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNamecatch :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNamefinally :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNamewhile :\r", "+\t\t\t\t\t\t\t\t\tcase TokenNamedo :\r", "+\t\t\t\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "+\t\t\t\t\t\t\t\t\tdefault :\r", "+\t\t\t\t\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameLBRACKET :\r", "+\t\t\t\t\t\topenBracketCount++;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameRBRACKET :\r", "+\t\t\t\t\t\topenBracketCount -= (openBracketCount > 0) ? 1 : 0;\r", "+\t\t\t\t\t\t// if there is no left bracket to close, the right bracket is ignored.\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameCOMMA :\r", "+\t\t\t\t\tcase TokenNameDOT :\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameSEMICOLON :\r", "-    case TokenNamedo :\r", "-     expectingOpenBrace = true;\r", "-     indentationLevel += pushControlStatement(token);\r", "-     nlicsToken = token;\r", "-     break;\r", "-    case TokenNamenew :\r", "-     break;\r", "-    case TokenNameLPAREN :\r", "+\t\t\t\t\t\t// Do not generate line terminators in the definition of\r", "+\t\t\t\t\t\t// the for statement.\r", "+\t\t\t\t\t\t// if not in this case, jump a line and reduce indentation after the brace\r", "+\t\t\t\t\t\t// if the block it closes belongs to a conditional statement (if, while, do...).\r", "+\t\t\t\t\t\tif (openParenthesisCount <= 1) {\r", "+\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\tif (expectingOpenBrace) {\r", "+\t\t\t\t\t\t\t\tclearNonBlockIndents = true;\r", "+\t\t\t\t\t\t\t\texpectingOpenBrace = false;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tinAssignment = false;\r", "+\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNamePLUS_PLUS :\r", "+\t\t\t\t\tcase TokenNameMINUS_MINUS :\r", "-     // Put a space between the previous and current token if the\r", "-     // previous token was not a keyword, open paren, logical\r", "-     // compliment (eg: !), semi-colon, open brace, close brace,\r", "-     // super, or this.\r", "+\t\t\t\t\t\t// Do not put a space between a post-increment/decrement\r", "+\t\t\t\t\t\t// and the identifier being modified.\r", "+\t\t\t\t\t\tif (previousToken == TokenNameIdentifier\r", "+\t\t\t\t\t\t\t|| previousToken == TokenNameRBRACKET) {\r", "+\t\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNamePLUS : // previously ADDITION\r", "+\t\t\t\t\tcase TokenNameMINUS :\r", "-     if (previousCompilableToken != TokenNameLBRACKET\r", "-      && previousToken != TokenNameIdentifier\r", "-      && previousToken != 0\r", "-      && previousToken != TokenNameNOT\r", "-      && previousToken != TokenNameLPAREN\r", "-      && previousToken != TokenNameTWIDDLE\r", "-      && previousToken != TokenNameSEMICOLON\r", "-      && previousToken != TokenNameLBRACE\r", "-      && previousToken != TokenNameRBRACE\r", "-      && previousToken != TokenNamesuper\r", "-      && previousToken != TokenNamethis) {\r", "-      space();\r", "-     }\r", "+\t\t\t\t\t\t// Handle the unary operators plus and minus via a flag\r", "+\t\t\t\t\t\tif (!isLiteralToken(previousToken)\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameIdentifier\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameRPAREN\r", "+\t\t\t\t\t\t\t&& previousToken != TokenNameRBRACKET) {\r", "+\t\t\t\t\t\t\tunarySignModifier = 1;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameCOLON :\r", "+\t\t\t\t\t\t// In a switch/case statement, add a newline & indent\r", "+\t\t\t\t\t\t// when a colon is encountered.\r", "+\t\t\t\t\t\tif (tokenBeforeColonCount > 0) {\r", "+\t\t\t\t\t\t\tif (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "+\t\t\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\ttokenBeforeColonCount--;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase TokenNameEQUAL :\r", "+\t\t\t\t\t\tinAssignment = true;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase Scanner.TokenNameCOMMENT_LINE :\r", "+\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\tif (inAssignment) {\r", "+\t\t\t\t\t\t\tcurrentLineIndentationLevel++;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak; // a line is always inserted after a one-line comment\r", "+\t\t\t\t\tcase Scanner.TokenNameCOMMENT_JAVADOC :\r", "+\t\t\t\t\tcase Scanner.TokenNameCOMMENT_BLOCK :\r", "+\t\t\t\t\t\tcurrentCommentOffset = getCurrentCommentOffset();\r", "+\t\t\t\t\t\tpendingNewLines = 1;\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tcase Scanner.TokenNameWHITESPACE :\r", "-     // If in a for/if/while statement, increase the parenthesis count\r", "-     // for the current openParenthesisCount\r", "-     // else increase the count for stand alone parenthesis.\r", "-     if (openParenthesisCount > 0)\r", "-      openParenthesis[openParenthesisCount - 1]++;\r", "-     else\r", "-      openParenthesis[0]++;\r", "+\t\t\t\t\t\t// Count the number of line terminators in the whitespace so\r", "+\t\t\t\t\t\t// line spacing can be preserved near comments.\r", "+\t\t\t\t\t\tchar[] source = scanner.source;\r", "+\t\t\t\t\t\tnewLinesInWhitespace = 0;\r", "+\t\t\t\t\t\tfor (int i = scanner.startPosition, max = scanner.currentPosition;\r", "+\t\t\t\t\t\t\ti < max;\r", "+\t\t\t\t\t\t\ti++) {\r", "+\t\t\t\t\t\t\tif (source[i] == '\\n') {\r", "+\t\t\t\t\t\t\t\tnewLinesInWhitespace++;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tincreaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t\tdefault :\r", "+\t\t\t\t\t\tif ((token == TokenNameIdentifier)\r", "+\t\t\t\t\t\t\t|| isLiteralToken(token)\r", "+\t\t\t\t\t\t\t|| token == TokenNamesuper\r", "+\t\t\t\t\t\t\t|| token == TokenNamethis) {\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNameRPAREN :\r", "+\t\t\t\t\t\t\t// Do not put a space between a unary operator\r", "+\t\t\t\t\t\t\t// (eg: ++, --, +, -) and the identifier being modified.\r", "+\t\t\t\t\t\t\tif (previousToken == TokenNamePLUS_PLUS\r", "+\t\t\t\t\t\t\t\t|| previousToken == TokenNameMINUS_MINUS\r", "+\t\t\t\t\t\t\t\t|| (previousToken == TokenNamePLUS && unarySignModifier > 0)\r", "+\t\t\t\t\t\t\t\t|| (previousToken == TokenNameMINUS && unarySignModifier > 0)) {\r", "+\t\t\t\t\t\t\t\tpendingSpace = false;\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\tunarySignModifier = 0;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tbreak;\r", "+\t\t\t\t}\r", "+\t\t\t\t// Do not output whitespace tokens.\r", "+\t\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "-     // Decrease the parenthesis count\r", "-     // if there is no more unclosed parenthesis,\r", "-     // a new line and indent may be append (depending on the next token).\r", "+\t\t\t\t\t/* Add pending space to the formatted source string.\r", "+\t\t\t\t\tDo not output a space under the following circumstances:\r", "+\t\t\t\t\t1) this is the first pass\r", "+\t\t\t\t\t2) previous token is an open paren\r", "+\t\t\t\t\t3) previous token is a period\r", "+\t\t\t\t\t4) previous token is the logical compliment (eg: !)\r", "+\t\t\t\t\t5) previous token is the bitwise compliment (eg: ~)\r", "+\t\t\t\t\t6) previous token is the open bracket (eg: [)\r", "+\t\t\t\t\t7) in an assignment statement, if the previous token is an \r", "+\t\t\t\t\topen brace or the current token is a close brace\r", "+\t\t\t\t\t8) previous token is a single line comment\r", "+\t\t\t\t\t*/\r", "+\t\t\t\t\tboolean openAndCloseBrace =\r", "+\t\t\t\t\t\tpreviousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "-     if ((openParenthesisCount > 1)\r", "-      && (openParenthesis[openParenthesisCount - 1] > 0)) {\r", "-      openParenthesis[openParenthesisCount - 1]--;\r", "-      if (openParenthesis[openParenthesisCount - 1] <= 0) {\r", "-       pendingNewlineAfterParen = true;\r", "-       inAssignment = false;\r", "-       openParenthesisCount--;\r", "+\t\t\t\t\tif (pendingSpace\r", "+\t\t\t\t\t\t&& insertSpaceAfter(previousToken)\r", "+\t\t\t\t\t\t&& !(inAssignment\r", "+\t\t\t\t\t\t\t&& (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "+\t\t\t\t\t\t&& previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "+\t\t\t\t\t\tif ((!(options.compactAssignmentMode && token == TokenNameEQUAL))\r", "+\t\t\t\t\t\t\t&& !openAndCloseBrace)\r", "+\t\t\t\t\t\t\tspace();\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\t// Add the next token to the formatted source string.\r", "+\t\t\t\t\toutputCurrentToken(token);\r", "+\t\t\t\t\tif (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1) {\r", "+\t\t\t\t\t\tpendingNewLines = 0;\r", "+\t\t\t\t\t\tcurrentLineBuffer.append(options.lineSeparatorSequence);\r", "+\t\t\t\t\t\tincreaseLineDelta(options.lineSeparatorSequence.length);\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\tpendingSpace = true;\r", "+\t\t\t\t}\r", "+\t\t\t\t// Whitespace tokens do not need to be remembered.\r", "+\t\t\t\tif (token != Scanner.TokenNameWHITESPACE) {\r", "+\t\t\t\t\tpreviousToken = token;\r", "+\t\t\t\t\tif (token != Scanner.TokenNameCOMMENT_BLOCK\r", "+\t\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_LINE\r", "+\t\t\t\t\t\t&& token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "+\t\t\t\t\t\tpreviousCompilableToken = token;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\toutput(copyRemainingSource());\r", "+\t\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "+\t\t} catch (InvalidInputException e) {\r", "+\t\t\toutput(copyRemainingSource());\r", "+\t\t\tflushBuffer(); // dump the last token of the source in the formatted output.\r", "+\t\t}\r", "+\t}\r", "-      }\r", "-     } else {\r", "-      openParenthesis[0]--;\r", "-     }\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNameLBRACE :\r", "-     if ((previousCompilableToken == TokenNameRBRACKET) || (previousCompilableToken == TokenNameEQUAL)) {\r", "-//                  if (previousCompilableToken == TokenNameRBRACKET) {\r", "-      inArrayAssignment = true;\r", "-      inAssignment = false;\r", "-     }\r", "-     if (inArrayAssignment) {\r", "-      indentationLevel += pushBlock();\r", "-     } else {\r", "-      // Add new line and increase indentation level after open brace.\r", "-      pendingNewLines = 1;\r", "-      indentationLevel += pushBlock();\r", "-     }\r", "-     break;\r", "-    case TokenNameRBRACE :\r", "-     if (previousCompilableToken == TokenNameRPAREN) {\r", "-      pendingSpace = false;\r", "-     }\r", "-     if (inArrayAssignment) {\r", "-      inArrayAssignment = false;\r", "-      pendingNewLines = 1;\r", "-      indentationLevel += popInclusiveUntilBlock();\r", "-     } else {\r", "-      pendingNewLines = 1;\r", "-      indentationLevel += popInclusiveUntilBlock();\r", "-      if (previousCompilableToken == TokenNameRPAREN){\r", "-       // fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression\r", "-       currentLineBuffer.append(options.lineSeparatorSequence);\r", "-       increaseLineDelta(options.lineSeparatorSequence.length);                            \r", "-      }\r", "-      if (constructionsCount > 0) {\r", "-       switch (constructions[constructionsCount - 1]) {\r", "-        case TokenNamefor :\r", "-         //indentationLevel += popExclusiveUntilBlock();\r", "-         //break;\r", "-        case TokenNameswitch :\r", "-        case TokenNameif :\r", "-        case TokenNameelse :\r", "-        case TokenNametry :\r", "-        case TokenNamecatch :\r", "-        case TokenNamefinally :\r", "-        case TokenNamewhile :\r", "-        case TokenNamedo :\r", "-         clearNonBlockIndents = true;\r", "-        default :\r", "-         break;\r", "-       }\r", "-      }\r", "-     }\r", "-     break;\r", "-    case TokenNameLBRACKET :\r", "-     openBracketCount++;\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNameRBRACKET :\r", "-     openBracketCount-=(openBracketCount>0)?1:0;\r", "-     // if there is no left bracket to close, the right bracket is ignored.\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNameCOMMA :\r", "-    case TokenNameDOT :\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNameSEMICOLON :\r", "-     // Do not generate line terminators in the definition of\r", "-     // the for statement.\r", "-     // if not in this case, jump a line and reduce indentation after the brace\r", "-     // if the block it closes belongs to a conditional statement (if, while, do...).\r", "-     if (openParenthesisCount <= 1) {\r", "-      pendingNewLines = 1;\r", "-      if (expectingOpenBrace) {\r", "-       clearNonBlockIndents = true;\r", "-       expectingOpenBrace = false;\r", "-      }\r", "-     }\r", "-     inAssignment = false;\r", "-     pendingSpace = false;\r", "-     break;\r", "-    case TokenNamePLUS_PLUS :\r", "-    case TokenNameMINUS_MINUS :\r", "-     // Do not put a space between a post-increment/decrement\r", "-     // and the identifier being modified.\r", "-     if (previousToken == TokenNameIdentifier\r", "-      || previousToken == TokenNameRBRACKET) {\r", "-      pendingSpace = false;\r", "-     }\r", "-     break;\r", "-    case TokenNamePLUS : // previously ADDITION\r", "-    case TokenNameMINUS :\r", "-     // Handle the unary operators plus and minus via a flag\r", "-     if (!isLiteralToken(previousToken)\r", "-      && previousToken != TokenNameIdentifier\r", "-      && previousToken != TokenNameRPAREN\r", "-      && previousToken != TokenNameRBRACKET) {\r", "-      unarySignModifier = 1;\r", "-     }\r", "-     break;\r", "-    case TokenNameCOLON :\r", "-     // In a switch/case statement, add a newline & indent\r", "-     // when a colon is encountered.\r", "-     if (tokenBeforeColonCount > 0) {\r", "-      if (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {\r", "-       pendingNewLines = 1;\r", "-      }\r", "-      tokenBeforeColonCount--;\r", "-     }\r", "-     break;\r", "-    case TokenNameEQUAL :\r", "-     inAssignment = true;\r", "-     break;\r", "-    case Scanner.TokenNameCOMMENT_LINE :\r", "-     pendingNewLines = 1;\r", "-     if (inAssignment) {\r", "-      currentLineIndentationLevel++;\r", "-     }\r", "-     break; // a line is always inserted after a one-line comment\r", "-    case Scanner.TokenNameCOMMENT_JAVADOC :\r", "-    case Scanner.TokenNameCOMMENT_BLOCK :\r", "-     currentCommentOffset = getCurrentCommentOffset();\r", "-     if (openParenthesis[0]==0 && openBracketCount < 1){\r", "-      pendingNewLines = 1;\r", "-      // a new line is inserted only if the comment is not between parenthesis.\r", "-     }\r", "-     break;\r", "-    case Scanner.TokenNameWHITESPACE :\r", "-     // Count the number of line terminators in the whitespace so\r", "-     // line spacing can be preserved near comments.\r", "-     char[] source = scanner.source;\r", "-     newLinesInWhitespace = 0;\r", "-     for (\r", "-      int i = scanner.startPosition, max = scanner.currentPosition; \r", "-      i < max; \r", "-      i++) {\r", "-      if (source[i] == '\\n') {\r", "-       newLinesInWhitespace++;\r", "-      }\r", "-     }\r", "-     increaseLineDelta(scanner.startPosition - scanner.currentPosition);\r", "-     break;\r", "-    default :\r", "-     if ((token == TokenNameIdentifier)\r", "-      || isLiteralToken(token)\r", "-      || token == TokenNamesuper\r", "-      || token == TokenNamethis) {\r", "-      // Do not put a space between a unary operator\r", "-      // (eg: ++, --, +, -) and the identifier being modified.\r", "-      if (previousToken == TokenNamePLUS_PLUS\r", "-       || previousToken == TokenNameMINUS_MINUS\r", "-       || (previousToken == TokenNamePLUS && unarySignModifier > 0)\r", "-       || (previousToken == TokenNameMINUS && unarySignModifier > 0)) {\r", "-       pendingSpace = false;\r", "-      }\r", "-      unarySignModifier = 0;\r", "-     }\r", "-     break;\r", "-   }\r", "-   // Do not output whitespace tokens.\r", "-   if (token != Scanner.TokenNameWHITESPACE) {\r", "-    /* Add pending space to the formatted source string.\r", "-    Do not output a space under the following circumstances:\r", "-    1) this is the first pass\r", "-    2) previous token is an open paren\r", "-    3) previous token is a period\r", "-    4) previous token is the logical compliment (eg: !)\r", "-    5) previous token is the bitwise compliment (eg: ~)\r", "-    6) previous token is the open bracket (eg: [)\r", "-    7) in an assignment statement, if the previous token is an \r", "-    open brace or the current token is a close brace\r", "-    8) previous token is a single line comment\r", "-    */\r", "-    boolean openAndCloseBrace = previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;\r", "-    // to be replaced by a nicer condition.\r", "-   \r", "-    if (pendingSpace\r", "-     && insertSpaceAfter(previousToken)\r", "-     && ! (inAssignment\r", "-      && (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))\r", "-     && previousToken != Scanner.TokenNameCOMMENT_LINE) {\r", "-     if ((! (options.compactAssignmentMode && token == TokenNameEQUAL)) && !openAndCloseBrace)\r", "-      space();\r", "-    }\r", "-    // Add the next token to the formatted source string.\r", "-    outputCurrentToken(token);\r", "-    if (token == Scanner.TokenNameCOMMENT_LINE && openParenthesisCount > 1){\r", "-     pendingNewLines = 0;\r", "-     currentLineBuffer.append(options.lineSeparatorSequence);\r", "-     increaseLineDelta(options.lineSeparatorSequence.length);                    \r", "-    }\r", "-    pendingSpace = true;\r", "-   }\r", "-   // Whitespace tokens do not need to be remembered.\r", "-   if (token != Scanner.TokenNameWHITESPACE) {\r", "-    previousToken = token;\r", "-    if (token != Scanner.TokenNameCOMMENT_BLOCK\r", "-     && token != Scanner.TokenNameCOMMENT_LINE\r", "-     && token != Scanner.TokenNameCOMMENT_JAVADOC) {\r", "-     previousCompilableToken = token;\r", "-    }\r", "-   }\r", "-  }\r", "-  output(copyRemainingSource());\r", "-  flushBuffer(); // dump the last token of the source in the formatted output.\r", "- } catch (InvalidInputException e) {\r", "-  output(copyRemainingSource());\r", "-  flushBuffer(); // dump the last token of the source in the formatted output.\r", "- }\r", "-}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d4acaa08038a50afbe6876a21bd0f1b2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterJavadocTest.java", "commitBeforeChange": "1589fb124e7e874aa6bee240247571801d34f0d8", "commitAfterChange": "db0d0539426c718589b4a2e672b5423396d1d75d", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 18, "signatureBeforeChange": " \tvoid setSourceComment(char[] source)", "signatureAfterChange": " \tvoid setSourceComment(char[] source)", "diff": ["-\t\t\t\t\tif (comment == 2 || source[i] != '\\r') {", "-\t\t\t\t\t\tbuffer.append(source[i]);", "-\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(source[i]);"]}], "num": 37299}