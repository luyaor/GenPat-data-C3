{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "53b8eafe5393e8b99e68dbf68fe915dc", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "14fb38476c06d43b6ad5772c818f3645", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java", "commitBeforeChange": "ba623d582045575b43eee2b86be165ff58225746", "commitAfterChange": "5f25db2c9c02bf799108bff292447ab679c3c3b7", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 7, "signatureBeforeChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod)", "signatureAfterChange": " void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods)", "diff": ["-void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod) {", "+void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {", "-\tif (inheritedMethod != originalInherited) {", "-\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "-\t\tif (toCheck.length > 1) {", "-\t\t\t// must check to see if a bridge method will collide with another current method (see 77861)", "-\t\t\tfor (int i = 0, length = toCheck.length; i < length; i++) {", "-\t\t\t\tif (currentMethod != toCheck[i] && toCheck[i].areParameterErasuresEqual(originalInherited)) {", "-\t\t\t\t\tproblemReporter(toCheck[i]).methodNameClash(toCheck[i], originalInherited); // bridge method will collide", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t}", "-\tthis.type.addSyntheticBridgeMethod(originalInherited, currentMethod);", "+", "+\tif (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod) != null) {", "+\t\tfor (int i = 0, l = otherInheritedMethods.length; i < l; i++) {", "+\t\t\tif (otherInheritedMethods[i] != null) {", "+\t\t\t\tMethodBinding otherOriginal = otherInheritedMethods[i].original();", "+\t\t\t\tif (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))", "+\t\t\t\t\treturn;", "+\t\t\t}", "+\t\t}", "+", "+\t\t// there is an ordering issue with the comparison in checkMethods", "+\t\t// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)", "+\t\t// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method", "+\t\t//\t\tclass X implements Comparable<X> {", "+\t\t//\t\t\tpublic int compareTo(Object o) { return 0; }", "+\t\t//\t\t\tpublic int compareTo(X o) { return 1; }", "+\t\t//\t\t}", "+\t\tMethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);", "+\t\tfor (int i = 0, l = toCheck.length; i < l; i++)", "+\t\t\tif (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))", "+\t\t\t\treturn;", "+\t}", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "505cc05ba61838a82fec674bd56fae38", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java", "commitBeforeChange": "13012d4d345052a766efaa509c91e36e4e9c4bd7", "commitAfterChange": "0e6d159b6b5bd2cefe41360d930f2e2ea9602f91", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType,  \t\tchar[][][] missingTypeNames, TypeAnnotationWalker walker)", "signatureAfterChange": " TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType,  \t\tchar[][][] missingTypeNames, TypeAnnotationWalker walker)", "diff": ["-\t// null annotations on dimensions?", "+\t// annotations on dimensions?", "-\tint depth = binding.depth();", "-\twhile (depth > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) { // we are dropping annotations on enclosing types.", "-\t\twalker = walker.toNextNestedType();", "-\t\tdepth--;", "+\tif (isParameterized) {", "+\t\tif (dimension != 0)", "+\t\t\tthrow new IllegalStateException();", "+\t\treturn binding;", "-\tAnnotationBinding [][] annotations = new AnnotationBinding[depth + 1][];", "-\tannotations[depth] = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);", "-\tif (annotations[depth] != null && annotations[depth] != Binding.NO_ANNOTATIONS)", "-\t\tbinding = createAnnotatedType(binding, annotations);", "+\tif (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {", "+\t\tfinal int depth = binding.depth();", "+\t\tAnnotationBinding [][] annotations = null;", "+\t\tfor (int i = 0; i <= depth; i++) {", "+\t\t\tAnnotationBinding[] annots = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);", "+\t\t\tif (annots != null && annots.length > 0) {", "+\t\t\t\tif (annotations == null)", "+\t\t\t\t\tannotations = new AnnotationBinding[depth + 1][];", "+\t\t\t\tannotations[i] = annots;", "+\t\t\t}", "+\t\t\twalker = walker.toNextNestedType();", "+\t\t}", "+\t\tif (annotations != null)", "+\t\t\tbinding = createAnnotatedType(binding, annotations);", "+\t}"]}], "num": 65681}