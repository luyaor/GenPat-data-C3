{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "bd636438b0375b69f8a53e3a049f92d3", "detectedBy": ["DIFF_HIERARCHICAL", "AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55baf7878c9001f96f6eafe145cbf5c1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "7e5cc03e445550d3cbc10c611218c79332074276", "commitAfterChange": "c57706d05dc3654769cca2053ff9cb20fb0a6664", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tprivate void findFields(\r \t\tchar[] fieldName,\r \t\tFieldBinding[] fields,\r \t\tScope scope,\r \t\tObjectVector fieldsFound,\r \t\tObjectVector localsFound,\r \t\tboolean onlyStaticFields,\r \t\tReferenceBinding receiverType,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope)", "signatureAfterChange": "\r \r private void findFields(\r \tchar[] fieldName,\r \tFieldBinding[] fields,\r \tScope scope,\r \tObjectVector fieldsFound,\r \tboolean onlyStaticFields)", "diff": ["-\r", "-\tprivate void findFields(\r", "-\t\tchar[] fieldName,\r", "-\t\tFieldBinding[] fields,\r", "-\t\tScope scope,\r", "-\t\tObjectVector fieldsFound,\r", "-\t\tObjectVector localsFound,\r", "-\t\tboolean onlyStaticFields,\r", "-\t\tReferenceBinding receiverType,\r", "-\t\tInvocationSite invocationSite,\r", "-\t\tScope invocationScope) {\r", "-\r", "-\t\t// Inherited fields which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint fieldLength = fieldName.length;\r", "-\t\tnext : for (int f = fields.length; --f >= 0;) {\r", "-\t\t\tFieldBinding field = fields[f];\r", "-\t\t\tif (onlyStaticFields && !field.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (fieldLength > field.name.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */\r", "-\t\t\t\t))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !field.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "-\t\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "-\t\t\t\tif (field == otherField)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "-\t\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherField.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tfieldsFound.add(field);\r", "-\r", "-\t\t\tfor (int l = localsFound.size; --l >= 0;) {\r", "-\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) localsFound.elementAt(l);\r", "-\t\t\t\tif (CharOperation.equals(field.name, local.name, true)) {\r", "-\t\t\t\t\tchar[] completion = field.name;\r", "-\t\t\t\t\tSourceTypeBinding enclosing = scope.enclosingSourceType();\r", "-\t\t\t\t\tif (field.isStatic()) {\r", "-\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\tcompletion = CharOperation.concat(name ,completion,'.');\r", "-\t\t\t\t\t} else {;\r", "-\t\t\t\t\t\tif(enclosing == invocationScope.enclosingSourceType()){\r", "-\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\t\tif(!enclosing.isNestedType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(name,completion,'.');\r", "-\t\t\t\t\t\t\t} else if (!enclosing.isAnonymousType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tint index = CharOperation.lastIndexOf('$',name);\r", "-\t\t\t\t\t\t\t\tchar[] shortName = CharOperation.subarray(name,index+1,name.length);\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(shortName,completion,'.');\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\trequestor\r", "-\t\t\t\t\t\t.acceptField(\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tfield.name,\r", "-\t\t\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\trequestor\r", "-\t\t\t\t.acceptField(\r", "-\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t}\r", "-\t}\r", "+\r", "+private void findFields(\r", "+\tchar[] fieldName,\r", "+\tFieldBinding[] fields,\r", "+\tScope scope,\r", "+\tObjectVector fieldsFound,\r", "+\tboolean onlyStaticFields) {\r", "+\r", "+\t// Inherited fields which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint fieldLength = fieldName.length;\r", "+\tnext : for (int f = fields.length; --f >= 0;) {\r", "+\t\tFieldBinding field = fields[f];\r", "+\t\tif (onlyStaticFields && !field.isStatic()) continue next;\r", "+\t\tif (fieldLength > field.name.length) continue next;\r", "+\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)) continue next;\r", "+\r", "+\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "+\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "+\t\t\tif (field == otherField) continue next;\r", "+\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "+\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass)) continue next;\r", "+\t\t\t\tif (otherField.declaringClass.isInterface())\r", "+\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tfieldsFound.add(field);\r", "+\t\trequestor.acceptField(\r", "+\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "+\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "+\t\t\tfield.name,\r", "+\t\t\tfield.type.qualifiedPackageName(),\r", "+\t\t\tfield.type.qualifiedSourceName(),\r", "+\t\t\tfield.name, // may include some qualification to resolve ambiguities\r", "+\t\t\tfield.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cab60b0f33ec3c067d704822abdf6b97", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "46418d248f89a29f49a77d154cdbfa57c408b256", "commitAfterChange": "c85433e27f0fa74bfe8e06c38c1c02c51b5599d7", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tprivate void findFields(\r \t\tchar[] fieldName,\r \t\tFieldBinding[] fields,\r \t\tScope scope,\r \t\tObjectVector fieldsFound,\r \t\tObjectVector localsFound,\r \t\tboolean onlyStaticFields,\r \t\tReferenceBinding receiverType,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope)", "signatureAfterChange": "\r \r private void findFields(\r \tchar[] fieldName,\r \tFieldBinding[] fields,\r \tScope scope,\r \tObjectVector fieldsFound,\r \tboolean onlyStaticFields)", "diff": ["-\r", "-\tprivate void findFields(\r", "-\t\tchar[] fieldName,\r", "-\t\tFieldBinding[] fields,\r", "-\t\tScope scope,\r", "-\t\tObjectVector fieldsFound,\r", "-\t\tObjectVector localsFound,\r", "-\t\tboolean onlyStaticFields,\r", "-\t\tReferenceBinding receiverType,\r", "-\t\tInvocationSite invocationSite,\r", "-\t\tScope invocationScope) {\r", "-\r", "-\t\t// Inherited fields which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint fieldLength = fieldName.length;\r", "-\t\tnext : for (int f = fields.length; --f >= 0;) {\r", "-\t\t\tFieldBinding field = fields[f];\r", "-\t\t\tif (onlyStaticFields && !field.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (fieldLength > field.name.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */\r", "-\t\t\t\t))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !field.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "-\t\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "-\t\t\t\tif (field == otherField)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "-\t\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherField.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tfieldsFound.add(field);\r", "-\r", "-\t\t\tfor (int l = localsFound.size; --l >= 0;) {\r", "-\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) localsFound.elementAt(l);\r", "-\t\t\t\tif (CharOperation.equals(field.name, local.name, true)) {\r", "-\t\t\t\t\tchar[] completion = field.name;\r", "-\t\t\t\t\tSourceTypeBinding enclosing = scope.enclosingSourceType();\r", "-\t\t\t\t\tif (field.isStatic()) {\r", "-\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\tcompletion = CharOperation.concat(name ,completion,'.');\r", "-\t\t\t\t\t} else {;\r", "-\t\t\t\t\t\tif(enclosing == invocationScope.enclosingSourceType()){\r", "-\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\t\tif(!enclosing.isNestedType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(name,completion,'.');\r", "-\t\t\t\t\t\t\t} else if (!enclosing.isAnonymousType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tint index = CharOperation.lastIndexOf('$',name);\r", "-\t\t\t\t\t\t\t\tchar[] shortName = CharOperation.subarray(name,index+1,name.length);\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(shortName,completion,'.');\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\trequestor\r", "-\t\t\t\t\t\t.acceptField(\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tfield.name,\r", "-\t\t\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\trequestor\r", "-\t\t\t\t.acceptField(\r", "-\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t}\r", "-\t}\r", "+\r", "+private void findFields(\r", "+\tchar[] fieldName,\r", "+\tFieldBinding[] fields,\r", "+\tScope scope,\r", "+\tObjectVector fieldsFound,\r", "+\tboolean onlyStaticFields) {\r", "+\r", "+\t// Inherited fields which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint fieldLength = fieldName.length;\r", "+\tnext : for (int f = fields.length; --f >= 0;) {\r", "+\t\tFieldBinding field = fields[f];\r", "+\t\tif (onlyStaticFields && !field.isStatic()) continue next;\r", "+\t\tif (fieldLength > field.name.length) continue next;\r", "+\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)) continue next;\r", "+\r", "+\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "+\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "+\t\t\tif (field == otherField) continue next;\r", "+\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "+\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass)) continue next;\r", "+\t\t\t\tif (otherField.declaringClass.isInterface())\r", "+\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tfieldsFound.add(field);\r", "+\t\trequestor.acceptField(\r", "+\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "+\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "+\t\t\tfield.name,\r", "+\t\t\tfield.type.qualifiedPackageName(),\r", "+\t\t\tfield.type.qualifiedSourceName(),\r", "+\t\t\tfield.name, // may include some qualification to resolve ambiguities\r", "+\t\t\tfield.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e71e3ea7656d0b5d427ddb65ef265677", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a56fdb9e1b8e5c1a02fedba085001b6a52d742b7", "commitAfterChange": "7ff0ccf2d889c8ccb2eec99187eac9efe4dc4e22", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tprivate void findFields(\r \t\tchar[] fieldName,\r \t\tFieldBinding[] fields,\r \t\tScope scope,\r \t\tObjectVector fieldsFound,\r \t\tObjectVector localsFound,\r \t\tboolean onlyStaticFields,\r \t\tReferenceBinding receiverType,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope)", "signatureAfterChange": "\r \r private void findFields(\r \tchar[] fieldName,\r \tFieldBinding[] fields,\r \tScope scope,\r \tObjectVector fieldsFound,\r \tboolean onlyStaticFields)", "diff": ["-\r", "-\tprivate void findFields(\r", "-\t\tchar[] fieldName,\r", "-\t\tFieldBinding[] fields,\r", "-\t\tScope scope,\r", "-\t\tObjectVector fieldsFound,\r", "-\t\tObjectVector localsFound,\r", "-\t\tboolean onlyStaticFields,\r", "-\t\tReferenceBinding receiverType,\r", "-\t\tInvocationSite invocationSite,\r", "-\t\tScope invocationScope) {\r", "-\r", "-\t\t// Inherited fields which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint fieldLength = fieldName.length;\r", "-\t\tnext : for (int f = fields.length; --f >= 0;) {\r", "-\t\t\tFieldBinding field = fields[f];\r", "-\t\t\tif (onlyStaticFields && !field.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (fieldLength > field.name.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */\r", "-\t\t\t\t))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !field.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "-\t\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "-\t\t\t\tif (field == otherField)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "-\t\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherField.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tfieldsFound.add(field);\r", "-\r", "-\t\t\tfor (int l = localsFound.size; --l >= 0;) {\r", "-\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) localsFound.elementAt(l);\r", "-\t\t\t\tif (CharOperation.equals(field.name, local.name, true)) {\r", "-\t\t\t\t\tchar[] completion = field.name;\r", "-\t\t\t\t\tSourceTypeBinding enclosing = scope.enclosingSourceType();\r", "-\t\t\t\t\tif (field.isStatic()) {\r", "-\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\tcompletion = CharOperation.concat(name ,completion,'.');\r", "-\t\t\t\t\t} else {;\r", "-\t\t\t\t\t\tif(enclosing == invocationScope.enclosingSourceType()){\r", "-\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\t\tif(!enclosing.isNestedType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(name,completion,'.');\r", "-\t\t\t\t\t\t\t} else if (!enclosing.isAnonymousType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tint index = CharOperation.lastIndexOf('$',name);\r", "-\t\t\t\t\t\t\t\tchar[] shortName = CharOperation.subarray(name,index+1,name.length);\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(shortName,completion,'.');\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\trequestor\r", "-\t\t\t\t\t\t.acceptField(\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tfield.name,\r", "-\t\t\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\trequestor\r", "-\t\t\t\t.acceptField(\r", "-\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t}\r", "-\t}\r", "+\r", "+private void findFields(\r", "+\tchar[] fieldName,\r", "+\tFieldBinding[] fields,\r", "+\tScope scope,\r", "+\tObjectVector fieldsFound,\r", "+\tboolean onlyStaticFields) {\r", "+\r", "+\t// Inherited fields which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint fieldLength = fieldName.length;\r", "+\tnext : for (int f = fields.length; --f >= 0;) {\r", "+\t\tFieldBinding field = fields[f];\r", "+\t\tif (onlyStaticFields && !field.isStatic()) continue next;\r", "+\t\tif (fieldLength > field.name.length) continue next;\r", "+\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)) continue next;\r", "+\r", "+\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "+\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "+\t\t\tif (field == otherField) continue next;\r", "+\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "+\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass)) continue next;\r", "+\t\t\t\tif (otherField.declaringClass.isInterface())\r", "+\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tfieldsFound.add(field);\r", "+\t\trequestor.acceptField(\r", "+\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "+\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "+\t\t\tfield.name,\r", "+\t\t\tfield.type.qualifiedPackageName(),\r", "+\t\t\tfield.type.qualifiedSourceName(),\r", "+\t\t\tfield.name, // may include some qualification to resolve ambiguities\r", "+\t\t\tfield.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fab030894356f9c4d81a4cbcf477eef9", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "a1b8b888d8c8c040023fcd2856f96f5ad6c69b3e", "commitAfterChange": "ba238895da0e9d116073a555bfb1c09f876bedf2", "methodNumberBeforeChange": 11, "methodNumberAfterChange": 11, "signatureBeforeChange": "\r \r \tprivate void findFields(\r \t\tchar[] fieldName,\r \t\tFieldBinding[] fields,\r \t\tScope scope,\r \t\tObjectVector fieldsFound,\r \t\tObjectVector localsFound,\r \t\tboolean onlyStaticFields,\r \t\tReferenceBinding receiverType,\r \t\tInvocationSite invocationSite,\r \t\tScope invocationScope)", "signatureAfterChange": "\r \r private void findFields(\r \tchar[] fieldName,\r \tFieldBinding[] fields,\r \tScope scope,\r \tObjectVector fieldsFound,\r \tboolean onlyStaticFields)", "diff": ["-\r", "-\tprivate void findFields(\r", "-\t\tchar[] fieldName,\r", "-\t\tFieldBinding[] fields,\r", "-\t\tScope scope,\r", "-\t\tObjectVector fieldsFound,\r", "-\t\tObjectVector localsFound,\r", "-\t\tboolean onlyStaticFields,\r", "-\t\tReferenceBinding receiverType,\r", "-\t\tInvocationSite invocationSite,\r", "-\t\tScope invocationScope) {\r", "-\r", "-\t\t// Inherited fields which are hidden by subclasses are filtered out\r", "-\t\t// No visibility checks can be performed without the scope & invocationSite\r", "-\r", "-\t\tint fieldLength = fieldName.length;\r", "-\t\tnext : for (int f = fields.length; --f >= 0;) {\r", "-\t\t\tFieldBinding field = fields[f];\r", "-\t\t\tif (onlyStaticFields && !field.isStatic())\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (fieldLength > field.name.length)\r", "-\t\t\t\tcontinue next;\r", "-\t\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */\r", "-\t\t\t\t))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tif (options.checkVisibilitySensitive()\r", "-\t\t\t\t&& !field.canBeSeenBy(receiverType, invocationSite, scope))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "-\t\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "-\t\t\t\tif (field == otherField)\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "-\t\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass))\r", "-\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t\tif (otherField.declaringClass.isInterface())\r", "-\t\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true))\r", "-\t\t\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\tfieldsFound.add(field);\r", "-\r", "-\t\t\tfor (int l = localsFound.size; --l >= 0;) {\r", "-\t\t\t\tLocalVariableBinding local = (LocalVariableBinding) localsFound.elementAt(l);\r", "-\t\t\t\tif (CharOperation.equals(field.name, local.name, true)) {\r", "-\t\t\t\t\tchar[] completion = field.name;\r", "-\t\t\t\t\tSourceTypeBinding enclosing = scope.enclosingSourceType();\r", "-\t\t\t\t\tif (field.isStatic()) {\r", "-\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\tcompletion = CharOperation.concat(name ,completion,'.');\r", "-\t\t\t\t\t} else {;\r", "-\t\t\t\t\t\tif(enclosing == invocationScope.enclosingSourceType()){\r", "-\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\tchar[] name = enclosing.compoundName[enclosing.compoundName.length-1];\r", "-\t\t\t\t\t\t\tif(!enclosing.isNestedType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(name,completion,'.');\r", "-\t\t\t\t\t\t\t} else if (!enclosing.isAnonymousType()){\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(THIS,completion,'.');\r", "-\t\t\t\t\t\t\t\tint index = CharOperation.lastIndexOf('$',name);\r", "-\t\t\t\t\t\t\t\tchar[] shortName = CharOperation.subarray(name,index+1,name.length);\r", "-\t\t\t\t\t\t\t\tcompletion = CharOperation.concat(shortName,completion,'.');\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\r", "-\t\t\t\t\trequestor\r", "-\t\t\t\t\t\t.acceptField(\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tfield.name,\r", "-\t\t\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\t\t\tcompletion,\r", "-\t\t\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t\t\t\tcontinue next;\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\r", "-\t\t\trequestor\r", "-\t\t\t\t.acceptField(\r", "-\t\t\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t\t\tfield.type.qualifiedPackageName(),\r", "-\t\t\t\t\tfield.type.qualifiedSourceName(),\r", "-\t\t\t\t\tfield.name,\r", "-\t\t\t// may include some qualification to resolve ambiguities\r", "-\t\t\tfield.modifiers, startPosition, endPosition);\r", "-\t\t}\r", "-\t}\r", "+\r", "+private void findFields(\r", "+\tchar[] fieldName,\r", "+\tFieldBinding[] fields,\r", "+\tScope scope,\r", "+\tObjectVector fieldsFound,\r", "+\tboolean onlyStaticFields) {\r", "+\r", "+\t// Inherited fields which are hidden by subclasses are filtered out\r", "+\t// No visibility checks can be performed without the scope & invocationSite\r", "+\r", "+\tint fieldLength = fieldName.length;\r", "+\tnext : for (int f = fields.length; --f >= 0;) {\r", "+\t\tFieldBinding field = fields[f];\r", "+\t\tif (onlyStaticFields && !field.isStatic()) continue next;\r", "+\t\tif (fieldLength > field.name.length) continue next;\r", "+\t\tif (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)) continue next;\r", "+\r", "+\t\tfor (int i = fieldsFound.size; --i >= 0;) {\r", "+\t\t\tFieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);\r", "+\t\t\tif (field == otherField) continue next;\r", "+\t\t\tif (CharOperation.equals(field.name, otherField.name, true)) {\r", "+\t\t\t\tif (field.declaringClass.isSuperclassOf(otherField.declaringClass)) continue next;\r", "+\t\t\t\tif (otherField.declaringClass.isInterface())\r", "+\t\t\t\t\tif (field.declaringClass.implementsInterface(otherField.declaringClass, true)) continue next;\r", "+\t\t\t}\r", "+\t\t}\r", "+\r", "+\t\tfieldsFound.add(field);\r", "+\t\trequestor.acceptField(\r", "+\t\t\tfield.declaringClass.qualifiedPackageName(),\r", "+\t\t\tfield.declaringClass.qualifiedSourceName(),\r", "+\t\t\tfield.name,\r", "+\t\t\tfield.type.qualifiedPackageName(),\r", "+\t\t\tfield.type.qualifiedSourceName(),\r", "+\t\t\tfield.name, // may include some qualification to resolve ambiguities\r", "+\t\t\tfield.modifiers,\r", "+\t\t\tstartPosition,\r", "+\t\t\tendPosition);\r", "+\t}\r", "+}\r"]}], "num": 21924}