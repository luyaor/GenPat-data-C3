{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "21170356b484b60ff0e88712f4740fe4", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1d45b69fa7d4a2d9491e7f0cc336c4a0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java", "commitBeforeChange": "600cc6e957b3608b8d3c26027936fe87489e52d9", "commitAfterChange": "23ffb43b2ebb4c3a8ec95cae07baf3650cc30157", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic static final Constant getConstantFor( \t\tFieldBinding binding, \t\tboolean implicitReceiver, \t\tReference reference, \t\tScope referenceScope, \t\tint indexInQualification)", "signatureAfterChange": "  \tpublic static final Constant getConstantFor( \t\tFieldBinding binding, \t\tReference reference, \t\tboolean isImplicit, \t\tScope referenceScope)", "diff": ["-\t\tboolean implicitReceiver,", "-\t\tScope referenceScope,", "-\t\tint indexInQualification) {", "+\t\tboolean isImplicit,", "+\t\tScope referenceScope) {", "-\t\t\tif (indexInQualification == 0) {", "-\t\t\t\treturn binding.constant;", "-\t\t\t}", "-\t\t\t//see previous comment for the (sould-always-be) valid cast", "-\t\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;", "-\t\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {", "+\t\t\tif (isImplicit || (reference instanceof QualifiedNameReference", "+\t\t\t\t\t&& binding == ((QualifiedNameReference)reference).binding)) {", "-\t\t//what scope to use (depend on the staticness of the field binding)", "-\t\tMethodScope fieldScope =", "-\t\t\tbinding.isStatic()", "+\t\tfieldDecl.resolve(binding.isStatic() //side effect on binding ", "-\t\t\t\t: typeDecl.initializerScope;", "+\t\t\t\t: typeDecl.initializerScope); ", "-\t\tif (implicitReceiver) { //Determine if the ref is legal in the current class of the field", "-\t\t\t//i.e. not a forward reference .... ", "-\t\t\tif (fieldScope.fieldDeclarationIndex == MethodScope.NotInFieldDecl) {", "-\t\t\t\t// no field is currently being analysed in typeDecl", "-\t\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ", "-\t\t\t\treturn binding.constant;", "-\t\t\t}", "-\t\t\t//We are re-entering the same class fields analysing", "-\t\t\tif ((reference != null)", "-\t\t\t\t&& (binding.declaringClass == referenceScope.enclosingSourceType()) // only complain for access inside same type", "-\t\t\t\t&& (binding.id > fieldScope.fieldDeclarationIndex)) {", "-\t\t\t\t//forward reference. The declaration remains unresolved.", "-\t\t\t\treferenceScope.problemReporter().forwardReference(reference, indexInQualification, typeBinding);", "-\t\t\t\treturn NotAConstant;", "-\t\t\t}", "-\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ", "+\t\tif (isImplicit || (reference instanceof QualifiedNameReference", "+\t\t\t\t&& binding == ((QualifiedNameReference)reference).binding)) {", "-\t\t//the field reference is explicity. It has to be a \"simple\" like field reference to get the", "-\t\t//constant propagation. For example in Packahe.Type.field1.field2 , field1 may have its", "-\t\t//constant having a propagation where field2 is always not propagating its", "-\t\tif (indexInQualification == 0) {", "-\t\t\tfieldDecl.resolve(fieldScope); //side effect on binding ... ", "-\t\t\treturn binding.constant;", "-\t\t}", "-\t\t// Side-effect on the field binding may not be propagated out for the qualified reference", "-\t\t// unless it occurs in first place of the name sequence", "-\t\tfieldDecl.resolve(fieldScope); //side effect on binding ... ", "-\t\t//see previous comment for the cast that should always be valid", "-\t\tQualifiedNameReference qualifiedReference = (QualifiedNameReference) reference;", "-\t\tif (indexInQualification == (qualifiedReference.indexOfFirstFieldBinding - 1)) {", "-\t\t\treturn binding.constant;", "-\t\t} else {", "-\t\t\treturn NotAConstant;", "-\t\t}", "+\t\treturn NotAConstant;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bcecf0e4eafdd1af6d540ba72e979e91", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java", "commitBeforeChange": "de8634c6596eba9d498f21b3f06a4d952c468878", "commitAfterChange": "ed3ff9a36eb2db48659e462eacb164d15ad7a872", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "signatureAfterChange": " \tprotected NameEnvironmentAnswer find(String typeName, String packageName)", "diff": ["-\t\tIType type =", "+\t\tNameLookup.Answer answer =", "-\t\t\t\tfalse,", "-\t\t\t\tNameLookup.ACCEPT_ALL);", "-\t\tif (type != null) {", "-\t\t\tboolean isBinary = type instanceof BinaryType;", "-\t\t\t", "-\t\t\t// determine associated access restriction", "-\t\t\tAccessRestriction accessRestriction = null;", "-\t\t\t", "-\t\t\tif (this.checkAccessRestrictions && (isBinary || !type.getJavaProject().equals(this.project))) {", "-\t\t\t\tPackageFragmentRoot root = (PackageFragmentRoot)type.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);", "-\t\t\t\tClasspathEntry entry = (ClasspathEntry) this.nameLookup.rootToResolvedEntries.get(root);", "-\t\t\t\tif (entry != null) { // reverse map always contains resolved CP entry", "-\t\t\t\t\tAccessRuleSet accessRuleSet = entry.getAccessRuleSet();", "-\t\t\t\t\tif (accessRuleSet != null) {", "-\t\t\t\t\t\t// TODO (philippe) improve char[] <-> String conversions to avoid performing them on the fly", "-\t\t\t\t\t\tchar[][] packageChars = CharOperation.splitOn('.', packageName.toCharArray());", "-\t\t\t\t\t\tchar[] classFileChars = type.getElementName().toCharArray();", "-\t\t\t\t\t\taccessRestriction = accessRuleSet.getViolatedRestriction(CharOperation.concatWith(packageChars, classFileChars, '/'));", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t", "+\t\t\t\tfalse/*exact match*/,", "+\t\t\t\tNameLookup.ACCEPT_ALL,", "+\t\t\t\tthis.checkAccessRestrictions);", "+\t\tif (answer != null) {", "-\t\t\tif (isBinary) { // BinaryType", "+\t\t\tif (answer.type instanceof BinaryType) { // BinaryType", "-\t\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getElementInfo(), accessRestriction);", "+\t\t\t\t\treturn new NameEnvironmentAnswer((IBinaryType) ((BinaryType) answer.type).getElementInfo(), answer.restriction);", "-\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getElementInfo();", "+\t\t\t\t\tSourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType) answer.type).getElementInfo();", "-\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes, accessRestriction);", "+\t\t\t\t\treturn new NameEnvironmentAnswer(sourceTypes, answer.restriction);"]}], "num": 43091}