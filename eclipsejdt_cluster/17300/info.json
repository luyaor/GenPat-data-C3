{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1fba07ec978924713b148a7370f46a73", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "019d31523ee037d495ea178083d13253", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 8, "methodNumberAfterChange": 8, "signatureBeforeChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\tif (hasError) return this.resolvedType = receiverType;", "+\t\tif (hasError) {", "+\t\t\tif (receiverType instanceof ReferenceBinding) {", "+\t\t\t\t// record a best guess, for clients who need hint about possible contructor match", "+\t\t\t\tint length = this.arguments  == null ? 0 : this.arguments.length;", "+\t\t\t\tTypeBinding[] pseudoArgs = new TypeBinding[length];", "+\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t}", "+\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) receiverType, TypeConstants.INIT, pseudoArgs, this);", "+\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t}", "+\t\t\treturn this.resolvedType = receiverType;", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1aceed17fba00155f9a76847eb4d0601", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java", "commitBeforeChange": "e74abb558d667117356c6f54df2ab5f4c2e65105", "commitAfterChange": "c616b779ea1b8ac58e576f87acddf9f0396396f5", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding) actualReceiverType, selector, pseudoArgs, this);", "+\t\t\t\tthis.binding = ", "+\t\t\t\t\treceiver.isImplicitThis()", "+\t\t\t\t\t\t? scope.getImplicitMethod(selector, pseudoArgs, this)", "+\t\t\t\t\t\t: scope.findMethod((ReferenceBinding) actualReceiverType, selector, pseudoArgs, this);", "+\t\t\t\tif (binding != null && !binding.isValidBinding()) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)binding).closestMatch;", "+\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\tif ((closestMatch.isPrivate() || closestMatch.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatch)) {", "+\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\tclosestMatch.original().modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2598c589a84334ab11b51474cd695cf0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": "  public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": "  public TypeBinding resolveType(BlockScope scope)", "diff": ["-\t\t\t\tfor (int i = length; --i >= 0;)", "-\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? this.resolvedType : argumentTypes[i]; // replace args with errors with receiver", "+\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t}", "+\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9175ea3eed113e435b38611859ba7c58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java", "commitBeforeChange": "8cf1dcdf2235b54b4116fb6f086a0d218e6b26f7", "commitAfterChange": "45fa88428d5d04389be0956547a1793c4e66bac3", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \t \tpublic void resolve(BlockScope scope)", "signatureAfterChange": " \t \tpublic void resolve(BlockScope scope)", "diff": ["-\t\t\t\t\tfor (int i = length; --i >= 0;)", "-\t\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? receiverType : argumentTypes[i]; // replace args with errors with receiver", "+\t\t\t\t\tfor (int i = length; --i >= 0;) {", "+\t\t\t\t\t\tpseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.binding != null && !this.binding.isValidBinding()) {", "+\t\t\t\t\t\tMethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;", "+\t\t\t\t\t\t// record the closest match, for clients who may still need hint about possible method match", "+\t\t\t\t\t\tif (closestMatch != null) {", "+\t\t\t\t\t\t\tif (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method", "+\t\t\t\t\t\t\t\t// shouldn't return generic method outside its context, rather convert it to raw method (175409)", "+\t\t\t\t\t\t\t\tclosestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\tthis.binding = closestMatch;", "+\t\t\t\t\t\t\tMethodBinding closestMatchOriginal = closestMatch.original();", "+\t\t\t\t\t\t\tif ((closestMatchOriginal.isPrivate() || closestMatchOriginal.declaringClass.isLocalType()) && !scope.isDefinedInMethod(closestMatchOriginal)) {", "+\t\t\t\t\t\t\t\t// ignore cases where method is used from within inside itself (e.g. direct recursions)", "+\t\t\t\t\t\t\t\tclosestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}"]}], "num": 17300}