{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "8947cde5935ca5ffc40aa7cbf790a237", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1db3f20228dd6a4af5aa862e2b43adbc", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java", "commitBeforeChange": "1bd28947ec61a68bcbaa48e5f62a38f1082dad74", "commitAfterChange": "158f15ed7305b84f608a44b2b3e60c3a50fa4c1b", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " \tpublic void boundCheck(Scope scope, TypeReference[] argumentReferences)", "signatureAfterChange": " \tpublic void boundCheck(Scope scope, TypeReference[] argumentReferences)", "diff": ["-\t\t\t\t    if (typeVariables[i].boundCheck(this, this.arguments[i], scope)  != TypeConstants.OK) {", "-\t\t\t\t    \thasErrors = true;", "-\t\t\t\t    \tif ((this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {", "-\t\t\t\t    \t\t// do not report secondary error, if type reference already got complained against", "-\t\t\t\t\t\t\tscope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);", "-\t\t\t\t    \t}", "-\t\t\t\t    }", "+\t\t\t\t    BoundCheckStatus checkStatus = typeVariables[i].boundCheck(this, this.arguments[i], scope, argumentReferences[i]);", "+\t\t\t\t    hasErrors |= checkStatus != BoundCheckStatus.OK;", "+\t\t\t    \tif (!checkStatus.isOKbyJLS() && (this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t    \t\t// do not report secondary error, if type reference already got complained against", "+\t\t\t\t\t\tscope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);", "+\t\t\t    \t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ff8b845d390560a9d4f3996c0181efa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e657b912c1ef94d48e9749f2cbf91c83fff8728f", "commitAfterChange": "a34df737b5102c35af6a4e4a81e1b17f0f972c06", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["+\t\t// fall thru if its a constructor with a synthetic argument... find it the slower way", "-\t\tif (reader == null) return null;", "-", "-\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\tif (methods != null) {", "-\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "-\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "-\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "-\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "-\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "-\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "-\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "-\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "-\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\tif (reader != null) {", "+\t\t\tIBinaryMethod[] methods = reader.getMethods();", "+\t\t\tif (methods != null) {", "+\t\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "+\t\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "+\t\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "+\t\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "+\t\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "+\t\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "+\t\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "+\t\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "+\t\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "+\t\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\treturn null;", "-\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tIMethod handle = type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tif (type.isBinary() && !handle.exists()) return null; // element doesn't exist in the .class file", "+\treturn handle;"]}], "num": 12692}