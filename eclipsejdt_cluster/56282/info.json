{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "87c6c4aa95e433be498a2098020d6602", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b221c287ed0546f5f343e6889cb38344", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java", "commitBeforeChange": "c559b74f9272fa02909675d464836a672389a516", "commitAfterChange": "2bd8634076dae415ed16f812be7f211adc594166", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tprotected void generateClasspathChangeDeltas()", "signatureAfterChange": " \tprotected void generateClasspathChangeDeltas()", "diff": ["-\t\t\t\t\tthis.needCycleCheck |= (oldResolvedPath[i].isExported() != newResolvedPath[index].isExported());", "+\t\t\t\t\t// Need to updated dependents in case old and/or new entries are exported and have an access restriction", "+\t\t\t\t\tClasspathEntry oldEntry = (ClasspathEntry) oldResolvedPath[i];", "+\t\t\t\t\tClasspathEntry newEntry = (ClasspathEntry) newResolvedPath[index];", "+\t\t\t\t\tneedToUpdateDependents |= (oldEntry.isExported && oldEntry.getImportRestriction() != null) || ", "+\t\t\t\t\t\t(newEntry.isExported && newEntry.getImportRestriction() != null);", "+\t\t\t\t\tthis.needCycleCheck |= (oldEntry.isExported() != newEntry.isExported());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff8532231b4c258abee3f831c368c33f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "7ba9ff29fe6b05ec0a2f58eaa1f5d3e68bb11101", "commitAfterChange": "427a01e331e57852efc472cca3a8360bd121fda9", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": "  private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames)", "signatureAfterChange": "  private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames, \t\t\t\t\t\t\t\t\t\t\t\t\tTypeAnnotationWalker walker, boolean isClassTypeParameter)", "diff": ["-private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames) {", "+private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames,", "+\t\t\t\t\t\t\t\t\t\t\t\t\tTypeAnnotationWalker walker, boolean isClassTypeParameter)", "+{", "-\t\t\t\t\t\tvariables.add(new TypeVariableBinding(variableName, this, rank++, this.environment));", "+\t\t\t\t\t\tTypeVariableBinding typeVariable = new TypeVariableBinding(variableName, this, rank, this.environment);", "+\t\t\t\t\t\tIBinaryAnnotation[] annotations = walker.toTypeParameter(isClassTypeParameter, rank++).getAnnotationsAtCursor();", "+\t\t\t\t\t\ttypeVariable.tagBits  |= this.environment.typeAnnotationsToTagBits(annotations);", "+\t\t\t\t\t\tvariables.add(typeVariable);", "-\t\tinitializeTypeVariable(result[i], result, wrapper, missingTypeNames);", "+\t\tinitializeTypeVariable(result[i], result, wrapper, missingTypeNames, walker.toTypeBarameterBounds(isClassTypeParameter, i));"]}], "num": 56282}