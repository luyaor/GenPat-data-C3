{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c442897cacafc6f19651c71567b679fe", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "3280d0e161debd5d461d1f49bd97db21", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java", "commitBeforeChange": "def990b8509828ed437909a92c80eeb89428931a", "commitAfterChange": "59f8b1366dc6dc4f5af017fd8d5242b930c185da", "methodNumberBeforeChange": 38, "methodNumberAfterChange": 40, "signatureBeforeChange": "  \tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode)", "signatureAfterChange": "  \tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum)", "diff": ["-\tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {", "+\tprivate void disassembleTypeMembers(IClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum) {", "-\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "-\t\t\tdisassemble(fields[i], buffer, lineSeparator, tabNumber, mode);", "-\t\t}", "-\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "-\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "-\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "-\t\t\tdisassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);", "+\t\tif (isEnum && checkMode(mode, WORKING_COPY)) {", "+\t\t\tint index = 0;", "+\t\t\tfinal int fieldsLength = fields.length;", "+\t\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "+\t\t\tchar[][] constructorArguments = getConstructorArgumentsForEnum(methods);", "+\t\t\tenumConstantLoop: for (; index < fieldsLength; index++) {", "+\t\t\t\tfinal IFieldInfo fieldInfo = fields[index];", "+\t\t\t\tfinal int accessFlags = fieldInfo.getAccessFlags();", "+\t\t\t\tif ((accessFlags & IModifierConstants.ACC_ENUM) != 0) {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassembleEnumConstants(fields[index], buffer, lineSeparator, tabNumber, constructorArguments);", "+\t\t\t\t} else {", "+\t\t\t\t\tbreak enumConstantLoop;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tbuffer.append(';');", "+\t\t\tboolean foundSyntheticField = false;", "+\t\t\tfieldLoop: for (; index < fieldsLength; index++) {", "+\t\t\t\tif (!foundSyntheticField && CharOperation.equals(TypeConstants.SYNTHETIC_ENUM_VALUES, fields[index].getName())) {", "+\t\t\t\t\tfoundSyntheticField = true;", "+\t\t\t\t\tcontinue fieldLoop;", "+\t\t\t\t}", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(fields[index], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}", "+\t\t\tmethodLoop: for (int i = 0, max = methods.length; i < max; i++) {", "+\t\t\t\tfinal IMethodInfo methodInfo = methods[i];", "+\t\t\t\tif (CharOperation.equals(methodInfo.getName(), TypeConstants.VALUES)) {", "+\t\t\t\t\tfinal char[] descriptor = methodInfo.getDescriptor();", "+\t\t\t\t\tCharOperation.replace(descriptor, '/', '.');", "+\t\t\t\t\tif (Signature.getParameterCount(descriptor) == 0) {", "+\t\t\t\t\t\tif (CharOperation.equals(returnClassName(Signature.getReturnType(descriptor), '.', mode),", "+\t\t\t\t\t\t\t\tCharOperation.concat(new char[] {'[', 'L'}, className, new char[] {';'}))) {", "+\t\t\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else if (CharOperation.equals(methodInfo.getName(), TypeConstants.VALUEOF)) {", "+\t\t\t\t\tfinal char[] descriptor = methodInfo.getDescriptor();", "+\t\t\t\t\tCharOperation.replace(descriptor, '/', '.');", "+\t\t\t\t\tfinal char[][] parameterTypes = Signature.getParameterTypes(descriptor);", "+\t\t\t\t\tif (parameterTypes.length == 1", "+\t\t\t\t\t\t\t&& CharOperation.equals(parameterTypes[0], \"Ljava.lang.String;\".toCharArray())) { //$NON-NLS-1$", "+\t\t\t\t\t\tif (CharOperation.equals(returnClassName(Signature.getReturnType(descriptor), '.', mode),", "+\t\t\t\t\t\t\t\tCharOperation.concat('L', className, ';'))) {", "+\t\t\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else if (methodInfo.isClinit()) {", "+\t\t\t\t\tcontinue methodLoop;", "+\t\t\t\t} else if (methodInfo.isConstructor()) {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassembleEnumConstructor(classFileReader, className, methodInfo, buffer, lineSeparator, tabNumber, mode);", "+\t\t\t\t} else {", "+\t\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\t\tdisassemble(classFileReader, className, methodInfo, buffer, lineSeparator, tabNumber, mode);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tfor (int i = 0, max = fields.length; i < max; i++) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(fields[i], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}", "+\t\t\tIMethodInfo[] methods = classFileReader.getMethodInfos();", "+\t\t\tfor (int i = 0, max = methods.length; i < max; i++) {", "+\t\t\t\twriteNewLine(buffer, lineSeparator, tabNumber);", "+\t\t\t\tdisassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42d7b2fbfe8f961b558628e0bf2320b0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java", "commitBeforeChange": "354ebb443c1299f35a4e7d9feb7df720666960e5", "commitAfterChange": "f5d7f3f14e69a955635d98e0e88aeb491988cae5", "methodNumberBeforeChange": 17, "methodNumberAfterChange": 64, "signatureBeforeChange": "  \tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding)", "signatureAfterChange": "  \tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType)", "diff": ["-", "-\tpublic boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding) {", "-\t\tSolution solution = this.solutionsPerTargetType.get(targetType);", "-\t\tif (solution != null)", "-\t\t\treturn false; // no update", "-\t\tthis.solutionsPerTargetType.put(targetType, new Solution(updatedBinding, null));", "-\t\tthis.stepCompleted = Math.max(this.stepCompleted, TYPE_INFERRED);", "-\t\treturn true;", "+", "+\tpublic void forwardResults(BoundSet result, Invocation invocation, ParameterizedMethodBinding pmb, TypeBinding targetType) {", "+\t\tif (targetType != null)", "+\t\t\tinvocation.registerResult(targetType, pmb);", "+\t\tExpression[] arguments = invocation.arguments();", "+\t\tfor (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {", "+\t\t\tExpression [] expressions = arguments[i].getPolyExpressions();", "+\t\t\tfor (int j = 0, jLength = expressions.length; j < jLength; j++) {", "+\t\t\t\tExpression expression = expressions[j];", "+\t\t\t\tif (!(expression instanceof Invocation))", "+\t\t\t\t\tcontinue;", "+\t\t\t\tInvocation polyInvocation = (Invocation) expression;", "+\t\t\t\tMethodBinding binding = polyInvocation.binding();", "+\t\t\t\tif (binding == null || !binding.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tParameterizedMethodBinding methodSubstitute = null;", "+\t\t\t\tif (binding instanceof ParameterizedGenericMethodBinding) {", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(shallowOriginal.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tmethodSubstitute = this.environment.createParameterizedGenericMethod(shallowOriginal, solutions);", "+\t\t\t\t} else {", "+\t\t\t\t\tif (!binding.isConstructor() || !(binding instanceof ParameterizedMethodBinding))", "+\t\t\t\t\t\tcontinue; // throw ISE ?", "+\t\t\t\t\tMethodBinding shallowOriginal = binding.shallowOriginal();", "+\t\t\t\t\tReferenceBinding genericType = shallowOriginal.declaringClass;", "+\t\t\t\t\tTypeBinding[] solutions = getSolutions(genericType.typeVariables(), polyInvocation, result);", "+\t\t\t\t\tif (solutions == null)  // in CEF.reduce, we lift inner poly expressions into outer context only if their target type has inference variables. ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tParameterizedTypeBinding parameterizedType = this.environment.createParameterizedType(genericType, solutions, binding.declaringClass.enclosingType());", "+\t\t\t\t\tfor (MethodBinding parameterizedMethod : parameterizedType.methods()) {", "+\t\t\t\t\t\tif (parameterizedMethod.original() == shallowOriginal) {", "+\t\t\t\t\t\t\tmethodSubstitute = (ParameterizedMethodBinding) parameterizedMethod;", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (methodSubstitute == null || !methodSubstitute.isValidBinding())", "+\t\t\t\t\tcontinue;", "+\t\t\t\tboolean variableArity = pmb.isVarargs();", "+\t\t\t\tfinal TypeBinding[] parameters = pmb.parameters;", "+\t\t\t\tif (variableArity && parameters.length == arguments.length && i == length - 1) {", "+\t\t\t\t\tTypeBinding returnType = methodSubstitute.returnType.capture(this.scope, expression.sourceStart, expression.sourceEnd);", "+\t\t\t\t\tif (returnType.isCompatibleWith(parameters[parameters.length - 1], this.scope)) {", "+\t\t\t\t\t\tvariableArity = false;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);", "+\t\t\t\tforwardResults(result, polyInvocation, methodSubstitute, parameterType);\t\t", "+\t\t\t}", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "520847a4ec511409f056ab7aa5a2c272", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 32, "signatureBeforeChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "signatureAfterChange": " public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration)", "diff": ["-\t\t\targumentTypes[i] = returnTypeName(arguments[i].type);", "+\t\t\targumentTypes[i] = CharOperation.concatWith(arguments[i].type.getParameterizedTypeName(), '.');", "-\t\t\t\tCharOperation.concatWith(thrownExceptions[i].getTypeName(), '.'); ", "+\t\t\t\tCharOperation.concatWith(thrownExceptions[i].getParameterizedTypeName(), '.'); ", "+\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "+\t\t\tchar[][] typeParameterNames = null;", "+\t\t\tchar[][][] typeParameterBounds = null;", "+\t\t\tif (typeParameters != null) {", "+\t\t\t\tint typeParametersLength = typeParameters.length;", "+\t\t\t\ttypeParameterNames = new char[typeParametersLength][];", "+\t\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "+\t\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "+\t\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "+\t\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "+\t\t\t\t\tif (bounds != null) {", "+\t\t\t\t\t\tint boundLength = bounds.length;", "+\t\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "+\t\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "+\t\t\t\t\t\t\tboundNames[j] = ", "+\t\t\t\t\t\t\t\tCharOperation.concatWith(bounds[i].getParameterizedTypeName(), '.'); ", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}\t\t\t", "-\t\t\t\tthrownExceptionTypes);", "+\t\t\t\tthrownExceptionTypes,", "+\t\t\t\ttypeParameterNames,", "+\t\t\t\ttypeParameterBounds);", "+\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();", "+\t\tchar[][] typeParameterNames = null;", "+\t\tchar[][][] typeParameterBounds = null;", "+\t\tif (typeParameters != null) {", "+\t\t\tint typeParametersLength = typeParameters.length;", "+\t\t\ttypeParameterNames = new char[typeParametersLength][];", "+\t\t\ttypeParameterBounds = new char[typeParametersLength][][];", "+\t\t\tfor (int i = 0; i < typeParametersLength; i++) {", "+\t\t\t\ttypeParameterNames[i] = typeParameters[i].name;", "+\t\t\t\tTypeReference[] bounds = typeParameters[i].bounds;", "+\t\t\t\tif (bounds != null) {", "+\t\t\t\t\tint boundLength = bounds.length;", "+\t\t\t\t\tchar[][] boundNames = new char[boundLength][];", "+\t\t\t\t\tfor (int j = 0; j < boundLength; j++) {", "+\t\t\t\t\t\tboundNames[j] = ", "+\t\t\t\t\t\t\tCharOperation.concatWith(bounds[i].getParameterizedTypeName(), '.'); ", "+\t\t\t\t\t}", "+\t\t\t\t\ttypeParameterBounds[i] = boundNames;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\trequestor.enterMethod(", "-\t\t\tmethodDeclaration.declarationSourceStart, ", "-\t\t\tdeprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "-\t\t\treturnTypeName(((MethodDeclaration) methodDeclaration).returnType), ", "-\t\t\tmethodDeclaration.selector, ", "-\t\t\tmethodDeclaration.sourceStart, ", "-\t\t\tselectorSourceEnd, ", "-\t\t\targumentTypes, ", "-\t\t\targumentNames, ", "-\t\t\tthrownExceptionTypes); ", "+\t\tif (methodDeclaration instanceof MethodDeclaration) {", "+\t\t\tTypeReference returnType = ((MethodDeclaration) methodDeclaration).returnType;", "+\t\t\trequestor.enterMethod(", "+\t\t\t\tmethodDeclaration.declarationSourceStart, ", "+\t\t\t\tdeprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "+\t\t\t\treturnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.'),", "+\t\t\t\tmethodDeclaration.selector, ", "+\t\t\t\tmethodDeclaration.sourceStart, ", "+\t\t\t\tselectorSourceEnd, ", "+\t\t\t\targumentTypes, ", "+\t\t\t\targumentNames, ", "+\t\t\t\tthrownExceptionTypes,", "+\t\t\t\ttypeParameterNames,", "+\t\t\t\ttypeParameterBounds);", "+\t\t} else {", "+\t\t\tTypeReference returnType = ((AnnotationTypeMemberDeclaration) methodDeclaration).returnType;", "+\t\t\trequestor.enterMethod(", "+\t\t\t\tmethodDeclaration.declarationSourceStart, ", "+\t\t\t\tdeprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, ", "+\t\t\t\treturnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.'),", "+\t\t\t\tmethodDeclaration.selector, ", "+\t\t\t\tmethodDeclaration.sourceStart, ", "+\t\t\t\tselectorSourceEnd, ", "+\t\t\t\targumentTypes, ", "+\t\t\t\targumentNames, ", "+\t\t\t\tthrownExceptionTypes,", "+\t\t\t\ttypeParameterNames,", "+\t\t\t\ttypeParameterBounds);", "+\t\t}", "+\t\t"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5223d6731719673e9593d9dd32006d9c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClassFileMatchLocator.java", "commitBeforeChange": "45a50f132d1a94817dc9fe333d375cdfb8483391", "commitAfterChange": "c6f039f09be385a8260b048a357d065b24687173", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "signatureAfterChange": " public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException", "diff": ["-\tint accuracy = SearchMatch.A_ACCURATE;", "-\tif (((InternalSearchPattern)pattern).mustResolve) {", "-\t\ttry {", "-\t\t\tBinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);", "-\t\t\tif (binding != null) {", "-\t\t\t\t// filter out element not in hierarchy scope", "-\t\t\t\tif (!locator.typeInHierarchy(binding)) return;", "+\t// Get methods from binary type info", "+\tIBinaryMethod[] binaryMethods = info.getMethods();", "+\tint bMethodsLength = binaryMethods == null ? 0 : binaryMethods.length;", "+\tIBinaryMethod[] inaccurateMethods = new IBinaryMethod[bMethodsLength];", "+\tchar[][] binaryMethodSignatures = null;", "+\tif (bMethodsLength > 0) {", "+\t\tSystem.arraycopy(binaryMethods, 0, inaccurateMethods, 0, bMethodsLength);", "+\t}", "-\t\t\t\tMethodBinding[] methods = binding.methods();", "-\t\t\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "-\t\t\t\t\tMethodBinding method = methods[i];", "-\t\t\t\t\tif (locator.patternLocator.resolveLevel(method) == PatternLocator.ACCURATE_MATCH) {", "-\t\t\t\t\t\tchar[] methodSignature = method.genericSignature();", "-\t\t\t\t\t\tif (methodSignature == null) methodSignature = method.signature();", "+\t// Get fields from binary type info", "+\tIBinaryField[] binaryFields = info.getFields();", "+\tint bFieldsLength = binaryFields == null ? 0 : binaryFields.length;", "+\tIBinaryField[] inaccurateFields = new IBinaryField[bFieldsLength];", "+\tif (bFieldsLength > 0) {", "+\t\tSystem.arraycopy(binaryFields, 0, inaccurateFields, 0, bFieldsLength);", "+\t}", "+\t", "+\t// Report as many accurate matches as possible", "+\tif (((InternalSearchPattern)pattern).mustResolve) {", "+\t\tBinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);", "+\t\tif (binding != null) {", "+\t\t\t// filter out element not in hierarchy scope", "+\t\t\tif (!locator.typeInHierarchy(binding)) return;", "+", "+\t\t\t// Report accurate methods", "+\t\t\tMethodBinding[] availableMethods = binding.availableMethods();", "+\t\t\tint aMethodsLength = availableMethods == null ? 0 : availableMethods.length;", "+\t\t\tfor (int i = 0; i < aMethodsLength; i++) {", "+\t\t\t\tMethodBinding method = availableMethods[i];", "+\t\t\t\tint level = locator.patternLocator.resolveLevel(method);", "+\t\t\t\tchar[] methodSignature = method.genericSignature();", "+\t\t\t\tif (methodSignature == null) methodSignature = method.signature();", "+\t\t\t\tswitch (level) {", "+\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through impossible match case to remove the reported method", "+\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "+\t\t\t\t\t\t// Store binary method signatures to avoid multiple computation", "+\t\t\t\t\t\tif (binaryMethodSignatures == null) {", "+\t\t\t\t\t\t\tbinaryMethodSignatures = new char[bMethodsLength][];", "+\t\t\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "+\t\t\t\t\t\t\t\tIBinaryMethod binaryMethod = binaryMethods[j];", "+\t\t\t\t\t\t\t\tchar[] signature = binaryMethod.getGenericSignature();", "+\t\t\t\t\t\t\t\tif (signature == null) signature = binaryMethod.getMethodDescriptor();", "+\t\t\t\t\t\t\t\tbinaryMethodSignatures[j] = signature;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t// The method is either accurate or impossible so remove from inaccurate methods list", "+\t\t\t\t\t\tfor (int j=0; j<bMethodsLength; j++) {", "+\t\t\t\t\t\t\tif (CharOperation.equals(binaryMethods[j].getSelector(), method.selector) && CharOperation.equals(binaryMethodSignatures[j], methodSignature)) {", "+\t\t\t\t\t\t\t\tinaccurateMethods[j] = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t}", "-\t\t\t\tFieldBinding[] fields = binding.fields();", "-\t\t\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "-\t\t\t\t\tFieldBinding field = fields[i];", "-\t\t\t\t\tif (locator.patternLocator.resolveLevel(field) == PatternLocator.ACCURATE_MATCH) {", "+\t\t\t// Report accurate fields", "+\t\t\tFieldBinding[] availableFields = binding.availableFields();", "+\t\t\tint aFieldsLength = availableFields == null ? 0 : availableFields.length;", "+\t\t\tfor (int i = 0; i < aFieldsLength; i++) {", "+\t\t\t\tFieldBinding field = availableFields[i];", "+\t\t\t\tint level = locator.patternLocator.resolveLevel(field);", "+\t\t\t\tswitch (level) {", "+\t\t\t\t\tcase PatternLocator.ACCURATE_MATCH:", "-\t\t\t\t\t}", "+\t\t\t\t\t\t// fall through impossible match case to remove reported field", "+\t\t\t\t\tcase PatternLocator.IMPOSSIBLE_MATCH:", "+\t\t\t\t\t\t// The field is either an accurate or impossible match, so remove it from inaccurate fields list", "+\t\t\t\t\t\tfor (int j=0; j<bFieldsLength; j++) {", "+\t\t\t\t\t\t\tif ( CharOperation.equals(binaryFields[j].getName(), field.name)) {", "+\t\t\t\t\t\t\t\tinaccurateFields[j] = null;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tbreak;", "+\t\t\t}", "-\t\t\t\t// no need to check binary info since resolve was successful", "+\t\t\t// If all methods/fields were accurate then returns now", "+\t\t\tif (bMethodsLength == aMethodsLength && bFieldsLength == aFieldsLength) {", "-\t\t} catch (AbortCompilation e) { // if compilation was aborted it is a problem with the class path", "-\t\t// report as a potential match if binary info matches the pattern\t\t", "-\t\taccuracy = SearchMatch.A_INACCURATE;", "-\tIBinaryMethod[] methods = info.getMethods();", "-\tif (methods != null) {", "-\t\tfor (int i = 0, l = methods.length; i < l; i++) {", "-\t\t\tIBinaryMethod method = methods[i];", "-\t\t\tif (matchBinary(pattern, method, info)) {", "-\t\t\t\tchar[] name;", "-\t\t\t\tif (method.isConstructor()) {", "-\t\t\t\t\tname = info.getName();", "-\t\t\t\t\tint lastSlash = CharOperation.lastIndexOf('/', name);", "-\t\t\t\t\tif (lastSlash != -1) {", "-\t\t\t\t\t\tname = CharOperation.subarray(name, lastSlash+1, name.length);", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tname = method.getSelector();", "+\t// Report inaccurate methods", "+\tfor (int i=0; i < bMethodsLength; i++) {", "+\t\tIBinaryMethod method = inaccurateMethods[i];", "+\t\tif (method == null) continue; // impossible match or already reported as accurate", "+\t\tif (matchBinary(pattern, method, info)) {", "+\t\t\tchar[] name;", "+\t\t\tif (method.isConstructor()) {", "+\t\t\t\tname = info.getName();", "+\t\t\t\tint lastSlash = CharOperation.lastIndexOf('/', name);", "+\t\t\t\tif (lastSlash != -1) {", "+\t\t\t\t\tname = CharOperation.subarray(name, lastSlash+1, name.length);", "-\t\t\t\tString selector = new String(name);", "-\t\t\t\tString[] parameterTypes = CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(method.getMethodDescriptor())));", "-\t\t\t\tIMethod methodHandle = binaryType.getMethod(selector, parameterTypes);", "-\t\t\t\tmethodHandle = new ResolvedBinaryMethod(binaryType, selector, parameterTypes, methodHandle.getKey());", "-\t\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, accuracy);", "+\t\t\t} else {", "+\t\t\t\tname = method.getSelector();", "+\t\t\tString selector = new String(name);", "+\t\t\tchar[] methodSignature = binaryMethodSignatures == null ? null : binaryMethodSignatures[i];", "+\t\t\tif (methodSignature == null) {", "+\t\t\t\tmethodSignature = method.getGenericSignature();", "+\t\t\t\tif (methodSignature == null) methodSignature = method.getMethodDescriptor();", "+\t\t\t}", "+\t\t\tString[] parameterTypes = CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(methodSignature)));", "+\t\t\tIMethod methodHandle = binaryType.getMethod(selector, parameterTypes);", "+\t\t\tmethodHandle = new ResolvedBinaryMethod(binaryType, selector, parameterTypes, methodHandle.getKey());", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, methodHandle, null, info, SearchMatch.A_INACCURATE);", "-\tIBinaryField[] fields = info.getFields();", "-\tif (fields != null) {", "-\t\tfor (int i = 0, l = fields.length; i < l; i++) {", "-\t\t\tIBinaryField field = fields[i];", "-\t\t\tif (matchBinary(pattern, field, info)) {", "-\t\t\t\tString fieldName = new String(field.getName());", "-\t\t\t\tIField fieldHandle = binaryType.getField(fieldName);", "-\t\t\t\tfieldHandle = new ResolvedBinaryField(binaryType, fieldName, fieldHandle.getKey());", "-\t\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, accuracy);", "-\t\t\t}", "+\t// Report inaccurate fields", "+\tfor (int i=0; i<bFieldsLength; i++) {", "+\t\tIBinaryField field = inaccurateFields[i];", "+\t\tif (field == null) continue; // impossible match or already reported as accurate", "+\t\tif (matchBinary(pattern, field, info)) {", "+\t\t\tString fieldName = new String(field.getName());", "+\t\t\tIField fieldHandle = binaryType.getField(fieldName);", "+\t\t\tfieldHandle = new ResolvedBinaryField(binaryType, fieldName, fieldHandle.getKey());", "+\t\t\tlocator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, SearchMatch.A_INACCURATE);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b8989b3cbdd769cb8f256bf8b73211a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+\tif (this.primaryExceptionVariable != null) {", "+\t\tthis.primaryExceptionVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\tif (this.caughtThrowableVariable != null) {", "+\t\tthis.caughtThrowableVariable.useFlag = LocalVariableBinding.USED;", "+\t}", "+\t\t\t\tthis.caughtExceptionsCatchBlocks,", "+\t\t\t\tthis.catchArguments,", "+\t\tfor (int i = 0, max = this.resources.length; i < max; i++) {", "+\t\t\tflowInfo = this.resources[i].analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.resources[i].binding.useFlag = LocalVariableBinding.USED; // Is implicitly used anyways.", "+\t\t\tTypeBinding type = this.resources[i].binding.type;", "+\t\t\tif (type != null && type.isValidBinding()) {", "+\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "+\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "+\t\t\t\tif (closeMethod != null && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], flowInfo, currentScope, true);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\tif (this.caughtExceptionTypes[i].isUncheckedException(true)) {", "+\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i])).", "+\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(this.caughtExceptionTypes[i]);", "+\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+\t\t\t\tthis.caughtExceptionsCatchBlocks,", "+\t\t\t\tthis.catchArguments,", "+\t\tfor (int i = 0, max = this.resources.length; i < max; i++) {", "+\t\t\tflowInfo = this.resources[i].analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\tthis.resources[i].binding.useFlag = LocalVariableBinding.USED; // Is implicitly used anyways.", "+\t\t\tTypeBinding type = this.resources[i].binding.type;", "+\t\t\tif (type != null && type.isValidBinding()) {", "+\t\t\t\tReferenceBinding binding = (ReferenceBinding) type;", "+\t\t\t\tMethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter", "+\t\t\t\tif (closeMethod != null && closeMethod.returnType.id == TypeIds.T_void) {", "+\t\t\t\t\tReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;", "+\t\t\t\t\tfor (int j = 0, length = thrownExceptions.length; j < length; j++) {", "+\t\t\t\t\t\thandlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[j], flowInfo, currentScope);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "-\t\t\t\tif (this.caughtExceptionTypes[i].isUncheckedException(true)) {", "+\t\t\t\tif (isUncheckedCatchBlock(i)) {", "-\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i])).", "+\t\t\t\t\t\t\t\t\thandlingContext.initsOnException(i)).", "-\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(this.caughtExceptionTypes[i]);", "+\t\t\t\t\tFlowInfo initsOnException = handlingContext.initsOnException(i);", "-\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\tif (this.tryBlock.statements == null && this.resources == NO_RESOURCES) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=350579", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f1e3200e92e5732d755b8020e2338ee", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/IndexSelector.java", "commitBeforeChange": "8eff811a28d835d940585e1dd6e43b7e81d9c25c", "commitAfterChange": "ecd6b6b03e84e16fa2ef3316475695c9990930d4", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " private boolean canSeeFocus(IPath projectOrJarPath)", "signatureAfterChange": " public static boolean canSeeFocus(IJavaElement focus, boolean isPolymorphicSearch, IPath projectOrJarPath)", "diff": ["- */", "-private boolean canSeeFocus(IPath projectOrJarPath) {", "-\t// if it is a workspace scope, focus is visible from everywhere", "-\t// if (this.searchScope instanceof JavaWorkspaceScope) return true;", "-\t", "-\treturn canSeeFocus(getProjectOrJar(this.focus), projectOrJarPath);", "+public static boolean canSeeFocus(IJavaElement focus, boolean isPolymorphicSearch, IPath projectOrJarPath) {", "+\t\tif (project == null) {", "+\t\t\t// projectOrJarPath is a jar", "+\t\t\t// it can see the focus only if it is on the classpath of a project that can see the focus", "+\t\t\tIJavaProject[] allProjects = model.getJavaProjects();", "+\t\t\tfor (int i = 0, length = allProjects.length; i < length; i++) {", "+\t\t\t\tIJavaProject otherProject = allProjects[i];", "+\t\t\t\tIClasspathEntry[] entries = otherProject.getResolvedClasspath(true);", "+\t\t\t\tfor (int j = 0, length2 = entries.length; j < length2; j++) {", "+\t\t\t\t\tIClasspathEntry entry = entries[j];", "+\t\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) ", "+\t\t\t\t\t\t&& entry.getPath().equals(projectOrJarPath)) {", "+\t\t\t\t\t\t\tif (canSeeFocus(focus, isPolymorphicSearch, otherProject.getPath())) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn false;", "+\t\t} else {", "+\t\t\t// projectOrJarPath is a project", "+\t\t\tJavaProject focusProject = focus instanceof JarPackageFragmentRoot ? (JavaProject)focus.getParent() : (JavaProject)focus;", "+\t\t\tif (isPolymorphicSearch) {", "+\t\t\t\t// look for refering project", "+\t\t\t\tIClasspathEntry[] entries = focusProject.getExpandedClasspath(true);", "+\t\t\t\tfor (int i = 0, length = entries.length; i < length; i++) {", "+\t\t\t\t\tIClasspathEntry entry = entries[i];", "+\t\t\t\t\tif ((entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) ", "+\t\t\t\t\t\t&& entry.getPath().equals(projectOrJarPath)) {", "+\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tif (focus instanceof JarPackageFragmentRoot) {", "+\t\t\t\t// focus is part of a jar", "+\t\t\t\tIPath focusPath = focus.getPath();", "+\t\t\t\t\t\t&& entry.getPath().equals(focusPath)) {", "+\t\t\t\t// focus is part of a project", "+\t\t\t\tif (focus.equals(project)) {", "+\t\t\t\t\t// look for dependent projects"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d31d654d63970b1e540e705f0a6d049d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "8726985690d5211d83787440cfdc69960f688cd3", "commitAfterChange": "b2bac1f114347c5119b74b76ba91158e0de76647", "methodNumberBeforeChange": 39, "methodNumberAfterChange": 39, "signatureBeforeChange": "\r \tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor)", "signatureAfterChange": "\r \tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException", "diff": ["-\tpublic void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){\r", "-/*\r", "+\tpublic static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] newContainers, IProgressMonitor monitor) throws JavaModelException {\r", "+\r", "-\t\t\r", "+\r", "+\t\tint projectLength = affectedProjects.length;\r", "-\t\tArrayList projectsToCheck = new ArrayList();\r", "+\t\tIClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];\r", "+\r", "+\t\t// filter out unmodified project containers\r", "+\t\tint remaining = 0;\r", "+\t\tfor (int i = 0; i < projectLength; i++){\r", "+\r", "+\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "+\r", "+\t\t\tIJavaProject affectedProject = affectedProjects[i];\r", "+\t\t\tIClasspathContainer newContainer = newContainers[i];\r", "+\t\t\t\r", "+\t\t\tIClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();\r", "+\t\t\tboolean found = false;\r", "+\t\t\tfor (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {", "+\t\t\t\tIClasspathEntry entry = rawClasspath[j];\r", "+\t\t\t\tif (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){\r", "+\t\t\t\t\tfound = true;\r", "+\t\t\t\t\tbreak;\r", "+\t\t\t\t}", "+\t\t\t}\r", "+\t\t\tif (!found){\r", "+\t\t\t\taffectedProjects[i] = null; // filter out this project - does not reference the container path\r", "+\t\t\t\tcontinue;\r", "+\t\t\t}\r", "+\t\t\tMap perProjectContainers = (Map)JavaModelManager.Containers.get(affectedProject);\r", "+\t\t\tif (perProjectContainers == null){\r", "+\t\t\t\tperProjectContainers = new HashMap();\r", "+\t\t\t\tJavaModelManager.Containers.put(affectedProject, perProjectContainers);\r", "+\t\t\t} else {\r", "+\t\t\t\tIClasspathContainer oldContainer = (IClasspathContainer) perProjectContainers.get(containerPath);\r", "+\t\t\t\tif (oldContainer != null && oldContainer.equals(newContainers[i])){\r", "+\t\t\t\t\taffectedProjects[i] = null; // filter out this project - container did not change\r", "+\t\t\t\t\tcontinue;\r", "+\t\t\t\t}\r", "+\t\t\t}\r", "+\t\t\tremaining++;\r", "+\t\t\toldResolvedPaths[i] = affectedProject.getResolvedClasspath(true);\r", "+\t\t\tperProjectContainers.put(containerPath, newContainer);\r", "+\t\t}\r", "-\t\tswitch (affectedElement.getElementType()){\r", "-\t\t\tcase IJavaElement.JAVA_PROJECT:\r", "-\t\t\t\tprojectsToCheck.add(affectedElement);\r", "-\t\t\t\tbreak;\r", "-\t\t\tcase IJavaElement.JAVA_MODEL:\r", "-\t\t\t\tIJavaProject[] projects = manager.getJavaModel().getJavaProjects();\r", "-\t\t\t\tfor (int i = 0; i < projects.length; i++) {\r", "-\t\t\t\t\tprojectsToCheck.add(projects[i]);\r", "-\t\t\t\t}\r", "-\t\t\t\tbreak;\r", "-\t\t\tdefault:\r", "-\t\t\t\t// no effect if affected element isn't one of the above case\r", "-\t\t\t\treturn;\r", "-\t\t}\r", "-\r", "-\t\t// gather classpath information for updating\r", "-\t\tHashMap affectedProjects = new HashMap(5);\r", "-\r", "-\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\tnextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){\r", "-\t\t\tIJavaProject project = projectsToCheck[i];\r", "-\t\t\t\t\t\r", "-\t\t\t// check to see if any of the modified variables is present on the classpath\r", "-\t\t\tIClasspathEntry[] classpath = project.getRawClasspath();\r", "-\t\t\tfor (int j = 0, cpLength = classpath.length; j < cpLength; j++){\r", "+\t\tif (remaining == 0) return;\r", "+\t\t\r", "+\t\t// trigger model refresh\r", "+\t\tboolean wasFiring = manager.isFiring();\r", "+\t\tint count = 0;\r", "+\t\ttry {\r", "+\t\t\tif (wasFiring)\r", "+\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\tIClasspathEntry entry = classpath[j];\r", "-\t\t\t\tfor (int k = 0; k < varLength; k++){\r", "+\t\t\tfor(int i = 0; i < projectLength; i++){\r", "-\t\t\t\t\tString variableName = variableNames[k];\t\t\t\t\t\t\r", "-\t\t\t\t\tif (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){\r", "+\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\t\t\t\t\t\tif (entry.getPath().equals(containerPath)){\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\t\r", "-\t\t\t\t\t\t\t// also check whether it will be necessary to update proj references and cycle markers\r", "-\t\t\t\t\t\t\tif (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){\r", "-\t\t\t\t\t\t\t\tIPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);\r", "-\t\t\t\t\t\t\t\tif (oldPath != null && oldPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t} else {\r", "-\t\t\t\t\t\t\t\t\tIPath newPath = variablePaths[k];\r", "-\t\t\t\t\t\t\t\t\tif (newPath != null && newPath.segmentCount() == 1) {\r", "-\t\t\t\t\t\t\t\t\t\tmayChangeProjectDependencies = true;\r", "-\t\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\t}\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t\tIPath sourcePath, sourceRootPath;\r", "-\t\t\t\t\t\tif (((sourcePath = entry.getSourceAttachmentPath()) != null\t&& sourcePath.segment(0).equals(variableName))\r", "-\t\t\t\t\t\t\t|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null\t&& sourceRootPath.segment(0).equals(variableName))) {\r", "-\r", "-\t\t\t\t\t\t\taffectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));\r", "-\t\t\t\t\t\t\tcontinue nextProject;\r", "-\t\t\t\t\t\t}\r", "-\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\r", "-\t\t\t\t}\r", "-\t\t\t}\r", "-\t\t}\r", "-\r", "-\t\t// reset saved container path\r", "-\t\tfor (int i = 0; i < \r", "-\t\tMap projectContainers = (Map)JavaModelManager.Containers.get(project);\r", "-\t\tif (projectContainers != null){\r", "-\t\t\tIClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);\r", "+\t\t\t\tJavaProject affectedProject = (JavaProject)affectedProjects[i];\r", "+\t\t\t\tif (affectedProject == null) continue; // was filtered out\r", "-\t\t// update affected project classpaths\r", "-\t\tif (!affectedProjects.isEmpty()) {\r", "-\t\t\tboolean wasFiring = manager.isFiring();\r", "-\t\t\ttry {\r", "-\t\t\t\tif (wasFiring)\r", "-\t\t\t\t\tmanager.stopDeltas();\r", "-\t\t\t\t// propagate classpath change\r", "-\t\t\t\tIterator projectsToUpdate = affectedProjects.keySet().iterator();\r", "-\t\t\t\twhile (projectsToUpdate.hasNext()) {\r", "-\r", "-\t\t\t\t\tif (monitor != null && monitor.isCanceled()) return;\r", "-\r", "-\t\t\t\t\tJavaProject project = (JavaProject) projectsToUpdate.next();\r", "-\t\t\t\t\t\r", "-\t\t\t\t\tif (!projectsToUpdate.hasNext()) {\r", "-\t\t\t\t\t\t// re-enable firing for the last operation\r", "-\t\t\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\t\t\twasFiring = false;\r", "-\t\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t\t}\r", "+\t\t\t\tif (++count == remaining) { // re-enable firing for the last operation\r", "+\t\t\t\t\tif (wasFiring) {\r", "+\t\t\t\t\t\twasFiring = false;\r", "+\t\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\tproject\r", "-\t\t\t\t\t\t.setRawClasspath(\r", "-\t\t\t\t\t\t\tproject.getRawClasspath(),\r", "-\t\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "-\t\t\t\t\t\t\tmonitor,\r", "-\t\t\t\t\t\t\ttrue,\r", "-\t\t\t\t\t\t\tproject.getWorkspace().isAutoBuilding(),\r", "-\t\t\t\t\t\t\t// force build if in auto build mode\r", "-\t\t\t\t\t\t\t(IClasspathEntry[]) affectedProjects.get(project),\r", "-\t\t\t\t\t\t\tmayChangeProjectDependencies);\r", "-\t\t\t} finally {\r", "-\t\t\t\tif (wasFiring) {\r", "-\t\t\t\t\tmanager.startDeltas();\r", "-\t\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t\r", "+\t\t\t\t// force a refresh of the affected project (will compute deltas)\r", "+\t\t\t\taffectedProject.setRawClasspath(\r", "+\t\t\t\t\t\taffectedProject.getRawClasspath(),\r", "+\t\t\t\t\t\tSetClasspathOperation.ReuseOutputLocation,\r", "+\t\t\t\t\t\tmonitor,\r", "+\t\t\t\t\t\ttrue,\r", "+\t\t\t\t\t\taffectedProject.getWorkspace().isAutoBuilding(),\r", "+\t\t\t\t\t\toldResolvedPaths[i],\r", "+\t\t\t\t\t\tremaining == 1); // no individual cycle check if more than 1 project\r", "+\t\t\t}\r", "+\t\t\tif (remaining > 1){\r", "+\t\t\t\ttry {\r", "+\t\t\t\t\t// use workspace runnable so as to allow marker creation - workaround bug 14733\r", "+\t\t\t\t\tResourcesPlugin.getWorkspace().run(\r", "+\t\t\t\t\t\tnew IWorkspaceRunnable() {\r", "+\t\t\t\t\t\t\tpublic void run(IProgressMonitor monitor) throws CoreException {\r", "+\t\t\t\t\t\t\t\tJavaProject.updateAllCycleMarkers(); // update them all at once\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t}, \r", "+\t\t\t\t\t\tmonitor);\t\t\t\t\t\r", "+\t\t\t\t} catch(CoreException e){\r", "+\t\t\t\t\tthrow new JavaModelException(e);\r", "+\t\t} finally {\r", "+\t\t\tif (wasFiring) {\r", "+\t\t\t\tmanager.startDeltas();\r", "+\t\t\t\t// in case of exception traversing, deltas may be fired only in the next #fire() iteration\r", "+\t\t\t}\r", "-*/\r", "+\t\t\t\t\t\r"]}], "num": 48142}