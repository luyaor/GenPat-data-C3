{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "c89eced71cf1082541c2ec7efda15ea1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5f9b5f3e60c0ed3ed8238ff3c650d58d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "b1909bb0c4bbb70fecea5345c2e954fa4204b1dd", "commitAfterChange": "1ef42230a28632657bfac5df1d197b6d35dcc83d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \tprivate static TypeBinding[] resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, TypeBinding[] substitutes, boolean considerEXTENDSConstraints, Map collectedSubstitutes)", "signatureAfterChange": " \t \tprivate static boolean resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, InferenceContext inferenceContext, boolean considerEXTENDSConstraints)", "diff": ["-\tprivate static TypeBinding[] resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, TypeBinding[] substitutes, boolean considerEXTENDSConstraints, Map collectedSubstitutes) {", "-\t\tif (collectedSubstitutes.isEmpty()) {", "-\t\t\t// raw generic method inferred", "-\t\t\treturn Binding.NO_TYPES; // empty array", "-\t\t}", "+\tprivate static boolean resolveSubstituteConstraints(Scope scope, TypeVariableBinding[] typeVariables, InferenceContext inferenceContext, boolean considerEXTENDSConstraints) {", "+\t\tTypeBinding[] substitutes = inferenceContext.substitutes;", "-\t\t", "-\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\tTypeBinding [] equalSubstitutes = variableSubstitutes[CONSTRAINT_EQUAL];", "+\t\t\t\tTypeBinding [] equalSubstitutes = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_EQUAL);", "-\t\tif (hasUnresolvedTypeArgument(substitutes)) {", "+\t\tif (inferenceContext.hasUnresolvedTypeArgument()) {", "-\t\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\t\tTypeBinding [] bounds = variableSubstitutes[CONSTRAINT_SUPER];", "+\t\t\t\t\tTypeBinding [] bounds = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_SUPER);", "-\t\t\t\t\tif (mostSpecificSubstitute == null)", "-\t\t\t\t\t\treturn null; // incompatible", "+\t\t\t\t\tif (mostSpecificSubstitute == null) {", "+\t\t\t\t\t\treturn false; // incompatible", "+\t\t\t\t\t}", "-\t\tif (considerEXTENDSConstraints && hasUnresolvedTypeArgument(substitutes)) {", "+\t\tif (considerEXTENDSConstraints && inferenceContext.hasUnresolvedTypeArgument()) {", "-\t\t\t\t\tTypeBinding[][] variableSubstitutes = (TypeBinding[][]) collectedSubstitutes.get(current);", "-\t\t\t\t\tTypeBinding [] bounds = variableSubstitutes[CONSTRAINT_EXTENDS];", "+\t\t\t\t\tTypeBinding [] bounds = inferenceContext.getSubstitutes(current, TypeConstants.CONSTRAINT_EXTENDS);", "-\t\treturn substitutes;", "+\t\treturn true;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9be44dcc8ff0c590ed33b709b3ed09e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java", "commitBeforeChange": "b1909bb0c4bbb70fecea5345c2e954fa4204b1dd", "commitAfterChange": "1ef42230a28632657bfac5df1d197b6d35dcc83d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint)", "signatureAfterChange": " \tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint)", "diff": ["-\tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint) {", "+\tpublic void collectSubstitutes(Scope scope, TypeBinding actualType, InferenceContext inferenceContext, int constraint) {", "+\t\t", "+\t\t//\tonly infer for type params of the generic method", "+\t\tif (this.declaringElement != inferenceContext.genericMethod) return;", "-\t    TypeBinding[][] variableSubstitutes = (TypeBinding[][])substitutes.get(this);", "-\t    if (variableSubstitutes != null) {", "-\t\t    insertLoop: {", "-\t\t    \tTypeBinding[] constraintSubstitutes = variableSubstitutes[variableConstraint];", "-\t\t    \tint length;", "-\t\t    \tif (constraintSubstitutes == null) {", "-\t\t    \t\tlength = 0;", "-\t\t    \t\tconstraintSubstitutes = new TypeBinding[1];", "-\t\t    \t} else {", "-\t\t    \t\tlength = constraintSubstitutes.length;", "-\t\t\t        for (int i = 0; i < length; i++) {", "-\t\t\t        \tTypeBinding substitute = constraintSubstitutes[i];", "-\t\t\t            if (substitute == actualType) return; // already there", "-\t\t\t            if (substitute == null) {", "-\t\t\t                constraintSubstitutes[i] = actualType;", "-\t\t\t                break insertLoop;", "-\t\t\t            }", "-\t\t\t        }", "-\t\t\t        // no free spot found, need to grow by one", "-\t\t\t        System.arraycopy(constraintSubstitutes, 0, constraintSubstitutes = new TypeBinding[length+1], 0, length);", "-\t\t    \t}", "-\t\t        constraintSubstitutes[length] = actualType;", "-\t\t        variableSubstitutes[variableConstraint] = constraintSubstitutes;", "-\t\t    }", "-\t    }", "+\t\tinferenceContext.recordSubstitute(this, actualType, variableConstraint);"]}], "num": 40452}