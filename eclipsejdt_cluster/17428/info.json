{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ddfcd50f5f4f00e8ffbb57e2b8040095", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2e5f2831b88e6eac4c9d71129e7501d3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "e0cd6e6d433203b4e058ad278dd47a28ff7501a4", "commitAfterChange": "1e3b5e92aa51321dda2b6b727f1d9a3ab953e626", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 12, "signatureBeforeChange": "  public FieldBinding[] fields()", "signatureAfterChange": " public FieldBinding[] fields()", "diff": ["-", "-\tif ((tagBits & AreFieldsComplete) == 0) {", "-\t\tfor (int i = fields.length; --i >= 0;)", "-\t\t\tresolveTypeFor(fields[i]);", "-\t\ttagBits |= AreFieldsComplete;", "-\t}", "+\tif ((tagBits & AreFieldsComplete) != 0)", "+\t\treturn fields;", "+", "+\tfor (int i = fields.length; --i >= 0;)", "+\t\tresolveTypeFor(fields[i]);", "+\ttagBits |= AreFieldsComplete;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9e3e823a2fedbd6ae52df5ed28a39cf4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "e0cd6e6d433203b4e058ad278dd47a28ff7501a4", "commitAfterChange": "1e3b5e92aa51321dda2b6b727f1d9a3ab953e626", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "  public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-", "-\tif ((tagBits & AreMethodsComplete) == 0) {", "-\t\tfor (int i = methods.length; --i >= 0;)", "-\t\t\tresolveTypesFor(methods[i]);", "-\t\ttagBits |= AreMethodsComplete;", "-\t}", "+\tif ((tagBits & AreMethodsComplete) != 0)", "+\t\treturn methods;", "+", "+\tfor (int i = methods.length; --i >= 0;)", "+\t\tresolveTypesFor(methods[i]);", "+\ttagBits |= AreMethodsComplete;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9132d3314afd1a91ed0ada310ad336c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java", "commitBeforeChange": "8c76b4014ea5428c07ebba6a1cc324074d6e35bd", "commitAfterChange": "ff2a27470c07ef3625cccb4ee1e5803e3112da43", "methodNumberBeforeChange": 29, "methodNumberAfterChange": 29, "signatureBeforeChange": " private int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, int depth, MatchLocator locator)", "signatureAfterChange": " private int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, int depth, MatchLocator locator)", "diff": ["-\t\t\t// If we get a binding for pattern arg, then verify if it is compatible with match type argument binding", "-\t\t\tif (patternBinding != null) {", "-\t\t\t\tTypeBinding argumentBinding = argumentsBinding[i];", "-\t\t\t\tswitch (patternWildcard) {", "-\t\t\t\t\tcase Signature.C_STAR : // UNBOUND pattern", "-\t\t\t\t\t\t// unbound always match => skip to next argument", "-\t\t\t\t\t\tcontinue;", "-\t\t\t\t\tcase Signature.C_EXTENDS : // EXTENDS pattern", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t\t\t// valid when arg extends a subclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (argumentBinding.isCompatibleWith(patternBinding)) {", "-\t\t\t\t\t\t\t// valid when arg is a subclass of pattern ", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tcase Signature.C_SUPER : // SUPER pattern", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg super a superclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (patternBinding.isCompatibleWith(argumentBinding)) {", "-\t\t\t\t\t\t\t// valid only when arg is a superclass of pattern", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\tdefault:", "-\t\t\t\t\t\tif (argumentBinding.isWildcard()) {", "-\t\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "-\t\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "-\t\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg extends a superclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.SUPER:", "-\t\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "-\t\t\t\t\t\t\t\t\t\t// valid only when arg super a subclass of pattern", "-\t\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "-\t\t\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else if (argumentBinding == patternBinding)", "-\t\t\t\t\t\t\t// valid only when arg is equals to pattern", "-\t\t\t\t\t\t\tcontinue;", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t}", "+\t\t\t// If have no binding for pattern arg, then we won't be able to refine accuracy", "+\t\t\tif (patternBinding == null) return accuracy;", "-\t\t\t\t// Refine the accuracy to impossible", "-\t\t\t\treturn -1;", "+\t\t\t// Verify tha pattern binding is compatible with match type argument binding", "+\t\t\tTypeBinding argumentBinding = argumentsBinding[i];", "+\t\t\tswitch (patternWildcard) {", "+\t\t\t\tcase Signature.C_STAR : // UNBOUND pattern", "+\t\t\t\t\t// unbound always match => skip to next argument", "+\t\t\t\t\tcontinue;", "+\t\t\t\tcase Signature.C_EXTENDS : // EXTENDS pattern", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "+\t\t\t\t\t\t\t\t\t// valid when arg extends a subclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (argumentBinding.isCompatibleWith(patternBinding)) {", "+\t\t\t\t\t\t// valid when arg is a subclass of pattern ", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tcase Signature.C_SUPER : // SUPER pattern", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "+\t\t\t\t\t\t\t\t\t// valid only when arg super a superclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (patternBinding.isCompatibleWith(argumentBinding)) {", "+\t\t\t\t\t\t// valid only when arg is a superclass of pattern", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t}", "+\t\t\t\t\tbreak;", "+\t\t\t\tdefault:", "+\t\t\t\t\tif (argumentBinding.isWildcard()) {", "+\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;", "+\t\t\t\t\t\tswitch (wildcardBinding.kind) {", "+\t\t\t\t\t\t\tcase Wildcard.EXTENDS:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))", "+\t\t\t\t\t\t\t\t\t// valid only when arg extends a superclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.SUPER:", "+\t\t\t\t\t\t\t\tif (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))", "+\t\t\t\t\t\t\t\t\t// valid only when arg super a subclass of pattern", "+\t\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t\tcase Wildcard.UNBOUND:", "+\t\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else if (argumentBinding == patternBinding)", "+\t\t\t\t\t\t// valid only when arg is equals to pattern", "+\t\t\t\t\t\tcontinue;", "+\t\t\t\t\tbreak;", "+\t\t\t", "+\t\t\t// Refine the accuracy to impossible", "+\t\t\treturn -1;"]}], "num": 17428}