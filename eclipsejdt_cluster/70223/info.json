{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7cfe6fd2f61c0fad52b506681a52d88d", "detectedBy": ["AST_HIERARCHICAL", "AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9cd26ce022484a18558be546137db6a1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java", "commitBeforeChange": "c2258f3a34b02ad7356115c6022b2790f990bcd4", "commitAfterChange": "b114726e6672732b572036987107a1d4de90980d", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["-\tthis.actualReceiverType = this.receiver.resolveType(scope); ", "+\tboolean receiverCast = false, argsContainCast = false; ", "+\tif (this.receiver instanceof CastExpression) {", "+\t\tthis.receiver.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\treceiverCast = true;", "+\t}", "+\tthis.actualReceiverType = receiver.resolveType(scope); ", "+\tif (receiverCast && this.actualReceiverType != null) {", "+\t\t // due to change of declaring class with receiver type, only identity cast should be notified", "+\t\tif (((CastExpression)this.receiver).expression.resolvedType == this.actualReceiverType) { ", "+\t\t\tscope.problemReporter().unnecessaryCast((CastExpression)this.receiver);\t\t", "+\t\t}", "+\t}", "+\t// resolve type arguments (for generic constructor call)", "+\tif (this.typeArguments != null) {", "+\t\tint length = this.typeArguments.length;", "+\t\tboolean argHasError = false; // typeChecks all arguments", "+\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tif ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\treturn null;", "+\t\t}", "+\t}", "-\t\tfor (int i = 0; i < length; i++)", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tExpression argument = arguments[i];", "+\t\t\tif (argument instanceof CastExpression) {", "+\t\t\t\targument.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\t\targsContainCast = true;", "+\t\t\t}", "-\t\tif (argHasError)", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\tif(actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\t// record any selector match, for clients who may still need hint about possible method match", "+\t\t\t\tthis.binding = scope.findMethod((ReferenceBinding)actualReceiverType, selector, new TypeBinding[]{}, this);", "+\t\t\t}\t\t\t", "+\t\t}", "-\tif (this.actualReceiverType == null) ", "+\tif (this.actualReceiverType == null) {", "-", "+\t}", "-\t\tif (this.receiver instanceof NameReference) {", "-\t\t\tif ((((NameReference) this.receiver).bits & Binding.TYPE) != 0) {", "-\t\t\t\tscope.problemReporter().mustUseAStaticMethod(this, this.binding);", "-\t\t\t\treturn null;", "+\t\tif (receiver instanceof NameReference ", "+\t\t\t\t&& (((NameReference) receiver).bits & Binding.TYPE) != 0) {", "+\t\t\tscope.problemReporter().mustUseAStaticMethod(this, binding);", "+\t\t} else {", "+\t\t\t// compute generic cast if necessary", "+\t\t\tTypeBinding receiverErasure = this.actualReceiverType.erasure();", "+\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeErasingTo((ReferenceBinding)this.binding.declaringClass.erasure());", "+\t\t\t\tif (match == null) {", "+\t\t\t\t\tthis.actualReceiverType = this.binding.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t}", "+\t\t\treceiver.computeConversion(scope, this.actualReceiverType, this.actualReceiverType);", "-\tif (this.arguments != null)", "-\t\tfor (int i = 0; i < this.arguments.length; i++)", "-\t\t\tthis.arguments[i].computeConversion(scope, this.binding.parameters[i], argumentTypes[i]);", "+\tcheckInvocationArguments(scope, this.receiver, actualReceiverType, binding, this.arguments, argumentTypes, argsContainCast, this);", "-\tif (this.binding.isAbstract()) {", "-\t\tif (this.receiver.isSuper()) {", "-\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, this.binding);", "-\t\t\treturn null;", "+\tif (binding.isAbstract()) {", "+\t\tif (receiver.isSuper()) {", "+\t\t\tscope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);", "-\tif (isMethodUseDeprecated(this.binding, scope))", "-\t\tscope.problemReporter().deprecatedMethod(this.binding, this);", "+\tif (isMethodUseDeprecated(binding, scope))", "+\t\tscope.problemReporter().deprecatedMethod(binding, this);", "-\treturn this.resolvedType = this.binding.returnType;", "+\t// from 1.5 compliance on, array#clone() returns the array type (but binding still shows Object)", "+\tif (actualReceiverType.isArrayType() ", "+\t\t\t&& this.binding.parameters == NoParameters ", "+\t\t\t&& scope.compilerOptions().complianceLevel >= JDK1_5 ", "+\t\t\t&& CharOperation.equals(this.binding.selector, CLONE)) {", "+\t\tthis.resolvedType = actualReceiverType;", "+\t} else {", "+\t\tTypeBinding returnType = this.binding.returnType;", "+\t\tif (returnType != null) returnType = returnType.capture(scope, this.sourceEnd);", "+\t\tthis.resolvedType = returnType;", "+\t}", "+\treturn this.resolvedType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fbfa6c18d4cdc0ac119f00da6974aaa3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java", "commitBeforeChange": "43bf4677e87b76a460506f46871dac9cbe16b176", "commitAfterChange": "f13a740e3b814a194962fd0ef85df91efde745be", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tprotected boolean mustQualifyType( \t\tchar[] packageName, \t\tchar[] typeName)", "signatureAfterChange": " \t \tprotected boolean mustQualifyType( \t\tchar[] packageName, \t\tchar[] typeName, \t\tchar[] enclosingTypeNames, \t\tint modifiers)", "diff": ["+\t", "-\t\tchar[] typeName) {", "+\t\tchar[] typeName,", "+\t\tchar[] enclosingTypeNames,", "+\t\tint modifiers) {", "-\t\t\t", "-\t\tchar[][] compoundPackageName = CharOperation.splitOn('.', packageName);", "-\t\tchar[] readableTypeName = CharOperation.concat(packageName, typeName, '.');", "-", "-\t\tif (CharOperation.equals(unitScope.fPackage.compoundName, compoundPackageName))", "+\t\t", "+\t\tif(!this.importCachesInitialized) {", "+\t\t\tthis.initializeImportCaches();", "+\t\t}", "+\t\t", "+\t\tchar[] fullyQualifiedTypeName = null;", "+\t\t", "+\t\tfor (int i = 0; i < this.importCacheCount; i++) {", "+\t\t\tchar[][] importName = this.importsCache[i];", "+\t\t\tif(CharOperation.equals(typeName, importName[0])) {", "+\t\t\t\tif (fullyQualifiedTypeName == null) {", "+\t\t\t\t\tfullyQualifiedTypeName =", "+\t\t\t\t\t\tenclosingTypeNames == null || enclosingTypeNames.length == 0", "+\t\t\t\t\t\t\t\t? CharOperation.concat(", "+\t\t\t\t\t\t\t\t\t\tpackageName,", "+\t\t\t\t\t\t\t\t\t\ttypeName,", "+\t\t\t\t\t\t\t\t\t\t'.')", "+\t\t\t\t\t\t\t\t: CharOperation.concat(", "+\t\t\t\t\t\t\t\t\t\tCharOperation.concat(", "+\t\t\t\t\t\t\t\t\t\t\tpackageName,", "+\t\t\t\t\t\t\t\t\t\t\tenclosingTypeNames,", "+\t\t\t\t\t\t\t\t\t\t\t'.'),", "+\t\t\t\t\t\t\t\t\t\ttypeName,", "+\t\t\t\t\t\t\t\t\t\t'.');", "+\t\t\t\t}", "+\t\t\t\treturn !CharOperation.equals(fullyQualifiedTypeName, importName[1]);", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tif ((enclosingTypeNames == null || enclosingTypeNames.length == 0 ) && CharOperation.equals(this.currentPackageName, packageName))", "-", "-\t\tImportBinding[] imports = unitScope.imports;", "-\t\tif (imports != null){", "-\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\tif (imports[i].onDemand) {", "-\t\t\t\t\tif (CharOperation.equals(imports[i].compoundName, compoundPackageName)) {", "-\t\t\t\t\t\tfor (int j = 0; j < imports.length; j++) {", "-\t\t\t\t\t\t\tif(i != j){", "-\t\t\t\t\t\t\t\tif(imports[j].onDemand) {", "-\t\t\t\t\t\t\t\t\tif(nameEnvironment.findType(typeName, imports[j].compoundName) != null){", "-\t\t\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\tif(CharOperation.equals(CharOperation.lastSegment(imports[j].readableName(), '.'), typeName)", "-\t\t\t\t\t\t\t\t\t\t&& !CharOperation.equals(imports[j].compoundName, CharOperation.splitOn('.', readableTypeName))) {", "-\t\t\t\t\t\t\t\t\t\treturn true;\t", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "+\t\t", "+\t\tchar[] fullyQualifiedEnclosingTypeName = null;", "+\t\t", "+\t\tfor (int i = 0; i < this.onDemandImportCacheCount; i++) {", "+\t\t\tImportBinding importBinding = this.onDemandImportsCache[i];", "+\t\t\tBinding resolvedImport = importBinding.resolvedImport;", "+\t\t\t", "+\t\t\tchar[][] importName = importBinding.compoundName;", "+\t\t\tchar[] importFlatName = CharOperation.concatWith(importName, '.');", "+\t\t\t", "+\t\t\tboolean isFound = false;", "+\t\t\t// resolvedImport is a ReferenceBindng or a PackageBinding", "+\t\t\tif(resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\tif(enclosingTypeNames != null && enclosingTypeNames.length != 0) {", "+\t\t\t\t\tif(fullyQualifiedEnclosingTypeName == null) {", "+\t\t\t\t\t\tfullyQualifiedEnclosingTypeName =", "+\t\t\t\t\t\t\tCharOperation.concat(", "+\t\t\t\t\t\t\t\t\tpackageName,", "+\t\t\t\t\t\t\t\t\tenclosingTypeNames,", "+\t\t\t\t\t\t\t\t\t'.');", "+\t\t\t\t\t}", "+\t\t\t\t\tif(CharOperation.equals(fullyQualifiedEnclosingTypeName, importFlatName)) {", "+\t\t\t\t\t\tif(importBinding.isStatic()) {", "+\t\t\t\t\t\t\tisFound = (modifiers & IConstants.AccStatic) != 0;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tisFound = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tif(enclosingTypeNames == null || enclosingTypeNames.length == 0) {", "+\t\t\t\t\tif(CharOperation.equals(packageName, importFlatName)) {", "+\t\t\t\t\t\tif(importBinding.isStatic()) {", "+\t\t\t\t\t\t\tisFound = (modifiers & IConstants.AccStatic) != 0;", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tisFound = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t", "+\t\t\t// find potential conflict with another import", "+\t\t\tif(isFound) {", "+\t\t\t\tfor (int j = 0; j < this.onDemandImportCacheCount; j++) {", "+\t\t\t\t\tif(i != j) {", "+\t\t\t\t\t\tImportBinding conflictingImportBinding = this.onDemandImportsCache[j];", "+\t\t\t\t\t\tif(conflictingImportBinding.resolvedImport instanceof ReferenceBinding) {", "+\t\t\t\t\t\t\tReferenceBinding refBinding =", "+\t\t\t\t\t\t\t\t(ReferenceBinding) conflictingImportBinding.resolvedImport;", "+\t\t\t\t\t\t\tif (refBinding.getMemberType(typeName) != null) {", "+\t\t\t\t\t\t\t\treturn true;", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tchar[] conflictingImportName =", "+\t\t\t\t\t\t\t\tCharOperation.concatWith(conflictingImportBinding.compoundName, '.');", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t\t\tif (this.nameEnvironment.nameLookup.findType(", "+\t\t\t\t\t\t\t\t\tString.valueOf(typeName),", "+\t\t\t\t\t\t\t\t\tString.valueOf(conflictingImportName),", "+\t\t\t\t\t\t\t\t\tfalse,", "+\t\t\t\t\t\t\t\t\tNameLookup.ACCEPT_ALL) != null) {", "+\t\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\treturn false; // how do you match p1.p2.A.* ?", "-\t", "-\t\t\t\t} else", "-\t", "-\t\t\t\t\tif (CharOperation.equals(imports[i].readableName(), readableTypeName)) {", "-\t\t\t\t\t\treturn false;", "-\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\treturn false;"]}], "num": 70223}