{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0ac8366db991d769ea44711371af29c7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8f169c44d4d4d685da7380f28c340be2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java", "commitBeforeChange": "b8b8ddf64dedf8c9c31f5a6a372768428e737f63", "commitAfterChange": "4889f3babd91783f30bca6f07ba58254cecf87d1", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " void faultInImports()", "signatureAfterChange": " void faultInImports()", "diff": ["-\tImportBinding[] resolvedImports = new ImportBinding[numberOfImports];", "-\tresolvedImports[0] = getDefaultImports()[0];", "-\tint index = 1;", "-", "+\tthis.tempImports = new ImportBinding[numberOfImports];", "+\tthis.tempImports[0] = getDefaultImports()[0];", "+\tthis.importPtr = 1;", "+\t", "-\t\tfor (int j = 0; j < index; j++) {", "-\t\t\tImportBinding resolved = resolvedImports[j];", "+\t\tfor (int j = 0; j < this.importPtr; j++) {", "+\t\t\tImportBinding resolved = this.tempImports[j];", "-\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, true, importBinding, importReference);", "+\t\t\trecordImportBinding(new ImportBinding(compoundName, true, importBinding, importReference));", "-\t\t\tReferenceBinding conflictingType = null;", "-\t\t\tif (importBinding instanceof MethodBinding) {", "-\t\t\t\tconflictingType = (ReferenceBinding) getType(compoundName, compoundName.length);", "-\t\t\t\tif (!conflictingType.isValidBinding() || (importReference.isStatic() && !conflictingType.isStatic()))", "-\t\t\t\t\tconflictingType = null;", "-\t\t\t}", "-\t\t\t// collisions between an imported static field & a type should be checked according to spec... but currently not by javac", "-\t\t\tif (importBinding instanceof ReferenceBinding || conflictingType != null) {", "-\t\t\t\tReferenceBinding referenceBinding = conflictingType == null ? (ReferenceBinding) importBinding : conflictingType;", "-\t\t\t\tReferenceBinding typeToCheck = referenceBinding.problemId() == ProblemReasons.Ambiguous", "-\t\t\t\t\t? ((ProblemReferenceBinding) referenceBinding).closestMatch", "-\t\t\t\t\t: referenceBinding;", "-\t\t\t\tif (importReference.isTypeUseDeprecated(typeToCheck, this))", "-\t\t\t\t\tproblemReporter().deprecatedType(typeToCheck, importReference);", "-", "-\t\t\t\tReferenceBinding existingType = typesBySimpleNames.get(compoundName[compoundName.length - 1]);", "-\t\t\t\tif (existingType != null) {", "-\t\t\t\t\t// duplicate test above should have caught this case, but make sure", "-\t\t\t\t\tif (existingType == referenceBinding) {", "-\t\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=302865", "-\t\t\t\t\t\t// Check all resolved imports to see if this import qualifies as a duplicate", "-\t\t\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t\t\tif (resolved instanceof ImportConflictBinding) {", "-\t\t\t\t\t\t\t\tImportConflictBinding importConflictBinding = (ImportConflictBinding) resolved;", "-\t\t\t\t\t\t\t\tif (importConflictBinding.conflictingTypeBinding == referenceBinding) {", "-\t\t\t\t\t\t\t\t\tif (!importReference.isStatic()) {", "-\t\t\t\t\t\t\t\t\t\t// resolved is implicitly static", "-\t\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (resolved.resolvedImport == referenceBinding) {", "-\t\t\t\t\t\t\t\tif (importReference.isStatic() != resolved.isStatic()) {", "-\t\t\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\t\t\tresolvedImports[index++] = new ImportBinding(compoundName, false, importBinding, importReference);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t}", "-\t\t\t\t\t// either the type collides with a top level type or another imported type", "-\t\t\t\t\tfor (int j = 0, length = this.topLevelTypes.length; j < length; j++) {", "-\t\t\t\t\t\tif (CharOperation.equals(this.topLevelTypes[j].sourceName, existingType.sourceName)) {", "-\t\t\t\t\t\t\tproblemReporter().conflictingImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t}", "-\t\t\t\ttypesBySimpleNames.put(compoundName[compoundName.length - 1], referenceBinding);", "-\t\t\t} else if (importBinding instanceof FieldBinding) {", "-\t\t\t\tfor (int j = 0; j < index; j++) {", "-\t\t\t\t\tImportBinding resolved = resolvedImports[j];", "-\t\t\t\t\t// find other static fields with the same name", "-\t\t\t\t\tif (resolved.isStatic() && resolved.resolvedImport instanceof FieldBinding && importBinding != resolved.resolvedImport) {", "-\t\t\t\t\t\tif (CharOperation.equals(compoundName[compoundName.length - 1], resolved.compoundName[resolved.compoundName.length - 1])) {", "-\t\t\t\t\t\t\tproblemReporter().duplicateImport(importReference);", "-\t\t\t\t\t\t\tcontinue nextImport;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "+\t\t\t// all the code here which checks for valid bindings have been moved to the method ", "+\t\t\t// checkAndRecordImportBinding() since bug 361327", "+\t\t\tif(checkAndRecordImportBinding(importBinding, typesBySimpleNames, importReference, compoundName) == -1)", "+\t\t\t\tcontinue nextImport;", "+\t\t\tif (importReference.isStatic()) {", "+\t\t\t\t// look for more static bindings being imported by single static import(bug 361327).", "+\t\t\t\t// findSingleImport() finds fields first, followed by method and then type", "+\t\t\t\t// So if a type is found, no fields and methods are available anyway", "+\t\t\t\t// similarly when method is found, type may be available but no field available for sure", "+\t\t\t\tif (importBinding.kind() == Binding.FIELD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE | Binding.METHOD, importReference);\t\t", "+\t\t\t\t} else if (importBinding.kind() == Binding.METHOD) {", "+\t\t\t\t\tcheckMoreStaticBindings(compoundName, typesBySimpleNames, Binding.TYPE, importReference);", "-\t\t\tresolvedImports[index++] = conflictingType == null", "-\t\t\t\t? new ImportBinding(compoundName, false, importBinding, importReference)", "-\t\t\t\t: new ImportConflictBinding(compoundName, importBinding, conflictingType, importReference);", "-\tif (resolvedImports.length > index)", "-\t\tSystem.arraycopy(resolvedImports, 0, resolvedImports = new ImportBinding[index], 0, index);", "-\tthis.imports = resolvedImports;", "-", "+\tif (this.tempImports.length > this.importPtr)", "+\t\tSystem.arraycopy(this.tempImports, 0, this.tempImports = new ImportBinding[this.importPtr], 0, this.importPtr);", "+\tthis.imports = this.tempImports;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa3b2a3f8708197c25de46c44cd15586", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java", "commitBeforeChange": "386973a3070496c014c76dfef6b370eb80aa95d3", "commitAfterChange": "1e351d47b6a42ac5f4bfe0ec77b007aad61afe06", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "signatureAfterChange": "\r public void generateCode(ClassScope classScope, ClassFile classFile)", "diff": ["+\t\tthis.internalGenerateCode(classScope, classFile);\r", "+\t} catch (AbortMethod e) {\r", "+\t\tif (e.compilationResult == CodeStream.RESTART_IN_WIDE_MODE) {\r", "+\t\t\t// a branch target required a goto_w, restart code gen in wide mode.\r", "+\t\t\ttry {\r", "+\t\t\t\tif (statements != null) {\r", "+\t\t\t\t\tfor (int i = 0, max = statements.length; i < max; i++)\r", "+\t\t\t\t\t\tstatements[i].resetStateForCodeGeneration();\r", "+\t\t\t\t}\r", "+\t\t\t\tclassFile.contentsOffset = problemResetPC;\r", "+\t\t\t\tclassFile.methodCount--;\r", "+\t\t\t\tclassFile.codeStream.wideMode = true; // request wide mode \r", "+\t\t\t\tthis.internalGenerateCode(classScope, classFile); // restart method generation\r", "+\t\t\t} catch(AbortMethod e2) {\r", "+\t\t\t\tint problemsLength;\r", "+\t\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "+\t\t\t}\r", "+\t\t} else {\r", "+\t\t\t\tint problemsLength;\r", "+\t\t\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "+\t\t\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "+\t\t\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "+\t\t\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "+\t\t}\r", "+\t}\r", "+}\r", "-\t} catch (AbortMethod e) {\r", "-\t\tint problemsLength;\r", "-\t\tIProblem[] problems = scope.referenceCompilationUnit().compilationResult.getProblems();\r", "-\t\tIProblem[] problemsCopy = new IProblem[problemsLength = problems.length];\r", "-\t\tSystem.arraycopy(problems, 0, problemsCopy, 0, problemsLength);\r", "-\t\tclassFile.addProblemConstructor(this, binding, problemsCopy, problemResetPC);\r", "-\t}\r"]}], "num": 21195}