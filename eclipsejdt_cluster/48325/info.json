{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2c41b870fab2361e508b663962a03332", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9f9dd8be46f8706ec99bea494aa8b3f6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java", "commitBeforeChange": "991fd6e4b6634483ff414608784017adef86e93b", "commitAfterChange": "88f4789ab87b5741bd84f761926c87f3851c7700", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \tpublic void selectType(ISourceType sourceType, char[] typeName, SourceTypeElementInfo[] topLevelTypes, boolean searchInEnvironment)", "signatureAfterChange": " \tpublic void selectType(char[] typeName, IType context) throws JavaModelException", "diff": ["-\tpublic void selectType(ISourceType sourceType, char[] typeName, SourceTypeElementInfo[] topLevelTypes, boolean searchInEnvironment) {", "+\tpublic void selectType(char[] typeName, IType context) throws JavaModelException {", "-\t\t\tISourceType outerType = sourceType;", "-\t\t\tISourceType parent = sourceType.getEnclosingType();", "+\t\t\tIType outerType = context;", "+\t\t\tIType parent = context.getDeclaringType();", "-\t\t\t\tparent = parent.getEnclosingType();", "+\t\t\t\tparent = parent.getDeclaringType();", "+\t\t\t", "-\t\t\tCompilationResult result = new CompilationResult(outerType.getFileName(), 1, 1, this.compilerOptions.maxProblemsPerUnit);", "-\t\t\tif (!(sourceType instanceof SourceTypeElementInfo)) return;", "-\t\t\tSourceType typeHandle = (SourceType) ((SourceTypeElementInfo)sourceType).getHandle();", "-\t\t\tint flags = SourceTypeConverter.FIELD_AND_METHOD | SourceTypeConverter.MEMBER_TYPE;", "-\t\t\tif (typeHandle.isAnonymous() || typeHandle.isLocal()) ", "-\t\t\t\tflags |= SourceTypeConverter.LOCAL_TYPE;", "-\t\t\tCompilationUnitDeclaration parsedUnit =", "-\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "-\t\t\t\t\t\ttopLevelTypes,", "-\t\t\t\t\t\tflags,", "-\t\t\t\t\t\tthis.parser.problemReporter(), ", "-\t\t\t\t\t\tresult);", "-", "-\t\t\tif (parsedUnit != null && parsedUnit.types != null) {", "-\t\t\t\tif(DEBUG) {", "-\t\t\t\t\tSystem.out.println(\"SELECTION - Diet AST :\"); //$NON-NLS-1$", "-\t\t\t\t\tSystem.out.println(parsedUnit.toString());", "+\t\t\tCompilationUnitDeclaration parsedUnit = null;", "+\t\t\tTypeDeclaration typeDeclaration = null;", "+\t\t\torg.eclipse.jdt.core.ICompilationUnit cu = context.getCompilationUnit();", "+\t\t\tif (cu != null) {", "+\t\t\t \tIType[] topLevelTypes = cu.getTypes();", "+\t\t\t \tint length = topLevelTypes.length;", "+\t\t\t \tSourceTypeElementInfo[] topLevelInfos = new SourceTypeElementInfo[length];", "+\t\t\t \tfor (int i = 0; i < length; i++) {", "+\t\t\t\t\ttopLevelInfos[i] = (SourceTypeElementInfo) ((SourceType)topLevelTypes[i]).getElementInfo();", "-\t\t\t\t// find the type declaration that corresponds to the original source type", "-\t\t\t\tTypeDeclaration typeDecl = new ASTNodeFinder(parsedUnit).findType(typeHandle);", "-", "-\t\t\t\tif (typeDecl != null) {", "-", "-\t\t\t\t\t// add fake field with the type we're looking for", "-\t\t\t\t\t// note: since we didn't ask for fields above, there is no field defined yet", "-\t\t\t\t\tFieldDeclaration field = new FieldDeclaration();", "-\t\t\t\t\tint dot;", "-\t\t\t\t\tif ((dot = CharOperation.lastIndexOf('.', typeName)) == -1) {", "-\t\t\t\t\t\tthis.selectedIdentifier = typeName;", "-\t\t\t\t\t\tfield.type = new SelectionOnSingleTypeReference(typeName, -1);", "-\t\t\t\t\t\t// position not used", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tchar[][] previousIdentifiers = CharOperation.splitOn('.', typeName, 0, dot);", "-\t\t\t\t\t\tchar[] selectionIdentifier =", "-\t\t\t\t\t\t\tCharOperation.subarray(typeName, dot + 1, typeName.length);", "-\t\t\t\t\t\tthis.selectedIdentifier = selectionIdentifier;", "-\t\t\t\t\t\tfield.type =", "-\t\t\t\t\t\t\tnew SelectionOnQualifiedTypeReference(", "-\t\t\t\t\t\t\t\tpreviousIdentifiers,", "-\t\t\t\t\t\t\t\tselectionIdentifier,", "-\t\t\t\t\t\t\t\tnew long[previousIdentifiers.length + 1]);", "+\t\t\t\tISourceType outerTypeInfo = (ISourceType) ((SourceType) outerType).getElementInfo();", "+\t\t\t\tCompilationResult result = new CompilationResult(outerTypeInfo.getFileName(), 1, 1, this.compilerOptions.maxProblemsPerUnit);", "+\t\t\t\tint flags = SourceTypeConverter.FIELD_AND_METHOD | SourceTypeConverter.MEMBER_TYPE;", "+\t\t\t\tif (context.isAnonymous() || context.isLocal()) ", "+\t\t\t\t\tflags |= SourceTypeConverter.LOCAL_TYPE;", "+\t\t\t\tparsedUnit =", "+\t\t\t\t\tSourceTypeConverter.buildCompilationUnit(", "+\t\t\t\t\t\t\ttopLevelInfos,", "+\t\t\t\t\t\t\tflags,", "+\t\t\t\t\t\t\tthis.parser.problemReporter(), ", "+\t\t\t\t\t\t\tresult);", "+\t\t\t\tif (parsedUnit != null && parsedUnit.types != null) {", "+\t\t\t\t\tif(DEBUG) {", "+\t\t\t\t\t\tSystem.out.println(\"SELECTION - Diet AST :\"); //$NON-NLS-1$", "+\t\t\t\t\t\tSystem.out.println(parsedUnit.toString());", "-\t\t\t\t\tfield.name = \"<fakeField>\".toCharArray(); //$NON-NLS-1$", "-\t\t\t\t\ttypeDecl.fields = new FieldDeclaration[] { field };", "-", "-\t\t\t\t\t// build bindings", "-\t\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);", "-\t\t\t\t\tif ((this.unitScope = parsedUnit.scope) != null) {", "-\t\t\t\t\t\ttry {", "-\t\t\t\t\t\t\t// build fields", "-\t\t\t\t\t\t\t// note: this builds fields only in the parsed unit (the buildFieldsAndMethods flag is not passed along)", "-\t\t\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, true);", "-", "-\t\t\t\t\t\t\t// resolve", "-\t\t\t\t\t\t\tparsedUnit.scope.faultInTypes();", "-\t\t\t\t\t\t\tparsedUnit.resolve();", "-\t\t\t\t\t\t} catch (SelectionNodeFound e) {", "-\t\t\t\t\t\t\tif (e.binding != null) {", "-\t\t\t\t\t\t\t\tif(DEBUG) {", "-\t\t\t\t\t\t\t\t\tSystem.out.println(\"SELECTION - Selection binding :\"); //$NON-NLS-1$", "-\t\t\t\t\t\t\t\t\tSystem.out.println(e.binding.toString());", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t// if null then we found a problem in the selection node", "-\t\t\t\t\t\t\t\tselectFrom(e.binding, parsedUnit, e.isDeclaration);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "+\t\t\t\t\t// find the type declaration that corresponds to the original source type", "+\t\t\t\t\ttypeDeclaration = new ASTNodeFinder(parsedUnit).findType(context);", "+\t\t\t\t} ", "+\t\t\t} else { // binary type", "+\t\t\t\tClassFile classFile = (ClassFile) context.getClassFile();", "+\t\t\t\tClassFileReader reader = (ClassFileReader) classFile.getBinaryTypeInfo((IFile) classFile.getResource(), false/*don't fully initialize so as to keep constant pool (used below)*/);", "+\t\t\t\tCompilationResult result = new CompilationResult(reader.getFileName(), 1, 1, this.compilerOptions.maxProblemsPerUnit);", "+\t\t\t\tparsedUnit = new CompilationUnitDeclaration(this.parser.problemReporter(), result, 0);", "+\t\t\t\tHashSetOfCharArrayArray typeNames = new HashSetOfCharArrayArray();", "+\t\t\t\ttypeDeclaration = BinaryTypeConverter.buildTypeDeclaration(context, parsedUnit, result, typeNames);", "+\t\t\t\tparsedUnit.imports = BinaryTypeConverter.buildImports(typeNames, reader);", "-\t\t\t// only reaches here if no selection could be derived from the parsed tree", "-\t\t\t// thus use the selected source and perform a textual type search", "-\t\t\tif (!this.acceptedAnswer && searchInEnvironment) {", "-\t\t\t\tif (this.selectedIdentifier != null) {", "-\t\t\t\t\tthis.nameEnvironment.findTypes(typeName, false, false, IJavaSearchConstants.TYPE, this);", "-\t\t\t\t\t", "-\t\t\t\t\t// accept qualified types only if no unqualified type was accepted", "-\t\t\t\t\tif(!this.acceptedAnswer) {", "-\t\t\t\t\t\tacceptQualifiedTypes();", "+", "+\t\t\tif (typeDeclaration != null) {", "+", "+\t\t\t\t// add fake field with the type we're looking for", "+\t\t\t\t// note: since we didn't ask for fields above, there is no field defined yet", "+\t\t\t\tFieldDeclaration field = new FieldDeclaration();", "+\t\t\t\tint dot;", "+\t\t\t\tif ((dot = CharOperation.lastIndexOf('.', typeName)) == -1) {", "+\t\t\t\t\tthis.selectedIdentifier = typeName;", "+\t\t\t\t\tfield.type = new SelectionOnSingleTypeReference(typeName, -1);", "+\t\t\t\t\t// position not used", "+\t\t\t\t} else {", "+\t\t\t\t\tchar[][] previousIdentifiers = CharOperation.splitOn('.', typeName, 0, dot);", "+\t\t\t\t\tchar[] selectionIdentifier =", "+\t\t\t\t\t\tCharOperation.subarray(typeName, dot + 1, typeName.length);", "+\t\t\t\t\tthis.selectedIdentifier = selectionIdentifier;", "+\t\t\t\t\tfield.type =", "+\t\t\t\t\t\tnew SelectionOnQualifiedTypeReference(", "+\t\t\t\t\t\t\tpreviousIdentifiers,", "+\t\t\t\t\t\t\tselectionIdentifier,", "+\t\t\t\t\t\t\tnew long[previousIdentifiers.length + 1]);", "+\t\t\t\t}", "+\t\t\t\tfield.name = \"<fakeField>\".toCharArray(); //$NON-NLS-1$", "+\t\t\t\ttypeDeclaration.fields = new FieldDeclaration[] { field };", "+", "+\t\t\t\t// build bindings", "+\t\t\t\tthis.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);", "+\t\t\t\tif ((this.unitScope = parsedUnit.scope) != null) {", "+\t\t\t\t\ttry {", "+\t\t\t\t\t\t// build fields", "+\t\t\t\t\t\t// note: this builds fields only in the parsed unit (the buildFieldsAndMethods flag is not passed along)", "+\t\t\t\t\t\tthis.lookupEnvironment.completeTypeBindings(parsedUnit, true);", "+", "+\t\t\t\t\t\t// resolve", "+\t\t\t\t\t\tparsedUnit.scope.faultInTypes();", "+\t\t\t\t\t\tparsedUnit.resolve();", "+\t\t\t\t\t} catch (SelectionNodeFound e) {", "+\t\t\t\t\t\tif (e.binding != null) {", "+\t\t\t\t\t\t\tif(DEBUG) {", "+\t\t\t\t\t\t\t\tSystem.out.println(\"SELECTION - Selection binding :\"); //$NON-NLS-1$", "+\t\t\t\t\t\t\t\tSystem.out.println(e.binding.toString());", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t// if null then we found a problem in the selection node", "+\t\t\t\t\t\t\tselectFrom(e.binding, parsedUnit, e.isDeclaration);", "+\t\t\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0554975ea53c1b592176c7763a9ee64", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java", "commitBeforeChange": "fe905e29a608f61f2afe181f4c1e4e27bb2b95dc", "commitAfterChange": "53a7cfa9bf2a3a1ade921d716dbdc58a4bfc35d4", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws JavaModelException", "diff": ["-\t\t\tStringBuffer sourceFileName = new StringBuffer(elementName.substring(0, elementName.lastIndexOf('.')));", "-\t\t\tsourceFileName.append(SuffixConstants.SUFFIX_java);", "+\t\t\tString sourceFileWithoutExtension = elementName.substring(0, elementName.lastIndexOf('.'));", "-\t\t\t\tPackageFragment packageFragment = (PackageFragment) getParent();", "-\t\t\t\tZipEntry zipEntry = jar.getEntry(Util.concatWith(packageFragment.names, sourceFileName.toString(), '/'));", "-\t\t\t\tif (zipEntry != null) {", "-\t\t\t\t\t// found a source file", "-\t\t\t\t\tthis.checkAutomaticSourceMapping = true;", "-\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "-\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "-\t\t\t\t\tif (sourceMapper != null) {", "-\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\tString[] pkgName = ((PackageFragment) getParent()).names;", "+\t\t\t\tfor (int i = 0, length = Util.JAVA_LIKE_EXTENSIONS.length; i < length; i++) {", "+\t\t\t\t\tStringBuffer entryName = new StringBuffer();", "+\t\t\t\t\tfor (int j = 0, pkgNameLength = pkgName.length; j < pkgNameLength; j++) {", "+\t\t\t\t\t\tentryName.append(pkgName[j]);", "+\t\t\t\t\t\tentryName.append('/');", "+\t\t\t\t\t}", "+\t\t\t\t\tentryName.append(sourceFileWithoutExtension);", "+\t\t\t\t\tentryName.append(Util.JAVA_LIKE_EXTENSIONS[i]);", "+\t\t\t\t\tZipEntry zipEntry = jar.getEntry(entryName.toString());", "+\t\t\t\t\tif (zipEntry != null) {", "+\t\t\t\t\t\t// found a source file", "+\t\t\t\t\t\tthis.checkAutomaticSourceMapping = true;", "+\t\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "+\t\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "+\t\t\t\t\t\tif (sourceMapper != null) {", "+\t\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\t\t\t}", "-\t\t\t\tIPath sourceFilePath = getPath().removeFileExtension().addFileExtension(EXTENSION_java);", "-\t\t\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "-\t\t\t\tif (workspace == null) {", "-\t\t\t\t\tthis.checkAutomaticSourceMapping = true; // we don't want to check again", "-\t\t\t\t\treturn null; // workaround for http://bugs.eclipse.org/bugs/show_bug.cgi?id=34069", "+\t\t\t\t", "+\t\t\t\tIFolder pkgFolder = (IFolder) getParent().getResource();", "+\t\t\t\tIResource[] files = null;", "+\t\t\t\ttry {", "+\t\t\t\t\tfiles = pkgFolder.members();", "+\t\t\t\t} catch (CoreException e) {", "+\t\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t\tif (JavaModel.getTarget(", "-\t\t\t\t\t\tworkspace.getRoot(),", "-\t\t\t\t\t\tsourceFilePath.makeRelative(), // ensure path is relative (see http://dev.eclipse.org/bugs/show_bug.cgi?id=22517)", "-\t\t\t\t\t\ttrue) != null) {", "+\t\t\t\tIResource sourceFile = null;", "+\t\t\t\tString classFileName = getElementName();", "+\t\t\t\tString simpleName = classFileName.substring(0, classFileName.lastIndexOf('.'));", "+\t\t\t\tfor (int i = 0, length = files.length; i < length; i++) {", "+\t\t\t\t\tIResource resource = files[i];", "+\t\t\t\t\tif (resource.getType() == IResource.FILE ", "+\t\t\t\t\t\t\t&& Util.equalsIgnoreJavaLikeExtension(resource.getName(), simpleName)) {", "+\t\t\t\t\t\tsourceFile = resource;", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tif (sourceFile != null) {"]}], "num": 48325}