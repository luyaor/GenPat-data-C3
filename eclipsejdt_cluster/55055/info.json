{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "e82852b1eb9a95eb1b37dedbc31a6195", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "42145bcf3fc9efea6662634100b65eae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java", "commitBeforeChange": "8d86c45b7dbc1d8316194b358e7234e4491fa695", "commitAfterChange": "0305482ace5c5443f44c914a225574b12096815b", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "signatureAfterChange": "\t \tpublic static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite)", "diff": ["-\t\t\tsubstitutes = new TypeBinding[varLength];", "-\t\t\tfor (int i = 0; i < varLength; i++) {", "-\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) collectedSubstitutes.get(typeVariables[i]);", "-\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "-\t\t\t\t//TypeBinding mostSpecificSubstitute = scope.mostSpecificCommonType(variableSubstitutes);", "-\t\t\t\tif (mostSpecificSubstitute == null)", "-\t\t\t\t\treturn null; // incompatible", "-\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "-\t\t\t\t\tneedReturnTypeInference = true;", "-\t\t\t\t    mostSpecificSubstitute = typeVariables[i];", "+\t\t\tif (collectedSubstitutes.isEmpty()) {", "+\t\t\t\t// raw generic method inferred", "+\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, (RawTypeBinding)null, scope.environment());", "+\t\t\t} else {", "+\t\t\t\tsubstitutes = new TypeBinding[varLength];", "+\t\t\t\tfor (int i = 0; i < varLength; i++) {", "+\t\t\t\t\tTypeBinding[] variableSubstitutes = (TypeBinding[]) collectedSubstitutes.get(typeVariables[i]);", "+\t\t\t\t\tTypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);", "+\t\t\t\t\tif (mostSpecificSubstitute == null)", "+\t\t\t\t\t\treturn null; // incompatible", "+\t\t\t\t\tif (mostSpecificSubstitute == VoidBinding) {", "+\t\t\t\t\t\tneedReturnTypeInference = true;", "+\t\t\t\t\t    mostSpecificSubstitute = typeVariables[i];", "+\t\t\t\t\t}\t\t\t\t", "+\t\t\t\t\tsubstitutes[i] = mostSpecificSubstitute;", "-\t\t\t\tsubstitutes[i] = mostSpecificSubstitute;", "+\t\t\t\t// apply inferred variable substitutions", "+\t\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t\t// apply inferred variable substitutions", "-\t\t\tmethodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());", "-\t\t\t\tif (expectedType != null)", "-\t\t\t\t\tmethodSubstitute.inferFromExpectedType(message.expectedType, scope);", "+\t\t\t\tmethodSubstitute.inferFromExpectedType(", "+\t\t\t\t\t\t// 15.12.2.8 - if no expected type, then assume Object", "+\t\t\t\t\t\texpectedType == null ? scope.getJavaLangObject() : expectedType, ", "+\t\t\t\t\t\tscope);", "-\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "-\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "-\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitutes[i]))", "-\t\t        // incompatible due to bound check", "-\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitutes[i], typeVariables[i] }, ParameterBoundMismatch);", "+\t\tif (!methodSubstitute.isRaw) {", "+\t\t\tfor (int i = 0, length = typeVariables.length; i < length; i++) {", "+\t\t\t    TypeVariableBinding typeVariable = typeVariables[i];", "+\t\t\t    TypeBinding substitute = substitutes[i];", "+\t\t\t    if (!typeVariable.boundCheck(methodSubstitute, substitute))", "+\t\t\t        // incompatible due to bound check", "+\t\t\t        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitutes[i], typeVariables[i] }, ParameterBoundMismatch);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "bc5500cc1ed283b8a363d5bb69a8c725", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/newbuilder/IncrementalImageBuilder.java", "commitBeforeChange": "79c96bc51135904745e51a2c90ed269611b0cb4a", "commitAfterChange": "ceb521e070d662becc4ec3ee749b1a95a26cea96", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "\r \r protected void finishedWith(String sourceLocation, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException", "signatureAfterChange": "\r \r protected void finishedWith(String sourceLocation, CompilationResult result, char[] mainTypeName, ArrayList definedTypeNames, ArrayList duplicateTypeNames) throws CoreException", "diff": ["-\tIPath packagePath = null;\r", "-\tnext : for (int i = 0, x = previousTypeNames.length; i < x; i++) {\r", "-\t\tchar[] previous = previousTypeNames[i];\r", "-\t\tfor (int j = 0, y = definedTypeNames.size(); j < y; j++)\r", "-\t\t\tif (CharOperation.equals(previous, (char[]) definedTypeNames.get(j)))\r", "-\t\t\t\tcontinue next;\r", "-\r", "-\t\tif (packagePath == null)\r", "-\t\t\tpackagePath = new Path(extractTypeNameFrom(sourceLocation)).removeLastSegments(1);\r", "-\t\tremoveClassFile(packagePath.append(new String(previous)));\r", "+\tif (previousTypeNames.length > 0) {\r", "+\t\tIPath packagePath = null;\r", "+\t\tnext : for (int i = 0, x = previousTypeNames.length; i < x; i++) {\r", "+\t\t\tchar[] previous = previousTypeNames[i];\r", "+\t\t\tfor (int j = 0, y = definedTypeNames.size(); j < y; j++)\r", "+\t\t\t\tif (CharOperation.equals(previous, (char[]) definedTypeNames.get(j)))\r", "+\t\t\t\t\tcontinue next;\r", "+\t\r", "+\t\t\tif (packagePath == null)\r", "+\t\t\t\tpackagePath = new Path(extractTypeNameFrom(sourceLocation)).removeLastSegments(1);\r", "+\t\t\tremoveClassFile(packagePath.append(new String(previous)));\r", "+\t\t}\r", "+\t} else if (!definedTypeNames.isEmpty()) { // added a type to an empty file\r", "+\t\tIPath typePath = new Path(extractTypeNameFrom(sourceLocation));\r", "+\t\tif (JavaBuilder.DEBUG)\r", "+\t\t\tSystem.out.println(\"Add dependents of changed empty source file \" + typePath); //$NON-NLS-1$\r", "+\t\taddDependentsOf(typePath, true);\r"]}], "num": 55055}