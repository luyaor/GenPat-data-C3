{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cfce7cfdb6fb5f6362e5162a62b297e1", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36d60e1d0b3bac94604ed709b9eb4f08", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java", "commitBeforeChange": "ba0154713ba7d434aa2e47b80fd55a84048c10dc", "commitAfterChange": "c691caa0dc4c5d86bd6e9b8bfd831e689219e521", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 0, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "signatureAfterChange": "  \tpublic FlowInfo analyseCode( \t\tBlockScope currentScope, \t\tFlowContext flowContext, \t\tFlowInfo flowInfo)", "diff": ["-\t\tInsideSubRoutineFlowContext insideSubContext;", "-\t\tFinallyFlowContext finallyContext;", "-\t\tUnconditionalFlowInfo subInfo;", "-\t\t\t// no finally block", "-\t\t\tinsideSubContext = null;", "-\t\t\tfinallyContext = null;", "-\t\t\tsubInfo = null;", "+\t\t\t// no finally block -- this is a simplified copy of the else part", "+\t\t\t// process the try block in a context handling the local exceptions.", "+\t\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\t\tflowContext,", "+\t\t\t\t\tthis.tryBlock,", "+\t\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\t\tthis.scope,", "+\t\t\t\t\tflowInfo.unconditionalInits());", "+\t", "+\t\t\tFlowInfo tryInfo;", "+\t\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\t\ttryInfo = flowInfo;", "+\t\t\t\tthis.tryBlockExit = false;", "+\t\t\t} else {", "+\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t}", "+\t", "+\t\t\t// check unreachable catch blocks", "+\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+\t", "+\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\t\tif (this.catchArguments != null) {", "+\t\t\t\tint catchCount;", "+\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+\t", "+\t\t\t\t\t// catch var is always set", "+\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t\t/*", "+\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t\t}", "+\t\t\t\t\tcatchInfo =", "+\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tflowContext,", "+\t\t\t\t\t\t\tcatchInfo);", "+\t\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "+\t\t\treturn tryInfo;", "+\t\t\tInsideSubRoutineFlowContext insideSubContext;", "+\t\t\tFinallyFlowContext finallyContext;", "+\t\t\tUnconditionalFlowInfo subInfo;", "-\t\t}", "-\t\t// process the try block in a context handling the local exceptions.", "-\t\tExceptionHandlingFlowContext handlingContext =", "-\t\t\tnew ExceptionHandlingFlowContext(", "-\t\t\t\tinsideSubContext == null ? flowContext : insideSubContext,", "-\t\t\t\tthis.tryBlock,", "-\t\t\t\tthis.caughtExceptionTypes,", "-\t\t\t\tthis.scope,", "-\t\t\t\tflowInfo.unconditionalInits());", "-", "-\t\tFlowInfo tryInfo;", "-\t\tif (this.tryBlock.isEmptyBlock()) {", "-\t\t\ttryInfo = flowInfo;", "-\t\t\tthis.tryBlockExit = false;", "-\t\t} else {", "-\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "-\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t}", "-", "-\t\t// check unreachable catch blocks", "-\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "-", "-\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "-\t\tif (this.catchArguments != null) {", "-\t\t\tint catchCount;", "-\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "-\t\t\tfor (int i = 0; i < catchCount; i++) {", "-\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "-\t\t\t\tFlowInfo catchInfo =", "-\t\t\t\t\tflowInfo.unconditionalCopy().", "-\t\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnException(", "-\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "-\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "-\t\t\t\t\t\t\t// remove null info to protect point of ", "-\t\t\t\t\t\t\t// exception null info ", "-\t\t\t\t\t\t.addPotentialInitializationsFrom(", "-\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "-\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "-", "-\t\t\t\t// catch var is always set", "-\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "-\t\t\t\tFlowContext catchContext = insideSubContext == null ? flowContext : insideSubContext;", "-\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "-\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "-\t\t\t\t/*", "-\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "-\t\t\t\tthe try block that need to be detected , e.g. ", "-\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "-\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "-\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "-\t\t\t\t*/", "-\t\t\t\tif (this.tryBlock.statements == null) {", "-\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t\t\t}", "-\t\t\t\tcatchInfo =", "-\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "-\t\t\t\t\t\tcurrentScope,", "-\t\t\t\t\t\tcatchContext,", "-\t\t\t\t\t\tcatchInfo);", "-\t\t\t\tthis.catchExits[i] = ", "-\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t// process the try block in a context handling the local exceptions.", "+\t\t\tExceptionHandlingFlowContext handlingContext =", "+\t\t\t\tnew ExceptionHandlingFlowContext(", "+\t\t\t\t\tinsideSubContext,", "+\t\t\t\t\tthis.tryBlock,", "+\t\t\t\t\tthis.caughtExceptionTypes,", "+\t\t\t\t\tthis.scope,", "+\t\t\t\t\tflowInfo.unconditionalInits());", "+\t", "+\t\t\tFlowInfo tryInfo;", "+\t\t\tif (this.tryBlock.isEmptyBlock()) {", "+\t\t\t\ttryInfo = flowInfo;", "+\t\t\t\tthis.tryBlockExit = false;", "+\t\t\t} else {", "+\t\t\t\ttryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());", "+\t\t\t\tthis.tryBlockExit = (tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "-\t\t}", "-\t\tif (this.subRoutineStartLabel == null) {", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(tryInfo);", "-\t\t\treturn tryInfo;", "-\t\t}", "-", "-", "-\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "-\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "-\t\tfinallyContext/* NN null with subRoutineStartLabel, which returns */.complainOnDeferredChecks( ", "-\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "-\t\t\t\t? flowInfo.unconditionalCopy().", "-\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "-\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "-\t\t\t\t\t\t// exited at any point", "-\t\t\t\t\taddPotentialInitializationsFrom(", "-\t\t\t\t\t\tinsideSubContext/* NN null with subRoutineStartLabel, which returns */.", "-\t\t\t\t\t\t\tinitsOnReturn)", "-\t\t\t\t: insideSubContext.initsOnReturn,", "-\t\t\tcurrentScope);", "-\t\tif (subInfo == FlowInfo.DEAD_END) {", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "-\t\t\treturn subInfo;", "-\t\t} else {", "-\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "-\t\t\tthis.mergedInitStateIndex =", "-\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\t\treturn mergedInfo;", "+\t", "+\t\t\t// check unreachable catch blocks", "+\t\t\thandlingContext.complainIfUnusedExceptionHandlers(this.scope, this);", "+\t", "+\t\t\t// process the catch blocks - computing the minimal exit depth amongst try/catch", "+\t\t\tif (this.catchArguments != null) {", "+\t\t\t\tint catchCount;", "+\t\t\t\tthis.catchExits = new boolean[catchCount = this.catchBlocks.length];", "+\t\t\t\tfor (int i = 0; i < catchCount; i++) {", "+\t\t\t\t\t// keep track of the inits that could potentially have led to this exception handler (for final assignments diagnosis)", "+\t\t\t\t\tFlowInfo catchInfo =", "+\t\t\t\t\t\tflowInfo.unconditionalCopy().", "+\t\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnException(", "+\t\t\t\t\t\t\t\t\tthis.caughtExceptionTypes[i]))", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\ttryInfo.nullInfoLessUnconditionalCopy())", "+\t\t\t\t\t\t\t\t// remove null info to protect point of ", "+\t\t\t\t\t\t\t\t// exception null info ", "+\t\t\t\t\t\t\t.addPotentialInitializationsFrom(", "+\t\t\t\t\t\t\t\thandlingContext.initsOnReturn.", "+\t\t\t\t\t\t\t\t\tnullInfoLessUnconditionalCopy());", "+\t", "+\t\t\t\t\t// catch var is always set", "+\t\t\t\t\tLocalVariableBinding catchArg = this.catchArguments[i].binding;", "+\t\t\t\t\tcatchInfo.markAsDefinitelyAssigned(catchArg);", "+\t\t\t\t\tcatchInfo.markAsDefinitelyNonNull(catchArg);", "+\t\t\t\t\t/*", "+\t\t\t\t\t\"If we are about to consider an unchecked exception handler, potential inits may have occured inside", "+\t\t\t\t\tthe try block that need to be detected , e.g. ", "+\t\t\t\t\ttry { x = 1; throwSomething();} catch(Exception e){ x = 2} \"", "+\t\t\t\t\t\"(uncheckedExceptionTypes notNil and: [uncheckedExceptionTypes at: index])", "+\t\t\t\t\tifTrue: [catchInits addPotentialInitializationsFrom: tryInits].\"", "+\t\t\t\t\t*/", "+\t\t\t\t\tif (this.tryBlock.statements == null) {", "+\t\t\t\t\t\tcatchInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\t\t\t\t\t}", "+\t\t\t\t\tcatchInfo =", "+\t\t\t\t\t\tthis.catchBlocks[i].analyseCode(", "+\t\t\t\t\t\t\tcurrentScope,", "+\t\t\t\t\t\t\tinsideSubContext,", "+\t\t\t\t\t\t\tcatchInfo);", "+\t\t\t\t\tthis.catchExits[i] = ", "+\t\t\t\t\t\t(catchInfo.tagBits & FlowInfo.UNREACHABLE) != 0;", "+\t\t\t\t\ttryInfo = tryInfo.mergedWith(catchInfo.unconditionalInits());", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// we also need to check potential multiple assignments of final variables inside the finally block", "+\t\t\t// need to include potential inits from returns inside the try/catch parts - 1GK2AOF", "+\t\t\tfinallyContext.complainOnDeferredChecks( ", "+\t\t\t\t(tryInfo.tagBits & FlowInfo.UNREACHABLE) == 0 ", "+\t\t\t\t\t? flowInfo.unconditionalCopy().", "+\t\t\t\t\t\taddPotentialInitializationsFrom(tryInfo).", "+\t\t\t\t\t\t\t// lighten the influence of the try block, which may have ", "+\t\t\t\t\t\t\t// exited at any point", "+\t\t\t\t\t\taddPotentialInitializationsFrom(", "+\t\t\t\t\t\t\tinsideSubContext.initsOnReturn)", "+\t\t\t\t\t: insideSubContext.initsOnReturn,", "+\t\t\t\tcurrentScope);", "+\t\t\t", "+\t\t\tif (subInfo == FlowInfo.DEAD_END) {", "+\t\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(subInfo);", "+\t\t\t\treturn subInfo;", "+\t\t\t} else {", "+\t\t\t\tFlowInfo mergedInfo = tryInfo.addInitializationsFrom(subInfo);", "+\t\t\t\tthis.mergedInitStateIndex =", "+\t\t\t\t\tcurrentScope.methodScope().recordInitializationStates(mergedInfo);", "+\t\t\t\treturn mergedInfo;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "71bfbe2b474ff1fa4757747218974727", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java", "commitBeforeChange": "849bead878c9a40a476fb6736e2c949015040926", "commitAfterChange": "ffce987f3a5cbc5edb4057595c44a9095dbf9c81", "methodNumberBeforeChange": 118, "methodNumberAfterChange": 118, "signatureBeforeChange": " \tpublic boolean visit(UnaryExpression unaryExpression, BlockScope scope)", "signatureAfterChange": " \tpublic boolean visit( \t\t\tParameterizedSingleTypeReference parameterizedSingleTypeReference, \t\t\tClassScope scope)", "diff": ["+\t}", "+\tpublic boolean visit(", "+\t\t\tParameterizedSingleTypeReference parameterizedSingleTypeReference,", "+\t\t\tClassScope scope) {", "+\t\tfinal int numberOfParens = (parameterizedSingleTypeReference.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageOpeningParenthesizedExpression(parameterizedSingleTypeReference, numberOfParens);", "+\t\t}", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameIdentifier);", "+", "+\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLESS, this.preferences.insert_space_before_opening_angle_bracket_in_parameterized_type_reference);", "+\t\tif (this.preferences.insert_space_after_opening_angle_bracket_in_parameterized_type_reference) {", "+\t\t\tthis.scribe.space();", "+\t\t}", "+\t\tTypeReference[] typeArguments = parameterizedSingleTypeReference.typeArguments;", "+\t\tint typeArgumentsLength = typeArguments.length;", "+\t\tfor (int i = 0; i < typeArgumentsLength - 1; i++) {", "+\t\t\ttypeArguments[i].traverse(this, scope);", "+\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_parameterized_type_reference);", "+\t\t\tif (this.preferences.insert_space_after_comma_in_parameterized_type_reference) {", "+\t\t\t\tthis.scribe.space();", "+\t\t\t}\t\t\t", "+\t\t}", "+\t\ttypeArguments[typeArgumentsLength - 1].traverse(this, scope);", "+\t\tif (isClosingGenericToken()) {", "+\t\t\tthis.scribe.printNextToken(CLOSING_GENERICS_EXPECTEDTOKENS, this.preferences.insert_space_before_closing_angle_bracket_in_parameterized_type_reference);", "+\t\t}", "+\t\tint dimensions = parameterizedSingleTypeReference.dimensions;", "+\t\tif (dimensions != 0) {", "+\t\t\tif (this.preferences.insert_space_before_opening_bracket_in_array_type_reference) {", "+\t\t\t\tthis.scribe.space();", "+\t\t\t}", "+\t\t\tfor (int i = 0; i < dimensions; i++) {", "+\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameLBRACKET);", "+\t\t\t\tif (this.preferences.insert_space_between_brackets_in_array_type_reference) {", "+\t\t\t\t\tthis.scribe.space();", "+\t\t\t\t}", "+\t\t\t\tthis.scribe.printNextToken(TerminalTokens.TokenNameRBRACKET);", "+\t\t\t}", "+\t\t}\t\t", "+\t\tif (numberOfParens > 0) {", "+\t\t\tmanageClosingParenthesizedExpression(parameterizedSingleTypeReference, numberOfParens);", "+\t\t}", "+\t\treturn false;"]}], "num": 7603}