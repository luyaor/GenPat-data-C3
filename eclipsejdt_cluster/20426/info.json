{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "46816616e1abee058f9c4e625f62c9ff", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36a4a36597eb843ab39ad14720029cc0", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "525a704f8fa6ccfd1b3f6df971478bd49aca39bd", "commitAfterChange": "6c4f830be0186c105d833a31f2a24dac2f9ecb1d", "methodNumberBeforeChange": 52, "methodNumberAfterChange": 52, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "diff": ["-\t\tPackageBinding currentPackage = unitScope.fPackage; ", "+\t\tHashtableOfObject typeOrPackageCache = unitScope.typeOrPackageCache;", "+\t\tif (typeOrPackageCache != null) {", "+\t\t\tBinding binding = (Binding) typeOrPackageCache.get(name);", "+\t\t\tif (binding != null) { // can also include NotFound ProblemReferenceBindings if we already know this name is not found", "+\t\t\t\tif (binding instanceof ImportBinding) { // single type import cached in faultInImports(), replace it in the cache with the type", "+\t\t\t\t\tImportReference importReference = ((ImportBinding) binding).reference;", "+\t\t\t\t\tif (importReference != null) importReference.used = true;", "+\t\t\t\t\ttypeOrPackageCache.put(name, binding = ((ImportBinding) binding).resolvedImport); // already know its visible", "+\t\t\t\t}", "+\t\t\t\tif (foundType != null && binding.problemId() != Ambiguous)", "+\t\t\t\t\treturn foundType; // problem type from above supercedes NotFound type but not Ambiguous import case", "+\t\t\t\treturn binding; // cached type or package found in previous walk below", "+\t\t\t}", "+\t\t}", "+", "-\t\t\t// check single type imports.", "-", "-\t\t\tif (imports != null) {", "-\t\t\t\tHashtableOfObject typeImports = unitScope.resolvedSingeTypeImports;", "-\t\t\t\tif (typeImports != null) {", "-\t\t\t\t\tObject typeImport = typeImports.get(name);", "-\t\t\t\t\tif (typeImport != null) {", "-\t\t\t\t\t\tif (typeImport instanceof ReferenceBinding)", "-\t\t\t\t\t\t\treturn (ReferenceBinding) typeImport; // cached from on-demand search below", "-\t\t\t\t\t\tImportReference importReference = ((ImportBinding) typeImport).reference;", "-\t\t\t\t\t\tif (importReference != null) importReference.used = true;", "-\t\t\t\t\t\treturn ((ImportBinding) typeImport).resolvedImport; // already know its visible", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\t// walk all the imports since resolvedSingleTypeImports is not yet initialized", "-\t\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "-\t\t\t\t\t\tImportBinding typeImport = imports[i];", "-\t\t\t\t\t\tif (!typeImport.onDemand) {", "-\t\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "-\t\t\t\t\t\t\t\tBinding resolvedImport = unitScope.resolveSingleImport(typeImport);", "-\t\t\t\t\t\t\t\tif (resolvedImport != null && resolvedImport instanceof TypeBinding) {", "-\t\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "-\t\t\t\t\t\t\t\t\tif (importReference != null)", "-\t\t\t\t\t\t\t\t\t\timportReference.used = true;", "-\t\t\t\t\t\t\t\t\treturn resolvedImport; // already know its visible", "-\t\t\t\t\t\t\t\t}", "+\t\t\tif (imports != null && typeOrPackageCache == null) { // walk single type imports since faultInImports() has not run yet", "+\t\t\t\tfor (int i = 0, length = imports.length; i < length; i++) {", "+\t\t\t\t\tImportBinding typeImport = imports[i];", "+\t\t\t\t\tif (!typeImport.onDemand) {", "+\t\t\t\t\t\tif (CharOperation.equals(typeImport.compoundName[typeImport.compoundName.length - 1], name)) {", "+\t\t\t\t\t\t\tBinding resolvedImport = unitScope.resolveSingleImport(typeImport);", "+\t\t\t\t\t\t\tif (resolvedImport != null && resolvedImport instanceof TypeBinding) {", "+\t\t\t\t\t\t\t\tImportReference importReference = typeImport.reference;", "+\t\t\t\t\t\t\t\tif (importReference != null)", "+\t\t\t\t\t\t\t\t\timportReference.used = true;", "+\t\t\t\t\t\t\t\treturn resolvedImport; // already know its visible", "+", "+\t\t\tPackageBinding currentPackage = unitScope.fPackage; ", "-\t\t\tif (binding instanceof ReferenceBinding) return binding; // type is always visible to its own package", "+\t\t\tif (binding instanceof ReferenceBinding) {", "+\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\ttypeOrPackageCache.put(name, binding);", "+\t\t\t\treturn binding; // type is always visible to its own package", "+\t\t\t}", "-\t\t\t\t\t\t\t\tif (foundInImport)", "+\t\t\t\t\t\t\t\tif (foundInImport) {", "-\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, Ambiguous);", "+\t\t\t\t\t\t\t\t\ttemp = new ProblemReferenceBinding(name, Ambiguous);", "+\t\t\t\t\t\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\t\t\t\t\t\ttypeOrPackageCache.put(name, temp);", "+\t\t\t\t\t\t\t\t\treturn temp;", "+\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t// put in single import cache so we can avoid doing on demand walk again", "-\t\t\t\t\tif (unitScope.resolvedSingeTypeImports != null)", "-\t\t\t\t\t\tunitScope.resolvedSingeTypeImports.put(name, type);", "+\t\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, type);", "-\t\t\tif (packageBinding != null) return packageBinding;", "+\t\t\tif (packageBinding != null) {", "+\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\ttypeOrPackageCache.put(name, packageBinding);", "+\t\t\t\treturn packageBinding;", "+\t\t\t}", "-\t\tif (foundType != null) return foundType; // problem type from above", "-\t\treturn new ProblemReferenceBinding(name, NotFound);", "+\t\tif (foundType == null) {", "+\t\t\tfoundType = new ProblemReferenceBinding(name, NotFound);", "+\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\ttypeOrPackageCache.put(name, foundType);", "+\t\t}", "+\t\treturn foundType;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f096f31f7929b0eb9b8007a8c67debc3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 55, "methodNumberAfterChange": 55, "signatureBeforeChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask)", "signatureAfterChange": " \tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve)", "diff": ["-\tfinal Binding getTypeOrPackage(char[] name, int mask) {", "+\tfinal Binding getTypeOrPackage(char[] name, int mask, boolean needResolve) {", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, memberType, ProblemReasons.NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, memberType, ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, typeVariable, ProblemReasons.NonStaticReferenceInStaticContext);", "+\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, typeVariable, ProblemReasons.NonStaticReferenceInStaticContext);", "-\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(name, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "+\t\t\t\t\t\t\t\treturn new ProblemReferenceBinding(new char[][]{name}, foundType, ProblemReasons.InheritedNameHidesEnclosingName);", "-\t\t\tBinding binding = (Binding) typeOrPackageCache.get(name);", "-\t\t\tif (binding != null) { // can also include NotFound ProblemReferenceBindings if we already know this name is not found", "-\t\t\t\tif (binding instanceof ImportBinding) { // single type import cached in faultInImports(), replace it in the cache with the type", "-\t\t\t\t\tImportReference importReference = ((ImportBinding) binding).reference;", "+\t\t\tBinding cachedBinding = (Binding) typeOrPackageCache.get(name);", "+\t\t\tif (cachedBinding != null) { // can also include NotFound ProblemReferenceBindings if we already know this name is not found", "+\t\t\t\tif (cachedBinding instanceof ImportBinding) { // single type import cached in faultInImports(), replace it in the cache with the type", "+\t\t\t\t\tImportReference importReference = ((ImportBinding) cachedBinding).reference;", "-\t\t\t\t\tif (binding instanceof ImportConflictBinding)", "-\t\t\t\t\t\ttypeOrPackageCache.put(name, binding = ((ImportConflictBinding) binding).conflictingTypeBinding); // already know its visible", "+\t\t\t\t\tif (cachedBinding instanceof ImportConflictBinding)", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, cachedBinding = ((ImportConflictBinding) cachedBinding).conflictingTypeBinding); // already know its visible", "-\t\t\t\t\t\ttypeOrPackageCache.put(name, binding = ((ImportBinding) binding).resolvedImport); // already know its visible", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, cachedBinding = ((ImportBinding) cachedBinding).resolvedImport); // already know its visible", "-\t\t\t\t\tif (foundType != null && foundType.problemId() != ProblemReasons.NotVisible && binding.problemId() != ProblemReasons.Ambiguous)", "+\t\t\t\t\tif (foundType != null && foundType.problemId() != ProblemReasons.NotVisible && cachedBinding.problemId() != ProblemReasons.Ambiguous)", "-\t\t\t\t\tif (binding instanceof ReferenceBinding)", "-\t\t\t\t\t\treturn binding; // cached type found in previous walk below", "+\t\t\t\t\tif (cachedBinding instanceof ReferenceBinding)", "+\t\t\t\t\t\treturn cachedBinding; // cached type found in previous walk below", "-\t\t\t\tif ((mask & Binding.PACKAGE) != 0 && binding instanceof PackageBinding)", "-\t\t\t\t\treturn binding; // cached package found in previous walk below", "+\t\t\t\tif ((mask & Binding.PACKAGE) != 0 && cachedBinding instanceof PackageBinding)", "+\t\t\t\t\treturn cachedBinding; // cached package found in previous walk below", "-\t\t\t\tif (typeOrPackageCache != null)", "-\t\t\t\t\ttypeOrPackageCache.put(name, binding);", "-\t\t\t\treturn binding; // type is always visible to its own package", "+\t\t\t\tReferenceBinding referenceType = (ReferenceBinding) binding;", "+\t\t\t\tif ((referenceType.tagBits & TagBits.HasMissingType) == 0) {", "+\t\t\t\t\tif (typeOrPackageCache != null)", "+\t\t\t\t\t\ttypeOrPackageCache.put(name, referenceType);", "+\t\t\t\t\treturn referenceType; // type is always visible to its own package", "+\t\t\t\t}", "-\t\t\t\t\t\t\t\t\ttemp = new ProblemReferenceBinding(name, type, ProblemReasons.Ambiguous);", "+\t\t\t\t\t\t\t\t\ttemp = new ProblemReferenceBinding(new char[][]{name}, type, ProblemReasons.Ambiguous);", "-\t\t\tfoundType = new ProblemReferenceBinding(name, null, ProblemReasons.NotFound);", "+\t\t\tchar[][] qName = new char[][] { name };", "+\t\t\tReferenceBinding closestMatch = null;", "+\t\t\tif ((mask & Binding.PACKAGE) != 0 || unitScope.environment.getTopLevelPackage(name) == null) {", "+\t\t\t\tif (needResolve) {", "+\t\t\t\t\tclosestMatch = environment().createMissingType(unitScope.fPackage, qName);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\tfoundType = new ProblemReferenceBinding(qName, closestMatch, ProblemReasons.NotFound);", "+\t\t\tif (typeOrPackageCache != null && (mask & Binding.PACKAGE) != 0) { // only put NotFound type in cache if you know its not a package", "+\t\t\t\ttypeOrPackageCache.put(name, foundType);", "+\t\t\t}", "+\t\t} else if ((foundType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\tchar[][] qName = new char[][] { name };", "+\t\t\tfoundType = new ProblemReferenceBinding(qName, foundType, ProblemReasons.NotFound);"]}], "num": 20426}