{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "9a93cf294b63e16607f864d4234f7a47", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "36f0861935dc6b2cc065bed1efec6e1b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java", "commitBeforeChange": "653b549b2ec915800fe34bbb2ab9809b71ca66a5", "commitAfterChange": "2caa59d033a9b6c8ec71aab586472ad7fe749893", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "signatureAfterChange": " protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)", "diff": ["-\tif (arguments != null && methodBinding.parameterNonNullness != null) {", "-", "-\t\t// check if varargs need special treatment:", "+\tif (arguments != null) {", "+\t\tCompilerOptions compilerOptions = currentScope.compilerOptions();", "+\t\tboolean considerTypeAnnotations = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8", "+\t\t\t\t&& compilerOptions.isAnnotationBasedNullAnalysisEnabled;", "+\t\tboolean hasJDK15NullAnnotations = methodBinding.parameterNonNullness != null;", "-\t\tboolean passThrough = false;", "-\t\tif (methodBinding.isVarargs()) {", "-\t\t\tint varArgPos = numParamsToCheck-1;", "-\t\t\t// this if-block essentially copied from generateArguments(..):", "-\t\t\tif (numParamsToCheck == arguments.length) {", "-\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "-\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "-\t\t\t\tif (lastType == TypeBinding.NULL", "-\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "-\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "-\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\tif (considerTypeAnnotations || hasJDK15NullAnnotations) {", "+\t\t\t// check if varargs need special treatment:", "+\t\t\tboolean passThrough = false;", "+\t\t\tif (methodBinding.isVarargs()) {", "+\t\t\t\tint varArgPos = numParamsToCheck-1;", "+\t\t\t\t// this if-block essentially copied from generateArguments(..):", "+\t\t\t\tif (numParamsToCheck == arguments.length) {", "+\t\t\t\t\tTypeBinding varArgsType = methodBinding.parameters[varArgPos];", "+\t\t\t\t\tTypeBinding lastType = arguments[varArgPos].resolvedType;", "+\t\t\t\t\tif (lastType == TypeBinding.NULL", "+\t\t\t\t\t\t\t|| (varArgsType.dimensions() == lastType.dimensions()", "+\t\t\t\t\t\t\t&& lastType.isCompatibleWith(varArgsType)))", "+\t\t\t\t\t\tpassThrough = true; // pass directly as-is", "+\t\t\t\t}", "+\t\t\t\tif (!passThrough)", "+\t\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-\t\t\tif (!passThrough)", "-\t\t\t\tnumParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check", "-", "-\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "-\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\tif (considerTypeAnnotations) {", "+\t\t\tfor (int i=0; i<numParamsToCheck; i++) {", "-\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "-\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "-\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t// prefer check based on type annotations:", "+\t\t\t\tint severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType);", "+\t\t\t\tif (severity > 0) {", "+\t\t\t\t\t// immediate reporting:", "+\t\t\t\t\tcurrentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity==1, currentScope.environment());", "+\t\t\t\t\t// next check flow-based null status against null JDK15-style annotations:", "+\t\t\t\t} else if (hasJDK15NullAnnotations && methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "-\t\t}", "+\t\t} else if (hasJDK15NullAnnotations) {", "+\t\t\tfor (int i = 0; i < numParamsToCheck; i++) {", "+\t\t\t\tif (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {", "+\t\t\t\t\tTypeBinding expectedType = methodBinding.parameters[i];", "+\t\t\t\t\tExpression argument = arguments[i];", "+\t\t\t\t\tint nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.", "+\t\t\t\t\tif (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided", "+\t\t\t\t\t\tflowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "8b5a0d13ce1cde01754863a96e8ea47a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsMassiveTests.java", "commitBeforeChange": "881da43b7e0b2ca5798e9c55f57054ccdaa23c6e", "commitAfterChange": "be760997ffe69084a7c4bd4d1ab81289e2452d86", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 14, "signatureBeforeChange": "  void compareFormattedSource() throws IOException, Exception", "signatureAfterChange": "  void compareFormattedSource() throws IOException, Exception", "diff": ["-\t\tString actualResult = runFormatter(codeFormatter, source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "-\t\tif (!this.hasSpaceFailure && COMPARE) {", "-\t\t\tString expectedResult = expectedFormattedSource(source);", "-\t\t\tassertLineEquals(actualResult, source, expectedResult, false);", "+\t\tif (\"comments\".equals(COMPARE)) {", "+\t\t\tString[] oldFormattedComments = formattedComments(source, true);", "+\t\t\tString[] newFormattedComments = formattedComments(source, false);", "+\t\t\tint length = oldFormattedComments == null ? 0 : oldFormattedComments.length;", "+\t\t\tthis.abortOnFailure = false;", "+\t\t\tassertEquals(\"Unexpected number of comments!\", length, newFormattedComments == null ? 0 : newFormattedComments.length);", "+\t\t\tfor (int i=0; i<length; i++) {", "+\t\t\t\tString oldComment = oldFormattedComments[i];", "+\t\t\t\tString newComment = newFormattedComments[i];", "+\t\t\t\tif (oldComment == null) {", "+\t\t\t\t\tassertNull(\"Unexpected non-null new comment\", newComment);", "+\t\t\t\t} else {", "+\t\t\t\t\tString expected = removeKnownDifferences(oldComment);", "+\t\t\t\t\tString actual = removeKnownDifferences(newComment);", "+\t\t\t\t\tif (!expected.equals(actual)) {", "+\t\t\t\t\t\tString actualResult = runFormatter(codeFormatter, source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "+\t\t\t\t\t\tString expectedResult = expectedFormattedSource(source);", "+\t\t\t\t\t\tassertEquals(\"Unexpected difference with formatted comment \"+(i+1), expectedResult, actualResult);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t} else {", "+\t\t\tString actualResult = runFormatter(codeFormatter, source, CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, 0, 0, source.length(), null);", "+\t\t\tif (!this.hasSpaceFailure && \"true\".equals(COMPARE)) {", "+\t\t\t\tString expectedResult = expectedFormattedSource(source);", "+\t\t\t\tassertLineEquals(actualResult, source, expectedResult, false);", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9b730b56036bd57f07766781dcc1cfb5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java", "commitBeforeChange": "2a46362da18e1189829e578c276cfbf726376a20", "commitAfterChange": "948661c4cb198af70b598b9954e5159cb73d7234", "methodNumberBeforeChange": 20, "methodNumberAfterChange": 20, "signatureBeforeChange": "\r \tprivate void findLocalMethodDeclarations(\r \t\tchar[] methodName,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType)", "signatureAfterChange": "\r \tprivate void findLocalMethodDeclarations(\r \t\tchar[] methodName,\r \t\tMethodBinding[] methods,\r \t\tScope scope,\r \t\tObjectVector methodsFound,\r \t\tboolean onlyStaticMethods,\r \t\tboolean exactMatch,\r \t\tTypeBinding receiverType)", "diff": ["+\t\t\t\t\tif(mustQualifyType(CharOperation.splitOn('.',parameterPackageNames[i]), parameterTypeNames[i])){\r", "+\t\t\t\t\t\tcompletion.append(parameterPackageNames[i]);\r", "+\t\t\t\t\t\tcompletion.append('.');\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\tcompletion.append(parameterNames[i]);\r", "+\t\t\t\t\tif(parameterNames != null){\r", "+\t\t\t\t\t\tcompletion.append(parameterNames[i]);\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\tcompletion.append('%');\r", "+\t\t\t\t\t}\r", "+\t\t\t\t\r", "+\t\t\t\tReferenceBinding[] exceptions = method.thrownExceptions;\r", "+\t\t\t\tint exceptionCount =0;\r", "+\t\t\t\tif (exceptions != null && (( exceptionCount = exceptions.length) > 0)){\r", "+\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\tcompletion.append(THROWS);\r", "+\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\tfor(int i = 0; i < exceptionCount ; i++){\r", "+\t\t\t\t\t\tReferenceBinding exception = exceptions[i];\r", "+\t\t\t\t\t\tchar[] typeName = exception.qualifiedSourceName();\r", "+\t\t\t\t\t\tchar[] packageName = exception.qualifiedPackageName();\r", "+\t\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif(mustQualifyType(CharOperation.splitOn('.',packageName), typeName)){\r", "+\t\t\t\t\t\t\tcompletion.append(packageName);\r", "+\t\t\t\t\t\t\tcompletion.append('.');\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t\tcompletion.append(typeName);\r", "+\t\t\t\t\t\t\r", "+\t\t\t\t\t\tif(i != (exceptionCount - 1)){\r", "+\t\t\t\t\t\t\tcompletion.append(',');\r", "+\t\t\t\t\t\t\tcompletion.append(' ');\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t}\r", "+\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aa058f888a2752002562dd9064bb6015", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java", "commitBeforeChange": "339cc4d6bf1e0c04b5fd8670b5c5775e9b614ac5", "commitAfterChange": "58ac3474e49d75029f8406ec492537c604468d2a", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \t@Override \tpublic <A extends Annotation> A getAnnotation(Class<A> annotationType)", "signatureAfterChange": "  \t@SuppressWarnings(\"unchecked\" \t@Override \tpublic <A extends Annotation> A getAnnotation(Class<A> annotationClass)", "diff": ["+\t@SuppressWarnings(\"unchecked\") // for cast of newProxyInstance() to A", "-\tpublic <A extends Annotation> A getAnnotation(Class<A> annotationType) {", "-\t\t// TODO Auto-generated method stub", "-\t\t// throw new UnsupportedOperationException(\"NYI: \" + this + \".getAnnotation(\" + annotationType + \")\"); //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$", "-\t\treturn null;", "+\tpublic <A extends Annotation> A getAnnotation(Class<A> annotationClass) {", "+\t\tAnnotationBinding[] annoInstances = getAnnotationBindings();", "+\t\tif( annoInstances == null || annoInstances.length == 0 || annotationClass == null ) ", "+\t\t\treturn null;", "+", "+\t\tString annoTypeName = annotationClass.getName();", "+\t\tif( annoTypeName == null ) return null;", "+\t\tannoTypeName = annoTypeName.replace('$', '.');", "+\t\tfor( AnnotationBinding annoInstance : annoInstances) {", "+\t\t\tif (annoInstance == null)", "+\t\t\t\tcontinue;", "+\t\t\tReferenceBinding binding = annoInstance.getAnnotationType();            ", "+\t\t\tif ( binding != null && binding.isAnnotationType() ) {", "+\t\t\t\tchar[] qName;", "+\t\t\t\tif (binding.isMemberType()) {", "+\t\t\t\t\tqName = CharOperation.concatWith(binding.enclosingType().compoundName, binding.sourceName, '.');", "+\t\t\t\t\tCharOperation.replace(qName, '$', '.');", "+\t\t\t\t} else {", "+\t\t\t\t\tqName = CharOperation.concatWith(binding.compoundName, '.');", "+\t\t\t\t}", "+\t\t\t\tif( annoTypeName.equals(new String(qName)) ){", "+\t\t\t\t\tAnnotationMirrorImpl annoMirror =", "+\t\t\t\t\t\t(AnnotationMirrorImpl)_env.getFactory().newAnnotationMirror(annoInstance);", "+\t\t\t\t\treturn (A)Proxy.newProxyInstance(annotationClass.getClassLoader(),", "+\t\t\t\t\t\t\tnew Class[]{ annotationClass }, annoMirror );", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\treturn null; ", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d9525e02729621cedde05b93f1b24aab", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "9201dfdd65456845c29d6dc3323aadc8322279d6", "commitAfterChange": "c8ca8bc0ed355b1996bc738eb2798ac55ee50894", "methodNumberBeforeChange": 332, "methodNumberAfterChange": 288, "signatureBeforeChange": " protected void consumeLambdaHeader()", "signatureAfterChange": " protected void consumeLambdaHeader()", "diff": ["+protected void consumeLambdaHeader() {", "+\t// LambdaHeader ::= LambdaParameters '->'  Synthetic/fake production with a synthetic non-terminal. Body not seen yet.", "+\tLambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, null, this instanceof AssistParser /* synthesize elided types as needed */);", "+\tlexp.sourceEnd = this.intStack[this.intPtr--];   // ')' position or identifier position.", "+\tpushOnAstStack(lexp);", "+\tpushOnExpressionStack(lexp);", "+\tthis.listLength = 0; // reset this.listLength after having read all parameters", "+}", "-}", "-protected void consumeLambdaHeader() {", "-\t// Overridden in assist parser."]}], "num": 53278}