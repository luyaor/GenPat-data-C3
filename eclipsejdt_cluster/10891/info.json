{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "1ac1f16cd6dc4c41a4d9dedfedd7aac3", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1462f1a39223bab1b6eb27acad45cbca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java", "commitBeforeChange": "ea5c9cc312f4b4f8b75e3a6a2f95be1c2b2c1422", "commitAfterChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "methodNumberBeforeChange": 35, "methodNumberAfterChange": 45, "signatureBeforeChange": "  \tprivate void doHandleWrap(int wrappingOption, ASTNode parentNode)", "signatureAfterChange": "  \tprivate void doHandleWrap(int wrappingOption, ASTNode parentNode)", "diff": ["-\t\t\t\tif (token.getWrapPolicy().isTopPriority()) {", "+\t\t\t\tif (token.getWrapPolicy().wrapMode == WrapMode.TOP_PRIORITY) {", "-\t\t\t\tboolean canWrapFirst = (wrappingOption & Alignment.M_NEXT_PER_LINE_SPLIT) != Alignment.M_NEXT_PER_LINE_SPLIT;", "+\t\t\t\tboolean canWrapFirst = (wrappingOption", "+\t\t\t\t\t\t& Alignment.M_NEXT_PER_LINE_SPLIT) != Alignment.M_NEXT_PER_LINE_SPLIT;", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (!this.secondaryWrapIndexes.isEmpty()) {", "+\t\t\tint optionNoAlignment = (wrappingOption & ~Alignment.SPLIT_MASK) | Alignment.M_NO_ALIGNMENT;", "+\t\t\tpolicy = getWrapPolicy(optionNoAlignment, 0, false, parentNode);", "+\t\t\tfor (int index : this.secondaryWrapIndexes) {", "+\t\t\t\tToken token = this.tm.get(index);", "+\t\t\t\tif (token.getWrapPolicy() == null)", "+\t\t\t\t\ttoken.setWrapPolicy(policy);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "5c1e1dcc82ff2cc80449cd8419a0d21e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java", "commitBeforeChange": "b48948c440f4082a22e31c203db0c29a35ec4b75", "commitAfterChange": "699cc351076b7c5897a886d674772d111233f0a3", "methodNumberBeforeChange": 84, "methodNumberAfterChange": 84, "signatureBeforeChange": " \tpublic boolean visit(TryStatement node)", "signatureAfterChange": " \tpublic boolean visit(TryStatement node)", "diff": ["+\t\tList resources = node.resources();", "+\t\tif (node.getAST().apiLevel() >= AST.JLS4) {", "+\t\t\tif (!node.resources().isEmpty()) {", "+\t\t\t\tthis.buffer.append('(');", "+\t\t\t\tfor (Iterator it = resources.iterator(); it.hasNext(); ) {", "+\t\t\t\t\tVariableDeclarationExpression variable = (VariableDeclarationExpression) it.next();", "+\t\t\t\t\tvariable.accept(this);", "+\t\t\t\t\tif (it.hasNext()) {", "+\t\t\t\t\t\tthis.buffer.append(';');", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tthis.buffer.append(')');", "+\t\t\t}", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "6ce94ccd29d0d44925a9654e794f7fe4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "f97b24f3f8e94d8f54a74d9a196551c56851e735", "commitAfterChange": "edd951b2efc6b8f7b24cb3f178fd99c174eb6c7a", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \tpublic char[][] charBasedExclusionPatterns()", "signatureAfterChange": " \tpublic char[][] fulExclusionPatternChars()", "diff": ["-\t * Returns a char based representation of the exclusions patterns.\r\t */", "-\tpublic char[][] charBasedExclusionPatterns() {", "-\t\tint length = exclusionPatterns == null ? 0 : exclusionPatterns.length;", "-\t\tif (length == 0) return null;", "-\t\tchar[][] result = new char[length][];", "-\t\tfor (int i = 0; i < length; i++) {", "-\t\t\tresult[i] = exclusionPatterns[i].toCharArray();", "+\t * Returns a char based representation of the exclusions patterns full path.\r\t */", "+\tpublic char[][] fulExclusionPatternChars() {", "+", "+\t\tif (this.fullCharExclusionPatterns == UNINIT_PATTERNS) {", "+\t\t\tint length = this.exclusionPatterns.length;", "+\t\t\tthis.fullCharExclusionPatterns = new char[length][];", "+\t\t\tIPath prefixPath = path.removeTrailingSeparator();", "+\t\t\tfor (int i = 0; i < length; i++) {", "+\t\t\t\tIPath fullPath = prefixPath, pattern;", "+\t\t\t\tif (!(pattern = exclusionPatterns[i]).isAbsolute()) { // add leading ** to relative fragment", "+\t\t\t\t\tfullPath.append(\"**/\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t\tfullPath.append(pattern);", "+\t\t\t\tthis.fullCharExclusionPatterns[i] = fullPath.toString().toCharArray();", "+\t\t\t}", "-\t\treturn result;", "+\t\treturn this.fullCharExclusionPatterns;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "76f8afdd6d83159fa5c309a543ca2eb4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java", "commitBeforeChange": "a5e82ba20d8203e21a0fe05e7c825167e940b15b", "commitAfterChange": "9f4bb9537b883f20829d071b5f6fb5b55dc13a0a", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " void mustPropagateStructuralChanges()", "signatureAfterChange": " void mustPropagateStructuralChanges()", "diff": ["-// TODO (CYCLE FIX) Comment out this method when the 2 new methods are added to IncrementalProjectBuilder", "-//\tHashSet cycleParticipants = new HashSet(3);", "-//\tjavaProject.updateCycleParticipants(null, new ArrayList(), cycleParticipants, workspaceRoot);", "-//", "-//\tIterator i= cycleParticipants.iterator();", "-//\twhile (i.hasNext()) {", "-//\t\tIJavaProject p = (IJavaProject) i.next();", "-//\t\tif (p != javaProject && wasProjectAlreadyBuilt(p.getProject())) {", "-//\t\t\tneedRebuild();", "-//\t\t\treturn;", "-//\t\t}", "-//\t}", "+\tHashSet cycleParticipants = new HashSet(3);", "+\tjavaProject.updateCycleParticipants(null, new ArrayList(), cycleParticipants, workspaceRoot);", "+", "+\tIterator i= cycleParticipants.iterator();", "+\twhile (i.hasNext()) {", "+\t\tIJavaProject p = (IJavaProject) i.next();", "+\t\tif (p != javaProject && hasBeenBuilt(p.getProject())) {", "+\t\t\tif (DEBUG) ", "+\t\t\t\tSystem.out.println(\"Requesting another build iteration since cycle participant \" + p.getProject().getName() //$NON-NLS-1$", "+\t\t\t\t\t+ \" has not yet seen some structural changes\"); //$NON-NLS-1$", "+\t\t\tneedRebuild();", "+\t\t\treturn;", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ae0a984bf73990fd03414726c8dacf2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/diagnose/DiagnoseParser.java", "commitBeforeChange": "a11ec54f2e1e149e77b968382e79f482cc29add9", "commitAfterChange": "831d96bc5763622ed503192c35bfd6688abedd96", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "signatureAfterChange": " \tprivate PrimaryRepairInfo checkPrimaryDistance(int stck[], int stack_top, PrimaryRepairInfo repair)", "diff": ["-\t\t//", "-\t\t// Next, try deletion of the error token.", "-\t\t//", "+\t\t/* Next, try deletion of the error token, preferring deletion as a criteria in", "+\t\t   case of identical, superfluous keyword tokens. See below.", "+\t\t*/", "+\t\t} else if (j == repair.distance) {", "+\t\t\t/* Handle some cases where deletion as a repair strategy is obviously superior to", "+\t\t\t   others. e.g: Object o = new new Object() {}; For some reason, with the new grammar", "+\t\t\t   rules to support type annotations in place, the scopeTrial's choice above wins out", "+\t\t\t   with the repair strategy being to insert a semicolon after the first new. That looks", "+\t\t\t   very suspicious. It is not clear if that is due to the bug in the implementation of", "+\t\t\t   scopeTrial or in the jikespg parser generator or in the grammar.", "+\t\t\t", "+\t\t\t   The current fix is a temporary point-fix to address this problem. It does make sense", "+\t\t\t   as a rule, but is a bit ad-hoc in nature and the reason why scopeTrial succeeds needs", "+\t\t\t   to be understood.", "+\t\t\t*/", "+\t\t\tLexStream.Token previousToken = this.lexStream.token(repair.bufferPosition + 1);", "+\t\t\tLexStream.Token curToken = this.lexStream.token(repair.bufferPosition + 2);", "+\t\t\tif (previousToken != null && curToken != null && previousToken.kind == curToken.kind && Scanner.isKeyword(curToken.kind)) {", "+\t\t\t\trepair.misspellIndex = k;", "+\t\t\t\trepair.code = DELETION_CODE;", "+\t\t\t\trepair.distance = j;", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9d3ae2831ead4b7c0c430641d3ce91fa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java", "commitBeforeChange": "64d39f3567030242a0089e54dec7b20eb2379aa8", "commitAfterChange": "61bef0fdf04ab68e34740d553b6ad5e9433edc7e", "methodNumberBeforeChange": 48, "methodNumberAfterChange": 48, "signatureBeforeChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "signatureAfterChange": " \tpublic static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException", "diff": ["+\t\t\t// and recreate links for external folders if needed", "+\t\t\tboolean externalFoldersProjectExists = JavaModelManager.getExternalManager().getExternalFoldersProject().isAccessible();", "+\t\t\t\tJavaProject javaProject = (JavaProject) projects[i];", "-\t\t\t\t\tclasspath = ((JavaProject) projects[i]).getResolvedClasspath();", "+\t\t\t\t\tclasspath = javaProject.getResolvedClasspath();", "+\t\t\t\t\tboolean needExternalFolderCreation = false;", "+\t\t\t\t\t\tif (!needExternalFolderCreation && !externalFoldersProjectExists && entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {", "+\t\t\t\t\t\t\tObject target = JavaModel.getTarget(entry.getPath(), false/*don't check existence*/);", "+\t\t\t\t\t\t\tif (target instanceof IFolder && ExternalFoldersManager.isExternal(((IFolder) target).getFullPath()))", "+\t\t\t\t\t\t\t\tneedExternalFolderCreation = true;", "+\t\t\t\t\t\t}", "+\t\t\t\t\tif (needExternalFolderCreation)", "+\t\t\t\t\t\tmanager.deltaState.addExternalFolderChange(javaProject, null/*act as if all external folders were new*/);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b9acdec70bb142f5525cced6c8fc4e6e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NaiveASTFlattener.java", "commitBeforeChange": "8ff87d310a91c2a77c65ad68bb4b1fd94425fd85", "commitAfterChange": "dbf8a869161361178e399dd7e18a85b9a48bde74", "methodNumberBeforeChange": 54, "methodNumberAfterChange": 54, "signatureBeforeChange": " \tpublic boolean visit(StringLiteral node)", "signatureAfterChange": " \tpublic boolean visit(PackageDeclaration node)", "diff": ["+\t\tif (node.getAST().API_LEVEL >= AST.LEVEL_3_0) {", "+\t\t\tfor (Iterator it = node.annotations().iterator(); it.hasNext(); ) {", "+\t\t\t\tAnnotation p = (Annotation) it.next();", "+\t\t\t\tp.accept(this);", "+\t\t\t\tthis.buffer.append(\" \");//$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+\t\treturn false;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d20a77ed33e97f47416d0e5e975ae7e1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/NaiveASTFlattener.java", "commitBeforeChange": "2bf3ca4fdac4d07bd91bee9a8957437ed1319e5b", "commitAfterChange": "095f68551aabc4fec8e028b2a81b692255ffc31a", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic boolean visit(ClassInstanceCreation node)", "signatureAfterChange": " \tpublic boolean visit(ClassInstanceCreation node)", "diff": ["+\t\t\tif (!node.typeParameters().isEmpty()) {", "+\t\t\t\tthis.buffer.append(\"<\");//$NON-NLS-1$", "+\t\t\t\tfor (Iterator it = node.typeParameters().iterator(); it.hasNext(); ) {", "+\t\t\t\t\tTypeParameter t = (TypeParameter) it.next();", "+\t\t\t\t\tt.accept(this);", "+\t\t\t\t\tif (it.hasNext()) {", "+\t\t\t\t\t\tthis.buffer.append(\",\");//$NON-NLS-1$", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tthis.buffer.append(\">\");//$NON-NLS-1$", "+\t\t\t}"]}], "num": 10891}