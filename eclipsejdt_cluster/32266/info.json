{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "488f0cc792210b2bb42982417a111681", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9c9b01e6bcff10cd0aad72dd8f7b0745", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 7, "signatureBeforeChange": " private MethodBinding createMethod(IBinaryMethod method)", "signatureAfterChange": " private MethodBinding createMethod(IBinaryMethod method, boolean checkGenericSignatures)", "diff": ["-private MethodBinding createMethod(IBinaryMethod method) {", "+private MethodBinding createMethod(IBinaryMethod method, boolean checkGenericSignatures) {", "-", "-\tchar[][] exceptionTypes = method.getExceptionTypeNames();", "-\tif (exceptionTypes != null) {", "-\t\tint size = exceptionTypes.length;", "-\t\tif (size > 0) {", "-\t\t\texceptions = new ReferenceBinding[size];", "-\t\t\tfor (int i = 0; i < size; i++)", "-\t\t\t\texceptions[i] = environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1);", "-\t\t}", "-\t}", "-", "-\tchar[] methodSignature = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V", "-\tint numOfParams = 0;", "-\tchar nextChar;", "-\tint index = 0;   // first character is always '(' so skip it", "-\twhile ((nextChar = methodSignature[++index]) != ')') {", "-\t\tif (nextChar != '[') {", "-\t\t\tnumOfParams++;", "-\t\t\tif (nextChar == 'L')", "-\t\t\t\twhile ((nextChar = methodSignature[++index]) != ';'){/*empty*/}", "+\tTypeVariableBinding[] typeVars = NoTypeVariables;", "+\tTypeBinding returnType = null;", "+", "+\tchar[] methodSignature = checkGenericSignatures ? method.getGenericSignature() : null;", "+\tif (methodSignature == null) { // no generics", "+\t\tchar[] methodDescriptor = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V", "+\t\tint numOfParams = 0;", "+\t\tchar nextChar;", "+\t\tint index = 0;   // first character is always '(' so skip it", "+\t\twhile ((nextChar = methodDescriptor[++index]) != ')') {", "+\t\t\tif (nextChar != '[') {", "+\t\t\t\tnumOfParams++;", "+\t\t\t\tif (nextChar == 'L')", "+\t\t\t\t\twhile ((nextChar = methodDescriptor[++index]) != ';'){/*empty*/}", "+\t\t\t}", "+\t\t}", "+", "+\t\t// Ignore synthetic argument for member types.", "+\t\tint startIndex = (method.isConstructor() && isMemberType() && !isStatic()) ? 1 : 0;", "+\t\tint size = numOfParams - startIndex;", "+\t\tif (size > 0) {", "+\t\t\tparameters = new TypeBinding[size];", "+\t\t\tindex = 1;", "+\t\t\tint end = 0;   // first character is always '(' so skip it", "+\t\t\tfor (int i = 0; i < numOfParams; i++) {", "+\t\t\t\twhile ((nextChar = methodDescriptor[++end]) == '['){/*empty*/}", "+\t\t\t\tif (nextChar == 'L')", "+\t\t\t\t\twhile ((nextChar = methodDescriptor[++end]) != ';'){/*empty*/}", "+\t", "+\t\t\t\tif (i >= startIndex)   // skip the synthetic arg if necessary", "+\t\t\t\t\tparameters[i - startIndex] = environment.getTypeFromSignature(methodDescriptor, index, end, false, this);", "+\t\t\t\tindex = end + 1;", "+\t\t\t}", "+\t\t}", "+", "+\t\tchar[][] exceptionTypes = method.getExceptionTypeNames();", "+\t\tif (exceptionTypes != null) {", "+\t\t\tsize = exceptionTypes.length;", "+\t\t\tif (size > 0) {", "+\t\t\t\texceptions = new ReferenceBinding[size];", "+\t\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\t\texceptions[i] = environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false);", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (!method.isConstructor())", "+\t\t\treturnType = environment.getTypeFromSignature(methodDescriptor, index + 1, -1, false, this);   // index is currently pointing at the ')'", "+\t} else {", "+\t\t// MethodTypeSignature = ParameterPart(optional) '(' TypeSignatures ')' return_typeSignature ['^' TypeSignature (optional)]", "+\t\tSignatureWrapper wrapper = new SignatureWrapper(methodSignature);", "+\t\tif (wrapper.signature[wrapper.start] == '<') {", "+\t\t\t// <A::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TA;>;)TA;", "+\t\t\t// ParameterPart = '<' ParameterSignature(s) '>'", "+\t\t\twrapper.start++; // skip '<'", "+\t\t\tint rank = 0;", "+\t\t\tdo {", "+\t\t\t\tTypeVariableBinding variable = createTypeVariable(wrapper, rank);", "+\t\t\t\tSystem.arraycopy(typeVars, 0, typeVars = new TypeVariableBinding[rank + 1], 0, rank);", "+\t\t\t\ttypeVars[rank++] = variable;", "+\t\t\t} while (wrapper.signature[wrapper.start] != '>');", "+\t\t\twrapper.start++; // skip '>'", "+\t\t}", "+", "+\t\tif (wrapper.signature[wrapper.start] == '(') {", "+\t\t\twrapper.start++; // skip '('", "+\t\t\tif (wrapper.signature[wrapper.start] == ')') {", "+\t\t\t\twrapper.start++; // skip ')'", "+\t\t\t} else {", "+\t\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "+\t\t\t\tint startIndex = (method.isConstructor() && isMemberType() && !isStatic()) ? 1 : 0;", "+\t\t\t\tif (startIndex == 1)", "+\t\t\t\t\tenvironment.getTypeFromTypeSignature(wrapper, typeVars, this); // skip synthetic argument", "+\t\t\t\twhile (wrapper.signature[wrapper.start] != ')') {", "+\t\t\t\t\ttypes.add(environment.getTypeFromTypeSignature(wrapper, typeVars, this));", "+\t\t\t\t}", "+\t\t\t\twrapper.start++; // skip ')'", "+\t\t\t\tparameters = new TypeBinding[types.size()];", "+\t\t\t\ttypes.toArray(parameters);", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (!method.isConstructor())", "+\t\t\treturnType = environment.getTypeFromTypeSignature(wrapper, typeVars, this);", "+", "+\t\tif (!wrapper.atEnd() && wrapper.signature[wrapper.start] == '^') {", "+\t\t\t// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)", "+\t\t\tjava.util.ArrayList types = new java.util.ArrayList(2);", "+\t\t\tdo {", "+\t\t\t\twrapper.start++; // skip '^'", "+\t\t\t\ttypes.add(environment.getTypeFromTypeSignature(wrapper, typeVars, this));", "+\t\t\t} while (!wrapper.atEnd() && wrapper.signature[wrapper.start] == '^');", "+\t\t\texceptions = new ReferenceBinding[types.size()];", "+\t\t\ttypes.toArray(exceptions);", "+\t\t} else { // get the exceptions the old way", "+\t\t\tchar[][] exceptionTypes = method.getExceptionTypeNames();", "+\t\t\tif (exceptionTypes != null) {", "+\t\t\t\tint size = exceptionTypes.length;", "+\t\t\t\tif (size > 0) {", "+\t\t\t\t\texceptions = new ReferenceBinding[size];", "+\t\t\t\t\tfor (int i = 0; i < size; i++)", "+\t\t\t\t\t\texceptions[i] = environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1, false);", "+\t\t\t\t}", "+\t\t\t}", "-\t// Ignore synthetic argument for member types.", "-\tint startIndex = (method.isConstructor() && isMemberType() && !isStatic()) ? 1 : 0;", "-\tint size = numOfParams - startIndex;", "-\tif (size > 0) {", "-\t\tparameters = new TypeBinding[size];", "-\t\tindex = 1;", "-\t\tint end = 0;   // first character is always '(' so skip it", "-\t\tfor (int i = 0; i < numOfParams; i++) {", "-\t\t\twhile ((nextChar = methodSignature[++end]) == '['){/*empty*/}", "-\t\t\tif (nextChar == 'L')", "-\t\t\t\twhile ((nextChar = methodSignature[++end]) != ';'){/*empty*/}", "-", "-\t\t\tif (i >= startIndex)   // skip the synthetic arg if necessary", "-\t\t\t\tparameters[i - startIndex] = environment.getTypeFromSignature(methodSignature, index, end);", "-\t\t\tindex = end + 1;", "-\t\t}", "-\t}", "-", "-\tMethodBinding binding = null;", "-\tif (method.isConstructor())", "-\t\tbinding = new MethodBinding(methodModifiers, parameters, exceptions, this);", "-\telse", "-\t\tbinding = new MethodBinding(", "-\t\t\tmethodModifiers,", "-\t\t\tmethod.getSelector(),", "-\t\t\tenvironment.getTypeFromSignature(methodSignature, index + 1, -1),   // index is currently pointing at the ')'", "-\t\t\tparameters,", "-\t\t\texceptions,", "-\t\t\tthis);", "-\treturn binding;", "+\tMethodBinding result = method.isConstructor()", "+\t\t? new MethodBinding(methodModifiers, parameters, exceptions, this)", "+\t\t: new MethodBinding(methodModifiers, method.getSelector(), returnType, parameters, exceptions, this);", "+\tresult.typeVariables = typeVars;", "+\treturn result;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "dcdf7d2be71ce713864a7280d63c52d8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java", "commitBeforeChange": "5281f7a1d02f4134760334f239cbffb833f0ed1c", "commitAfterChange": "b8222e0e4564cc4472bb2fdfd410e7de68bbf0fa", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " \tprotected void logPerfResult(PrintStream[] logStreams, int count)", "signatureAfterChange": " \t\tprotected void logPerfResult(PrintStream[] logStreams, int count)", "diff": ["-\tprotected void logPerfResult(PrintStream[] logStreams, int count) {", "-", "-\t\t// Log perf result", "-\t\tboolean haveTimes  = JdtCorePerformanceMeter.CPU_TIMES != null;", "-\t\tif (haveTimes) {", "-\t\t\tJdtCorePerformanceMeter.Statistics stats = (JdtCorePerformanceMeter.Statistics) JdtCorePerformanceMeter.CPU_TIMES.get(this.scenario);", "-\t\t\tif (stats != null) {", "-\t\t\t\tif (logStreams[0] != null) {", "-\t\t\t\t\tlogStreams[0].print(\"\"+stats.count+\"\\t\");", "-\t\t\t\t\tif (DEBUG) System.out.println(\"\t- count stored in log file.\\n\");", "-\t\t\t\t}", "-\t\t\t\tif (logStreams[1] != null) {", "-\t\t\t\t\tlogStreams[1].print(\"\"+stats.sum+\"\\t\");", "-\t\t\t\t\tif (DEBUG) System.out.println(\"\t- sum stored in log file.\\n\");", "-\t\t\t\t}", "-\t\t\t\tif (logStreams[2] != null) {", "-\t\t\t\t\tlogStreams[2].print(\"\"+stats.average+\"\\t\");", "-\t\t\t\t\tif (DEBUG) System.out.println(\"\t- average stored in log file.\\n\");", "-\t\t\t\t}", "-\t\t\t\tif (logStreams[3] != null) {", "-\t\t\t\t\tlogStreams[3].print(\"\"+stats.stddev+\"\\t\");", "-\t\t\t\t\tif (DEBUG) System.out.println(\"\t- stddev stored in log file.\\n\");", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tSystem.err.println(\"We should have stored Cpu Time for \"+this.scenario);", "-\t\t}", "-", "-\t\t// Close log", "-\t\tif (count == 0) {", "-\t\t\tfor (int i=0, ln=logStreams.length; i<ln; i++) {", "-\t\t\t\tif (logStreams[i] != null) {", "-\t\t\t\t\tif (haveTimes) logStreams[i].println();", "-\t\t\t\t\tlogStreams[i].close();", "-\t\t\t\t}", "+\t\t */", "+\t\tprotected void logPerfResult(PrintStream[] logStreams, int count) {", "+", "+\t\t\t// Perfs comment buffers", "+\t\t\tString[] comments = new String[2];", "+", "+\t\t\t// Log perf result", "+\t\t\tboolean haveTimes  = JdtCorePerformanceMeter.CPU_TIMES != null && JdtCorePerformanceMeter.ELAPSED_TIMES != null;", "+\t\t\tif (haveTimes) {", "+\t\t\t\tNumberFormat pFormat = NumberFormat.getPercentInstance();", "+\t\t\t\tpFormat.setMaximumFractionDigits(1);", "+\t\t\t\tNumberFormat dFormat = NumberFormat.getNumberInstance();", "+\t\t\t\tdFormat.setMaximumFractionDigits(2);", "+\t\t\t\ttry {", "+\t\t\t\t\t// Store CPU Time", "+\t\t\t\t\tJdtCorePerformanceMeter.Statistics cpuStats = (JdtCorePerformanceMeter.Statistics) JdtCorePerformanceMeter.CPU_TIMES.get(this.scenarioReadableName);", "+\t\t\t\t\tif (cpuStats != null) {", "+\t\t\t\t\t\tdouble percent = cpuStats.stddev/cpuStats.average;", "+\t\t\t\t\t\tif (percent > STDDEV_THRESHOLD) {", "+\t\t\t\t\t\t\tif (logStreams[0] != null) logStreams[0].print(\"'\");", "+\t\t\t\t\t\t\tSystem.out.println(\"\tWARNING: CPU time standard deviation is over 2%: \"+dFormat.format(cpuStats.stddev)+\"/\"+cpuStats.average+\"=\"+ pFormat.format(percent));", "+\t\t\t\t\t\t\tcomments[0] = \"stddev=\" + pFormat.format(percent);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (logStreams[0] != null) {", "+\t\t\t\t\t\t\tlogStreams[0].print(\"\"+cpuStats.average+\"\\t\");", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tThread.sleep(1000);", "+\t\t\t\t\t\tSystem.err.println(this.scenarioShortName+\": we should have stored CPU time!\");", "+\t\t\t\t\t\tThread.sleep(1000);", "+\t\t\t\t\t}", "+\t\t\t\t\t// Store Elapsed time", "+\t\t\t\t\tJdtCorePerformanceMeter.Statistics elapsedStats = (JdtCorePerformanceMeter.Statistics) JdtCorePerformanceMeter.ELAPSED_TIMES.get(this.scenarioReadableName);", "+\t\t\t\t\tif (elapsedStats != null) {", "+\t\t\t\t\t\tdouble percent = elapsedStats.stddev/elapsedStats.average;", "+\t\t\t\t\t\tif (percent > STDDEV_THRESHOLD) {", "+\t\t\t\t\t\t\tif (logStreams[1] != null) logStreams[1].print(\"'\");", "+\t\t\t\t\t\t\tSystem.out.println(\"\tWARNING: Elapsed time standard deviation is over 2%: \"+dFormat.format(elapsedStats.stddev)+\"/\"+elapsedStats.average+\"=\"+ pFormat.format(percent));", "+\t\t\t\t\t\t\tcomments[1] = \"stddev=\" + pFormat.format(percent);", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (logStreams[1] != null) {", "+\t\t\t\t\t\t\tlogStreams[1].print(\"\"+elapsedStats.average+\"\\t\");", "+\t\t\t\t\t\t}", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tThread.sleep(1000);", "+\t\t\t\t\t\tSystem.err.println(this.scenarioShortName+\": we should have stored Elapsed time\");", "+\t\t\t\t\t\tThread.sleep(1000);", "+\t\t\t\t\t}", "+\t\t\t\t} catch (InterruptedException e) {", "+\t\t\t\t\t// do nothing", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// Update comment buffers", "+\t\t\tStringBuffer[] scenarioComments = (StringBuffer[]) SCENARII_COMMENT.get(getClass());", "+\t\t\tif (scenarioComments == null) {", "+\t\t\t\tscenarioComments = new StringBuffer[LOG_TYPES.length];", "+\t\t\t\tSCENARII_COMMENT.put(getClass(), scenarioComments);", "+\t\t\t}", "+\t\t\tfor (int i=0, ln=LOG_TYPES.length; i<ln; i++) {", "+\t\t\t\tif (comments[i] != null) {", "+\t\t\t\t\tif (scenarioComments[i] == null) {", "+\t\t\t\t\t\tscenarioComments[i] = new StringBuffer();", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tscenarioComments[i].append(' ');", "+\t\t\t\t\t}", "+\t\t\t\t\tif (this.scenarioComment == null) {", "+\t\t\t\t\t\tscenarioComments[i].append(\"[\"+TEST_POSITION+\"]\");", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tscenarioComments[i].append(this.scenarioComment);", "+\t\t\t\t\t}", "+\t\t\t\t\tscenarioComments[i].append(' ');", "+\t\t\t\t\tscenarioComments[i].append(comments[i]);", "+\t\t\t\t}\t", "+\t\t\t}", "+", "+\t\t\t// Close log", "+\t\t\tif (count == 0) {", "+\t\t\t\tfor (int i=0, ln=logStreams.length; i<ln; i++) {", "+\t\t\t\t\tif (logStreams[i] != null) {", "+\t\t\t\t\t\tif (haveTimes) {", "+\t\t\t\t\t\t\tif (comments[i] != null) {", "+\t\t\t\t\t\t\t\tlogStreams[i].print(scenarioComments[i].toString());", "+\t\t\t\t\t\t\t}\t", "+\t\t\t\t\t\t\tlogStreams[i].println();", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tlogStreams[i].close();", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tTEST_POSITION = 0;", "+\t\t\t}", "+\t\t}"]}], "num": 32266}