{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "10eb5678ea0c14092f4d6c46050832bb", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73130742cdcfdde9157c09c00984610e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java", "commitBeforeChange": "6781b5445d9813f939573ded9d37ee82c9dbbd15", "commitAfterChange": "6989e5bb4ed8f3be37ea69298930332629e9b475", "methodNumberBeforeChange": 15, "methodNumberAfterChange": 15, "signatureBeforeChange": " \t \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "signatureAfterChange": " \t \tpublic TypeBinding getOtherFieldBindings(BlockScope scope)", "diff": ["-\t\t\t// set generic cast of for previous field (if any)", "-\t\t\tif (field != null) {", "-\t\t\t\tFieldBinding originalBinding = field.original();", "-\t\t\t\tif (originalBinding != field) {", "-\t\t\t\t    // extra cast needed if method return type has type variable", "-\t\t\t\t    if ((originalBinding.type.tagBits & TagBits.HasTypeVariable) != 0 && type.id != T_JavaLangObject) {", "-\t\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(type)); // type cannot be base-type even in boxing case", "-\t\t\t\t    }", "-\t\t\t\t} \t", "-\t\t\t}", "-\t\t\tbits &= ~DepthMASK; // flush previous depth if any\t\t\t", "+\t\t\tbits &= ~DepthMASK; // flush previous depth if any\t\t", "+\t\t\tFieldBinding previousField = field;", "+\t\t\t\t// set generic cast of for previous field (if any)", "+\t\t\t\tif (previousField != null) {", "+\t\t\t\t\tTypeBinding fieldReceiverType = type;", "+\t\t\t\t\tTypeBinding receiverErasure = type.erasure();", "+\t\t\t\t\tif (receiverErasure instanceof ReferenceBinding) {", "+\t\t\t\t\t\tReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeErasingTo((ReferenceBinding)field.declaringClass.erasure());", "+\t\t\t\t\t\tif (match == null) {", "+\t\t\t\t\t\t\tfieldReceiverType = field.declaringClass; // handle indirect inheritance thru variable secondary bound", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}\t\t\t\t", "+\t\t\t\t\tFieldBinding originalBinding = previousField.original();", "+\t\t\t\t    if ((originalBinding.type.tagBits & TagBits.HasTypeVariable) != 0 && fieldReceiverType.id != T_JavaLangObject) {", "+\t\t\t\t    \tsetGenericCast(index-1,originalBinding.type.genericCast(fieldReceiverType)); // type cannot be base-type even in boxing case", "+\t\t\t\t    }", "+\t\t\t    }"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a1712357c8ce42711c4a970cabd4ad46", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java", "commitBeforeChange": "39e0b3c44033d41fbb2f81071d1364bb178092c7", "commitAfterChange": "b4de16a0dc7d3ad9d6dd3c598e29125b9c3084c3", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 15, "signatureBeforeChange": " \tprivate boolean connectSuperInterfaces()", "signatureAfterChange": " \tprivate boolean connectSuperInterfaces()", "diff": ["-\t\t\tReferenceBinding superInterface = findSupertype(referenceContext.superInterfaces[i]);", "+\t\t    TypeReference superInterfaceRef = referenceContext.superInterfaces[i];", "+\t\t\tReferenceBinding superInterface = findSupertype(superInterfaceRef);", "-\t\t\t\tnoProblems = false;", "-\t\t\t\tcontinue nextInterface;", "-\t\t\t}", "-\t\t\treferenceContext.superInterfaces[i].resolvedType = superInterface; // hold onto the problem type", "-\t\t\tif (!superInterface.isValidBinding()) {", "-\t\t\t\tproblemReporter().invalidSuperinterface(", "-\t\t\t\t\tsourceType,", "-\t\t\t\t\treferenceContext.superInterfaces[i],", "-\t\t\t\t\tsuperInterface);", "+\t\t\tsuperInterfaceRef.resolvedType = superInterface; // hold onto the problem type", "+\t\t\t\tsourceType.tagBits |= HierarchyHasProblems;", "+\t\t\t\tnoProblems = false;", "+\t\t\t\tcontinue nextInterface;", "+\t\t\t}", "+\t\t\tReferenceBinding invalid = findAmbiguousInterface(superInterface, sourceType);", "+\t\t\tif (invalid != null) {", "+\t\t\t\tReferenceBinding generic = null;", "+\t\t\t\tif (superInterface.isParameterizedType())", "+\t\t\t\t\tgeneric = ((ParameterizedTypeBinding) superInterface).type;", "+\t\t\t\telse if (invalid.isParameterizedType())", "+\t\t\t\t\tgeneric = ((ParameterizedTypeBinding) invalid).type;", "+\t\t\t\tproblemReporter().superinterfacesCollide(generic, referenceContext, superInterface, invalid);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "eca93f7a8840cfb483590f923c437a7a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "8c93d4e99b8a943865cb7391e781eba5bb83dfc9", "commitAfterChange": "bd0edd7688142c1743cb6b10766dfc576040f113", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": " private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+\t// start assembling info for reseting field info by UnconditionalFlowInfo.resetNullInfoForFields():", "+\tClassScope enclosingClassScope = this.scope.enclosingClassScope();", "+\tUnconditionalFlowInfo fieldResetInfo = (enclosingClassScope != null)", "+\t\t\t? (UnconditionalFlowInfo) enclosingClassScope.fieldResetFlowInfo.copy()", "+\t\t\t: FlowInfo.initial(((UnconditionalFlowInfo)staticFieldInfo).maxFieldCount);", "+\tthis.scope.fieldResetFlowInfo = fieldResetInfo;", "+", "-\t\t\t\tstaticFieldInfo = field.analyseCode(this.staticInitializerScope, staticInitializerContext, staticFieldInfo);", "-\t\t\t\tif (field.binding != null && this.scope.compilerOptions().includeFieldsInNullAnalysis", "-\t\t\t\t\t\t&& ((field.binding.modifiers & ClassFileConstants.AccFinal) != 0)) {", "-\t\t\t\t\t// we won't reset null Info for constant fields", "-\t\t\t\t\tstaticFieldInfo.updateConstantFieldsMask(field.binding);", "-\t\t\t\t}", "+\t\t\t\tstaticFieldInfo = field.analyseCode(this.staticInitializerScope, staticInitializerContext, staticFieldInfo, flowInfo, fieldResetInfo);", "-\t\t\t\tnonStaticFieldInfo = field.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo);", "+\t\t\t\tnonStaticFieldInfo = field.analyseCode(this.initializerScope, initializerContext, nonStaticFieldInfo, flowInfo, fieldResetInfo);", "-\t\t\tflowInfo.addConstantFieldsMask(staticFieldUnconditionalInfo);\t// prevent resetting null info for constant fields inside methods", "-\t\t\tflowInfo.resetNullInfoForFields();\t// only preserve null info for constant fields", "+\t\t\tflowInfo.addConstantFieldsMask(fieldResetInfo);\t// prevent resetting null info for constant fields inside methods", "+\t\t\tflowInfo.resetNullInfoForFields(fieldResetInfo);\t// only preserve null info for constant fields", "-\t\t\tconstructorInfo.addConstantFieldsMask(staticFieldUnconditionalInfo); // prevent resetting null info for constant fields inside c'tor too", "+\t\t\tconstructorInfo.addConstantFieldsMask(fieldResetInfo); // prevent resetting null info for constant fields inside c'tor too"]}], "num": 50633}