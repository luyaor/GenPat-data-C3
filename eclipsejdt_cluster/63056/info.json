{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b34973da564b0468091a9b060a26e562", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0f82c566d6b8fba8aa3a851b5bd7e2c5", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java", "commitBeforeChange": "d4c834daaadbd8c680a6fcccd31170f229344d7e", "commitAfterChange": "9afcaef5b1b73c3a14828e7dccbe0110d44ea231", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  private void computeClasspathLocations( \tIWorkspaceRoot root, \tJavaProject javaProject) throws CoreException", "signatureAfterChange": "  private void computeClasspathLocations( \tIWorkspaceRoot workspaceRoot, \tJavaProject javaProject) throws CoreException", "diff": ["-\tIWorkspaceRoot root,", "+\tIWorkspaceRoot workspaceRoot,", "-", "-\tIClasspathEntry[] classpath = javaProject.getExpandedClasspath(true/*ignore unresolved variables*/);", "-\tint length = classpath.length;", "-\tArrayList locations = new ArrayList(length);", "-\tnextEntry : for (int i = 0; i < length; i++) {", "-\t\tIClasspathEntry entry = classpath[i];", "-\t\tIPath path = entry.getPath();", "-\t\tObject target = JavaModel.getTarget(root, path, true);", "-\t\tif (target == null) continue nextEntry;", "-", "-\t\tswitch(entry.getEntryKind()) {", "-\t\t\tcase IClasspathEntry.CPE_SOURCE :", "-\t\t\t\tif (!(target instanceof IContainer)) continue nextEntry;", "+\tIPackageFragmentRoot[] roots = javaProject.getAllPackageFragmentRoots();", "+\tint length = roots.length;", "+\tClasspathLocation[] locations = new ClasspathLocation[length];", "+\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\tfor (int i = 0; i < length; i++) {", "+\t\tIPackageFragmentRoot root = roots[i];", "+\t\tIPath path = root.getPath();", "+\t\tif (root.isArchive()) {", "+\t\t\tZipFile zipFile = manager.getZipFile(path);", "+\t\t\tlocations[i] = new ClasspathJar(zipFile);", "+\t\t} else {", "+\t\t\tObject target = JavaModel.getTarget(workspaceRoot, path, false);", "+\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {", "-\t\t\t\tlocations.add(new ClasspathSourceDirectory((IContainer)target, encoding));", "-\t\t\t\tcontinue nextEntry;", "-", "-\t\t\tcase IClasspathEntry.CPE_LIBRARY :", "-\t\t\t\tif (target instanceof IResource) {", "-\t\t\t\t\tIResource resource = (IResource) target;", "-\t\t\t\t\tClasspathLocation location = null;", "-\t\t\t\t\tif (resource instanceof IFile) {", "-\t\t\t\t\t\tString fileName = path.lastSegment();", "-\t\t\t\t\t\tif (!Util.isArchiveFileName(fileName)) continue nextEntry;", "-\t\t\t\t\t\tlocation = getClasspathJar((IFile)resource);", "-\t\t\t\t\t} else if (resource instanceof IContainer) {", "-\t\t\t\t\t\tlocation = ClasspathLocation.forBinaryFolder((IContainer) target, false); // is library folder not output folder", "-\t\t\t\t\t}", "-\t\t\t\t\tlocations.add(location);", "-\t\t\t\t} else if (target instanceof File) {", "-\t\t\t\t\tString fileName = path.lastSegment();", "-\t\t\t\t\tif (!Util.isArchiveFileName(fileName)) continue nextEntry;", "-\t\t\t\t\tlocations.add(getClasspathJar(path.toOSString()));", "-\t\t\t\t}", "-\t\t\t\tcontinue nextEntry;", "+\t\t\t\tlocations[i] = new ClasspathSourceDirectory((IContainer)target, encoding);", "+\t\t\t} else {", "+\t\t\t\tlocations[i] = ClasspathLocation.forBinaryFolder((IContainer) target, false);", "+\t\t\t}", "-", "-\tthis.locations = new ClasspathLocation[locations.size()];", "-\tlocations.toArray(this.locations);", "+\tthis.locations = locations;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0f050c5b9ab6cf7da35348de29cba1e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java", "commitBeforeChange": "415e478fd80c86e1c699eefa6d86979134ae5921", "commitAfterChange": "63b8bf54c7c6ab31eaeaf33c9d376ceaa28b674d", "methodNumberBeforeChange": 90, "methodNumberAfterChange": 86, "signatureBeforeChange": " \tpublic IClasspathEntry[] getResolvedClasspath( \t\tboolean ignoreUnresolvedEntry, \t\tboolean generateMarkerOnError, \t\tboolean returnResolutionInProgress) \t\tthrows JavaModelException", "signatureAfterChange": " \tpublic IClasspathEntry[] getResolvedClasspath(boolean ignoreUnresolvedEntry) throws JavaModelException", "diff": ["-\t */", "-\tpublic IClasspathEntry[] getResolvedClasspath(", "-\t\tboolean ignoreUnresolvedEntry,", "-\t\tboolean generateMarkerOnError,", "-\t\tboolean returnResolutionInProgress)", "-\t\tthrows JavaModelException {", "-", "-\t    JavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\tJavaModelManager.PerProjectInfo perProjectInfo = null;", "-\t\tif (ignoreUnresolvedEntry && !generateMarkerOnError) {", "-\t\t\tperProjectInfo = getPerProjectInfo();", "-\t\t\tif (perProjectInfo != null) {", "-\t\t\t\t// resolved path is cached on its info", "-\t\t\t\tIClasspathEntry[] infoPath = perProjectInfo.resolvedClasspath;", "-\t\t\t\tif (infoPath != null) {", "-\t\t\t\t\treturn infoPath;", "-\t\t\t\t} else if  (returnResolutionInProgress && manager.isClasspathBeingResolved(this)) {", "-\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE) {", "-\t\t\t\t\t\tUtil.verbose(", "-\t\t\t\t\t\t\t\"CPResolution: reentering raw classpath resolution, will use empty classpath instead\" + //$NON-NLS-1$", "-\t\t\t\t\t\t\t\"\tproject: \" + getElementName() + '\\n' + //$NON-NLS-1$", "-\t\t\t\t\t\t\t\"\tinvocation stack trace:\"); //$NON-NLS-1$", "-\t\t\t\t\t\tnew Exception(\"<Fake exception>\").printStackTrace(System.out); //$NON-NLS-1$", "-\t\t\t\t\t}\t\t\t\t\t\t", "-\t\t\t\t    return RESOLUTION_IN_PROGRESS;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-\t\tMap rawReverseMap = perProjectInfo == null ? null : new HashMap(5);", "-\t\tIClasspathEntry[] resolvedPath = null;", "-\t\tboolean nullOldResolvedCP = perProjectInfo != null && perProjectInfo.resolvedClasspath == null;", "-\t\ttry {", "-\t\t\t// protect against misbehaving clients (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=61040)", "-\t\t\tif (nullOldResolvedCP) manager.setClasspathBeingResolved(this, true);", "-\t\t\tresolvedPath = getResolvedClasspath(", "-\t\t\t\tgetRawClasspath(generateMarkerOnError, !generateMarkerOnError), ", "-\t\t\t\tgenerateMarkerOnError ? getOutputLocation() : null, ", "-\t\t\t\tignoreUnresolvedEntry, ", "-\t\t\t\tgenerateMarkerOnError,", "-\t\t\t\trawReverseMap);", "-\t\t} finally {", "-\t\t\tif (nullOldResolvedCP) perProjectInfo.resolvedClasspath = null;", "-\t\t}", "-", "-\t\tif (perProjectInfo != null){", "-\t\t\tif (perProjectInfo.rawClasspath == null // .classpath file could not be read", "-\t\t\t\t&& generateMarkerOnError ", "-\t\t\t\t&& JavaProject.hasJavaNature(this.project)) {", "-\t\t\t\t\t// flush .classpath format markers (bug 39877), but only when file cannot be read (bug 42366)", "-\t\t\t\t\tthis.flushClasspathProblemMarkers(false, true);", "-\t\t\t\t\tthis.createClasspathProblemMarker(new JavaModelStatus(", "-\t\t\t\t\t\tIJavaModelStatusConstants.INVALID_CLASSPATH_FILE_FORMAT,", "-\t\t\t\t\t\tMessages.bind(Messages.classpath_cannotReadClasspathFile, this.getElementName()))); ", "-\t\t\t}", "-", "-\t\t\tperProjectInfo.resolvedClasspath = resolvedPath;", "-\t\t\tperProjectInfo.resolvedPathToRawEntries = rawReverseMap;", "-\t\t\tmanager.setClasspathBeingResolved(this, false);", "-\t\t}", "-\t\treturn resolvedPath;", "+\t */", "+\tpublic IClasspathEntry[] getResolvedClasspath(boolean ignoreUnresolvedEntry) throws JavaModelException {", "+\t\tif  (JavaModelManager.getJavaModelManager().isClasspathBeingResolved(this)) {", "+\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE) {", "+\t\t\t\tUtil.verbose(", "+\t\t\t\t\t\"CPResolution: reentering raw classpath resolution, will use empty classpath instead\" + //$NON-NLS-1$", "+\t\t\t\t\t\"\tproject: \" + getElementName() + '\\n' + //$NON-NLS-1$", "+\t\t\t\t\t\"\tinvocation stack trace:\"); //$NON-NLS-1$", "+\t\t\t\tnew Exception(\"<Fake exception>\").printStackTrace(System.out); //$NON-NLS-1$", "+\t\t\t}\t\t\t\t\t\t", "+\t\t    return RESOLUTION_IN_PROGRESS;", "+\t\tPerProjectInfo perProjectInfo = getPerProjectInfo();", "+\t\t// use synchronized block to ensure consistency", "+\t\tIClasspathEntry[] resolvedClasspath;", "+\t\tIJavaModelStatus unresolvedEntryStatus;", "+\t\tsynchronized (perProjectInfo) {", "+\t\t\tresolvedClasspath = perProjectInfo.resolvedClasspath;", "+\t\t\tunresolvedEntryStatus = perProjectInfo.unresolvedEntryStatus;", "+\t\t}", "+\t\tif (resolvedClasspath == null ", "+\t\t\t\t|| (unresolvedEntryStatus != null && !unresolvedEntryStatus.isOK())) { // force resolution to ensure initializers are run again", "+\t\t\tresolveClasspath(perProjectInfo);", "+\t\t\tsynchronized (perProjectInfo) {", "+\t\t\t\tresolvedClasspath = perProjectInfo.resolvedClasspath;", "+\t\t\t\tunresolvedEntryStatus = perProjectInfo.unresolvedEntryStatus;", "+\t\tif (!ignoreUnresolvedEntry && unresolvedEntryStatus != null && !unresolvedEntryStatus.isOK())", "+\t\t\tthrow new JavaModelException(unresolvedEntryStatus);", "+\t\treturn resolvedClasspath;"]}], "num": 63056}