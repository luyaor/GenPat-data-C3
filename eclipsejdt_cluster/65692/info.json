{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "cc681097d3b2a1333298c5e2f3b24312", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b0fcd55c32f99f67b5bdccdbdd8579ac", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "e6bf96fd82847410c46479a652f4e58f9a6dd052", "commitAfterChange": "5e8c3183792bb167a28b31bd623b66ded11f658d", "methodNumberBeforeChange": 6, "methodNumberAfterChange": 6, "signatureBeforeChange": " \tpublic void analyseCode(CompilationUnitScope unitScope)", "signatureAfterChange": " \tpublic void analyseCode(CompilationUnitScope unitScope)", "diff": ["-", "-//\t\t\tFlowInfo flowInfo = FlowInfo.initial(maxFieldCount); // start fresh init info", "-//\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "-//\t\t\tInitializationFlowContext initializerContext =", "-//\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "-//\t\t\tInitializationFlowContext staticInitializerContext =", "-//\t\t\t\tnew InitializationFlowContext(null, this, staticInitializerScope);", "-//\t\t\tFlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//\t\t\tFlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//\t\t\tif (fields != null) {", "-//\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-//\t\t\t\t\tFieldDeclaration field = fields[i];", "-//\t\t\t\t\tif (field.isStatic()) {", "-//\t\t\t\t\t\t/*if (field.isField()){", "-//\t\t\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-//\t\t\t\t\t\t} else {*/", "-//\t\t\t\t\t\tstaticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-//\t\t\t\t\t\t/*}*/", "-//\t\t\t\t\t\tstaticFieldInfo =", "-//\t\t\t\t\t\t\tfield.analyseCode(", "-//\t\t\t\t\t\t\t\tstaticInitializerScope,", "-//\t\t\t\t\t\t\t\tstaticInitializerContext,", "-//\t\t\t\t\t\t\t\tstaticFieldInfo);", "-//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-//\t\t\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "-//\t\t\t\t\t\t\tstaticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-//\t\t\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t} else {", "-//\t\t\t\t\t\t/*if (field.isField()){", "-//\t\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-//\t\t\t\t\t\t} else {*/", "-//\t\t\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-//\t\t\t\t\t\t/*}*/", "-//\t\t\t\t\t\tnonStaticFieldInfo =", "-//\t\t\t\t\t\t\tfield.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);", "-//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-//\t\t\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "-//\t\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-//\t\t\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t}", "-//\t\t\tif (memberTypes != null) {", "-//\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-//\t\t\t\t\tmemberTypes[i].analyseCode(scope);", "-//\t\t\t\t}", "-//\t\t\t}", "-//\t\t\tif (methods != null) {", "-//\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//\t\t\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-//\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-//\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-//\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "-//\t\t\t\t\t\tcontinue;", "-//\t\t\t\t\tif (method.isInitializationMethod()) {", "-//\t\t\t\t\t\tif (method.isStatic()) { // <clinit>", "-//\t\t\t\t\t\t\t((Clinit)method).analyseCode(", "-//\t\t\t\t\t\t\t\tscope, ", "-//\t\t\t\t\t\t\t\tstaticInitializerContext, ", "-//\t\t\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));", "-//\t\t\t\t\t\t} else { // constructor", "-//\t\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t} else { // regular method", "-//\t\t\t\t\t\tmethod.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t}", "-\t\t};", "+\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c9250bad36f96c8d7265404661b25319", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java", "commitBeforeChange": "e6bf96fd82847410c46479a652f4e58f9a6dd052", "commitAfterChange": "5e8c3183792bb167a28b31bd623b66ded11f658d", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " \tpublic void analyseCode(ClassScope enclosingClassScope)", "signatureAfterChange": " \tpublic void analyseCode(ClassScope enclosingClassScope)", "diff": ["-//\t\t\tFlowInfo flowInfo = FlowInfo.initial(maxFieldCount); // start fresh init info", "-//", "-//\t\t\tReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception", "-//\t\t\tInitializationFlowContext initializerContext =", "-//\t\t\t\tnew InitializationFlowContext(null, this, initializerScope);", "-//\t\t\tInitializationFlowContext staticInitializerContext =", "-//\t\t\t\tnew InitializationFlowContext(null, this, staticInitializerScope);", "-//", "-//\t\t\tFlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//\t\t\tFlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//", "-//\t\t\tif (fields != null) {", "-//\t\t\t\tfor (int i = 0, count = fields.length; i < count; i++) {", "-//\t\t\t\t\tFieldDeclaration field = fields[i];", "-//\t\t\t\t\tif (field.isStatic()) {", "-//\t\t\t\t\t\t/*if (field.isField()){", "-//\t\t\t\t\t\t\tstaticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-//\t\t\t\t\t\t} else {*/", "-//\t\t\t\t\t\tstaticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-//\t\t\t\t\t\t/*}*/", "-//\t\t\t\t\t\tstaticFieldInfo =", "-//\t\t\t\t\t\t\tfield.analyseCode(", "-//\t\t\t\t\t\t\t\tstaticInitializerScope,", "-//\t\t\t\t\t\t\t\tstaticInitializerContext,", "-//\t\t\t\t\t\t\t\tstaticFieldInfo);", "-//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-//\t\t\t\t\t\tif (staticFieldInfo == FlowInfo.DEAD_END) {", "-//\t\t\t\t\t\t\tstaticInitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-//\t\t\t\t\t\t\tstaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t} else {", "-//\t\t\t\t\t\t/*if (field.isField()){", "-//\t\t\t\t\t\t\tinitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2", "-//\t\t\t\t\t\t} else {*/", "-//\t\t\t\t\t\t\tinitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them", "-//\t\t\t\t\t\t/*}*/", "-//\t\t\t\t\t\tnonStaticFieldInfo = field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);", "-//\t\t\t\t\t\t// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable", "-//\t\t\t\t\t\t// branch, since the previous initializer already got the blame.", "-//\t\t\t\t\t\tif (nonStaticFieldInfo == FlowInfo.DEAD_END) {", "-//\t\t\t\t\t\t\tinitializerScope.problemReporter().initializerMustCompleteNormally(field);", "-//\t\t\t\t\t\t\tnonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t}", "-//\t\t\tif (memberTypes != null) {", "-//\t\t\t\tfor (int i = 0, count = memberTypes.length; i < count; i++) {", "-//\t\t\t\t\tmemberTypes[i].analyseCode(scope);", "-//\t\t\t\t}", "-//\t\t\t}", "-//\t\t\tif (methods != null) {", "-//\t\t\t\tUnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();", "-//\t\t\t\tFlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);", "-//\t\t\t\tfor (int i = 0, count = methods.length; i < count; i++) {", "-//\t\t\t\t\tAbstractMethodDeclaration method = methods[i];", "-//\t\t\t\t\tif (method.ignoreFurtherInvestigation)", "-//\t\t\t\t\t\tcontinue;", "-//\t\t\t\t\tif (method.isInitializationMethod()) {", "-//\t\t\t\t\t\tif (method.isStatic()) { // <clinit>", "-//\t\t\t\t\t\t\t((Clinit)method).analyseCode(", "-//\t\t\t\t\t\t\t\tscope, ", "-//\t\t\t\t\t\t\t\tstaticInitializerContext, ", "-//\t\t\t\t\t\t\t\tstaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));", "-//\t\t\t\t\t\t} else { // constructor", "-//\t\t\t\t\t\t\t((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());", "-//\t\t\t\t\t\t}", "-//\t\t\t\t\t} else { // regular method", "-//\t\t\t\t\t\tmethod.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));", "-//\t\t\t\t\t}", "-//\t\t\t\t}", "-//\t\t\t}", "-\t\t};", "+\t\t}"]}], "num": 65692}