{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7988f0f8deee601af5f0194ac85612e4", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "1d99856b7d0f759ebdff0ec86bb1f1a7", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "6a300d21464d2fe06e2fb97a05726aa4bf91f99a", "commitAfterChange": "a32ab9844c9785077bc7ead2e7a3b745b89de636", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " protected void locateMatches(JavaProject javaProject, PossibleMatch[] possibleMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PossibleMatch[] possibleMatches, int start, int length) throws JavaModelException", "diff": ["+\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\tboolean bindingsWereCreated = true;", "-\t\tthis.nameLookup.setUnitsToLookInside(this.workingCopies);", "+\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\tbuildBindings(possibleMatches[i]);", "+\t\tlookupEnvironment.completeTypeBindings();", "-\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\t\tboolean bindingsWereCreated = true;", "+\t\t// create hierarchy resolver if needed", "+\t\tIType focusType = getFocusType();", "+\t\tif (focusType == null) {", "+\t\t\tthis.hierarchyResolver = null;", "+\t\t} else if (!createHierarchyResolver(focusType, possibleMatches)) {", "+\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t}", "+\t} catch (AbortCompilation e) {", "+\t\tbindingsWereCreated = false;", "+\t}", "+", "+\t// possible match resolution", "+\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\tthrow new OperationCanceledException();", "+\t\tPossibleMatch possibleMatch = this.matchesToProcess[i];", "+\t\tthis.matchesToProcess[i] = null; // release reference to processed possible match", "-\t\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "-\t\t\t\tbuildBindings(possibleMatches[i]);", "-\t\t\tlookupEnvironment.completeTypeBindings();", "-", "-\t\t\t// create hierarchy resolver if needed", "-\t\t\tIType focusType = getFocusType();", "-\t\t\tif (focusType == null) {", "-\t\t\t\tthis.hierarchyResolver = null;", "-\t\t\t} else if (!createHierarchyResolver(focusType, possibleMatches)) {", "-\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "-\t\t\t}", "+\t\t\tprocess(possibleMatch, bindingsWereCreated);", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t} catch (JavaModelException e) {", "+\t\t\t// problem with class path: it could not find base classes", "+\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\tbindingsWereCreated = false;", "+\t\t} catch (CoreException e) {", "+\t\t\t// core exception thrown by client's code: let it through", "+\t\t\tthrow new JavaModelException(e);", "+\t\t} finally {", "+\t\t\tif (this.options.verbose)", "+\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\tnew String(possibleMatch.parsedUnit.getFileName())}));", "+\t\t\t// cleanup compilation unit result", "+\t\t\tpossibleMatch.parsedUnit.cleanUp();", "+\t\t\tpossibleMatch.parsedUnit = null;", "-", "-\t\t// possible match resolution", "-\t\tfor (int i = 0; i < this.numberOfMatches; i++) {", "-\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "-\t\t\t\tthrow new OperationCanceledException();", "-\t\t\tPossibleMatch possibleMatch = this.matchesToProcess[i];", "-\t\t\tthis.matchesToProcess[i] = null; // release reference to processed possible match", "-\t\t\ttry {", "-\t\t\t\tprocess(possibleMatch, bindingsWereCreated);", "-\t\t\t} catch (AbortCompilation e) {", "-\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\tbindingsWereCreated = false;", "-\t\t\t} catch (JavaModelException e) {", "-\t\t\t\t// problem with class path: it could not find base classes", "-\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\t\tbindingsWereCreated = false;", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\t// core exception thrown by client's code: let it through", "-\t\t\t\tthrow new JavaModelException(e);", "-\t\t\t} finally {", "-\t\t\t\tif (this.options.verbose)", "-\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\t\tnew String[] {", "-\t\t\t\t\t\t\tString.valueOf(i + 1),", "-\t\t\t\t\t\t\tString.valueOf(numberOfMatches),", "-\t\t\t\t\t\t\tnew String(possibleMatch.parsedUnit.getFileName())}));", "-\t\t\t\t// cleanup compilation unit result", "-\t\t\t\tpossibleMatch.parsedUnit.cleanUp();", "-\t\t\t\tpossibleMatch.parsedUnit = null;", "-\t\t\t}", "-\t\t\tif (this.progressMonitor != null)", "-\t\t\t\tthis.progressMonitor.worked(5);", "-\t\t}", "-\t} finally {", "-\t\tthis.nameLookup.setUnitsToLookInside(null);", "+\t\tif (this.progressMonitor != null)", "+\t\t\tthis.progressMonitor.worked(5);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "fda884a5a0a56bef341761c34f5f8862", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "b7f88e87f49f0610756dfbedb8e57185924f0ebb", "commitAfterChange": "386549a68b724ddc22b4fffcf50fe779bbe728e1", "methodNumberBeforeChange": 22, "methodNumberAfterChange": 22, "signatureBeforeChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "signatureAfterChange": " protected void locateMatches(JavaProject javaProject, PotentialMatch[] potentialMatches, int start, int length) throws JavaModelException", "diff": ["+\t", "-", "-\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "-\tboolean bindingsWereCreated = true;", "-\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "-\t\t\tbuildBindings(potentialMatches[i]);", "-\t\tlookupEnvironment.completeTypeBindings();", "-", "-\t\t// create hierarchy resolver if needed", "-\t\tIType focusType = getFocusType();", "-\t\tif (focusType == null) {", "-\t\t\tthis.hierarchyResolver = null;", "-\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "-\t\t\t// focus type is not visible, use the super type names instead of the bindings", "-\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "-\t\t}", "-\t} catch (AbortCompilation e) {", "-\t\tbindingsWereCreated = false;", "-\t}", "-", "-\t// potential match resolution", "-\tfor (int i = 0; i < this.numberOfMatches; i++) {", "-\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "-\t\t\tthrow new OperationCanceledException();", "-\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "-\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\tthis.nameLookup.setUnitsToLookInside(this.workingCopies);", "+\t", "+\t\t// create and resolve binding (equivalent to beginCompilation() in Compiler)", "+\t\tboolean bindingsWereCreated = true;", "-\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t\tfor (int i = start, maxUnits = start + length; i < maxUnits; i++)", "+\t\t\t\tbuildBindings(potentialMatches[i]);", "+\t\t\tlookupEnvironment.completeTypeBindings();", "+\t", "+\t\t\t// create hierarchy resolver if needed", "+\t\t\tIType focusType = getFocusType();", "+\t\t\tif (focusType == null) {", "+\t\t\t\tthis.hierarchyResolver = null;", "+\t\t\t} else if (!createHierarchyResolver(focusType, potentialMatches)) {", "+\t\t\t\t// focus type is not visible, use the super type names instead of the bindings", "+\t\t\t\tif (computeSuperTypeNames(focusType) == null) return;", "+\t\t\t}", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t} catch (JavaModelException e) {", "-\t\t\t// problem with class path: it could not find base classes", "-\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "-\t\t\tbindingsWereCreated = false;", "-\t\t} catch (CoreException e) {", "-\t\t\t// core exception thrown by client's code: let it through", "-\t\t\tthrow new JavaModelException(e);", "-\t\t} finally {", "-\t\t\tif (this.options.verbose)", "-\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "-\t\t\t\t\tnew String[] {", "-\t\t\t\t\t\tString.valueOf(i + 1),", "-\t\t\t\t\t\tString.valueOf(numberOfMatches),", "-\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "-\t\t\t// cleanup compilation unit result", "-\t\t\tpotentialMatch.parsedUnit.cleanUp();", "-\t\t\tpotentialMatch.parsedUnit = null;", "-\t\tif (this.progressMonitor != null)", "-\t\t\tthis.progressMonitor.worked(5);", "+\t", "+\t\t// potential match resolution", "+\t\tfor (int i = 0; i < this.numberOfMatches; i++) {", "+\t\t\tif (this.progressMonitor != null && this.progressMonitor.isCanceled())", "+\t\t\t\tthrow new OperationCanceledException();", "+\t\t\tPotentialMatch potentialMatch = this.matchesToProcess[i];", "+\t\t\tthis.matchesToProcess[i] = null; // release reference to processed potential match", "+\t\t\ttry {", "+\t\t\t\tprocess(potentialMatch, bindingsWereCreated);", "+\t\t\t} catch (AbortCompilation e) {", "+\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\tbindingsWereCreated = false;", "+\t\t\t} catch (JavaModelException e) {", "+\t\t\t\t// problem with class path: it could not find base classes", "+\t\t\t\t// continue and try next matching openable reporting innacurate matches (since bindings will be null)", "+\t\t\t\tbindingsWereCreated = false;", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\t// core exception thrown by client's code: let it through", "+\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t} finally {", "+\t\t\t\tif (this.options.verbose)", "+\t\t\t\t\tSystem.out.println(Util.bind(\"compilation.done\", //$NON-NLS-1$", "+\t\t\t\t\t\tnew String[] {", "+\t\t\t\t\t\t\tString.valueOf(i + 1),", "+\t\t\t\t\t\t\tString.valueOf(numberOfMatches),", "+\t\t\t\t\t\t\tnew String(potentialMatch.parsedUnit.getFileName())}));", "+\t\t\t\t// cleanup compilation unit result", "+\t\t\t\tpotentialMatch.parsedUnit.cleanUp();", "+\t\t\t\tpotentialMatch.parsedUnit = null;", "+\t\t\t}", "+\t\t\tif (this.progressMonitor != null)", "+\t\t\t\tthis.progressMonitor.worked(5);", "+\t\t}", "+\t} finally {", "+\t\tthis.nameLookup.setUnitsToLookInside(null);"]}], "num": 27246}