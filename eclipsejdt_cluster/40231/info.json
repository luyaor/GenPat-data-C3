{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7ef6fce6133d1ce15674c56d8763557b", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "0339fc7d8f8be0120db01c9df89a437c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java", "commitBeforeChange": "d827489386a0080be2baf2be380c0f3630a2f239", "commitAfterChange": "b0e22c1c1f34d79e167c112a42cdff6b01498911", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": "  \tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "signatureAfterChange": "  public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo)", "diff": ["+", "+public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "+\t// process the condition", "+\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "+\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "+", "+\tConstant cst = this.condition.optimizedBooleanConstant();", "+\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "+\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "+", "+\t// process the THEN part", "+\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (isConditionOptimizedFalse) {", "+\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "+\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "+\tif (isConditionOptimizedTrue) {", "+\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-", "-\tpublic FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {", "-\t\t// process the condition", "-\t\tFlowInfo conditionFlowInfo = this.condition.analyseCode(currentScope, flowContext, flowInfo);", "-\t\tint initialComplaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;", "-", "-\t\tConstant cst = this.condition.optimizedBooleanConstant();", "-\t\tboolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;", "-\t\tboolean isConditionOptimizedFalse = cst != Constant.NotAConstant && cst.booleanValue() == false;", "-", "-\t\t// process the THEN part", "-\t\tFlowInfo thenFlowInfo = conditionFlowInfo.safeInitsWhenTrue();", "+\tif (this.thenStatement != null) {", "+\t\t// Save info for code gen", "+\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tthenFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tFlowInfo elseFlowInfo = conditionFlowInfo.initsWhenFalse();", "-\t\tif (isConditionOptimizedTrue) {", "-\t\t\telseFlowInfo.setReachMode(FlowInfo.UNREACHABLE);", "-\t\t}", "-\t\tif (this.thenStatement != null) {", "-\t\t\t// Save info for code gen", "-\t\t\tthis.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);", "-\t\t\tif (this.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel);", "-\t\t// code gen: optimizing the jump around the ELSE part", "-\t\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "-\t\t\tthis.bits |= ASTNode.ThenExit;", "-\t\t}", "-", "-\t\t// process the ELSE part", "-\t\tif (this.elseStatement != null) {", "-\t\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "-\t\t    if (thenFlowInfo == FlowInfo.DEAD_END", "-\t\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "-\t\t            && !(this.elseStatement instanceof IfStatement)) {", "-\t\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "-\t\t    }", "-\t\t\t// Save info for code gen", "-\t\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "-\t\t\tif (this.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel) < Statement.COMPLAINED_UNREACHABLE) {", "-\t\t\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "-\t\t\t}", "-\t\t}", "-", "-\t\t// merge THEN & ELSE initializations", "-\t\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "-\t\t\tthenFlowInfo,", "-\t\t\tisConditionOptimizedTrue,", "-\t\t\telseFlowInfo,", "-\t\t\tisConditionOptimizedFalse,", "-\t\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "-\t\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "-\t\treturn mergedInfo;", "+\t\tthenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);", "+\t}", "+\t// code gen: optimizing the jump around the ELSE part", "+\tif ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {", "+\t\tthis.bits |= ASTNode.ThenExit;", "+\t// process the ELSE part", "+\tif (this.elseStatement != null) {", "+\t    // signal else clause unnecessarily nested, tolerate else-if code pattern", "+\t    if (thenFlowInfo == FlowInfo.DEAD_END", "+\t            && (this.bits & IsElseIfStatement) == 0 \t// else of an else-if", "+\t            && !(this.elseStatement instanceof IfStatement)) {", "+\t        currentScope.problemReporter().unnecessaryElse(this.elseStatement);", "+\t    }", "+\t\t// Save info for code gen", "+\t\tthis.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);", "+\t\tif (isConditionOptimizedTrue) {", "+\t\t\tif (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {", "+\t\t\t\tthis.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel);", "+\t\t\t}", "+\t\telseFlowInfo = this.elseStatement.analyseCode(currentScope, flowContext, elseFlowInfo);", "+\t}", "+\t// merge THEN & ELSE initializations", "+\tFlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(", "+\t\tthenFlowInfo,", "+\t\tisConditionOptimizedTrue,", "+\t\telseFlowInfo,", "+\t\tisConditionOptimizedFalse,", "+\t\ttrue /*if(true){ return; }  fake-reachable(); */);", "+\tthis.mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);", "+\treturn mergedInfo;", "+}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "724b247079576a6e921f8b32fb2cd5d2", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "9a1059fe76216670b8b967bb606268c00c49c5d6", "commitAfterChange": "48d5cc392e6d910c33f7049ee7ced65653038398", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic synchronized IMethodBinding[] getDeclaredMethods()", "signatureAfterChange": " \tpublic synchronized IMethodBinding[] getDeclaredMethods()", "diff": ["-\t\t\t\t\tint removeSyntheticsCounter = 0;", "+\t\t\t\t\tint convertedMethodCount = 0;", "-\t\t\t\t\t\tif (!shouldBeRemoved(methodBinding)) {", "-\t\t\t\t\t\t\tIMethodBinding methodBinding2 = this.resolver.getMethodBinding(methodBinding);", "-\t\t\t\t\t\t\tif (methodBinding2 != null) {", "-\t\t\t\t\t\t\t\tnewMethods[removeSyntheticsCounter++] = methodBinding2;", "-\t\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (methodBinding.isDefaultAbstract() || methodBinding.isSynthetic() || (methodBinding.isConstructor() && isInterface())) {", "+\t\t\t\t\t\t\tcontinue;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tIMethodBinding methodBinding2 = this.resolver.getMethodBinding(methodBinding);", "+\t\t\t\t\t\tif (methodBinding2 != null) {", "+\t\t\t\t\t\t\tnewMethods[convertedMethodCount++] = methodBinding2;", "-\t\t\t\t\tif (removeSyntheticsCounter != length) {", "-\t\t\t\t\t\tSystem.arraycopy(newMethods, 0, (newMethods = new IMethodBinding[removeSyntheticsCounter]), 0, removeSyntheticsCounter);", "+\t\t\t\t\tif (convertedMethodCount != length) {", "+\t\t\t\t\t\tif (convertedMethodCount == 0) {", "+\t\t\t\t\t\t\treturn this.methods = NO_METHOD_BINDINGS;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tSystem.arraycopy(newMethods, 0, (newMethods = new IMethodBinding[convertedMethodCount]), 0, convertedMethodCount);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a3760fc740fb217df1e4e8a05e4b75f8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java", "commitBeforeChange": "ec12553ca5ec05e5d29ae2df78ae2ebf9cac1065", "commitAfterChange": "165d2ee0a4a374ec3dbb0f3df780db24664ac692", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 5, "signatureBeforeChange": " public int match(TypeDeclaration node, MatchingNodeSet nodeSet)", "signatureAfterChange": " public int match(MessageSend msgSend, MatchingNodeSet nodeSet)", "diff": ["+ */", "+public int match(MessageSend msgSend, MatchingNodeSet nodeSet)  {", "+\tif ((msgSend.bits & ASTNode.InsideJavadoc) == 0) return IMPOSSIBLE_MATCH;", "+\tif (this.pattern.declaringSimpleName == null || CharOperation.equals(msgSend.selector, this.pattern.declaringSimpleName)) {", "+\t\treturn nodeSet.addMatch(msgSend, ((InternalSearchPattern)this.pattern).mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);", "+\t}", "+\treturn IMPOSSIBLE_MATCH;", "+}"]}], "num": 40231}