{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "ce095f669f8849723f028374a999f84d", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "318ce57592e86f876218814ef9899a5d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java", "commitBeforeChange": "fe024fd7797ce73b0a83969f685073606863b79e", "commitAfterChange": "124641ac651bbea2bd062a9605817d39b473bf0e", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 5, "signatureBeforeChange": "  \tpublic void resolveDocument()", "signatureAfterChange": " \t \tpublic void resolveDocument()", "diff": ["-", "-\tpublic void resolveDocument() {", "-\t\tIPath path = new Path(this.document.getPath());", "-\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));", "-\t\tJavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "-\t\tJavaProject javaProject = (JavaProject) model.getJavaProject(project);", "-\t\ttry {", "-\t\t\tCancelableNameEnvironment nameEnvironment;", "-\t\t\tnameEnvironment = new CancelableNameEnvironment(javaProject, DefaultWorkingCopyOwner.PRIMARY, null);", "-\t\t\tthis.options = new CompilerOptions(javaProject.getOptions(true));", "-\t\t\tthis.problemReporter =", "-\t\t\t\t\tnew ProblemReporter(", "-\t\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "-\t\t\t\t\t\tthis.options,", "-\t\t\t\t\t\tnew DefaultProblemFactory());", "-\t\t\tthis.lookupEnvironment = new LookupEnvironment(this, this.options, this.problemReporter, nameEnvironment);", "-\t\t} catch (JavaModelException e) {", "-\t\t\tif (JobManager.VERBOSE) {", "-\t\t\t\te.printStackTrace();", "-\t\t\t}", "-\t\t\tthis.cu = null;", "-\t\t\treturn;", "-\t\t}", "-\t\tthis.lookupEnvironment.buildTypeBindings(this.cu, null);", "-\t\tthis.lookupEnvironment.completeTypeBindings();", "-\t\tif (this.cu.scope != null) {", "-\t\t\tthis.cu.scope.faultInTypes();", "-\t\t\tthis.cu.resolve();", "+\tpublic void resolveDocument() {", "+\t\ttry {", "+\t\t\tIPath path = new Path(this.document.getPath());", "+\t\t\tIProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));", "+\t\t\tJavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();", "+\t\t\tJavaProject javaProject = (JavaProject) model.getJavaProject(project);", "+", "+\t\t\tthis.options = new CompilerOptions(javaProject.getOptions(true));", "+\t\t\tProblemReporter problemReporter =", "+\t\t\t\t\tnew ProblemReporter(", "+\t\t\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),", "+\t\t\t\t\t\t\tthis.options,", "+\t\t\t\t\t\t\tnew DefaultProblemFactory());", "+", "+\t\t\t// Re-parse using normal parser, IndexingParser swallows several nodes, see comment above class.", "+\t\t\tthis.basicParser = new Parser(problemReporter, false);", "+\t\t\tthis.cud = this.basicParser.parse(this.compilationUnit, new CompilationResult(this.compilationUnit, 0, 0, this.options.maxProblemsPerUnit));", "+", "+\t\t\t// Use a non model name environment to avoid locks, monitors and such.", "+\t\t\tINameEnvironment nameEnvironment = new JavaSearchNameEnvironment(javaProject, JavaModelManager.getJavaModelManager().getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY, true/*add primary WCs*/));", "+\t\t\tthis.lookupEnvironment = new LookupEnvironment(this, this.options, problemReporter, nameEnvironment);", "+", "+\t\t\tthis.lookupEnvironment.buildTypeBindings(this.cud, null);", "+\t\t\tthis.lookupEnvironment.completeTypeBindings();", "+\t\t\tthis.cud.scope.faultInTypes();", "+\t\t\tthis.cud.resolve();", "+\t\t} catch (Exception e) {", "+\t\t\tif (JobManager.VERBOSE) {", "+\t\t\t\te.printStackTrace();", "+\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90c32cae9542fc417fdd00891970dd1a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \tpublic void resolve(BlockScope upperScope)", "signatureAfterChange": "  \tpublic void resolve(BlockScope upperScope)", "diff": ["-\t\t\tTypeBinding testType = expression.resolveType(upperScope);", "-\t\t\tif (testType == null)", "+\t\t\tTypeBinding expressionType = expression.resolveType(upperScope);", "+\t\t\tif (expressionType == null)", "-\t\t\texpression.computeConversion(upperScope, testType, testType);", "-\t\t\tif (!(expression.isConstantValueOfTypeAssignableToType(testType, IntBinding))) {", "-\t\t\t\tif (!testType.isCompatibleWith(IntBinding)) {", "-\t\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, testType);", "-\t\t\t\t\treturn;", "-\t\t\t\t}", "+\t\t\texpression.computeConversion(upperScope, expressionType, expressionType);", "+\t\t\tcheckType: {", "+\t\t\t\tif (expressionType.isBaseType()) {", "+\t\t\t\t\tif (expression.isConstantValueOfTypeAssignableToType(expressionType, IntBinding))", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t\tif (expressionType.isCompatibleWith(IntBinding))", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\t} else if (expressionType.isEnum())", "+\t\t\t\t\t\tbreak checkType;", "+\t\t\t\tupperScope.problemReporter().incorrectSwitchType(expression, expressionType);", "+\t\t\t\t// TODO (philippe) could keep analyzing switch statements in case of error", "+\t\t\t\treturn;", "-\t\t\t\tint[] casesValues = new int[length];", "+\t\t\t\tthis.constants = new int[length];", "-\t\t\t\t\tif ((constant = statement.resolveCase(scope, testType, this)) != null) {", "+\t\t\t\t\tif ((constant = statement.resolveCase(scope, expressionType, this)) != Constant.NotAConstant) {", "+\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\tif (constant != NotAConstant) {", "-\t\t\t\t\t\t\tint key = constant.intValue();", "-\t\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "-\t\t\t\t\t\t\t\tif (casesValues[j] == key) {", "-\t\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "-\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "+\t\t\t\t\t\tfor (int j = 0; j < counter; j++) {", "+\t\t\t\t\t\t\tif (this.constants[j] == key) {", "+\t\t\t\t\t\t\t\tfinal CaseStatement currentCaseStatement = (CaseStatement) statement;", "+\t\t\t\t\t\t\t\tif (duplicateCaseStatements == null) {", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(cases[j]);", "+\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "+\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "+\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\tboolean found = false;", "+\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "+\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "+\t\t\t\t\t\t\t\t\t\t\tfound = true;", "+\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "+\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements = new CaseStatement[length];", "-\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];", "-\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\tboolean found = false;", "-\t\t\t\t\t\t\t\t\t\tsearchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {", "-\t\t\t\t\t\t\t\t\t\t\tif (duplicateCaseStatements[k] == statement) {", "-\t\t\t\t\t\t\t\t\t\t\t\tfound = true;", "-\t\t\t\t\t\t\t\t\t\t\t\tbreak searchReportedDuplicate;", "-\t\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\tif (!found) {", "-\t\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateCase(currentCaseStatement);", "-\t\t\t\t\t\t\t\t\t\t\tduplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tcasesValues[counter++] = key;", "+\t\t\t\t\t\tthis.constants[counter++] = key;", "+\t\t\t\tif (length != counter) { // resize constants array", "+\t\t\t\t\tSystem.arraycopy(this.constants, 0, this.constants = new int[counter], 0, counter);", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a6e759ef27a7175297c20d41e52647c3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java", "commitBeforeChange": "a73c1b70646c33788c416636d54ca7b824b36c44", "commitAfterChange": "89bcdbe3377ffa239857ce6e220c3e9a2f048f0c", "methodNumberBeforeChange": 45, "methodNumberAfterChange": 44, "signatureBeforeChange": "   \tprivate void printIndentationIfNecessary(StringBuffer buffer)", "signatureAfterChange": "  \tprivate void printIndentationIfNecessary(StringBuffer buffer)", "diff": ["-", "-\t\tint indentationColumn = (this.useTab ? this.indentationLevel * this.tabSize : this.indentationLevel)+1;", "-\t\tif (this.column < indentationColumn) {", "-\t\t\tfor (int i = getColumnIndentationLevel(), max = this.indentationLevel; i < max; i++) { ", "-\t\t\t\tif (this.useTab) {", "-\t\t\t\t\tthis.tab(buffer);", "-\t\t\t\t} else {", "-\t\t\t\t\tthis.column++;", "-\t\t\t\t\tbuffer.append(this.fillingSpace);", "-\t\t\t\t\tthis.needSpace = false;", "-\t\t\t\t}", "+\t\t// where do we want to go (will round up to the next tab stop if snapToTabs == true)", "+\t\tint wantedIndentation= getNextIndentationLevel(this.indentationLevel + 1);", "+\t\twhile (this.column - 1 < this.indentationLevel) {", "+\t\t\t// where would we get by appending a tab?", "+\t\t\tint nextTabIndentation= this.column - 1 + (this.tabLength - ((this.column - 1) % this.tabLength));", "+\t\t\tif (this.useTab && nextTabIndentation <= wantedIndentation) {", "+\t\t\t\tbuffer.append('\\t');", "+\t\t\t\tthis.lastNumberOfNewLines = 0;", "+\t\t\t\tint complement = this.tabLength - ((this.column - 1) % this.tabLength); // amount of space", "+\t\t\t\tthis.column += complement;", "+\t\t\t} else {", "+\t\t\t\tbuffer.append(this.fillingSpace);", "+\t\t\t\tthis.column++;", "+\t\t\tthis.needSpace = false;"]}], "num": 56260}