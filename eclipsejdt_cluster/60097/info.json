{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "2eec960bc684c1aa84d5824bafafadb1", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "93aabd25cb61c0f0802f66eb39b5e900", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "9a9af4e642a47932f3bfeeec13330339dcc48de3", "commitAfterChange": "c3ad34ec44b228feb09e91ff5ac00fc774236d05", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\tTypeBinding methodTypeErasure = method.returnType == null ? null : method.returnType.erasure();", "+\t\t\t\tTypeBinding returnErasure = method.returnType == null ? null : method.returnType.erasure();", "-\t\t\t\tnextOtherMethod: for (int j = length - 1; j > i; j--) {", "-\t\t\t\t\tMethodBinding otherMethod = methods[j];", "-\t\t\t\t\t// check collision with otherMethod", "-\t\t\t\t\tif (otherMethod == null) ", "-\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\tif (!CharOperation.equals(selector, otherMethod.selector))", "-\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\tnextMethod : for (int j = length - 1; j > i; j--) {", "+\t\t\t\t\tMethodBinding method2 = methods[j];", "+\t\t\t\t\tif (method2 == null || !CharOperation.equals(selector, method2.selector))", "+\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\tTypeBinding otherMethodTypeErasure = otherMethod.returnType == null ? null : otherMethod.returnType.erasure();", "-\t\t\t\t\t\tif (methodTypeErasure != otherMethodTypeErasure) {", "-\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables && otherMethod.typeVariables != NoTypeVariables) {", "-\t\t\t\t\t\t\t\t// for generic methods, no need to check arguments", "-\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "-\t\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "-\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tif (!method.areParameterErasuresEqual(otherMethod))", "-\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\tif (returnErasure != (method2.returnType == null ? null : method2.returnType.erasure())) {", "+\t\t\t\t\t\t\t // colllision when parameters are identical & type variable erasures match", "+\t\t\t\t\t\t\tif (!method.areParametersEqual(method2))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\tif (!method.areTypeVariableErasuresEqual(method2))", "+\t\t\t\t\t\t\t\tif (method.typeVariables.length > 0 && method2.typeVariables.length > 0)", "+\t\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t} else if (!method.areParameterErasuresEqual(method2)) { // colllision when parameter & return type erasures match", "+\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\t// prior to 1.5, parameter match is enough for collision", "-\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "-\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t} else if (!method.areParametersEqual(method2)) { // prior to 1.5, parameter identity meant a collision case", "+\t\t\t\t\t\tcontinue nextMethod;", "+", "-\t\t\t\t\tAbstractMethodDeclaration otherMethodDecl = otherMethod.sourceMethod();", "-\t\t\t\t\tif (otherMethodDecl != null && otherMethodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\tAbstractMethodDeclaration method2Decl = method2.sourceMethod();", "+\t\t\t\t\tif (method2Decl != null && method2Decl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, otherMethodDecl);", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);", "-\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, otherMethodDecl);", "-\t\t\t\t\t\totherMethodDecl.binding = null;", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "+\t\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\tif (methodTypeErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions", "+\t\t\t\tif (returnErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e5f2884cd912987c4e80e386b7ee25c4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java", "commitBeforeChange": "244829701e930ed5e8c032bf583662e3d16d3513", "commitAfterChange": "352a6d10b0265833df8f27de2e4e038afdaa31d6", "methodNumberBeforeChange": 34, "methodNumberAfterChange": 34, "signatureBeforeChange": " public MethodBinding[] methods()", "signatureAfterChange": " public MethodBinding[] methods()", "diff": ["-\t\t\t\tfor (int j = length - 1; j > i; j--) {", "-\t\t\t\t\tMethodBinding method2 = methods[j];", "-\t\t\t\t\tif (method2 != null && CharOperation.equals(selector, method2.selector)) {", "-\t\t\t\t\t\tboolean paramsMatch = complyTo15 && methodTypeErasure == (method2.returnType == null ? null : method2.returnType.erasure()) // see 87956 & 88094", "-\t\t\t\t\t\t\t? method.areParameterErasuresEqual(method2)", "-\t\t\t\t\t\t\t: method.areParametersEqual(method2);", "-\t\t\t\t\t\tif (paramsMatch) {", "-\t\t\t\t\t\t\tboolean isEnumSpecialMethod = isEnum()", "-\t\t\t\t\t\t\t\t&& (selector == TypeConstants.VALUEOF || selector == TypeConstants.VALUES);", "-\t\t\t\t\t\t\tif (methodDecl == null) {", "-\t\t\t\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special", "-\t\t\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "-\t\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "-\t\t\t\t\t\t\t\t\tmethodDecl.binding = null;", "-\t\t\t\t\t\t\t\t\tmethods[i] = null;", "-\t\t\t\t\t\t\t\t\tfailed++;", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tAbstractMethodDeclaration method2Decl = method2.sourceMethod();", "-\t\t\t\t\t\t\tif (method2Decl != null && method2Decl.binding != null) { // ensure its a valid user defined method", "-\t\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);", "-\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, method2Decl);", "-\t\t\t\t\t\t\t\tmethod2Decl.binding = null;", "-\t\t\t\t\t\t\t\tmethods[j] = null;", "-\t\t\t\t\t\t\t\tfailed++;", "-\t\t\t\t\t\t\t}", "+\t\t\t\tnextOtherMethod: for (int j = length - 1; j > i; j--) {", "+\t\t\t\t\tMethodBinding otherMethod = methods[j];", "+\t\t\t\t\t// check collision with otherMethod", "+\t\t\t\t\tif (otherMethod == null) ", "+\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\tif (!CharOperation.equals(selector, otherMethod.selector))", "+\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\tif (complyTo15) {", "+\t\t\t\t\t\tTypeBinding otherMethodTypeErasure = otherMethod.returnType == null ? null : otherMethod.returnType.erasure();", "+\t\t\t\t\t\tif (methodTypeErasure != otherMethodTypeErasure) {", "+\t\t\t\t\t\t\tif (method.typeVariables != NoTypeVariables && otherMethod.typeVariables != NoTypeVariables) {", "+\t\t\t\t\t\t\t\t// for generic methods, no need to check arguments", "+\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "+\t\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t\t\t}\t\t\t\t\t\t\t", "+\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\tif (!method.areParameterErasuresEqual(otherMethod))", "+\t\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\t// prior to 1.5, parameter match is enough for collision", "+\t\t\t\t\t\tif (!method.areParametersEqual(otherMethod)) ", "+\t\t\t\t\t\t\tcontinue nextOtherMethod;", "+\t\t\t\t\t}", "+\t\t\t\t\t// report duplicate", "+\t\t\t\t\tboolean isEnumSpecialMethod = isEnum()", "+\t\t\t\t\t\t&& (selector == TypeConstants.VALUEOF || selector == TypeConstants.VALUES);", "+\t\t\t\t\tif (methodDecl == null) {", "+\t\t\t\t\t\tmethodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special", "+\t\t\t\t\t\tif (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);", "+\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, methodDecl);", "+\t\t\t\t\t\t\tmethodDecl.binding = null;", "+\t\t\t\t\t\t\tmethods[i] = null;", "+\t\t\t\t\t\t\tfailed++;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tAbstractMethodDeclaration otherMethodDecl = otherMethod.sourceMethod();", "+\t\t\t\t\tif (otherMethodDecl != null && otherMethodDecl.binding != null) { // ensure its a valid user defined method", "+\t\t\t\t\t\tif (isEnumSpecialMethod)", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateEnumSpecialMethod(this, otherMethodDecl);", "+\t\t\t\t\t\telse", "+\t\t\t\t\t\t\tscope.problemReporter().duplicateMethodInType(this, otherMethodDecl);", "+\t\t\t\t\t\totherMethodDecl.binding = null;", "+\t\t\t\t\t\tmethods[j] = null;", "+\t\t\t\t\t\tfailed++;"]}], "num": 60097}