{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "a92a0196554e4a2d9be60ba74c4a7477", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "018a9b7e90318363753fbaee008bdc2c", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "e73037ff248454bfb7965c3990814d5ef5cb4620", "commitAfterChange": "cafb328a42240bc62f70f6b130384a29f0e8d16a", "methodNumberBeforeChange": 3, "methodNumberAfterChange": 3, "signatureBeforeChange": " private void buildMoreCompletionContext(Expression expression)", "signatureAfterChange": " private void buildMoreCompletionContext(Expression expression)", "diff": ["-\t\t\tcase K_OPERATOR :", "-//\t\t\t\tif(expressionPtr > 0) {", "-//\t\t\t\t\tExpression operatorExpression;", "-//\t\t\t\t\tswitch (info) {", "-//\t\t\t\t\t\tcase AND_AND :", "-//\t\t\t\t\t\t\toperatorExpression = new AND_AND_Expression(this.expressionStack[expressionPtr-1], expression, info);", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t\tcase OR_OR :", "-//\t\t\t\t\t\t\toperatorExpression = new OR_OR_Expression(this.expressionStack[expressionPtr-1], expression, info);", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t\tcase PLUS_PLUS :", "-//\t\t\t\t\t\tcase MINUS_MINUS :", "-//\t\t\t\t\t\t\toperatorExpression = new PrefixExpression(expression,IntLiteral.One,info, expression.sourceStart); ;", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t\tcase TWIDDLE:", "-//\t\t\t\t\t\tcase NOT:", "-//\t\t\t\t\t\t\toperatorExpression = new UnaryExpression(expression, info);", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t\tcase PLUS:", "-//\t\t\t\t\t\tcase MINUS:", "-//\t\t\t\t\t\t\t", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t\tdefault :", "-//\t\t\t\t\t\t\toperatorExpression = new BinaryExpression(this.expressionStack[expressionPtr-1], expression, info);", "-//\t\t\t\t\t\t\tbreak;", "-//\t\t\t\t\t}", "-//\t\t\t\t\tassistNodeParent = operatorExpression;", "-//\t\t\t\t}", "+\t\t\tcase K_UNARY_OPERATOR :", "+\t\t\t\tif(expressionPtr > -1) {", "+\t\t\t\t\tExpression operatorExpression = null;", "+\t\t\t\t\tswitch (info) {", "+\t\t\t\t\t\tcase PLUS_PLUS :", "+\t\t\t\t\t\t\toperatorExpression = new PrefixExpression(expression,IntLiteral.One, PLUS, expression.sourceStart);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase MINUS_MINUS :", "+\t\t\t\t\t\t\toperatorExpression = new PrefixExpression(expression,IntLiteral.One, MINUS, expression.sourceStart);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\toperatorExpression = new UnaryExpression(expression, info);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tif(operatorExpression != null) {", "+\t\t\t\t\t\tassistNodeParent = operatorExpression;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_BINARY_OPERATOR :", "+\t\t\t\tif(expressionPtr > 0) {", "+\t\t\t\t\tExpression operatorExpression = null;", "+\t\t\t\t\tswitch (info) {", "+\t\t\t\t\t\tcase AND_AND :", "+\t\t\t\t\t\t\toperatorExpression = new AND_AND_Expression(this.expressionStack[expressionPtr-1], expression, info);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase OR_OR :", "+\t\t\t\t\t\t\toperatorExpression = new OR_OR_Expression(this.expressionStack[expressionPtr-1], expression, info);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase EQUAL_EQUAL :", "+\t\t\t\t\t\tcase NOT_EQUAL :", "+\t\t\t\t\t\t\toperatorExpression = new EqualExpression(this.expressionStack[expressionPtr-1], expression, info);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tcase INSTANCEOF :", "+\t\t\t\t\t\t\t// should never occur", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\tdefault :", "+\t\t\t\t\t\t\toperatorExpression = new BinaryExpression(this.expressionStack[expressionPtr-1], expression, info);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t}", "+\t\t\t\t\tif(operatorExpression != null) {", "+\t\t\t\t\t\tassistNodeParent = operatorExpression;", "+\t\t\t\t\t}", "+\t\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "07e8bd05af03c0667acd1036d29eed5d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java", "commitBeforeChange": "a8001f94dedfcf0ea807d46ff48ed3d0c7a3c2ef", "commitAfterChange": "7e1b661f635897c28beea613ca1b58777d8c7c7a", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 42, "signatureBeforeChange": "  private boolean hasStructuralAnnotationChanges(IBinaryAnnotation[] currentAnnotations, IBinaryAnnotation[] otherAnnotations)", "signatureAfterChange": "  private boolean hasStructuralAnnotationChanges(IBinaryAnnotation[] currentAnnotations, IBinaryAnnotation[] otherAnnotations)", "diff": ["-\t\tif (!CharOperation.equals(currentAnnotations[i].getTypeName(), otherAnnotations[i].getTypeName()))", "-\t\t\treturn true;", "-\t\tIBinaryElementValuePair[] currentPairs = currentAnnotations[i].getElementValuePairs();", "-\t\tIBinaryElementValuePair[] otherPairs = otherAnnotations[i].getElementValuePairs();", "-\t\tint currentPairsLength = currentPairs == null ? 0 : currentPairs.length;", "-\t\tint otherPairsLength = otherPairs == null ? 0 : otherPairs.length;", "-\t\tif (currentPairsLength != otherPairsLength)", "-\t\t\treturn true;", "-\t\tfor (int j = 0; j < currentPairsLength; j++) {", "-\t\t\tif (!CharOperation.equals(currentPairs[j].getName(), otherPairs[j].getName()))", "-\t\t\t\treturn true;", "-\t\t\tfinal Object value = currentPairs[j].getValue();", "-\t\t\tfinal Object value2 = otherPairs[j].getValue();", "-\t\t\tif (value instanceof Object[]) {", "-\t\t\t\tObject[] currentValues = (Object[]) value;", "-\t\t\t\tif (value2 instanceof Object[]) {", "-\t\t\t\t\tObject[] currentValues2 = (Object[]) value2;", "-\t\t\t\t\tfinal int length = currentValues.length;", "-\t\t\t\t\tif (length != currentValues2.length) {", "-\t\t\t\t\t\treturn true;", "-\t\t\t\t\t}", "-\t\t\t\t\tfor (int n = 0; n < length; n++) {", "-\t\t\t\t\t\tif (!currentValues[n].equals(currentValues2[n])) {", "-\t\t\t\t\t\t\treturn true;", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-\t\t\t\treturn true;", "-\t\t\t} else if (!value.equals(value2)) {", "-\t\t\t\treturn true;", "-\t\t\t}", "-\t\t}", "+\t\tBoolean match = matchAnnotations(currentAnnotations[i], otherAnnotations[i]);", "+\t\tif (match != null)", "+\t\t\treturn match.booleanValue();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "10333b5e26dee5ea6728da5059215350", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "259752fd2611ae86a8e7deb13311cd77026ab6f4", "commitAfterChange": "4725cc4b92cda70d0724324edfd82ed8a46041bc", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 21, "signatureBeforeChange": "  \tprivate IBinding internalResolveNameForSimpleName(Name name)", "signatureAfterChange": "  \tprivate IBinding internalResolveNameForSimpleName(Name name)", "diff": ["-\t\tif (node instanceof SingleNameReference) {", "+\t\tif (node instanceof CompilationUnitDeclaration) {", "+\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = (CompilationUnitDeclaration) node;", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = compilationUnitDeclaration.types;", "+\t\t\tif (types == null || types.length == 0) {", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration type = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) types[0];", "+\t\t\tif (type != null) {", "+\t\t\t\tITypeBinding typeBinding = this.getTypeBinding(type.binding);", "+\t\t\t\tif (typeBinding == null) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\treturn typeBinding.getPackage();", "+\t\t\t}", "+\t\t} else if (node instanceof AbstractMethodDeclaration) {", "+\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;", "+\t\t\tif (methodDeclaration != null) {", "+\t\t\t\tIMethodBinding methodBinding = this.getMethodBinding(methodDeclaration.binding);", "+\t\t\t\tif (methodBinding == null) {", "+\t\t\t\t\treturn null;", "+\t\t\t\t}", "+\t\t\t\tthis.bindingsToAstNodes.put(methodBinding, node);", "+\t\t\t\treturn methodBinding;", "+\t\t\t}", "+\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;", "+\t\t\tITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);", "+\t\t\tif (typeBinding == null) {", "+\t\t\t\treturn null;", "+\t\t\t}", "+\t\t\tthis.bindingsToAstNodes.put(typeBinding, node);", "+\t\t\treturn typeBinding;", "+\t\t} if (node instanceof SingleNameReference) {", "-\t\t\tif (singleTypeReference.binding == null) {", "-\t\t\t\treturn null;", "-\t\t\t}", "-\t\t\treturn this.getTypeBinding(singleTypeReference.binding.leafComponentType());", "-\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) {", "-\t\t\torg.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration = (org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) node;", "-\t\t\treturn this.getVariableBinding(fieldDeclaration.binding);", "-\t\t}", "-\t\treturn null;", "-\t}", "+\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding binding = singleTypeReference.binding;", "+\t\t} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) {", "+\t\t\torg.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDeclaration = (org.eclipse.jdt.internal.compiler.ast.FieldDeclaration) node;", "+\t\t\treturn this.getVariableBinding(fieldDeclaration.binding);", "+\t\t} else if (node instanceof MessageSend) {", "+\t\t\tMessageSend messageSend = (MessageSend) node;", "+\t\t\treturn getMethodBinding(messageSend.binding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "2bc1db4bfd2290d4c425d84fc9a2d4da", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/antadapter/org/eclipse/jdt/core/JDTCompilerAdapter.java", "commitBeforeChange": "cdefa638776da3a046378c28559a0f9103ab4eaa", "commitAfterChange": "364f4a6fecddde86cbff58b22f5a3999ee18f64c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 2, "signatureBeforeChange": " \t \t \tprotected Commandline setupJavacCommand() throws BuildException", "signatureAfterChange": "  \tprotected Commandline setupJavacCommand() throws BuildException", "diff": ["-\t", "-\tprotected Commandline setupJavacCommand() throws BuildException {", "-\t\tCommandline cmd = new Commandline();", "-\t\t", "-\t\t/*", "-\t\t * This option is used to never exit at the end of the ant task. ", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "-", "-\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "-        if (bootclasspath != null && bootclasspath.size() != 0) {", "-\t\t\t/*", "-\t\t\t * Set the bootclasspath for the Eclipse compiler.", "-\t\t\t */", "-\t\t\tcmd.createArgument().setPath(bootclasspath);        \t", "-        } else {", "-            includeJavaRuntime = true;", "-        }", "-", "-        Path classpath = new Path(project);", "-", "-       /*", "-         * Eclipse compiler doesn't support -extdirs.", "-         * It is emulated using the classpath. We add extdirs entries after the ", "-         * bootclasspath.", "-         */", "-        addExtdirs(extdirs, classpath);", "-", "-\t\t/*", "-\t\t * The java runtime is already handled, so we simply want to retrieve the", "-\t\t * ant runtime and the compile classpath.", "-\t\t */", "-        classpath.append(getCompileClasspath());", "-", "-        // For -sourcepath, use the \"sourcepath\" value if present.", "-        // Otherwise default to the \"srcdir\" value.", "-        Path sourcepath = null;", "-        ", "-        // retrieve the method getSourcepath() using reflect", "-        // This is done to improve the compatibility to ant 1.5", "-        Class javacClass = Javac.class;", "-        Method getSourcepathMethod = null;", "-        try {", "-\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "-        } catch(NoSuchMethodException e) {", "-        \t// if not found, then we cannot use this method (ant 1.5)", "-        }", "-        Path compileSourcePath = null;", "-        if (getSourcepathMethod != null) {", "-\t \t\ttry {", "-\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(attributes, null);", "-\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t// should never happen", "-\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t// should never happen", "-\t\t\t}", "-        }", "-        if (compileSourcePath != null) {", "-            sourcepath = compileSourcePath;", "-        } else {", "-            sourcepath = src;", "-        }", "-\t\tclasspath.append(sourcepath);", "-\t\t/*", "-\t\t * Set the classpath for the Eclipse compiler.", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "-\t\tcmd.createArgument().setPath(classpath);", "-", "-        String memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\";//$NON-NLS-1$//$NON-NLS-2$", "-        if (memoryInitialSize != null) {", "-            if (!attributes.isForkedJavac()) {", "-                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-            } else {", "-                cmd.createArgument().setValue(memoryParameterPrefix", "-                                              + \"ms\" + memoryInitialSize); //$NON-NLS-1$", "-            }", "-        }", "-", "-        if (memoryMaximumSize != null) {", "-            if (!attributes.isForkedJavac()) {", "-                attributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "-            } else {", "-                cmd.createArgument().setValue(memoryParameterPrefix", "-                                              + \"mx\" + memoryMaximumSize); //$NON-NLS-1$", "-            }", "-        }", "-", "-        if (debug) {", "-\t       // retrieve the method getSourcepath() using reflect", "-\t        // This is done to improve the compatibility to ant 1.5", "-\t        Method getDebugLevelMethod = null;", "-\t        try {", "-\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "-\t        } catch(NoSuchMethodException e) {", "-\t        \t// if not found, then we cannot use this method (ant 1.5)", "-\t        \t// debug level is only available with ant 1.5.x", "-\t        }", "-     \t    String debugLevel = null;", "-\t        if (getDebugLevelMethod != null) {", "-\t\t\t\ttry {", "-\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(attributes, null);", "-\t\t\t\t} catch (IllegalAccessException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t} catch (InvocationTargetException e) {", "-\t\t\t\t\t// should never happen", "-\t\t\t\t}", "-        \t}", "-\t\t\tif (debugLevel != null) {", "-\t\t\t\tif (debugLevel.length() == 0) {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-\t\t\t\t} else {", "-\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "-\t\t\t\t}", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "-            }", "-        } else {", "-            cmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "-        }", "-        ", "-\t\t/*", "-\t\t * Handle the nowarn option. If none, then we generate all warnings.", "-\t\t */\t\t", "-        if (attributes.getNowarn()) {", "-\t\t\tif (deprecation) {", "-\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t            cmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "-\t\t\t}", "-        } else {", "-\t\t\t/*", "-\t\t\t * deprecation option.", "-\t\t\t */\t\t", "-\t\t\tif (deprecation) {", "-\t\t\t\tcmd.createArgument().setValue(", "-\t\t\t\t\t\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(", "-\t\t\t\t\t\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "-\t\t\t}", "-        }", "-", "-\t\t/*", "-\t\t * destDir option.", "-\t\t */\t\t", "-\t\tif (destDir != null) {", "-\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setFile(destDir.getAbsoluteFile());", "-\t\t}", "-", "-\t\t/*", "-\t\t * target option.", "-\t\t */\t\t", "-\t\tif (target != null) {", "-\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(target);", "-\t\t}", "-", "-\t\t/*", "-\t\t * verbose option", "-\t\t */", "-\t\tif (verbose) {", "-\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "-\t\t\t/*", "-\t\t\t * extra option allowed by the Eclipse compiler", "-\t\t\t */", "-\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "-\t\t\tlogFileName = destDir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "-\t\t\tcmd.createArgument().setValue(logFileName);", "-\t\t}", "-", "-\t\t/*", "-\t\t * failnoerror option", "-\t\t */", "-\t\tif (!attributes.getFailonerror()) {", "-\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "-\t\t}", "-", "-\t\t/*", "-\t\t * source option", "-\t\t */", "-\t\tString source = attributes.getSource();", "-        if (source != null) {", "-            cmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "-            cmd.createArgument().setValue(source);", "-        }", "-        ", "-\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "-\t\t\tif (target != null && target.equals(\"1.1\")) {\t\t\t   //$NON-NLS-1$\t", "-\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "-\t\t\t} else {", "-\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "-\t\t\t}", "-\t\t} else {", "-\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "-\t\t}", "-\t\t", "-\t\t/*", "-\t\t * encoding option", "-\t\t */", "-        if (encoding != null) {", "-            cmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "-            cmd.createArgument().setValue(encoding);", "-        }", "-", "-\t\t/*", "-\t\t * extra option allowed by the Eclipse compiler", "-\t\t */", "-\t\tcmd.createArgument().setValue(\"-time\"); //$NON-NLS-1$", "-", "-\t\t/*", "-\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "-\t\t * handled through the javac task that collects all source files in", "-\t\t * srcdir option.", "-\t\t */        ", "-        logAndAddFilesToCompile(cmd);", "-\t\treturn cmd;", "-\t}", "+", "+\tprotected Commandline setupJavacCommand() throws BuildException {", "+\t\tCommandline cmd = new Commandline();", "+", "+\t\t/*", "+\t\t * This option is used to never exit at the end of the ant task. ", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-noExit\"); //$NON-NLS-1$", "+", "+\t\tcmd.createArgument().setValue(\"-bootclasspath\"); //$NON-NLS-1$", "+\t\tfinal Javac javac = getJavac();", "+\t\tPath bootcp = javac.getBootclasspath();", "+\t\tif (bootcp != null && bootcp.size() != 0) {", "+\t\t\t/*", "+\t\t\t * Set the bootclasspath for the Eclipse compiler.", "+\t\t\t */", "+\t\t\tcmd.createArgument().setPath(bootcp);", "+\t\t} else {", "+\t\t\tjavac.setIncludejavaruntime(true);", "+\t\t}", "+", "+\t\tProject proj = javac.getProject();", "+\t\tPath classpath = new Path(proj);", "+", "+\t\t/*", "+\t\t * Eclipse compiler doesn't support -extdirs.", "+\t\t * It is emulated using the classpath. We add extdirs entries after the ", "+\t\t * bootclasspath.", "+\t\t */", "+\t\taddExtdirs(classpath, javac.getExtdirs());", "+", "+\t\t/*", "+\t\t * The java runtime is already handled, so we simply want to retrieve the", "+\t\t * ant runtime and the compile classpath.", "+\t\t */", "+\t\tclasspath.append(getCompileClasspath());", "+", "+\t\t// For -sourcepath, use the \"sourcepath\" value if present.", "+\t\t// Otherwise default to the \"srcdir\" value.", "+\t\tPath sourcepath = null;", "+", "+        // retrieve the method getSourcepath() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Class javacClass = Javac.class;", "+        Method getSourcepathMethod = null;", "+        try {", "+\t        getSourcepathMethod = javacClass.getMethod(\"getSourcepath\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        }", "+        Path compileSourcePath = null;", "+        if (getSourcepathMethod != null) {", "+\t \t\ttry {", "+\t\t\t\tcompileSourcePath = (Path) getSourcepathMethod.invoke(javac, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+        }", "+ ", "+\t\tif (compileSourcePath != null) {", "+\t\t\tsourcepath = compileSourcePath;", "+\t\t} else {", "+\t\t\tsourcepath = javac.getSrcdir();", "+\t\t}", "+\t\tclasspath.append(sourcepath);", "+\t\t/*", "+\t\t * Set the classpath for the Eclipse compiler.", "+\t\t */", "+\t\tcmd.createArgument().setValue(\"-classpath\"); //$NON-NLS-1$", "+\t\tcmd.createArgument().setPath(javac.getClasspath());", "+", "+\t\tString memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? \"-J-\" : \"-J-X\"; //$NON-NLS-1$//$NON-NLS-2$", "+\t\tString memInitialSize = javac.getMemoryInitialSize();", "+\t\tif (memInitialSize != null) {", "+\t\t\tif (!javac.isForkedJavac()) {", "+\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryInitialSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"ms\" + memInitialSize); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+", "+\t\tString memMaximumSize = javac.getMemoryMaximumSize();", "+\t\tif (memMaximumSize != null) {", "+\t\t\tif (!javac.isForkedJavac()) {", "+\t\t\t\tattributes.log(Util.getString(\"ant.jdtadapter.info.ignoringMemoryMaximumSize\"), Project.MSG_WARN); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(memoryParameterPrefix + \"mx\" + memMaximumSize); //$NON-NLS-1$", "+\t\t\t}", "+\t\t}", "+", "+\t\tif (javac.getDebug()) {", "+\t       // retrieve the method getDebugLevel() using reflect", "+\t        // This is done to improve the compatibility to ant 1.5", "+\t        Method getDebugLevelMethod = null;", "+\t        try {", "+\t\t        getDebugLevelMethod = javacClass.getMethod(\"getDebugLevel\", null); //$NON-NLS-1$", "+\t        } catch(NoSuchMethodException e) {", "+\t        \t// if not found, then we cannot use this method (ant 1.5)", "+\t        \t// debug level is only available with ant 1.5.x", "+\t        }", "+     \t    String debugLevel = null;", "+\t        if (getDebugLevelMethod != null) {", "+\t\t\t\ttry {", "+\t\t\t\t\tdebugLevel = (String) getDebugLevelMethod.invoke(javac, null);", "+\t\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t\t// should never happen", "+\t\t\t\t}", "+        \t}", "+\t\t\tif (debugLevel != null) {", "+\t\t\t\tif (debugLevel.length() == 0) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-g:\" + debugLevel); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-g\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else {", "+\t\t\tcmd.createArgument().setValue(\"-g:none\"); //$NON-NLS-1$", "+\t\t}", "+", "+       // retrieve the method getCurrentCompilerArgs() using reflect", "+        // This is done to improve the compatibility to ant 1.5", "+        Method getCurrentCompilerArgsMethod = null;", "+        try {", "+\t        getCurrentCompilerArgsMethod = javacClass.getMethod(\"getCurrentCompilerArgs\", null); //$NON-NLS-1$", "+        } catch(NoSuchMethodException e) {", "+        \t// if not found, then we cannot use this method (ant 1.5)", "+        \t// debug level is only available with ant 1.5.x", "+        }", "+ \t    String[] compilerArgs = null;", "+        if (getCurrentCompilerArgsMethod != null) {", "+\t\t\ttry {", "+\t\t\t\tcompilerArgs = (String[]) getCurrentCompilerArgsMethod.invoke(javac, null);", "+\t\t\t} catch (IllegalAccessException e) {", "+\t\t\t\t// should never happen", "+\t\t\t} catch (InvocationTargetException e) {", "+\t\t\t\t// should never happen", "+\t\t\t}", "+    \t}", "+    \t", "+\t\tfinal boolean deprecationSetting = javac.getDeprecation();", "+\t   \tif (compilerArgs == null) {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (javac.getNowarn()) {", "+\t\t\t\tif (deprecationSetting) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecationSetting) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver\"); //$NON-NLS-1$", "+\t\t\t}", "+    \t} else {", "+\t\t\t/*", "+\t\t\t * Handle the nowarn option. If none, then we generate all warnings.", "+\t\t\t */", "+\t\t\tif (javac.getNowarn()) {", "+\t\t\t\tif (deprecationSetting) {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t\t} else {", "+\t\t\t\t\tcmd.createArgument().setValue(\"-nowarn\"); //$NON-NLS-1$", "+\t\t\t\t}", "+\t\t\t} else if (deprecationSetting) {", "+\t\t\t\tcmd.createArgument().setValue(\"-warn:allDeprecation\"); //$NON-NLS-1$", "+\t\t\t}", "+\t   \t}", "+", "+\t\t/*", "+\t\t * destDir option.", "+\t\t */", "+\t\tfinal File destdir = javac.getDestdir();", "+\t\tif (destdir != null) {", "+\t\t\tcmd.createArgument().setValue(\"-d\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setFile(destdir.getAbsoluteFile());", "+\t\t}", "+", "+\t\t/*", "+\t\t * target option.", "+\t\t */", "+\t\tfinal String targetSetting = javac.getTarget();", "+\t\tif (targetSetting != null) {", "+\t\t\tcmd.createArgument().setValue(\"-target\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(targetSetting);", "+\t\t}", "+", "+\t\t/*", "+\t\t * verbose option", "+\t\t */", "+\t\tif (javac.getVerbose()) {", "+\t\t\tcmd.createArgument().setValue(\"-verbose\"); //$NON-NLS-1$", "+\t\t\t/*", "+\t\t\t * extra option allowed by the Eclipse compiler", "+\t\t\t */", "+\t\t\tcmd.createArgument().setValue(\"-log\"); //$NON-NLS-1$", "+\t\t\tlogFileName = destdir.getAbsolutePath() + \".log\"; //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(logFileName);", "+\t\t}", "+", "+\t\t/*", "+\t\t * failnoerror option", "+\t\t */", "+\t\tif (!javac.getFailonerror()) {", "+\t\t\tcmd.createArgument().setValue(\"-proceedOnError\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t/*", "+\t\t * source option", "+\t\t */", "+\t\tfinal String source = javac.getSource();", "+\t\tif (source != null) {", "+\t\t\tcmd.createArgument().setValue(\"-source\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(source);", "+\t\t}", "+", "+\t\tif (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {", "+\t\t\tif (targetSetting != null && targetSetting.equals(\"1.1\")) { //$NON-NLS-1$\t", "+\t\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t\t} else {", "+\t\t\t\tcmd.createArgument().setValue(\"-1.4\"); //$NON-NLS-1$", "+\t\t\t}", "+\t\t} else {", "+\t\t\tcmd.createArgument().setValue(\"-1.3\"); //$NON-NLS-1$", "+\t\t}", "+", "+\t\t/*", "+\t\t * encoding option", "+\t\t */", "+\t\tfinal String encodingSetting = javac.getEncoding();", "+\t\tif (encodingSetting != null) {", "+\t\t\tcmd.createArgument().setValue(\"-encoding\"); //$NON-NLS-1$", "+\t\t\tcmd.createArgument().setValue(encodingSetting);", "+\t\t}", "+", "+\t\t/*", "+\t\t * Add extra argument on the command line", "+\t\t */", "+\t\tif (compilerArgs != null) {", "+\t        cmd.addArguments(compilerArgs);", "+\t\t}", "+\t\t/*", "+\t\t * Eclipse compiler doesn't have a -sourcepath option. This is", "+\t\t * handled through the javac task that collects all source files in", "+\t\t * srcdir option.", "+\t\t */", "+\t\tlogAndAddFilesToCompile(cmd);", "+\t\treturn cmd;", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44b1a9d676873d356f4842ecf23b4e58", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java", "commitBeforeChange": "ec8e689e69ce65d5a3f127f9c7126c4bebdd7b60", "commitAfterChange": "c922c60b9bc5fcda7fb9f2a477eba6f8f95a6cf9", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 16, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\t\tbuffer.append(this.getDeclaringClass().getKey());", "+\t\t\tbuffer.append(getDeclaringClass().getKey());", "-\t\t\tITypeBinding _returnType = getReturnType();", "-\t\t\tif (_returnType != null) {", "-\t\t\t\tif (_returnType.isTypeVariable()) {", "-\t\t\t\t\tbuffer.append(_returnType.getQualifiedName());", "-\t\t\t\t} else if (_returnType.isArray() && _returnType.getElementType().isTypeVariable()) {", "-\t\t\t\t\tint dimensions = _returnType.getDimensions();", "-\t\t\t\t\tbuffer.append(_returnType.getElementType().getQualifiedName());", "-\t\t\t\t\tfor (int i = 0; i < dimensions; i++) {", "-\t\t\t\t\t\tbuffer.append('[').append(']');", "-\t\t\t\t\t}", "-\t\t\t\t} else {", "-\t\t\t\t\tbuffer.append(_returnType.getKey());", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t\tbuffer.append(this.getName());", "+\t\t\t\tbuffer.append(getName());", "+\t\t\t\t\t\tbuffer.append(',');", "-\t\t\tITypeBinding[] thrownExceptions = getExceptionTypes();", "-\t\t\tfor (int i = 0, max = thrownExceptions.length; i < max; i++) {", "-\t\t\t\tfinal ITypeBinding thrownException = thrownExceptions[i];", "-\t\t\t\tif (thrownException != null) {", "-\t\t\t\t\tif (thrownException.isTypeVariable()) {", "-\t\t\t\t\t\tbuffer.append(thrownException.getQualifiedName());\t\t\t\t\t", "-\t\t\t\t\t} else if (thrownException.isArray() && thrownException.getElementType().isTypeVariable()) {", "-\t\t\t\t\t\tint dimensions = thrownException.getDimensions();", "-\t\t\t\t\t\tbuffer.append(thrownException.getElementType().getQualifiedName());", "-\t\t\t\t\t\tfor (int j = 0; j < dimensions; j++) {", "-\t\t\t\t\t\t\tbuffer.append('[').append(']');", "-\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\tbuffer.append(thrownException.getKey());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "44fe6e94ff6b18b730369a5ad078be43", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java", "commitBeforeChange": "df84bc0b0e74080458b4e3f35c6e77ec6fed2587", "commitAfterChange": "2bb013de372e754bf58118fac6dab82d5a5c9625", "methodNumberBeforeChange": 210, "methodNumberAfterChange": 210, "signatureBeforeChange": " protected void consumeLocalVariableDeclarationStatement()", "signatureAfterChange": " protected void consumeLocalVariableDeclarationStatement()", "diff": ["+\t", "+\tint variableDeclaratorsCounter = this.astLengthStack[this.astLengthPtr];", "+\tif (variableDeclaratorsCounter == 1) {", "+\t\tLocalDeclaration localDeclaration = (LocalDeclaration) this.astStack[this.astPtr];", "+\t\tif (localDeclaration.isRecoveredFromLoneIdentifier()) {", "+\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=430336, [1.8][compiler] Bad syntax error recovery: Lonely identifier should be variable name, not type", "+\t\t\t// Mutate foo $missing; into foo = $missing$; ", "+\t\t\tExpression left;", "+\t\t\tif (localDeclaration.type instanceof QualifiedTypeReference) {", "+\t\t\t\tQualifiedTypeReference qtr = (QualifiedTypeReference) localDeclaration.type;", "+\t\t\t\tleft = new QualifiedNameReference(qtr.tokens, qtr.sourcePositions, 0, 0);", "+\t\t\t} else {", "+\t\t\t\tleft = new SingleNameReference(localDeclaration.type.getLastToken(), 0L);", "+\t\t\t}", "+\t\t\tleft.sourceStart = localDeclaration.type.sourceStart;", "+\t\t\tleft.sourceEnd = localDeclaration.type.sourceEnd;", "+\t\t\t", "+\t\t\tExpression right = new SingleNameReference(localDeclaration.name, 0L);", "+\t\t\tright.sourceStart = localDeclaration.sourceStart;", "+\t\t\tright.sourceEnd = localDeclaration.sourceEnd;", "+\t\t\t", "+\t\t\tAssignment assignment = new Assignment(left, right, 0);", "+\t\t\tint end = this.endStatementPosition;", "+\t\t\tassignment.sourceEnd = (end == localDeclaration.sourceEnd) ? ++end : end; ", "+\t\t\tassignment.statementEnd = end;", "+\t\t\tthis.astStack[this.astPtr] = assignment;", "+\t\t\t", "+\t\t\t// also massage recovery scanner data.", "+\t\t\tif (this.recoveryScanner != null) {", "+\t\t\t\tRecoveryScannerData data = this.recoveryScanner.getData();", "+\t\t\t\tint position = data.insertedTokensPtr;", "+\t\t\t\twhile (position > 0) {", "+\t\t\t\t\tif (data.insertedTokensPosition[position] != data.insertedTokensPosition[position - 1])", "+\t\t\t\t\t\tbreak;", "+\t\t\t\t\tposition--;", "+\t\t\t\t}", "+\t\t\t\tthis.recoveryScanner.insertTokenAhead(TerminalTokens.TokenNameEQUAL, position);", "+\t\t\t}", "+\t\t\t", "+\t\t\tif (this.currentElement != null) {", "+\t\t\t\tthis.lastCheckPoint = assignment.sourceEnd + 1;", "+\t\t\t\tthis.currentElement = this.currentElement.add(assignment, 0);", "+\t\t\t}", "+\t\t\treturn;", "+\t\t}", "+\t}", "-\tint variableDeclaratorsCounter = this.astLengthStack[this.astLengthPtr];"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "539066f99d522cf257220eb3628a8106", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Javadoc.java", "commitBeforeChange": "3de46f74e60c4a3809d64f36594b156b755e8151", "commitAfterChange": "a278a6d0aa65f732809dc346bd96a708d28563bd", "methodNumberBeforeChange": 5, "methodNumberAfterChange": 6, "signatureBeforeChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "signatureAfterChange": " \t \tprivate void resolveReference(Expression reference, Scope scope)", "diff": ["+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (fieldRef.binding != null && fieldRef.binding.isValidBinding() && fieldRef.receiverType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) fieldRef.receiverType;", "+\t\t\t\tverifyTypeReference(fieldRef.receiver, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/", "+", "-\t\t\tif (reference.resolvedType.isValidBinding()) {", "-", "-\t\t\t\t// member types", "-\t\t\t\tif (resolvedType.isMemberType()) {", "-\t\t\t\t\tReferenceBinding topLevelType = resolvedType;", "-\t\t\t\t\tint depth = 0;", "-\t\t\t\t\twhile (topLevelType.enclosingType() != null) {", "-\t\t\t\t\t\ttopLevelType = topLevelType.enclosingType();", "-\t\t\t\t\t\tdepth++;", "-\t\t\t\t\t}", "-\t\t\t\t\tClassScope topLevelScope = scope.classScope();", "-\t\t\t\t\t// when scope is not on compilation unit type, then inner class may not be visible...", "-\t\t\t\t\tif (topLevelScope.parent.kind != Scope.COMPILATION_UNIT_SCOPE ||", "-\t\t\t\t\t\t!CharOperation.equals(topLevelType.sourceName, topLevelScope.referenceContext.name)) {", "-\t\t\t\t\t\ttopLevelScope = topLevelScope.outerMostClassScope();", "-\t\t\t\t\t\tif (reference instanceof JavadocSingleTypeReference) {", "-\t\t\t\t\t\t\t// inner class single reference can only be done in same unit", "-\t\t\t\t\t\t\tif ((!source15 && depth == 1) || topLevelType != topLevelScope.referenceContext.binding) {", "-\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t// inner class qualified reference can only be done in same package", "-\t\t\t\t\t\t\tif (topLevelType.getPackage() != topLevelScope.referenceContext.binding.getPackage()) {", "-\t\t\t\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-", "-\t\t\t\t// reference must have enough visibility to be used", "-\t\t\t\tif (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType)) {", "-\t\t\t\t\tif (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();", "-\t\t\t\t\tscope.problemReporter().javadocNotVisibleReference(reference.sourceStart, reference.sourceEnd, scopeModifiers);", "-\t\t\t\t}", "-\t\t\t}", "+\t\t\tverifyTypeReference(reference, scope, source15, resolvedType);", "+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (msgSend.binding != null && msgSend.binding.isValidBinding() && msgSend.actualReceiverType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) msgSend.actualReceiverType;", "+\t\t\t\tverifyTypeReference(msgSend.receiver, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/", "+\t\t\t// Verify type references", "+\t\t\t// TODO (frederic) fix for bug 119857", "+\t\t\t/*", "+\t\t\tif (alloc.binding != null && alloc.binding.isValidBinding() && alloc.resolvedType instanceof ReferenceBinding) {", "+\t\t\t\tReferenceBinding resolvedType = (ReferenceBinding) alloc.resolvedType;", "+\t\t\t\tverifyTypeReference(alloc.type, scope, source15, resolvedType);", "+\t\t\t}", "+\t\t\t*/"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "55bc336a657706cc183b767d218bcb3a", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java", "commitBeforeChange": "ec6d7f365ea3ec3ffcd55d64775bd62b984807f3", "commitAfterChange": "c021c50efca4c234ec58241ed1fc82f6871e98bd", "methodNumberBeforeChange": 10, "methodNumberAfterChange": 10, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\t\tif (false) {", "-\t\t\t\tthis.key = new String(this.binding.computeUniqueKey());", "-\t\t\t\treturn this.key;", "-\t\t\t}", "-\t\t\tif (isField()) {", "-\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\tif (this.getDeclaringClass() != null) {", "-\t\t\t\t\tbuffer.append(this.getDeclaringClass().getKey());", "-\t\t\t\t\tbuffer.append('/');", "-\t\t\t\t}", "-\t\t\t\tbuffer.append(this.getName());", "-\t\t\t\tthis.key = buffer.toString();", "-\t\t\t} else {", "-\t\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\t\t", "-\t\t\t\t// declaring method or type", "-\t\t\t\tLocalVariableBinding localVarBinding = (LocalVariableBinding) this.binding;", "-\t\t\t\tBlockScope scope = localVarBinding.declaringScope;", "-\t\t\t\tMethodScope methodScope = scope instanceof MethodScope ? (MethodScope) scope : scope.enclosingMethodScope();", "-\t\t\t\tReferenceContext referenceContext = methodScope.referenceContext;", "-\t\t\t\tif (referenceContext instanceof AbstractMethodDeclaration) {", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.MethodBinding internalBinding = ((AbstractMethodDeclaration) referenceContext).binding;", "-\t\t\t\t\tIMethodBinding methodBinding = this.resolver.getMethodBinding(internalBinding);", "-\t\t\t\t\tif (methodBinding != null) {", "-\t\t\t\t\t\tbuffer.append(methodBinding.getKey());", "-\t\t\t\t\t}", "-\t\t\t\t} else if (referenceContext instanceof TypeDeclaration) {", "-\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding internalBinding = ((TypeDeclaration) referenceContext).binding;", "-\t\t\t\t\tITypeBinding typeBinding = this.resolver.getTypeBinding(internalBinding);", "-\t\t\t\t\tif (typeBinding != null) {", "-\t\t\t\t\t\tbuffer.append(typeBinding.getKey());", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t", "-\t\t\t\t// scope index", "-\t\t\t\tgetKey(scope, buffer);", "-\t", "-\t\t\t\t// variable name", "-\t\t\t\tbuffer.append('/');", "-\t\t\t\tbuffer.append(getName());", "-\t\t\t\t", "-\t\t\t\tthis.key = buffer.toString();", "-\t\t\t}", "+\t\t\tthis.key = new String(this.binding.computeUniqueKey());", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "64ae3b672a5a77a8ec42573a5eb3c039", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java", "commitBeforeChange": "8a3cbdf1db434ade029724481c4ce0338046043a", "commitAfterChange": "a67fa7cbc880c9e9bad3f8e391aeed5f3e00392a", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " \t@Override \tpublic String getDocComment(Element e)", "signatureAfterChange": " \t@Override \tpublic String getDocComment(Element e)", "diff": ["+\t\tchar[] unparsed = getUnparsedDocComment(e);", "+\t\treturn formatJavadoc(unparsed);", "+\t}", "-\t\t\t\treturn new String(CharOperation.subarray(contents, javadoc.sourceStart, javadoc.sourceEnd));"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "73bfa8b2de404c0abf15c031cf5af9ae", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "948661c4cb198af70b598b9954e5159cb73d7234", "commitAfterChange": "b1348e3d0230a581c7eb25acd6ec072853b12bb0", "methodNumberBeforeChange": 26, "methodNumberAfterChange": 26, "signatureBeforeChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "signatureAfterChange": "\r \tpublic void reportAccurateReference(\r \t\tint sourceStart,\r \t\tint sourceEnd,\r \t\tchar[][] qualifiedName,\r \t\tIJavaElement element,\r \t\tint accuracy)\r \t\tthrows CoreException", "diff": ["+\t\tthrows CoreException {\r", "+\t\t\t\r", "+\t\tthis.reportAccurateReference(\r", "+\t\t\tsourceStart,\r", "+\t\t\tsourceEnd,\r", "+\t\t\tqualifiedName,\r", "+\t\t\telement,\r", "+\t\t\tnew int[] {accuracy},\r", "+\t\t\tfalse);\r", "+\t}\r", "-\t\t\t\t\t&& !CharOperation.equals(currentTokenSource, qualifiedName[i++])) {\r", "-\t\t\t\tif (CharOperation.equals(currentTokenSource, qualifiedName[i - 1])\r", "-\t\t\t\t\t&& (previousValid == -1 || previousValid == i - 2)) {\r", "-\t\t}\r", "-\t\twhile (token != TerminalSymbols.TokenNameEOF && i < tokenNumber);\r", "-\t\t// accept reference\r", "-\t\tif (refSourceStart != -1) {\r", "-\t\t\tthis.report(refSourceStart, refSourceEnd, element, accuracy);\r", "-\t\t} else {\r", "-\t\t\tthis.report(sourceStart, sourceEnd, element, accuracy);\r", "-\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7d9cf228c984c0bddefbe1992e40109b", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/align/Alignment.java", "commitBeforeChange": "900c13d17fd147c187a2b319111ff0c850c4ae89", "commitAfterChange": "f02cc00df615ce0df96d2675e50465c713b4b942", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": "  \tpublic String toString()", "signatureAfterChange": "  \tpublic String toString()", "diff": ["-\t\tString className = getClass().getName();", "-\t\tclassName = className.substring(className.lastIndexOf('.')+1);", "-\t\tbuffer", "-\t\t\t.append(className)", "-\t\t\t.append(\":<name: \")\t//$NON-NLS-1$", "-\t\t\t.append(this.name)", "-\t\t\t.append(\">\");\t//$NON-NLS-1$", "-\t\tint indentLength = className.length()+1;", "-\t\tbuffer.append('\\n');", "-\t\tfor (int i=0; i<indentLength; i++) {", "-\t\t\tbuffer.append(' ');", "+\t\treturn toString(buffer, -1);", "+\t}", "-\t\t\t.append('>');", "-\t\tif (this.enclosing != null) {", "-\t\t\tbuffer", "-\t\t\t\t.append(\"<enclosingName: \")\t//$NON-NLS-1$", "-\t\t\t\t.append(this.enclosing.name)", "-\t\t\t\t.append('>');", "-\t\t}", "-\t\tbuffer.append('\\n');", "-\t\t\t\t.append(\" - fragment \")\t//$NON-NLS-1$", "-\t\tbuffer.append('\\n');"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "7e126e54860579a123bc901623f1f081", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java", "commitBeforeChange": "0df9f1687f9162f2dcdfeec3aed4b01b8d385a19", "commitAfterChange": "ce0f19288bc3747a9c0cb27b6996f5589afb99d1", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": " \tpublic void seekTypes(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "signatureAfterChange": "  \tpublic void seekTypes(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor)", "diff": ["+\tpublic void seekTypes(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor) {", "+\t\tseekTypes(name, pkg, partialMatch, acceptFlags, requestor, true);", "+\t}", "-\tpublic void seekTypes(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor) {", "-\t\t\t\tif (seekTypesInWorkingCopies(matchName, pkg, firstDot, partialMatch, topLevelTypeName, acceptFlags, requestor))"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "808657a6d37c027664f230cbbd952352", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java", "commitBeforeChange": "f0cc0529135fe43e5b6252dca937651f0a04d49c", "commitAfterChange": "79c1182746ff2f44f9956aeaf2f61882a4911acb", "methodNumberBeforeChange": 42, "methodNumberAfterChange": 37, "signatureBeforeChange": " \tpublic void completeMethodInfo( \t\t\tMethodBinding binding, \t\t\tint methodAttributeOffset, \t\t\tint attributesNumber)", "signatureAfterChange": " \tpublic void completeMethodInfo( \t\t\tMethodBinding binding, \t\t\tint methodAttributeOffset, \t\t\tint attributesNumber)", "diff": ["-", "+\t\t", "-\t\t\tList allTypeAnnotationContexts = ((TypeAnnotationCodeStream) this.codeStream).allTypeAnnotationContexts;", "+\t\t\tList allTypeAnnotationContexts = new ArrayList();", "-\t\t\tfor (int i = 0, max = this.codeStream.allLocalsCounter; i < max; i++) {", "-\t\t\t\tLocalVariableBinding localVariable = this.codeStream.locals[i];", "-\t\t\t\tLocalDeclaration declaration = localVariable.declaration;", "-\t\t\t\tif (declaration == null", "-\t\t\t\t\t\t|| (declaration.isArgument() && ((declaration.bits & ASTNode.IsUnionType) == 0))", "-\t\t\t\t\t\t|| (localVariable.initializationCount == 0)", "-\t\t\t\t\t\t|| ((declaration.bits & ASTNode.HasTypeAnnotations) == 0)) {", "-\t\t\t\t\tcontinue;", "-\t\t\t\t}", "-\t\t\t\tdeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.LOCAL_VARIABLE, localVariable, allTypeAnnotationContexts);", "-\t\t\t}", "-\t\t\t\t\t\t\t\targument.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_PARAMETER, i, allTypeAnnotationContexts);", "+\t\t\t\t\t\t\t\targument.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER, i, allTypeAnnotationContexts);", "-\t\t\t\t\tAnnotation[] annotations = (methodDeclaration.receiver==null?null:methodDeclaration.receiver.annotations);", "-\t\t\t\t\tif (annotations != null) {", "-\t\t\t\t\t\tfor (int i = 0, max = annotations.length; i < max; i++) {", "-\t\t\t\t\t\t\tAnnotation annotation = annotations[i];", "-\t\t\t\t\t\t\tAnnotationContext annotationContext = null;", "-\t\t\t\t\t\t\tif (annotation.isRuntimeTypeInvisible()) {", "-\t\t\t\t\t\t\t\tannotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.INVISIBLE, null);", "-\t\t\t\t\t\t\t\tinvisibleTypeAnnotationsCounter++;", "-\t\t\t\t\t\t\t} else if (annotation.isRuntimeTypeVisible()) {", "-\t\t\t\t\t\t\t\tannotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.VISIBLE, null);", "-\t\t\t\t\t\t\t\tvisibleTypeAnnotationsCounter++;", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (annotationContext != null) {", "-\t\t\t\t\t\t\t\tallTypeAnnotationContexts.add(annotationContext);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\tReceiver receiver = methodDeclaration.receiver;", "+\t\t\t\t\tif (receiver != null && (receiver.type.bits & ASTNode.HasTypeAnnotations) != 0) {", "+\t\t\t\t\t\treceiver.type.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RECEIVER, allTypeAnnotationContexts);", "-\t\t\t\t\tmethodDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);", "+\t\t\t\t\tmethodDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN, allTypeAnnotationContexts);", "-\t\t\t\t\t\ttypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);", "+\t\t\t\t\t\ttypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN, allTypeAnnotationContexts);", "-"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "83d03769f660ec10417f8b0c32a0d2b6", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/ElementProc.java", "commitBeforeChange": "f4eb00a745a91dbc4b9bd7fa4022524e166e1b90", "commitAfterChange": "a4f11659e59fa8a478723fa3bc2c5651f04c5382", "methodNumberBeforeChange": 0, "methodNumberAfterChange": 3, "signatureBeforeChange": "  \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "signatureAfterChange": " \t@Override \tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)", "diff": ["+\t// Always return false from this processor, because it supports \"*\".", "-\t\tMap<String, String> options = processingEnv.getOptions();", "-\t\tif (!options.containsKey(\"org.eclipse.jdt.compiler.apt.tests.processors.elements.ElementProc\")) {", "+\t\tif (roundEnv.processingOver()) {", "+\t\t\t// We're not interested in the postprocessing round.", "-\t\tfor (Element e : roundEnv.getRootElements()) {", "-\t\t\tSystem.out.println(\"Found element \" + e.getSimpleName());", "+\t\tMap<String, String> options = processingEnv.getOptions();", "+\t\tif (!options.containsKey(CLASSNAME)) {", "+\t\t\t// Disable this processor unless we are intentionally performing the test.", "+\t\t\treturn false;", "+\t\t", "+\t\t// Verify that we get the root elements we expect", "+\t\tSet<String> expectedRootElementNames = new HashSet<String>(_rootElementNames.length);", "+\t\tfor (String name : _rootElementNames) {", "+\t\t\texpectedRootElementNames.add(name);", "+\t\t}", "+\t\tSet<? extends Element> actualRootElements = roundEnv.getRootElements();", "+\t\tif (null == actualRootElements) {", "+\t\t\tElementProc.reportError(\"getRootElements() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tfor (Element e : actualRootElements) {", "+\t\t\tString name = e.getSimpleName().toString();", "+\t\t\tif (!expectedRootElementNames.remove(name)) {", "+\t\t\t\tElementProc.reportError(\"Missing root element \" + name);", "+\t\t\t}", "+\t\t}", "+\t\tif (!expectedRootElementNames.isEmpty()) {", "+\t\t\tElementProc.reportError(\"Found extra root elements including \" + expectedRootElementNames.iterator().next());", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Check some basic attributes", "+\t\tTypeElement elementIA = _elementUtils.getTypeElement(\"targets.model.pa.IA\");", "+\t\tif (elementIA == null) {", "+\t\t\tElementProc.reportError(\"element IA was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tTypeElement elementAB = _elementUtils.getTypeElement(\"targets.model.pb.AB\");", "+\t\tif (elementAB == null) {", "+\t\t\tElementProc.reportError(\"element AB was not found\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementIA.getKind() != ElementKind.INTERFACE) {", "+\t\t\tElementProc.reportError(\"IA claims to not be an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tif (elementAB.getKind() != ElementKind.CLASS) {", "+\t\t\tElementProc.reportError(\"AB claims to not be a class\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\t// Can we look at what interfaces AB implements?", "+\t\tList<? extends TypeMirror> ABinterfaces = elementAB.getInterfaces();", "+\t\tif (null == ABinterfaces) {", "+\t\t\tElementProc.reportError(\"AB.getInterfaces() returned null\");", "+\t\t\treturn false;", "+\t\t}", "+\t\tboolean foundIAinterface = false;", "+\t\tfor (TypeMirror type : ABinterfaces) {", "+\t\t\tElement decl = _typeUtils.asElement(type);", "+\t\t\tif (null == decl) {", "+\t\t\t\tElementProc.reportError(\"One of AB's interfaces, \" + type.toString() + \", produced null from Types.asElement()\");", "+\t\t\t\treturn false;", "+\t\t\t}", "+\t\t\tif (elementIA.equals(decl)) {", "+\t\t\t\tfoundIAinterface = true;", "+\t\t\t\tbreak;", "+\t\t\t}", "+\t\t}", "+\t\tif (!foundIAinterface) {", "+\t\t\tElementProc.reportError(\"AB does not have IA as an interface\");", "+\t\t\treturn false;", "+\t\t}", "+\t\t", "+\t\tElementProc.reportSuccess();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "858eb19aa5e8098fd4fd1139e3f902ef", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java", "commitBeforeChange": "30087d59ff5bea89d3392799267963cf724c3b0a", "commitAfterChange": "b08badd66fa6a6f7b4561ee1019c14e2a696043e", "methodNumberBeforeChange": 24, "methodNumberAfterChange": 24, "signatureBeforeChange": " protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException", "signatureAfterChange": " protected IBuffer openBuffer(IProgressMonitor pm) throws JavaModelException", "diff": ["+\t\treturn mapSource(mapper);", "+\t} else if (!checkAutomaticSourceMapping) {", "+\t\t/*", "+\t\t * We try to see if we can automatically attach a source", "+\t\t * source files located inside the same folder than its .class file", "+\t\t * See bug 36510.", "+\t\t */", "+\t\tPackageFragmentRoot root = getPackageFragmentRoot();", "+\t\tif (root.isArchive()) {", "+\t\t\t// root is a jar file or a zip file", "+\t\t\tString elementName = getElementName();", "+\t\t\tStringBuffer sourceFileName = new StringBuffer(elementName.substring(0, elementName.lastIndexOf('.')));", "+\t\t\tsourceFileName.append(Util.SUFFIX_java);", "+\t\t\tJarPackageFragmentRoot jarPackageFragmentRoot = (JarPackageFragmentRoot) root;", "+\t\t\tZipFile jar = null;", "+\t\t\ttry {", "+\t\t\t\tjar = jarPackageFragmentRoot.getJar();", "+\t\t\t\tIPackageFragment packageFragment = (IPackageFragment) getParent();", "+\t\t\t\tZipEntry zipEntry = null;", "+\t\t\t\tif (packageFragment.isDefaultPackage()) {", "+\t\t\t\t\tzipEntry = jar.getEntry(sourceFileName.toString());", "+\t\t\t\t} else {", "+\t\t\t\t\tzipEntry = jar.getEntry(getParent().getElementName() + '/' + sourceFileName.toString());", "+\t\t\t\t}", "+\t\t\t\tif (zipEntry != null) {", "+\t\t\t\t\t// found a source file", "+\t\t\t\t\tcheckAutomaticSourceMapping = true;", "+\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "+\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "+\t\t\t\t\tif (sourceMapper != null) {", "+\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} catch (CoreException e) {", "+\t\t\t\tif (e instanceof JavaModelException) throw (JavaModelException)e;", "+\t\t\t\tthrow new JavaModelException(e);", "+\t\t\t} finally {", "+\t\t\t\tJavaModelManager.getJavaModelManager().closeZipFile(jar);", "+\t\t\t}", "+\t\t} else {", "+\t\t\t// Attempts to find the corresponding java file", "+\t\t\tString qualifiedName = getType().getFullyQualifiedName();", "+\t\t\tNameLookup lookup = ((JavaProject) getJavaProject()).getNameLookup();", "+\t\t\tICompilationUnit cu = lookup.findCompilationUnit(qualifiedName);", "+\t\t\tif (cu != null) {", "+\t\t\t\treturn cu.getBuffer();", "+\t\t\t} else\t{", "+\t\t\t\t// root is a class folder", "+\t\t\t\tIPath sourceFilePath = getPath().removeFileExtension().addFileExtension(\"java\");", "+\t\t\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();", "+\t\t\t\tif (workspace == null) {", "+\t\t\t\t\tcheckAutomaticSourceMapping = true; // we don't want to check again", "+\t\t\t\t\treturn null; // workaround for http://bugs.eclipse.org/bugs/show_bug.cgi?id=34069", "+\t\t\t\t}", "+\t\t\t\tif (JavaModel.getTarget(", "+\t\t\t\t\t\tworkspace.getRoot(),", "+\t\t\t\t\t\tsourceFilePath.makeRelative(), // ensure path is relative (see http://dev.eclipse.org/bugs/show_bug.cgi?id=22517)", "+\t\t\t\t\t\ttrue) != null) {", "+\t\t\t\t\t\t\t", "+\t\t\t\t\t// found a source file", "+\t\t\t\t\t // we don't need to check again. The source will be attached.", "+\t\t\t\t\tcheckAutomaticSourceMapping = true;", "+\t\t\t\t\troot.attachSource(root.getPath(), null, null);", "+\t\t\t\t\tSourceMapper sourceMapper = getSourceMapper();", "+\t\t\t\t\tif (sourceMapper != null) {", "+\t\t\t\t\t\treturn mapSource(sourceMapper);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+\treturn null;", "+}", "-\t} else {", "-\t\t// Attempts to find the corresponding java file", "-\t\tString qualifiedName = getType().getFullyQualifiedName();", "-\t\tNameLookup lookup = ((JavaProject) getJavaProject()).getNameLookup();", "-\t\tICompilationUnit cu = lookup.findCompilationUnit(qualifiedName);", "-\t\tif (cu != null) {", "-\t\t\treturn cu.getBuffer();", "-\t\t}", "-\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "914e575f3eff52eca77cde5b4a425938", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "1cd36da9dd049ac527dcab1976c08155d6c121b9", "commitAfterChange": "f2c2a11caa27156fb260986cef359f78136ce40c", "methodNumberBeforeChange": 27, "methodNumberAfterChange": 27, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\tif (isLocal()) {", "-\t\t\treturn null;", "+\t\tif (this.key == null) {", "+\t\t\tif (isLocal()) {", "+\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t", "+\t\t\t\t// declaring method or type", "+\t\t\t\tSourceTypeBinding sourceBinding = (SourceTypeBinding) this.binding; // per construction, a local type can only be defined in source", "+\t\t\t\tClassScope scope = sourceBinding.scope;", "+\t\t\t\tReferenceContext referenceContext;", "+\t\t\t\tif (isAnonymous()) {", "+\t\t\t\t\tClassScope classScope = scope.enclosingClassScope();", "+\t\t\t\t\treferenceContext = classScope.referenceContext;", "+\t\t\t\t} else {", "+\t\t\t\t\tMethodScope methodScope = scope.enclosingMethodScope();", "+\t\t\t\t\treferenceContext = methodScope.referenceContext;", "+\t\t\t\t}", "+\t\t\t\tif (referenceContext instanceof AbstractMethodDeclaration) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.MethodBinding internalBinding = ((AbstractMethodDeclaration) referenceContext).binding;", "+\t\t\t\t\tIMethodBinding methodBinding = this.resolver.getMethodBinding(internalBinding);", "+\t\t\t\t\tif (methodBinding != null) {", "+\t\t\t\t\t\tbuffer.append(methodBinding.getKey());", "+\t\t\t\t\t}", "+\t\t\t\t} else if (referenceContext instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {", "+\t\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding internalBinding = ((org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) referenceContext).binding;", "+\t\t\t\t\tITypeBinding typeBinding = this.resolver.getTypeBinding(internalBinding);", "+\t\t\t\t\tif (typeBinding != null) {", "+\t\t\t\t\t\tbuffer.append(typeBinding.getKey());", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t", "+\t\t\t\tif (isAnonymous()) {", "+\t\t\t\t\tbuffer.append('$');", "+\t\t\t\t\tCompilationUnitScope compilationUnitScope = scope.compilationUnitScope();", "+\t\t\t\t\tCompilationUnitDeclaration compilationUnitDeclaration = compilationUnitScope.referenceContext;", "+\t\t\t\t\tLocalTypeBinding[] localTypeBindings = compilationUnitDeclaration.localTypes;", "+\t\t\t\t\tfor (int i = 0, max = compilationUnitDeclaration.localTypeCount; i < max; i++) {", "+\t\t\t\t\t\tif (localTypeBindings[i] == sourceBinding) {", "+\t\t\t\t\t\t\tbuffer.append(i+1);", "+\t\t\t\t\t\t\tbreak;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\t// type name", "+\t\t\t\t\tbuffer.append('/');", "+\t\t\t\t\tbuffer.append(getName());", "+\t\t\t\t}", "+\t\t\t\t", "+\t\t\t\tthis.key = buffer.toString();", "+\t\t\t} else {", "+\t\t\t\tif (this.binding.isClass() || this.binding.isInterface()) {", "+\t\t\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t\t\tbuffer", "+\t\t\t\t\t\t.append(getPackage().getName())", "+\t\t\t\t\t\t.append('/')", "+\t\t\t\t\t\t.append(getName());", "+\t\t\t\t\tthis.key = buffer.toString();", "+\t\t\t\t} else if (this.binding.isArrayType()) {", "+\t\t\t\t\tthis.key = this.getElementType().getKey() + this.getDimensions();", "+\t\t\t\t} else {", "+\t\t\t\t\t// this is a primitive type", "+\t\t\t\t\tthis.key = this.getName();", "+\t\t\t\t}", "+\t\t\t}", "-\t\tif (this.binding.isClass() || this.binding.isInterface()) {", "-\t\t\tStringBuffer buffer = new StringBuffer();", "-\t\t\tbuffer", "-\t\t\t\t.append(getPackage().getName())", "-\t\t\t\t.append('.')", "-\t\t\t\t.append(getName());", "-\t\t\treturn buffer.toString();", "-\t\t} else if (this.binding.isArrayType()) {", "-\t\t\treturn this.getElementType().getKey() + this.getDimensions();", "-\t\t}", "-\t\t// this is a primitive type", "-\t\treturn this.getName();", "+\t\treturn this.key;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a40929e0779dddd52c91c48c8b9ede41", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java", "commitBeforeChange": "507dcedd3a1fdac6fc22c9b1a4a0ec9c8798fdc1", "commitAfterChange": "d150c95a398a3e8cb83192b0abf48f6fefa4a7a3", "methodNumberBeforeChange": 107, "methodNumberAfterChange": 107, "signatureBeforeChange": "  \tpublic Javadoc convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc)", "signatureAfterChange": "  \tpublic Javadoc convert(org.eclipse.jdt.internal.compiler.ast.Javadoc javadoc)", "diff": ["-\t\t\t\t\t\tTagElement tagElement = (TagElement) tags.next();", "-\t\t\t\t\t\tIterator fragments = tagElement.fragments().listIterator();", "-\t\t\t\t\t\twhile (fragments.hasNext()) {", "-\t\t\t\t\t\t\tASTNode node = (ASTNode) fragments.next();", "-\t\t\t\t\t\t\tif (node.getNodeType() == ASTNode.MEMBER_REF) {", "-\t\t\t\t\t\t\t\tint start = node.getStartPosition();", "-\t\t\t\t\t\t\t\tName name = ((MemberRef)node).getName();", "-\t\t\t\t\t\t\t\tif (name != null) start = name.getStartPosition();", "-\t\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(start);", "-\t\t\t\t\t\t\t\tif (compilerNode != null) {", "-\t\t\t\t\t\t\t\t\trecordNodes(node, compilerNode);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (node.getNodeType() == ASTNode.METHOD_REF) {", "-\t\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(node.getStartPosition());", "-\t\t\t\t\t\t\t\tif (compilerNode != null) {", "-\t\t\t\t\t\t\t\t\trecordNodes(node, compilerNode);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else if (node.getNodeType() == ASTNode.TAG_ELEMENT) {", "-\t\t\t\t\t\t\t\t// resolve member and method references binding", "-\t\t\t\t\t\t\t\tTagElement inlineTag = (TagElement) node;", "-\t\t\t\t\t\t\t\tIterator inlineFragments = inlineTag.fragments().listIterator();", "-\t\t\t\t\t\t\t\twhile (inlineFragments.hasNext()) {", "-\t\t\t\t\t\t\t\t\tASTNode inlineNode = (ASTNode) inlineFragments.next();", "-\t\t\t\t\t\t\t\t\tif (inlineNode.getNodeType() == ASTNode.MEMBER_REF || inlineNode.getNodeType() == ASTNode.METHOD_REF) {", "-\t\t\t\t\t\t\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode compilerNode = javadoc.getNodeStartingAt(inlineNode.getStartPosition());", "-\t\t\t\t\t\t\t\t\t\tif (compilerNode != null) {", "-\t\t\t\t\t\t\t\t\t\t\trecordNodes(inlineNode, compilerNode);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "+\t\t\t\t\t\trecordNodes(javadoc, (TagElement) tags.next());"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a660c8e21285e62152f784b146497628", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "1b98b39107e931dc0893df1da7a410cad5cc4745", "commitAfterChange": "9635fd418f2d5b55fe3d3dc4ccb7797a5daf3a53", "methodNumberBeforeChange": 2, "methodNumberAfterChange": 2, "signatureBeforeChange": " protected void attachOrphanCompletionNode()", "signatureAfterChange": " protected void attachOrphanCompletionNode()", "diff": ["+\t\t\t\t\t} else if (expression instanceof QualifiedNameReference) {", "+\t\t\t\t\t\tMemberValuePair valuePair =", "+\t\t\t\t\t\t\tnew MemberValuePair(VALUE, expression.sourceStart, expression.sourceEnd, expression);", "+\t\t\t\t\t\tbuildMoreAnnotationCompletionContext(valuePair);", "+\t\t\t\t} else {", "+\t\t\t\t\tint index;", "+\t\t\t\t\tif((index = lastIndexOfElement(K_ATTRIBUTE_VALUE_DELIMITER)) != -1) {", "+\t\t\t\t\t\tint attributeIndentifierPtr = this.elementInfoStack[index];", "+\t\t\t\t\t\tint identLengthPtr = this.identifierLengthPtr;", "+\t\t\t\t\t\tint identPtr = this.identifierPtr;", "+\t\t\t\t\t\twhile (attributeIndentifierPtr < identPtr) {", "+\t\t\t\t\t\t\tidentPtr -= this.identifierLengthStack[identLengthPtr--];", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tif(attributeIndentifierPtr != identPtr) return;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tthis.identifierLengthPtr = identLengthPtr;", "+\t\t\t\t\t\tthis.identifierPtr = identPtr;", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tthis.identifierLengthPtr--;", "+\t\t\t\t\t\tMemberValuePair memberValuePair = new MemberValuePair(", "+\t\t\t\t\t\t\t\tthis.identifierStack[this.identifierPtr--],", "+\t\t\t\t\t\t\t\texpression.sourceStart,", "+\t\t\t\t\t\t\t\texpression.sourceEnd,", "+\t\t\t\t\t\t\t\texpression);", "+\t\t\t\t\t\t", "+\t\t\t\t\t\tbuildMoreAnnotationCompletionContext(memberValuePair);", "+\t\t\t\t\t\treturn;", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\tCompletionNodeDetector detector =  new CompletionNodeDetector(this.assistNode, expression);", "+\t\t\t\tif(detector.containsCompletionNode()) {", "+\t\t\t\t\tMemberValuePair valuePair =", "+\t\t\t\t\t\tnew MemberValuePair(VALUE, expression.sourceStart, expression.sourceEnd, expression);", "+\t\t\t\t\tbuildMoreAnnotationCompletionContext(valuePair);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t\t", "+\t\tif (this.astPtr > -1) {", "+\t\t\tASTNode node = this.astStack[this.astPtr];", "+\t\t\tif(node instanceof MemberValuePair) {", "+\t\t\t\tMemberValuePair memberValuePair = (MemberValuePair) node;", "+\t\t\t\tCompletionNodeDetector detector =  new CompletionNodeDetector(this.assistNode, memberValuePair);", "+\t\t\t\tif(detector.containsCompletionNode()) {", "+\t\t\t\t\tbuildMoreAnnotationCompletionContext(memberValuePair);", "+\t\t\t\t\tthis.assistNodeParent = detector.getCompletionNodeParent();", "+\t\t\t\t\treturn;", "-\tif ((!isInsideMethod() && !isInsideFieldInitialization())) { ", "+\tif ((!isInsideMethod() && !isInsideFieldInitialization() && !isInsideAttributeValue())) { "]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "aed87ef817741539c31ac3cf76a453e3", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java", "commitBeforeChange": "3474b76fc94606d0b8f4ddadcc2ba8eb6a2c0d7e", "commitAfterChange": "25ee38ac5310b866b312c28ed2b05a72790c9904", "methodNumberBeforeChange": 151, "methodNumberAfterChange": 151, "signatureBeforeChange": " \tpublic void test0138() throws CoreException", "signatureAfterChange": " \tpublic void test0138() throws CoreException", "diff": ["-    \tString contents =", "+    \tfinal String contents =", "-    \t\tpublic boolean visit(QualifiedName qualifiedName) {", "-    \t\t\tIBinding binding = qualifiedName.resolveBinding();", "-    \t\t\tassertNotNull(\"No binding\", binding);", "-    \t\t\treturn true;", "-    \t\t}", "-    \t\tpublic boolean visit(SimpleName simpleName) {", "-\t\t\t\tif (simpleName.getIdentifier().equals(\"URL\")", "-\t\t\t\t\t\t|| simpleName.getIdentifier().equals(\"method\")) {", "-\t\t\t\t\treturn false;", "-\t\t\t\t}", "-    \t\t\tIBinding binding = simpleName.resolveBinding();", "-    \t\t\tassertNotNull(\"No binding\", binding);", "-    \t\t\treturn true;", "-    \t\t}", "+    \t\t\tcheckSourceRange(type, \"java.util.List<URL>\", contents);", "-    \t\t\tassertNotNull(\"No binding\", typeBinding);", "-    \t\t\treturn true;", "-    \t\t}", "-    \t\tpublic boolean visit(SimpleType type) {", "-    \t\t\tITypeBinding typeBinding = type.resolveBinding();", "-    \t\t\tName name = type.getName();", "-    \t\t\tif (name.isSimpleName()) {", "-    \t\t\t\tSimpleName simpleName = (SimpleName) name;", "-    \t\t\t\tif (simpleName.getIdentifier().equals(\"URL\")) {", "-    \t\t\t\t\treturn false;", "-    \t\t\t\t}", "-    \t\t\t}", "-    \t\t\tassertNotNull(\"No binding\", typeBinding);", "-    \t\t\treturn true;", "-    \t\t}", "-    \t\tpublic boolean visit(TypeParameter typeParameter) {", "-    \t\t\tITypeBinding typeBinding = typeParameter.resolveBinding();", "-    \t\t\tassertNotNull(\"No binding\", typeBinding);", "-    \t\t\treturn true;", "-    \t\t}", "-    \t\tpublic boolean visit(QualifiedType type) {", "-    \t\t\tITypeBinding typeBinding = type.resolveBinding();", "-    \t\t\tassertNotNull(\"No binding\", typeBinding);", "+    \t\t\tassertNull(\"Got a binding\", typeBinding);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "cd140831c01c7272f21936c0dbcc4acd", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "18811c004d543a3728cc5dfc4e05503a79b434ee", "commitAfterChange": "96cbe57b16442df110d3b0ecde11c12b456820b8", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": "\r \r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "signatureAfterChange": "\r public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope)", "diff": ["-\r", "-\treturn this.canBeSeenBy(receiverType,invocationSite.isSuperAccess(),scope);\r", "-}\r", "+\t\tint depth = 0;\r", "+\t\t\t\tif (invocationSite.isSuperAccess()){\r", "+\t\t\t\t}\r", "+\t\t\t\t// receiverType can be an array binding in one case... see if you can change it\r", "+\t\t\t\tif (receiverType instanceof ArrayBinding){\r", "+\t\t\t\t\treturn false;\r", "+\t\t\t\t}\r", "+\t\t\t\tif (isStatic()){\r", "+\t\t\t\t}\r", "+\t\t\t\tif (currentType == receiverType || currentType.isSuperclassOf((ReferenceBinding) receiverType)){\r", "+\t\t\t\t\tif (depth > 0) invocationSite.setDepth(depth);\r", "+\t\t\t\t\treturn true;\r", "+\t\t\t\t}\r", "+\t\t\tdepth++;\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ceb8cb02bff7c3a26c34e569b09ece5d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java", "commitBeforeChange": "4374063ffc07d9e5a6e12269e991cbcb89c32543", "commitAfterChange": "996ea5997dae4e7ec05722a233804ef32ae29f15", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 21, "signatureBeforeChange": " \tpublic String getQualifiedName()", "signatureAfterChange": " \tpublic String getQualifiedName()", "diff": ["-\t\t", "-\t\tif (isPrimitive() || isNullType() || this.isTypeVariable()) {", "-\t\t\treturn new String(this.binding.sourceName());", "+\t\tif (isPrimitive() || isNullType()) {", "+\t\t\tBaseTypeBinding baseTypeBinding = (BaseTypeBinding) this.binding;", "+\t\t\treturn new String(baseTypeBinding.simpleName);", "-\t\t", "-\t\tif (isArray()) {", "-\t\t\tITypeBinding elementType = getElementType();", "-\t\t\tString elementTypeQualifiedName = elementType.getQualifiedName();", "-\t\t\tif (elementTypeQualifiedName.length() != 0) {", "-\t\t\t\tint dimensions = this.getDimensions();", "-\t\t\t\tchar[] brackets = new char[dimensions * 2];", "-\t\t\t\tfor (int i = dimensions * 2 - 1; i >= 0; i -= 2) {", "-\t\t\t\t\tbrackets[i] = ']';", "-\t\t\t\t\tbrackets[i - 1] = '[';", "-\t\t\t\t}", "-\t\t\t\tStringBuffer stringBuffer = new StringBuffer(elementTypeQualifiedName);", "-\t\t\t\tstringBuffer.append(brackets);", "-\t\t\t\treturn stringBuffer.toString();", "-\t\t\t} else {", "-\t\t\t\treturn NO_NAME;", "-\t\t\t}", "-\t\t}", "-\t\tif (isTopLevel() || isMember()) {", "-\t\t\tPackageBinding packageBinding = this.binding.getPackage();", "-\t\t\t", "+\t\tif (isWildcardType()) {", "+\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) this.binding;", "-\t\t\tif (isWildcardType()) {", "-\t\t\t\tbuffer.append(TypeConstants.WILDCARD_NAME);", "-\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) this.binding;", "-\t\t\t\tif (wildcardBinding.bound != null) {", "-\t\t\t\t\tswitch(wildcardBinding.kind) {", "-\t\t\t\t\t\tcase Wildcard.SUPER :", "-\t\t\t\t\t\t\tbuffer.append(TypeConstants.WILDCARD_SUPER);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\tcase Wildcard.EXTENDS :", "-\t\t\t\t\t\t\tbuffer.append(TypeConstants.WILDCARD_EXTENDS);", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tbuffer.append(getBound().getQualifiedName());\t\t\t\t", "+\t\t\tbuffer.append(TypeConstants.WILDCARD_NAME);", "+\t\t\tfinal ITypeBinding bound = getBound();", "+\t\t\tif (bound != null) {", "+\t\t\t\tswitch(wildcardBinding.kind) {", "+\t\t\t        case Wildcard.SUPER :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_SUPER);", "+\t\t\t            break;", "+\t\t\t        case Wildcard.EXTENDS :", "+\t\t\t        \tbuffer.append(TypeConstants.WILDCARD_EXTENDS);", "-\t\t\t} else {", "-\t\t\t\tif (packageBinding != null && packageBinding.compoundName != CharOperation.NO_CHAR_CHAR) {", "-\t\t\t\t\tbuffer.append(packageBinding.readableName()).append('.');", "-\t\t\t\t}", "-\t\t\t\tbuffer.append(this.binding.qualifiedSourceName());", "-\t\t\t\tif (!isRawType()) {", "-\t\t\t\t\t// only one of the type parameters or type arguments is non-empty at the same time", "-\t\t\t\t\tappendQualifiedTypeParameters(buffer, getTypeParameters());", "-\t\t\t\t\tappendQualifiedTypeArguments(buffer, getTypeArguments());", "-\t\t\t\t}", "+\t\t\t\tbuffer.append(bound.getQualifiedName());", "-\t\treturn NO_NAME;", "+\t\tif (isRawType()) {", "+\t\t\treturn getErasure().getQualifiedName();", "+\t\t}", "+\t\tif (isArray()) {", "+\t\t\tITypeBinding elementType = getElementType();", "+\t\t\tif (elementType.isLocal() || elementType.isAnonymous()) {", "+\t\t\t\treturn NO_NAME;", "+\t\t\t}", "+\t\t\tfinal int dimensions = getDimensions();", "+\t\t\tchar[] brackets = new char[dimensions * 2];", "+\t\t\tfor (int i = dimensions * 2 - 1; i >= 0; i -= 2) {", "+\t\t\t\tbrackets[i] = ']';", "+\t\t\t\tbrackets[i - 1] = '[';", "+\t\t\t}", "+\t\t\tStringBuffer buffer = new StringBuffer(elementType.getQualifiedName());", "+\t\t\tbuffer.append(brackets);", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isTypeVariable()) {", "+\t\t\tTypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.binding;", "+\t\t\treturn new String(typeVariableBinding.sourceName);", "+\t\t}", "+\t\tif (isMember()) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer", "+\t\t\t\t.append(this.resolver.getTypeBinding(this.binding.enclosingType()).getQualifiedName())", "+\t\t\t\t.append('.')", "+\t\t\t\t.append(getName());", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isParameterizedType()) {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\tbuffer.append(getErasure().getQualifiedName());", "+\t\t\tITypeBinding[] typeArguments = getTypeArguments();", "+\t\t\tfinal int typeArgumentsLength = typeArguments.length;", "+\t\t\tif (typeArgumentsLength != 0) {", "+\t\t\t\tbuffer.append('<');", "+\t\t\t\tfor (int i = 0, max = typeArguments.length; i < max; i++) {", "+\t\t\t\t\tif (i > 0) {", "+\t\t\t\t\t\tbuffer.append(',');", "+\t\t\t\t\t}", "+\t\t\t\t\tbuffer.append(typeArguments[i].getQualifiedName());", "+\t\t\t\t}", "+\t\t\t\tbuffer.append('>');", "+\t\t\t}", "+\t\t\treturn String.valueOf(buffer);", "+\t\t}", "+\t\tif (isRawType()) {", "+\t\t\treturn getErasure().getQualifiedName();", "+\t\t}", "+\t\tPackageBinding packageBinding = this.binding.getPackage();", "+\t\t", "+\t\tStringBuffer buffer = new StringBuffer();", "+\t\tif (packageBinding != null && packageBinding.compoundName != CharOperation.NO_CHAR_CHAR) {", "+\t\t\tbuffer.append(CharOperation.concatWith(packageBinding.compoundName, '.')).append('.');", "+\t\t}", "+\t\tbuffer.append(getName());", "+", "+\t\treturn String.valueOf(buffer);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "d42594cbe2caf135880240474578e036", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java", "commitBeforeChange": "33e03339ed2881c9f793c3a49497633bbac5c8a8", "commitAfterChange": "09c3f545375b31028657f0b8044c5cbcb5324abc", "methodNumberBeforeChange": 7, "methodNumberAfterChange": 7, "signatureBeforeChange": " private void buildMoreCompletionContext(Expression expression)", "signatureAfterChange": " private void buildMoreCompletionContext(Expression expression)", "diff": ["+\t\t\tcase K_BETWEEN_IF_AND_RIGHT_PAREN :", "+\t\t\t\tIfStatement ifStatement = new IfStatement(expression, new EmptyStatement(expression.sourceEnd, expression.sourceEnd), expression.sourceStart, expression.sourceEnd);", "+\t\t\t\tassistNodeParent = ifStatement;", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_BETWEEN_WHILE_AND_RIGHT_PAREN :", "+\t\t\t\tWhileStatement whileStatement = new WhileStatement(expression, new EmptyStatement(expression.sourceEnd, expression.sourceEnd), expression.sourceStart, expression.sourceEnd);", "+\t\t\t\tassistNodeParent = whileStatement;", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_BETWEEN_SWITCH_AND_RIGHT_PAREN:", "+\t\t\t\tSwitchStatement switchStatement = new SwitchStatement();", "+\t\t\t\tswitchStatement.expression = expression;", "+\t\t\t\tswitchStatement.statements = new Statement[0];", "+\t\t\t\tassistNodeParent = switchStatement;", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_BETWEEN_SYNCHRONIZED_AND_RIGHT_PAREN :", "+\t\t\t\tSynchronizedStatement synchronizedStatement = new SynchronizedStatement(expression, new Block(0), expression.sourceStart, expression.sourceEnd);", "+\t\t\t\tassistNodeParent = synchronizedStatement;", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_INSIDE_THROW_STATEMENT:", "+\t\t\t\tif(info == bracketDepth) {", "+\t\t\t\t\tThrowStatement throwStatement = new ThrowStatement(expression, expression.sourceStart, expression.sourceEnd);", "+\t\t\t\t\tassistNodeParent = throwStatement;", "+\t\t\t\t}", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_INSIDE_ASSERT_STATEMENT:", "+\t\t\t\tif(info == bracketDepth) {", "+\t\t\t\t\tAssertStatement assertStatement = new AssertStatement(expression, expression.sourceStart);", "+\t\t\t\t\tassistNodeParent = assertStatement;", "+\t\t\t\t}", "+\t\t\t\tbreak nextElement;", "+\t\t\tcase K_INSIDE_ASSERT_EXCEPTION:", "+\t\t\t\tif(info == bracketDepth) {", "+\t\t\t\t\tAssertStatement assertStatement = new AssertStatement(expression, new TrueLiteral(expression.sourceStart, expression.sourceStart), expression.sourceStart);", "+\t\t\t\t\tassistNodeParent = assertStatement;", "+\t\t\t\t}", "+\t\t\t\tbreak nextElement;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "e121335bf8c1c7038e3a7e51ce62fd28", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java", "commitBeforeChange": "f6b4fd201225783143c8aa7d615f417f01e17763", "commitAfterChange": "99dc83c87acb33ba34a918de9dea75beba3da624", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 9, "signatureBeforeChange": " \tpublic String getKey()", "signatureAfterChange": " \tpublic String getKey()", "diff": ["-\t\t}\t\t\t", "-\t\treturn null;", "+\t\t} else {", "+\t\t\tStringBuffer buffer = new StringBuffer();", "+\t\t\t", "+\t\t\t// declaring method or type", "+\t\t\tLocalVariableBinding localVarBinding = (LocalVariableBinding) this.binding;", "+\t\t\tBlockScope scope = localVarBinding.declaringScope;", "+\t\t\tMethodScope methodScope = scope instanceof MethodScope ? (MethodScope) scope : scope.enclosingMethodScope();", "+\t\t\tReferenceContext referenceContext = methodScope.referenceContext;", "+\t\t\tif (referenceContext instanceof AbstractMethodDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.MethodBinding internalBinding = ((AbstractMethodDeclaration) referenceContext).binding;", "+\t\t\t\tIMethodBinding methodBinding = this.resolver.getMethodBinding(internalBinding);", "+\t\t\t\tif (methodBinding != null) {", "+\t\t\t\t\tbuffer.append(methodBinding.getKey());", "+\t\t\t\t}", "+\t\t\t} else if (referenceContext instanceof TypeDeclaration) {", "+\t\t\t\torg.eclipse.jdt.internal.compiler.lookup.TypeBinding internalBinding = ((TypeDeclaration) referenceContext).binding;", "+\t\t\t\tITypeBinding typeBinding = this.resolver.getTypeBinding(internalBinding);", "+\t\t\t\tif (typeBinding != null) {", "+\t\t\t\t\tbuffer.append(typeBinding.getKey());", "+\t\t\t\t}", "+\t\t\t}", "+", "+\t\t\t// scope index", "+\t\t\tgetKey(((LocalVariableBinding) this.binding).declaringScope, buffer);", "+", "+\t\t\t// variable name", "+\t\t\tbuffer.append('/');", "+\t\t\tbuffer.append(getName());", "+\t\t\t", "+\t\t\treturn buffer.toString();", "+\t\t}", "+\t}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f0a30ea19d734587211fe1bc782bc425", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java", "commitBeforeChange": "ad3220b4b434313891b223270deb616283ce8051", "commitAfterChange": "c0a30fbd56f0faf040945ca7720c23f3dd404282", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 23, "signatureBeforeChange": " \t \tprivate static void resolvedChainedLibraries(IPath jarPath, HashSet visited, ArrayList result)", "signatureAfterChange": " \t \tprivate static void resolvedChainedLibraries(IPath jarPath, HashSet visited, ArrayList result)", "diff": ["-\t\tObject target = JavaModel.getTarget(jarPath, true/*check existence, otherwise the manifest cannot be read*/);", "-\t\tif (target instanceof IFile || target instanceof File) {", "-\t\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "-\t\t\tZipFile zip = null;", "-\t\t\tBufferedReader reader = null;", "-\t\t\ttry {", "-\t\t\t\tzip = manager.getZipFile(jarPath);", "-\t\t\t\tZipEntry manifest =\tzip.getEntry(\"META-INF/MANIFEST.MF\"); //$NON-NLS-1$", "-\t\t\t\tif (manifest != null) { // non-null implies regular file", "-\t\t\t\t\treader = new BufferedReader(new InputStreamReader(zip.getInputStream(manifest)));", "-\t\t\t\t\tManifestAnalyzer analyzer = new ManifestAnalyzer();", "-\t\t\t\t\tboolean success = analyzer.analyzeManifestContents(reader);", "-\t\t\t\t\tList calledFileNames = analyzer.getCalledFileNames();", "-\t\t\t\t\tif (!success || analyzer.getClasspathSectionsCount() == 1 && calledFileNames == null) {", "-\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\tUtil.verbose(\"Invalid Class-Path header in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn;", "-\t\t\t\t\t} else if (analyzer.getClasspathSectionsCount() > 1) {", "-\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\tUtil.verbose(\"Multiple Class-Path headers in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$", "-\t\t\t\t\t\t}", "-\t\t\t\t\t\treturn;", "+\t\tJavaModelManager manager = JavaModelManager.getJavaModelManager();", "+\t\tif (manager.isNonChainingJar(jarPath))", "+\t\t\treturn;", "+\t\tList calledFileNames = getCalledFileNames(jarPath);", "+\t\tif (calledFileNames == null) {", "+\t\t\tmanager.addNonChainingJar(jarPath);", "+\t\t} else {", "+\t\t\tIterator calledFilesIterator = calledFileNames.iterator();", "+\t\t\tIPath directoryPath = jarPath.removeLastSegments(1);", "+\t\t\twhile (calledFilesIterator.hasNext()) {", "+\t\t\t\tString calledFileName = (String) calledFilesIterator.next();", "+\t\t\t\tif (!directoryPath.isValidPath(calledFileName)) {", "+\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "+\t\t\t\t\t\tUtil.verbose(\"Invalid Class-Path entry \" + calledFileName + \" in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\t\tif (calledFileNames != null) {", "-\t\t\t\t\t\tIterator calledFilesIterator = calledFileNames.iterator();", "-\t\t\t\t\t\tIPath directoryPath = jarPath.removeLastSegments(1);", "-\t\t\t\t\t\twhile (calledFilesIterator.hasNext()) {", "-\t\t\t\t\t\t\tString calledFileName = (String) calledFilesIterator.next();", "-\t\t\t\t\t\t\tif (!directoryPath.isValidPath(calledFileName)) {", "-\t\t\t\t\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\t\t\t\t\tUtil.verbose(\"Invalid Class-Path entry \" + calledFileName + \" in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$ //$NON-NLS-2$", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\tIPath calledJar = directoryPath.append(new Path(calledFileName));", "-\t\t\t\t\t\t\t\tresolvedChainedLibraries(calledJar, visited, result);", "-\t\t\t\t\t\t\t\tresult.add(calledJar);", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t} catch (CoreException e) {", "-\t\t\t\t// not a zip file", "-\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\tUtil.verbose(\"Could not read Class-Path header in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$", "-\t\t\t\t\te.printStackTrace();", "-\t\t\t\t}", "-\t\t\t} catch (IOException e) {", "-\t\t\t\t// not a zip file", "-\t\t\t\tif (JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {", "-\t\t\t\t\tUtil.verbose(\"Could not read Class-Path header in manifest of jar file: \" + jarPath.toOSString()); //$NON-NLS-1$", "-\t\t\t\t\te.printStackTrace();", "-\t\t\t\t}", "-\t\t\t} finally {", "-\t\t\t\tmanager.closeZipFile(zip);", "-\t\t\t\tif (reader != null) {", "-\t\t\t\t\ttry {", "-\t\t\t\t\t\treader.close();", "-\t\t\t\t\t} catch (IOException e) {", "-\t\t\t\t\t\t// best effort", "-\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\tIPath calledJar = directoryPath.append(new Path(calledFileName));", "+\t\t\t\t\tresolvedChainedLibraries(calledJar, visited, result);", "+\t\t\t\t\tresult.add(calledJar);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "ff1acf23a4730b248809105e55563a11", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java", "commitBeforeChange": "aa46ed677ee85f03d71a5e403b6a2449b883ffe1", "commitAfterChange": "c0de86876da4886baced9b3782c3e678b86d856e", "methodNumberBeforeChange": 340, "methodNumberAfterChange": 117, "signatureBeforeChange": " public void test2999_coverage()", "signatureAfterChange": " public void test0340_if_else_nested()", "diff": ["+// null analysis - if/else nested", "+public void test0340_if_else_nested() {", "+\tthis.runNegativeTest(", "+\t\tnew String[] {", "+\t\t\t\"X.java\",", "+\t\t\t\"public class X {\\n\" + ", "+\t\t\t\"  void foo(Object o) {\\n\" + ", "+\t\t\t\"    if (o == null) {\\n\" + ", "+\t\t\t\"      if (bar() == o) {\\n\" + ", "+\t\t\t\"        o.toString();\\n\" + ", "+\t\t\t\"      }\\n\" + ", "+\t\t\t\"    }\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"  Object bar() {\\n\" + ", "+\t\t\t\"    return new Object();\\n\" + ", "+\t\t\t\"  }\\n\" + ", "+\t\t\t\"}\"},", "+\t\t\"----------\\n\" + ", "+\t\t\"1. ERROR in X.java (at line 5)\\n\" + ", "+\t\t\"\to.toString();\\n\" + ", "+\t\t\"\t^\\n\" + ", "+\t\t\"The variable o can only be null; it was either set to null or checked for null when last used\\n\" + ", "+\t\t\"----------\\n\");", "+}", "-// Coverage by code samples.", "-public void test2999_coverage() {", "-\tif (UnconditionalFlowInfo.coverageTestFlag) {", "-\t\t// sanity check: need to be sure that the tests execute properly when not", "-\t\t// trying to check coverage", "-\t\tUnconditionalFlowInfo.coverageTestId = 0;", "-\t\ttest0001_simple_local();", "-\t\ttest0053_array();", "-\t\ttest0070_type_reference();", "-\t\ttest0327_if_else();", "-\t\ttest0401_while();", "-\t\ttest0420_while();", "-\t\ttest0509_try_finally_embedded();", "-\t\ttest2000_flow_info();", "-\t\ttest2004_flow_info();", "-\t\ttest2008_flow_info();", "-\t\ttest2011_flow_info();", "-\t\ttest2013_flow_info();", "-\t\ttest2018_flow_info();", "-\t\ttest2019_flow_info();", "-\t\ttest2020_flow_info();", "-\t\t// coverage check", "-\t\tint failuresNb = 0;", "-\t\tfor (int i = 1; i <= coveragePointsNb; i++) {", "-\t\t\tif (i > 4 && i < 15 ||", "-\t\t\t\ti > 15 && i < 19 ||", "-\t\t\t\ti == 22 ||", "-\t\t\t\ti == 23 ||", "-\t\t\t\ti == 27 ||", "-\t\t\t\ti == 28 ||", "-\t\t\t\ti == 30 ||", "-\t\t\t\ti == 33 ||", "-\t\t\t\ti == 34 ||", "-\t\t\t\ti == 38 ||", "-\t\t\t\ti >= 43", "-\t\t\t\t) { // TODO (maxime) complete coverage tests", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\ttry {", "-\t\t\t\tUnconditionalFlowInfo.coverageTestId = i;", "-\t\t\t\ttest0001_simple_local();", "-\t\t\t\ttest0053_array();", "-\t\t\t\ttest0070_type_reference();", "-\t\t\t\ttest0327_if_else();", "-\t\t\t\ttest0401_while();", "-\t\t\t\ttest0420_while();", "-\t\t\t\ttest0509_try_finally_embedded();", "-\t\t\t\ttest2000_flow_info();", "-\t\t\t\ttest2004_flow_info();", "-\t\t\t\ttest2008_flow_info();", "-\t\t\t\ttest2011_flow_info();", "-\t\t\t\ttest2013_flow_info();", "-\t\t\t\ttest2018_flow_info();", "-\t\t\t\ttest2019_flow_info();", "-\t\t\t\ttest2020_flow_info();", "-\t\t\t}", "-\t\t\tcatch (AssertionFailedError e) {", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tcatch (AssertionFailedException e) {", "-\t\t\t\tcontinue;", "-\t\t\t}", "-\t\t\tfailuresNb++;", "-\t\t\tSystem.out.println(\"Missing coverage point: \" + i);", "-\t\t}", "-\t\tUnconditionalFlowInfo.coverageTestId = 0; // reset for other tests", "-\t\tassertEquals(failuresNb + \" missing coverage point(s)\", failuresNb, 0);", "-\t}", "-}"]}], "num": 49873}