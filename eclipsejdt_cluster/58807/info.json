{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "b5004e912d0366d8b43e7eaaa42b5ef7", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "45d4bc14780bef31fc31819ffabf0981", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "98ad487e103c268099d7117573693243c8d3b8fc", "commitAfterChange": "721a9dcda02493639666143934bddb089e848d18", "methodNumberBeforeChange": 71, "methodNumberAfterChange": 72, "signatureBeforeChange": " protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException", "signatureAfterChange": " protected void reportMatching(TypeDeclaration type, IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, int occurrenceCount) throws CoreException", "diff": ["-\t", "+", "-\t\tfor (int i=0, l=type.typeParameters.length; i<l; i++) {", "-\t\t\tTypeParameter typeParameter = type.typeParameters[i];", "-\t\t\tif (typeParameter != null) {", "-\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(typeParameter);", "-\t\t\t\tif (level != null && matchedClassContainer) {", "-\t\t\t\t\tif (level.intValue() > -1 && enclosesElement) {", "-\t\t\t\t\t\tint offset = typeParameter.sourceStart;", "-\t\t\t\t\t\tSearchMatch match = this.patternLocator.newDeclarationMatch(typeParameter, enclosingElement, type.binding, level.intValue(), typeParameter.sourceEnd-offset+1, this);", "-\t\t\t\t\t\treport(match);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (typeParameter.type != null) {", "-\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeParameter.type);", "-\t\t\t\t\tif (level != null && matchedClassContainer) {", "-\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeParameter.type, enclosingElement, type.binding, level.intValue(), this);", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t\tif (typeParameter.bounds != null) {", "-\t\t\t\t\tfor (int j=0, b=typeParameter.bounds.length; j<b; j++) {", "-\t\t\t\t\t\tlevel = (Integer) nodeSet.matchingNodes.removeKey(typeParameter.bounds[j]);", "-\t\t\t\t\t\tif (level != null && matchedClassContainer) {", "-\t\t\t\t\t\t\tthis.patternLocator.matchReportReference(typeParameter.bounds[j], enclosingElement, type.binding, level.intValue(), this);", "-\t\t\t\t\t\t}", "-\t\t\t\t\t}", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "+\t\treportMatching(type.typeParameters, enclosingElement, parent, type.binding, nodeSet);", "+\t// Visit fields", "-\t\tif (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes", "+\t\tif (nodeSet.matchingNodes.elementSize == 0) return;\t// end as all matching nodes were reported", "+\t\tIJavaElement[] otherElements = null;", "+\t\tint first = -1;", "-\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(field);", "-\t\t\tint value = (level != null && matchedClassContainer) ? level.intValue() : -1;", "-\t\t\treportMatching(field, type, enclosingElement, value, typeInHierarchy, nodeSet);", "+\t\t\tboolean last = field.endPart2Position == 0 || field.declarationEnd == field.endPart2Position;", "+\t\t\t// Store first index of multiple field declaration", "+\t\t\tif (!last) {", "+\t\t\t\tif (first == -1) {", "+\t\t\t\t\tfirst = i;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\t// Mutliple declaration fields", "+\t\t\tif (first >= 0) {", "+\t\t\t\t// Create handle for all multiple fields except first one as it would be returned through the match", "+\t\t\t\tif (i > first) {", "+\t\t\t\t\tif (otherElements == null) {", "+\t\t\t\t\t\totherElements = new IJavaElement[] { createHandle(field, type, enclosingElement) };", "+\t\t\t\t\t} else {", "+\t\t\t\t\t\tint length = otherElements.length;", "+\t\t\t\t\t\tSystem.arraycopy(otherElements, 0, otherElements = new IJavaElement[length+1], 0, length);", "+\t\t\t\t\t\totherElements[length] = createHandle(field, type, enclosingElement);", "+\t\t\t\t\t}", "+\t\t\t\t}", "+\t\t\t\t// On last field, report match with all other elements", "+\t\t\t\tif (last) {", "+\t\t\t\t\tfor (int j=first; j<=i; j++) {", "+\t\t\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(fields[j]);", "+\t\t\t\t\t\tint value = (level != null && matchedClassContainer) ? level.intValue() : -1;", "+\t\t\t\t\t\treportMatching(fields[j], type, enclosingElement, otherElements, value, typeInHierarchy, nodeSet);", "+\t\t\t\t\t}", "+\t\t\t\t\tfirst = -1;", "+\t\t\t\t\totherElements = null;", "+\t\t\t\t}", "+\t\t\t} else {", "+\t\t\t\t// Single field, report normally", "+\t\t\t\tInteger level = (Integer) nodeSet.matchingNodes.removeKey(field);", "+\t\t\t\tint value = (level != null && matchedClassContainer) ? level.intValue() : -1;", "+\t\t\t\treportMatching(field, type, enclosingElement, null, value, typeInHierarchy, nodeSet);", "+\t\t\t}", "+\t// Visit methods", "-\t\tif (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes", "+\t\tif (nodeSet.matchingNodes.elementSize == 0) return;\t// end as all matching nodes were reported", "+\t// Visit types", "-\t\t\tif (nodeSet.matchingNodes.elementSize == 0) return; // reported all the matching nodes", "+\t\t\tif (nodeSet.matchingNodes.elementSize == 0) return;\t// end as all matching nodes were reported"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "b226c5265b2a57b98d0022aa5f6efe9e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java", "commitBeforeChange": "0492d8e41c1aba4d81d43f5d644f4506ed10c8ab", "commitAfterChange": "cbb80b4c969d064367ed598ba99f074660c726c6", "methodNumberBeforeChange": 23, "methodNumberAfterChange": 24, "signatureBeforeChange": " \tboolean incorporate(InferenceContext18 context) throws InferenceFailureException", "signatureAfterChange": " \tboolean incorporate(InferenceContext18 context, TypeBound [] first, TypeBound [] next) throws InferenceFailureException", "diff": ["-\tboolean incorporate(InferenceContext18 context) throws InferenceFailureException {", "-\t\tif (this.isIncorporated)", "-\t\t\treturn true;", "+\tboolean incorporate(InferenceContext18 context, TypeBound [] first, TypeBound [] next) throws InferenceFailureException {", "-\t\tdo {", "-\t\t\tthis.isIncorporated = true;", "-\t\t\t// using a flattened copy also allows us to insert more bounds during the process", "-\t\t\t// without disturbing the current round of incorporation:", "-\t\t\tTypeBound[] bounds = flatten();", "-\t\t\tint boundsCount = bounds.length;", "-\t\t\tif (boundsCount < 2)", "-\t\t\t\treturn true;", "-\t\t\t// check each pair:", "-\t\t\tfor (int i = 0; i < boundsCount; i++) {", "-\t\t\t\tTypeBound boundI = bounds[i];", "-\t\t\t\tfinal boolean setHasI = boundI.id < this.incorporatedBounds.length && this.incorporatedBounds[boundI.id] == true;", "-\t\t\t\tfor (int j = i+1; j < boundsCount; j++) {", "-\t\t\t\t\tTypeBound boundJ = bounds[j];", "-\t\t\t\t\tif (setHasI && boundJ.id < this.incorporatedBounds.length && this.incorporatedBounds[boundJ.id] == true)", "-\t\t\t\t\t\tcontinue;", "+\t\tConstraintTypeFormula [] mostRecentFormulas = new ConstraintTypeFormula[4]; // poor man's cache to toss out duplicates, in pathological cases there are a good quarter million of them.", "+\t\t// check each pair, in each way.", "+\t\tfor (int i = 0, iLength = first.length; i < iLength; i++) {", "+\t\t\tTypeBound boundI = first[i];", "+\t\t\tfor (int j = 0, jLength = next.length; j < jLength; j++) {", "+\t\t\t\tTypeBound boundJ = next[j];", "+\t\t\t\tint iteration = 1;", "+\t\t\t\tdo {", "+\t\t\t\t\tif (iteration == 2) {", "+\t\t\t\t\t\tTypeBound boundX = boundI;", "+\t\t\t\t\t\tboundI = boundJ;", "+\t\t\t\t\t\tboundJ = boundX;", "+\t\t\t\t\t}", "+\t\t\t\t\t\tif (newConstraint.left == newConstraint.right) { //$IDENTITY-COMPARISON$", "+\t\t\t\t\t\t\tnewConstraint = null;", "+\t\t\t\t\t\t} else \tif (newConstraint.equalsEquals(mostRecentFormulas[0]) || newConstraint.equalsEquals(mostRecentFormulas[1]) ||", "+\t\t\t\t\t\t\t\t\tnewConstraint.equalsEquals(mostRecentFormulas[2]) || newConstraint.equalsEquals(mostRecentFormulas[3])) {", "+\t\t\t\t\t\t\tnewConstraint = null;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t}", "+\t\t\t\t\tif (newConstraint != null) {", "+\t\t\t\t\t\t// bubble formulas around the cache.", "+\t\t\t\t\t\tmostRecentFormulas[3] = mostRecentFormulas[2];", "+\t\t\t\t\t\tmostRecentFormulas[2] = mostRecentFormulas[1];", "+\t\t\t\t\t\tmostRecentFormulas[1] = mostRecentFormulas[0];", "+\t\t\t\t\t\tmostRecentFormulas[0] = newConstraint;", "+\t\t\t\t\t", "+\t\t\t\t\t\t", "-\t\t\t\t}", "-\t\t\t\tif (!setHasI) {", "-\t\t\t\t\tint length = this.incorporatedBounds.length;", "-\t\t\t\t\tif (boundI.id >= length)", "-\t\t\t\t\t\tSystem.arraycopy(this.incorporatedBounds, 0, this.incorporatedBounds = new boolean[boundI.id * 2], 0, length);", "-\t\t\t\t\tthis.incorporatedBounds[boundI.id] = true;", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\t/* TODO: are we sure this will always terminate? Cf. e.g. (Discussion in 18.3):", "-\t\t\t *  ", "-\t\t\t *    \"The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. ...\"", "-\t\t\t */", "-\t\t\tIterator<Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captIter = this.captures.entrySet().iterator();", "-\t\t\twhile (captIter.hasNext()) {", "-\t\t\t\tEntry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();", "-\t\t\t\tParameterizedTypeBinding gAlpha = capt.getKey();", "-\t\t\t\tParameterizedTypeBinding gA = capt.getValue();", "-\t\t\t\tReferenceBinding g = (ReferenceBinding) gA.original();", "-\t\t\t\tfinal TypeVariableBinding[] parameters = g.typeVariables();", "-\t\t\t\t// construct theta = [P1:=alpha1,...]", "-\t\t\t\tfinal InferenceVariable[] alphas = new InferenceVariable[gAlpha.arguments.length];", "-\t\t\t\tSystem.arraycopy(gAlpha.arguments, 0, alphas, 0, alphas.length);", "-\t\t\t\tInferenceSubstitution theta = new InferenceSubstitution(context.environment, alphas) {", "-\t\t\t\t\t@Override", "-\t\t\t\t\tprotected TypeBinding getP(int i) {", "-\t\t\t\t\t\treturn parameters[i];", "+\t\t\t\t\tif (iteration == 2) {", "+\t\t\t\t\t\tTypeBound boundX = boundI;", "+\t\t\t\t\t\tboundI = boundJ;", "+\t\t\t\t\t\tboundJ = boundX;", "-\t\t\t\t};", "-\t\t\t\tfor (int i = 0, length = parameters.length; i < length; i++) {", "-\t\t\t\t\t// A set of bounds on \u03b11, ..., \u03b1n, constructed from the declared bounds of P1, ..., Pn as described in 18.1.3, is immediately implied.", "-\t\t\t\t\tTypeVariableBinding pi = parameters[i];", "-\t\t\t\t\tInferenceVariable alpha = (InferenceVariable) gAlpha.arguments[i];", "-\t\t\t\t\taddBounds(pi.getTypeBounds(alpha, theta), context.environment);", "+\t\t\t\t} while (first != next && ++iteration <= 2);", "+\t\t\t}", "+\t\t}", "+\t\t/* TODO: are we sure this will always terminate? Cf. e.g. (Discussion in 18.3):", "+\t\t *  ", "+\t\t *    \"The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. ...\"", "+\t\t */", "+\t\tIterator<Entry<ParameterizedTypeBinding, ParameterizedTypeBinding>> captIter = this.captures.entrySet().iterator();", "+\t\twhile (captIter.hasNext()) {", "+\t\t\tEntry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();", "+\t\t\tParameterizedTypeBinding gAlpha = capt.getKey();", "+\t\t\tParameterizedTypeBinding gA = capt.getValue();", "+\t\t\tReferenceBinding g = (ReferenceBinding) gA.original();", "+\t\t\tfinal TypeVariableBinding[] parameters = g.typeVariables();", "+\t\t\t// construct theta = [P1:=alpha1,...]", "+\t\t\tfinal InferenceVariable[] alphas = new InferenceVariable[gAlpha.arguments.length];", "+\t\t\tSystem.arraycopy(gAlpha.arguments, 0, alphas, 0, alphas.length);", "+\t\t\tInferenceSubstitution theta = new InferenceSubstitution(context.environment, alphas) {", "+\t\t\t\t@Override", "+\t\t\t\tprotected TypeBinding getP(int i) {", "+\t\t\t\t\treturn parameters[i];", "+\t\t\t\t}", "+\t\t\t};", "+\t\t\tfor (int i = 0, length = parameters.length; i < length; i++) {", "+\t\t\t\t// A set of bounds on \u03b11, ..., \u03b1n, constructed from the declared bounds of P1, ..., Pn as described in 18.1.3, is immediately implied.", "+\t\t\t\tTypeVariableBinding pi = parameters[i];", "+\t\t\t\tInferenceVariable alpha = (InferenceVariable) gAlpha.arguments[i];", "+\t\t\t\taddBounds(pi.getTypeBounds(alpha, theta), context.environment);", "-\t\t\t\t\tTypeBinding ai = gA.arguments[i];", "-\t\t\t\t\tif (ai instanceof WildcardBinding) {", "-\t\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding)ai;", "-\t\t\t\t\t\tTypeBinding t = wildcardBinding.bound;", "-\t\t\t\t\t\tThreeSets three = this.boundsPerVariable.get(alpha.prototype());", "-\t\t\t\t\t\tif (three != null) {", "-\t\t\t\t\t\t\tIterator<TypeBound> it;", "-\t\t\t\t\t\t\tif (three.sameBounds != null) {", "-\t\t\t\t\t\t\t\t//  \u03b1 = R implies false", "-\t\t\t\t\t\t\t\tit = three.sameBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable))", "-\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t}", "+\t\t\t\tTypeBinding ai = gA.arguments[i];", "+\t\t\t\tif (ai instanceof WildcardBinding) {", "+\t\t\t\t\tWildcardBinding wildcardBinding = (WildcardBinding)ai;", "+\t\t\t\t\tTypeBinding t = wildcardBinding.bound;", "+\t\t\t\t\tThreeSets three = this.boundsPerVariable.get(alpha.prototype());", "+\t\t\t\t\tif (three != null) {", "+\t\t\t\t\t\tIterator<TypeBound> it;", "+\t\t\t\t\t\tif (three.sameBounds != null) {", "+\t\t\t\t\t\t\t//  \u03b1 = R implies false", "+\t\t\t\t\t\t\tit = three.sameBounds.iterator();", "+\t\t\t\t\t\t\twhile (it.hasNext()) {", "+\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "+\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable))", "+\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\tif (three.subBounds != null && pi.firstBound != null) {", "-\t\t\t\t\t\t\t\t// If Bi is Object, \u03b1 <: R implies \u27e8T <: R\u27e9\t(extends wildcard)", "-\t\t\t\t\t\t\t\t// \u03b1 <: R implies \u27e8\u03b8 Bi <: R\u27e9\t\t\t\t(else) ", "-\t\t\t\t\t\t\t\tit = three.subBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "-\t\t\t\t\t\t\t\t\t\tTypeBinding r = bound.right;", "-\t\t\t\t\t\t\t\t\t\tTypeBinding bi1 = pi.firstBound;", "-\t\t\t\t\t\t\t\t\t\tReferenceBinding[] otherBounds = pi.superInterfaces;", "-\t\t\t\t\t\t\t\t\t\tTypeBinding bi;", "-\t\t\t\t\t\t\t\t\t\tif (otherBounds == Binding.NO_SUPERINTERFACES) {", "-\t\t\t\t\t\t\t\t\t\t\tbi = bi1;", "-\t\t\t\t\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\t\t\t\t\tint n = otherBounds.length+1;", "-\t\t\t\t\t\t\t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[n];", "-\t\t\t\t\t\t\t\t\t\t\tallBounds[0] = (ReferenceBinding) bi1; // TODO is this safe?", "-\t\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(otherBounds, 0, allBounds, 1, n-1);", "-\t\t\t\t\t\t\t\t\t\t\tbi = new IntersectionCastTypeBinding(allBounds, context.environment);", "-\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, theta, wildcardBinding.boundKind, t, r, bi);", "-//\t\t\t\t\t\t\t\t\t\tif (otherBounds != null) {", "-//\t\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < otherBounds.length; j++) {", "-//\t\t\t\t\t\t\t\t\t\t\t\tTypeBinding tj = otherBounds[j];", "-//\t\t\t\t\t\t\t\t\t\t\t\tif (TypeBinding.notEquals(tj, t))", "-//\t\t\t\t\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, wildcardBinding, tj, r, bij);", "-//\t\t\t\t\t\t\t\t\t\t\t}", "-//\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\tif (three.subBounds != null && pi.firstBound != null) {", "+\t\t\t\t\t\t\t// If Bi is Object, \u03b1 <: R implies \u27e8T <: R\u27e9\t(extends wildcard)", "+\t\t\t\t\t\t\t// \u03b1 <: R implies \u27e8\u03b8 Bi <: R\u27e9\t\t\t\t(else) ", "+\t\t\t\t\t\t\tit = three.subBounds.iterator();", "+\t\t\t\t\t\t\twhile (it.hasNext()) {", "+\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "+\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "+\t\t\t\t\t\t\t\t\tTypeBinding r = bound.right;", "+\t\t\t\t\t\t\t\t\tTypeBinding bi1 = pi.firstBound;", "+\t\t\t\t\t\t\t\t\tReferenceBinding[] otherBounds = pi.superInterfaces;", "+\t\t\t\t\t\t\t\t\tTypeBinding bi;", "+\t\t\t\t\t\t\t\t\tif (otherBounds == Binding.NO_SUPERINTERFACES) {", "+\t\t\t\t\t\t\t\t\t\tbi = bi1;", "+\t\t\t\t\t\t\t\t\t} else {", "+\t\t\t\t\t\t\t\t\t\tint n = otherBounds.length+1;", "+\t\t\t\t\t\t\t\t\t\tReferenceBinding[] allBounds = new ReferenceBinding[n];", "+\t\t\t\t\t\t\t\t\t\tallBounds[0] = (ReferenceBinding) bi1; // TODO is this safe?", "+\t\t\t\t\t\t\t\t\t\tSystem.arraycopy(otherBounds, 0, allBounds, 1, n-1);", "+\t\t\t\t\t\t\t\t\t\tbi = new IntersectionCastTypeBinding(allBounds, context.environment);", "-\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\t}", "-\t\t\t\t\t\t\tif (three.superBounds != null) {", "-\t\t\t\t\t\t\t\t//  R <: \u03b1 implies \u27e8R <: T\u27e9  (super wildcard)", "-\t\t\t\t\t\t\t\t//  R <: \u03b1 implies false\t (else) ", "-\t\t\t\t\t\t\t\tit = three.superBounds.iterator();", "-\t\t\t\t\t\t\t\twhile (it.hasNext()) {", "-\t\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "-\t\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "-\t\t\t\t\t\t\t\t\t\tif (wildcardBinding.boundKind == Wildcard.SUPER)", "-\t\t\t\t\t\t\t\t\t\t\treduceOneConstraint(context, ConstraintTypeFormula.create(bound.right, t, ReductionResult.SUBTYPE));", "-\t\t\t\t\t\t\t\t\t\telse", "-\t\t\t\t\t\t\t\t\t\t\treturn false;", "-\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, theta, wildcardBinding.boundKind, t, r, bi);", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\tif (otherBounds != null) {", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < otherBounds.length; j++) {", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\tTypeBinding tj = otherBounds[j];", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\tif (TypeBinding.notEquals(tj, t))", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t\t\taddTypeBoundsFromWildcardBound(context, wildcardBinding, tj, r, bij);", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\t\t\t}", "-\t\t\t\t\t} else {", "-\t\t\t\t\t\taddBound(new TypeBound(alpha, ai, ReductionResult.SAME), context.environment);", "+\t\t\t\t\t\tif (three.superBounds != null) {", "+\t\t\t\t\t\t\t//  R <: \u03b1 implies \u27e8R <: T\u27e9  (super wildcard)", "+\t\t\t\t\t\t\t//  R <: \u03b1 implies false\t (else) ", "+\t\t\t\t\t\t\tit = three.superBounds.iterator();", "+\t\t\t\t\t\t\twhile (it.hasNext()) {", "+\t\t\t\t\t\t\t\tTypeBound bound = it.next();", "+\t\t\t\t\t\t\t\tif (!(bound.right instanceof InferenceVariable)) {", "+\t\t\t\t\t\t\t\t\tif (wildcardBinding.boundKind == Wildcard.SUPER)", "+\t\t\t\t\t\t\t\t\t\treduceOneConstraint(context, ConstraintTypeFormula.create(bound.right, t, ReductionResult.SUBTYPE));", "+\t\t\t\t\t\t\t\t\telse", "+\t\t\t\t\t\t\t\t\t\treturn false;", "+\t\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t\t}", "+\t\t\t\t\t\t}", "+\t\t\t\t} else {", "+\t\t\t\t\taddBound(new TypeBound(alpha, ai, ReductionResult.SAME), context.environment);", "-\t\t\tthis.captures.clear();", "-\t\t} while (!this.isIncorporated);", "+\t\t}"]}], "num": 58807}