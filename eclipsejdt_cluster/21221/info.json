{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "39dbfcec9aed9e070a42f56ce82f8493", "detectedBy": ["AST_HIERARCHICAL"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "be5f78964771973bcbc2ec70dd217e40", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java", "commitBeforeChange": "ea5c9cc312f4b4f8b75e3a6a2f95be1c2b2c1422", "commitAfterChange": "1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf", "methodNumberBeforeChange": 12, "methodNumberAfterChange": 13, "signatureBeforeChange": "  \tpublic void executeWraps()", "signatureAfterChange": "  \tpublic void executeWraps()", "diff": ["-\t\tmainLoop: while (index < this.tm.size()) {", "+\t\twhile (index < this.tm.size()) {", "-\t\t\thandleOnColumnIndent(index, token.getWrapPolicy());", "-\t\t\t// this might be a pre-existing wrap that should trigger other top priority wraps", "-\t\t\tint jumpToIndex = handleTopPriorityWraps(index);", "-\t\t\tif (jumpToIndex >= 0) {", "-\t\t\t\tindex = jumpToIndex;", "-\t\t\t\tcontinue mainLoop;", "+\t\t\twhile (true) {", "+\t\t\t\ttry {", "+\t\t\t\t\tint currentIndent = getWrapIndent(token);", "+\t\t\t\t\tthis.wrapSearchResults.clear();", "+\t\t\t\t\tindex = applyWraps(index, currentIndent);", "+\t\t\t\t\tbreak;", "+\t\t\t\t} catch (WrapRestartException e) {", "+\t\t\t\t\thandleTopPriorityWraps(e);", "+\t\t\t\t}", "-", "-\t\t\t// determine wraps for incoming line", "-\t\t\tint currentIndent = getWrapIndent(token);", "-\t\t\tboolean isLineWrapped = token.isWrappable();", "-\t\t\tWrapResult wrapResult = findWraps(index, currentIndent);", "-\t\t\tif (wrapResult == WrapResult.TOP_PRIORITY_WRAP_MET) {", "-\t\t\t\tjumpToIndex = handleTopPriorityWraps(this.topPriorityWrapIndex);", "-\t\t\t\tassert jumpToIndex >= 0;", "-\t\t\t\tindex = Math.min(index, jumpToIndex);", "-\t\t\t\tcontinue mainLoop;", "-\t\t\t}", "-", "-\t\t\t// apply wraps and indents", "-\t\t\tWrapInfo wrapInfo = wrapResult.nextWrap;", "-\t\t\twhile (wrapInfo != null) {", "-\t\t\t\tisLineWrapped = true;", "-\t\t\t\tfor (; index < wrapInfo.wrapTokenIndex; index++) {", "-\t\t\t\t\ttoken = this.tm.get(index);", "-\t\t\t\t\tif (shouldForceWrap(token, currentIndent)) {", "-\t\t\t\t\t\tcurrentIndent = token.getIndent();", "-\t\t\t\t\t\twrapInfo = new WrapInfo(index, currentIndent);", "-\t\t\t\t\t\tfindWrapsCached(index, currentIndent);", "-\t\t\t\t\t\tbreak;", "-\t\t\t\t\t}", "-\t\t\t\t\tcurrentIndent = Math.max(currentIndent, token.getAlign());", "-\t\t\t\t\ttoken.setIndent(currentIndent);", "-\t\t\t\t}", "-\t\t\t\ttoken = this.tm.get(index);", "-\t\t\t\ttoken.breakBefore();", "-\t\t\t\ttoken.setIndent(currentIndent = wrapInfo.indent);", "-\t\t\t\thandleOnColumnIndent(index, token.getWrapPolicy());", "-\t\t\t\tjumpToIndex = handleTopPriorityWraps(index);", "-\t\t\t\tif (jumpToIndex >= 0) {", "-\t\t\t\t\tindex = jumpToIndex;", "-\t\t\t\t\tcontinue mainLoop;", "-\t\t\t\t}", "-\t\t\t\twrapInfo = this.wrapSearchResults.get(wrapInfo).nextWrap;", "-\t\t\t}", "-", "-\t\t\t// apply indent until the beginning of the next line", "-\t\t\ttoken.setIndent(currentIndent);", "-\t\t\tfor (index++; index < this.tm.size(); index++) {", "-\t\t\t\tif (token.getLineBreaksAfter() > 0)", "-\t\t\t\t\tbreak;", "-\t\t\t\ttoken = this.tm.get(index);", "-\t\t\t\tif (token.isNextLineOnWrap() && isLineWrapped)", "-\t\t\t\t\ttoken.breakBefore();", "-\t\t\t\tif (token.getLineBreaksBefore() > 0)", "-\t\t\t\t\tbreak;", "-\t\t\t\tif (shouldForceWrap(token, currentIndent))", "-\t\t\t\t\tcurrentIndent = token.getIndent();", "-\t\t\t\tcurrentIndent = Math.max(currentIndent, token.getAlign());", "-\t\t\t\ttoken.setIndent(currentIndent);", "-\t\t\t}", "+\t\t\tthis.usedTopPriorityWraps.clear();", "-\t\tthis.wrapSearchResults.clear();", "-\t\tthis.usedTopPriorityWraps.clear();"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "f79213505eda583d4c266b90fbcbdc69", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java", "commitBeforeChange": "9275c96ab9e7e5e5f780672ec67bf57a1eb2d42e", "commitAfterChange": "437ac0488c92b5c24e88567c6caa0b204b0064ba", "methodNumberBeforeChange": 16, "methodNumberAfterChange": 17, "signatureBeforeChange": " public int literalIndex(MethodBinding aMethodBinding)", "signatureAfterChange": " public int literalIndex(MethodBinding aMethodBinding)", "diff": ["-\tint nameAndTypeIndex;", "-\tint classIndex;", "-\tint indexWellKnownMethod;", "-\tif ((indexWellKnownMethod = indexOfWellKnownMethods(aMethodBinding)) == -1) {", "-\t\tif (aMethodBinding.constantPoolDeclaringClass().isInterface()) {", "-\t\t\t// Lookinf into the interface method ref table", "-\t\t\tif ((index = interfaceMethodCache.get(aMethodBinding)) < 0) {", "-\t\t\t\tclassIndex = literalIndex(aMethodBinding.constantPoolDeclaringClass());", "-\t\t\t\tnameAndTypeIndex = literalIndexForMethods(literalIndex(aMethodBinding.constantPoolName()), literalIndex(aMethodBinding.signature()), aMethodBinding);", "-\t\t\t\tindex = interfaceMethodCache.put(aMethodBinding, currentIndex++);", "-\t\t\t\tif (index > 0xFFFF){", "-\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t\t\t}", "-\t\t\t\t// Write the interface method ref constant into the constant pool", "-\t\t\t\t// First add the tag", "-\t\t\t\twriteU1(InterfaceMethodRefTag);", "-\t\t\t\t// Then write the class index", "-\t\t\t\twriteU2(classIndex);", "-\t\t\t\t// The write the nameAndType index", "-\t\t\t\twriteU2(nameAndTypeIndex);", "-\t\t\t}", "-\t\t} else {", "-\t\t\t// Lookinf into the method ref table", "-\t\t\tif ((index = methodCache.get(aMethodBinding)) < 0) {", "-\t\t\t\tclassIndex = literalIndex(aMethodBinding.constantPoolDeclaringClass());", "-\t\t\t\tnameAndTypeIndex = literalIndexForMethods(literalIndex(aMethodBinding.constantPoolName()), literalIndex(aMethodBinding.signature()), aMethodBinding);", "-\t\t\t\tindex = methodCache.put(aMethodBinding, currentIndex++);", "-\t\t\t\tif (index > 0xFFFF){", "-\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t\t\t}", "-\t\t\t\t// Write the method ref constant into the constant pool", "-\t\t\t\t// First add the tag", "-\t\t\t\twriteU1(MethodRefTag);", "-\t\t\t\t// Then write the class index", "-\t\t\t\twriteU2(classIndex);", "-\t\t\t\t// The write the nameAndType index", "-\t\t\t\twriteU2(nameAndTypeIndex);", "-\t\t\t}", "+\tif ((index = getFromCache(aMethodBinding)) < 0) {", "+\t\tint classIndex = literalIndexForType(aMethodBinding.constantPoolDeclaringClass().constantPoolName());", "+\t\tint nameAndTypeIndex = literalIndexForMethods(literalIndex(aMethodBinding.constantPoolName()), literalIndex(aMethodBinding.signature()), aMethodBinding);", "+\t\tindex = putInCache(aMethodBinding, currentIndex++);", "+\t\tif (index > 0xFFFF){", "+\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t} else {", "-\t\t// This is a well known method", "-\t\tif ((index = wellKnownMethods[indexWellKnownMethod]) == 0) {", "-\t\t\t// this methods was not inserted yet", "-\t\t\tif (aMethodBinding.constantPoolDeclaringClass().isInterface()) {", "-\t\t\t\t// Lookinf into the interface method ref table", "-\t\t\t\tclassIndex = literalIndex(aMethodBinding.constantPoolDeclaringClass());", "-\t\t\t\tnameAndTypeIndex = literalIndexForMethods(literalIndex(aMethodBinding.constantPoolName()), literalIndex(aMethodBinding.signature()), aMethodBinding);", "-\t\t\t\tindex = wellKnownMethods[indexWellKnownMethod] = currentIndex++;", "-\t\t\t\tif (index > 0xFFFF){", "-\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t\t\t}", "-\t\t\t\t// Write the interface method ref constant into the constant pool", "-\t\t\t\t// First add the tag", "-\t\t\t\twriteU1(InterfaceMethodRefTag);", "-\t\t\t\t// Then write the class index", "-\t\t\t\twriteU2(classIndex);", "-\t\t\t\t// The write the nameAndType index", "-\t\t\t\twriteU2(nameAndTypeIndex);", "-\t\t\t} else {", "-\t\t\t\t// Lookinf into the method ref table", "-\t\t\t\tclassIndex = literalIndex(aMethodBinding.constantPoolDeclaringClass());", "-\t\t\t\tnameAndTypeIndex = literalIndexForMethods(literalIndex(aMethodBinding.constantPoolName()), literalIndex(aMethodBinding.signature()), aMethodBinding);", "-\t\t\t\tindex = wellKnownMethods[indexWellKnownMethod] = currentIndex++;", "-\t\t\t\tif (index > 0xFFFF){", "-\t\t\t\t\tthis.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());", "-\t\t\t\t}", "-\t\t\t\t// Write the method ref constant into the constant pool", "-\t\t\t\t// First add the tag", "-\t\t\t\twriteU1(MethodRefTag);", "-\t\t\t\t// Then write the class index", "-\t\t\t\twriteU2(classIndex);", "-\t\t\t\t// The write the nameAndType index", "-\t\t\t\twriteU2(nameAndTypeIndex);", "-\t\t\t}", "-\t\t}", "+\t\t// Write the interface method ref constant into the constant pool", "+\t\t// First add the tag", "+\t\twriteU1(aMethodBinding.constantPoolDeclaringClass().isInterface() ? InterfaceMethodRefTag : MethodRefTag);", "+\t\t// Then write the class index", "+\t\twriteU2(classIndex);", "+\t\t// The write the nameAndType index", "+\t\twriteU2(nameAndTypeIndex);"]}], "num": 21221}