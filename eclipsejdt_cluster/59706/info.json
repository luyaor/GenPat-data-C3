{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "0cb4eeea442b2d6ed108a03f88e72644", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "61fffb386ea1e7265d3f9b42057b78ca", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java", "commitBeforeChange": "7d377efa996fb82a3b5c1b0d3643171f071fe458", "commitAfterChange": "5725587b7e076e798174c1de3afdd9fd81ea2803", "methodNumberBeforeChange": 58, "methodNumberAfterChange": 58, "signatureBeforeChange": " public final char[] signature(ClassFile classFile)", "signatureAfterChange": " public final char[] signature(ClassFile classFile)", "diff": ["-\t\tif ((this.tagBits & TagBits.ContainsNestedTypesInSignature) != 0) {", "+\t\tif ((this.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "-\t\t\t\t\t\tif (syntheticArgumentType.isNestedType()) {", "-\t\t\t\t\t\t\tclassFile.recordInnerClasses(syntheticArgumentType);", "+\t\t\t\t\t\tif ((syntheticArgumentType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\t\t\t\tUtil.recordNestedType(classFile, syntheticArgumentType);", "-\t\t\t\tfor (int i = 0; i < targetParameters.length; i++) {", "+\t\t\t\tfor (int i = 0, max = targetParameters.length; i < max; i++) {", "-\t\t\t\t\tif (leafTargetParameterType.isNestedType()) {", "-\t\t\t\t\t\tclassFile.recordInnerClasses(leafTargetParameterType);", "+\t\t\t\t\tif ((leafTargetParameterType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\t\t\tUtil.recordNestedType(classFile, leafTargetParameterType);", "-\t\t\t\t\tif (leafParameterType.isNestedType()) {", "-\t\t\t\t\t\tclassFile.recordInnerClasses(leafParameterType);", "+\t\t\t\t\tif ((leafParameterType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\t\t\tUtil.recordNestedType(classFile, leafParameterType);", "-\t\t\t\tif (ret.isNestedType()) {", "-\t\t\t\t\tclassFile.recordInnerClasses(ret);", "+\t\t\t\tif ((ret.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\t\tUtil.recordNestedType(classFile, ret);", "-\t\t\t\tif (syntheticArgumentType.isNestedType()) {", "-\t\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypesInSignature;", "-\t\t\t\t\tclassFile.recordInnerClasses(syntheticArgumentType);", "+\t\t\t\tif ((syntheticArgumentType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypeReferences;", "+\t\t\t\t\tUtil.recordNestedType(classFile, syntheticArgumentType);", "-\t\tfor (int i = 0; i < targetParameters.length; i++) {", "+\t\tfor (int i = 0, max = targetParameters.length; i < max; i++) {", "-\t\t\tif (leafTargetParameterType.isNestedType()) {", "-\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypesInSignature;", "-\t\t\t\tclassFile.recordInnerClasses(leafTargetParameterType);", "+\t\t\tif ((leafTargetParameterType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypeReferences;", "+\t\t\t\tUtil.recordNestedType(classFile, leafTargetParameterType);", "-\t\t\tif (leafParameterType.isNestedType()) {", "-\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypesInSignature;", "-\t\t\t\tclassFile.recordInnerClasses(leafParameterType);", "+\t\t\tif ((leafParameterType.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\t\tthis.tagBits |= TagBits.ContainsNestedTypeReferences;", "+\t\t\t\tUtil.recordNestedType(classFile, leafParameterType);", "-\t\tif (ret.isNestedType()) {", "-\t\t\tthis.tagBits |= TagBits.ContainsNestedTypesInSignature;", "-\t\t\tclassFile.recordInnerClasses(ret);", "+\t\tif ((ret.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {", "+\t\t\tthis.tagBits |= TagBits.ContainsNestedTypeReferences;", "+\t\t\tUtil.recordNestedType(classFile, ret);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "90249b33f853288df139e013dc925c1d", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "c738f8a2f8c38edb037b1844278da54dc7b0f406", "commitAfterChange": "2ceff175173889ef3caa9cfcd05ec98c46b15cac", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " public IMethod createMethodHandle(AbstractMethodDeclaration method, IType type)", "signatureAfterChange": " public IMethod createMethodHandle(AbstractMethodDeclaration method, IType type)", "diff": ["-\tint length = arguments == null ? 0 : arguments.length;", "+\tint argCount = arguments == null ? 0 : arguments.length;", "-\t\tIBinaryMethod[] methods = reader.getMethods();", "+\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\t\tfor (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "+\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\t\tString[] parameterTypes = Signature.getParameterTypes(new String(binaryMethod.getMethodDescriptor()));", "-\t\t\t\t\tif (length != parameterTypes.length) continue;", "-\t\t\t\t\tboolean sameParameters = true;", "-\t\t\t\t\tfor (int j = 0; j < length; j++) {", "-\t\t\t\t\t\tTypeReference parameterType = arguments[j].type;", "-\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "-\t\t\t\t\t\tfor (int k = 0; k < parameterType.dimensions(); k++)", "-\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "-\t\t\t\t\t\tString parameterTypeName = parameterTypes[j].replace('/', '.');", "-\t\t\t\t\t\tif (!Signature.toString(parameterTypeName).endsWith(new String(typeName))) {", "-\t\t\t\t\t\t\tsameParameters = false;", "-\t\t\t\t\t\t\tbreak;", "-\t\t\t\t\t\t} else {", "-\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "-\t\t\t\t\t\t}", "+\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "+\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "+\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "+\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "+\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "+\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "+\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "-\t\t\t\t\tif (sameParameters)", "-\t\t\t\t\t\treturn type.getMethod(new String(selector), parameterTypes);", "+\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\tString[] parameterTypeSignatures = new String[length];", "-\tfor (int i = 0; i < length; i++) {", "-\t\tTypeReference parameterType = arguments[i].type;", "-\t\tchar[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');", "-\t\tfor (int j = 0; j < parameterType.dimensions(); j++)", "-\t\t\ttypeName = CharOperation.concat(typeName, \"[]\" .toCharArray()); //$NON-NLS-1$", "+\tString[] parameterTypeSignatures = new String[argCount];", "+\tfor (int i = 0; i < argCount; i++) {", "+\t\tTypeReference typeRef = arguments[i].type;", "+\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\tfor (int j = 0, dim = typeRef.dimensions(); j < dim; j++)", "+\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "9ff8b845d390560a9d4f3996c0181efa", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java", "commitBeforeChange": "e657b912c1ef94d48e9749f2cbf91c83fff8728f", "commitAfterChange": "a34df737b5102c35af6a4e4a81e1b17f0f972c06", "methodNumberBeforeChange": 14, "methodNumberAfterChange": 14, "signatureBeforeChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "signatureAfterChange": " protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent)", "diff": ["+\t\t// fall thru if its a constructor with a synthetic argument... find it the slower way", "-\t\tif (reader == null) return null;", "-", "-\t\tIBinaryMethod[] methods = reader.getMethods();", "-\t\tif (methods != null) {", "-\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "-\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "-\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "-\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "-\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "-\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "-\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "-\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "-\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "-\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "-\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "-\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "-\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "-\t\t\t\t\t\t\tcontinue nextMethod;", "-\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\tif (reader != null) {", "+\t\t\tIBinaryMethod[] methods = reader.getMethods();", "+\t\t\tif (methods != null) {", "+\t\t\t\tnextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {", "+\t\t\t\t\tIBinaryMethod binaryMethod = methods[i];", "+\t\t\t\t\tchar[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();", "+\t\t\t\t\tif (CharOperation.equals(selector, method.selector)) {", "+\t\t\t\t\t\tchar[][] parameterTypes = Signature.getParameterTypes(binaryMethod.getMethodDescriptor());", "+\t\t\t\t\t\tif (argCount != parameterTypes.length) continue nextMethod;", "+\t\t\t\t\t\tfor (int j = 0; j < argCount; j++) {", "+\t\t\t\t\t\t\tTypeReference typeRef = arguments[j].type;", "+\t\t\t\t\t\t\tchar[] typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');", "+\t\t\t\t\t\t\tfor (int k = 0, dim = typeRef.dimensions(); k < dim; k++)", "+\t\t\t\t\t\t\t\ttypeName = CharOperation.concat(typeName, new char[] {'[', ']'});", "+\t\t\t\t\t\t\tchar[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);", "+\t\t\t\t\t\t\tif (!CharOperation.endsWith(Signature.toCharArray(parameterTypeName), typeName))", "+\t\t\t\t\t\t\t\tcontinue nextMethod;", "+\t\t\t\t\t\t\tparameterTypes[j] = parameterTypeName;", "+\t\t\t\t\t\t}", "+\t\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\t\t\t\treturn type.getMethod(new String(selector), CharOperation.toStrings(parameterTypes));", "-\t\treturn null;", "-\treturn type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tIMethod handle = type.getMethod(new String(method.selector), parameterTypeSignatures);", "+\tif (type.isBinary() && !handle.exists()) return null; // element doesn't exist in the .class file", "+\treturn handle;"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c6f657382968ec30c05d517fa1401ff1", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java", "commitBeforeChange": "3b34d278ba258a10a58d188a2047da908229b941", "commitAfterChange": "6104682417d6806d1d8ccbb82820f9e6e9f650ff", "methodNumberBeforeChange": 13, "methodNumberAfterChange": 13, "signatureBeforeChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope blockScope)", "diff": ["-\t\tint length = this.arguments == null ? 0 : this.arguments.length;", "+\t\tint argumentsLength = this.arguments == null ? 0 : this.arguments.length;", "-\t\t\t\tfor (int i = 0; i < length; i++)", "+\t\t\t\tfor (int i = 0; i < argumentsLength; i++)", "-\t\tsuper.resolveType(blockScope); // compute & capture interface function descriptor in singleAbstractMethod.", "+\t\tsuper.resolveType(blockScope); // compute & capture interface function descriptor.", "-\t\t\tint descriptorParameterCount = this.descriptor.parameters.length;", "-\t\t\tint lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;", "-            if (descriptorParameterCount != lambdaArgumentCount) {", "+\t\t\tint parametersLength = this.descriptor.parameters.length;", "+\t\t\tif (parametersLength != argumentsLength) {", "-\t\tTypeBinding[] newParameters = new TypeBinding[length];", "+\t\tTypeBinding[] newParameters = new TypeBinding[argumentsLength];", "-\t\tfor (int i = 0; i < length; i++) {", "+\t\tfor (int i = 0; i < argumentsLength; i++) {", "-\t\t\t\tif (i == length - 1) {", "+\t\t\t\tif (i == argumentsLength - 1) {", "-\t\t\tTypeBinding parameterType;", "+\t\t\tTypeBinding argumentType;", "-\t\t\tparameterType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];", "-\t\t\tif (parameterType == null) {", "+\t\t\targumentType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];", "+\t\t\tif (argumentType == null) {", "-\t\t\t} else if (parameterType == TypeBinding.VOID) {", "+\t\t\t} else if (argumentType == TypeBinding.VOID) {", "-\t\t\t\tif (!parameterType.isValidBinding()) {", "+\t\t\t\tif (!argumentType.isValidBinding()) {", "-\t\t\t\tif ((parameterType.tagBits & TagBits.HasMissingType) != 0) {", "+\t\t\t\tif ((argumentType.tagBits & TagBits.HasMissingType) != 0) {", "-\t\tfor (int i = 0; i < length; i++) {", "+\t\tfor (int i = 0; i < argumentsLength; i++) {", "-\t\t\tTypeBinding parameterType;", "+\t\t\tTypeBinding argumentType;", "-\t\t\tparameterType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];", "-\t\t\tif (parameterType != null && parameterType != TypeBinding.VOID) {", "-\t\t\t\tif (haveDescriptor && expectedParameterType != null && parameterType.isValidBinding() && TypeBinding.notEquals(parameterType, expectedParameterType)) {", "+\t\t\targumentType = argumentsTypeElided ? expectedParameterType : this.argumentTypes[i];", "+\t\t\tif (argumentType != null && argumentType != TypeBinding.VOID) {", "+\t\t\t\tif (haveDescriptor && expectedParameterType != null && argumentType.isValidBinding() && TypeBinding.notEquals(argumentType, expectedParameterType)) {", "-\t\t\t\t\tTypeBinding leafType = parameterType.leafComponentType();", "+\t\t\t\t\tTypeBinding leafType = argumentType.leafComponentType();", "-\t\t\t\tnewParameters[i] = argument.bind(this.scope, parameterType, false);\t\t\t\t", "+\t\t\t\tnewParameters[i] = argument.bind(this.scope, argumentType, false);\t\t\t\t", "-\t\t\t\t\t\tparameterAnnotations = new AnnotationBinding[length][];", "+\t\t\t\t\t\tparameterAnnotations = new AnnotationBinding[argumentsLength][];", "-\t\tlength = exceptions.length;", "-\t\tfor (int i = 0; i < length; i++) {", "+\t\tint exceptionsLength = exceptions.length;", "+\t\tfor (int i = 0; i < exceptionsLength; i++) {"]}], "num": 59706}