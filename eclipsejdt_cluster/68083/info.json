{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "7c46edcecd2e63d5d735a75e99a143ba", "detectedBy": ["AST_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "16fd04fee243aa14bf9097c54d10526f", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/DefaultProblem.java", "commitBeforeChange": "4c8a3ba34c720dda98e8d56ba71f0361efbe740b", "commitAfterChange": "c06cfa4791f8eb98381a7dd55dd6950dbcddf37c", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": "  public String errorReportSource(char[] unitSource)", "signatureAfterChange": "  public String errorReportSource(char[] unitSource)", "diff": ["-\treturn errorReportSource(unitSource, 0);", "-}", "+\terrorBuffer.append(' ').append(Messages.bind(Messages.problem_atLine, String.valueOf(this.line))); ", "+\terrorBuffer.append(Util.LINE_SEPARATOR);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "25ba2cf50d7b76bf9dde807431dddd7e", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java", "commitBeforeChange": "f797a4fefd78f3a1e278248a5427c284f913a1e4", "commitAfterChange": "aa4e1bcbd015d2517f92b0ecb8f5e5cc59766723", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": "\r \tITypeBinding resolveType(Type type)", "signatureAfterChange": "\r \tITypeBinding resolveType(Type type)", "diff": ["-\t\tAstNode node = (AstNode) this.newAstToOldAst.get(type);\r", "+\t\tint index = 0;\r", "+\t\tASTNode parentType = type.getParent();\r", "+\t\tType arrayType = null;\r", "+\t\twhile ((parentType instanceof Type) && ((Type) parentType).isArrayType()) {\r", "+\t\t\tarrayType = (Type) parentType;\r", "+\t\t\tparentType = parentType.getParent();\r", "+\t\t\tindex++;\r", "+\t\t}\r", "+\t\tAstNode node = null;\r", "+\t\tif (index != 0) {\r", "+\t\t\tnode = (AstNode) this.newAstToOldAst.get(arrayType);\r", "+\t\t} else {\r", "+\t\t\tnode = (AstNode) this.newAstToOldAst.get(type);\r", "+\t\t}\r", "-\t\t\t\treturn this.getTypeBinding(typeReference.binding);\r", "+\t\t\t\tITypeBinding typeBinding = this.getTypeBinding(typeReference.binding);\r", "+\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)typeReference.binding;\r", "+\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t}\r", "+\t\t\t\t} else {\r", "+\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t}\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "+\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)singleNameReference.binding);\r", "+\t\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)singleNameReference.binding;\r", "+\t\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t\t}\r", "-\t\t\t\t\treturn this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "+\t\t\t\t\tITypeBinding typeBinding = this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);\r", "+\t\t\t\t\tif (index != 0) {\r", "+\t\t\t\t\t\tif (typeBinding.isArray()) {\r", "+\t\t\t\t\t\t\tArrayBinding arrayBinding = (ArrayBinding)qualifiedNameReference.binding;\r", "+\t\t\t\t\t\t\tif (index == arrayBinding.dimensions) {\r", "+\t\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding.leafComponentType);\r", "+\t\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\t\tfor (int i = 0; i < index; i++) {\r", "+\t\t\t\t\t\t\t\t\tarrayBinding = (ArrayBinding) arrayBinding.elementsType(this.scope);\r", "+\t\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\t}\r", "+\t\t\t\t\t\t\treturn this.getTypeBinding(arrayBinding);\r", "+\t\t\t\t\t\t} else {\r", "+\t\t\t\t\t\t\treturn null;\r", "+\t\t\t\t\t\t}\r", "+\t\t\t\t\t} else {\r", "+\t\t\t\t\t\treturn typeBinding;\r", "+\t\t\t\t\t}\r"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "355003a257ad0c919f3b5331716f5397", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java", "commitBeforeChange": "030558e3600e0a604bc6dac35a883b52ac0c5446", "commitAfterChange": "20a2fc3a8fdc6d3e237f88ae81c19fcd38d96cb4", "methodNumberBeforeChange": 4, "methodNumberAfterChange": 4, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " public TypeBinding resolveType(BlockScope scope)", "diff": ["+\tcheckParameterizedAllocation: {", "+\t\tif (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()", "+\t\t\tReferenceBinding currentType = (ReferenceBinding)this.resolvedType;", "+\t\t\tif (currentType == null) return currentType;", "+\t\t\tdo {", "+\t\t\t\t// isStatic() is answering true for toplevel types", "+\t\t\t\tif ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;", "+\t\t\t\tif (currentType.isRawType()) break checkParameterizedAllocation;", "+\t\t\t} while ((currentType = currentType.enclosingType())!= null);", "+\t\t\tParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;", "+\t\t\tfor (int i = qRef.typeArguments.length - 2; i >= 0; i--) {", "+\t\t\t\tif (qRef.typeArguments[i] != null) {", "+\t\t\t\t\tscope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);", "+\t\t\t\t\tbreak;", "+\t\t\t\t}", "+\t\t\t}", "+\t\t}", "+\t}", "+", "+\t// resolve type arguments (for generic constructor call)", "+\tif (this.typeArguments != null) {", "+\t\tint length = this.typeArguments.length;", "+\t\tboolean argHasError = scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_5;", "+\t\tthis.genericTypeArguments = new TypeBinding[length];", "+\t\tfor (int i = 0; i < length; i++) {", "+\t\t\tTypeReference typeReference = this.typeArguments[i];", "+\t\t\tif ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {", "+\t\t\t\targHasError = true;", "+\t\t\t}", "+\t\t\tif (argHasError && typeReference instanceof Wildcard) {", "+\t\t\t\tscope.problemReporter().illegalUsageOfWildcard(typeReference);", "+\t\t\t}", "+\t\t}", "+\t\tif (argHasError) {", "+\t\t\tif (this.arguments != null) { // still attempt to resolve arguments", "+\t\t\t\tfor (int i = 0, max = this.arguments.length; i < max; i++) {", "+\t\t\t\t\tthis.arguments[i].resolveType(scope);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn null;", "+\t\t}", "+\t}", "-\t\t    TypeBinding parameterType = this.binding.parameters[i];", "-\t\t    TypeBinding argumentType = argumentTypes[i];", "+\t\t\tTypeBinding parameterType = this.binding.parameters[i];", "+\t\t\tTypeBinding argumentType = argumentTypes[i];", "-\t    scope.problemReporter().unsafeRawInvocation(this, this.binding);", "+\t\tscope.problemReporter().unsafeRawInvocation(this, this.binding);", "+\t}", "+\tif (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {", "+\t\tscope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "c0f712a8b7e9a8da38532f8c144c0547", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodPattern.java", "commitBeforeChange": "9037a5669c89fc0ae3f8548a99dce6fa5402fb31", "commitAfterChange": "e4e1e1935f0e7607d1265df332c7ce922de89c18", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 9, "signatureBeforeChange": " public abstract String getPatternName();", "signatureAfterChange": " public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo)", "diff": ["-}", "-public abstract String getPatternName();", "+ */", "+public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo) {", "+\tif (!this.findDeclarations) return false; // only relevant when finding declarations", "+\tif (!(binaryInfo instanceof IBinaryMethod)) return false;", "+", "+\tIBinaryMethod method = (IBinaryMethod) binaryInfo;", "+\tif (!matchesName(this.selector, method.getSelector())) return false;", "+", "+\t// declaring type", "+\tif (enclosingBinaryInfo != null && (this.declaringSimpleName != null || this.declaringQualification != null)) {", "+\t\tIBinaryType declaringType = (IBinaryType) enclosingBinaryInfo;", "+\t\tchar[] declaringTypeName = (char[]) declaringType.getName().clone();", "+\t\tCharOperation.replace(declaringTypeName, '/', '.');", "+\t\tif (!matchesType(this.declaringSimpleName, this.declaringQualification, declaringTypeName))", "+\t\t\treturn false;", "+\t}", "+", "+\t// parameter types", "+\tboolean checkReturnType = this.declaringSimpleName == null && (this.returnSimpleName != null || this.returnQualification != null);", "+\tint parameterCount = this.parameterSimpleNames == null ? -1 : this.parameterSimpleNames.length;", "+\tif (checkReturnType || parameterCount > -1) {", "+\t\tString methodDescriptor = new String(method.getMethodDescriptor()).replace('/', '.');", "+", "+\t\t// look at return type only if declaring type is not specified", "+\t\tif (checkReturnType) {", "+\t\t\tString returnTypeSignature = Signature.toString(Signature.getReturnType(methodDescriptor));", "+\t\t\tif (!matchesType(this.returnSimpleName, this.returnQualification, returnTypeSignature.toCharArray()))", "+\t\t\t\treturn false;", "+\t\t}", "+", "+\t\tif (parameterCount > -1) {", "+\t\t\tString[] arguments = Signature.getParameterTypes(methodDescriptor);", "+\t\t\tif (parameterCount != arguments.length) return false;", "+\t\t\tfor (int i = 0; i < parameterCount; i++)", "+\t\t\t\tif (!matchesType(this.parameterSimpleNames[i], this.parameterQualifications[i], Signature.toString(arguments[i]).toCharArray()))", "+\t\t\t\t\treturn false;", "+\t\t}"]}], "num": 68083}