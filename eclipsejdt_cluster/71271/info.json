{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "f9d0da4b918ee770e03bf1f62a32a30a", "detectedBy": ["DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "84ab1bbff6bfb5f0d58cad7e6300ebce", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java", "commitBeforeChange": "2e4e63b9ed8aad7925bed1f9109d7e2d1a341f45", "commitAfterChange": "6f2d59d80da8490e52a278944b98c97220ac4149", "methodNumberBeforeChange": 25, "methodNumberAfterChange": 25, "signatureBeforeChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "signatureAfterChange": "  static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod, LookupEnvironment environment)", "diff": ["-\t\tTypeBinding argument = arguments[i];", "-\t\tif (argument instanceof TypeVariableBinding) {", "-\t\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) argument;", "-\t\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "-\t\t\t\tif (typeVariable.firstBound == null)", "-\t\t\t\t\tcontinue; // both are null", "-\t\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "-\t\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\tTypeVariableBinding typeVariable = (TypeVariableBinding) arguments[i]; // cast is safe by construction: arguments is copied from TypeVariableBinding[]", "+\t\tif (typeVariable.firstBound == inheritedTypeVariable.firstBound) {", "+\t\t\tif (typeVariable.firstBound == null)", "+\t\t\t\tcontinue; // both are null", "+\t\t} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {", "+\t\t\tif (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())", "-\t\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "-\t\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "-\t\t\tif (interfaceLength != interfaces.length)", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "-\t\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "-\t\t\t\tfor (int k = 0; k < interfaceLength; k++)", "-\t\t\t\t\tif (superType == interfaces[k])", "-\t\t\t\t\t\tcontinue next;", "-\t\t\t\treturn inheritedMethod; // not a match", "-\t\t\t}", "-\t\t} else if (inheritedTypeVariable.boundCheck(substitute, argument, null) != TypeConstants.OK) {", "-\t    \treturn inheritedMethod;", "+\t\t}", "+\t\tif (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tint interfaceLength = inheritedTypeVariable.superInterfaces.length;", "+\t\tReferenceBinding[] interfaces = typeVariable.superInterfaces;", "+\t\tif (interfaceLength != interfaces.length)", "+\t\t\treturn inheritedMethod; // not a match", "+\t\tnext : for (int j = 0; j < interfaceLength; j++) {", "+\t\t\tTypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);", "+\t\t\tfor (int k = 0; k < interfaceLength; k++)", "+\t\t\t\tif (superType == interfaces[k])", "+\t\t\t\t\tcontinue next;", "+\t\t\treturn inheritedMethod; // not a match"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "a101c74d0eb5c70367343dd33e5d6e19", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java", "commitBeforeChange": "fce949b99d272770d0ef99d0fd14291b59c28cff", "commitAfterChange": "bec584357dd9f5416d76c043f6bc97254c43e356", "methodNumberBeforeChange": 1, "methodNumberAfterChange": 1, "signatureBeforeChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "signatureAfterChange": " \t \tpublic Object reduce(InferenceContext18 inferenceContext)", "diff": ["+\t\t", "+\t\t/* If throw specification does not encode any type parameters, there are no constraints to be gleaned/gathered from the throw sites.", "+\t\t   See also that thrown exceptions are not allowed to influence compatibility and overload resolution.", "+\t\t*/", "+\t\tif (n == 0)", "+\t\t\treturn TRUE;", "+\t\t", "-\t\t\treturn TRUE; // TODO is it a bug if we actually get here?", "-\t\tint m = ePrime.length;", "-\t\tif (n == 0) {", "-\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\tif (ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\tcontinue actual;", "-\t\t\t\treturn FALSE;", "-\t\t\t}", "-\t\t} else {", "-\t\t\tList<ConstraintFormula> result = new ArrayList<ConstraintFormula>();", "-\t\t\tactual: for (int i = 0; i < m; i++) {", "-\t\t\t\tfor (int j = 0; j < thrown.length; j++)", "-\t\t\t\t\tif (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))", "-\t\t\t\t\t\tcontinue actual;", "-\t\t\t\tfor (int j = 0; j < n; j++)", "-\t\t\t\t\tresult.add(ConstraintTypeFormula.create(ePrime[i], e[j], SUBTYPE));", "-\t\t\t}\t\t\t\t", "+\t\tint m = ePrime.length;", "+\t\tList<ConstraintFormula> result = new ArrayList<ConstraintFormula>();", "+\t\tactual: for (int i = 0; i < m; i++) {", "+\t\t\tif (ePrime[i].isUncheckedException(false))", "+\t\t\t\tcontinue;", "+\t\t\tfor (int j = 0; j < thrown.length; j++)", "+\t\t\t\tif (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))", "+\t\t\t\t\tcontinue actual;", "-\t\t\t\tinferenceContext.currentBounds.inThrows.add(e[j]);", "-\t\t\treturn result.toArray(new ConstraintFormula[result.size()]);", "-\t\t}", "+\t\t\t\tresult.add(ConstraintTypeFormula.create(ePrime[i], e[j], SUBTYPE));", "+\t\t}\t\t\t\t", "+\t\tfor (int j = 0; j < n; j++)", "+\t\t\tinferenceContext.currentBounds.inThrows.add(e[j]);", "+\t\treturn result.toArray(new ConstraintFormula[result.size()]);"]}], "num": 71271}