{"@class": "de.fau.cs.inf2.cthree.data.Cluster", "id": "688e18855dc5cffe786a8ce6867fe9a3", "detectedBy": ["DIFF_HIERARCHICAL", "DIFF_DBSCAN"], "members": [{"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "04998c67b60555da7259a498a4d4f4c8", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java", "commitBeforeChange": "442cfec5b0ec5f78f613dac66413d02e26889f22", "commitAfterChange": "d42d74dc89c043581d93318957eb6b633b137649", "methodNumberBeforeChange": 9, "methodNumberAfterChange": 8, "signatureBeforeChange": " public TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \tpublic TypeBinding resolveType(BlockScope scope)", "diff": ["-}", "-public TypeBinding resolveType(BlockScope scope) {", "-", "-\t\tboolean leftIsCast, rightIsCast;", "-\t\tif ((leftIsCast = left instanceof CastExpression) == true) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\tTypeBinding leftType = left.resolveType(scope);", "-", "-\t\tif ((rightIsCast = right instanceof CastExpression) == true) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "-\t\tTypeBinding rightType = right.resolveType(scope);", "-", "-\t// always return BooleanBinding", "-\tif (leftType == null || rightType == null){", "-\t\tconstant = NotAConstant;\t\t", "-\t\treturn null;", "-\t}", "-", "-\t// both base type", "-\tif (leftType.isBaseType() && rightType.isBaseType()) {", "-\t\t// the code is an int", "-\t\t// (cast)  left   == (cast)  right --> result", "-\t\t//  0000   0000       0000   0000      0000", "-\t\t//  <<16   <<12       <<8    <<4       <<0", "-\t\tint operatorSignature = OperatorSignatures[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];", "-\t\tleft.implicitConversion = operatorSignature >>> 12;", "-\t\tright.implicitConversion = (operatorSignature >>> 4) & 0x000FF;", "-\t\tbits |= operatorSignature & 0xF;\t\t", "-\t\tif ((operatorSignature & 0x0000F) == T_undefined) {", "-\t\t\tconstant = Constant.NotAConstant;", "-\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\tpublic TypeBinding resolveType(BlockScope scope) {", "+\t", "+\t\t\tboolean leftIsCast, rightIsCast;", "+\t\t\tif ((leftIsCast = left instanceof CastExpression) == true) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\tTypeBinding leftType = left.resolveType(scope);", "+\t", "+\t\t\tif ((rightIsCast = right instanceof CastExpression) == true) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on", "+\t\t\tTypeBinding rightType = right.resolveType(scope);", "+\t", "+\t\t// always return BooleanBinding", "+\t\tif (leftType == null || rightType == null){", "+\t\t\tconstant = NotAConstant;\t\t", "-\t\t// check need for operand cast", "-\t\tif (leftIsCast || rightIsCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, EQUAL_EQUAL, operatorSignature, left, leftType.id, leftIsCast, right, rightType.id, rightIsCast);", "-\t\t}", "-\t\tcomputeConstant(leftType, rightType);", "-\t\treturn this.resolvedType = BooleanBinding;", "-\t}", "-", "-\t// Object references ", "-\t// spec 15.20.3", "-\tif (areTypesCastCompatible(scope, rightType, leftType) || areTypesCastCompatible(scope, leftType, rightType)) {", "-\t\t// (special case for String)", "-\t\tif ((rightType.id == T_String) && (leftType.id == T_String)) {", "-\t\t\tcomputeConstant(leftType, rightType);", "-\t\t} else {", "-\t\t\tconstant = NotAConstant;", "-\t\t}", "-\t\tif (rightType.id == T_String) {", "-\t\t\tright.implicitConversion = String2String;", "-\t\t}", "-\t\tif (leftType.id == T_String) {", "-\t\t\tleft.implicitConversion = String2String;", "-\t\t}", "-\t\t// check need for operand cast", "-\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "-\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "-\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "-\t\t\tTypeBinding alternateLeftType = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType : leftType;", "-\t\t\tTypeBinding alternateRightType = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType : rightType;", "-\t\t\tif (areTypesCastCompatible(scope, alternateLeftType, alternateRightType)", "-\t\t\t\t\t|| areTypesCastCompatible(scope, alternateRightType, alternateLeftType)) {", "-\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "-\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "+\t", "+\t\t// both base type", "+\t\tif (leftType.isBaseType() && rightType.isBaseType()) {", "+\t\t\t// the code is an int", "+\t\t\t// (cast)  left   == (cast)  right --> result", "+\t\t\t//  0000   0000       0000   0000      0000", "+\t\t\t//  <<16   <<12       <<8    <<4       <<0", "+\t\t\tint operatorSignature = OperatorSignatures[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];", "+\t\t\tleft.implicitConversion = operatorSignature >>> 12;", "+\t\t\tright.implicitConversion = (operatorSignature >>> 4) & 0x000FF;", "+\t\t\tbits |= operatorSignature & 0xF;\t\t", "+\t\t\tif ((operatorSignature & 0x0000F) == T_undefined) {", "+\t\t\t\tconstant = Constant.NotAConstant;", "+\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\t\t\t\treturn null;", "+\t\t\t// check need for operand cast", "+\t\t\tif (leftIsCast || rightIsCast) {", "+\t\t\t\tCastExpression.checkNeedForArgumentCasts(scope, EQUAL_EQUAL, operatorSignature, left, leftType.id, leftIsCast, right, rightType.id, rightIsCast);", "+\t\t\t}", "+\t\t\tcomputeConstant(leftType, rightType);", "+\t\t\treturn this.resolvedType = BooleanBinding;", "-\t\treturn this.resolvedType = BooleanBinding;", "+\t", "+\t\t// Object references ", "+\t\t// spec 15.20.3", "+\t\tif (this.checkCastTypesCompatibility(scope, leftType, rightType, null) ", "+\t\t\t\t|| this.checkCastTypesCompatibility(scope, rightType, leftType, null)) {", "+", "+\t\t\t// (special case for String)", "+\t\t\tif ((rightType.id == T_String) && (leftType.id == T_String)) {", "+\t\t\t\tcomputeConstant(leftType, rightType);", "+\t\t\t} else {", "+\t\t\t\tconstant = NotAConstant;", "+\t\t\t}", "+\t\t\tif (rightType.id == T_String) {", "+\t\t\t\tright.implicitConversion = String2String;", "+\t\t\t}", "+\t\t\tif (leftType.id == T_String) {", "+\t\t\t\tleft.implicitConversion = String2String;", "+\t\t\t}", "+\t\t\t// check need for operand cast", "+\t\t\tboolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;", "+\t\t\tboolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;", "+\t\t\tif (unnecessaryLeftCast || unnecessaryRightCast) {", "+\t\t\t\tTypeBinding alternateLeftType = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType : leftType;", "+\t\t\t\tTypeBinding alternateRightType = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType : rightType;", "+\t\t\t\tif (this.checkCastTypesCompatibility(scope, alternateLeftType, alternateRightType, null) ", "+\t\t\t\t\t\t|| this.checkCastTypesCompatibility(scope, alternateRightType, alternateLeftType, null)) {", "+\t\t\t\t\tif (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); ", "+\t\t\t\t\tif (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);", "+\t\t\t\t}", "+\t\t\t}", "+\t\t\treturn this.resolvedType = BooleanBinding;", "+\t\t}", "+\t\tconstant = NotAConstant;", "+\t\tscope.problemReporter().notCompatibleTypesError(this, leftType, rightType);", "+\t\treturn null;", "-\tconstant = NotAConstant;", "-\tscope.problemReporter().notCompatibleTypesError(this, leftType, rightType);", "-\treturn null;", "-}"]}, {"@class": "de.fau.cs.inf2.cthree.data.CodeChange", "id": "13fb639f51c0200b50d0b5df9a15f8e4", "repository": "http://git.eclipse.org/gitroot/jdt/eclipse.jdt.core.git", "fileName": "org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java", "commitBeforeChange": "3a7eebe0921eeefbdbf1fe4891891b6335310197", "commitAfterChange": "e8aa72d0e85424c76c1185b7518db6803dde6255", "methodNumberBeforeChange": 21, "methodNumberAfterChange": 21, "signatureBeforeChange": " \t\t \tpublic TypeBinding resolveType(BlockScope scope)", "signatureAfterChange": " \t public TypeBinding resolveType(BlockScope scope)", "diff": ["+\t", "+public TypeBinding resolveType(BlockScope scope) {", "+\tboolean leftIsCast, rightIsCast;", "+\tif ((leftIsCast = this.left instanceof CastExpression) == true) this.left.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding leftType = this.left.resolveType(scope);", "+", "+\tif ((rightIsCast = this.right instanceof CastExpression) == true) this.right.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on", "+\tTypeBinding rightType = this.right.resolveType(scope);", "+", "+\t// use the id of the type to navigate into the table", "+\tif (leftType == null || rightType == null) {", "+\t\tthis.constant = Constant.NotAConstant;", "+\t\treturn null;", "+\t}", "+", "+\tint leftTypeID = leftType.id;", "+\tint rightTypeID = rightType.id;", "+", "+\t// autoboxing support", "+\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "+\tif (use15specifics) {", "+\t\tif (!leftType.isBaseType() && rightTypeID != TypeIds.T_JavaLangString && rightTypeID != TypeIds.T_null) {", "+\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "+\t\t}", "+\t\tif (!rightType.isBaseType() && leftTypeID != TypeIds.T_JavaLangString && leftTypeID != TypeIds.T_null) {", "+\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "-\t\t", "-\tpublic TypeBinding resolveType(BlockScope scope) {", "-", "-\t\tboolean leftIsCast, rightIsCast;", "-\t\tif ((leftIsCast = left instanceof CastExpression) == true) left.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding leftType = left.resolveType(scope);", "-", "-\t\tif ((rightIsCast = right instanceof CastExpression) == true) right.bits |= DisableUnnecessaryCastCheck; // will check later on", "-\t\tTypeBinding rightType = right.resolveType(scope);", "-", "-\t\t// use the id of the type to navigate into the table", "-\t\tif (leftType == null || rightType == null) {", "-\t\t\tconstant = Constant.NotAConstant;", "+\tif (leftTypeID > 15", "+\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\trightTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else if (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tleftTypeID = TypeIds.T_JavaLangObject;", "+\t\t} else {", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-", "-\t\tint leftTypeID = leftType.id;", "-\t\tint rightTypeID = rightType.id;", "-", "-\t\t// autoboxing support", "-\t\tboolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;", "-\t\tif (use15specifics) {", "-\t\t\tif (!leftType.isBaseType() && rightTypeID != T_JavaLangString && rightTypeID != T_null) {", "-\t\t\t\tleftTypeID = scope.environment().computeBoxingType(leftType).id;", "-\t\t\t}", "-\t\t\tif (!rightType.isBaseType() && leftTypeID != T_JavaLangString && leftTypeID != T_null) {", "-\t\t\t\trightTypeID = scope.environment().computeBoxingType(rightType).id;", "+\t}", "+\tif (((this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT) == OperatorIds.PLUS) {", "+\t\tif (leftTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "+\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.right);", "-\t\tif (leftTypeID > 15", "-\t\t\t|| rightTypeID > 15) { // must convert String + Object || Object + String", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\trightTypeID = T_JavaLangObject;", "-\t\t\t} else if (rightTypeID == T_JavaLangString) {", "-\t\t\t\tleftTypeID = T_JavaLangObject;", "-\t\t\t} else {", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "+\t\tif (rightTypeID == TypeIds.T_JavaLangString) {", "+\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "+\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "+\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(this.left);", "-\t\tif (((bits & OperatorMASK) >> OperatorSHIFT) == PLUS) {", "-\t\t\tif (leftTypeID == T_JavaLangString) {", "-\t\t\t\tthis.left.computeConversion(scope, leftType, leftType);", "-\t\t\t\tif (rightType.isArrayType() && ((ArrayBinding) rightType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(right);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t\tif (rightTypeID == T_JavaLangString) {", "-\t\t\t\tthis.right.computeConversion(scope, rightType, rightType);", "-\t\t\t\tif (leftType.isArrayType() && ((ArrayBinding) leftType).elementsType() == TypeBinding.CHAR) {", "-\t\t\t\t\tscope.problemReporter().signalNoImplicitStringConversionForCharArrayExpression(left);", "-\t\t\t\t}", "-\t\t\t}", "-\t\t}", "-", "-\t\t// the code is an int", "-\t\t// (cast)  left   Op (cast)  right --> result", "-\t\t//  0000   0000       0000   0000      0000", "-\t\t//  <<16   <<12       <<8    <<4       <<0", "-", "-\t\t// Don't test for result = 0. If it is zero, some more work is done.", "-\t\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "-\t\tint operator = (bits & OperatorMASK) >> OperatorSHIFT;", "-\t\tint operatorSignature = OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "-", "-\t\tleft.computeConversion(\tscope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "-\t\tright.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "-\t\tbits |= operatorSignature & 0xF;", "-\t\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "-\t\t\t// only switch on possible result type.....", "-\t\t\tcase T_boolean :", "-\t\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "-\t\t\t\tbreak;", "-\t\t\tcase T_byte :", "-\t\t\t\tthis.resolvedType = TypeBinding.BYTE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_char :", "-\t\t\t\tthis.resolvedType = TypeBinding.CHAR;", "-\t\t\t\tbreak;", "-\t\t\tcase T_double :", "-\t\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "-\t\t\t\tbreak;", "-\t\t\tcase T_float :", "-\t\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_int :", "-\t\t\t\tthis.resolvedType = TypeBinding.INT;", "-\t\t\t\tbreak;", "-\t\t\tcase T_long :", "-\t\t\t\tthis.resolvedType = TypeBinding.LONG;", "-\t\t\t\tbreak;", "-\t\t\tcase T_JavaLangString :", "-\t\t\t\tthis.resolvedType = scope.getJavaLangString();", "-\t\t\t\tbreak;", "-\t\t\tdefault : //error........", "-\t\t\t\tconstant = Constant.NotAConstant;", "-\t\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "-\t\t\t\treturn null;", "-\t\t}", "-", "-\t\t// check need for operand cast", "-\t\tif (leftIsCast || rightIsCast) {", "-\t\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, left, leftTypeID, leftIsCast, right, rightTypeID, rightIsCast);", "-\t\t}", "-\t\t// compute the constant when valid", "-\t\tcomputeConstant(scope, leftTypeID, rightTypeID);", "-\t\treturn this.resolvedType;", "+\t// the code is an int", "+\t// (cast)  left   Op (cast)  right --> result", "+\t//  0000   0000       0000   0000      0000", "+\t//  <<16   <<12       <<8    <<4       <<0", "+", "+\t// Don't test for result = 0. If it is zero, some more work is done.", "+\t// On the one hand when it is not zero (correct code) we avoid doing the test\t", "+\tint operator = (this.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;", "+\tint operatorSignature = OperatorExpression.OperatorSignatures[operator][(leftTypeID << 4) + rightTypeID];", "+", "+\tthis.left.computeConversion(scope, \tTypeBinding.wellKnownType(scope, (operatorSignature >>> 16) & 0x0000F), leftType);", "+\tthis.right.computeConversion(scope, TypeBinding.wellKnownType(scope, (operatorSignature >>> 8) & 0x0000F), rightType);", "+\tthis.bits |= operatorSignature & 0xF;", "+\tswitch (operatorSignature & 0xF) { // record the current ReturnTypeID", "+\t\t// only switch on possible result type.....", "+\t\tcase T_boolean :", "+\t\t\tthis.resolvedType = TypeBinding.BOOLEAN;", "+\t\t\tbreak;", "+\t\tcase T_byte :", "+\t\t\tthis.resolvedType = TypeBinding.BYTE;", "+\t\t\tbreak;", "+\t\tcase T_char :", "+\t\t\tthis.resolvedType = TypeBinding.CHAR;", "+\t\t\tbreak;", "+\t\tcase T_double :", "+\t\t\tthis.resolvedType = TypeBinding.DOUBLE;", "+\t\t\tbreak;", "+\t\tcase T_float :", "+\t\t\tthis.resolvedType = TypeBinding.FLOAT;", "+\t\t\tbreak;", "+\t\tcase T_int :", "+\t\t\tthis.resolvedType = TypeBinding.INT;", "+\t\t\tbreak;", "+\t\tcase T_long :", "+\t\t\tthis.resolvedType = TypeBinding.LONG;", "+\t\t\tbreak;", "+\t\tcase T_JavaLangString :", "+\t\t\tthis.resolvedType = scope.getJavaLangString();", "+\t\t\tbreak;", "+\t\tdefault : //error........", "+\t\t\tthis.constant = Constant.NotAConstant;", "+\t\t\tscope.problemReporter().invalidOperator(this, leftType, rightType);", "+\t\t\treturn null;", "+", "+\t// check need for operand cast", "+\tif (leftIsCast || rightIsCast) {", "+\t\tCastExpression.checkNeedForArgumentCasts(scope, operator, operatorSignature, this.left, leftTypeID, leftIsCast, this.right, rightTypeID, rightIsCast);", "+\t}", "+\t// compute the constant when valid", "+\tcomputeConstant(scope, leftTypeID, rightTypeID);", "+\treturn this.resolvedType;", "+}"]}], "num": 55513}